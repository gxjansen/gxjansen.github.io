import {getScrollLeft as $ce415dc67314b753$export$1389d168952b34b5} from "./utils.module.js";
import {flushSync as $f9kpT$flushSync} from "react-dom";
import $f9kpT$react, {useRef as $f9kpT$useRef, useState as $f9kpT$useState, useCallback as $f9kpT$useCallback, useEffect as $f9kpT$useEffect} from "react";
import {Rect as $f9kpT$Rect} from "@react-stately/virtualizer";
import {useLayoutEffect as $f9kpT$useLayoutEffect, useResizeObserver as $f9kpT$useResizeObserver} from "@react-aria/utils";
import {useLocale as $f9kpT$useLocale} from "@react-aria/i18n";

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // @ts-ignore






let $44a6ee657928b002$var$isOldReact = (0, $f9kpT$react).version.startsWith('16.') || (0, $f9kpT$react).version.startsWith('17.');
function $44a6ee657928b002$var$ScrollView(props, ref) {
    let { contentSize: contentSize, onVisibleRectChange: onVisibleRectChange, children: children, innerStyle: innerStyle, sizeToFit: sizeToFit, onScrollStart: onScrollStart, onScrollEnd: onScrollEnd, scrollDirection: scrollDirection = 'both', ...otherProps } = props;
    let defaultRef = (0, $f9kpT$useRef)();
    ref = ref || defaultRef;
    let state = (0, $f9kpT$useRef)({
        scrollTop: 0,
        scrollLeft: 0,
        scrollEndTime: 0,
        scrollTimeout: null,
        width: 0,
        height: 0,
        isScrolling: false
    }).current;
    let { direction: direction } = (0, $f9kpT$useLocale)();
    let [isScrolling, setScrolling] = (0, $f9kpT$useState)(false);
    let onScroll = (0, $f9kpT$useCallback)((e)=>{
        if (e.target !== e.currentTarget) return;
        if (props.onScroll) props.onScroll(e);
        (0, $f9kpT$flushSync)(()=>{
            let scrollTop = e.currentTarget.scrollTop;
            let scrollLeft = (0, $ce415dc67314b753$export$1389d168952b34b5)(e.currentTarget, direction);
            // Prevent rubber band scrolling from shaking when scrolling out of bounds
            state.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state.height));
            state.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state.width));
            onVisibleRectChange(new (0, $f9kpT$Rect)(state.scrollLeft, state.scrollTop, state.width, state.height));
            if (!state.isScrolling) {
                state.isScrolling = true;
                setScrolling(true);
                if (onScrollStart) onScrollStart();
            }
            // So we don't constantly call clearTimeout and setTimeout,
            // keep track of the current timeout time and only reschedule
            // the timer when it is getting close.
            let now = Date.now();
            if (state.scrollEndTime <= now + 50) {
                state.scrollEndTime = now + 300;
                clearTimeout(state.scrollTimeout);
                state.scrollTimeout = setTimeout(()=>{
                    state.isScrolling = false;
                    setScrolling(false);
                    state.scrollTimeout = null;
                    if (onScrollEnd) onScrollEnd();
                }, 300);
            }
        });
    }, [
        props,
        direction,
        state,
        contentSize,
        onVisibleRectChange,
        onScrollStart,
        onScrollEnd
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $f9kpT$useEffect)(()=>{
        return ()=>{
            clearTimeout(state.scrollTimeout);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    let updateSize = (0, $f9kpT$useCallback)(()=>{
        let dom = ref.current;
        if (!dom) return;
        let isTestEnv = false;
        let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientWidth');
        let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientHeight');
        let w = isTestEnv && !isClientWidthMocked ? Infinity : dom.clientWidth;
        let h = isTestEnv && !isClientHeightMocked ? Infinity : dom.clientHeight;
        if (sizeToFit && contentSize.width > 0 && contentSize.height > 0) {
            if (sizeToFit === 'width') w = Math.min(w, contentSize.width);
            else if (sizeToFit === 'height') h = Math.min(h, contentSize.height);
        }
        if (state.width !== w || state.height !== h) {
            state.width = w;
            state.height = h;
            onVisibleRectChange(new (0, $f9kpT$Rect)(state.scrollLeft, state.scrollTop, w, h));
        }
    }, [
        onVisibleRectChange,
        ref,
        state,
        sizeToFit,
        contentSize
    ]);
    (0, $f9kpT$useLayoutEffect)(()=>{
        updateSize();
    }, [
        updateSize
    ]);
    let raf = (0, $f9kpT$useRef)();
    let onResize = ()=>{
        var _raf;
        var _current;
        if ($44a6ee657928b002$var$isOldReact) (_current = (_raf = raf).current) !== null && _current !== void 0 ? _current : _raf.current = requestAnimationFrame(()=>{
            updateSize();
            raf.current = null;
        });
        else updateSize();
    };
    (0, $f9kpT$useResizeObserver)({
        ref: ref,
        onResize: onResize
    });
    (0, $f9kpT$useEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, []);
    let style = {
        // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.
        padding: 0,
        ...otherProps.style
    };
    if (scrollDirection === 'horizontal') {
        style.overflowX = 'auto';
        style.overflowY = 'hidden';
    } else if (scrollDirection === 'vertical' || contentSize.width === state.width) {
        // Set overflow-x: hidden if content size is equal to the width of the scroll view.
        // This prevents horizontal scrollbars from flickering during resizing due to resize observer
        // firing slower than the frame rate, which may cause an infinite re-render loop.
        style.overflowY = 'auto';
        style.overflowX = 'hidden';
    } else style.overflow = 'auto';
    innerStyle = {
        width: Number.isFinite(contentSize.width) ? contentSize.width : undefined,
        height: Number.isFinite(contentSize.height) ? contentSize.height : undefined,
        pointerEvents: isScrolling ? 'none' : 'auto',
        position: 'relative',
        ...innerStyle
    };
    return /*#__PURE__*/ (0, $f9kpT$react).createElement("div", {
        ...otherProps,
        style: style,
        ref: ref,
        onScroll: onScroll
    }, /*#__PURE__*/ (0, $f9kpT$react).createElement("div", {
        role: "presentation",
        style: innerStyle
    }, children));
}
const $44a6ee657928b002$export$5665e3d6be6adea = /*#__PURE__*/ (0, $f9kpT$react).forwardRef($44a6ee657928b002$var$ScrollView);


export {$44a6ee657928b002$export$5665e3d6be6adea as ScrollView};
//# sourceMappingURL=ScrollView.module.js.map
