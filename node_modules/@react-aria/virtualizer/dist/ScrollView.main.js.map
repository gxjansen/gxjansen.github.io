{"mappings":"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","sources":["packages/@react-aria/virtualizer/src/ScrollView.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// @ts-ignore\nimport {flushSync} from 'react-dom';\nimport {getScrollLeft} from './utils';\nimport React, {\n  CSSProperties,\n  ForwardedRef,\n  HTMLAttributes,\n  ReactNode,\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n  useState\n} from 'react';\nimport {Rect, Size} from '@react-stately/virtualizer';\nimport {useEffectEvent, useEvent, useLayoutEffect, useObjectRef, useResizeObserver} from '@react-aria/utils';\nimport {useLocale} from '@react-aria/i18n';\n\ninterface ScrollViewProps extends HTMLAttributes<HTMLElement> {\n  contentSize: Size,\n  onVisibleRectChange: (rect: Rect) => void,\n  children?: ReactNode,\n  innerStyle?: CSSProperties,\n  onScrollStart?: () => void,\n  onScrollEnd?: () => void,\n  scrollDirection?: 'horizontal' | 'vertical' | 'both'\n}\n\nfunction ScrollView(props: ScrollViewProps, ref: ForwardedRef<HTMLDivElement | null>) {\n  ref = useObjectRef(ref);\n  let {scrollViewProps, contentProps} = useScrollView(props, ref);\n\n  return (\n    <div role=\"presentation\" {...scrollViewProps} ref={ref}>\n      <div role=\"presentation\" {...contentProps}>\n        {props.children}\n      </div>\n    </div>\n  );\n}\n\nconst ScrollViewForwardRef = React.forwardRef(ScrollView);\nexport {ScrollViewForwardRef as ScrollView};\n\nexport function useScrollView(props: ScrollViewProps, ref: RefObject<HTMLElement | null>) {\n  let {\n    contentSize,\n    onVisibleRectChange,\n    innerStyle,\n    onScrollStart,\n    onScrollEnd,\n    scrollDirection = 'both',\n    ...otherProps\n  } = props;\n\n  let state = useRef({\n    scrollTop: 0,\n    scrollLeft: 0,\n    scrollEndTime: 0,\n    scrollTimeout: null,\n    width: 0,\n    height: 0,\n    isScrolling: false\n  }).current;\n  let {direction} = useLocale();\n\n  let [isScrolling, setScrolling] = useState(false);\n  let onScroll = useCallback((e) => {\n    if (e.target !== e.currentTarget) {\n      return;\n    }\n\n    if (props.onScroll) {\n      props.onScroll(e);\n    }\n\n    flushSync(() => {\n      let scrollTop = e.currentTarget.scrollTop;\n      let scrollLeft = getScrollLeft(e.currentTarget, direction);\n\n      // Prevent rubber band scrolling from shaking when scrolling out of bounds\n      state.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state.height));\n      state.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state.width));\n\n      onVisibleRectChange(new Rect(state.scrollLeft, state.scrollTop, state.width, state.height));\n\n      if (!state.isScrolling) {\n        state.isScrolling = true;\n        setScrolling(true);\n\n        // Pause typekit MutationObserver during scrolling.\n        window.dispatchEvent(new Event('tk.disconnect-observer'));\n        if (onScrollStart) {\n          onScrollStart();\n        }\n      }\n\n      // So we don't constantly call clearTimeout and setTimeout,\n      // keep track of the current timeout time and only reschedule\n      // the timer when it is getting close.\n      let now = Date.now();\n      if (state.scrollEndTime <= now + 50) {\n        state.scrollEndTime = now + 300;\n\n        clearTimeout(state.scrollTimeout);\n        state.scrollTimeout = setTimeout(() => {\n          state.isScrolling = false;\n          setScrolling(false);\n          state.scrollTimeout = null;\n\n          window.dispatchEvent(new Event('tk.connect-observer'));\n          if (onScrollEnd) {\n            onScrollEnd();\n          }\n        }, 300);\n      }\n    });\n  }, [props, direction, state, contentSize, onVisibleRectChange, onScrollStart, onScrollEnd]);\n\n  // Attach event directly to ref so RAC Virtualizer doesn't need to send props upward.\n  useEvent(ref, 'scroll', onScroll);\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      clearTimeout(state.scrollTimeout);\n      if (state.isScrolling) {\n        window.dispatchEvent(new Event('tk.connect-observer'));\n      }\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  let isUpdatingSize = useRef(false);\n  let updateSize = useEffectEvent((flush: typeof flushSync) => {\n    let dom = ref.current;\n    if (!dom && !isUpdatingSize.current) {\n      return;\n    }\n\n    // Prevent reentrancy when resize observer fires, triggers re-layout that results in\n    // content size update, causing below layout effect to fire. This avoids infinite loops.\n    isUpdatingSize.current = true;\n\n    let isTestEnv = process.env.NODE_ENV === 'test' && !process.env.VIRT_ON;\n    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientWidth');\n    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientHeight');\n    let clientWidth = dom.clientWidth;\n    let clientHeight = dom.clientHeight;\n    let w = isTestEnv && !isClientWidthMocked ? Infinity : clientWidth;\n    let h = isTestEnv && !isClientHeightMocked ? Infinity : clientHeight;\n\n    if (state.width !== w || state.height !== h) {\n      state.width = w;\n      state.height = h;\n      flush(() => {\n        onVisibleRectChange(new Rect(state.scrollLeft, state.scrollTop, w, h));\n      });\n\n      // If the clientWidth or clientHeight changed, scrollbars appeared or disappeared as\n      // a result of the layout update. In this case, re-layout again to account for the\n      // adjusted space. In very specific cases this might result in the scrollbars disappearing\n      // again, resulting in extra padding. We stop after a maximum of two layout passes to avoid\n      // an infinite loop. This matches how browsers behavior with native CSS grid layout.\n      if (!isTestEnv && clientWidth !== dom.clientWidth || clientHeight !== dom.clientHeight) {\n        state.width = dom.clientWidth;\n        state.height = dom.clientHeight;\n        flush(() => {\n          onVisibleRectChange(new Rect(state.scrollLeft, state.scrollTop, state.width, state.height));\n        });\n      }\n    }\n\n    isUpdatingSize.current = false;\n  });\n\n  // Update visible rect when the content size changes, in case scrollbars need to appear or disappear.\n  let lastContentSize = useRef<Size | null>(null);\n  useLayoutEffect(() => {\n    if (!isUpdatingSize.current && (lastContentSize.current == null || !contentSize.equals(lastContentSize.current))) {\n      // React doesn't allow flushSync inside effects, so queue a microtask.\n      // We also need to wait until all refs are set (e.g. when passing a ref down from a parent).\n      // If we are in an `act` environment, update immediately without a microtask so you don't need\n      // to mock timers in tests. In this case, the update is synchronous already.\n      // IS_REACT_ACT_ENVIRONMENT is used by React 18. Previous versions checked for the `jest` global.\n      // https://github.com/reactwg/react-18/discussions/102\n      // @ts-ignore\n      if (typeof IS_REACT_ACT_ENVIRONMENT === 'boolean' ? IS_REACT_ACT_ENVIRONMENT : typeof jest !== 'undefined') {\n        updateSize(fn => fn());\n      } else {\n        queueMicrotask(() => updateSize(flushSync));\n      }\n    }\n\n    lastContentSize.current = contentSize;\n  });\n\n  let onResize = useCallback(() => {\n    updateSize(flushSync);\n  }, [updateSize]);\n\n  // Watch border-box instead of of content-box so that we don't go into\n  // an infinite loop when scrollbars appear or disappear.\n  useResizeObserver({ref, box: 'border-box', onResize});\n\n  let style: React.CSSProperties = {\n    // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.\n    padding: 0,\n    ...otherProps.style\n  };\n\n  if (scrollDirection === 'horizontal') {\n    style.overflowX = 'auto';\n    style.overflowY = 'hidden';\n  } else if (scrollDirection === 'vertical' || contentSize.width === state.width) {\n    // Set overflow-x: hidden if content size is equal to the width of the scroll view.\n    // This prevents horizontal scrollbars from flickering during resizing due to resize observer\n    // firing slower than the frame rate, which may cause an infinite re-render loop.\n    style.overflowY = 'auto';\n    style.overflowX = 'hidden';\n  } else {\n    style.overflow = 'auto';\n  }\n\n  innerStyle = {\n    width: Number.isFinite(contentSize.width) ? contentSize.width : undefined,\n    height: Number.isFinite(contentSize.height) ? contentSize.height : undefined,\n    pointerEvents: isScrolling ? 'none' : 'auto',\n    position: 'relative',\n    ...innerStyle\n  };\n\n  return {\n    scrollViewProps: {\n      ...otherProps,\n      style\n    },\n    contentProps: {\n      role: 'presentation',\n      style: innerStyle\n    }\n  };\n}\n"],"names":[],"version":3,"file":"ScrollView.main.js.map"}