{"mappings":"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","sources":["packages/@react-aria/virtualizer/src/Virtualizer.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Key} from '@react-types/shared';\nimport {getInteractionModality} from '@react-aria/interactions';\nimport {Layout, Rect, ReusableView, useVirtualizerState, VirtualizerState} from '@react-stately/virtualizer';\nimport {mergeProps, useLayoutEffect} from '@react-aria/utils';\nimport React, {FocusEvent, HTMLAttributes, ReactElement, ReactNode, RefObject, useCallback, useEffect, useMemo, useRef} from 'react';\nimport {ScrollView} from './ScrollView';\nimport {VirtualizerItem} from './VirtualizerItem';\n\ninterface VirtualizerProps<T extends object, V> extends Omit<HTMLAttributes<HTMLElement>, 'children'> {\n  children: (type: string, content: T) => V,\n  renderWrapper?: (\n    parent: ReusableView<T, V> | null,\n    reusableView: ReusableView<T, V>,\n    children: ReusableView<T, V>[],\n    renderChildren: (views: ReusableView<T, V>[]) => ReactElement[]\n  ) => ReactElement,\n  layout: Layout<T>,\n  collection: Collection<T>,\n  focusedKey?: Key,\n  sizeToFit?: 'width' | 'height',\n  scrollDirection?: 'horizontal' | 'vertical' | 'both',\n  transitionDuration?: number,\n  isLoading?: boolean,\n  onLoadMore?: () => void,\n  shouldUseVirtualFocus?: boolean,\n  scrollToItem?: (key: Key) => void,\n  autoFocus?: boolean\n}\n\nfunction Virtualizer<T extends object, V extends ReactNode>(props: VirtualizerProps<T, V>, ref: RefObject<HTMLDivElement>) {\n  let {\n    children: renderView,\n    renderWrapper,\n    layout,\n    collection,\n    sizeToFit,\n    scrollDirection,\n    transitionDuration,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isLoading,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onLoadMore,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    focusedKey,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    shouldUseVirtualFocus,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    scrollToItem,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    autoFocus,\n    ...otherProps\n  } = props;\n\n  let fallbackRef = useRef<HTMLDivElement>();\n  ref = ref || fallbackRef;\n\n  let state = useVirtualizerState({\n    transitionDuration,\n    layout,\n    collection,\n    renderView,\n    renderWrapper: renderWrapper || defaultRenderWrapper,\n    onVisibleRectChange(rect) {\n      ref.current.scrollLeft = rect.x;\n      ref.current.scrollTop = rect.y;\n    }\n  });\n\n  let {virtualizerProps, scrollViewProps} = useVirtualizer(props, state, ref);\n\n  return (\n    <ScrollView\n      {...mergeProps(otherProps, virtualizerProps, scrollViewProps)}\n      ref={ref}\n      innerStyle={state.isAnimating ? {transition: `none ${state.virtualizer.transitionDuration}ms`} : undefined}\n      contentSize={state.contentSize}\n      onScrollStart={state.startScrolling}\n      onScrollEnd={state.endScrolling}\n      sizeToFit={sizeToFit}\n      scrollDirection={scrollDirection}>\n      {state.visibleViews}\n    </ScrollView>\n  );\n}\n\ninterface VirtualizerOptions {\n  tabIndex?: number,\n  focusedKey?: Key,\n  scrollToItem?: (key: Key) => void,\n  shouldUseVirtualFocus?: boolean,\n  autoFocus?: boolean,\n  isLoading?: boolean,\n  onLoadMore?: () => void\n}\n\nexport function useVirtualizer<T extends object, V extends ReactNode, W>(props: VirtualizerOptions, state: VirtualizerState<T, V, W>, ref: RefObject<HTMLElement>) {\n  let {focusedKey, scrollToItem, shouldUseVirtualFocus, isLoading, onLoadMore} = props;\n  let {virtualizer} = state;\n  // Scroll to the focusedKey when it changes. Actually focusing the focusedKey\n  // is up to the implementation using Virtualizer since we don't have refs\n  // to all of the item DOM nodes.\n  let lastFocusedKey = useRef(null);\n  let isFocusWithin = useRef(false);\n  let autoFocus = useRef(props.autoFocus);\n  useEffect(() => {\n    if (virtualizer.visibleRect.height === 0) {\n      return;\n    }\n\n    // Only scroll the focusedKey into view if the modality is not pointer to avoid jumps in position when clicking/pressing tall items.\n    let modality = getInteractionModality();\n    if (focusedKey !== lastFocusedKey.current && (modality !== 'pointer' || autoFocus.current)) {\n      autoFocus.current = false;\n      if (scrollToItem) {\n        // If user provides scrolltoitem, then it is their responsibility to call scrollIntoViewport if desired\n        // since we don't know if their scrollToItem may take some time to actually bring the active element into the virtualizer's visible rect.\n        scrollToItem(focusedKey);\n      } else {\n        virtualizer.scrollToItem(focusedKey, {duration: 0});\n\n      }\n    }\n\n    lastFocusedKey.current = focusedKey;\n  }, [focusedKey, virtualizer.visibleRect.height, virtualizer, lastFocusedKey, scrollToItem, ref]);\n\n  // Persist the focusedKey and prevent it from being removed from the DOM when scrolled out of view.\n  virtualizer.persistedKeys = useMemo(() => focusedKey ? new Set([focusedKey]) : new Set(), [focusedKey]);\n\n  let onFocus = useCallback((e: FocusEvent) => {\n    // If the focused item is scrolled out of view and is not in the DOM, the collection\n    // will have tabIndex={0}. When tabbing in from outside, scroll the focused item into view.\n    // Ignore focus events that bubble through portals (e.g. focus that happens on a menu popover child of the virtualizer)\n    // Don't scroll focused key into view if modality is pointer to prevent sudden jump in position (e.g. CardView).\n    let modality = getInteractionModality();\n    if (!isFocusWithin.current && ref.current.contains(e.target) && modality !== 'pointer') {\n      if (scrollToItem) {\n        scrollToItem(focusedKey);\n      } else {\n        virtualizer.scrollToItem(focusedKey, {duration: 0});\n      }\n    }\n\n    isFocusWithin.current = e.target !== ref.current;\n  }, [ref, virtualizer, focusedKey, scrollToItem]);\n\n  let onBlur = useCallback((e: FocusEvent) => {\n    isFocusWithin.current = ref.current.contains(e.relatedTarget as Element);\n  }, [ref]);\n\n  // Set tabIndex to -1 if there is a focused key, otherwise 0 so that the collection\n  // itself is tabbable. When the collection receives focus, we scroll the focused item back into\n  // view, which will allow it to be properly focused. If using virtual focus, don't set a\n  // tabIndex at all so that VoiceOver on iOS 14 doesn't try to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    // When there is no focusedKey the default tabIndex is 0. We include logic for empty collections too.\n    // For collections that are empty, but have a link in the empty children we want to skip focusing this\n    // and let focus move to the link similar to link moving to children.\n    tabIndex = focusedKey != null ? -1 : 0;\n\n    // If the collection is empty, we want the tabIndex provided from props (if any)\n    // so that we handle when tabbable items are added to the empty state.\n    if (virtualizer.collection.size === 0 && props.tabIndex != null) {\n      tabIndex = props.tabIndex;\n    }\n  }\n\n  // Handle scrolling, and call onLoadMore when nearing the bottom.\n  let isLoadingRef = useRef(isLoading);\n  let prevProps = useRef(props);\n  let onVisibleRectChange = useCallback((rect: Rect) => {\n    state.setVisibleRect(rect);\n\n    if (!isLoadingRef.current && onLoadMore) {\n      let scrollOffset = state.virtualizer.contentSize.height - rect.height * 2;\n      if (rect.y > scrollOffset) {\n        isLoadingRef.current = true;\n        onLoadMore();\n      }\n    }\n  }, [onLoadMore, state]);\n\n  let lastContentSize = useRef(0);\n  useLayoutEffect(() => {\n    // If animating, wait until we're done.\n    if (state.isAnimating) {\n      return;\n    }\n\n    // Only update isLoadingRef if props object actually changed,\n    // not if a local state change occurred.\n    let wasLoading = isLoadingRef.current;\n    if (props !== prevProps.current) {\n      isLoadingRef.current = isLoading;\n      prevProps.current = props;\n    }\n\n    let shouldLoadMore = !isLoadingRef.current\n      && onLoadMore\n      && state.contentSize.height > 0\n      && state.contentSize.height <= state.virtualizer.visibleRect.height\n      // Only try loading more if the content size changed, or if we just finished\n      // loading and still have room for more items.\n      && (wasLoading || state.contentSize.height !== lastContentSize.current);\n\n    if (shouldLoadMore) {\n      isLoadingRef.current = true;\n      onLoadMore();\n    }\n    lastContentSize.current = state.contentSize.height;\n  }, [state.contentSize, state.isAnimating, state.virtualizer, isLoading, onLoadMore, props]);\n\n  return {\n    virtualizerProps: {\n      tabIndex,\n      onFocus,\n      onBlur\n    },\n    scrollViewProps: {\n      onVisibleRectChange\n    }\n  };\n}\n\n// forwardRef doesn't support generic parameters, so cast the result to the correct type\n// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref\nconst _Virtualizer = React.forwardRef(Virtualizer) as <T extends object, V>(props: VirtualizerProps<T, V> & {ref?: RefObject<HTMLDivElement>}) => ReactElement;\nexport {_Virtualizer as Virtualizer};\n\nfunction defaultRenderWrapper<T extends object, V extends ReactNode>(\n  parent: ReusableView<T, V> | null,\n  reusableView: ReusableView<T, V>\n) {\n  return (\n    <VirtualizerItem\n      key={reusableView.key}\n      layoutInfo={reusableView.layoutInfo}\n      virtualizer={reusableView.virtualizer}\n      parent={parent?.layoutInfo}>\n      {reusableView.rendered}\n    </VirtualizerItem>\n  );\n}\n"],"names":[],"version":3,"file":"Virtualizer.main.js.map"}