import {ScrollView as $44a6ee657928b002$export$5665e3d6be6adea} from "./ScrollView.mjs";
import {VirtualizerItem as $ccf8a0a04e4175ae$export$6796df8ba7398521} from "./VirtualizerItem.mjs";
import {getInteractionModality as $9WwqA$getInteractionModality} from "@react-aria/interactions";
import {useVirtualizerState as $9WwqA$useVirtualizerState} from "@react-stately/virtualizer";
import {mergeProps as $9WwqA$mergeProps, useLayoutEffect as $9WwqA$useLayoutEffect} from "@react-aria/utils";
import $9WwqA$react, {useRef as $9WwqA$useRef, useEffect as $9WwqA$useEffect, useMemo as $9WwqA$useMemo, useCallback as $9WwqA$useCallback} from "react";

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 





function $6d0a5c394373ae64$var$Virtualizer(props, ref) {
    let { children: renderView, renderWrapper: renderWrapper, layout: layout, collection: collection, sizeToFit: sizeToFit, scrollDirection: scrollDirection, transitionDuration: transitionDuration, isLoading: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isLoading, onLoadMore: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLoadMore, focusedKey: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusedKey, shouldUseVirtualFocus: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldUseVirtualFocus, scrollToItem: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    scrollToItem, autoFocus: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    autoFocus, ...otherProps } = props;
    let fallbackRef = (0, $9WwqA$useRef)();
    ref = ref || fallbackRef;
    let state = (0, $9WwqA$useVirtualizerState)({
        transitionDuration: transitionDuration,
        layout: layout,
        collection: collection,
        renderView: renderView,
        renderWrapper: renderWrapper || $6d0a5c394373ae64$var$defaultRenderWrapper,
        onVisibleRectChange (rect) {
            ref.current.scrollLeft = rect.x;
            ref.current.scrollTop = rect.y;
        }
    });
    let { virtualizerProps: virtualizerProps, scrollViewProps: scrollViewProps } = $6d0a5c394373ae64$export$dd6d526d88b5a137(props, state, ref);
    return /*#__PURE__*/ (0, $9WwqA$react).createElement((0, $44a6ee657928b002$export$5665e3d6be6adea), {
        ...(0, $9WwqA$mergeProps)(otherProps, virtualizerProps, scrollViewProps),
        ref: ref,
        innerStyle: state.isAnimating ? {
            transition: `none ${state.virtualizer.transitionDuration}ms`
        } : undefined,
        contentSize: state.contentSize,
        onScrollStart: state.startScrolling,
        onScrollEnd: state.endScrolling,
        sizeToFit: sizeToFit,
        scrollDirection: scrollDirection
    }, state.visibleViews);
}
function $6d0a5c394373ae64$export$dd6d526d88b5a137(props, state, ref) {
    let { focusedKey: focusedKey, scrollToItem: scrollToItem, shouldUseVirtualFocus: shouldUseVirtualFocus, isLoading: isLoading, onLoadMore: onLoadMore } = props;
    let { virtualizer: virtualizer } = state;
    // Scroll to the focusedKey when it changes. Actually focusing the focusedKey
    // is up to the implementation using Virtualizer since we don't have refs
    // to all of the item DOM nodes.
    let lastFocusedKey = (0, $9WwqA$useRef)(null);
    let isFocusWithin = (0, $9WwqA$useRef)(false);
    let autoFocus = (0, $9WwqA$useRef)(props.autoFocus);
    (0, $9WwqA$useEffect)(()=>{
        if (virtualizer.visibleRect.height === 0) return;
        // Only scroll the focusedKey into view if the modality is not pointer to avoid jumps in position when clicking/pressing tall items.
        let modality = (0, $9WwqA$getInteractionModality)();
        if (focusedKey !== lastFocusedKey.current && (modality !== 'pointer' || autoFocus.current)) {
            autoFocus.current = false;
            if (scrollToItem) // If user provides scrolltoitem, then it is their responsibility to call scrollIntoViewport if desired
            // since we don't know if their scrollToItem may take some time to actually bring the active element into the virtualizer's visible rect.
            scrollToItem(focusedKey);
            else virtualizer.scrollToItem(focusedKey, {
                duration: 0
            });
        }
        lastFocusedKey.current = focusedKey;
    }, [
        focusedKey,
        virtualizer.visibleRect.height,
        virtualizer,
        lastFocusedKey,
        scrollToItem,
        ref
    ]);
    // Persist the focusedKey and prevent it from being removed from the DOM when scrolled out of view.
    virtualizer.persistedKeys = (0, $9WwqA$useMemo)(()=>focusedKey ? new Set([
            focusedKey
        ]) : new Set(), [
        focusedKey
    ]);
    let onFocus = (0, $9WwqA$useCallback)((e)=>{
        // If the focused item is scrolled out of view and is not in the DOM, the collection
        // will have tabIndex={0}. When tabbing in from outside, scroll the focused item into view.
        // Ignore focus events that bubble through portals (e.g. focus that happens on a menu popover child of the virtualizer)
        // Don't scroll focused key into view if modality is pointer to prevent sudden jump in position (e.g. CardView).
        let modality = (0, $9WwqA$getInteractionModality)();
        if (!isFocusWithin.current && ref.current.contains(e.target) && modality !== 'pointer') {
            if (scrollToItem) scrollToItem(focusedKey);
            else virtualizer.scrollToItem(focusedKey, {
                duration: 0
            });
        }
        isFocusWithin.current = e.target !== ref.current;
    }, [
        ref,
        virtualizer,
        focusedKey,
        scrollToItem
    ]);
    let onBlur = (0, $9WwqA$useCallback)((e)=>{
        isFocusWithin.current = ref.current.contains(e.relatedTarget);
    }, [
        ref
    ]);
    // Set tabIndex to -1 if there is a focused key, otherwise 0 so that the collection
    // itself is tabbable. When the collection receives focus, we scroll the focused item back into
    // view, which will allow it to be properly focused. If using virtual focus, don't set a
    // tabIndex at all so that VoiceOver on iOS 14 doesn't try to move real DOM focus to the element anyway.
    let tabIndex;
    if (!shouldUseVirtualFocus) {
        // When there is no focusedKey the default tabIndex is 0. We include logic for empty collections too.
        // For collections that are empty, but have a link in the empty children we want to skip focusing this
        // and let focus move to the link similar to link moving to children.
        tabIndex = focusedKey != null ? -1 : 0;
        // If the collection is empty, we want the tabIndex provided from props (if any)
        // so that we handle when tabbable items are added to the empty state.
        if (virtualizer.collection.size === 0 && props.tabIndex != null) tabIndex = props.tabIndex;
    }
    // Handle scrolling, and call onLoadMore when nearing the bottom.
    let isLoadingRef = (0, $9WwqA$useRef)(isLoading);
    let prevProps = (0, $9WwqA$useRef)(props);
    let onVisibleRectChange = (0, $9WwqA$useCallback)((rect)=>{
        state.setVisibleRect(rect);
        if (!isLoadingRef.current && onLoadMore) {
            let scrollOffset = state.virtualizer.contentSize.height - rect.height * 2;
            if (rect.y > scrollOffset) {
                isLoadingRef.current = true;
                onLoadMore();
            }
        }
    }, [
        onLoadMore,
        state
    ]);
    let lastContentSize = (0, $9WwqA$useRef)(0);
    (0, $9WwqA$useLayoutEffect)(()=>{
        // If animating, wait until we're done.
        if (state.isAnimating) return;
        // Only update isLoadingRef if props object actually changed,
        // not if a local state change occurred.
        let wasLoading = isLoadingRef.current;
        if (props !== prevProps.current) {
            isLoadingRef.current = isLoading;
            prevProps.current = props;
        }
        let shouldLoadMore = !isLoadingRef.current && onLoadMore && state.contentSize.height > 0 && state.contentSize.height <= state.virtualizer.visibleRect.height && (wasLoading || state.contentSize.height !== lastContentSize.current);
        if (shouldLoadMore) {
            isLoadingRef.current = true;
            onLoadMore();
        }
        lastContentSize.current = state.contentSize.height;
    }, [
        state.contentSize,
        state.isAnimating,
        state.virtualizer,
        isLoading,
        onLoadMore,
        props
    ]);
    return {
        virtualizerProps: {
            tabIndex: tabIndex,
            onFocus: onFocus,
            onBlur: onBlur
        },
        scrollViewProps: {
            onVisibleRectChange: onVisibleRectChange
        }
    };
}
// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref
const $6d0a5c394373ae64$export$89be5a243e59c4b2 = /*#__PURE__*/ (0, $9WwqA$react).forwardRef($6d0a5c394373ae64$var$Virtualizer);
function $6d0a5c394373ae64$var$defaultRenderWrapper(parent, reusableView) {
    return /*#__PURE__*/ (0, $9WwqA$react).createElement((0, $ccf8a0a04e4175ae$export$6796df8ba7398521), {
        key: reusableView.key,
        layoutInfo: reusableView.layoutInfo,
        virtualizer: reusableView.virtualizer,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo
    }, reusableView.rendered);
}


export {$6d0a5c394373ae64$export$dd6d526d88b5a137 as useVirtualizer, $6d0a5c394373ae64$export$89be5a243e59c4b2 as Virtualizer};
//# sourceMappingURL=Virtualizer.module.js.map
