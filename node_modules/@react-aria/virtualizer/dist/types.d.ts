import { Direction, Key, Collection } from "@react-types/shared";
import { LayoutInfo, Size, Rect, Layout, ReusableView, VirtualizerState } from "@react-stately/virtualizer";
import React, { RefObject, CSSProperties, HTMLAttributes, ReactNode, FocusEvent, ReactElement } from "react";
export type RTLOffsetType = 'negative' | 'positive-descending' | 'positive-ascending';
export function getRTLOffsetType(recalculate?: boolean): RTLOffsetType;
export function getScrollLeft(node: Element, direction: Direction): number;
export function setScrollLeft(node: Element, direction: Direction, scrollLeft: number): void;
interface IVirtualizer {
    updateItemSize(key: Key, size: Size): void;
}
export interface VirtualizerItemOptions {
    layoutInfo: LayoutInfo;
    virtualizer: IVirtualizer;
    ref: RefObject<HTMLElement>;
}
export function useVirtualizerItem(options: VirtualizerItemOptions): {
    updateSize: () => void;
};
interface ScrollViewProps extends HTMLAttributes<HTMLElement> {
    contentSize: Size;
    onVisibleRectChange: (rect: Rect) => void;
    children: ReactNode;
    innerStyle?: CSSProperties;
    sizeToFit?: 'width' | 'height';
    onScrollStart?: () => void;
    onScrollEnd?: () => void;
    scrollDirection?: 'horizontal' | 'vertical' | 'both';
}
export const ScrollView: React.ForwardRefExoticComponent<ScrollViewProps & React.RefAttributes<HTMLDivElement>>;
interface VirtualizerItemProps extends Omit<VirtualizerItemOptions, 'ref'> {
    parent?: LayoutInfo;
    className?: string;
    children: ReactNode;
}
export function VirtualizerItem(props: VirtualizerItemProps): React.JSX.Element;
export function layoutInfoToStyle(layoutInfo: LayoutInfo, dir: Direction, parent?: LayoutInfo | null): CSSProperties;
interface VirtualizerProps<T extends object, V> extends Omit<HTMLAttributes<HTMLElement>, 'children'> {
    children: (type: string, content: T) => V;
    renderWrapper?: (parent: ReusableView<T, V> | null, reusableView: ReusableView<T, V>, children: ReusableView<T, V>[], renderChildren: (views: ReusableView<T, V>[]) => ReactElement[]) => ReactElement;
    layout: Layout<T>;
    collection: Collection<T>;
    focusedKey?: Key;
    sizeToFit?: 'width' | 'height';
    scrollDirection?: 'horizontal' | 'vertical' | 'both';
    transitionDuration?: number;
    isLoading?: boolean;
    onLoadMore?: () => void;
    shouldUseVirtualFocus?: boolean;
    scrollToItem?: (key: Key) => void;
    autoFocus?: boolean;
}
interface VirtualizerOptions {
    tabIndex?: number;
    focusedKey?: Key;
    scrollToItem?: (key: Key) => void;
    shouldUseVirtualFocus?: boolean;
    autoFocus?: boolean;
    isLoading?: boolean;
    onLoadMore?: () => void;
}
export function useVirtualizer<T extends object, V extends ReactNode, W>(props: VirtualizerOptions, state: VirtualizerState<T, V, W>, ref: RefObject<HTMLElement>): {
    virtualizerProps: {
        tabIndex: number;
        onFocus: (e: FocusEvent) => void;
        onBlur: (e: FocusEvent) => void;
    };
    scrollViewProps: {
        onVisibleRectChange: (rect: Rect) => void;
    };
};
export const Virtualizer: <T extends object, V>(props: VirtualizerProps<T, V> & {
    ref?: RefObject<HTMLDivElement>;
}) => ReactElement;

//# sourceMappingURL=types.d.ts.map
