{"mappings":"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","sources":["packages/@react-aria/dnd/src/DragManager.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {announce} from '@react-aria/live-announcer';\nimport {ariaHideOutside} from '@react-aria/overlays';\nimport {DragEndEvent, DragItem, DropActivateEvent, DropEnterEvent, DropEvent, DropExitEvent, DropItem, DropOperation, DropTarget as DroppableCollectionTarget, FocusableElement} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {getDragModality, getTypes} from './utils';\nimport {isVirtualClick, isVirtualPointerEvent} from '@react-aria/utils';\nimport type {LocalizedStringFormatter} from '@internationalized/string';\nimport {useEffect, useState} from 'react';\n\nlet dropTargets = new Map<Element, DropTarget>();\nlet dropItems = new Map<Element, DroppableItem>();\nlet dragSession: DragSession = null;\nlet subscriptions = new Set<() => void>();\n\ninterface DropTarget {\n  element: FocusableElement,\n  getDropOperation?: (types: Set<string>, allowedOperations: DropOperation[]) => DropOperation,\n  onDropEnter?: (e: DropEnterEvent, dragTarget: DragTarget) => void,\n  onDropExit?: (e: DropExitEvent) => void,\n  onDropTargetEnter?: (target?: DroppableCollectionTarget) => void,\n  onDropActivate?: (e: DropActivateEvent, target?: DroppableCollectionTarget) => void,\n  onDrop?: (e: DropEvent, target?: DroppableCollectionTarget) => void,\n  onKeyDown?: (e: KeyboardEvent, dragTarget: DragTarget) => void\n}\n\nexport function registerDropTarget(target: DropTarget) {\n  dropTargets.set(target.element, target);\n  dragSession?.updateValidDropTargets();\n  return () => {\n    dropTargets.delete(target.element);\n    dragSession?.updateValidDropTargets();\n  };\n}\n\ninterface DroppableItem {\n  element: FocusableElement,\n  target: DroppableCollectionTarget,\n  getDropOperation?: (types: Set<string>, allowedOperations: DropOperation[]) => DropOperation\n}\n\nexport function registerDropItem(item: DroppableItem) {\n  dropItems.set(item.element, item);\n  return () => {\n    dropItems.delete(item.element);\n  };\n}\n\ninterface DragTarget {\n  element: FocusableElement,\n  items: DragItem[],\n  allowedDropOperations: DropOperation[],\n  onDragEnd?: (e: DragEndEvent) => void\n}\n\nexport function beginDragging(target: DragTarget, stringFormatter: LocalizedStringFormatter) {\n  if (dragSession) {\n    throw new Error('Cannot begin dragging while already dragging');\n  }\n\n  dragSession = new DragSession(target, stringFormatter);\n  requestAnimationFrame(() => {\n    dragSession.setup();\n    if (getDragModality() === 'keyboard') {\n      dragSession.next();\n    }\n  });\n\n  for (let cb of subscriptions) {\n    cb();\n  }\n}\n\nexport function useDragSession() {\n  let [session, setSession] = useState(dragSession);\n\n  useEffect(() => {\n    let cb = () => setSession(dragSession);\n    subscriptions.add(cb);\n    return () => {\n      subscriptions.delete(cb);\n    };\n  }, []);\n\n  return session;\n}\n\n/** @private */\nexport function isVirtualDragging(): boolean {\n  return !!dragSession;\n}\n\nfunction endDragging() {\n  dragSession = null;\n  for (let cb of subscriptions) {\n    cb();\n  }\n}\n\nexport function isValidDropTarget(element: Element): boolean {\n  for (let target of dropTargets.keys()) {\n    if (target.contains(element)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst CANCELED_EVENTS = [\n  'pointerdown',\n  'pointermove',\n  'pointerenter',\n  'pointerleave',\n  'pointerover',\n  'pointerout',\n  'pointerup',\n  'mousedown',\n  'mousemove',\n  'mouseenter',\n  'mouseleave',\n  'mouseover',\n  'mouseout',\n  'mouseup',\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'focusin',\n  'focusout'\n];\n\nconst CLICK_EVENTS = [\n  'pointerup',\n  'mouseup',\n  'touchend'\n];\n\nconst MESSAGES = {\n  keyboard: 'dragStartedKeyboard',\n  touch: 'dragStartedTouch',\n  virtual: 'dragStartedVirtual'\n};\n\nclass DragSession {\n  dragTarget: DragTarget;\n  validDropTargets: DropTarget[];\n  currentDropTarget: DropTarget;\n  currentDropItem: DroppableItem;\n  dropOperation: DropOperation;\n  private mutationObserver: MutationObserver;\n  private restoreAriaHidden: () => void;\n  private stringFormatter: LocalizedStringFormatter;\n  private isVirtualClick: boolean;\n  private initialFocused: boolean;\n\n  constructor(target: DragTarget, stringFormatter: LocalizedStringFormatter) {\n    this.dragTarget = target;\n    this.stringFormatter = stringFormatter;\n\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.onKeyUp = this.onKeyUp.bind(this);\n    this.onFocus = this.onFocus.bind(this);\n    this.onBlur = this.onBlur.bind(this);\n    this.onClick = this.onClick.bind(this);\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.cancelEvent = this.cancelEvent.bind(this);\n    this.initialFocused = false;\n  }\n\n  setup() {\n    document.addEventListener('keydown', this.onKeyDown, true);\n    document.addEventListener('keyup', this.onKeyUp, true);\n    window.addEventListener('focus', this.onFocus, true);\n    window.addEventListener('blur', this.onBlur, true);\n    document.addEventListener('click', this.onClick, true);\n    document.addEventListener('pointerdown', this.onPointerDown, true);\n\n    for (let event of CANCELED_EVENTS) {\n      document.addEventListener(event, this.cancelEvent, true);\n    }\n\n    this.mutationObserver = new MutationObserver(() =>\n      this.updateValidDropTargets()\n    );\n    this.updateValidDropTargets();\n\n    announce(this.stringFormatter.format(MESSAGES[getDragModality()]));\n  }\n\n  teardown() {\n    document.removeEventListener('keydown', this.onKeyDown, true);\n    document.removeEventListener('keyup', this.onKeyUp, true);\n    window.removeEventListener('focus', this.onFocus, true);\n    window.removeEventListener('blur', this.onBlur, true);\n    document.removeEventListener('click', this.onClick, true);\n    document.removeEventListener('pointerdown', this.onPointerDown, true);\n\n    for (let event of CANCELED_EVENTS) {\n      document.removeEventListener(event, this.cancelEvent, true);\n    }\n\n    this.mutationObserver.disconnect();\n    this.restoreAriaHidden();\n  }\n\n  onKeyDown(e: KeyboardEvent) {\n    this.cancelEvent(e);\n\n    if (e.key === 'Escape') {\n      this.cancel();\n      return;\n    }\n\n    if (e.key === 'Tab' && !(e.metaKey || e.altKey || e.ctrlKey)) {\n      if (e.shiftKey) {\n        this.previous();\n      } else {\n        this.next();\n      }\n    }\n\n    if (typeof this.currentDropTarget?.onKeyDown === 'function') {\n      this.currentDropTarget.onKeyDown(e, this.dragTarget);\n    }\n  }\n\n  onKeyUp(e: KeyboardEvent) {\n    this.cancelEvent(e);\n\n    if (e.key === 'Enter') {\n      if (e.altKey) {\n        this.activate();\n      } else {\n        this.drop();\n      }\n    }\n  }\n\n  onFocus(e: FocusEvent) {\n    // Prevent focus events, except to the original drag target.\n    if (e.target !== this.dragTarget.element) {\n      this.cancelEvent(e);\n    }\n\n    // Ignore focus events on the window/document (JSDOM). Will be handled in onBlur, below.\n    if (!(e.target instanceof HTMLElement) || e.target === this.dragTarget.element) {\n      return;\n    }\n\n    let dropTarget =\n      this.validDropTargets.find(target => target.element === e.target as HTMLElement) ||\n      this.validDropTargets.find(target => target.element.contains(e.target as HTMLElement));\n\n    if (!dropTarget) {\n      if (this.currentDropTarget) {\n        this.currentDropTarget.element.focus();\n      } else {\n        this.dragTarget.element.focus();\n      }\n      return;\n    }\n\n    let item = dropItems.get(e.target as HTMLElement);\n    this.setCurrentDropTarget(dropTarget, item);\n  }\n\n  onBlur(e: FocusEvent) {\n    if (e.target !== this.dragTarget.element) {\n      this.cancelEvent(e);\n    }\n\n    // If nothing is gaining focus, or e.relatedTarget is the window/document (JSDOM),\n    // restore focus back to the current drop target if any, or the original drag target.\n    if (!e.relatedTarget || !(e.relatedTarget instanceof HTMLElement)) {\n      if (this.currentDropTarget) {\n        this.currentDropTarget.element.focus();\n      } else {\n        this.dragTarget.element.focus();\n      }\n    }\n  }\n\n  onClick(e: MouseEvent) {\n    this.cancelEvent(e);\n    if (isVirtualClick(e) || this.isVirtualClick) {\n      if (e.target === this.dragTarget.element) {\n        this.cancel();\n        return;\n      }\n\n      let dropTarget = this.validDropTargets.find(target => target.element.contains(e.target as HTMLElement));\n      if (dropTarget) {\n        let item = dropItems.get(e.target as HTMLElement);\n        this.setCurrentDropTarget(dropTarget, item);\n        this.drop(item);\n      }\n    }\n  }\n\n  onPointerDown(e: PointerEvent) {\n    // Android Talkback double tap has e.detail = 1 for onClick. Detect the virtual click in onPointerDown before onClick fires\n    // so we can properly perform cancel and drop operations.\n    this.cancelEvent(e);\n    this.isVirtualClick = isVirtualPointerEvent(e);\n  }\n\n  cancelEvent(e: Event) {\n    // Allow focusin and focusout on the drag target so focus ring works properly.\n    if ((e.type === 'focusin' || e.type === 'focusout') && e.target === this.dragTarget?.element) {\n      return;\n    }\n\n    // Allow default for events that might cancel a click event\n    if (!CLICK_EVENTS.includes(e.type)) {\n      e.preventDefault();\n    }\n\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n  }\n\n  updateValidDropTargets() {\n    if (!this.mutationObserver) {\n      return;\n    }\n\n    this.mutationObserver.disconnect();\n    if (this.restoreAriaHidden) {\n      this.restoreAriaHidden();\n    }\n\n    this.validDropTargets = findValidDropTargets(this.dragTarget);\n\n    // Shuffle drop target order based on starting drag target.\n    if (this.validDropTargets.length > 0) {\n      let nearestIndex = this.findNearestDropTarget();\n      this.validDropTargets = [\n        ...this.validDropTargets.slice(nearestIndex),\n        ...this.validDropTargets.slice(0, nearestIndex)\n      ];\n    }\n\n    if (this.currentDropTarget && !this.validDropTargets.includes(this.currentDropTarget)) {\n      this.setCurrentDropTarget(this.validDropTargets[0]);\n    }\n\n    // Find valid drop items within collections\n    let types = getTypes(this.dragTarget.items);\n    let validDropItems = [...dropItems.values()].filter(item => {\n      if (typeof item.getDropOperation === 'function') {\n        return item.getDropOperation(types, this.dragTarget.allowedDropOperations) !== 'cancel';\n      }\n\n      return true;\n    });\n\n    // Filter out drop targets that contain valid items. We don't want to stop hiding elements\n    // other than the drop items that exist inside the collection.\n    let visibleDropTargets = this.validDropTargets.filter(target =>\n      !validDropItems.some(item => target.element.contains(item.element))\n    );\n\n    this.restoreAriaHidden = ariaHideOutside([\n      this.dragTarget.element,\n      ...validDropItems.map(item => item.element),\n      ...visibleDropTargets.map(target => target.element)\n    ]);\n\n    this.mutationObserver.observe(document.body, {subtree: true, attributes: true, attributeFilter: ['aria-hidden']});\n  }\n\n  next() {\n    if (!this.currentDropTarget) {\n      this.setCurrentDropTarget(this.validDropTargets[0]);\n      return;\n    }\n\n    let index = this.validDropTargets.indexOf(this.currentDropTarget);\n    if (index < 0) {\n      this.setCurrentDropTarget(this.validDropTargets[0]);\n      return;\n    }\n\n    // If we've reached the end of the valid drop targets, cycle back to the original drag target.\n    // This lets the user cancel the drag in case they don't have an Escape key (e.g. iPad keyboard case).\n    if (index === this.validDropTargets.length - 1) {\n      if (!this.dragTarget.element.closest('[aria-hidden=\"true\"]')) {\n        this.setCurrentDropTarget(null);\n        this.dragTarget.element.focus();\n      } else {\n        this.setCurrentDropTarget(this.validDropTargets[0]);\n      }\n    } else {\n      this.setCurrentDropTarget(this.validDropTargets[index + 1]);\n    }\n  }\n\n  previous() {\n    if (!this.currentDropTarget) {\n      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);\n      return;\n    }\n\n    let index = this.validDropTargets.indexOf(this.currentDropTarget);\n    if (index < 0) {\n      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);\n      return;\n    }\n\n    // If we've reached the start of the valid drop targets, cycle back to the original drag target.\n    // This lets the user cancel the drag in case they don't have an Escape key (e.g. iPad keyboard case).\n    if (index === 0) {\n      if (!this.dragTarget.element.closest('[aria-hidden=\"true\"]')) {\n        this.setCurrentDropTarget(null);\n        this.dragTarget.element.focus();\n      } else {\n        this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);\n      }\n    } else {\n      this.setCurrentDropTarget(this.validDropTargets[index - 1]);\n    }\n  }\n\n  findNearestDropTarget(): number {\n    let dragTargetRect = this.dragTarget.element.getBoundingClientRect();\n\n    let minDistance = Infinity;\n    let nearest = -1;\n    for (let i = 0; i < this.validDropTargets.length; i++) {\n      let dropTarget = this.validDropTargets[i];\n      let rect = dropTarget.element.getBoundingClientRect();\n      let dx = rect.left - dragTargetRect.left;\n      let dy = rect.top - dragTargetRect.top;\n      let dist = (dx * dx) + (dy * dy);\n      if (dist < minDistance) {\n        minDistance = dist;\n        nearest = i;\n      }\n    }\n\n    return nearest;\n  }\n\n  setCurrentDropTarget(dropTarget: DropTarget, item?: DroppableItem) {\n    if (dropTarget !== this.currentDropTarget) {\n      if (this.currentDropTarget && typeof this.currentDropTarget.onDropExit === 'function') {\n        let rect = this.currentDropTarget.element.getBoundingClientRect();\n        this.currentDropTarget.onDropExit({\n          type: 'dropexit',\n          x: rect.left + (rect.width / 2),\n          y: rect.top + (rect.height / 2)\n        });\n      }\n\n      this.currentDropTarget = dropTarget;\n\n      if (dropTarget) {\n        if (typeof dropTarget.onDropEnter === 'function') {\n          let rect = dropTarget.element.getBoundingClientRect();\n          dropTarget.onDropEnter({\n            type: 'dropenter',\n            x: rect.left + (rect.width / 2),\n            y: rect.top + (rect.height / 2)\n          }, this.dragTarget);\n        }\n\n        if (!item) {\n          dropTarget?.element.focus();\n        }\n      }\n    }\n\n    if (item !== this.currentDropItem) {\n      if (item && typeof this.currentDropTarget.onDropTargetEnter === 'function') {\n        this.currentDropTarget.onDropTargetEnter(item?.target);\n      }\n\n      item?.element.focus();\n      this.currentDropItem = item;\n\n      // Announce first drop target after drag start announcement finishes.\n      // Otherwise, it will never get announced because drag start announcement is assertive.\n      if (!this.initialFocused) {\n        announce(item?.element.getAttribute('aria-label'), 'polite');\n        this.initialFocused = true;\n      }\n    }\n  }\n\n  end() {\n    this.teardown();\n    endDragging();\n\n    if (typeof this.dragTarget.onDragEnd === 'function') {\n      let target = this.currentDropTarget && this.dropOperation !== 'cancel' ? this.currentDropTarget : this.dragTarget;\n      let rect = target.element.getBoundingClientRect();\n      this.dragTarget.onDragEnd({\n        type: 'dragend',\n        x: rect.x + (rect.width / 2),\n        y: rect.y + (rect.height / 2),\n        dropOperation: this.dropOperation || 'cancel'\n      });\n    }\n\n    // Blur and re-focus the drop target so that the focus ring appears.\n    if (this.currentDropTarget) {\n      // Since we cancel all focus events in drag sessions, refire blur to make sure state gets updated so drag target doesn't think it's still focused\n      // i.e. When you from one list to another during a drag session, we need the blur to fire on the first list after the drag.\n      if (!this.dragTarget.element.contains(this.currentDropTarget.element)) {\n        this.dragTarget.element.dispatchEvent(new FocusEvent('blur'));\n        this.dragTarget.element.dispatchEvent(new FocusEvent('focusout', {bubbles: true}));\n      }\n      // Re-focus the focusedKey upon reorder. This requires a React rerender between blurring and focusing.\n      flushSync(() => {\n        this.currentDropTarget.element.blur();\n      });\n      this.currentDropTarget.element.focus();\n    }\n\n    this.setCurrentDropTarget(null);\n  }\n\n  cancel() {\n    this.setCurrentDropTarget(null);\n    this.end();\n    if (!this.dragTarget.element.closest('[aria-hidden=\"true\"]')) {\n      this.dragTarget.element.focus();\n    }\n\n    announce(this.stringFormatter.format('dropCanceled'));\n  }\n\n  drop(item?: DroppableItem) {\n    if (!this.currentDropTarget) {\n      this.cancel();\n      return;\n    }\n\n    if (typeof item?.getDropOperation === 'function') {\n      let types = getTypes(this.dragTarget.items);\n      this.dropOperation = item.getDropOperation(types, this.dragTarget.allowedDropOperations);\n    } else if (typeof this.currentDropTarget.getDropOperation === 'function') {\n      let types = getTypes(this.dragTarget.items);\n      this.dropOperation = this.currentDropTarget.getDropOperation(types, this.dragTarget.allowedDropOperations);\n    } else {\n      // TODO: show menu ??\n      this.dropOperation = this.dragTarget.allowedDropOperations[0];\n    }\n\n    if (typeof this.currentDropTarget.onDrop === 'function') {\n      let items: DropItem[] = this.dragTarget.items.map(item => ({\n        kind: 'text',\n        types: new Set(Object.keys(item)),\n        getText: (type: string) => Promise.resolve(item[type])\n      }));\n\n      let rect = this.currentDropTarget.element.getBoundingClientRect();\n      this.currentDropTarget.onDrop({\n        type: 'drop',\n        x: rect.left + (rect.width / 2),\n        y: rect.top + (rect.height / 2),\n        items,\n        dropOperation: this.dropOperation\n      }, item?.target);\n    }\n\n    this.end();\n    announce(this.stringFormatter.format('dropComplete'));\n  }\n\n  activate() {\n    if (this.currentDropTarget && typeof this.currentDropTarget.onDropActivate === 'function') {\n      let rect = this.currentDropTarget.element.getBoundingClientRect();\n      this.currentDropTarget.onDropActivate({\n        type: 'dropactivate',\n        x: rect.left + (rect.width / 2),\n        y: rect.top + (rect.height / 2)\n      });\n    }\n  }\n}\n\nfunction findValidDropTargets(options: DragTarget) {\n  let types = getTypes(options.items);\n  return [...dropTargets.values()].filter(target => {\n    if (target.element.closest('[aria-hidden=\"true\"]')) {\n      return false;\n    }\n\n    if (typeof target.getDropOperation === 'function') {\n      return target.getDropOperation(types, options.allowedDropOperations) !== 'cancel';\n    }\n\n    return true;\n  });\n}\n"],"names":[],"version":3,"file":"DragManager.module.js.map"}