{"mappings":"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","sources":["packages/@react-aria/dnd/src/useDrop.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {DragEvent, HTMLAttributes, RefObject, useRef, useState} from 'react';\nimport * as DragManager from './DragManager';\nimport {DragTypes, globalAllowedDropOperations, globalDndState, readFromDataTransfer, setGlobalDnDState, setGlobalDropEffect} from './utils';\nimport {DROP_EFFECT_TO_DROP_OPERATION, DROP_OPERATION, DROP_OPERATION_ALLOWED, DROP_OPERATION_TO_DROP_EFFECT} from './constants';\nimport {DropActivateEvent, DropEnterEvent, DropEvent, DropExitEvent, DropMoveEvent, DropOperation, DragTypes as IDragTypes} from '@react-types/shared';\nimport {isIPad, isMac, useEffectEvent, useLayoutEffect} from '@react-aria/utils';\nimport {useVirtualDrop} from './useVirtualDrop';\n\nexport interface DropOptions {\n  /** A ref for the droppable element. */\n  ref: RefObject<HTMLElement>,\n  /**\n   * A function returning the drop operation to be performed when items matching the given types are dropped\n   * on the drop target.\n   */\n  getDropOperation?: (types: IDragTypes, allowedOperations: DropOperation[]) => DropOperation,\n  /** A function that returns the drop operation for a specific point within the target. */\n  getDropOperationForPoint?: (types: IDragTypes, allowedOperations: DropOperation[], x: number, y: number) => DropOperation,\n  /** Handler that is called when a valid drag enters the drop target. */\n  onDropEnter?: (e: DropEnterEvent) => void,\n  /** Handler that is called when a valid drag is moved within the drop target. */\n  onDropMove?: (e: DropMoveEvent) => void,\n  /**\n   * Handler that is called after a valid drag is held over the drop target for a period of time.\n   * This typically opens the item so that the user can drop within it.\n   * @private\n   */\n  onDropActivate?: (e: DropActivateEvent) => void,\n  /** Handler that is called when a valid drag exits the drop target. */\n  onDropExit?: (e: DropExitEvent) => void,\n  /** Handler that is called when a valid drag is dropped on the drop target. */\n  onDrop?: (e: DropEvent) => void,\n  /**\n   * Whether the item has an explicit focusable drop affordance to initiate accessible drag and drop mode.\n   * If true, the dropProps will omit these event handlers, and they will be applied to dropButtonProps instead.\n   */\n  hasDropButton?: boolean,\n  /**\n   * Whether the drop target is disabled. If true, the drop target will not accept any drops.\n   */\n  isDisabled?: boolean\n}\n\nexport interface DropResult {\n  /** Props for the droppable element. */\n  dropProps: HTMLAttributes<HTMLElement>,\n  /** Whether the drop target is currently focused or hovered. */\n  isDropTarget: boolean,\n  /** Props for the explicit drop button affordance, if any. */\n  dropButtonProps?: AriaButtonProps\n}\n\nconst DROP_ACTIVATE_TIMEOUT = 800;\n\n/**\n * Handles drop interactions for an element, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDrop(options: DropOptions): DropResult {\n  let {hasDropButton, isDisabled} = options;\n  let [isDropTarget, setDropTarget] = useState(false);\n  let state = useRef({\n    x: 0,\n    y: 0,\n    dragOverElements: new Set<Element>(),\n    dropEffect: 'none' as DataTransfer['dropEffect'],\n    allowedOperations: DROP_OPERATION.all,\n    dropActivateTimer: null\n  }).current;\n\n  let fireDropEnter = (e: DragEvent) => {\n    setDropTarget(true);\n\n    if (typeof options.onDropEnter === 'function') {\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      options.onDropEnter({\n        type: 'dropenter',\n        x: e.clientX - rect.x,\n        y: e.clientY - rect.y\n      });\n    }\n  };\n\n  let fireDropExit = (e: DragEvent) => {\n    setDropTarget(false);\n\n    if (typeof options.onDropExit === 'function') {\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      options.onDropExit({\n        type: 'dropexit',\n        x: e.clientX - rect.x,\n        y: e.clientY - rect.y\n      });\n    }\n  };\n\n  let onDragOver = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    let allowedOperations = getAllowedOperations(e);\n    if (e.clientX === state.x && e.clientY === state.y && allowedOperations === state.allowedOperations) {\n      e.dataTransfer.dropEffect = state.dropEffect;\n      return;\n    }\n\n    state.x = e.clientX;\n    state.y = e.clientY;\n\n    let prevDropEffect = state.dropEffect;\n\n    // Update drop effect if allowed drop operations changed (e.g. user pressed modifier key).\n    if (allowedOperations !== state.allowedOperations) {\n      let allowedOps = allowedOperationsToArray(allowedOperations);\n      let dropOperation = allowedOps[0];\n      if (typeof options.getDropOperation === 'function') {\n        let types = new DragTypes(e.dataTransfer);\n        dropOperation = getDropOperation(allowedOperations, options.getDropOperation(types, allowedOps));\n      }\n      state.dropEffect = DROP_OPERATION_TO_DROP_EFFECT[dropOperation] || 'none';\n    }\n\n    if (typeof options.getDropOperationForPoint === 'function') {\n      let types = new DragTypes(e.dataTransfer);\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      let dropOperation = getDropOperation(\n        allowedOperations,\n        options.getDropOperationForPoint(types, allowedOperationsToArray(allowedOperations), state.x - rect.x, state.y - rect.y)\n      );\n      state.dropEffect = DROP_OPERATION_TO_DROP_EFFECT[dropOperation] || 'none';\n    }\n\n    state.allowedOperations = allowedOperations;\n    e.dataTransfer.dropEffect = state.dropEffect;\n\n    // If the drop operation changes, update state and fire events appropriately.\n    if (state.dropEffect === 'none' && prevDropEffect !== 'none') {\n      fireDropExit(e);\n    } else if (state.dropEffect !== 'none' && prevDropEffect === 'none') {\n      fireDropEnter(e);\n    }\n\n    if (typeof options.onDropMove === 'function' && state.dropEffect !== 'none') {\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      options.onDropMove({\n        type: 'dropmove',\n        x: state.x - rect.x,\n        y: state.y - rect.y\n      });\n    }\n\n    clearTimeout(state.dropActivateTimer);\n\n    if (typeof options.onDropActivate === 'function' && state.dropEffect !== 'none') {\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      state.dropActivateTimer = setTimeout(() => {\n        options.onDropActivate({\n          type: 'dropactivate',\n          x: state.x - rect.x,\n          y: state.y - rect.y\n        });\n      }, DROP_ACTIVATE_TIMEOUT);\n    }\n  };\n\n  let onDragEnter = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    state.dragOverElements.add(e.target as Element);\n    if (state.dragOverElements.size > 1) {\n      return;\n    }\n\n    let allowedOperationsBits = getAllowedOperations(e);\n    let allowedOperations = allowedOperationsToArray(allowedOperationsBits);\n    let dropOperation = allowedOperations[0];\n\n    if (typeof options.getDropOperation === 'function') {\n      let types = new DragTypes(e.dataTransfer);\n      dropOperation = getDropOperation(allowedOperationsBits, options.getDropOperation(types, allowedOperations));\n    }\n\n    if (typeof options.getDropOperationForPoint === 'function') {\n      let types = new DragTypes(e.dataTransfer);\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      dropOperation = getDropOperation(\n        allowedOperationsBits,\n        options.getDropOperationForPoint(types, allowedOperations, e.clientX - rect.x, e.clientY - rect.y)\n      );\n    }\n\n    state.x = e.clientX;\n    state.y = e.clientY;\n    state.allowedOperations = allowedOperationsBits;\n    state.dropEffect = DROP_OPERATION_TO_DROP_EFFECT[dropOperation] || 'none';\n    e.dataTransfer.dropEffect = state.dropEffect;\n\n    if (dropOperation !== 'cancel') {\n      fireDropEnter(e);\n    }\n  };\n\n  let onDragLeave = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    // We would use e.relatedTarget to detect if the drag is still inside the drop target,\n    // but it is always null in WebKit. https://bugs.webkit.org/show_bug.cgi?id=66547\n    // Instead, we track all of the targets of dragenter events in a set, and remove them\n    // in dragleave. When the set becomes empty, we've left the drop target completely.\n    // We must also remove any elements that are no longer in the DOM, because dragleave\n    // events will never be fired for these. This can happen, for example, with drop\n    // indicators between items, which disappear when the drop target changes.\n\n    state.dragOverElements.delete(e.target as Element);\n    for (let element of state.dragOverElements) {\n      if (!e.currentTarget.contains(element)) {\n        state.dragOverElements.delete(element);\n      }\n    }\n\n    if (state.dragOverElements.size > 0) {\n      return;\n    }\n\n    if (state.dropEffect !== 'none') {\n      fireDropExit(e);\n    }\n\n    clearTimeout(state.dropActivateTimer);\n  };\n\n  let onDrop = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    // Track drop effect in global state for Chrome Android. https://bugs.chromium.org/p/chromium/issues/detail?id=1353951\n    // Android onDragEnd always returns \"none\" as its drop effect.\n    setGlobalDropEffect(state.dropEffect);\n\n    if (typeof options.onDrop === 'function') {\n      let dropOperation = DROP_EFFECT_TO_DROP_OPERATION[state.dropEffect];\n      let items = readFromDataTransfer(e.dataTransfer);\n\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      let event: DropEvent = {\n        type: 'drop',\n        x: e.clientX - rect.x,\n        y: e.clientY - rect.y,\n        items,\n        dropOperation\n      };\n\n      options.onDrop(event);\n    }\n\n    let dndStateSnapshot = {...globalDndState};\n    state.dragOverElements.clear();\n    fireDropExit(e);\n    clearTimeout(state.dropActivateTimer);\n    // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a\n    // RSP collection and thus we don't need to preserve the global drop effect\n    if (dndStateSnapshot.draggingCollectionRef == null) {\n      setGlobalDropEffect(undefined);\n    } else {\n      // Otherwise we need to preserve the global dnd state for onDragEnd's isInternal check.\n      // At the moment fireDropExit may clear dropCollectionRef (i.e. useDroppableCollection's provided onDropExit, required to clear dropCollectionRef when exiting a valid drop target)\n      setGlobalDnDState(dndStateSnapshot);\n    }\n  };\n\n  let onDropEnter = useEffectEvent((e: DropEnterEvent) => {\n    if (typeof options.onDropEnter === 'function') {\n      options.onDropEnter(e);\n    }\n  });\n\n  let onDropExit = useEffectEvent((e: DropExitEvent) => {\n    if (typeof options.onDropExit === 'function') {\n      options.onDropExit(e);\n    }\n  });\n\n  let onDropActivate = useEffectEvent((e: DropActivateEvent) => {\n    if (typeof options.onDropActivate === 'function') {\n      options.onDropActivate(e);\n    }\n  });\n\n  let onKeyboardDrop = useEffectEvent((e: DropEvent) => {\n    if (typeof options.onDrop === 'function') {\n      options.onDrop(e);\n    }\n  });\n\n  let getDropOperationKeyboard = useEffectEvent((types: IDragTypes, allowedOperations: DropOperation[]) => {\n    if (options.getDropOperation) {\n      return options.getDropOperation(types, allowedOperations);\n    }\n\n    return allowedOperations[0];\n  });\n\n  let {ref} = options;\n  useLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n    return DragManager.registerDropTarget({\n      element: ref.current,\n      getDropOperation: getDropOperationKeyboard,\n      onDropEnter(e) {\n        setDropTarget(true);\n        onDropEnter(e);\n      },\n      onDropExit(e) {\n        setDropTarget(false);\n        onDropExit(e);\n      },\n      onDrop: onKeyboardDrop,\n      onDropActivate\n    });\n  }, [isDisabled, ref, getDropOperationKeyboard, onDropEnter, onDropExit, onKeyboardDrop, onDropActivate]);\n\n  let {dropProps} = useVirtualDrop();\n  if (isDisabled) {\n    return {\n      dropProps: {},\n      dropButtonProps: {isDisabled: true},\n      isDropTarget: false\n    };\n  }\n  return {\n    dropProps: {\n      ...(!hasDropButton && dropProps),\n      onDragEnter,\n      onDragOver,\n      onDragLeave,\n      onDrop\n    },\n    dropButtonProps: {...(hasDropButton && dropProps)},\n    isDropTarget\n  };\n}\n\nfunction getAllowedOperations(e: DragEvent) {\n  let allowedOperations = DROP_OPERATION_ALLOWED[e.dataTransfer.effectAllowed];\n\n  // WebKit always sets effectAllowed to \"copyMove\" on macOS, and \"all\" on iOS, regardless of what was\n  // set during the dragstart event: https://bugs.webkit.org/show_bug.cgi?id=178058\n  //\n  // Android Chrome also sets effectAllowed to \"copyMove\" in all cases: https://bugs.chromium.org/p/chromium/issues/detail?id=1359182\n  //\n  // If the drag started within the page, we can use a global variable to get the real allowed operations.\n  // This needs to be intersected with the actual effectAllowed, which may have been filtered based on modifier keys.\n  // Unfortunately, this means that link operations do not work at all in Safari.\n  if (globalAllowedDropOperations) {\n    allowedOperations &= globalAllowedDropOperations;\n  }\n\n  // Chrome and Safari on macOS will automatically filter effectAllowed when pressing modifier keys,\n  // allowing the user to switch between move, link, and copy operations. Firefox on macOS and all\n  // Windows browsers do not do this, so do it ourselves instead. The exact keys are platform dependent.\n  // https://ux.stackexchange.com/questions/83748/what-are-the-most-common-modifier-keys-for-dragging-objects-with-a-mouse\n  //\n  // Note that none of these modifiers are ever set in WebKit due to a bug: https://bugs.webkit.org/show_bug.cgi?id=77465\n  // However, Safari does update effectAllowed correctly, so we can just rely on that.\n  let allowedModifiers = DROP_OPERATION.none;\n  if (isMac()) {\n    if (e.altKey) {\n      allowedModifiers |= DROP_OPERATION.copy;\n    }\n\n    // Chrome and Safari both use the Control key for link, even though Finder uses Command + Option.\n    // iPadOS doesn't support link operations and will not fire the drop event at all if dropEffect is set to link.\n    // https://bugs.webkit.org/show_bug.cgi?id=244701\n    if (e.ctrlKey && !isIPad()) {\n      allowedModifiers |= DROP_OPERATION.link;\n    }\n\n    if (e.metaKey) {\n      allowedModifiers |= DROP_OPERATION.move;\n    }\n  } else {\n    if (e.altKey) {\n      allowedModifiers |= DROP_OPERATION.link;\n    }\n\n    if (e.shiftKey) {\n      allowedModifiers |= DROP_OPERATION.move;\n    }\n\n    if (e.ctrlKey) {\n      allowedModifiers |= DROP_OPERATION.copy;\n    }\n  }\n\n  if (allowedModifiers) {\n    return allowedOperations & allowedModifiers;\n  }\n\n  return allowedOperations;\n}\n\nfunction allowedOperationsToArray(allowedOperationsBits: DROP_OPERATION) {\n  let allowedOperations = [];\n  if (allowedOperationsBits & DROP_OPERATION.move) {\n    allowedOperations.push('move');\n  }\n\n  if (allowedOperationsBits & DROP_OPERATION.copy) {\n    allowedOperations.push('copy');\n  }\n\n  if (allowedOperationsBits & DROP_OPERATION.link) {\n    allowedOperations.push('link');\n  }\n\n  return allowedOperations;\n}\n\nfunction getDropOperation(allowedOperations: DROP_OPERATION, operation: DropOperation) {\n  let op = DROP_OPERATION[operation];\n  return allowedOperations & op ? operation : 'cancel';\n}\n"],"names":[],"version":3,"file":"useDrop.module.js.map"}