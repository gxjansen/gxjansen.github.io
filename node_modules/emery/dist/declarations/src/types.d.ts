export declare type ErrorLike = {
    message: string;
};
export declare type ObjectEntry<T> = {
    [K in keyof T]: [K, T[K]];
}[keyof T];
export declare type Nullish = null | undefined;
export declare type UnaryPredicate<T> = (value: T) => boolean;
declare const OPAQUE_TAG: unique symbol;
declare type Tagged<Token> = {
    readonly [OPAQUE_TAG]: Token;
};
export declare type ValidOpaqueValues = bigint | number | string | symbol;
/** Create an opaque type. */
export declare type Opaque<Type extends ValidOpaqueValues, Token> = Type & Tagged<Token>;
/** @private Extract the transparent type from an opaque type. */
export declare type Transparent<OpaqueType extends ValidOpaqueValues> = OpaqueType extends bigint ? bigint : OpaqueType extends number ? number : OpaqueType extends string ? string : OpaqueType extends symbol ? symbol : never;
export {};
//# sourceMappingURL=types.d.ts.map