'use strict';

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/**
 * Simplifies `error` handling in `try...catch` statements.
 *
 * JavaScript is weird, you can `throw` anything. Since it's possible for
 * library authors to throw something unexpected, we have to take precautions.
 */
function getErrorMessage(error) {
  var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Unknown error';

  if (isErrorLike(error)) {
    return error.message;
  }

  return error ? JSON.stringify(error) : fallbackMessage;
}
/** Handle situations where the error object isn't an _actual_ error. */

function isErrorLike(error) {
  return _typeof(error) === 'object' && error !== null && 'message' in error && typeof error.message === 'string';
}

/**
 * An alternative to `Object.entries()` that avoids type widening.
 *
 * @example
 * Object.entries({ foo: 1, bar: 2 }) // [string, number][]
 * typedEntries({ foo: 1, bar: 2 }) // ["foo" | "bar", number][]
 */
function typedEntries(value) {
  return Object.entries(value);
}
/**
 * An alternative to `Object.keys()` that avoids type widening.
 *
 * @example
 * Object.keys({ foo: 1, bar: 2 }) // string[]
 * typedKeys({ foo: 1, bar: 2 }) // ("foo" | "bar")[]
 */

function typedKeys(value) {
  return Object.keys(value);
}

exports.getErrorMessage = getErrorMessage;
exports.typedEntries = typedEntries;
exports.typedKeys = typedKeys;
