{"version":3,"file":"urql-exchange-persisted.mjs","sources":["../src/sha256.ts","../src/persistedExchange.ts"],"sourcesContent":["const webCrypto = (\n  typeof window !== 'undefined'\n    ? window.crypto\n    : typeof self !== 'undefined'\n    ? self.crypto\n    : null\n) as typeof globalThis.crypto | null;\n\nlet nodeCrypto: Promise<typeof import('crypto') | void> | void;\n\nconst getNodeCrypto = async (): Promise<typeof import('crypto') | void> => {\n  if (!nodeCrypto) {\n    // Indirect eval'd require/import to guarantee no side-effects in module scope\n    // (optimization for minifiers)\n    try {\n      nodeCrypto = new Function('require', 'return require(\"crypto\")')(require);\n    } catch (_error) {\n      try {\n        nodeCrypto = new Function('return import(\"crypto\")')();\n      } catch (_error) {}\n    }\n  }\n  return nodeCrypto;\n};\n\nexport const hash = async (query: string): Promise<string> => {\n  if (webCrypto && webCrypto.subtle) {\n    const digest = await webCrypto.subtle.digest(\n      { name: 'SHA-256' },\n      new TextEncoder().encode(query)\n    );\n    return new Uint8Array(digest).reduce(\n      (prev, byte) => prev + byte.toString(16).padStart(2, '0'),\n      ''\n    );\n  } else if (await getNodeCrypto()) {\n    // Node.js support\n    return (await nodeCrypto)!.createHash('sha256').update(query).digest('hex');\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn(\n      '[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\\n' +\n        'This is an unexpected error. Please report it by filing a GitHub Issue.'\n    );\n  }\n\n  return '';\n};\n","import {\n  map,\n  makeSubject,\n  fromPromise,\n  filter,\n  merge,\n  mergeMap,\n  takeUntil,\n  pipe,\n} from 'wonka';\n\nimport type {\n  PersistedRequestExtensions,\n  TypedDocumentNode,\n  OperationResult,\n  CombinedError,\n  Exchange,\n  Operation,\n  OperationContext,\n} from '@urql/core';\nimport { makeOperation, stringifyDocument } from '@urql/core';\n\nimport { hash } from './sha256';\n\nconst isPersistedMiss = (error: CombinedError): boolean =>\n  error.graphQLErrors.some(x => x.message === 'PersistedQueryNotFound');\n\nconst isPersistedUnsupported = (error: CombinedError): boolean =>\n  error.graphQLErrors.some(x => x.message === 'PersistedQueryNotSupported');\n\n/** Input parameters for the {@link persistedExchange}. */\nexport interface PersistedExchangeOptions {\n  /** Controls whether GET method requests will be made for Persisted Queries.\n   *\n   * @remarks\n   * When set to `true` or `'within-url-limit'`, the `persistedExchange`\n   * will use GET requests on persisted queries when the request URL\n   * doesn't exceed the 2048 character limit.\n   *\n   * When set to `force`, the `persistedExchange` will set\n   * `OperationContext.preferGetMethod` to `'force'` on persisted queries,\n   * which will force requests to be made using a GET request.\n   *\n   * GET requests are frequently used to make GraphQL requests more\n   * cacheable on CDNs.\n   *\n   * @defaultValue `undefined` - disabled\n   */\n  preferGetForPersistedQueries?: OperationContext['preferGetMethod'];\n  /** Enforces non-automatic persisted queries by ignoring APQ errors.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will ignore `PersistedQueryNotFound`\n   * and `PersistedQueryNotSupported` errors and assume that all persisted\n   * queries are already known to the API.\n   *\n   * This is used to switch from Automatic Persisted Queries to\n   * Persisted Queries. This is commonly used to obfuscate GraphQL\n   * APIs.\n   */\n  enforcePersistedQueries?: boolean;\n  /** Custom hashing function for persisted queries.\n   *\n   * @remarks\n   * By default, `persistedExchange` will create a SHA-256 hash for\n   * persisted queries automatically. If you're instead generating\n   * hashes at compile-time, or need to use a custom SHA-256 function,\n   * you may pass one here.\n   *\n   * If `generateHash` returns either `null` or `undefined`, the\n   * operation will not be treated as a persisted operation, which\n   * essentially skips this exchange’s logic for a given operation.\n   *\n   * Hint: The default SHA-256 function uses the WebCrypto API. This\n   * API is unavailable on React Native, which may require you to\n   * pass a custom function here.\n   */\n  generateHash?(\n    query: string,\n    document: TypedDocumentNode<any, any>\n  ): Promise<string | undefined | null>;\n  /** Enables persisted queries to be used for mutations.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will also use the persisted queries\n   * logic for mutation operations.\n   *\n   * This is disabled by default, but often used on APIs that obfuscate\n   * their GraphQL APIs.\n   */\n  enableForMutation?: boolean;\n  /** Enables persisted queries to be used for subscriptions.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will also use the persisted queries\n   * logic for subscription operations.\n   *\n   * This is disabled by default, but often used on APIs that obfuscate\n   * their GraphQL APIs.\n   */\n  enableForSubscriptions?: boolean;\n}\n\n/** Exchange factory that adds support for Persisted Queries.\n *\n * @param options - A {@link PersistedExchangeOptions} configuration object.\n * @returns the created persisted queries {@link Exchange}.\n *\n * @remarks\n * The `persistedExchange` adds support for (Automatic) Persisted Queries\n * to any `fetchExchange`, `subscriptionExchange`, or other API exchanges\n * following it.\n *\n * It does so by adding the `persistedQuery` extensions field to GraphQL\n * requests and handles `PersistedQueryNotFound` and\n * `PersistedQueryNotSupported` errors.\n *\n * @example\n * ```ts\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n * import { persistedExchange } from '@urql/exchange-persisted';\n *\n * const client = new Client({\n *   url: 'URL',\n *   exchanges: [\n *     cacheExchange,\n *     persistedExchange({\n *       preferGetForPersistedQueries: true,\n *     }),\n *     fetchExchange\n *   ],\n * });\n * ```\n */\nexport const persistedExchange =\n  (options?: PersistedExchangeOptions): Exchange =>\n  ({ forward }) => {\n    if (!options) options = {};\n\n    const preferGetForPersistedQueries = options.preferGetForPersistedQueries;\n    const enforcePersistedQueries = !!options.enforcePersistedQueries;\n    const hashFn = options.generateHash || hash;\n    const enableForMutation = !!options.enableForMutation;\n    const enableForSubscriptions = !!options.enableForSubscriptions;\n    let supportsPersistedQueries = true;\n\n    const operationFilter = (operation: Operation) =>\n      supportsPersistedQueries &&\n      !operation.context.persistAttempt &&\n      ((enableForMutation && operation.kind === 'mutation') ||\n        (enableForSubscriptions && operation.kind === 'subscription') ||\n        operation.kind === 'query');\n\n    const getPersistedOperation = async (operation: Operation) => {\n      const persistedOperation = makeOperation(operation.kind, operation, {\n        ...operation.context,\n        persistAttempt: true,\n      });\n\n      const sha256Hash = await hashFn(\n        stringifyDocument(operation.query),\n        operation.query\n      );\n      if (sha256Hash) {\n        persistedOperation.extensions = {\n          ...persistedOperation.extensions,\n          persistedQuery: {\n            version: 1,\n            sha256Hash,\n          },\n        };\n        if (\n          persistedOperation.kind === 'query' &&\n          preferGetForPersistedQueries\n        ) {\n          persistedOperation.context.preferGetMethod =\n            preferGetForPersistedQueries;\n        }\n      }\n\n      return persistedOperation;\n    };\n\n    return operations$ => {\n      const retries = makeSubject<Operation>();\n\n      const forwardedOps$ = pipe(\n        operations$,\n        filter(operation => !operationFilter(operation))\n      );\n\n      const persistedOps$ = pipe(\n        operations$,\n        filter(operationFilter),\n        mergeMap(operation => {\n          const persistedOperation$ = getPersistedOperation(operation);\n          return pipe(\n            fromPromise(persistedOperation$),\n            takeUntil(\n              pipe(\n                operations$,\n                filter(op => op.kind === 'teardown' && op.key === operation.key)\n              )\n            )\n          );\n        })\n      );\n\n      return pipe(\n        merge([persistedOps$, forwardedOps$, retries.source]),\n        forward,\n        map(result => {\n          if (\n            !enforcePersistedQueries &&\n            result.operation.extensions &&\n            result.operation.extensions.persistedQuery\n          ) {\n            if (result.error && isPersistedUnsupported(result.error)) {\n              // Disable future persisted queries if they're not enforced\n              supportsPersistedQueries = false;\n              // Update operation with unsupported attempt\n              const followupOperation = makeOperation(\n                result.operation.kind,\n                result.operation\n              );\n              if (followupOperation.extensions)\n                delete followupOperation.extensions.persistedQuery;\n              retries.next(followupOperation);\n              return null;\n            } else if (result.error && isPersistedMiss(result.error)) {\n              if (result.operation.extensions.persistedQuery.miss) {\n                if (process.env.NODE_ENV !== 'production') {\n                  console.warn(\n                    'persistedExchange()’s results include two misses for the same operation.\\n' +\n                      'This is not expected as it means a persisted error has been delivered for a non-persisted query!\\n' +\n                      'Another exchange with a cache may be delivering an outdated result. For example, a server-side ssrExchange() may be caching an errored result.\\n' +\n                      'Try moving the persistedExchange() in past these exchanges, for example in front of your fetchExchange.'\n                  );\n                }\n\n                return result;\n              }\n              // Update operation with unsupported attempt\n              const followupOperation = makeOperation(\n                result.operation.kind,\n                result.operation\n              );\n              // Mark as missed persisted query\n              followupOperation.extensions = {\n                ...followupOperation.extensions,\n                persistedQuery: {\n                  ...(followupOperation.extensions || {}).persistedQuery,\n                  miss: true,\n                } as PersistedRequestExtensions,\n              };\n              retries.next(followupOperation);\n              return null;\n            }\n          }\n          return result;\n        }),\n        filter((result): result is OperationResult => !!result)\n      );\n    };\n  };\n"],"names":["webCrypto","window","crypto","self","nodeCrypto","hash","async","subtle","digest","name","TextEncoder","encode","query","Uint8Array","reduce","prev","byte","toString","padStart","Function","require","_error","getNodeCrypto","createHash","update","process","env","NODE_ENV","console","warn","persistedExchange","options","forward","preferGetForPersistedQueries","enforcePersistedQueries","hashFn","generateHash","enableForMutation","enableForSubscriptions","supportsPersistedQueries","operationFilter","operation","context","persistAttempt","kind","operations$","retries","makeSubject","forwardedOps$","filter","persistedOps$","mergeMap","persistedOperation$","persistedOperation","makeOperation","sha256Hash","stringifyDocument","extensions","persistedQuery","version","preferGetMethod","getPersistedOperation","takeUntil","op","key","fromPromise","result","map","error","graphQLErrors","some","x","message","followupOperation","next","isPersistedMiss","miss","merge","source"],"mappings":"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"}