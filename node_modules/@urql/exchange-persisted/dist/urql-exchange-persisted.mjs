import { makeSubject as e, filter as r, mergeMap as t, takeUntil as n, fromPromise as s, map as i, merge as o } from "wonka";

import { makeOperation as a, stringifyDocument as u } from "@urql/core";

var d = "undefined" != typeof window ? window.crypto : "undefined" != typeof self ? self.crypto : null;

var p;

var hash = async e => {
  if (d && d.subtle) {
    var r = await d.subtle.digest({
      name: "SHA-256"
    }, (new TextEncoder).encode(e));
    return new Uint8Array(r).reduce(((e, r) => e + r.toString(16).padStart(2, "0")), "");
  } else if (await (async () => {
    if (!p) {
      try {
        p = new Function("require", 'return require("crypto")')(require);
      } catch (e) {
        try {
          p = new Function('return import("crypto")')();
        } catch (e) {}
      }
    }
    return p;
  })()) {
    return (await p).createHash("sha256").update(e).digest("hex");
  }
  if ("production" !== process.env.NODE_ENV) {
    console.warn("[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\nThis is an unexpected error. Please report it by filing a GitHub Issue.");
  }
  return "";
};

var persistedExchange = d => ({forward: p}) => {
  if (!d) {
    d = {};
  }
  var c = d.preferGetForPersistedQueries;
  var y = !!d.enforcePersistedQueries;
  var f = d.generateHash || hash;
  var h = !!d.enableForMutation;
  var l = !!d.enableForSubscriptions;
  var x = !0;
  var operationFilter = e => x && !e.context.persistAttempt && (h && "mutation" === e.kind || l && "subscription" === e.kind || "query" === e.kind);
  return d => {
    var h = e();
    var l = r((e => !operationFilter(e)))(d);
    var v = t((e => {
      var t = (async e => {
        var r = a(e.kind, e, {
          ...e.context,
          persistAttempt: !0
        });
        var t = await f(u(e.query), e.query);
        if (t) {
          r.extensions = {
            ...r.extensions,
            persistedQuery: {
              version: 1,
              sha256Hash: t
            }
          };
          if ("query" === r.kind && c) {
            r.context.preferGetMethod = c;
          }
        }
        return r;
      })(e);
      return n(r((r => "teardown" === r.kind && r.key === e.key))(d))(s(t));
    }))(r(operationFilter)(d));
    return r((e => !!e))(i((e => {
      if (!y && e.operation.extensions && e.operation.extensions.persistedQuery) {
        if (e.error && e.error.graphQLErrors.some((e => "PersistedQueryNotSupported" === e.message))) {
          x = !1;
          var r = a(e.operation.kind, e.operation);
          if (r.extensions) {
            delete r.extensions.persistedQuery;
          }
          h.next(r);
          return null;
        } else if (e.error && (e => e.graphQLErrors.some((e => "PersistedQueryNotFound" === e.message)))(e.error)) {
          if (e.operation.extensions.persistedQuery.miss) {
            if ("production" !== process.env.NODE_ENV) {
              console.warn("persistedExchange()â€™s results include two misses for the same operation.\nThis is not expected as it means a persisted error has been delivered for a non-persisted query!\nAnother exchange with a cache may be delivering an outdated result. For example, a server-side ssrExchange() may be caching an errored result.\nTry moving the persistedExchange() in past these exchanges, for example in front of your fetchExchange.");
            }
            return e;
          }
          var t = a(e.operation.kind, e.operation);
          t.extensions = {
            ...t.extensions,
            persistedQuery: {
              ...(t.extensions || {}).persistedQuery,
              miss: !0
            }
          };
          h.next(t);
          return null;
        }
      }
      return e;
    }))(p(o([ v, l, h.source ]))));
  };
};

export { persistedExchange };
//# sourceMappingURL=urql-exchange-persisted.mjs.map
