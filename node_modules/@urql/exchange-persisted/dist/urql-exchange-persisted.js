Object.defineProperty(exports, '__esModule', { value: true });

var wonka = require('wonka');
var core = require('@urql/core');

var webCrypto = typeof window !== 'undefined' ? window.crypto : typeof self !== 'undefined' ? self.crypto : null;
var nodeCrypto;
var getNodeCrypto = async () => {
  if (!nodeCrypto) {
    // Indirect eval'd require/import to guarantee no side-effects in module scope
    // (optimization for minifiers)
    try {
      nodeCrypto = new Function('require', 'return require("crypto")')(require);
    } catch (_error) {
      try {
        nodeCrypto = new Function('return import("crypto")')();
      } catch (_error) {}
    }
  }
  return nodeCrypto;
};
var hash = async query => {
  if (webCrypto && webCrypto.subtle) {
    var digest = await webCrypto.subtle.digest({
      name: 'SHA-256'
    }, new TextEncoder().encode(query));
    return new Uint8Array(digest).reduce((prev, byte) => prev + byte.toString(16).padStart(2, '0'), '');
  } else if (await getNodeCrypto()) {
    // Node.js support
    return (await nodeCrypto).createHash('sha256').update(query).digest('hex');
  }
  if (process.env.NODE_ENV !== 'production') {
    console.warn('[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\n' + 'This is an unexpected error. Please report it by filing a GitHub Issue.');
  }
  return '';
};

var isPersistedMiss = error => error.graphQLErrors.some(x => x.message === 'PersistedQueryNotFound');
var isPersistedUnsupported = error => error.graphQLErrors.some(x => x.message === 'PersistedQueryNotSupported');

/** Input parameters for the {@link persistedExchange}. */

/** Exchange factory that adds support for Persisted Queries.
 *
 * @param options - A {@link PersistedExchangeOptions} configuration object.
 * @returns the created persisted queries {@link Exchange}.
 *
 * @remarks
 * The `persistedExchange` adds support for (Automatic) Persisted Queries
 * to any `fetchExchange`, `subscriptionExchange`, or other API exchanges
 * following it.
 *
 * It does so by adding the `persistedQuery` extensions field to GraphQL
 * requests and handles `PersistedQueryNotFound` and
 * `PersistedQueryNotSupported` errors.
 *
 * @example
 * ```ts
 * import { Client, cacheExchange, fetchExchange } from '@urql/core';
 * import { persistedExchange } from '@urql/exchange-persisted';
 *
 * const client = new Client({
 *   url: 'URL',
 *   exchanges: [
 *     cacheExchange,
 *     persistedExchange({
 *       preferGetForPersistedQueries: true,
 *     }),
 *     fetchExchange
 *   ],
 * });
 * ```
 */
var persistedExchange = options => ({
  forward
}) => {
  if (!options) options = {};
  var preferGetForPersistedQueries = options.preferGetForPersistedQueries;
  var enforcePersistedQueries = !!options.enforcePersistedQueries;
  var hashFn = options.generateHash || hash;
  var enableForMutation = !!options.enableForMutation;
  var enableForSubscriptions = !!options.enableForSubscriptions;
  var supportsPersistedQueries = true;
  var operationFilter = operation => supportsPersistedQueries && !operation.context.persistAttempt && (enableForMutation && operation.kind === 'mutation' || enableForSubscriptions && operation.kind === 'subscription' || operation.kind === 'query');
  var getPersistedOperation = async operation => {
    var persistedOperation = core.makeOperation(operation.kind, operation, {
      ...operation.context,
      persistAttempt: true
    });
    var sha256Hash = await hashFn(core.stringifyDocument(operation.query), operation.query);
    if (sha256Hash) {
      persistedOperation.extensions = {
        ...persistedOperation.extensions,
        persistedQuery: {
          version: 1,
          sha256Hash
        }
      };
      if (persistedOperation.kind === 'query' && preferGetForPersistedQueries) {
        persistedOperation.context.preferGetMethod = preferGetForPersistedQueries;
      }
    }
    return persistedOperation;
  };
  return operations$ => {
    var retries = wonka.makeSubject();
    var forwardedOps$ = wonka.filter(operation => !operationFilter(operation))(operations$);
    var persistedOps$ = wonka.mergeMap(operation => {
      var persistedOperation$ = getPersistedOperation(operation);
      return wonka.takeUntil(wonka.filter(op => op.kind === 'teardown' && op.key === operation.key)(operations$))(wonka.fromPromise(persistedOperation$));
    })(wonka.filter(operationFilter)(operations$));
    return wonka.filter(result => !!result)(wonka.map(result => {
      if (!enforcePersistedQueries && result.operation.extensions && result.operation.extensions.persistedQuery) {
        if (result.error && isPersistedUnsupported(result.error)) {
          // Disable future persisted queries if they're not enforced
          supportsPersistedQueries = false;
          // Update operation with unsupported attempt
          var followupOperation = core.makeOperation(result.operation.kind, result.operation);
          if (followupOperation.extensions) delete followupOperation.extensions.persistedQuery;
          retries.next(followupOperation);
          return null;
        } else if (result.error && isPersistedMiss(result.error)) {
          if (result.operation.extensions.persistedQuery.miss) {
            if (process.env.NODE_ENV !== 'production') {
              console.warn('persistedExchange()â€™s results include two misses for the same operation.\n' + 'This is not expected as it means a persisted error has been delivered for a non-persisted query!\n' + 'Another exchange with a cache may be delivering an outdated result. For example, a server-side ssrExchange() may be caching an errored result.\n' + 'Try moving the persistedExchange() in past these exchanges, for example in front of your fetchExchange.');
            }
            return result;
          }
          // Update operation with unsupported attempt
          var _followupOperation = core.makeOperation(result.operation.kind, result.operation);
          // Mark as missed persisted query
          _followupOperation.extensions = {
            ..._followupOperation.extensions,
            persistedQuery: {
              ...(_followupOperation.extensions || {}).persistedQuery,
              miss: true
            }
          };
          retries.next(_followupOperation);
          return null;
        }
      }
      return result;
    })(forward(wonka.merge([persistedOps$, forwardedOps$, retries.source]))));
  };
};

exports.persistedExchange = persistedExchange;
//# sourceMappingURL=urql-exchange-persisted.js.map
