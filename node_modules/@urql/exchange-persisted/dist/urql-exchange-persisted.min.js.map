{"version":3,"file":"urql-exchange-persisted.min.js","sources":["../src/sha256.ts","../src/persistedExchange.ts"],"sourcesContent":["const webCrypto = (\n  typeof window !== 'undefined'\n    ? window.crypto\n    : typeof self !== 'undefined'\n    ? self.crypto\n    : null\n) as typeof globalThis.crypto | null;\n\nlet nodeCrypto: Promise<typeof import('crypto') | void> | void;\n\nconst getNodeCrypto = async (): Promise<typeof import('crypto') | void> => {\n  if (!nodeCrypto) {\n    // Indirect eval'd require/import to guarantee no side-effects in module scope\n    // (optimization for minifiers)\n    try {\n      nodeCrypto = new Function('require', 'return require(\"crypto\")')(require);\n    } catch (_error) {\n      try {\n        nodeCrypto = new Function('return import(\"crypto\")')();\n      } catch (_error) {}\n    }\n  }\n  return nodeCrypto;\n};\n\nexport const hash = async (query: string): Promise<string> => {\n  if (webCrypto && webCrypto.subtle) {\n    const digest = await webCrypto.subtle.digest(\n      { name: 'SHA-256' },\n      new TextEncoder().encode(query)\n    );\n    return new Uint8Array(digest).reduce(\n      (prev, byte) => prev + byte.toString(16).padStart(2, '0'),\n      ''\n    );\n  } else if (await getNodeCrypto()) {\n    // Node.js support\n    return (await nodeCrypto)!.createHash('sha256').update(query).digest('hex');\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn(\n      '[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\\n' +\n        'This is an unexpected error. Please report it by filing a GitHub Issue.'\n    );\n  }\n\n  return '';\n};\n","import {\n  map,\n  makeSubject,\n  fromPromise,\n  filter,\n  merge,\n  mergeMap,\n  takeUntil,\n  pipe,\n} from 'wonka';\n\nimport type {\n  PersistedRequestExtensions,\n  TypedDocumentNode,\n  OperationResult,\n  CombinedError,\n  Exchange,\n  Operation,\n  OperationContext,\n} from '@urql/core';\nimport { makeOperation, stringifyDocument } from '@urql/core';\n\nimport { hash } from './sha256';\n\nconst isPersistedMiss = (error: CombinedError): boolean =>\n  error.graphQLErrors.some(x => x.message === 'PersistedQueryNotFound');\n\nconst isPersistedUnsupported = (error: CombinedError): boolean =>\n  error.graphQLErrors.some(x => x.message === 'PersistedQueryNotSupported');\n\n/** Input parameters for the {@link persistedExchange}. */\nexport interface PersistedExchangeOptions {\n  /** Controls whether GET method requests will be made for Persisted Queries.\n   *\n   * @remarks\n   * When set to `true` or `'within-url-limit'`, the `persistedExchange`\n   * will use GET requests on persisted queries when the request URL\n   * doesn't exceed the 2048 character limit.\n   *\n   * When set to `force`, the `persistedExchange` will set\n   * `OperationContext.preferGetMethod` to `'force'` on persisted queries,\n   * which will force requests to be made using a GET request.\n   *\n   * GET requests are frequently used to make GraphQL requests more\n   * cacheable on CDNs.\n   *\n   * @defaultValue `undefined` - disabled\n   */\n  preferGetForPersistedQueries?: OperationContext['preferGetMethod'];\n  /** Enforces non-automatic persisted queries by ignoring APQ errors.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will ignore `PersistedQueryNotFound`\n   * and `PersistedQueryNotSupported` errors and assume that all persisted\n   * queries are already known to the API.\n   *\n   * This is used to switch from Automatic Persisted Queries to\n   * Persisted Queries. This is commonly used to obfuscate GraphQL\n   * APIs.\n   */\n  enforcePersistedQueries?: boolean;\n  /** Custom hashing function for persisted queries.\n   *\n   * @remarks\n   * By default, `persistedExchange` will create a SHA-256 hash for\n   * persisted queries automatically. If you're instead generating\n   * hashes at compile-time, or need to use a custom SHA-256 function,\n   * you may pass one here.\n   *\n   * If `generateHash` returns either `null` or `undefined`, the\n   * operation will not be treated as a persisted operation, which\n   * essentially skips this exchange’s logic for a given operation.\n   *\n   * Hint: The default SHA-256 function uses the WebCrypto API. This\n   * API is unavailable on React Native, which may require you to\n   * pass a custom function here.\n   */\n  generateHash?(\n    query: string,\n    document: TypedDocumentNode<any, any>\n  ): Promise<string | undefined | null>;\n  /** Enables persisted queries to be used for mutations.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will also use the persisted queries\n   * logic for mutation operations.\n   *\n   * This is disabled by default, but often used on APIs that obfuscate\n   * their GraphQL APIs.\n   */\n  enableForMutation?: boolean;\n  /** Enables persisted queries to be used for subscriptions.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will also use the persisted queries\n   * logic for subscription operations.\n   *\n   * This is disabled by default, but often used on APIs that obfuscate\n   * their GraphQL APIs.\n   */\n  enableForSubscriptions?: boolean;\n}\n\n/** Exchange factory that adds support for Persisted Queries.\n *\n * @param options - A {@link PersistedExchangeOptions} configuration object.\n * @returns the created persisted queries {@link Exchange}.\n *\n * @remarks\n * The `persistedExchange` adds support for (Automatic) Persisted Queries\n * to any `fetchExchange`, `subscriptionExchange`, or other API exchanges\n * following it.\n *\n * It does so by adding the `persistedQuery` extensions field to GraphQL\n * requests and handles `PersistedQueryNotFound` and\n * `PersistedQueryNotSupported` errors.\n *\n * @example\n * ```ts\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n * import { persistedExchange } from '@urql/exchange-persisted';\n *\n * const client = new Client({\n *   url: 'URL',\n *   exchanges: [\n *     cacheExchange,\n *     persistedExchange({\n *       preferGetForPersistedQueries: true,\n *     }),\n *     fetchExchange\n *   ],\n * });\n * ```\n */\nexport const persistedExchange =\n  (options?: PersistedExchangeOptions): Exchange =>\n  ({ forward }) => {\n    if (!options) options = {};\n\n    const preferGetForPersistedQueries = options.preferGetForPersistedQueries;\n    const enforcePersistedQueries = !!options.enforcePersistedQueries;\n    const hashFn = options.generateHash || hash;\n    const enableForMutation = !!options.enableForMutation;\n    const enableForSubscriptions = !!options.enableForSubscriptions;\n    let supportsPersistedQueries = true;\n\n    const operationFilter = (operation: Operation) =>\n      supportsPersistedQueries &&\n      !operation.context.persistAttempt &&\n      ((enableForMutation && operation.kind === 'mutation') ||\n        (enableForSubscriptions && operation.kind === 'subscription') ||\n        operation.kind === 'query');\n\n    const getPersistedOperation = async (operation: Operation) => {\n      const persistedOperation = makeOperation(operation.kind, operation, {\n        ...operation.context,\n        persistAttempt: true,\n      });\n\n      const sha256Hash = await hashFn(\n        stringifyDocument(operation.query),\n        operation.query\n      );\n      if (sha256Hash) {\n        persistedOperation.extensions = {\n          ...persistedOperation.extensions,\n          persistedQuery: {\n            version: 1,\n            sha256Hash,\n          },\n        };\n        if (\n          persistedOperation.kind === 'query' &&\n          preferGetForPersistedQueries\n        ) {\n          persistedOperation.context.preferGetMethod =\n            preferGetForPersistedQueries;\n        }\n      }\n\n      return persistedOperation;\n    };\n\n    return operations$ => {\n      const retries = makeSubject<Operation>();\n\n      const forwardedOps$ = pipe(\n        operations$,\n        filter(operation => !operationFilter(operation))\n      );\n\n      const persistedOps$ = pipe(\n        operations$,\n        filter(operationFilter),\n        mergeMap(operation => {\n          const persistedOperation$ = getPersistedOperation(operation);\n          return pipe(\n            fromPromise(persistedOperation$),\n            takeUntil(\n              pipe(\n                operations$,\n                filter(op => op.kind === 'teardown' && op.key === operation.key)\n              )\n            )\n          );\n        })\n      );\n\n      return pipe(\n        merge([persistedOps$, forwardedOps$, retries.source]),\n        forward,\n        map(result => {\n          if (\n            !enforcePersistedQueries &&\n            result.operation.extensions &&\n            result.operation.extensions.persistedQuery\n          ) {\n            if (result.error && isPersistedUnsupported(result.error)) {\n              // Disable future persisted queries if they're not enforced\n              supportsPersistedQueries = false;\n              // Update operation with unsupported attempt\n              const followupOperation = makeOperation(\n                result.operation.kind,\n                result.operation\n              );\n              if (followupOperation.extensions)\n                delete followupOperation.extensions.persistedQuery;\n              retries.next(followupOperation);\n              return null;\n            } else if (result.error && isPersistedMiss(result.error)) {\n              if (result.operation.extensions.persistedQuery.miss) {\n                if (process.env.NODE_ENV !== 'production') {\n                  console.warn(\n                    'persistedExchange()’s results include two misses for the same operation.\\n' +\n                      'This is not expected as it means a persisted error has been delivered for a non-persisted query!\\n' +\n                      'Another exchange with a cache may be delivering an outdated result. For example, a server-side ssrExchange() may be caching an errored result.\\n' +\n                      'Try moving the persistedExchange() in past these exchanges, for example in front of your fetchExchange.'\n                  );\n                }\n\n                return result;\n              }\n              // Update operation with unsupported attempt\n              const followupOperation = makeOperation(\n                result.operation.kind,\n                result.operation\n              );\n              // Mark as missed persisted query\n              followupOperation.extensions = {\n                ...followupOperation.extensions,\n                persistedQuery: {\n                  ...(followupOperation.extensions || {}).persistedQuery,\n                  miss: true,\n                } as PersistedRequestExtensions,\n              };\n              retries.next(followupOperation);\n              return null;\n            }\n          }\n          return result;\n        }),\n        filter((result): result is OperationResult => !!result)\n      );\n    };\n  };\n"],"names":["nodeCrypto","webCrypto","window","crypto","self","hash","async","subtle","digest","name","TextEncoder","encode","query","Uint8Array","reduce","prev","byte","toString","padStart","Function","require","_error","getNodeCrypto","createHash","update","options","forward","preferGetForPersistedQueries","enforcePersistedQueries","hashFn","generateHash","enableForMutation","enableForSubscriptions","supportsPersistedQueries","operationFilter","operation","context","persistAttempt","kind","operations$","retries","makeSubject","forwardedOps$","filter","persistedOps$","mergeMap","persistedOperation$","persistedOperation","makeOperation","sha256Hash","stringifyDocument","extensions","persistedQuery","version","preferGetMethod","getPersistedOperation","takeUntil","op","key","fromPromise","result","map","error","graphQLErrors","some","x","message","followupOperation","next","miss","merge","source"],"mappings":"2DAQIA,6CAREC,EACc,oBAAXC,OACHA,OAAOC,OACS,oBAATC,KACPA,KAAKD,OACL,KAoBOE,EAAOC,UAClB,GAAIL,GAAaA,EAAUM,OAAQ,CACjC,IAAMC,QAAeP,EAAUM,OAAOC,OACpC,CAAEC,KAAM,YACR,IAAIC,aAAcC,OAAOC,IAE3B,OAAO,IAAIC,WAAWL,GAAQM,QAC5B,CAACC,EAAMC,IAASD,EAAOC,EAAKC,SAAS,IAAIC,SAAS,EAAG,MACrD,GAEJ,CAAO,YAzBaZ,WACpB,IAAKN,EAGH,IACEA,EAAa,IAAImB,SAAS,UAAW,2BAAxB,CAAoDC,QAClE,CAAC,MAAOC,GACP,IACErB,EAAa,IAAImB,SAAS,0BAAb,EACf,CAAE,MAAOE,GAAS,CACpB,CAEF,OAAOrB,CAAU,EAaAsB,UAEDtB,GAAauB,WAAW,UAAUC,OAAOZ,GAAOJ,OAAO,OAUhE,EAAE,4BCwFRiB,GACD,EAAGC,cACID,IAASA,EAAU,IAExB,IAAME,EAA+BF,EAAQE,6BACvCC,IAA4BH,EAAQG,wBACpCC,EAASJ,EAAQK,cAAgBzB,EACjC0B,IAAsBN,EAAQM,kBAC9BC,IAA2BP,EAAQO,uBACrCC,GAA2B,EAEzBC,EAAmBC,GACvBF,IACCE,EAAUC,QAAQC,iBACjBN,GAAwC,aAAnBI,EAAUG,MAC9BN,GAA6C,iBAAnBG,EAAUG,MAClB,UAAnBH,EAAUG,MAgCd,OAAOC,IACL,IAAMC,EAAUC,EAAAA,cAEVC,EAEJC,EAAMA,QAACR,IAAcD,EAAgBC,IAArCQ,CADAJ,GAIIK,EAGJC,EAAQA,UAACV,IACP,IAAMW,EA1CkBxC,WAC5B,IAAMyC,EAAqBC,EAAaA,cAACb,EAAUG,KAAMH,EAAW,IAC/DA,EAAUC,QACbC,gBAAgB,IAGZY,QAAmBpB,EACvBqB,EAAiBA,kBAACf,EAAUvB,OAC5BuB,EAAUvB,OAmBZ,OAjBIqC,IACFF,EAAmBI,WAAa,IAC3BJ,EAAmBI,WACtBC,eAAgB,CACdC,QAAS,EACTJ,eAI0B,UAA5BF,EAAmBT,MACnBX,IAEAoB,EAAmBX,QAAQkB,gBACzB3B,IAICoB,CAAkB,EAeOQ,CAAsBpB,GAClD,OAEEqB,EAAAA,UAGIb,EAAAA,QAAOc,GAAkB,aAAZA,EAAGnB,MAAuBmB,EAAGC,MAAQvB,EAAUuB,KAA5Df,CADAJ,GAFJiB,CADAG,EAAWA,YAACb,GAAoB,GAHpCD,CADAF,EAAAA,OAAOT,EAAPS,CADAJ,IAgBF,OAqDEI,EAAAA,QAAQiB,KAAwCA,GAAhDjB,CAlDAkB,EAAGA,KAACD,IACF,IACGhC,GACDgC,EAAOzB,UAAUgB,YACjBS,EAAOzB,UAAUgB,WAAWC,eAC5B,CACA,GAAIQ,EAAOE,OAAgCF,EAAOE,MA7LtDC,cAAcC,MAAKC,GAAmB,+BAAdA,EAAEC,UA6LoC,CAExDjC,GAA2B,EAE3B,IAAMkC,EAAoBnB,EAAAA,cACxBY,EAAOzB,UAAUG,KACjBsB,EAAOzB,WAKT,OAHIgC,EAAkBhB,mBACbgB,EAAkBhB,WAAWC,eACtCZ,EAAQ4B,KAAKD,GACN,IACT,CAAO,GAAIP,EAAOE,OAAyBF,EAAOE,MA5MtDC,cAAcC,MAAKC,GAAmB,2BAAdA,EAAEC,UA4MoC,CACxD,GAAIN,EAAOzB,UAAUgB,WAAWC,eAAeiB,KAU7C,OAAOT,EAGT,IAAMO,EAAoBnB,EAAAA,cACxBY,EAAOzB,UAAUG,KACjBsB,EAAOzB,WAWT,OARAgC,EAAkBhB,WAAa,IAC1BgB,EAAkBhB,WACrBC,eAAgB,KACVe,EAAkBhB,YAAc,CAAA,GAAIC,eACxCiB,MAAM,IAGV7B,EAAQ4B,KAAKD,GACN,IACT,CACF,CACA,OAAOP,CAAM,GAhDfC,CADAnC,EADA4C,EAAKA,MAAC,CAAC1B,EAAeF,EAAeF,EAAQ+B,WAAQ,CAsDxD"}