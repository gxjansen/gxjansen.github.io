{"version":3,"file":"urql-exchange-auth.js","sources":["../src/authExchange.ts"],"sourcesContent":["import {\n  Source,\n  pipe,\n  map,\n  filter,\n  onStart,\n  take,\n  makeSubject,\n  toPromise,\n  merge,\n} from 'wonka';\n\nimport {\n  createRequest,\n  makeOperation,\n  makeErrorResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n  CombinedError,\n  Exchange,\n  DocumentInput,\n  AnyVariables,\n  OperationInstance,\n} from '@urql/core';\n\n/** Utilities to use while refreshing authentication tokens. */\nexport interface AuthUtilities {\n  /** Sends a mutation to your GraphQL API, bypassing earlier exchanges and authentication.\n   *\n   * @param query - a GraphQL document containing the mutation operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param context - {@link OperationContext} options that'll be used in future exchanges.\n   * @returns A `Promise` of an {@link OperationResult} for the GraphQL mutation.\n   *\n   * @remarks\n   * The `mutation()` utility method is useful when your authentication requires you to make a GraphQL mutation\n   * request to update your authentication tokens. In these cases, you likely wish to bypass prior exchanges and\n   * the authentication in the `authExchange` itself.\n   *\n   * This method bypasses the usual mutation flow of the `Client` and instead issues the mutation as directly\n   * as possible. This also means that it doesn’t carry your `Client`'s default {@link OperationContext}\n   * options, so you may have to pass them again, if needed.\n   */\n  mutate<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): Promise<OperationResult<Data>>;\n\n  /** Adds additional HTTP headers to an `Operation`.\n   *\n   * @param operation - An {@link Operation} to add headers to.\n   * @param headers - The HTTP headers to add to the `Operation`.\n   * @returns The passed {@link Operation} with the headers added to it.\n   *\n   * @remarks\n   * The `appendHeaders()` utility method is useful to add additional HTTP headers\n   * to an {@link Operation}. It’s a simple convenience function that takes\n   * `operation.context.fetchOptions` into account, since adding headers for\n   * authentication is common.\n   */\n  appendHeaders(\n    operation: Operation,\n    headers: Record<string, string>\n  ): Operation;\n}\n\n/** Configuration for the `authExchange` returned by the initializer function you write. */\nexport interface AuthConfig {\n  /** Called for every operation to add authentication data to your operation.\n   *\n   * @param operation - An {@link Operation} that needs authentication tokens added.\n   * @returns a new {@link Operation} with added authentication tokens.\n   *\n   * @remarks\n   * The {@link authExchange} will call this function you provide and expects that you\n   * add your authentication tokens to your operation here, on the {@link Operation}\n   * that is returned.\n   *\n   * Hint: You likely want to modify your `fetchOptions.headers` here, for instance to\n   * add an `Authorization` header.\n   */\n  addAuthToOperation(operation: Operation): Operation;\n\n  /** Called before an operation is forwaded onwards to make a request.\n   *\n   * @param operation - An {@link Operation} that needs authentication tokens added.\n   * @returns a boolean, if true, authentication must be refreshed.\n   *\n   * @remarks\n   * The {@link authExchange} will call this function before an {@link Operation} is\n   * forwarded onwards to your following exchanges.\n   *\n   * When this function returns `true`, the `authExchange` will call\n   * {@link AuthConfig.refreshAuth} before forwarding more operations\n   * to prompt you to update your authentication tokens.\n   *\n   * Hint: If you define this function, you can use it to check whether your authentication\n   * tokens have expired.\n   */\n  willAuthError?(operation: Operation): boolean;\n\n  /** Called after receiving an operation result to check whether it has failed with an authentication error.\n   *\n   * @param error - A {@link CombinedError} that a result has come back with.\n   * @param operation - The {@link Operation} of that has failed.\n   * @returns a boolean, if true, authentication must be refreshed.\n   *\n   * @remarks\n   * The {@link authExchange} will call this function if it sees an {@link OperationResult}\n   * with a {@link CombinedError} on it, implying that it may have failed due to an authentication\n   * error.\n   *\n   * When this function returns `true`, the `authExchange` will call\n   * {@link AuthConfig.refreshAuth} before forwarding more operations\n   * to prompt you to update your authentication tokens.\n   * Afterwards, this operation will be retried once.\n   *\n   * Hint: You should define a function that detects your API’s authentication\n   * errors, e.g. using `result.extensions`.\n   */\n  didAuthError(error: CombinedError, operation: Operation): boolean;\n\n  /** Called to refresh the authentication state.\n   *\n   * @remarks\n   * The {@link authExchange} will call this function if either {@link AuthConfig.willAuthError}\n   * or {@link AuthConfig.didAuthError} have returned `true` prior, which indicates that the\n   * authentication state you hold has expired or is out-of-date.\n   *\n   * When this function is called, you should refresh your authentication state.\n   * For instance, if you have a refresh token and an access token, you should rotate\n   * these tokens with your API by sending the refresh token.\n   *\n   * Hint: You can use the {@link fetch} API here, or use {@link AuthUtilities.mutate}\n   * if your API requires a GraphQL mutation to refresh your authentication state.\n   */\n  refreshAuth(): Promise<void>;\n}\n\nconst addAuthAttemptToOperation = (\n  operation: Operation,\n  authAttempt: boolean\n) =>\n  makeOperation(operation.kind, operation, {\n    ...operation.context,\n    authAttempt,\n  });\n\n/** Creates an `Exchange` handling control flow for authentication.\n *\n * @param init - An initializer function that returns an {@link AuthConfig} wrapped in a `Promise`.\n * @returns the created authentication {@link Exchange}.\n *\n * @remarks\n * The `authExchange` is used to create an exchange handling authentication and\n * the control flow of refresh authentication.\n *\n * You must pass an initializer function, which receives {@link AuthUtilities} and\n * must return an {@link AuthConfig} wrapped in a `Promise`.\n * When this exchange is used in your `Client`, it will first call your initializer\n * function, which gives you an opportunity to get your authentication state, e.g.\n * from local storage.\n *\n * You may then choose to validate this authentication state and update it, and must\n * then return an {@link AuthConfig}.\n *\n * This configuration defines how you add authentication state to {@link Operation | Operations},\n * when your authentication state expires, when an {@link OperationResult} has errored\n * with an authentication error, and how to refresh your authentication state.\n *\n * @example\n * ```ts\n * authExchange(async (utils) => {\n *   let token = localStorage.getItem('token');\n *   let refreshToken = localStorage.getItem('refreshToken');\n *   return {\n *     addAuthToOperation(operation) {\n *       return utils.appendHeaders(operation, {\n *         Authorization: `Bearer ${token}`,\n *       });\n *     },\n *     didAuthError(error) {\n *       return error.graphQLErrors.some(e => e.extensions?.code === 'FORBIDDEN');\n *     },\n *     async refreshAuth() {\n *       const result = await utils.mutate(REFRESH, { token });\n *       if (result.data?.refreshLogin) {\n *         token = result.data.refreshLogin.token;\n *         refreshToken = result.data.refreshLogin.refreshToken;\n *         localStorage.setItem('token', token);\n *         localStorage.setItem('refreshToken', refreshToken);\n *       }\n *     },\n *   };\n * });\n * ```\n */\nexport function authExchange(\n  init: (utilities: AuthUtilities) => Promise<AuthConfig>\n): Exchange {\n  return ({ client, forward }) => {\n    const bypassQueue = new Set<OperationInstance | undefined>();\n    const retries = makeSubject<Operation>();\n    const errors = makeSubject<OperationResult>();\n\n    let retryQueue = new Map<number, Operation>();\n\n    function flushQueue() {\n      authPromise = undefined;\n      const queue = retryQueue;\n      retryQueue = new Map();\n      queue.forEach(retries.next);\n    }\n\n    function errorQueue(error: Error) {\n      authPromise = undefined;\n      const queue = retryQueue;\n      retryQueue = new Map();\n      queue.forEach(operation => {\n        errors.next(makeErrorResult(operation, error));\n      });\n    }\n\n    let authPromise: Promise<void> | void;\n    let config: AuthConfig | null = null;\n\n    return operations$ => {\n      function initAuth() {\n        authPromise = Promise.resolve()\n          .then(() =>\n            init({\n              mutate<Data = any, Variables extends AnyVariables = AnyVariables>(\n                query: DocumentInput<Data, Variables>,\n                variables: Variables,\n                context?: Partial<OperationContext>\n              ): Promise<OperationResult<Data>> {\n                const baseOperation = client.createRequestOperation(\n                  'mutation',\n                  createRequest(query, variables),\n                  context\n                );\n                return pipe(\n                  result$,\n                  onStart(() => {\n                    const operation = addAuthToOperation(baseOperation);\n                    bypassQueue.add(\n                      operation.context._instance as OperationInstance\n                    );\n                    retries.next(operation);\n                  }),\n                  filter(\n                    result =>\n                      result.operation.key === baseOperation.key &&\n                      baseOperation.context._instance ===\n                        result.operation.context._instance\n                  ),\n                  take(1),\n                  toPromise\n                );\n              },\n              appendHeaders(\n                operation: Operation,\n                headers: Record<string, string>\n              ) {\n                const fetchOptions =\n                  typeof operation.context.fetchOptions === 'function'\n                    ? operation.context.fetchOptions()\n                    : operation.context.fetchOptions || {};\n                return makeOperation(operation.kind, operation, {\n                  ...operation.context,\n                  fetchOptions: {\n                    ...fetchOptions,\n                    headers: {\n                      ...fetchOptions.headers,\n                      ...headers,\n                    },\n                  },\n                });\n              },\n            })\n          )\n          .then((_config: AuthConfig) => {\n            if (_config) config = _config;\n            flushQueue();\n          })\n          .catch((error: Error) => {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn(\n                'authExchange()’s initialization function has failed, which is unexpected.\\n' +\n                  'If your initialization function is expected to throw/reject, catch this error and handle it explicitly.\\n' +\n                  'Unless this error is handled it’ll be passed onto any `OperationResult` instantly and authExchange() will block further operations and retry.',\n                error\n              );\n            }\n\n            errorQueue(error);\n          });\n      }\n\n      initAuth();\n\n      function refreshAuth(operation: Operation) {\n        // add to retry queue to try again later\n        retryQueue.set(\n          operation.key,\n          addAuthAttemptToOperation(operation, true)\n        );\n\n        // check that another operation isn't already doing refresh\n        if (config && !authPromise) {\n          authPromise = config.refreshAuth().then(flushQueue).catch(errorQueue);\n        }\n      }\n\n      function willAuthError(operation: Operation) {\n        return (\n          !operation.context.authAttempt &&\n          config &&\n          config.willAuthError &&\n          config.willAuthError(operation)\n        );\n      }\n\n      function didAuthError(result: OperationResult) {\n        return (\n          config &&\n          config.didAuthError &&\n          config.didAuthError(result.error!, result.operation)\n        );\n      }\n\n      function addAuthToOperation(operation: Operation) {\n        return config ? config.addAuthToOperation(operation) : operation;\n      }\n\n      const opsWithAuth$ = pipe(\n        merge([retries.source, operations$]),\n        map(operation => {\n          if (operation.kind === 'teardown') {\n            retryQueue.delete(operation.key);\n            return operation;\n          } else if (\n            operation.context._instance &&\n            bypassQueue.has(operation.context._instance)\n          ) {\n            return operation;\n          } else if (operation.context.authAttempt) {\n            return addAuthToOperation(operation);\n          } else if (authPromise || !config) {\n            if (!authPromise) initAuth();\n\n            if (!retryQueue.has(operation.key))\n              retryQueue.set(\n                operation.key,\n                addAuthAttemptToOperation(operation, false)\n              );\n\n            return null;\n          } else if (willAuthError(operation)) {\n            refreshAuth(operation);\n            return null;\n          }\n\n          return addAuthToOperation(\n            addAuthAttemptToOperation(operation, false)\n          );\n        }),\n        filter(Boolean)\n      ) as Source<Operation>;\n\n      const result$ = pipe(opsWithAuth$, forward);\n\n      return merge([\n        errors.source,\n        pipe(\n          result$,\n          filter(result => {\n            if (\n              !bypassQueue.has(result.operation.context._instance) &&\n              result.error &&\n              didAuthError(result) &&\n              !result.operation.context.authAttempt\n            ) {\n              refreshAuth(result.operation);\n              return false;\n            }\n\n            if (bypassQueue.has(result.operation.context._instance)) {\n              bypassQueue.delete(result.operation.context._instance);\n            }\n\n            return true;\n          })\n        ),\n      ]);\n    };\n  };\n}\n"],"names":["addAuthAttemptToOperation","operation","authAttempt","makeOperation","kind","context","authExchange","init","client","forward","bypassQueue","Set","retries","makeSubject","errors","retryQueue","Map","flushQueue","authPromise","undefined","queue","forEach","next","errorQueue","error","makeErrorResult","config","operations$","initAuth","Promise","resolve","then","mutate","query","variables","baseOperation","createRequestOperation","createRequest","toPromise","take","filter","result","key","_instance","onStart","addAuthToOperation","add","result$","appendHeaders","headers","fetchOptions","_config","catch","process","env","NODE_ENV","console","warn","refreshAuth","set","willAuthError","didAuthError","opsWithAuth$","Boolean","map","delete","has","merge","source"],"mappings":"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"}