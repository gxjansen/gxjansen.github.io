import { makeSubject as t, filter as e, map as n, merge as r, toPromise as o, take as i, onStart as a } from "wonka";

import { makeOperation as u, createRequest as c, makeErrorResult as h } from "@urql/core";

var addAuthAttemptToOperation = (t, e) => u(t.kind, t, {
  ...t.context,
  authAttempt: e
});

function authExchange(s) {
  return ({client: f, forward: d}) => {
    var l = new Set;
    var p = t();
    var x = t();
    var A = new Map;
    function flushQueue() {
      v = void 0;
      var t = A;
      A = new Map;
      t.forEach(p.next);
    }
    function errorQueue(t) {
      v = void 0;
      var e = A;
      A = new Map;
      e.forEach((e => {
        x.next(h(e, t));
      }));
    }
    var v;
    var w = null;
    return t => {
      function initAuth() {
        v = Promise.resolve().then((() => s({
          mutate(t, n, r) {
            var u = f.createRequestOperation("mutation", c(t, n), r);
            return o(i(1)(e((t => t.operation.key === u.key && u.context._instance === t.operation.context._instance))(a((() => {
              var t = addAuthToOperation(u);
              l.add(t.context._instance);
              p.next(t);
            }))(E))));
          },
          appendHeaders(t, e) {
            var n = "function" == typeof t.context.fetchOptions ? t.context.fetchOptions() : t.context.fetchOptions || {};
            return u(t.kind, t, {
              ...t.context,
              fetchOptions: {
                ...n,
                headers: {
                  ...n.headers,
                  ...e
                }
              }
            });
          }
        }))).then((t => {
          if (t) {
            w = t;
          }
          flushQueue();
        })).catch((t => {
          if ("production" !== process.env.NODE_ENV) {
            console.warn("authExchange()’s initialization function has failed, which is unexpected.\nIf your initialization function is expected to throw/reject, catch this error and handle it explicitly.\nUnless this error is handled it’ll be passed onto any `OperationResult` instantly and authExchange() will block further operations and retry.", t);
          }
          errorQueue(t);
        }));
      }
      initAuth();
      function refreshAuth(t) {
        A.set(t.key, addAuthAttemptToOperation(t, !0));
        if (w && !v) {
          v = w.refreshAuth().then(flushQueue).catch(errorQueue);
        }
      }
      function addAuthToOperation(t) {
        return w ? w.addAuthToOperation(t) : t;
      }
      var h = e(Boolean)(n((t => {
        if ("teardown" === t.kind) {
          A.delete(t.key);
          return t;
        } else if (t.context._instance && l.has(t.context._instance)) {
          return t;
        } else if (t.context.authAttempt) {
          return addAuthToOperation(t);
        } else if (v || !w) {
          if (!v) {
            initAuth();
          }
          if (!A.has(t.key)) {
            A.set(t.key, addAuthAttemptToOperation(t, !1));
          }
          return null;
        } else if (function willAuthError(t) {
          return !t.context.authAttempt && w && w.willAuthError && w.willAuthError(t);
        }(t)) {
          refreshAuth(t);
          return null;
        }
        return addAuthToOperation(addAuthAttemptToOperation(t, !1));
      }))(r([ p.source, t ])));
      var E = d(h);
      return r([ x.source, e((t => {
        if (!l.has(t.operation.context._instance) && t.error && function didAuthError(t) {
          return w && w.didAuthError && w.didAuthError(t.error, t.operation);
        }(t) && !t.operation.context.authAttempt) {
          refreshAuth(t.operation);
          return !1;
        }
        if (l.has(t.operation.context._instance)) {
          l.delete(t.operation.context._instance);
        }
        return !0;
      }))(E) ]);
    };
  };
}

export { authExchange };
//# sourceMappingURL=urql-exchange-auth.mjs.map
