import { stringifyVariables as e, formatDocument as r, createRequest as t, makeOperation as a, stringifyDocument as i } from "@urql/core";

import { Kind as n, valueFromASTUntyped as o } from "@0no-co/graphql.web";

import { share as s, map as l, filter as v, merge as d, mergeMap as c, empty as u, fromArray as p, makeSubject as f, onPush as y } from "wonka";

var h = "\nhttps://bit.ly/2XbVrpR#";

var m = new Set;

var g = [];

var popDebugNode = () => g.pop();

var pushDebugNode = (e, r) => {
  var t = "";
  if (r.kind === n.INLINE_FRAGMENT) {
    t = e ? `Inline Fragment on "${e}"` : "Inline Fragment";
  } else if (r.kind === n.OPERATION_DEFINITION) {
    t = `${r.name ? `"${r.name.value}"` : "Unnamed"} ${r.operation}`;
  } else if (r.kind === n.FRAGMENT_DEFINITION) {
    t = `"${r.name.value}" Fragment`;
  }
  if (t) {
    g.push(t);
  }
};

var getDebugOutput = () => g.length ? "\n(Caused At: " + g.join(", ") + ")" : "";

function invariant(e, r, t) {
  if (!e) {
    var a = r || "Minfied Error #" + t + "\n";
    if ("production" !== process.env.NODE_ENV) {
      a += getDebugOutput();
    }
    var i = new Error(a + h + t);
    i.name = "Graphcache Error";
    throw i;
  }
}

function warn(e, r, t) {
  if (!m.has(e)) {
    if (t) {
      t("warn", e + getDebugOutput() + h + r);
    } else {
      console.warn(e + getDebugOutput() + h + r);
    }
    m.add(e);
  }
}

var _ = {};

var getDirectives = e => e._directives || _;

var getName = e => e.name.value;

var getFragmentTypeName = e => e.typeCondition.name.value;

var getFieldAlias = e => e.alias ? e.alias.value : e.name.value;

var N = [];

var getSelectionSet = e => e.selectionSet ? e.selectionSet.selections : N;

var getTypeCondition = e => e.typeCondition ? e.typeCondition.name.value : null;

var getFieldArguments = (e, r) => {
  var t = null;
  if (e.arguments) {
    for (var a = 0, i = e.arguments.length; a < i; a++) {
      var n = e.arguments[a];
      var s = o(n.value, r);
      if (null != s) {
        if (!t) {
          t = {};
        }
        t[getName(n)] = s;
      }
    }
  }
  return t;
};

var filterVariables = (e, r) => {
  if (!r || !e.variableDefinitions) {
    return;
  }
  var t = {};
  for (var a = 0, i = e.variableDefinitions.length; a < i; a++) {
    var n = getName(e.variableDefinitions[a].variable);
    t[n] = r[n];
  }
  return t;
};

var normalizeVariables = (e, r) => {
  var t = {};
  if (!r) {
    return t;
  }
  if (e.variableDefinitions) {
    for (var a = 0, i = e.variableDefinitions.length; a < i; a++) {
      var n = e.variableDefinitions[a];
      var s = getName(n.variable);
      t[s] = void 0 === r[s] && n.defaultValue ? o(n.defaultValue, r) : r[s];
    }
  }
  for (var l in r) {
    if (!(l in t)) {
      t[l] = r[l];
    }
  }
  return t;
};

function getMainOperation(e) {
  for (var r = 0; r < e.definitions.length; r++) {
    if (e.definitions[r].kind === n.OPERATION_DEFINITION) {
      return e.definitions[r];
    }
  }
  invariant(!1, "production" !== process.env.NODE_ENV ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
}

var getFragments = e => {
  var r = {};
  for (var t = 0; t < e.definitions.length; t++) {
    var a = e.definitions[t];
    if (a.kind === n.FRAGMENT_DEFINITION) {
      r[getName(a)] = a;
    }
  }
  return r;
};

var shouldInclude = (e, r) => {
  var t = getDirectives(e);
  if (t.include || t.skip) {
    for (var a in t) {
      var i = t[a];
      if (i && ("include" === a || "skip" === a) && i.arguments && i.arguments[0] && "if" === getName(i.arguments[0])) {
        var n = o(i.arguments[0].value, r);
        return "include" === a ? !!n : !n;
      }
    }
  }
  return !0;
};

var isDeferred = (e, r) => {
  var {defer: t} = getDirectives(e);
  if (t) {
    for (var a of t.arguments || []) {
      if ("if" === getName(a)) {
        return !!o(a.value, r);
      }
    }
    return !0;
  }
  return !1;
};

var isOptional = e => {
  var {optional: r, required: t} = getDirectives(e);
  if (t) {
    return !1;
  }
  if (r) {
    return !0;
  }
  return;
};

var k = "__";

var isFieldNullable = (e, r, t, a) => {
  var i = getField(e, r, t, a);
  return !!i && "NON_NULL" !== i.type.kind;
};

var isListNullable = (e, r, t, a) => {
  var i = getField(e, r, t, a);
  if (!i) {
    return !1;
  }
  var n = "NON_NULL" === i.type.kind ? i.type.ofType : i.type;
  return "LIST" === n.kind && "NON_NULL" !== n.ofType.kind;
};

var isFieldAvailableOnType = (e, r, t, a) => 0 === t.indexOf(k) || 0 === r.indexOf(k) || !!getField(e, r, t, a);

var isInterfaceOfType = (e, r, t) => {
  if (!t) {
    return !1;
  }
  var a = getTypeCondition(r);
  if (!a || t === a) {
    return !0;
  } else if (e.types.has(a) && "OBJECT" === e.types.get(a).kind) {
    return a === t;
  }
  !function expectAbstractType(e, r) {
    invariant(e.types.has(r) && ("INTERFACE" === e.types.get(r).kind || "UNION" === e.types.get(r).kind), "production" !== process.env.NODE_ENV ? "Invalid Abstract type: The type `" + r + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5);
  }(e, a);
  expectObjectType(e, t);
  return e.isSubType(a, t);
};

var getField = (e, r, t, a) => {
  if (0 === t.indexOf(k) || 0 === r.indexOf(k)) {
    return;
  }
  expectObjectType(e, r);
  var i = e.types.get(r).fields()[t];
  if ("production" !== process.env.NODE_ENV) {
    if (!i) {
      warn("Invalid field: The field `" + t + "` does not exist on `" + r + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4, a);
    }
  }
  return i;
};

function expectObjectType(e, r) {
  invariant(e.types.has(r) && "OBJECT" === e.types.get(r).kind, "production" !== process.env.NODE_ENV ? "Invalid Object type: The type `" + r + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}

function warnAboutResolver(e, r) {
  "production" !== process.env.NODE_ENV && warn(`Invalid resolver: \`${e}\` is not in the defined schema, but the \`resolvers\` option is referencing it.`, 23, r);
}

function warnAboutAbstractResolver(e, r, t) {
  "production" !== process.env.NODE_ENV && warn(`Invalid resolver: \`${e}\` does not match to a concrete type in the schema, but the \`resolvers\` option is referencing it. Implement the resolver for the types that ${"UNION" === r ? "make up the union" : "implement the interface"} instead.`, 26, t);
}

var keyOfField = (r, t) => t ? `${r}(${e(t)})` : r;

var joinKeys = (e, r) => `${e}.${r}`;

var fieldInfoOfKey = e => {
  var r = e.indexOf("(");
  if (r > -1) {
    return {
      fieldKey: e,
      fieldName: e.slice(0, r),
      arguments: JSON.parse(e.slice(r + 1, -1))
    };
  } else {
    return {
      fieldKey: e,
      fieldName: e,
      arguments: null
    };
  }
};

var deserializeKeyInfo = e => {
  var r = e.indexOf(".");
  return {
    entityKey: e.slice(0, r).replace(/%2e/g, "."),
    fieldKey: e.slice(r + 1)
  };
};

var E = null;

var O = null;

var w = null;

var b = null;

var D = null;

var x = null;

var V = !1;

var I = !1;

function makeData(e, r) {
  var t;
  if (e) {
    if (E.has(e)) {
      return e;
    }
    t = O.get(e);
  }
  if (null == t) {
    t = r ? [] : {};
  }
  if (e) {
    O.set(e, t);
  }
  E.add(t);
  return t;
}

var ownsData = e => !!e && E.has(e);

var initDataState = (e, r, t, a, i) => {
  E = new WeakSet;
  O = new WeakMap;
  D = e;
  w = r;
  x = new Set;
  I = !!a;
  V = !!i;
  if ("production" !== process.env.NODE_ENV) {
    g.length = 0;
  }
  if (!t) {
    b = null;
  } else if ("read" === D) {
    b = t;
  } else if (a || r.hydrating || r.optimisticOrder.length > 1) {
    if (!a && !r.commutativeKeys.has(t)) {
      reserveLayer(r, t);
    } else if (a) {
      if (-1 !== r.optimisticOrder.indexOf(t) && !r.commutativeKeys.has(t)) {
        r.optimisticOrder.splice(r.optimisticOrder.indexOf(t), 1);
      }
      r.commutativeKeys.delete(t);
    }
    b = t;
    createLayer(r, t);
  } else {
    b = null;
    deleteLayer(r, t);
  }
};

var clearDataState = () => {
  if ("production" !== process.env.NODE_ENV) {
    getCurrentDependencies();
  }
  var e = w;
  var r = b;
  I = !1;
  b = null;
  if (!e.hydrating && r && e.optimisticOrder.indexOf(r) > -1) {
    var t = e.optimisticOrder.length;
    while (--t >= 0 && e.dirtyKeys.has(e.optimisticOrder[t]) && e.commutativeKeys.has(e.optimisticOrder[t])) {
      squashLayer(e.optimisticOrder[t]);
    }
  }
  E = null;
  O = null;
  D = null;
  w = null;
  x = null;
  if ("production" !== process.env.NODE_ENV) {
    g.length = 0;
  }
  if ("test" !== process.env.NODE_ENV) {
    if (!e.defer && (e.storage || !e.optimisticOrder.length)) {
      e.defer = !0;
      setTimeout((() => {
        initDataState("read", e, null);
        gc();
        persistData();
        clearDataState();
        e.defer = !1;
      }));
    }
  }
};

var noopDataState = (e, r, t) => {
  if (r && !t) {
    e.deferredKeys.delete(r);
  }
  initDataState("write", e, r, t);
  clearDataState();
};

var getCurrentDependencies = () => {
  invariant(null !== x, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return x;
};

var q = new Set;

var setNode = (e, r, t, a) => {
  if ("production" !== process.env.NODE_ENV) {
    invariant("read" !== D, "production" !== process.env.NODE_ENV ? "Invalid Cache write: You may not write to the cache during cache reads.  Accesses to `cache.writeFragment`, `cache.updateQuery`, and `cache.link` may  not be made inside `resolvers` for instance." : "", 27);
  }
  var i = b ? e.optimistic.get(b) : e.base;
  var n = i.get(r);
  if (void 0 === n) {
    i.set(r, n = Object.create(null));
  }
  if (void 0 === a && !b) {
    delete n[t];
  } else {
    n[t] = a;
  }
};

var getNode = (e, r, t) => {
  var a;
  var i = !I && "read" === D && b && w.commutativeKeys.has(b);
  for (var n = 0, o = w.optimisticOrder.length; n < o; n++) {
    var s = w.optimisticOrder[n];
    var l = e.optimistic.get(s);
    i = i && s !== b;
    if (l && (!i || !w.commutativeKeys.has(s)) && (!I || "write" === D || w.commutativeKeys.has(s)) && void 0 !== (a = l.get(r)) && t in a) {
      return a[t];
    }
  }
  return void 0 !== (a = e.base.get(r)) ? a[t] : void 0;
};

function getRefCount(e) {
  return w.refCount.get(e) || 0;
}

var updateRCForLink = (e, r) => {
  if (Array.isArray(e)) {
    for (var t = 0, a = e.length; t < a; t++) {
      updateRCForLink(e[t], r);
    }
  } else if ("string" == typeof e) {
    ((e, r) => {
      var t = getRefCount(e);
      var a = t + r > 0 ? t + r : 0;
      w.refCount.set(e, a);
      if (!a) {
        w.gc.add(e);
      } else if (!t && a) {
        w.gc.delete(e);
      }
    })(e, r);
  }
};

var extractNodeFields = (e, r, t) => {
  if (void 0 !== t) {
    for (var a in t) {
      if (!r.has(a)) {
        e.push(fieldInfoOfKey(a));
        r.add(a);
      }
    }
  }
};

var extractNodeMapFields = (e, r, t, a) => {
  extractNodeFields(e, r, a.base.get(t));
  for (var i = 0, n = w.optimisticOrder.length; i < n; i++) {
    var o = a.optimistic.get(w.optimisticOrder[i]);
    if (void 0 !== o) {
      extractNodeFields(e, r, o.get(t));
    }
  }
};

var gc = () => {
  if (w.optimisticOrder.length) {
    return;
  }
  for (var e of w.gc.keys()) {
    w.gc.delete(e);
    if (getRefCount(e) > 0) {
      continue;
    }
    var r = w.records.base.get(e);
    w.refCount.delete(e);
    w.records.base.delete(e);
    var t = r && r.__typename;
    if (t) {
      var a = w.types.get(t);
      if (a) {
        a.delete(e);
      }
    }
    var i = w.links.base.get(e);
    if (i) {
      w.links.base.delete(e);
      for (var n in i) {
        updateRCForLink(i[n], -1);
      }
    }
  }
};

var updateDependencies = (e, r) => {
  if (e !== w.queryRootKey) {
    x.add(e);
  } else if (void 0 !== r && "__typename" !== r) {
    x.add(joinKeys(e, r));
  }
};

var updatePersist = (e, r) => {
  if (!I && w.storage) {
    w.persist.add(((e, r) => `${e.replace(/\./g, "%2e")}.${r}`)(e, r));
  }
};

var readRecord = (e, r) => {
  if ("read" === D) {
    updateDependencies(e, r);
  }
  return getNode(w.records, e, r);
};

var readLink = (e, r) => {
  if ("read" === D) {
    updateDependencies(e, r);
  }
  return getNode(w.links, e, r);
};

var writeConcreteType = (e, r) => {
  var t = w.abstractToConcreteMap.get(e);
  if (!t) {
    var a = new Set;
    a.add(r);
    w.abstractToConcreteMap.set(e, a);
  } else {
    t.add(r);
  }
};

var writeRecord = (e, r, t) => {
  if (!isEqualLinkOrScalar(getNode(w.records, e, r), t)) {
    updateDependencies(e, r);
    updatePersist(e, r);
  }
  setNode(w.records, e, r, t);
};

var hasField = (e, r) => void 0 !== readRecord(e, r) || void 0 !== readLink(e, r);

var writeLink = (e, r, t) => {
  var a = b ? w.links.optimistic.get(b) : w.links.base;
  if (!b) {
    var i = a && a.get(e);
    updateRCForLink(i && i[r], -1);
    updateRCForLink(t, 1);
  }
  if (!isEqualLinkOrScalar(getNode(w.links, e, r), t)) {
    updateDependencies(e, r);
    updatePersist(e, r);
  }
  setNode(w.links, e, r, t);
};

var reserveLayer = (e, r, t) => {
  var a = e.optimisticOrder.indexOf(r);
  if (a > -1) {
    e.optimisticOrder.splice(a, 1);
  }
  if (t) {
    e.deferredKeys.add(r);
    for (a = a > -1 ? a : 0; a < e.optimisticOrder.length && !e.deferredKeys.has(e.optimisticOrder[a]) && (!e.dirtyKeys.has(e.optimisticOrder[a]) || !e.commutativeKeys.has(e.optimisticOrder[a])); a++) {}
  } else {
    e.deferredKeys.delete(r);
    if (a > -1 && !e.commutativeKeys.has(r)) {
      clearLayer(e, r);
    }
    a = 0;
  }
  e.optimisticOrder.splice(a, 0, r);
  e.commutativeKeys.add(r);
};

var createLayer = (e, r) => {
  if (-1 === e.optimisticOrder.indexOf(r)) {
    e.optimisticOrder.unshift(r);
  }
  if (!e.dirtyKeys.has(r)) {
    e.dirtyKeys.add(r);
    e.links.optimistic.set(r, new Map);
    e.records.optimistic.set(r, new Map);
  }
};

var clearLayer = (e, r) => {
  if (e.dirtyKeys.has(r)) {
    e.dirtyKeys.delete(r);
    e.records.optimistic.delete(r);
    e.links.optimistic.delete(r);
    e.deferredKeys.delete(r);
  }
};

var deleteLayer = (e, r) => {
  var t = e.optimisticOrder.indexOf(r);
  if (t > -1) {
    e.optimisticOrder.splice(t, 1);
    e.commutativeKeys.delete(r);
  }
  clearLayer(e, r);
};

var squashLayer = e => {
  var r = x;
  x = new Set;
  D = "write";
  var t = w.links.optimistic.get(e);
  if (t) {
    for (var a of t.entries()) {
      var i = a[0];
      var n = a[1];
      for (var o in n) {
        writeLink(i, o, n[o]);
      }
    }
  }
  var s = w.records.optimistic.get(e);
  if (s) {
    for (var l of s.entries()) {
      var v = l[0];
      var d = l[1];
      for (var c in d) {
        writeRecord(v, c, d[c]);
      }
    }
  }
  x = r;
  deleteLayer(w, e);
};

var inspectFields = e => {
  var {links: r, records: t} = w;
  var a = [];
  var i = new Set;
  updateDependencies(e);
  extractNodeMapFields(a, i, e, r);
  extractNodeMapFields(a, i, e, t);
  return a;
};

var persistData = () => {
  if (w.storage) {
    I = !0;
    D = "read";
    var r = {};
    for (var t of w.persist.keys()) {
      var {entityKey: a, fieldKey: i} = deserializeKeyInfo(t);
      var n = void 0;
      if (void 0 !== (n = readLink(a, i))) {
        r[t] = `:${e(n)}`;
      } else if (void 0 !== (n = readRecord(a, i))) {
        r[t] = e(n);
      } else {
        r[t] = void 0;
      }
    }
    I = !1;
    w.storage.writeData(r);
    w.persist.clear();
  }
};

function isEqualLinkOrScalar(e, r) {
  if (typeof e != typeof r) {
    return !1;
  }
  if (e !== r) {
    return !1;
  }
  if (Array.isArray(e) && Array.isArray(r)) {
    if (e.length !== r.length) {
      return !1;
    }
    return !e.some(((e, t) => e !== r[t]));
  }
  return !0;
}

var S = null;

var A = !1;

var T = void 0;

var getFieldError = e => e.__internal.path.length > 0 && e.__internal.errorMap ? e.__internal.errorMap[e.__internal.path.join(".")] : void 0;

var makeContext = (e, r, t, a, i, n) => {
  var o = {
    store: e,
    variables: r,
    fragments: t,
    parent: {
      __typename: a
    },
    parentTypeName: a,
    parentKey: i,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: !1,
    hasNext: !1,
    optimistic: I,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (n && n.graphQLErrors) {
    for (var s = 0; s < n.graphQLErrors.length; s++) {
      var l = n.graphQLErrors[s];
      if (l.path && l.path.length) {
        if (!o.__internal.errorMap) {
          o.__internal.errorMap = Object.create(null);
        }
        o.__internal.errorMap[l.path.join(".")] = l;
      }
    }
  }
  return o;
};

var updateContext = (e, r, t, a, i, n) => {
  S = e;
  e.parent = r;
  e.parentTypeName = t;
  e.parentKey = a;
  e.parentFieldKey = i;
  e.fieldName = n;
  e.error = getFieldError(e);
};

var isFragmentHeuristicallyMatching = (e, r, t, a, i) => {
  if (!r) {
    return !1;
  }
  var o = getTypeCondition(e);
  if (!o || r === o) {
    return !0;
  }
  "production" !== process.env.NODE_ENV && warn("Heuristic Fragment Matching: A fragment is trying to match against the `" + r + "` type, but the type condition is `" + o + "`. Since GraphQL allows for interfaces `" + o + "` may be an interface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16, i);
  return !getSelectionSet(e).some((e => {
    if (e.kind !== n.FIELD) {
      return !1;
    }
    var r = keyOfField(getName(e), getFieldArguments(e, a));
    return !hasField(t, r);
  }));
};

class SelectionIterator {
  constructor(e, r, t, a, i, n) {
    this.typename = e;
    this.entityKey = r;
    this.ctx = n;
    this.stack = [ {
      selectionSet: i,
      index: 0,
      defer: t,
      optional: a
    } ];
  }
  next() {
    while (this.stack.length > 0) {
      var e = this.stack[this.stack.length - 1];
      while (e.index < e.selectionSet.length) {
        var r = e.selectionSet[e.index++];
        if (!shouldInclude(r, this.ctx.variables)) {} else if (r.kind !== n.FIELD) {
          var t = r.kind !== n.INLINE_FRAGMENT ? this.ctx.fragments[getName(r)] : r;
          if (t) {
            var a = !t.typeCondition || (this.ctx.store.schema ? isInterfaceOfType(this.ctx.store.schema, t, this.typename) : "read" === D && isFragmentMatching(t.typeCondition.name.value, this.typename) || isFragmentHeuristicallyMatching(t, this.typename, this.entityKey, this.ctx.variables, this.ctx.store.logger));
            if (a || "write" === D && !this.ctx.store.schema) {
              if ("production" !== process.env.NODE_ENV) {
                pushDebugNode(this.typename, t);
              }
              var i = isOptional(r);
              if (a && t.typeCondition && this.typename !== t.typeCondition.name.value) {
                writeConcreteType(t.typeCondition.name.value, this.typename);
              }
              this.stack.push(e = {
                selectionSet: getSelectionSet(t),
                index: 0,
                defer: e.defer || isDeferred(r, this.ctx.variables),
                optional: void 0 !== i ? i : e.optional
              });
            }
          }
        } else if ("write" === D || !r._generated) {
          A = e.defer;
          T = e.optional;
          return r;
        }
      }
      this.stack.pop();
      if ("production" !== process.env.NODE_ENV) {
        popDebugNode();
      }
    }
    return;
  }
}

var isFragmentMatching = (e, r) => {
  if (!r) {
    return !1;
  }
  if (e === r) {
    return !0;
  }
  var t = !(e => w.types.has(e))(e);
  if (!t) {
    return !1;
  }
  var a = (e => w.abstractToConcreteMap.get(e) || q)(e);
  return a.size && a.has(r);
};

var ensureData = e => null == e ? null : e;

var ensureLink = (e, r) => {
  if (!r) {
    return r || null;
  } else if (Array.isArray(r)) {
    var t = new Array(r.length);
    for (var a = 0, i = t.length; a < i; a++) {
      t[a] = ensureLink(e, r[a]);
    }
    return t;
  }
  var n = e.keyOfEntity(r);
  if ("production" !== process.env.NODE_ENV) {
    if (!n && r && "object" == typeof r) {
      warn("Can't generate a key for link(...) item.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + r.__typename + "`.", 12, e.logger);
    }
  }
  return n;
};

var _query = (e, t, a, i) => {
  var n = r(t.query);
  var o = getMainOperation(n);
  var s = e.rootFields[o.operation];
  var l = getSelectionSet(o);
  var v = makeContext(e, normalizeVariables(o, t.variables), getFragments(n), s, s, i);
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(s, o);
  }
  var d = s !== v.store.rootFields.query ? readRoot(v, s, l, a || makeData()) : readSelection(v, s, l, a || makeData());
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
    getCurrentDependencies();
  }
  return {
    dependencies: x,
    partial: v.partial || !d,
    hasNext: v.hasNext,
    data: d || null
  };
};

var readRoot = (e, r, t, a) => {
  if ("string" != typeof (e.store.rootNames[r] ? r : a.__typename)) {
    return a;
  }
  var i = new SelectionIterator(r, r, !1, void 0, t, e);
  var n;
  var o = V;
  var s = makeData(a);
  while (n = i.next()) {
    var l = getFieldAlias(n);
    var v = a[l];
    e.__internal.path.push(l);
    var d = void 0;
    if (n.selectionSet && null !== v) {
      d = readRootField(e, getSelectionSet(n), ensureData(v));
    } else {
      d = v;
    }
    o = o || d !== v;
    if (void 0 !== d) {
      s[l] = d;
    }
    e.__internal.path.pop();
  }
  return o ? s : a;
};

var readRootField = (e, r, t) => {
  if (Array.isArray(t)) {
    var a = new Array(t.length);
    var i = V;
    for (var n = 0, o = t.length; n < o; n++) {
      e.__internal.path.push(n);
      a[n] = readRootField(e, r, t[n]);
      i = i || a[n] !== t[n];
      e.__internal.path.pop();
    }
    return i ? a : t;
  } else if (null === t) {
    return null;
  }
  var s = e.store.keyOfEntity(t);
  if (null !== s) {
    return readSelection(e, s, r, t) || null;
  } else {
    return readRoot(e, t.__typename, r, t);
  }
};

function getFieldResolver(e, r, t, a) {
  var i = a.store.resolvers[r];
  var n = i && i[t];
  var o;
  for (var s in e) {
    var l = e[s];
    if (l && "include" !== s && "skip" !== s && a.store.directives[s]) {
      o = a.store.directives[s](getFieldArguments(l, a.variables));
      if ("production" === process.env.NODE_ENV) {
        return o;
      }
      break;
    }
  }
  if ("production" !== process.env.NODE_ENV) {
    if (n && o) {
      warn(`A resolver and directive is being used at "${r}.${t}" simultaneously. Only the directive will apply.`, 28, a.store.logger);
    }
  }
  return o || n;
}

var readSelection = (e, r, t, a, i) => {
  var {store: n} = e;
  var o = r === n.rootFields.query;
  var s = i && n.keyOfEntity(i) || r;
  if ("production" !== process.env.NODE_ENV) {
    if (!o && e.store.rootNames[s]) {
      warn("Invalid root traversal: A selection was being read on `" + s + "` which is an uncached root type.\nThe `" + e.store.rootFields.mutation + "` and `" + e.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25, n.logger);
    }
  }
  var l = !o ? readRecord(s, "__typename") || i && i.__typename : r;
  if ("string" != typeof l) {
    return;
  } else if (i && l !== i.__typename) {
    "production" !== process.env.NODE_ENV && warn("Invalid resolver data: The resolver at `" + s + "` returned an invalid typename that could not be reconciled with the cache.", 8, n.logger);
    return;
  }
  var v = new SelectionIterator(l, s, !1, void 0, t, e);
  var d = !1;
  var c = !1;
  var u = V;
  var p;
  var f = e.partial;
  var y = makeData(a);
  while (void 0 !== (p = v.next())) {
    var h = getName(p);
    var m = getFieldArguments(p, e.variables);
    var g = getFieldAlias(p);
    var _ = getDirectives(p);
    var N = getFieldResolver(_, l, h, e);
    var k = keyOfField(h, m);
    var E = joinKeys(s, k);
    var O = readRecord(s, k);
    var w = i ? i[h] : void 0;
    if ("production" !== process.env.NODE_ENV && n.schema && l) {
      isFieldAvailableOnType(n.schema, l, h, e.store.logger);
    }
    e.__internal.path.push(g);
    var b = void 0;
    if ("__typename" === h) {
      b = l;
    } else if (void 0 !== w && void 0 === p.selectionSet) {
      b = w;
    } else if ("read" === D && N) {
      var x = y;
      if (void 0 === p.selectionSet && void 0 !== O) {
        x = {
          ...y,
          [g]: O,
          [h]: O
        };
      }
      updateContext(e, x, l, s, k, h);
      b = N(x, m || {}, n, e);
      if (p.selectionSet) {
        b = resolveResolverResult(e, l, h, E, getSelectionSet(p), void 0 !== y[g] ? y[g] : a[g], b, ownsData(a));
      }
      if (n.schema && null === b && !isFieldNullable(n.schema, l, h, e.store.logger)) {
        return;
      }
    } else if (!p.selectionSet) {
      b = O;
    } else if (void 0 !== w) {
      b = resolveResolverResult(e, l, h, E, getSelectionSet(p), void 0 !== y[g] ? y[g] : a[g], w, ownsData(a));
    } else {
      var I = readLink(s, k);
      if (void 0 !== I) {
        b = resolveLink(e, I, l, h, getSelectionSet(p), void 0 !== y[g] ? y[g] : a[g], ownsData(a));
      } else if ("object" == typeof O && null !== O) {
        b = O;
      }
    }
    if (!A && void 0 === b && (_.optional || T && !_.required || getFieldError(e) || !_.required && n.schema && isFieldNullable(n.schema, l, h, e.store.logger))) {
      e.partial = !0;
      b = null;
    } else if (null === b && (_.required || !1 === T)) {
      if (e.store.logger && "production" !== process.env.NODE_ENV && "read" === D) {
        e.store.logger("debug", `Got value "null" for required field "${h}"${m ? ` with args ${JSON.stringify(m)}` : ""} on entity "${s}"`);
      }
      b = void 0;
    } else {
      d = d || "__typename" !== h;
    }
    e.__internal.path.pop();
    u = u || b !== a[g];
    if (void 0 !== b) {
      y[g] = b;
    } else if (A) {
      c = !0;
    } else {
      if (e.store.logger && "production" !== process.env.NODE_ENV && "read" === D) {
        e.store.logger("debug", `No value for field "${h}"${m ? ` with args ${JSON.stringify(m)}` : ""} on entity "${s}"`);
      }
      e.partial = f;
      return;
    }
  }
  e.partial = e.partial || f;
  e.hasNext = e.hasNext || c;
  return o && e.partial && !d ? void 0 : u ? y : a;
};

var resolveResolverResult = (e, r, t, a, i, n, o, s) => {
  if (Array.isArray(o)) {
    var {store: l} = e;
    var v = l.schema ? isListNullable(l.schema, r, t, e.store.logger) : !1;
    var d = e.partial;
    var c = makeData(n, !0);
    var u = V || !Array.isArray(n) || o.length !== n.length;
    for (var p = 0, f = o.length; p < f; p++) {
      e.__internal.path.push(p);
      var y = resolveResolverResult(e, r, t, joinKeys(a, `${p}`), i, null != n ? n[p] : void 0, o[p], s);
      e.__internal.path.pop();
      if (void 0 === y && !v) {
        e.partial = d;
        return;
      } else {
        e.partial = e.partial || void 0 === y && v;
        c[p] = null != y ? y : null;
        u = u || c[p] !== n[p];
      }
    }
    return u ? c : n;
  } else if (null == o) {
    return o;
  } else if (s && null === n) {
    return null;
  } else if (isDataOrKey(o)) {
    var h = n || makeData(n);
    return "string" == typeof o ? readSelection(e, o, i, h) : readSelection(e, a, i, h, o);
  } else {
    "production" !== process.env.NODE_ENV && warn("Invalid resolver value: The field at `" + a + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9, e.store.logger);
    return;
  }
};

var resolveLink = (e, r, t, a, i, n, o) => {
  if (Array.isArray(r)) {
    var {store: s} = e;
    var l = s.schema ? isListNullable(s.schema, t, a, e.store.logger) : !1;
    var v = makeData(n, !0);
    var d = e.partial;
    var c = V || !Array.isArray(n) || r.length !== n.length;
    for (var u = 0, p = r.length; u < p; u++) {
      e.__internal.path.push(u);
      var f = resolveLink(e, r[u], t, a, i, null != n ? n[u] : void 0, o);
      e.__internal.path.pop();
      if (void 0 === f && !l) {
        e.partial = d;
        return;
      } else {
        e.partial = e.partial || void 0 === f && l;
        v[u] = f || null;
        c = c || v[u] !== n[u];
      }
    }
    return c ? v : n;
  } else if (null === r || null === n && o) {
    return null;
  }
  return readSelection(e, r, i, n || makeData(n));
};

var isDataOrKey = e => "string" == typeof e || "object" == typeof e && "string" == typeof e.__typename;

var invalidateEntity = (e, r, t) => {
  var a = r ? [ {
    fieldKey: keyOfField(r, t)
  } ] : inspectFields(e);
  for (var i = 0, n = a.length; i < n; i++) {
    var {fieldKey: o} = a[i];
    if (void 0 !== readLink(e, o)) {
      writeLink(e, o, void 0);
    } else {
      writeRecord(e, o, void 0);
    }
  }
};

var invalidateType = (e, r) => {
  var t = (e => w.types.get(e) || q)(e);
  for (var a of t) {
    if (r.includes(a)) {
      continue;
    }
    invalidateEntity(a);
  }
};

var _write = (e, t, a, i) => {
  if ("production" !== process.env.NODE_ENV) {
    getCurrentDependencies();
  }
  var n = r(t.query);
  var o = getMainOperation(n);
  var s = {
    data: a || makeData(),
    dependencies: x
  };
  var l = e.rootFields[o.operation];
  var v = makeContext(e, normalizeVariables(o, t.variables), getFragments(n), l, l, i);
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(l, o);
  }
  writeSelection(v, l, getSelectionSet(o), s.data);
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
  }
  return s;
};

var writeSelection = (e, r, t, a) => {
  var i = e.store.rootNames[r] || "query";
  var n = !!e.store.rootNames[r];
  var o = n ? r : a.__typename;
  if (!o && r && e.optimistic) {
    o = readRecord(r, "__typename");
  }
  if (!o) {
    "production" !== process.env.NODE_ENV && warn("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14, e.store.logger);
    return;
  } else if (!n && r) {
    writeRecord(r, "__typename", o);
    ((e, r) => {
      var t = w.types.get(e);
      if (!t) {
        var a = new Set;
        a.add(r);
        w.types.set(e, a);
      } else {
        t.add(r);
      }
    })(o, r);
  }
  var s = e.store.updates[o];
  var l = new SelectionIterator(o, r || o, !1, void 0, t, e);
  var v;
  while (v = l.next()) {
    var d = getName(v);
    var c = getFieldArguments(v, e.variables);
    var u = keyOfField(d, c);
    var p = getFieldAlias(v);
    var f = a[e.optimistic ? d : p];
    if ("__typename" === d || void 0 === f && (A || e.optimistic && "query" === i)) {
      continue;
    }
    if ("production" !== process.env.NODE_ENV) {
      if (e.store.schema && o && "__typename" !== d) {
        isFieldAvailableOnType(e.store.schema, o, d, e.store.logger);
      }
    }
    e.__internal.path.push(p);
    var y = void 0;
    if (e.optimistic && "mutation" === i) {
      if (!(y = e.store.optimisticMutations[d])) {
        continue;
      }
    } else if (e.optimistic && "function" == typeof f) {
      y = f;
    }
    if (y) {
      updateContext(e, a, o, r || o, u, d);
      f = ensureData(y(c || {}, e.store, e));
    }
    if (void 0 === f) {
      if ("production" !== process.env.NODE_ENV) {
        if (!r || !hasField(r, u) || e.optimistic && !readRecord(r, "__typename")) {
          "production" !== process.env.NODE_ENV && warn("Invalid undefined: The field at `" + u + "` is `undefined`, but the GraphQL query expects a " + (void 0 === v.selectionSet ? "scalar (number, boolean, etc)" : "selection set") + " for this field.", 13, e.store.logger);
        }
      }
      continue;
    }
    if (v.selectionSet) {
      if (r && "query" === i) {
        var h = joinKeys(r, u);
        var m = writeField(e, getSelectionSet(v), ensureData(f), h, e.optimistic ? readLink(r || o, u) : void 0);
        writeLink(r || o, u, m);
      } else {
        writeField(e, getSelectionSet(v), ensureData(f));
      }
    } else if (r && "query" === i) {
      writeRecord(r || o, u, null !== f || !getFieldError(e) ? f : void 0);
    }
    var g = s && s[d];
    if (g) {
      updateContext(e, a, o, r || o, u, d);
      a[d] = f;
      g(a, c || {}, e.store, e);
    } else if (o === e.store.rootFields.mutation && !e.optimistic) {
      if (f && Array.isArray(f)) {
        var _ = f.map((r => e.store.keyOfEntity(r) || ""));
        for (var N = 0, k = f.length; N < k; N++) {
          var E = _[N];
          if (E && f[N].__typename) {
            var O = readRecord(E, "__typename");
            var b = getRefCount(E);
            if (O && !b) {
              invalidateType(f[N].__typename, _);
            }
          }
        }
      } else if (f && "object" == typeof f) {
        var D = e.store.keyOfEntity(f);
        if (D) {
          var x = readRecord(D, "__typename");
          var V = getRefCount(D);
          if ((!x || !V) && f.__typename) {
            invalidateType(f.__typename, [ D ]);
          }
        }
      }
    }
    e.__internal.path.pop();
  }
};

var M = /^__|PageInfo|(Connection|Edge)$/;

var writeField = (e, r, t, a, i) => {
  if (Array.isArray(t)) {
    var n = new Array(t.length);
    for (var o = 0, s = t.length; o < s; o++) {
      e.__internal.path.push(o);
      var l = a ? joinKeys(a, `${o}`) : void 0;
      var v = writeField(e, r, t[o], l, null != i ? i[o] : void 0);
      n[o] = v;
      e.__internal.path.pop();
    }
    return n;
  } else if (null === t) {
    return getFieldError(e) ? void 0 : null;
  }
  var d = e.store.keyOfEntity(t) || ("string" == typeof i ? i : null);
  var c = t.__typename;
  if ("production" !== process.env.NODE_ENV) {
    if (a && !e.store.keys[t.__typename] && null === d && "string" == typeof c && !M.test(c)) {
      warn("Invalid key: The GraphQL query at the field at `" + a + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + c + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + c + "` that always returns null.", 15, e.store.logger);
    }
  }
  var u = d || a;
  writeSelection(e, u, r, t);
  return u || null;
};

class Store {
  constructor(e) {
    if (!e) {
      e = {};
    }
    this.logger = e.logger;
    this.resolvers = e.resolvers || {};
    this.directives = e.directives || {};
    this.optimisticMutations = e.optimistic || {};
    this.keys = e.keys || {};
    this.globalIDs = Array.isArray(e.globalIDs) ? new Set(e.globalIDs) : !!e.globalIDs;
    var r = "Query";
    var t = "Mutation";
    var a = "Subscription";
    if (e.schema) {
      var i = (({__schema: e}) => {
        var r = new Map;
        var buildNameMap = e => {
          var r;
          return () => {
            if (!r) {
              r = {};
              for (var t = 0; t < e.length; t++) {
                r[e[t].name] = e[t];
              }
            }
            return r;
          };
        };
        var buildType = e => {
          switch (e.kind) {
           case "OBJECT":
           case "INTERFACE":
            return {
              name: e.name,
              kind: e.kind,
              interfaces: buildNameMap(e.interfaces || []),
              fields: buildNameMap(e.fields.map((e => ({
                name: e.name,
                type: e.type,
                args: buildNameMap(e.args)
              }))))
            };

           case "UNION":
            return {
              name: e.name,
              kind: e.kind,
              types: buildNameMap(e.possibleTypes || [])
            };
          }
        };
        var t = {
          query: e.queryType ? e.queryType.name : null,
          mutation: e.mutationType ? e.mutationType.name : null,
          subscription: e.subscriptionType ? e.subscriptionType.name : null,
          types: void 0,
          isSubType(e, t) {
            var a = r.get(e);
            var i = r.get(t);
            if (!a || !i) {
              return !1;
            } else if ("UNION" === a.kind) {
              return !!a.types()[t];
            } else if ("OBJECT" !== a.kind && "OBJECT" === i.kind) {
              return !!i.interfaces()[e];
            } else {
              return e === t;
            }
          }
        };
        if (e.types) {
          t.types = r;
          for (var a = 0; a < e.types.length; a++) {
            var i = e.types[a];
            if (i && i.name) {
              var n = buildType(i);
              if (n) {
                r.set(i.name, n);
              }
            }
          }
        }
        return t;
      })(e.schema);
      r = i.query || r;
      t = i.mutation || t;
      a = i.subscription || a;
      if (i.types) {
        this.schema = i;
      }
    }
    this.updates = e.updates || {};
    this.rootFields = {
      query: r,
      mutation: t,
      subscription: a
    };
    this.rootNames = {
      [r]: "query",
      [t]: "mutation",
      [a]: "subscription"
    };
    this.data = (n = r, {
      hydrating: !1,
      defer: !1,
      gc: new Set,
      types: new Map,
      persist: new Set,
      queryRootKey: n,
      refCount: new Map,
      links: {
        optimistic: new Map,
        base: new Map
      },
      abstractToConcreteMap: new Map,
      records: {
        optimistic: new Map,
        base: new Map
      },
      deferredKeys: new Set,
      commutativeKeys: new Set,
      dirtyKeys: new Set,
      optimisticOrder: [],
      storage: null
    });
    var n;
    if (this.schema && "production" !== process.env.NODE_ENV) {
      !function expectValidKeyingConfig(e, r, t) {
        if ("production" !== process.env.NODE_ENV) {
          for (var a in r) {
            if ("production" !== process.env.NODE_ENV) {
              if (!e.types.has(a)) {
                warn("Invalid Object type: The type `" + a + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20, t);
              }
            }
          }
        }
      }(this.schema, this.keys, this.logger);
      !function expectValidUpdatesConfig(e, r, t) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        for (var a in r) {
          if (!r[a]) {
            continue;
          } else if (!e.types.has(a)) {
            var i = "";
            if ("Mutation" === a && e.mutation && "Mutation" !== e.mutation) {
              i += "\nMaybe your config should reference `" + e.mutation + "`?";
            } else if ("Subscription" === a && e.subscription && "Subscription" !== e.subscription) {
              i += "\nMaybe your config should reference `" + e.subscription + "`?";
            }
            return "production" !== process.env.NODE_ENV ? warn("Invalid updates type: The type `" + a + "` is not an object in the defined schema, but the `updates` config is referencing it." + i, 21, t) : void 0;
          }
          var n = e.types.get(a).fields();
          for (var o in r[a]) {
            if ("production" !== process.env.NODE_ENV) {
              if (!n[o]) {
                warn("Invalid updates field: `" + o + "` on `" + a + "` is not in the defined schema, but the `updates` config is referencing it.", 22, t);
              }
            }
          }
        }
      }(this.schema, this.updates, this.logger);
      !function expectValidResolversConfig(e, r, t) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        for (var a in r) {
          if ("Query" === a) {
            if (e.query) {
              var i = e.types.get(e.query).fields();
              for (var n in r.Query || {}) {
                if (!i[n]) {
                  warnAboutResolver("Query." + n, t);
                }
              }
            } else {
              warnAboutResolver("Query", t);
            }
          } else if (!e.types.has(a)) {
            warnAboutResolver(a, t);
          } else if ("INTERFACE" === e.types.get(a).kind || "UNION" === e.types.get(a).kind) {
            warnAboutAbstractResolver(a, e.types.get(a).kind, t);
          } else {
            var o = e.types.get(a).fields();
            for (var s in r[a] || {}) {
              if (!o[s]) {
                warnAboutResolver(a + "." + s, t);
              }
            }
          }
        }
      }(this.schema, this.resolvers, this.logger);
      !function expectValidOptimisticMutationsConfig(e, r, t) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        if (e.mutation) {
          var a = e.types.get(e.mutation).fields();
          for (var i in r) {
            if ("production" !== process.env.NODE_ENV) {
              if (!a[i]) {
                warn(`Invalid optimistic mutation field: \`${i}\` is not a mutation field in the defined schema, but the \`optimistic\` option is referencing it.`, 24, t);
              }
            }
          }
        }
      }(this.schema, this.optimisticMutations, this.logger);
    }
  }
  keyOfField(e, r) {
    return keyOfField(e, r);
  }
  keyOfEntity(e) {
    if (S && e === S.parent) {
      return S.parentKey;
    } else if (null == e || "string" == typeof e) {
      return e || null;
    } else if (!e.__typename) {
      return null;
    } else if (this.rootNames[e.__typename]) {
      return e.__typename;
    }
    var r = null;
    if (this.keys[e.__typename]) {
      r = this.keys[e.__typename](e) || null;
    } else if (null != e.id) {
      r = `${e.id}`;
    } else if (null != e._id) {
      r = `${e._id}`;
    }
    var t = e.__typename;
    return !0 === this.globalIDs || this.globalIDs && this.globalIDs.has(t) || !r ? r : `${t}:${r}`;
  }
  resolve(e, r, t) {
    var a = this.keyOfEntity(e);
    if (a) {
      var i = keyOfField(r, t);
      var n = readRecord(a, i);
      if (void 0 !== n) {
        return n;
      }
      var o = readLink(a, i);
      if (void 0 !== o) {
        o = ensureLink(this, o);
      }
      return o;
    }
  }
  invalidate(e, r, t) {
    var a = this.keyOfEntity(e);
    if (e && "string" == typeof e && !r && !t && !this.resolve(e, "__typename")) {
      invalidateType(e, []);
    } else {
      invariant(a, "production" !== process.env.NODE_ENV ? "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + ("object" == typeof e ? e.__typename : e + "`.") : "", 19);
      invalidateEntity(a, r, t);
    }
  }
  inspectFields(e) {
    var r = this.keyOfEntity(e);
    return r ? inspectFields(r) : [];
  }
  updateQuery(e, r) {
    var a = t(e.query, e.variables);
    var i = r(this.readQuery(a));
    if (null !== i) {
      _write(this, a, i, void 0);
    }
  }
  readQuery(e) {
    var r = t(e.query, e.variables);
    return _query(this, r, void 0, void 0).data;
  }
  readFragment(e, t, a, i) {
    return ((e, r, t, a, i) => {
      var n = getFragments(r);
      var o;
      if (i) {
        if (!(o = n[i])) {
          "production" !== process.env.NODE_ENV && warn("readFragment(...) was called with a fragment name that does not exist.\nYou provided " + i + " but could only find " + Object.keys(n).join(", ") + ".", 6, e.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        "production" !== process.env.NODE_ENV && warn("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6, e.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      if ("string" != typeof t && !t.__typename) {
        t.__typename = s;
      }
      var l = e.keyOfEntity(t);
      if (!l) {
        "production" !== process.env.NODE_ENV && warn("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 7, e.logger);
        return null;
      }
      if ("production" !== process.env.NODE_ENV) {
        pushDebugNode(s, o);
      }
      var v = makeContext(e, a || {}, n, s, l, void 0);
      var d = readSelection(v, l, getSelectionSet(o), makeData()) || null;
      if ("production" !== process.env.NODE_ENV) {
        popDebugNode();
      }
      return d;
    })(this, r(e), t, a, i);
  }
  writeFragment(e, t, a, i) {
    ((e, r, t, a, i) => {
      var n = getFragments(r);
      var o;
      if (i) {
        if (!(o = n[i])) {
          "production" !== process.env.NODE_ENV && warn("writeFragment(...) was called with a fragment name that does not exist.\nYou provided " + i + " but could only find " + Object.keys(n).join(", ") + ".", 11, e.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        "production" !== process.env.NODE_ENV && warn("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11, e.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      var l = {
        __typename: s,
        ...t
      };
      var v = e.keyOfEntity(l);
      if (!v) {
        return "production" !== process.env.NODE_ENV ? warn("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 12, e.logger) : void 0;
      }
      if ("production" !== process.env.NODE_ENV) {
        pushDebugNode(s, o);
      }
      var d = makeContext(e, a || {}, n, s, v, void 0);
      writeSelection(d, v, getSelectionSet(o), l);
      if ("production" !== process.env.NODE_ENV) {
        popDebugNode();
      }
    })(this, r(e), t, a, i);
  }
  link(e, r, ...t) {
    var a = 2 === t.length ? t[0] : null;
    var i = 2 === t.length ? t[1] : t[0];
    var n = this.keyOfEntity(e);
    if (n) {
      writeLink(n, keyOfField(r, a), ensureLink(this, i));
    }
  }
}

var addMetadata = (e, r) => a(e.kind, e, {
  ...e.context,
  meta: {
    ...e.context.meta,
    ...r
  }
});

var toRequestPolicy = (e, r) => a(e.kind, e, {
  ...e.context,
  requestPolicy: r
});

var cacheExchange = e => ({forward: t, client: i, dispatchDebug: n}) => {
  var o = new Store(e);
  if (e && e.storage) {
    o.data.hydrating = !0;
    e.storage.readData().then((r => {
      ((e, r, t) => {
        initDataState("write", e, null);
        for (var a in t) {
          var i = t[a];
          if (void 0 !== i) {
            var {entityKey: n, fieldKey: o} = deserializeKeyInfo(a);
            if (":" === i[0]) {
              if (void 0 === readLink(n, o)) {
                writeLink(n, o, JSON.parse(i.slice(1)));
              }
            } else if (void 0 === readRecord(n, o)) {
              writeRecord(n, o, JSON.parse(i));
            }
          }
        }
        e.storage = r;
        e.hydrating = !1;
        clearDataState();
      })(o.data, e.storage, r);
      if (e.storage.onCacheHydrated) {
        e.storage.onCacheHydrated();
      }
    }));
  }
  var f = new Map;
  var y = [];
  var h = new Map;
  var m = new Map;
  var g = new Set;
  var _ = new Set;
  var N = new Map;
  var k = new Set;
  var E = new Set;
  var isBlockedByOptimisticUpdate = e => {
    for (var r of e.values()) {
      if (g.has(r)) {
        return !0;
      }
    }
    return !1;
  };
  var collectPendingOperations = (e, r) => {
    if (r) {
      for (var t of r.values()) {
        var a = N.get(t);
        if (a) {
          for (var i of a.values()) {
            e.add(i);
          }
        }
      }
    }
  };
  var executePendingOperations = (e, r, t) => {
    for (var a of r.values()) {
      if (a !== e.key) {
        var n = h.get(a);
        if (n) {
          if ("query" === e.kind) {
            E.add(a);
          }
          var o = "cache-first";
          if (_.has(a)) {
            _.delete(a);
            o = "cache-and-network";
          }
          i.reexecuteOperation(toRequestPolicy(n, o));
        }
      }
    }
    if (!t) {
      var s = k;
      k = E;
      if ("query" === e.kind) {
        k.add(e.key);
      }
      (E = s).clear();
    }
  };
  var prepareForwardedOperation = e => {
    var t = !1;
    if ("query" === e.kind) {
      reserveLayer(o.data, e.key);
      h.set(e.key, e);
    } else if ("teardown" === e.kind) {
      h.delete(e.key);
      m.delete(e.key);
      k.delete(e.key);
      noopDataState(o.data, e.key);
      return e;
    } else if ("mutation" === e.kind && "network-only" !== e.context.requestPolicy) {
      h.set(e.key, e);
      initDataState("write", o.data, e.key, !0, !1);
      var {dependencies: i} = _write(o, e, void 0, void 0);
      clearDataState();
      if (i.size) {
        for (var n of i.values()) {
          g.add(n);
        }
        f.set(e.key, i);
        var s = new Set;
        collectPendingOperations(s, i);
        executePendingOperations(e, s, !0);
        t = !0;
      }
    }
    return a(e.kind, {
      key: e.key,
      query: r(e.query),
      variables: e.variables ? filterVariables(getMainOperation(e.query), e.variables) : e.variables
    }, {
      ...e.context,
      optimistic: t
    });
  };
  var updateDependencies = (e, r) => {
    for (var t of r.values()) {
      var a = N.get(t);
      if (!a) {
        N.set(t, a = new Set);
      }
      a.add(e.key);
    }
  };
  var operationResultFromCache = e => {
    initDataState("read", o.data, void 0, !1, !1);
    var r = _query(o, e, m.get(e.key), void 0);
    clearDataState();
    var t = r.data ? !r.partial && !r.hasNext ? "hit" : "partial" : "miss";
    m.set(e.key, r.data);
    h.set(e.key, e);
    updateDependencies(e, r.dependencies);
    return {
      outcome: t,
      operation: e,
      data: r.data,
      dependencies: r.dependencies,
      hasNext: r.hasNext
    };
  };
  var updateCacheWithResult = (e, r) => {
    var t = h.get(e.operation.key) || e.operation;
    if ("mutation" === t.kind) {
      var a = f.get(t.key);
      collectPendingOperations(r, a);
      f.delete(t.key);
    }
    if ("subscription" === t.kind || e.hasNext) {
      reserveLayer(o.data, t.key, !0);
    }
    var i;
    var n = e.data;
    if (n) {
      initDataState("write", o.data, t.key, !1, !1);
      var s = _write(o, t, n, e.error).dependencies;
      clearDataState();
      collectPendingOperations(r, s);
      var l = "query" === t.kind ? m.get(t.key) : null;
      initDataState("read", o.data, t.key, !1, l !== n);
      var v = _query(o, t, l || n, e.error);
      clearDataState();
      n = v.data;
      if ("query" === t.kind) {
        collectPendingOperations(r, i = v.dependencies);
        m.set(t.key, n);
      }
    } else {
      noopDataState(o.data, t.key);
    }
    if (i) {
      updateDependencies(e.operation, i);
    }
    return {
      operation: t,
      data: n,
      error: e.error,
      extensions: e.extensions,
      hasNext: e.hasNext,
      stale: e.stale
    };
  };
  return e => {
    var r = s(l(operationResultFromCache)(v((e => "query" === e.kind && "network-only" !== e.context.requestPolicy))(e)));
    var a = v((e => "query" !== e.kind || "network-only" === e.context.requestPolicy))(e);
    var m = l((e => {
      "production" !== process.env.NODE_ENV && n({
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache",
        operation: e.operation,
        source: "cacheExchange"
      });
      return "production" !== process.env.NODE_ENV ? addMetadata(e.operation, {
        cacheOutcome: "miss"
      }) : e.operation;
    }))(v((e => "miss" === e.outcome && "cache-only" !== e.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e.dependencies) && !k.has(e.operation.key)))(r));
    var N = l((e => {
      var {requestPolicy: r} = e.operation.context;
      var t = "cache-only" !== r && (e.hasNext || "cache-and-network" === r || "cache-first" === r && "partial" === e.outcome && !k.has(e.operation.key));
      var a = "cache-only" !== r && (t || "partial" === e.outcome && k.has(e.operation.key) && ((s = o.data).commutativeKeys.has(l = e.operation.key) || s.optimisticOrder.indexOf(l) > -1));
      var s, l;
      var v = {
        operation: "production" !== process.env.NODE_ENV ? addMetadata(e.operation, {
          cacheOutcome: e.outcome
        }) : e.operation,
        data: e.data,
        error: e.error,
        extensions: e.extensions,
        stale: a && !e.hasNext,
        hasNext: t && e.hasNext
      };
      if (!t) {} else if (!isBlockedByOptimisticUpdate(e.dependencies)) {
        i.reexecuteOperation(toRequestPolicy(h.get(e.operation.key) || e.operation, "network-only"));
      } else if ("cache-and-network" === r) {
        _.add(e.operation.key);
      }
      "production" !== process.env.NODE_ENV && n({
        type: "cacheHit",
        message: "A requested operation was found and returned from the cache.",
        operation: e.operation,
        data: {
          value: v
        },
        source: "cacheExchange"
      });
      return v;
    }))(v((e => "miss" !== e.outcome || "cache-only" === e.operation.context.requestPolicy))(r));
    var E = t(l(prepareForwardedOperation)(d([ a, m ])));
    var O = l((e => {
      var r = new Set;
      var t = updateCacheWithResult(e, r);
      executePendingOperations(e.operation, r, !1);
      return t;
    }))(v((e => !f.has(e.operation.key)))(E));
    var w = c((e => {
      if (y.push(e) < f.size) {
        return u;
      }
      for (var r = 0; r < y.length; r++) {
        reserveLayer(o.data, y[r].operation.key);
      }
      g.clear();
      var t = [];
      var a = new Set;
      var i;
      while (i = y.shift()) {
        t.push(updateCacheWithResult(i, a));
      }
      executePendingOperations(e.operation, a, !1);
      return p(t);
    }))(v((e => f.has(e.operation.key)))(E));
    return d([ O, w, N ]);
  };
};

var K = {
  "cache-only": 0,
  "cache-first": 1,
  "network-only": 2,
  "cache-and-network": 3
};

var offlineExchange = e => r => {
  var {storage: n} = e;
  var o = e.isOfflineError || (e => e && e.networkError && !e.response && ("undefined" != typeof navigator && !1 === navigator.onLine || /request failed|failed to fetch|network\s?error/i.test(e.networkError.message)));
  if (n && n.onOnline && n.readMetadata && n.writeMetadata) {
    var {forward: l, client: c, dispatchDebug: u} = r;
    var {source: p, next: h} = f();
    var m = [];
    var g = !1;
    var _ = !1;
    var updateMetadata = () => {
      if (g) {
        var e = [];
        for (var r = 0; r < m.length; r++) {
          var t = m[r];
          if ("mutation" === t.kind) {
            e.push({
              query: i(t.query),
              variables: t.variables,
              extensions: t.extensions
            });
          }
        }
        n.writeMetadata(e);
      }
    };
    var filterQueue = e => {
      for (var r = m.length - 1; r >= 0; r--) {
        if (m[r].key === e) {
          m.splice(r, 1);
        }
      }
    };
    var flushQueue = () => {
      if (!_) {
        var e = new Set;
        _ = !0;
        for (var r = 0; r < m.length; r++) {
          var t = m[r];
          if ("mutation" === t.kind || !e.has(t.key)) {
            e.add(t.key);
            if ("subscription" !== t.kind) {
              h(a("teardown", t));
              var i = "cache-first";
              for (var n = 0; n < m.length; n++) {
                var {requestPolicy: o} = m[n].context;
                if (K[o] > K[i]) {
                  i = o;
                }
              }
              h(toRequestPolicy(t, i));
            } else {
              h(toRequestPolicy(t, "cache-first"));
            }
          }
        }
        _ = !1;
        m.length = 0;
        updateMetadata();
      }
    };
    var N = cacheExchange({
      ...e,
      storage: {
        ...n,
        readData() {
          var e = n.readData();
          return {
            async then(r) {
              var a = await n.readMetadata();
              for (var i = 0; a && i < a.length; i++) {
                m.push(c.createRequestOperation("mutation", t(a[i].query, a[i].variables), a[i].extensions));
              }
              r(await e);
              n.onOnline(flushQueue);
              g = !0;
              flushQueue();
            }
          };
        }
      }
    })({
      client: c,
      dispatchDebug: u,
      forward: e => s(v((e => {
        if (g && "mutation" === e.operation.kind && e.operation.context.optimistic && o(e.error, e)) {
          m.push(e.operation);
          updateMetadata();
          return !1;
        }
        return !0;
      }))(l(e)))
    });
    return e => {
      var r = d([ p, y((e => {
        if ("query" === e.kind && !g) {
          m.push(e);
        } else if ("teardown" === e.kind) {
          filterQueue(e.key);
        }
      }))(e) ]);
      return v((e => {
        if ("query" === e.operation.kind) {
          if (o(e.error, e)) {
            h(toRequestPolicy(e.operation, "cache-only"));
            m.push(e.operation);
            return !1;
          } else if (!g) {
            filterQueue(e.operation.key);
          }
        }
        return !0;
      }))(N(r));
    };
  }
  return cacheExchange(e)(r);
};

export { Store, cacheExchange, offlineExchange };
//# sourceMappingURL=urql-exchange-graphcache.mjs.map
