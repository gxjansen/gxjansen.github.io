{"version":3,"file":"urql-exchange-graphcache-extras.mjs","sources":["../src/extras/relayPagination.ts","../src/extras/simplePagination.ts"],"sourcesContent":["import { stringifyVariables } from '@urql/core';\nimport type { Cache, Resolver, Variables, NullArray } from '../types';\n\nexport type MergeMode = 'outwards' | 'inwards';\n\n/** Input parameters for the {@link relayPagination} factory. */\nexport interface PaginationParams {\n  /** Flip between inwards and outwards pagination.\n   *\n   * @remarks\n   * This is only relevant if youâ€™re querying pages using forwards and\n   * backwards pagination at the same time.\n   * When set to `'inwards'`, its default, pages that have been queried\n   * forward are placed in front of all pages that were queried backwards.\n   * When set to `'outwards'`, the two sets are merged in reverse.\n   */\n  mergeMode?: MergeMode;\n}\n\ninterface PageInfo {\n  __typename: string;\n  endCursor: null | string;\n  startCursor: null | string;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n\ninterface Page {\n  __typename: string;\n  edges: NullArray<string>;\n  nodes: NullArray<string>;\n  pageInfo: PageInfo;\n}\n\nconst defaultPageInfo: PageInfo = {\n  __typename: 'PageInfo',\n  endCursor: null,\n  startCursor: null,\n  hasNextPage: false,\n  hasPreviousPage: false,\n};\n\nconst ensureKey = (x: any): string | null => (typeof x === 'string' ? x : null);\n\nconst concatEdges = (\n  cache: Cache,\n  leftEdges: NullArray<string>,\n  rightEdges: NullArray<string>\n) => {\n  const ids = new Set<string>();\n  for (let i = 0, l = leftEdges.length; i < l; i++) {\n    const edge = leftEdges[i] as string | null;\n    const node = cache.resolve(edge, 'node');\n    if (typeof node === 'string') ids.add(node);\n  }\n\n  const newEdges = leftEdges.slice();\n  for (let i = 0, l = rightEdges.length; i < l; i++) {\n    const edge = rightEdges[i] as string | null;\n    const node = cache.resolve(edge, 'node');\n    if (typeof node === 'string' && !ids.has(node)) {\n      ids.add(node);\n      newEdges.push(edge);\n    }\n  }\n\n  return newEdges;\n};\n\nconst concatNodes = (\n  leftNodes: NullArray<string>,\n  rightNodes: NullArray<string>\n) => {\n  const ids = new Set<string>();\n  for (let i = 0, l = leftNodes.length; i < l; i++) {\n    const node = leftNodes[i];\n    if (typeof node === 'string') ids.add(node);\n  }\n\n  const newNodes = leftNodes.slice();\n  for (let i = 0, l = rightNodes.length; i < l; i++) {\n    const node = rightNodes[i];\n    if (typeof node === 'string' && !ids.has(node)) {\n      ids.add(node);\n      newNodes.push(node);\n    }\n  }\n\n  return newNodes;\n};\n\nconst compareArgs = (\n  fieldArgs: Variables,\n  connectionArgs: Variables\n): boolean => {\n  for (const key in connectionArgs) {\n    if (\n      key === 'first' ||\n      key === 'last' ||\n      key === 'after' ||\n      key === 'before'\n    ) {\n      continue;\n    } else if (!(key in fieldArgs)) {\n      return false;\n    }\n\n    const argA = fieldArgs[key];\n    const argB = connectionArgs[key];\n\n    if (\n      typeof argA !== typeof argB || typeof argA !== 'object'\n        ? argA !== argB\n        : stringifyVariables(argA) !== stringifyVariables(argB)\n    ) {\n      return false;\n    }\n  }\n\n  for (const key in fieldArgs) {\n    if (\n      key === 'first' ||\n      key === 'last' ||\n      key === 'after' ||\n      key === 'before'\n    ) {\n      continue;\n    }\n\n    if (!(key in connectionArgs)) return false;\n  }\n\n  return true;\n};\n\nconst getPage = (\n  cache: Cache,\n  entityKey: string,\n  fieldKey: string\n): Page | null => {\n  const link = ensureKey(cache.resolve(entityKey, fieldKey));\n  if (!link) return null;\n\n  const typename = cache.resolve(link, '__typename') as string;\n  const edges = (cache.resolve(link, 'edges') || []) as NullArray<string>;\n  const nodes = (cache.resolve(link, 'nodes') || []) as NullArray<string>;\n  if (typeof typename !== 'string') {\n    return null;\n  }\n\n  const page: Page = {\n    __typename: typename,\n    edges,\n    nodes,\n    pageInfo: defaultPageInfo,\n  };\n\n  const pageInfoKey = cache.resolve(link, 'pageInfo');\n  if (typeof pageInfoKey === 'string') {\n    const pageInfoType = ensureKey(cache.resolve(pageInfoKey, '__typename'));\n    const endCursor = ensureKey(cache.resolve(pageInfoKey, 'endCursor'));\n    const startCursor = ensureKey(cache.resolve(pageInfoKey, 'startCursor'));\n    const hasNextPage = cache.resolve(pageInfoKey, 'hasNextPage');\n    const hasPreviousPage = cache.resolve(pageInfoKey, 'hasPreviousPage');\n\n    const pageInfo: PageInfo = (page.pageInfo = {\n      __typename: typeof pageInfoType === 'string' ? pageInfoType : 'PageInfo',\n      hasNextPage: typeof hasNextPage === 'boolean' ? hasNextPage : !!endCursor,\n      hasPreviousPage:\n        typeof hasPreviousPage === 'boolean' ? hasPreviousPage : !!startCursor,\n      endCursor,\n      startCursor,\n    });\n\n    if (pageInfo.endCursor === null) {\n      const edge = edges[edges.length - 1] as string | null;\n      if (edge) {\n        const endCursor = cache.resolve(edge, 'cursor');\n        pageInfo.endCursor = ensureKey(endCursor);\n      }\n    }\n\n    if (pageInfo.startCursor === null) {\n      const edge = edges[0] as string | null;\n      if (edge) {\n        const startCursor = cache.resolve(edge, 'cursor');\n        pageInfo.startCursor = ensureKey(startCursor);\n      }\n    }\n  }\n\n  return page;\n};\n\n/** Creates a {@link Resolver} that combines pages that comply to the Relay pagination spec.\n *\n * @param params - A {@link PaginationParams} configuration object.\n * @returns the created Relay pagination {@link Resolver}.\n *\n * @remarks\n * `relayPagination` is a factory that creates a {@link Resolver} that can combine\n * multiple pages on a field that complies to the Relay pagination spec into a single,\n * combined list for infinite scrolling.\n *\n * This resolver will only work on fields that return a `Connection` GraphQL object\n * type, according to the Relay pagination spec.\n *\n * Hint: It's not recommended to use this when you can handle infinite scrolling\n * in your UI code instead.\n *\n * @see {@link https://urql.dev/goto/docs/graphcache/local-resolvers#relay-pagination} for more information.\n * @see {@link https://urql.dev/goto/docs/basics/ui-patterns/#infinite-scrolling} for an alternate approach.\n */\nexport const relayPagination = (\n  params: PaginationParams = {}\n): Resolver<any, any, any> => {\n  const mergeMode = params.mergeMode || 'inwards';\n\n  return (_parent, fieldArgs, cache, info) => {\n    const { parentKey: entityKey, fieldName } = info;\n\n    const allFields = cache.inspectFields(entityKey);\n    const fieldInfos = allFields.filter(info => info.fieldName === fieldName);\n    const size = fieldInfos.length;\n    if (size === 0) {\n      return undefined;\n    }\n\n    let typename: string | null = null;\n    let startEdges: NullArray<string> = [];\n    let endEdges: NullArray<string> = [];\n    let startNodes: NullArray<string> = [];\n    let endNodes: NullArray<string> = [];\n    let pageInfo: PageInfo = { ...defaultPageInfo };\n\n    for (let i = 0; i < size; i++) {\n      const { fieldKey, arguments: args } = fieldInfos[i];\n      if (args === null || !compareArgs(fieldArgs, args)) {\n        continue;\n      }\n\n      const page = getPage(cache, entityKey, fieldKey);\n      if (page === null) {\n        continue;\n      }\n      if (page.nodes.length === 0 && page.edges.length === 0 && typename) {\n        continue;\n      }\n\n      if (\n        mergeMode === 'inwards' &&\n        typeof args.last === 'number' &&\n        typeof args.first === 'number'\n      ) {\n        const firstEdges = page.edges.slice(0, args.first + 1);\n        const lastEdges = page.edges.slice(-args.last);\n        const firstNodes = page.nodes.slice(0, args.first + 1);\n        const lastNodes = page.nodes.slice(-args.last);\n\n        startEdges = concatEdges(cache, startEdges, firstEdges);\n        endEdges = concatEdges(cache, lastEdges, endEdges);\n        startNodes = concatNodes(startNodes, firstNodes);\n        endNodes = concatNodes(lastNodes, endNodes);\n\n        pageInfo = page.pageInfo;\n      } else if (args.after) {\n        startEdges = concatEdges(cache, startEdges, page.edges);\n        startNodes = concatNodes(startNodes, page.nodes);\n        pageInfo.endCursor = page.pageInfo.endCursor;\n        pageInfo.hasNextPage = page.pageInfo.hasNextPage;\n      } else if (args.before) {\n        endEdges = concatEdges(cache, page.edges, endEdges);\n        endNodes = concatNodes(page.nodes, endNodes);\n        pageInfo.startCursor = page.pageInfo.startCursor;\n        pageInfo.hasPreviousPage = page.pageInfo.hasPreviousPage;\n      } else if (typeof args.last === 'number') {\n        endEdges = concatEdges(cache, page.edges, endEdges);\n        endNodes = concatNodes(page.nodes, endNodes);\n        pageInfo = page.pageInfo;\n      } else {\n        startEdges = concatEdges(cache, startEdges, page.edges);\n        startNodes = concatNodes(startNodes, page.nodes);\n        pageInfo = page.pageInfo;\n      }\n\n      if (page.pageInfo.__typename !== pageInfo.__typename)\n        pageInfo.__typename = page.pageInfo.__typename;\n      if (typename !== page.__typename) typename = page.__typename;\n    }\n\n    if (typeof typename !== 'string') {\n      return undefined;\n    }\n\n    const hasCurrentPage = !!ensureKey(\n      cache.resolve(entityKey, fieldName, fieldArgs)\n    );\n    if (!hasCurrentPage) {\n      if (!(info as any).store.schema) {\n        return undefined;\n      } else {\n        info.partial = true;\n      }\n    }\n\n    return {\n      __typename: typename,\n      edges:\n        mergeMode === 'inwards'\n          ? concatEdges(cache, startEdges, endEdges)\n          : concatEdges(cache, endEdges, startEdges),\n      nodes:\n        mergeMode === 'inwards'\n          ? concatNodes(startNodes, endNodes)\n          : concatNodes(endNodes, startNodes),\n      pageInfo: {\n        __typename: pageInfo.__typename,\n        endCursor: pageInfo.endCursor,\n        startCursor: pageInfo.startCursor,\n        hasNextPage: pageInfo.hasNextPage,\n        hasPreviousPage: pageInfo.hasPreviousPage,\n      },\n    };\n  };\n};\n","import { stringifyVariables } from '@urql/core';\nimport type { Resolver, Variables, NullArray } from '../types';\n\nexport type MergeMode = 'before' | 'after';\n\n/** Input parameters for the {@link simplePagination} factory. */\nexport interface PaginationParams {\n  /** The name of the field argument used to define the pageâ€™s offset. */\n  offsetArgument?: string;\n  /** The name of the field argument used to define the pageâ€™s length. */\n  limitArgument?: string;\n  /** Flip between forward and backwards pagination.\n   *\n   * @remarks\n   * When set to `'after'`, its default, pages are merged forwards and in order.\n   * When set to `'before'`, pages are merged in reverse, putting later pages\n   * in front of earlier ones.\n   */\n  mergeMode?: MergeMode;\n}\n\n/** Creates a {@link Resolver} that combines pages of a primitive pagination field.\n *\n * @param options - A {@link PaginationParams} configuration object.\n * @returns the created pagination {@link Resolver}.\n *\n * @remarks\n * `simplePagination` is a factory that creates a {@link Resolver} that can combine\n * multiple lists on a paginated field into a single, combined list for infinite\n * scrolling.\n *\n * Hint: It's not recommended to use this when you can handle infinite scrolling\n * in your UI code instead.\n *\n * @see {@link https://urql.dev/goto/docs/graphcache/local-resolvers#simple-pagination} for more information.\n * @see {@link https://urql.dev/goto/docs/basics/ui-patterns/#infinite-scrolling} for an alternate approach.\n */\nexport const simplePagination = ({\n  offsetArgument = 'skip',\n  limitArgument = 'limit',\n  mergeMode = 'after',\n}: PaginationParams = {}): Resolver<any, any, any> => {\n  const compareArgs = (\n    fieldArgs: Variables,\n    connectionArgs: Variables\n  ): boolean => {\n    for (const key in connectionArgs) {\n      if (key === offsetArgument || key === limitArgument) {\n        continue;\n      } else if (!(key in fieldArgs)) {\n        return false;\n      }\n\n      const argA = fieldArgs[key];\n      const argB = connectionArgs[key];\n\n      if (\n        typeof argA !== typeof argB || typeof argA !== 'object'\n          ? argA !== argB\n          : stringifyVariables(argA) !== stringifyVariables(argB)\n      ) {\n        return false;\n      }\n    }\n\n    for (const key in fieldArgs) {\n      if (key === offsetArgument || key === limitArgument) {\n        continue;\n      }\n      if (!(key in connectionArgs)) return false;\n    }\n\n    return true;\n  };\n\n  return (_parent, fieldArgs, cache, info) => {\n    const { parentKey: entityKey, fieldName } = info;\n\n    const allFields = cache.inspectFields(entityKey);\n    const fieldInfos = allFields.filter(info => info.fieldName === fieldName);\n    const size = fieldInfos.length;\n    if (size === 0) {\n      return undefined;\n    }\n\n    const visited = new Set();\n    let result: NullArray<string> = [];\n    let prevOffset: number | null = null;\n\n    for (let i = 0; i < size; i++) {\n      const { fieldKey, arguments: args } = fieldInfos[i];\n      if (args === null || !compareArgs(fieldArgs, args)) {\n        continue;\n      }\n\n      const links = cache.resolve(entityKey, fieldKey) as string[];\n      const currentOffset = args[offsetArgument];\n\n      if (\n        links === null ||\n        links.length === 0 ||\n        typeof currentOffset !== 'number'\n      ) {\n        continue;\n      }\n\n      const tempResult: NullArray<string> = [];\n\n      for (let j = 0; j < links.length; j++) {\n        const link = links[j];\n        if (visited.has(link)) continue;\n        tempResult.push(link);\n        visited.add(link);\n      }\n\n      if (\n        (!prevOffset || currentOffset > prevOffset) ===\n        (mergeMode === 'after')\n      ) {\n        result = [...result, ...tempResult];\n      } else {\n        result = [...tempResult, ...result];\n      }\n\n      prevOffset = currentOffset;\n    }\n\n    const hasCurrentPage = cache.resolve(entityKey, fieldName, fieldArgs);\n    if (hasCurrentPage) {\n      return result;\n    } else if (!(info as any).store.schema) {\n      return undefined;\n    } else {\n      info.partial = true;\n      return result;\n    }\n  };\n};\n"],"names":["defaultPageInfo","__typename","endCursor","startCursor","hasNextPage","hasPreviousPage","ensureKey","x","concatEdges","cache","leftEdges","rightEdges","ids","Set","i","l","length","node","resolve","add","newEdges","slice","edge","has","push","concatNodes","leftNodes","rightNodes","newNodes","compareArgs","fieldArgs","connectionArgs","key","argA","argB","stringifyVariables","getPage","entityKey","fieldKey","link","typename","edges","nodes","page","pageInfo","pageInfoKey","pageInfoType","relayPagination","params","mergeMode","_parent","info","parentKey","fieldName","fieldInfos","inspectFields","filter","size","startEdges","endEdges","startNodes","endNodes","arguments","args","last","first","firstEdges","lastEdges","firstNodes","lastNodes","after","before","store","schema","partial","simplePagination","offsetArgument","limitArgument","visited","result","prevOffset","links","currentOffset","tempResult","j"],"mappings":"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"}