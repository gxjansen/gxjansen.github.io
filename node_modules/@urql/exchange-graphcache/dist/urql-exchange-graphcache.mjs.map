{"version":3,"file":"urql-exchange-graphcache.mjs","sources":["../src/helpers/help.ts","../src/ast/node.ts","../src/ast/variables.ts","../src/ast/traversal.ts","../src/ast/schemaPredicates.ts","../src/store/keys.ts","../src/store/data.ts","../src/operations/shared.ts","../src/operations/query.ts","../src/operations/write.ts","../src/operations/invalidate.ts","../src/store/store.ts","../src/ast/schema.ts","../src/helpers/operation.ts","../src/cacheExchange.ts","../src/offlineExchange.ts"],"sourcesContent":["// These are guards that are used throughout the codebase to warn or error on\n// unexpected behaviour or conditions.\n// Every warning and error comes with a number that uniquely identifies them.\n// You can read more about the messages themselves in `docs/graphcache/errors.md`\n\nimport type {\n  ExecutableDefinitionNode,\n  InlineFragmentNode,\n} from '@0no-co/graphql.web';\nimport type { Logger } from '../types';\nimport { Kind } from '@0no-co/graphql.web';\n\nexport type ErrorCode =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26\n  | 27\n  | 28;\n\ntype DebugNode = ExecutableDefinitionNode | InlineFragmentNode;\n\n// URL unfurls to https://formidable.com/open-source/urql/docs/graphcache/errors/\nconst helpUrl = '\\nhttps://bit.ly/2XbVrpR#';\nconst cache = new Set<string>();\n\nexport const currentDebugStack: string[] = [];\n\nexport const popDebugNode = () => currentDebugStack.pop();\n\nexport const pushDebugNode = (typename: void | string, node: DebugNode) => {\n  let identifier = '';\n  if (node.kind === Kind.INLINE_FRAGMENT) {\n    identifier = typename\n      ? `Inline Fragment on \"${typename}\"`\n      : 'Inline Fragment';\n  } else if (node.kind === Kind.OPERATION_DEFINITION) {\n    const name = node.name ? `\"${node.name.value}\"` : 'Unnamed';\n    identifier = `${name} ${node.operation}`;\n  } else if (node.kind === Kind.FRAGMENT_DEFINITION) {\n    identifier = `\"${node.name.value}\" Fragment`;\n  }\n\n  if (identifier) {\n    currentDebugStack.push(identifier);\n  }\n};\n\nconst getDebugOutput = (): string =>\n  currentDebugStack.length\n    ? '\\n(Caused At: ' + currentDebugStack.join(', ') + ')'\n    : '';\n\nexport function invariant(\n  condition: any,\n  message: string,\n  code: ErrorCode\n): asserts condition {\n  if (!condition) {\n    let errorMessage = message || 'Minfied Error #' + code + '\\n';\n    if (process.env.NODE_ENV !== 'production') {\n      errorMessage += getDebugOutput();\n    }\n\n    const error = new Error(errorMessage + helpUrl + code);\n    error.name = 'Graphcache Error';\n    throw error;\n  }\n}\n\nexport function warn(\n  message: string,\n  code: ErrorCode,\n  logger: Logger | undefined\n) {\n  if (!cache.has(message)) {\n    if (logger) {\n      logger('warn', message + getDebugOutput() + helpUrl + code);\n    } else {\n      console.warn(message + getDebugOutput() + helpUrl + code);\n    }\n    cache.add(message);\n  }\n}\n","import type {\n  NamedTypeNode,\n  NameNode,\n  DirectiveNode,\n  SelectionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\n\nimport type { FormattedNode } from '@urql/core';\n\nexport type SelectionSet = readonly FormattedNode<SelectionNode>[];\n\nconst EMPTY_DIRECTIVES: Record<string, DirectiveNode | undefined> = {};\n\n/** Returns the directives dictionary of a given node */\nexport const getDirectives = (node: {\n  _directives?: Record<string, DirectiveNode | undefined>;\n}) => node._directives || EMPTY_DIRECTIVES;\n\n/** Returns the name of a given node */\nexport const getName = (node: { name: NameNode }): string => node.name.value;\n\nexport const getFragmentTypeName = (node: FragmentDefinitionNode): string =>\n  node.typeCondition.name.value;\n\n/** Returns either the field's name or the field's alias */\nexport const getFieldAlias = (node: FieldNode): string =>\n  node.alias ? node.alias.value : node.name.value;\n\nconst emptySelectionSet: SelectionSet = [];\n\n/** Returns the SelectionSet for a given inline or defined fragment node */\nexport const getSelectionSet = (node: {\n  selectionSet?: FormattedNode<SelectionSetNode>;\n}): FormattedNode<SelectionSet> =>\n  (node.selectionSet\n    ? node.selectionSet.selections\n    : emptySelectionSet) as FormattedNode<SelectionSet>;\n\nexport const getTypeCondition = (node: {\n  typeCondition?: NamedTypeNode;\n}): string | null =>\n  node.typeCondition ? node.typeCondition.name.value : null;\n","import type {\n  FieldNode,\n  DirectiveNode,\n  OperationDefinitionNode,\n} from '@0no-co/graphql.web';\nimport { valueFromASTUntyped } from '@0no-co/graphql.web';\n\nimport { getName } from './node';\n\nimport type { Variables } from '../types';\n\n/** Evaluates a fields arguments taking vars into account */\nexport const getFieldArguments = (\n  node: FieldNode | DirectiveNode,\n  vars: Variables\n): null | Variables => {\n  let args: null | Variables = null;\n  if (node.arguments) {\n    for (let i = 0, l = node.arguments.length; i < l; i++) {\n      const arg = node.arguments[i];\n      const value = valueFromASTUntyped(arg.value, vars);\n      if (value !== undefined && value !== null) {\n        if (!args) args = {};\n        args[getName(arg)] = value as any;\n      }\n    }\n  }\n  return args;\n};\n\n/** Returns a filtered form of variables with values missing that the query doesn't require */\nexport const filterVariables = (\n  node: OperationDefinitionNode,\n  input: void | object\n) => {\n  if (!input || !node.variableDefinitions) {\n    return undefined;\n  }\n\n  const vars = {};\n  for (let i = 0, l = node.variableDefinitions.length; i < l; i++) {\n    const name = getName(node.variableDefinitions[i].variable);\n    vars[name] = input[name];\n  }\n\n  return vars;\n};\n\n/** Returns a normalized form of variables with defaulted values */\nexport const normalizeVariables = (\n  node: OperationDefinitionNode,\n  input: void | Record<string, unknown>\n): Variables => {\n  const vars = {};\n  if (!input) return vars;\n\n  if (node.variableDefinitions) {\n    for (let i = 0, l = node.variableDefinitions.length; i < l; i++) {\n      const def = node.variableDefinitions[i];\n      const name = getName(def.variable);\n      vars[name] =\n        input[name] === undefined && def.defaultValue\n          ? valueFromASTUntyped(def.defaultValue, input)\n          : input[name];\n    }\n  }\n\n  for (const key in input) {\n    if (!(key in vars)) vars[key] = input[key];\n  }\n\n  return vars;\n};\n","import type {\n  SelectionNode,\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n} from '@0no-co/graphql.web';\nimport { valueFromASTUntyped, Kind } from '@0no-co/graphql.web';\n\nimport type { FormattedNode } from '@urql/core';\nimport { getName, getDirectives } from './node';\nimport { invariant } from '../helpers/help';\nimport type { Fragments, Variables } from '../types';\n\nfunction getMainOperation(\n  doc: FormattedNode<DocumentNode>\n): FormattedNode<OperationDefinitionNode>;\nfunction getMainOperation(doc: DocumentNode): OperationDefinitionNode;\n\n/** Returns the main operation's definition */\nfunction getMainOperation(doc: DocumentNode): OperationDefinitionNode {\n  for (let i = 0; i < doc.definitions.length; i++) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      return doc.definitions[i] as FormattedNode<OperationDefinitionNode>;\n    }\n  }\n\n  invariant(\n    false,\n    'Invalid GraphQL document: All GraphQL documents must contain an OperationDefinition' +\n      'node for a query, subscription, or mutation.',\n    1\n  );\n}\n\nexport { getMainOperation };\n\n/** Returns a mapping from fragment names to their selections */\nexport const getFragments = (doc: FormattedNode<DocumentNode>): Fragments => {\n  const fragments: Fragments = {};\n  for (let i = 0; i < doc.definitions.length; i++) {\n    const node = doc.definitions[i];\n    if (node.kind === Kind.FRAGMENT_DEFINITION) {\n      fragments[getName(node)] = node;\n    }\n  }\n\n  return fragments;\n};\n\n/** Resolves @include and @skip directives to determine whether field is included. */\nexport const shouldInclude = (\n  node: FormattedNode<SelectionNode>,\n  vars: Variables\n): boolean => {\n  const directives = getDirectives(node);\n  if (directives.include || directives.skip) {\n    // Finds any @include or @skip directive that forces the node to be skipped\n    for (const name in directives) {\n      const directive = directives[name];\n      if (\n        directive &&\n        (name === 'include' || name === 'skip') &&\n        directive.arguments &&\n        directive.arguments[0] &&\n        getName(directive.arguments[0]) === 'if'\n      ) {\n        // Return whether this directive forces us to skip\n        // `@include(if: false)` or `@skip(if: true)`\n        const value = valueFromASTUntyped(directive.arguments[0].value, vars);\n        return name === 'include' ? !!value : !value;\n      }\n    }\n  }\n  return true;\n};\n\n/** Resolves @defer directive to determine whether a fragment is potentially skipped. */\nexport const isDeferred = (\n  node: FormattedNode<FragmentSpreadNode | InlineFragmentNode>,\n  vars: Variables\n): boolean => {\n  const { defer } = getDirectives(node);\n  if (defer) {\n    for (const argument of defer.arguments || []) {\n      if (getName(argument) === 'if') {\n        // Return whether `@defer(if: )` is enabled\n        return !!valueFromASTUntyped(argument.value, vars);\n      }\n    }\n    return true;\n  }\n\n  return false;\n};\n\n/** Resolves @_optional and @_required directive to determine whether the fields in a fragment are conaidered optional. */\nexport const isOptional = (\n  node: FormattedNode<FragmentSpreadNode | InlineFragmentNode>\n): boolean | undefined => {\n  const { optional, required } = getDirectives(node);\n  if (required) {\n    return false;\n  }\n\n  if (optional) {\n    return true;\n  }\n\n  return undefined;\n};\n","import type {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\n\nimport { warn, invariant } from '../helpers/help';\nimport { getTypeCondition } from './node';\nimport type { SchemaIntrospector, SchemaObject } from './schema';\n\nimport type {\n  KeyingConfig,\n  UpdatesConfig,\n  ResolverConfig,\n  OptimisticMutationConfig,\n  Logger,\n} from '../types';\n\nconst BUILTIN_NAME = '__';\n\nexport const isFieldNullable = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string,\n  logger: Logger | undefined\n): boolean => {\n  const field = getField(schema, typename, fieldName, logger);\n  return !!field && field.type.kind !== 'NON_NULL';\n};\n\nexport const isListNullable = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string,\n  logger: Logger | undefined\n): boolean => {\n  const field = getField(schema, typename, fieldName, logger);\n  if (!field) return false;\n  const ofType =\n    field.type.kind === 'NON_NULL' ? field.type.ofType : field.type;\n  return ofType.kind === 'LIST' && ofType.ofType.kind !== 'NON_NULL';\n};\n\nexport const isFieldAvailableOnType = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string,\n  logger: Logger | undefined\n): boolean =>\n  fieldName.indexOf(BUILTIN_NAME) === 0 ||\n  typename.indexOf(BUILTIN_NAME) === 0 ||\n  !!getField(schema, typename, fieldName, logger);\n\nexport const isInterfaceOfType = (\n  schema: SchemaIntrospector,\n  node: InlineFragmentNode | FragmentDefinitionNode,\n  typename: string | void\n): boolean => {\n  if (!typename) return false;\n  const typeCondition = getTypeCondition(node);\n  if (!typeCondition || typename === typeCondition) {\n    return true;\n  } else if (\n    schema.types!.has(typeCondition) &&\n    schema.types!.get(typeCondition)!.kind === 'OBJECT'\n  ) {\n    return typeCondition === typename;\n  }\n\n  expectAbstractType(schema, typeCondition!);\n  expectObjectType(schema, typename!);\n  return schema.isSubType(typeCondition, typename);\n};\n\nconst getField = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string,\n  logger: Logger | undefined\n) => {\n  if (\n    fieldName.indexOf(BUILTIN_NAME) === 0 ||\n    typename.indexOf(BUILTIN_NAME) === 0\n  )\n    return;\n\n  expectObjectType(schema, typename);\n  const object = schema.types!.get(typename) as SchemaObject;\n  const field = object.fields()[fieldName];\n  if (!field) {\n    warn(\n      'Invalid field: The field `' +\n        fieldName +\n        '` does not exist on `' +\n        typename +\n        '`, ' +\n        'but the GraphQL document expects it to exist.\\n' +\n        'Traversal will continue, however this may lead to undefined behavior!',\n      4,\n      logger\n    );\n  }\n\n  return field;\n};\n\nfunction expectObjectType(schema: SchemaIntrospector, typename: string) {\n  invariant(\n    schema.types!.has(typename) &&\n      schema.types!.get(typename)!.kind === 'OBJECT',\n    'Invalid Object type: The type `' +\n      typename +\n      '` is not an object in the defined schema, ' +\n      'but the GraphQL document is traversing it.',\n    3\n  );\n}\n\nfunction expectAbstractType(schema: SchemaIntrospector, typename: string) {\n  invariant(\n    schema.types!.has(typename) &&\n      (schema.types!.get(typename)!.kind === 'INTERFACE' ||\n        schema.types!.get(typename)!.kind === 'UNION'),\n    'Invalid Abstract type: The type `' +\n      typename +\n      '` is not an Interface or Union type in the defined schema, ' +\n      'but a fragment in the GraphQL document is using it as a type condition.',\n    5\n  );\n}\n\nexport function expectValidKeyingConfig(\n  schema: SchemaIntrospector,\n  keys: KeyingConfig,\n  logger: Logger | undefined\n): void {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const key in keys) {\n      if (!schema.types!.has(key)) {\n        warn(\n          'Invalid Object type: The type `' +\n            key +\n            '` is not an object in the defined schema, but the `keys` option is referencing it.',\n          20,\n          logger\n        );\n      }\n    }\n  }\n}\n\nexport function expectValidUpdatesConfig(\n  schema: SchemaIntrospector,\n  updates: UpdatesConfig,\n  logger: Logger | undefined\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  for (const typename in updates) {\n    if (!updates[typename]) {\n      continue;\n    } else if (!schema.types!.has(typename)) {\n      let addition = '';\n\n      if (\n        typename === 'Mutation' &&\n        schema.mutation &&\n        schema.mutation !== 'Mutation'\n      ) {\n        addition +=\n          '\\nMaybe your config should reference `' + schema.mutation + '`?';\n      } else if (\n        typename === 'Subscription' &&\n        schema.subscription &&\n        schema.subscription !== 'Subscription'\n      ) {\n        addition +=\n          '\\nMaybe your config should reference `' + schema.subscription + '`?';\n      }\n\n      return warn(\n        'Invalid updates type: The type `' +\n          typename +\n          '` is not an object in the defined schema, but the `updates` config is referencing it.' +\n          addition,\n        21,\n        logger\n      );\n    }\n\n    const fields = (schema.types!.get(typename)! as SchemaObject).fields();\n    for (const fieldName in updates[typename]!) {\n      if (!fields[fieldName]) {\n        warn(\n          'Invalid updates field: `' +\n            fieldName +\n            '` on `' +\n            typename +\n            '` is not in the defined schema, but the `updates` config is referencing it.',\n          22,\n          logger\n        );\n      }\n    }\n  }\n}\n\nfunction warnAboutResolver(name: string, logger: Logger | undefined): void {\n  warn(\n    `Invalid resolver: \\`${name}\\` is not in the defined schema, but the \\`resolvers\\` option is referencing it.`,\n    23,\n    logger\n  );\n}\n\nfunction warnAboutAbstractResolver(\n  name: string,\n  kind: 'UNION' | 'INTERFACE',\n  logger: Logger | undefined\n): void {\n  warn(\n    `Invalid resolver: \\`${name}\\` does not match to a concrete type in the schema, but the \\`resolvers\\` option is referencing it. Implement the resolver for the types that ${\n      kind === 'UNION' ? 'make up the union' : 'implement the interface'\n    } instead.`,\n    26,\n    logger\n  );\n}\n\nexport function expectValidResolversConfig(\n  schema: SchemaIntrospector,\n  resolvers: ResolverConfig,\n  logger: Logger | undefined\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  for (const key in resolvers) {\n    if (key === 'Query') {\n      if (schema.query) {\n        const validQueries = (\n          schema.types!.get(schema.query) as SchemaObject\n        ).fields();\n        for (const resolverQuery in resolvers.Query || {}) {\n          if (!validQueries[resolverQuery]) {\n            warnAboutResolver('Query.' + resolverQuery, logger);\n          }\n        }\n      } else {\n        warnAboutResolver('Query', logger);\n      }\n    } else {\n      if (!schema.types!.has(key)) {\n        warnAboutResolver(key, logger);\n      } else if (\n        schema.types!.get(key)!.kind === 'INTERFACE' ||\n        schema.types!.get(key)!.kind === 'UNION'\n      ) {\n        warnAboutAbstractResolver(\n          key,\n          schema.types!.get(key)!.kind as 'INTERFACE' | 'UNION',\n          logger\n        );\n      } else {\n        const validTypeProperties = (\n          schema.types!.get(key) as SchemaObject\n        ).fields();\n        for (const resolverProperty in resolvers[key] || {}) {\n          if (!validTypeProperties[resolverProperty]) {\n            warnAboutResolver(key + '.' + resolverProperty, logger);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport function expectValidOptimisticMutationsConfig(\n  schema: SchemaIntrospector,\n  optimisticMutations: OptimisticMutationConfig,\n  logger: Logger | undefined\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  if (schema.mutation) {\n    const validMutations = (\n      schema.types!.get(schema.mutation) as SchemaObject\n    ).fields();\n    for (const mutation in optimisticMutations) {\n      if (!validMutations[mutation]) {\n        warn(\n          `Invalid optimistic mutation field: \\`${mutation}\\` is not a mutation field in the defined schema, but the \\`optimistic\\` option is referencing it.`,\n          24,\n          logger\n        );\n      }\n    }\n  }\n}\n","import { stringifyVariables } from '@urql/core';\nimport type { FieldArgs, FieldInfo, KeyInfo } from '../types';\n\nexport const keyOfField = (fieldName: string, args?: FieldArgs) =>\n  args ? `${fieldName}(${stringifyVariables(args)})` : fieldName;\n\nexport const joinKeys = (parentKey: string, key: string) =>\n  `${parentKey}.${key}`;\n\nexport const fieldInfoOfKey = (fieldKey: string): FieldInfo => {\n  const parenIndex = fieldKey.indexOf('(');\n  if (parenIndex > -1) {\n    return {\n      fieldKey,\n      fieldName: fieldKey.slice(0, parenIndex),\n      arguments: JSON.parse(fieldKey.slice(parenIndex + 1, -1)),\n    };\n  } else {\n    return {\n      fieldKey,\n      fieldName: fieldKey,\n      arguments: null,\n    };\n  }\n};\n\nexport const serializeKeys = (entityKey: string, fieldKey: string) =>\n  `${entityKey.replace(/\\./g, '%2e')}.${fieldKey}`;\n\nexport const deserializeKeyInfo = (key: string): KeyInfo => {\n  const dotIndex = key.indexOf('.');\n  const entityKey = key.slice(0, dotIndex).replace(/%2e/g, '.');\n  const fieldKey = key.slice(dotIndex + 1);\n  return { entityKey, fieldKey };\n};\n","import { stringifyVariables } from '@urql/core';\n\nimport type {\n  Link,\n  EntityField,\n  FieldInfo,\n  StorageAdapter,\n  SerializedEntries,\n  Dependencies,\n  OperationType,\n  DataField,\n  Data,\n} from '../types';\n\nimport {\n  serializeKeys,\n  deserializeKeyInfo,\n  fieldInfoOfKey,\n  joinKeys,\n} from './keys';\n\nimport { invariant, currentDebugStack } from '../helpers/help';\n\ntype Dict<T> = Record<string, T>;\ntype KeyMap<T> = Map<string, T>;\ntype OperationMap<T> = Map<number, T>;\n\ninterface NodeMap<T> {\n  optimistic: OperationMap<KeyMap<Dict<T | undefined>>>;\n  base: KeyMap<Dict<T>>;\n}\n\nexport interface InMemoryData {\n  /** Flag for whether the data is waiting for hydration */\n  hydrating: boolean;\n  /** Flag for whether deferred tasks have been scheduled yet */\n  defer: boolean;\n  /** A list of entities that have been flagged for gargabe collection since no references to them are left */\n  gc: Set<string>;\n  /** A list of entity+field keys that will be persisted */\n  persist: Set<string>;\n  /** The API's \"Query\" typename which is needed to filter dependencies */\n  queryRootKey: string;\n  /** Number of references to each entity (except \"Query\") */\n  refCount: KeyMap<number>;\n  /** A map of entity fields (key-value entries per entity) */\n  records: NodeMap<EntityField>;\n  /** A map of entity links which are connections from one entity to another (key-value entries per entity) */\n  links: NodeMap<Link>;\n  /** A map of typename to a list of entity-keys belonging to said type */\n  types: Map<string, Set<string>>;\n  /** A set of Query operation keys that are in-flight and deferred/streamed */\n  deferredKeys: Set<number>;\n  /** A set of Query operation keys that are in-flight and awaiting a result */\n  commutativeKeys: Set<number>;\n  /** A set of Query operation keys that have been written to */\n  dirtyKeys: Set<number>;\n  /** The order of optimistic layers */\n  optimisticOrder: number[];\n  /** This may be a persistence adapter that will receive changes in a batch */\n  storage: StorageAdapter | null;\n}\n\nlet currentOwnership: null | WeakSet<any> = null;\nlet currentDataMapping: null | WeakMap<any, any> = null;\nlet currentData: null | InMemoryData = null;\nlet currentOptimisticKey: null | number = null;\nexport let currentOperation: null | OperationType = null;\nexport let currentDependencies: null | Dependencies = null;\nexport let currentForeignData = false;\nexport let currentOptimistic = false;\n\nexport function makeData(data: DataField | void, isArray?: false): Data;\nexport function makeData(data: DataField | void, isArray: true): DataField[];\n\n/** Creates a new data object unless it's been created in this data run */\nexport function makeData(data?: DataField | void, isArray?: boolean) {\n  let newData: Data | Data[] | undefined;\n  if (data) {\n    if (currentOwnership!.has(data)) return data;\n    newData = currentDataMapping!.get(data) as any;\n  }\n\n  if (newData == null) {\n    newData = (isArray ? [] : {}) as any;\n  }\n\n  if (data) {\n    currentDataMapping!.set(data, newData);\n  }\n\n  currentOwnership!.add(newData);\n  return newData;\n}\n\nexport const ownsData = (data?: Data): boolean =>\n  !!data && currentOwnership!.has(data);\n\n/** Before reading or writing the global state needs to be initialised */\nexport const initDataState = (\n  operationType: OperationType,\n  data: InMemoryData,\n  layerKey?: number | null,\n  isOptimistic?: boolean,\n  isForeignData?: boolean\n) => {\n  currentOwnership = new WeakSet();\n  currentDataMapping = new WeakMap();\n  currentOperation = operationType;\n  currentData = data;\n  currentDependencies = new Set();\n  currentOptimistic = !!isOptimistic;\n  currentForeignData = !!isForeignData;\n  if (process.env.NODE_ENV !== 'production') {\n    currentDebugStack.length = 0;\n  }\n\n  if (!layerKey) {\n    currentOptimisticKey = null;\n  } else if (currentOperation === 'read') {\n    // We don't create new layers for read operations and instead simply\n    // apply the currently available layer, if any\n    currentOptimisticKey = layerKey;\n  } else if (\n    isOptimistic ||\n    data.hydrating ||\n    data.optimisticOrder.length > 1\n  ) {\n    // If this operation isn't optimistic and we see it for the first time,\n    // then it must've been optimistic in the past, so we can proactively\n    // clear the optimistic data before writing\n    if (!isOptimistic && !data.commutativeKeys.has(layerKey)) {\n      reserveLayer(data, layerKey);\n    } else if (isOptimistic) {\n      if (\n        data.optimisticOrder.indexOf(layerKey) !== -1 &&\n        !data.commutativeKeys.has(layerKey)\n      ) {\n        data.optimisticOrder.splice(data.optimisticOrder.indexOf(layerKey), 1);\n      }\n      // NOTE: This optimally shouldn't happen as it implies that an optimistic\n      // write is being performed after a concrete write.\n      data.commutativeKeys.delete(layerKey);\n    }\n\n    // An optimistic update of a mutation may force an optimistic layer,\n    // or this Query update may be applied optimistically since it's part\n    // of a commutative chain\n    currentOptimisticKey = layerKey;\n    createLayer(data, layerKey);\n  } else {\n    // Otherwise we don't create an optimistic layer and clear the\n    // operation's one if it already exists\n    // We also do this when only one layer exists to avoid having to squash\n    // any layers at the end of writing this layer\n    currentOptimisticKey = null;\n    deleteLayer(data, layerKey);\n  }\n};\n\n/** Reset the data state after read/write is complete */\nexport const clearDataState = () => {\n  // NOTE: This is only called to check for the invariant to pass\n  if (process.env.NODE_ENV !== 'production') {\n    getCurrentDependencies();\n  }\n\n  const data = currentData!;\n  const layerKey = currentOptimisticKey;\n  currentOptimistic = false;\n  currentOptimisticKey = null;\n\n  // Determine whether the current operation has been a commutative layer\n  if (\n    !data.hydrating &&\n    layerKey &&\n    data.optimisticOrder.indexOf(layerKey) > -1\n  ) {\n    // Squash all layers in reverse order (low priority upwards) that have\n    // been written already\n    let i = data.optimisticOrder.length;\n    while (\n      --i >= 0 &&\n      data.dirtyKeys.has(data.optimisticOrder[i]) &&\n      data.commutativeKeys.has(data.optimisticOrder[i])\n    )\n      squashLayer(data.optimisticOrder[i]);\n  }\n\n  currentOwnership = null;\n  currentDataMapping = null;\n  currentOperation = null;\n  currentData = null;\n  currentDependencies = null;\n  if (process.env.NODE_ENV !== 'production') {\n    currentDebugStack.length = 0;\n  }\n\n  if (process.env.NODE_ENV !== 'test') {\n    // Schedule deferred tasks if we haven't already, and if either a persist or GC run\n    // are likely to be needed\n    if (!data.defer && (data.storage || !data.optimisticOrder.length)) {\n      data.defer = true;\n      setTimeout(() => {\n        initDataState('read', data, null);\n        gc();\n        persistData();\n        clearDataState();\n        data.defer = false;\n      });\n    }\n  }\n};\n\n/** Initialises then resets the data state, which may squash this layer if necessary */\nexport const noopDataState = (\n  data: InMemoryData,\n  layerKey: number | null,\n  isOptimistic?: boolean\n) => {\n  if (layerKey && !isOptimistic) data.deferredKeys.delete(layerKey);\n  initDataState('write', data, layerKey, isOptimistic);\n  clearDataState();\n};\n\n/** As we're writing, we keep around all the records and links we've read or have written to */\nexport const getCurrentDependencies = (): Dependencies => {\n  invariant(\n    currentDependencies !== null,\n    'Invalid Cache call: The cache may only be accessed or mutated during' +\n      'operations like write or query, or as part of its resolvers, updaters, ' +\n      'or optimistic configs.',\n    2\n  );\n\n  return currentDependencies;\n};\n\nconst DEFAULT_EMPTY_SET = new Set<string>();\nexport const make = (queryRootKey: string): InMemoryData => ({\n  hydrating: false,\n  defer: false,\n  gc: new Set(),\n  types: new Map(),\n  persist: new Set(),\n  queryRootKey,\n  refCount: new Map(),\n  links: {\n    optimistic: new Map(),\n    base: new Map(),\n  },\n  records: {\n    optimistic: new Map(),\n    base: new Map(),\n  },\n  deferredKeys: new Set(),\n  commutativeKeys: new Set(),\n  dirtyKeys: new Set(),\n  optimisticOrder: [],\n  storage: null,\n});\n\n/** Adds a node value to a NodeMap (taking optimistic values into account */\nconst setNode = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string,\n  value: T\n) => {\n  if (process.env.NODE_ENV !== 'production') {\n    invariant(\n      currentOperation !== 'read',\n      'Invalid Cache write: You may not write to the cache during cache reads. ' +\n        ' Accesses to `cache.writeFragment`, `cache.updateQuery`, and `cache.link` may ' +\n        ' not be made inside `resolvers` for instance.',\n      27\n    );\n  }\n\n  // Optimistic values are written to a map in the optimistic dict\n  // All other values are written to the base map\n  const keymap: KeyMap<Dict<T | undefined>> = currentOptimisticKey\n    ? map.optimistic.get(currentOptimisticKey)!\n    : map.base;\n\n  // On the map itself we get or create the entity as a dict\n  let entity = keymap.get(entityKey) as Dict<T | undefined>;\n  if (entity === undefined) {\n    keymap.set(entityKey, (entity = Object.create(null)));\n  }\n\n  // If we're setting undefined we delete the node's entry\n  // On optimistic layers we actually set undefined so it can\n  // override the base value\n  if (value === undefined && !currentOptimisticKey) {\n    delete entity[fieldKey];\n  } else {\n    entity[fieldKey] = value;\n  }\n};\n\n/** Gets a node value from a NodeMap (taking optimistic values into account */\nconst getNode = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string\n): T | undefined => {\n  let node: Dict<T | undefined> | undefined;\n  // A read may be initialised to skip layers until its own, which is useful for\n  // reading back written data. It won't skip over optimistic layers however\n  let skip =\n    !currentOptimistic &&\n    currentOperation === 'read' &&\n    currentOptimisticKey &&\n    currentData!.commutativeKeys.has(currentOptimisticKey);\n  // This first iterates over optimistic layers (in order)\n  for (let i = 0, l = currentData!.optimisticOrder.length; i < l; i++) {\n    const layerKey = currentData!.optimisticOrder[i];\n    const optimistic = map.optimistic.get(layerKey);\n    // If we're reading starting from a specific layer, we skip until a match\n    skip = skip && layerKey !== currentOptimisticKey;\n    // If the node and node value exists it is returned, including undefined\n    if (\n      optimistic &&\n      (!skip || !currentData!.commutativeKeys.has(layerKey)) &&\n      (!currentOptimistic ||\n        currentOperation === 'write' ||\n        currentData!.commutativeKeys.has(layerKey)) &&\n      (node = optimistic.get(entityKey)) !== undefined &&\n      fieldKey in node\n    ) {\n      return node[fieldKey];\n    }\n  }\n\n  // Otherwise we read the non-optimistic base value\n  node = map.base.get(entityKey);\n  return node !== undefined ? node[fieldKey] : undefined;\n};\n\n/** Adjusts the reference count of an entity on a refCount dict by \"by\" and updates the gc */\nconst updateRCForEntity = (entityKey: string, by: number): void => {\n  // Retrieve the reference count and adjust it by \"by\"\n  const count = currentData!.refCount.get(entityKey) || 0;\n  const newCount = count + by > 0 ? count + by : 0;\n  currentData!.refCount.set(entityKey, newCount);\n  // Add it to the garbage collection batch if it needs to be deleted or remove it\n  // from the batch if it needs to be kept\n  if (!newCount) currentData!.gc.add(entityKey);\n  else if (!count && newCount) currentData!.gc.delete(entityKey);\n};\n\n/** Adjusts the reference counts of all entities of a link on a refCount dict by \"by\" and updates the gc */\nconst updateRCForLink = (link: Link | undefined, by: number): void => {\n  if (Array.isArray(link)) {\n    for (let i = 0, l = link.length; i < l; i++) updateRCForLink(link[i], by);\n  } else if (typeof link === 'string') {\n    updateRCForEntity(link, by);\n  }\n};\n\n/** Writes all parsed FieldInfo objects of a given node dict to a given array if it hasn't been seen */\nconst extractNodeFields = <T>(\n  fieldInfos: FieldInfo[],\n  seenFieldKeys: Set<string>,\n  node: Dict<T> | undefined\n): void => {\n  if (node !== undefined) {\n    for (const fieldKey in node) {\n      if (!seenFieldKeys.has(fieldKey)) {\n        // If the node hasn't been seen the serialized fieldKey is turnt back into\n        // a rich FieldInfo object that also contains the field's name and arguments\n        fieldInfos.push(fieldInfoOfKey(fieldKey));\n        seenFieldKeys.add(fieldKey);\n      }\n    }\n  }\n};\n\n/** Writes all parsed FieldInfo objects of all nodes in a NodeMap to a given array */\nconst extractNodeMapFields = <T>(\n  fieldInfos: FieldInfo[],\n  seenFieldKeys: Set<string>,\n  entityKey: string,\n  map: NodeMap<T>\n) => {\n  // Extracts FieldInfo for the entity in the base map\n  extractNodeFields(fieldInfos, seenFieldKeys, map.base.get(entityKey));\n\n  // Then extracts FieldInfo for the entity from the optimistic maps\n  for (let i = 0, l = currentData!.optimisticOrder.length; i < l; i++) {\n    const optimistic = map.optimistic.get(currentData!.optimisticOrder[i]);\n    if (optimistic !== undefined) {\n      extractNodeFields(fieldInfos, seenFieldKeys, optimistic.get(entityKey));\n    }\n  }\n};\n\n/** Garbage collects all entities that have been marked as having no references */\nexport const gc = () => {\n  // If we're currently awaiting deferred results, abort GC run\n  if (currentData!.optimisticOrder.length) return;\n\n  // Iterate over all entities that have been marked for deletion\n  // Entities have been marked for deletion in `updateRCForEntity` if\n  // their reference count dropped to 0\n  for (const entityKey of currentData!.gc.keys()) {\n    // Remove the current key from the GC batch\n    currentData!.gc.delete(entityKey);\n\n    // Check first whether the entity has any references,\n    // if so, we skip it from the GC run\n    const rc = currentData!.refCount.get(entityKey) || 0;\n    if (rc > 0) continue;\n\n    const record = currentData!.records.base.get(entityKey);\n    // Delete the reference count, and delete the entity from the GC batch\n    currentData!.refCount.delete(entityKey);\n    currentData!.records.base.delete(entityKey);\n\n    const typename = (record && record.__typename) as string | undefined;\n    if (typename) {\n      const type = currentData!.types.get(typename);\n      if (type) type.delete(entityKey);\n    }\n\n    const linkNode = currentData!.links.base.get(entityKey);\n    if (linkNode) {\n      currentData!.links.base.delete(entityKey);\n      for (const fieldKey in linkNode) updateRCForLink(linkNode[fieldKey], -1);\n    }\n  }\n};\n\nconst updateDependencies = (entityKey: string, fieldKey?: string) => {\n  if (entityKey !== currentData!.queryRootKey) {\n    currentDependencies!.add(entityKey);\n  } else if (fieldKey !== undefined && fieldKey !== '__typename') {\n    currentDependencies!.add(joinKeys(entityKey, fieldKey));\n  }\n};\n\nconst updatePersist = (entityKey: string, fieldKey: string) => {\n  if (!currentOptimistic && currentData!.storage) {\n    currentData!.persist.add(serializeKeys(entityKey, fieldKey));\n  }\n};\n\n/** Reads an entity's field (a \"record\") from data */\nexport const readRecord = (\n  entityKey: string,\n  fieldKey: string\n): EntityField => {\n  updateDependencies(entityKey, fieldKey);\n  return getNode(currentData!.records, entityKey, fieldKey);\n};\n\n/** Reads an entity's link from data */\nexport const readLink = (\n  entityKey: string,\n  fieldKey: string\n): Link | undefined => {\n  updateDependencies(entityKey, fieldKey);\n  return getNode(currentData!.links, entityKey, fieldKey);\n};\n\nexport const getEntitiesForType = (typename: string): Set<string> =>\n  currentData!.types.get(typename) || DEFAULT_EMPTY_SET;\n\nexport const writeType = (typename: string, entityKey: string) => {\n  const existingTypes = currentData!.types.get(typename);\n  if (!existingTypes) {\n    const typeSet = new Set<string>();\n    typeSet.add(entityKey);\n    currentData!.types.set(typename, typeSet);\n  } else {\n    existingTypes.add(entityKey);\n  }\n};\n\n/** Writes an entity's field (a \"record\") to data */\nexport const writeRecord = (\n  entityKey: string,\n  fieldKey: string,\n  value?: EntityField\n) => {\n  updateDependencies(entityKey, fieldKey);\n  updatePersist(entityKey, fieldKey);\n  setNode(currentData!.records, entityKey, fieldKey, value);\n};\n\nexport const hasField = (entityKey: string, fieldKey: string): boolean =>\n  readRecord(entityKey, fieldKey) !== undefined ||\n  readLink(entityKey, fieldKey) !== undefined;\n\n/** Writes an entity's link to data */\nexport const writeLink = (\n  entityKey: string,\n  fieldKey: string,\n  link?: Link | undefined\n) => {\n  // Retrieve the link NodeMap from either an optimistic or the base layer\n  const links = currentOptimisticKey\n    ? currentData!.links.optimistic.get(currentOptimisticKey)\n    : currentData!.links.base;\n  // Update the reference count for the link\n  if (!currentOptimisticKey) {\n    const entityLinks = links && links.get(entityKey);\n    updateRCForLink(entityLinks && entityLinks[fieldKey], -1);\n    updateRCForLink(link, 1);\n  }\n  // Update persistence batch and dependencies\n  updateDependencies(entityKey, fieldKey);\n  updatePersist(entityKey, fieldKey);\n  // Update the link\n  setNode(currentData!.links, entityKey, fieldKey, link);\n};\n\n/** Reserves an optimistic layer and preorders it */\nexport const reserveLayer = (\n  data: InMemoryData,\n  layerKey: number,\n  hasNext?: boolean\n) => {\n  // Find the current index for the layer, and remove it from\n  // the order if it exists already\n  let index = data.optimisticOrder.indexOf(layerKey);\n  if (index > -1) data.optimisticOrder.splice(index, 1);\n\n  if (hasNext) {\n    data.deferredKeys.add(layerKey);\n    // If the layer has future results then we'll move it past any layer that's\n    // still empty, so currently pending operations will take precedence over it\n    for (\n      index = index > -1 ? index : 0;\n      index < data.optimisticOrder.length &&\n      !data.deferredKeys.has(data.optimisticOrder[index]) &&\n      (!data.dirtyKeys.has(data.optimisticOrder[index]) ||\n        !data.commutativeKeys.has(data.optimisticOrder[index]));\n      index++\n    );\n  } else {\n    data.deferredKeys.delete(layerKey);\n    // Protect optimistic layers from being turned into non-optimistic layers\n    // while preserving optimistic data\n    if (index > -1 && !data.commutativeKeys.has(layerKey))\n      clearLayer(data, layerKey);\n    index = 0;\n  }\n\n  // Register the layer with the deferred or \"top\" index and\n  // mark it as commutative\n  data.optimisticOrder.splice(index, 0, layerKey);\n  data.commutativeKeys.add(layerKey);\n};\n\n/** Checks whether a given layer exists */\nexport const hasLayer = (data: InMemoryData, layerKey: number) =>\n  data.commutativeKeys.has(layerKey) ||\n  data.optimisticOrder.indexOf(layerKey) > -1;\n\n/** Creates an optimistic layer of links and records */\nconst createLayer = (data: InMemoryData, layerKey: number) => {\n  if (data.optimisticOrder.indexOf(layerKey) === -1) {\n    data.optimisticOrder.unshift(layerKey);\n  }\n\n  if (!data.dirtyKeys.has(layerKey)) {\n    data.dirtyKeys.add(layerKey);\n    data.links.optimistic.set(layerKey, new Map());\n    data.records.optimistic.set(layerKey, new Map());\n  }\n};\n\n/** Clears all links and records of an optimistic layer */\nconst clearLayer = (data: InMemoryData, layerKey: number) => {\n  if (data.dirtyKeys.has(layerKey)) {\n    data.dirtyKeys.delete(layerKey);\n    data.records.optimistic.delete(layerKey);\n    data.links.optimistic.delete(layerKey);\n    data.deferredKeys.delete(layerKey);\n  }\n};\n\n/** Deletes links and records of an optimistic layer, and the layer itself */\nconst deleteLayer = (data: InMemoryData, layerKey: number) => {\n  const index = data.optimisticOrder.indexOf(layerKey);\n  if (index > -1) {\n    data.optimisticOrder.splice(index, 1);\n    data.commutativeKeys.delete(layerKey);\n  }\n\n  clearLayer(data, layerKey);\n};\n\n/** Merges an optimistic layer of links and records into the base data */\nconst squashLayer = (layerKey: number) => {\n  // Hide current dependencies from squashing operations\n  const previousDependencies = currentDependencies;\n  currentDependencies = new Set();\n  currentOperation = 'write';\n\n  const links = currentData!.links.optimistic.get(layerKey);\n  if (links) {\n    for (const entry of links.entries()) {\n      const entityKey = entry[0];\n      const keyMap = entry[1];\n      for (const fieldKey in keyMap)\n        writeLink(entityKey, fieldKey, keyMap[fieldKey]);\n    }\n  }\n\n  const records = currentData!.records.optimistic.get(layerKey);\n  if (records) {\n    for (const entry of records.entries()) {\n      const entityKey = entry[0];\n      const keyMap = entry[1];\n      for (const fieldKey in keyMap)\n        writeRecord(entityKey, fieldKey, keyMap[fieldKey]);\n    }\n  }\n\n  currentDependencies = previousDependencies;\n  deleteLayer(currentData!, layerKey);\n};\n\n/** Return an array of FieldInfo (info on all the fields and their arguments) for a given entity */\nexport const inspectFields = (entityKey: string): FieldInfo[] => {\n  const { links, records } = currentData!;\n  const fieldInfos: FieldInfo[] = [];\n  const seenFieldKeys: Set<string> = new Set();\n  // Update dependencies\n  updateDependencies(entityKey);\n  // Extract FieldInfos to the fieldInfos array for links and records\n  // This also deduplicates by keeping track of fieldKeys in the seenFieldKeys Set\n  extractNodeMapFields(fieldInfos, seenFieldKeys, entityKey, links);\n  extractNodeMapFields(fieldInfos, seenFieldKeys, entityKey, records);\n  return fieldInfos;\n};\n\nexport const persistData = () => {\n  if (currentData!.storage) {\n    currentOptimistic = true;\n    currentOperation = 'read';\n    const entries: SerializedEntries = {};\n    for (const key of currentData!.persist.keys()) {\n      const { entityKey, fieldKey } = deserializeKeyInfo(key);\n      let x: void | Link | EntityField;\n      if ((x = readLink(entityKey, fieldKey)) !== undefined) {\n        entries[key] = `:${stringifyVariables(x)}`;\n      } else if ((x = readRecord(entityKey, fieldKey)) !== undefined) {\n        entries[key] = stringifyVariables(x);\n      } else {\n        entries[key] = undefined;\n      }\n    }\n\n    currentOptimistic = false;\n    currentData!.storage.writeData(entries);\n    currentData!.persist.clear();\n  }\n};\n\nexport const hydrateData = (\n  data: InMemoryData,\n  storage: StorageAdapter,\n  entries: SerializedEntries\n) => {\n  initDataState('write', data, null);\n\n  for (const key in entries) {\n    const value = entries[key];\n    if (value !== undefined) {\n      const { entityKey, fieldKey } = deserializeKeyInfo(key);\n      if (value[0] === ':') {\n        if (readLink(entityKey, fieldKey) === undefined)\n          writeLink(entityKey, fieldKey, JSON.parse(value.slice(1)));\n      } else {\n        if (readRecord(entityKey, fieldKey) === undefined)\n          writeRecord(entityKey, fieldKey, JSON.parse(value));\n      }\n    }\n  }\n\n  data.storage = storage;\n  data.hydrating = false;\n  clearDataState();\n};\n","import type { CombinedError, ErrorLike, FormattedNode } from '@urql/core';\n\nimport type {\n  FieldNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\nimport { Kind } from '@0no-co/graphql.web';\n\nimport type { SelectionSet } from '../ast';\nimport {\n  isDeferred,\n  getTypeCondition,\n  getSelectionSet,\n  getName,\n  isOptional,\n} from '../ast';\n\nimport { warn, pushDebugNode, popDebugNode } from '../helpers/help';\nimport { hasField, currentOperation, currentOptimistic } from '../store/data';\nimport { keyOfField } from '../store/keys';\nimport type { Store } from '../store/store';\n\nimport { getFieldArguments, shouldInclude, isInterfaceOfType } from '../ast';\n\nimport type {\n  Fragments,\n  Variables,\n  DataField,\n  NullArray,\n  Link,\n  Entity,\n  Data,\n  Logger,\n} from '../types';\n\nexport interface Context {\n  store: Store;\n  variables: Variables;\n  fragments: Fragments;\n  parentTypeName: string;\n  parentKey: string;\n  parentFieldKey: string;\n  parent: Data;\n  fieldName: string;\n  error: ErrorLike | undefined;\n  partial: boolean;\n  hasNext: boolean;\n  optimistic: boolean;\n  __internal: {\n    path: Array<string | number>;\n    errorMap: { [path: string]: ErrorLike } | undefined;\n  };\n}\n\nexport let contextRef: Context | null = null;\nexport let deferRef = false;\nexport let optionalRef: boolean | undefined = undefined;\n\n// Checks whether the current data field is a cache miss because of a GraphQLError\nexport const getFieldError = (ctx: Context): ErrorLike | undefined =>\n  ctx.__internal.path.length > 0 && ctx.__internal.errorMap\n    ? ctx.__internal.errorMap[ctx.__internal.path.join('.')]\n    : undefined;\n\nexport const makeContext = (\n  store: Store,\n  variables: Variables,\n  fragments: Fragments,\n  typename: string,\n  entityKey: string,\n  error: CombinedError | undefined\n): Context => {\n  const ctx: Context = {\n    store,\n    variables,\n    fragments,\n    parent: { __typename: typename },\n    parentTypeName: typename,\n    parentKey: entityKey,\n    parentFieldKey: '',\n    fieldName: '',\n    error: undefined,\n    partial: false,\n    hasNext: false,\n    optimistic: currentOptimistic,\n    __internal: {\n      path: [],\n      errorMap: undefined,\n    },\n  };\n\n  if (error && error.graphQLErrors) {\n    for (let i = 0; i < error.graphQLErrors.length; i++) {\n      const graphQLError = error.graphQLErrors[i];\n      if (graphQLError.path && graphQLError.path.length) {\n        if (!ctx.__internal.errorMap)\n          ctx.__internal.errorMap = Object.create(null);\n        ctx.__internal.errorMap![graphQLError.path.join('.')] = graphQLError;\n      }\n    }\n  }\n\n  return ctx;\n};\n\nexport const updateContext = (\n  ctx: Context,\n  data: Data,\n  typename: string,\n  entityKey: string,\n  fieldKey: string,\n  fieldName: string\n) => {\n  contextRef = ctx;\n  ctx.parent = data;\n  ctx.parentTypeName = typename;\n  ctx.parentKey = entityKey;\n  ctx.parentFieldKey = fieldKey;\n  ctx.fieldName = fieldName;\n  ctx.error = getFieldError(ctx);\n};\n\nconst isFragmentHeuristicallyMatching = (\n  node: FormattedNode<InlineFragmentNode | FragmentDefinitionNode>,\n  typename: void | string,\n  entityKey: string,\n  vars: Variables,\n  logger?: Logger\n) => {\n  if (!typename) return false;\n  const typeCondition = getTypeCondition(node);\n  if (!typeCondition || typename === typeCondition) return true;\n\n  warn(\n    'Heuristic Fragment Matching: A fragment is trying to match against the `' +\n      typename +\n      '` type, ' +\n      'but the type condition is `' +\n      typeCondition +\n      '`. Since GraphQL allows for interfaces `' +\n      typeCondition +\n      '` may be an ' +\n      'interface.\\nA schema needs to be defined for this match to be deterministic, ' +\n      'otherwise the fragment will be matched heuristically!',\n    16,\n    logger\n  );\n\n  return (\n    currentOperation === 'write' ||\n    !getSelectionSet(node).some(node => {\n      if (node.kind !== Kind.FIELD) return false;\n      const fieldKey = keyOfField(getName(node), getFieldArguments(node, vars));\n      return !hasField(entityKey, fieldKey);\n    })\n  );\n};\n\ninterface SelectionIterator {\n  (): FormattedNode<FieldNode> | undefined;\n}\n\n// NOTE: Outside of this file, we expect `_defer` to always be reset to `false`\nexport function makeSelectionIterator(\n  typename: undefined | string,\n  entityKey: string,\n  _defer: false,\n  _optional: undefined,\n  selectionSet: FormattedNode<SelectionSet>,\n  ctx: Context\n): SelectionIterator;\n// NOTE: Inside this file we expect the state to be recursively passed on\nexport function makeSelectionIterator(\n  typename: undefined | string,\n  entityKey: string,\n  _defer: boolean,\n  _optional: undefined | boolean,\n  selectionSet: FormattedNode<SelectionSet>,\n  ctx: Context\n): SelectionIterator;\n\nexport function makeSelectionIterator(\n  typename: undefined | string,\n  entityKey: string,\n  _defer: boolean,\n  _optional: boolean | undefined,\n  selectionSet: FormattedNode<SelectionSet>,\n  ctx: Context\n): SelectionIterator {\n  let child: SelectionIterator | void;\n  let index = 0;\n\n  return function next() {\n    let node: FormattedNode<FieldNode> | undefined;\n    while (child || index < selectionSet.length) {\n      node = undefined;\n      deferRef = _defer;\n      optionalRef = _optional;\n      if (child) {\n        if ((node = child())) {\n          return node;\n        } else {\n          child = undefined;\n          if (process.env.NODE_ENV !== 'production') popDebugNode();\n        }\n      } else {\n        const select = selectionSet[index++];\n        if (!shouldInclude(select, ctx.variables)) {\n          /*noop*/\n        } else if (select.kind !== Kind.FIELD) {\n          // A fragment is either referred to by FragmentSpread or inline\n          const fragment =\n            select.kind !== Kind.INLINE_FRAGMENT\n              ? ctx.fragments[getName(select)]\n              : select;\n          if (fragment) {\n            const isMatching =\n              !fragment.typeCondition ||\n              (ctx.store.schema\n                ? isInterfaceOfType(ctx.store.schema, fragment, typename)\n                : isFragmentHeuristicallyMatching(\n                    fragment,\n                    typename,\n                    entityKey,\n                    ctx.variables,\n                    ctx.store.logger\n                  ));\n            if (isMatching) {\n              if (process.env.NODE_ENV !== 'production')\n                pushDebugNode(typename, fragment);\n              const isFragmentOptional = isOptional(select);\n              child = makeSelectionIterator(\n                typename,\n                entityKey,\n                _defer || isDeferred(select, ctx.variables),\n                isFragmentOptional !== undefined\n                  ? isFragmentOptional\n                  : _optional,\n                getSelectionSet(fragment),\n                ctx\n              );\n            }\n          }\n        } else if (currentOperation === 'write' || !select._generated) {\n          return select;\n        }\n      }\n    }\n  };\n}\n\nexport const ensureData = (x: DataField): Data | NullArray<Data> | null =>\n  x == null ? null : (x as Data | NullArray<Data>);\n\nexport const ensureLink = (store: Store, ref: Link<Entity>): Link => {\n  if (!ref) {\n    return ref || null;\n  } else if (Array.isArray(ref)) {\n    const link = new Array(ref.length);\n    for (let i = 0, l = link.length; i < l; i++)\n      link[i] = ensureLink(store, ref[i]);\n    return link;\n  }\n\n  const link = store.keyOfEntity(ref);\n  if (!link && ref && typeof ref === 'object') {\n    warn(\n      \"Can't generate a key for link(...) item.\" +\n        '\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        ref.__typename +\n        '`.',\n      12,\n      store.logger\n    );\n  }\n\n  return link;\n};\n","import type { FormattedNode, CombinedError } from '@urql/core';\nimport { formatDocument } from '@urql/core';\n\nimport type {\n  FieldNode,\n  DocumentNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\n\nimport type { SelectionSet } from '../ast';\nimport {\n  getSelectionSet,\n  getName,\n  getFragmentTypeName,\n  getFieldAlias,\n  getFragments,\n  getMainOperation,\n  normalizeVariables,\n  getFieldArguments,\n  getDirectives,\n} from '../ast';\n\nimport type {\n  Variables,\n  Data,\n  DataField,\n  Link,\n  OperationRequest,\n  Dependencies,\n  Resolver,\n} from '../types';\n\nimport { joinKeys, keyOfField } from '../store/keys';\nimport type { Store } from '../store/store';\nimport * as InMemoryData from '../store/data';\nimport { warn, pushDebugNode, popDebugNode } from '../helpers/help';\n\nimport type { Context } from './shared';\nimport {\n  makeSelectionIterator,\n  ensureData,\n  makeContext,\n  updateContext,\n  getFieldError,\n  deferRef,\n  optionalRef,\n} from './shared';\n\nimport {\n  isFieldAvailableOnType,\n  isFieldNullable,\n  isListNullable,\n} from '../ast';\n\nexport interface QueryResult {\n  dependencies: Dependencies;\n  partial: boolean;\n  hasNext: boolean;\n  data: null | Data;\n}\n\n/** Reads a GraphQL query from the cache.\n * @internal\n */\nexport const __initAnd_query = (\n  store: Store,\n  request: OperationRequest,\n  data?: Data | null | undefined,\n  error?: CombinedError | undefined,\n  key?: number\n): QueryResult => {\n  InMemoryData.initDataState('read', store.data, key);\n  const result = _query(store, request, data, error);\n  InMemoryData.clearDataState();\n  return result;\n};\n\n/** Reads a GraphQL query from the cache.\n * @internal\n */\nexport const _query = (\n  store: Store,\n  request: OperationRequest,\n  input?: Data | null | undefined,\n  error?: CombinedError | undefined\n): QueryResult => {\n  const query = formatDocument(request.query);\n  const operation = getMainOperation(query);\n  const rootKey = store.rootFields[operation.operation];\n  const rootSelect = getSelectionSet(operation);\n\n  const ctx = makeContext(\n    store,\n    normalizeVariables(operation, request.variables),\n    getFragments(query),\n    rootKey,\n    rootKey,\n    error\n  );\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(rootKey, operation);\n  }\n\n  // NOTE: This may reuse \"previous result data\" as indicated by the\n  // `originalData` argument in readRoot(). This behaviour isn't used\n  // for readSelection() however, which always produces results from\n  // scratch\n  const data =\n    rootKey !== ctx.store.rootFields['query']\n      ? readRoot(ctx, rootKey, rootSelect, input || InMemoryData.makeData())\n      : readSelection(\n          ctx,\n          rootKey,\n          rootSelect,\n          input || InMemoryData.makeData()\n        );\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n    InMemoryData.getCurrentDependencies();\n  }\n\n  return {\n    dependencies: InMemoryData.currentDependencies!,\n    partial: ctx.partial || !data,\n    hasNext: ctx.hasNext,\n    data: data || null,\n  };\n};\n\nconst readRoot = (\n  ctx: Context,\n  entityKey: string,\n  select: FormattedNode<SelectionSet>,\n  input: Data\n): Data => {\n  const typename = ctx.store.rootNames[entityKey]\n    ? entityKey\n    : input.__typename;\n  if (typeof typename !== 'string') {\n    return input;\n  }\n\n  const iterate = makeSelectionIterator(\n    entityKey,\n    entityKey,\n    false,\n    undefined,\n    select,\n    ctx\n  );\n\n  let node: FormattedNode<FieldNode> | void;\n  let hasChanged = InMemoryData.currentForeignData;\n  const output = InMemoryData.makeData(input);\n  while ((node = iterate())) {\n    const fieldAlias = getFieldAlias(node);\n    const fieldValue = input[fieldAlias];\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n    // We temporarily store the data field in here, but undefined\n    // means that the value is missing from the cache\n    let dataFieldValue: void | DataField;\n    if (node.selectionSet && fieldValue !== null) {\n      dataFieldValue = readRootField(\n        ctx,\n        getSelectionSet(node),\n        ensureData(fieldValue)\n      );\n    } else {\n      dataFieldValue = fieldValue;\n    }\n\n    // Check for any referential changes in the field's value\n    hasChanged = hasChanged || dataFieldValue !== fieldValue;\n    if (dataFieldValue !== undefined) output[fieldAlias] = dataFieldValue!;\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n  }\n\n  return hasChanged ? output : input;\n};\n\nconst readRootField = (\n  ctx: Context,\n  select: FormattedNode<SelectionSet>,\n  originalData: Link<Data>\n): Link<Data> => {\n  if (Array.isArray(originalData)) {\n    const newData = new Array(originalData.length);\n    let hasChanged = InMemoryData.currentForeignData;\n    for (let i = 0, l = originalData.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read the root field's value\n      newData[i] = readRootField(ctx, select, originalData[i]);\n      hasChanged = hasChanged || newData[i] !== originalData[i];\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n    }\n\n    return hasChanged ? newData : originalData;\n  } else if (originalData === null) {\n    return null;\n  }\n\n  // Write entity to key that falls back to the given parentFieldKey\n  const entityKey = ctx.store.keyOfEntity(originalData);\n  if (entityKey !== null) {\n    // We assume that since this is used for result data this can never be undefined,\n    // since the result data has already been written to the cache\n    return readSelection(ctx, entityKey, select, originalData) || null;\n  } else {\n    return readRoot(ctx, originalData.__typename, select, originalData);\n  }\n};\n\nexport const _queryFragment = (\n  store: Store,\n  query: FormattedNode<DocumentNode>,\n  entity: Partial<Data> | string,\n  variables?: Variables,\n  fragmentName?: string\n): Data | null => {\n  const fragments = getFragments(query);\n\n  let fragment: FormattedNode<FragmentDefinitionNode>;\n  if (fragmentName) {\n    fragment = fragments[fragmentName]!;\n    if (!fragment) {\n      warn(\n        'readFragment(...) was called with a fragment name that does not exist.\\n' +\n          'You provided ' +\n          fragmentName +\n          ' but could only find ' +\n          Object.keys(fragments).join(', ') +\n          '.',\n        6,\n        store.logger\n      );\n\n      return null;\n    }\n  } else {\n    const names = Object.keys(fragments);\n    fragment = fragments[names[0]]!;\n    if (!fragment) {\n      warn(\n        'readFragment(...) was called with an empty fragment.\\n' +\n          'You have to call it with at least one fragment in your GraphQL document.',\n        6,\n        store.logger\n      );\n\n      return null;\n    }\n  }\n\n  const typename = getFragmentTypeName(fragment);\n  if (typeof entity !== 'string' && !entity.__typename)\n    entity.__typename = typename;\n  const entityKey = store.keyOfEntity(entity as Data);\n  if (!entityKey) {\n    warn(\n      \"Can't generate a key for readFragment(...).\\n\" +\n        'You have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        typename +\n        '`.',\n      7,\n      store.logger\n    );\n\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(typename, fragment);\n  }\n\n  const ctx = makeContext(\n    store,\n    variables || {},\n    fragments,\n    typename,\n    entityKey,\n    undefined\n  );\n\n  const result =\n    readSelection(\n      ctx,\n      entityKey,\n      getSelectionSet(fragment),\n      InMemoryData.makeData()\n    ) || null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n\n  return result;\n};\n\nfunction getFieldResolver(\n  directives: ReturnType<typeof getDirectives>,\n  typename: string,\n  fieldName: string,\n  ctx: Context\n): Resolver | void {\n  const resolvers = ctx.store.resolvers[typename];\n  const fieldResolver = resolvers && resolvers[fieldName];\n\n  let directiveResolver: Resolver | undefined;\n  for (const name in directives) {\n    const directiveNode = directives[name];\n    if (\n      directiveNode &&\n      name !== 'include' &&\n      name !== 'skip' &&\n      ctx.store.directives[name]\n    ) {\n      directiveResolver = ctx.store.directives[name](\n        getFieldArguments(directiveNode, ctx.variables)\n      );\n      if (process.env.NODE_ENV === 'production') return directiveResolver;\n      break;\n    }\n  }\n\n  if (fieldResolver && directiveResolver) {\n    warn(\n      `A resolver and directive is being used at \"${typename}.${fieldName}\" simultaneously. Only the directive will apply.`,\n      28,\n      ctx.store.logger\n    );\n  }\n\n  return directiveResolver || fieldResolver;\n}\n\nconst readSelection = (\n  ctx: Context,\n  key: string,\n  select: FormattedNode<SelectionSet>,\n  input: Data,\n  result?: Data\n): Data | undefined => {\n  const { store } = ctx;\n  const isQuery = key === store.rootFields.query;\n\n  const entityKey = (result && store.keyOfEntity(result)) || key;\n  if (!isQuery && !!ctx.store.rootNames[entityKey]) {\n    warn(\n      'Invalid root traversal: A selection was being read on `' +\n        entityKey +\n        '` which is an uncached root type.\\n' +\n        'The `' +\n        ctx.store.rootFields.mutation +\n        '` and `' +\n        ctx.store.rootFields.subscription +\n        '` types are special ' +\n        'Operation Root Types and cannot be read back from the cache.',\n      25,\n      store.logger\n    );\n  }\n\n  const typename = !isQuery\n    ? InMemoryData.readRecord(entityKey, '__typename') ||\n      (result && result.__typename)\n    : key;\n\n  if (typeof typename !== 'string') {\n    return;\n  } else if (result && typename !== result.__typename) {\n    warn(\n      'Invalid resolver data: The resolver at `' +\n        entityKey +\n        '` returned an ' +\n        'invalid typename that could not be reconciled with the cache.',\n      8,\n      store.logger\n    );\n\n    return;\n  }\n\n  const iterate = makeSelectionIterator(\n    typename,\n    entityKey,\n    false,\n    undefined,\n    select,\n    ctx\n  );\n\n  let hasFields = false;\n  let hasNext = false;\n  let hasChanged = InMemoryData.currentForeignData;\n  let node: FormattedNode<FieldNode> | void;\n  const hasPartials = ctx.partial;\n  const output = InMemoryData.makeData(input);\n  while ((node = iterate()) !== undefined) {\n    // Derive the needed data from our node.\n    const fieldName = getName(node);\n    const fieldArgs = getFieldArguments(node, ctx.variables);\n    const fieldAlias = getFieldAlias(node);\n    const directives = getDirectives(node);\n    const resolver = getFieldResolver(directives, typename, fieldName, ctx);\n    const fieldKey = keyOfField(fieldName, fieldArgs);\n    const key = joinKeys(entityKey, fieldKey);\n    const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n    const resultValue = result ? result[fieldName] : undefined;\n\n    if (process.env.NODE_ENV !== 'production' && store.schema && typename) {\n      isFieldAvailableOnType(\n        store.schema,\n        typename,\n        fieldName,\n        ctx.store.logger\n      );\n    }\n\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n    // We temporarily store the data field in here, but undefined\n    // means that the value is missing from the cache\n    let dataFieldValue: void | DataField = undefined;\n\n    if (fieldName === '__typename') {\n      // We directly assign the typename as it's already available\n      dataFieldValue = typename;\n    } else if (resultValue !== undefined && node.selectionSet === undefined) {\n      // The field is a scalar and can be retrieved directly from the result\n      dataFieldValue = resultValue;\n    } else if (InMemoryData.currentOperation === 'read' && resolver) {\n      // We have a resolver for this field.\n      // Prepare the actual fieldValue, so that the resolver can use it,\n      // as to avoid the user having to do `cache.resolve(parent, info.fieldKey)`\n      // only to get a scalar value.\n      let parent = output;\n      if (node.selectionSet === undefined && fieldValue !== undefined) {\n        parent = {\n          ...output,\n          [fieldAlias]: fieldValue,\n          [fieldName]: fieldValue,\n        };\n      }\n\n      // We have to update the information in context to reflect the info\n      // that the resolver will receive\n      updateContext(ctx, parent, typename, entityKey, fieldKey, fieldName);\n\n      dataFieldValue = resolver(\n        parent,\n        fieldArgs || ({} as Variables),\n        store,\n        ctx\n      );\n\n      if (node.selectionSet) {\n        // When it has a selection set we are resolving an entity with a\n        // subselection. This can either be a list or an object.\n        dataFieldValue = resolveResolverResult(\n          ctx,\n          typename,\n          fieldName,\n          key,\n          getSelectionSet(node),\n          (output[fieldAlias] !== undefined\n            ? output[fieldAlias]\n            : input[fieldAlias]) as Data,\n          dataFieldValue,\n          InMemoryData.ownsData(input)\n        );\n      }\n\n      if (\n        store.schema &&\n        dataFieldValue === null &&\n        !isFieldNullable(store.schema, typename, fieldName, ctx.store.logger)\n      ) {\n        // Special case for when null is not a valid value for the\n        // current field\n        return undefined;\n      }\n    } else if (!node.selectionSet) {\n      // The field is a scalar but isn't on the result, so it's retrieved from the cache\n      dataFieldValue = fieldValue;\n    } else if (resultValue !== undefined) {\n      // We start walking the nested resolver result here\n      dataFieldValue = resolveResolverResult(\n        ctx,\n        typename,\n        fieldName,\n        key,\n        getSelectionSet(node),\n        (output[fieldAlias] !== undefined\n          ? output[fieldAlias]\n          : input[fieldAlias]) as Data,\n        resultValue,\n        InMemoryData.ownsData(input)\n      );\n    } else {\n      // Otherwise we attempt to get the missing field from the cache\n      const link = InMemoryData.readLink(entityKey, fieldKey);\n\n      if (link !== undefined) {\n        dataFieldValue = resolveLink(\n          ctx,\n          link,\n          typename,\n          fieldName,\n          getSelectionSet(node),\n          (output[fieldAlias] !== undefined\n            ? output[fieldAlias]\n            : input[fieldAlias]) as Data,\n          InMemoryData.ownsData(input)\n        );\n      } else if (typeof fieldValue === 'object' && fieldValue !== null) {\n        // The entity on the field was invalid but can still be recovered\n        dataFieldValue = fieldValue;\n      }\n    }\n\n    // Now that dataFieldValue has been retrieved it'll be set on data\n    // If it's uncached (undefined) but nullable we can continue assembling\n    // a partial query result\n    if (\n      !deferRef &&\n      dataFieldValue === undefined &&\n      (directives.optional ||\n        (optionalRef && !directives.required) ||\n        !!getFieldError(ctx) ||\n        (store.schema &&\n          isFieldNullable(store.schema, typename, fieldName, ctx.store.logger)))\n    ) {\n      // The field is uncached or has errored, so it'll be set to null and skipped\n      ctx.partial = true;\n      dataFieldValue = null;\n    } else if (\n      dataFieldValue === null &&\n      (directives.required || optionalRef === false)\n    ) {\n      if (\n        ctx.store.logger &&\n        process.env.NODE_ENV !== 'production' &&\n        InMemoryData.currentOperation === 'read'\n      ) {\n        ctx.store.logger(\n          'debug',\n          `Got value \"null\" for required field \"${fieldName}\"${\n            fieldArgs ? ` with args ${JSON.stringify(fieldArgs)}` : ''\n          } on entity \"${entityKey}\"`\n        );\n      }\n      dataFieldValue = undefined;\n    } else {\n      hasFields = hasFields || fieldName !== '__typename';\n    }\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n    // Check for any referential changes in the field's value\n    hasChanged = hasChanged || dataFieldValue !== input[fieldAlias];\n    if (dataFieldValue !== undefined) {\n      output[fieldAlias] = dataFieldValue;\n    } else if (deferRef) {\n      hasNext = true;\n    } else {\n      if (\n        ctx.store.logger &&\n        process.env.NODE_ENV !== 'production' &&\n        InMemoryData.currentOperation === 'read'\n      ) {\n        ctx.store.logger(\n          'debug',\n          `No value for field \"${fieldName}\"${\n            fieldArgs ? ` with args ${JSON.stringify(fieldArgs)}` : ''\n          } on entity \"${entityKey}\"`\n        );\n      }\n      // If the field isn't deferred or partial then we have to abort and also reset\n      // the partial field\n      ctx.partial = hasPartials;\n      return undefined;\n    }\n  }\n\n  ctx.partial = ctx.partial || hasPartials;\n  ctx.hasNext = ctx.hasNext || hasNext;\n  return isQuery && ctx.partial && !hasFields\n    ? undefined\n    : hasChanged\n    ? output\n    : input;\n};\n\nconst resolveResolverResult = (\n  ctx: Context,\n  typename: string,\n  fieldName: string,\n  key: string,\n  select: FormattedNode<SelectionSet>,\n  prevData: void | null | Data | Data[],\n  result: void | DataField,\n  isOwnedData: boolean\n): DataField | void => {\n  if (Array.isArray(result)) {\n    const { store } = ctx;\n    // Check whether values of the list may be null; for resolvers we assume\n    // that they can be, since it's user-provided data\n    const _isListNullable = store.schema\n      ? isListNullable(store.schema, typename, fieldName, ctx.store.logger)\n      : false;\n    const hasPartials = ctx.partial;\n    const data = InMemoryData.makeData(prevData, true);\n    let hasChanged =\n      InMemoryData.currentForeignData ||\n      !Array.isArray(prevData) ||\n      result.length !== prevData.length;\n    for (let i = 0, l = result.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read resolver result\n      const childResult = resolveResolverResult(\n        ctx,\n        typename,\n        fieldName,\n        joinKeys(key, `${i}`),\n        select,\n        prevData != null ? prevData[i] : undefined,\n        result[i],\n        isOwnedData\n      );\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n      // Check the result for cache-missed values\n      if (childResult === undefined && !_isListNullable) {\n        ctx.partial = hasPartials;\n        return undefined;\n      } else {\n        ctx.partial =\n          ctx.partial || (childResult === undefined && _isListNullable);\n        data[i] = childResult != null ? childResult : null;\n        hasChanged = hasChanged || data[i] !== prevData![i];\n      }\n    }\n\n    return hasChanged ? data : prevData;\n  } else if (result === null || result === undefined) {\n    return result;\n  } else if (isOwnedData && prevData === null) {\n    return null;\n  } else if (isDataOrKey(result)) {\n    const data = (prevData || InMemoryData.makeData(prevData)) as Data;\n    return typeof result === 'string'\n      ? readSelection(ctx, result, select, data)\n      : readSelection(ctx, key, select, data, result);\n  } else {\n    warn(\n      'Invalid resolver value: The field at `' +\n        key +\n        '` is a scalar (number, boolean, etc)' +\n        ', but the GraphQL query expects a selection set for this field.',\n      9,\n      ctx.store.logger\n    );\n\n    return undefined;\n  }\n};\n\nconst resolveLink = (\n  ctx: Context,\n  link: Link | Link[],\n  typename: string,\n  fieldName: string,\n  select: FormattedNode<SelectionSet>,\n  prevData: void | null | Data | Data[],\n  isOwnedData: boolean\n): DataField | undefined => {\n  if (Array.isArray(link)) {\n    const { store } = ctx;\n    const _isListNullable = store.schema\n      ? isListNullable(store.schema, typename, fieldName, ctx.store.logger)\n      : false;\n    const newLink = InMemoryData.makeData(prevData, true);\n    const hasPartials = ctx.partial;\n    let hasChanged =\n      InMemoryData.currentForeignData ||\n      !Array.isArray(prevData) ||\n      link.length !== prevData.length;\n    for (let i = 0, l = link.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read the link\n      const childLink = resolveLink(\n        ctx,\n        link[i],\n        typename,\n        fieldName,\n        select,\n        prevData != null ? prevData[i] : undefined,\n        isOwnedData\n      );\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n      // Check the result for cache-missed values\n      if (childLink === undefined && !_isListNullable) {\n        ctx.partial = hasPartials;\n        return undefined;\n      } else {\n        ctx.partial =\n          ctx.partial || (childLink === undefined && _isListNullable);\n        newLink[i] = childLink || null;\n        hasChanged = hasChanged || newLink[i] !== prevData![i];\n      }\n    }\n\n    return hasChanged ? newLink : (prevData as Data[]);\n  } else if (link === null || (prevData === null && isOwnedData)) {\n    return null;\n  }\n\n  return readSelection(\n    ctx,\n    link,\n    select,\n    (prevData || InMemoryData.makeData(prevData)) as Data\n  );\n};\n\nconst isDataOrKey = (x: any): x is string | Data =>\n  typeof x === 'string' ||\n  (typeof x === 'object' && typeof (x as any).__typename === 'string');\n","import type { FormattedNode, CombinedError } from '@urql/core';\nimport { formatDocument } from '@urql/core';\n\nimport type {\n  FieldNode,\n  DocumentNode,\n  FragmentDefinitionNode,\n} from '@0no-co/graphql.web';\n\nimport type { SelectionSet } from '../ast';\nimport {\n  getFragments,\n  getMainOperation,\n  normalizeVariables,\n  getFieldArguments,\n  isFieldAvailableOnType,\n  getSelectionSet,\n  getName,\n  getFragmentTypeName,\n  getFieldAlias,\n} from '../ast';\n\nimport { invariant, warn, pushDebugNode, popDebugNode } from '../helpers/help';\n\nimport type {\n  NullArray,\n  Variables,\n  Data,\n  Link,\n  OperationRequest,\n  Dependencies,\n  EntityField,\n  OptimisticMutationResolver,\n} from '../types';\n\nimport { joinKeys, keyOfField } from '../store/keys';\nimport type { Store } from '../store/store';\nimport * as InMemoryData from '../store/data';\n\nimport type { Context } from './shared';\nimport {\n  makeSelectionIterator,\n  ensureData,\n  makeContext,\n  updateContext,\n  getFieldError,\n  deferRef,\n} from './shared';\n\nexport interface WriteResult {\n  data: null | Data;\n  dependencies: Dependencies;\n}\n\n/** Writes a GraphQL response to the cache.\n * @internal\n */\nexport const __initAnd_write = (\n  store: Store,\n  request: OperationRequest,\n  data: Data,\n  error?: CombinedError | undefined,\n  key?: number\n): WriteResult => {\n  InMemoryData.initDataState('write', store.data, key || null);\n  const result = _write(store, request, data, error);\n  InMemoryData.clearDataState();\n  return result;\n};\n\nexport const __initAnd_writeOptimistic = (\n  store: Store,\n  request: OperationRequest,\n  key: number\n): WriteResult => {\n  if (process.env.NODE_ENV !== 'production') {\n    invariant(\n      getMainOperation(request.query).operation === 'mutation',\n      'writeOptimistic(...) was called with an operation that is not a mutation.\\n' +\n        'This case is unsupported and should never occur.',\n      10\n    );\n  }\n\n  InMemoryData.initDataState('write', store.data, key, true);\n  const result = _write(store, request, {} as Data, undefined);\n  InMemoryData.clearDataState();\n  return result;\n};\n\nexport const _write = (\n  store: Store,\n  request: OperationRequest,\n  data?: Data,\n  error?: CombinedError | undefined\n) => {\n  if (process.env.NODE_ENV !== 'production') {\n    InMemoryData.getCurrentDependencies();\n  }\n\n  const query = formatDocument(request.query);\n  const operation = getMainOperation(query);\n  const result: WriteResult = {\n    data: data || InMemoryData.makeData(),\n    dependencies: InMemoryData.currentDependencies!,\n  };\n  const kind = store.rootFields[operation.operation];\n\n  const ctx = makeContext(\n    store,\n    normalizeVariables(operation, request.variables),\n    getFragments(query),\n    kind,\n    kind,\n    error\n  );\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(kind, operation);\n  }\n\n  writeSelection(ctx, kind, getSelectionSet(operation), result.data!);\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n\n  return result;\n};\n\nexport const _writeFragment = (\n  store: Store,\n  query: FormattedNode<DocumentNode>,\n  data: Partial<Data>,\n  variables?: Variables,\n  fragmentName?: string\n) => {\n  const fragments = getFragments(query);\n  let fragment: FormattedNode<FragmentDefinitionNode>;\n  if (fragmentName) {\n    fragment = fragments[fragmentName]!;\n    if (!fragment) {\n      warn(\n        'writeFragment(...) was called with a fragment name that does not exist.\\n' +\n          'You provided ' +\n          fragmentName +\n          ' but could only find ' +\n          Object.keys(fragments).join(', ') +\n          '.',\n        11,\n        store.logger\n      );\n\n      return null;\n    }\n  } else {\n    const names = Object.keys(fragments);\n    fragment = fragments[names[0]]!;\n    if (!fragment) {\n      warn(\n        'writeFragment(...) was called with an empty fragment.\\n' +\n          'You have to call it with at least one fragment in your GraphQL document.',\n        11,\n        store.logger\n      );\n\n      return null;\n    }\n  }\n\n  const typename = getFragmentTypeName(fragment);\n  const dataToWrite = { __typename: typename, ...data } as Data;\n  const entityKey = store.keyOfEntity(dataToWrite);\n  if (!entityKey) {\n    return warn(\n      \"Can't generate a key for writeFragment(...) data.\\n\" +\n        'You have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        typename +\n        '`.',\n      12,\n      store.logger\n    );\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(typename, fragment);\n  }\n\n  const ctx = makeContext(\n    store,\n    variables || {},\n    fragments,\n    typename,\n    entityKey,\n    undefined\n  );\n\n  writeSelection(ctx, entityKey, getSelectionSet(fragment), dataToWrite);\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n};\n\nconst writeSelection = (\n  ctx: Context,\n  entityKey: undefined | string,\n  select: FormattedNode<SelectionSet>,\n  data: Data\n) => {\n  // These fields determine how we write. The `Query` root type is written\n  // like a normal entity, hence, we use `rootField` with a default to determine\n  // this. All other root names (Subscription & Mutation) are in a different\n  // write mode\n  const rootField = ctx.store.rootNames[entityKey!] || 'query';\n  const isRoot = !!ctx.store.rootNames[entityKey!];\n\n  let typename = isRoot ? entityKey : data.__typename;\n  if (!typename && entityKey && ctx.optimistic) {\n    typename = InMemoryData.readRecord(entityKey, '__typename') as\n      | string\n      | undefined;\n  }\n\n  if (!typename) {\n    warn(\n      \"Couldn't find __typename when writing.\\n\" +\n        \"If you're writing to the cache manually have to pass a `__typename` property on each entity in your data.\",\n      14,\n      ctx.store.logger\n    );\n    return;\n  } else if (!isRoot && entityKey) {\n    InMemoryData.writeRecord(entityKey, '__typename', typename);\n    InMemoryData.writeType(typename, entityKey);\n  }\n\n  const updates = ctx.store.updates[typename];\n  const iterate = makeSelectionIterator(\n    typename,\n    entityKey || typename,\n    false,\n    undefined,\n    select,\n    ctx\n  );\n\n  let node: FormattedNode<FieldNode> | void;\n  while ((node = iterate())) {\n    const fieldName = getName(node);\n    const fieldArgs = getFieldArguments(node, ctx.variables);\n    const fieldKey = keyOfField(fieldName, fieldArgs);\n    const fieldAlias = getFieldAlias(node);\n    let fieldValue = data[ctx.optimistic ? fieldName : fieldAlias];\n\n    if (\n      // Skip typename fields and assume they've already been written above\n      fieldName === '__typename' ||\n      // Fields marked as deferred that aren't defined must be skipped\n      // Otherwise, we also ignore undefined values in optimistic updaters\n      (fieldValue === undefined &&\n        (deferRef || (ctx.optimistic && rootField === 'query')))\n    ) {\n      continue;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (ctx.store.schema && typename && fieldName !== '__typename') {\n        isFieldAvailableOnType(\n          ctx.store.schema,\n          typename,\n          fieldName,\n          ctx.store.logger\n        );\n      }\n    }\n\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n\n    // Execute optimistic mutation functions on root fields, or execute recursive functions\n    // that have been returned on optimistic objects\n    let resolver: OptimisticMutationResolver | undefined;\n    if (ctx.optimistic && rootField === 'mutation') {\n      resolver = ctx.store.optimisticMutations[fieldName];\n      if (!resolver) continue;\n    } else if (ctx.optimistic && typeof fieldValue === 'function') {\n      resolver = fieldValue as any;\n    }\n\n    // Execute the field-level resolver to retrieve its data\n    if (resolver) {\n      // We have to update the context to reflect up-to-date ResolveInfo\n      updateContext(\n        ctx,\n        data,\n        typename,\n        entityKey || typename,\n        fieldKey,\n        fieldName\n      );\n      fieldValue = ensureData(resolver(fieldArgs || {}, ctx.store, ctx));\n    }\n\n    if (fieldValue === undefined) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (\n          !entityKey ||\n          !InMemoryData.hasField(entityKey, fieldKey) ||\n          (ctx.optimistic && !InMemoryData.readRecord(entityKey, '__typename'))\n        ) {\n          const expected =\n            node.selectionSet === undefined\n              ? 'scalar (number, boolean, etc)'\n              : 'selection set';\n\n          warn(\n            'Invalid undefined: The field at `' +\n              fieldKey +\n              '` is `undefined`, but the GraphQL query expects a ' +\n              expected +\n              ' for this field.',\n            13,\n            ctx.store.logger\n          );\n        }\n      }\n\n      continue; // Skip this field\n    }\n\n    if (node.selectionSet) {\n      // Process the field and write links for the child entities that have been written\n      if (entityKey && rootField === 'query') {\n        const key = joinKeys(entityKey, fieldKey);\n        const link = writeField(\n          ctx,\n          getSelectionSet(node),\n          ensureData(fieldValue),\n          key,\n          ctx.optimistic\n            ? InMemoryData.readLink(entityKey || typename, fieldKey)\n            : undefined\n        );\n        InMemoryData.writeLink(entityKey || typename, fieldKey, link);\n      } else {\n        writeField(ctx, getSelectionSet(node), ensureData(fieldValue));\n      }\n    } else if (entityKey && rootField === 'query') {\n      // This is a leaf node, so we're setting the field's value directly\n      InMemoryData.writeRecord(\n        entityKey || typename,\n        fieldKey,\n        (fieldValue !== null || !getFieldError(ctx)\n          ? fieldValue\n          : undefined) as EntityField\n      );\n    }\n\n    // We run side-effect updates after the default, normalized updates\n    // so that the data is already available in-store if necessary\n    const updater = updates && updates[fieldName];\n    if (updater) {\n      // We have to update the context to reflect up-to-date ResolveInfo\n      updateContext(\n        ctx,\n        data,\n        typename,\n        entityKey || typename,\n        fieldKey,\n        fieldName\n      );\n\n      data[fieldName] = fieldValue;\n      updater(data, fieldArgs || {}, ctx.store, ctx);\n    }\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n  }\n};\n\n// A pattern to match typenames of types that are likely never keyable\nconst KEYLESS_TYPE_RE = /^__|PageInfo|(Connection|Edge)$/;\n\nconst writeField = (\n  ctx: Context,\n  select: FormattedNode<SelectionSet>,\n  data: null | Data | NullArray<Data>,\n  parentFieldKey?: string,\n  prevLink?: Link\n): Link | undefined => {\n  if (Array.isArray(data)) {\n    const newData = new Array(data.length);\n    for (let i = 0, l = data.length; i < l; i++) {\n      // Add the current index to the walked path before processing the link\n      ctx.__internal.path.push(i);\n      // Append the current index to the parentFieldKey fallback\n      const indexKey = parentFieldKey\n        ? joinKeys(parentFieldKey, `${i}`)\n        : undefined;\n      // Recursively write array data\n      const prevIndex = prevLink != null ? prevLink[i] : undefined;\n      const links = writeField(ctx, select, data[i], indexKey, prevIndex);\n      // Link cannot be expressed as a recursive type\n      newData[i] = links as string | null;\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n    }\n\n    return newData;\n  } else if (data === null) {\n    return getFieldError(ctx) ? undefined : null;\n  }\n\n  const entityKey =\n    ctx.store.keyOfEntity(data) ||\n    (typeof prevLink === 'string' ? prevLink : null);\n  const typename = data.__typename;\n\n  if (\n    parentFieldKey &&\n    !ctx.store.keys[data.__typename] &&\n    entityKey === null &&\n    typeof typename === 'string' &&\n    !KEYLESS_TYPE_RE.test(typename)\n  ) {\n    warn(\n      'Invalid key: The GraphQL query at the field at `' +\n        parentFieldKey +\n        '` has a selection set, ' +\n        'but no key could be generated for the data at this field.\\n' +\n        'You have to request `id` or `_id` fields for all selection sets or create ' +\n        'a custom `keys` config for `' +\n        typename +\n        '`.\\n' +\n        'Entities without keys will be embedded directly on the parent entity. ' +\n        'If this is intentional, create a `keys` config for `' +\n        typename +\n        '` that always returns null.',\n      15,\n      ctx.store.logger\n    );\n  }\n\n  const childKey = entityKey || parentFieldKey;\n  writeSelection(ctx, childKey, select, data);\n  return childKey || null;\n};\n","import * as InMemoryData from '../store/data';\nimport { keyOfField } from '../store/keys';\nimport type { FieldArgs } from '../types';\n\ninterface PartialFieldInfo {\n  fieldKey: string;\n}\n\nexport const invalidateEntity = (\n  entityKey: string,\n  field?: string,\n  args?: FieldArgs\n) => {\n  const fields: PartialFieldInfo[] = field\n    ? [{ fieldKey: keyOfField(field, args) }]\n    : InMemoryData.inspectFields(entityKey);\n\n  for (let i = 0, l = fields.length; i < l; i++) {\n    const { fieldKey } = fields[i];\n    if (InMemoryData.readLink(entityKey, fieldKey) !== undefined) {\n      InMemoryData.writeLink(entityKey, fieldKey, undefined);\n    } else {\n      InMemoryData.writeRecord(entityKey, fieldKey, undefined);\n    }\n  }\n};\n\nexport const invalidateType = (typename: string) => {\n  const types = InMemoryData.getEntitiesForType(typename);\n  for (const entity of types) {\n    invalidateEntity(entity);\n  }\n};\n","import type { TypedDocumentNode } from '@urql/core';\nimport { formatDocument, createRequest } from '@urql/core';\n\nimport type {\n  Cache,\n  FieldInfo,\n  ResolverConfig,\n  DataField,\n  Variables,\n  FieldArgs,\n  Link,\n  Data,\n  QueryInput,\n  UpdatesConfig,\n  OptimisticMutationConfig,\n  KeyingConfig,\n  Entity,\n  CacheExchangeOpts,\n  DirectivesConfig,\n  Logger,\n} from '../types';\n\nimport { invariant } from '../helpers/help';\nimport { contextRef, ensureLink } from '../operations/shared';\nimport { _query, _queryFragment } from '../operations/query';\nimport { _write, _writeFragment } from '../operations/write';\nimport { invalidateEntity, invalidateType } from '../operations/invalidate';\nimport { keyOfField } from './keys';\nimport * as InMemoryData from './data';\n\nimport type { SchemaIntrospector } from '../ast';\nimport {\n  buildClientSchema,\n  expectValidKeyingConfig,\n  expectValidUpdatesConfig,\n  expectValidResolversConfig,\n  expectValidOptimisticMutationsConfig,\n} from '../ast';\n\ntype DocumentNode = TypedDocumentNode<any, any>;\ntype RootField = 'query' | 'mutation' | 'subscription';\n\n/** Implementation of the {@link Cache} interface as created internally by the {@link cacheExchange}.\n * @internal\n */\nexport class Store<\n  C extends Partial<CacheExchangeOpts> = Partial<CacheExchangeOpts>,\n> implements Cache\n{\n  data: InMemoryData.InMemoryData;\n\n  logger?: Logger;\n  directives: DirectivesConfig;\n  resolvers: ResolverConfig;\n  updates: UpdatesConfig;\n  optimisticMutations: OptimisticMutationConfig;\n  keys: KeyingConfig;\n  globalIDs: Set<string> | boolean;\n  schema?: SchemaIntrospector;\n\n  rootFields: { query: string; mutation: string; subscription: string };\n  rootNames: { [name: string]: RootField | void };\n\n  constructor(opts?: C) {\n    if (!opts) opts = {} as C;\n\n    this.logger = opts.logger;\n    this.resolvers = opts.resolvers || {};\n    this.directives = opts.directives || {};\n    this.optimisticMutations = opts.optimistic || {};\n    this.keys = opts.keys || {};\n\n    this.globalIDs = Array.isArray(opts.globalIDs)\n      ? new Set(opts.globalIDs)\n      : !!opts.globalIDs;\n\n    let queryName = 'Query';\n    let mutationName = 'Mutation';\n    let subscriptionName = 'Subscription';\n    if (opts.schema) {\n      const schema = buildClientSchema(opts.schema);\n      queryName = schema.query || queryName;\n      mutationName = schema.mutation || mutationName;\n      subscriptionName = schema.subscription || subscriptionName;\n      // Only add schema introspector if it has types info\n      if (schema.types) this.schema = schema;\n    }\n\n    this.updates = opts.updates || {};\n\n    this.rootFields = {\n      query: queryName,\n      mutation: mutationName,\n      subscription: subscriptionName,\n    };\n\n    this.rootNames = {\n      [queryName]: 'query',\n      [mutationName]: 'mutation',\n      [subscriptionName]: 'subscription',\n    };\n\n    this.data = InMemoryData.make(queryName);\n\n    if (this.schema && process.env.NODE_ENV !== 'production') {\n      expectValidKeyingConfig(this.schema, this.keys, this.logger);\n      expectValidUpdatesConfig(this.schema, this.updates, this.logger);\n      expectValidResolversConfig(this.schema, this.resolvers, this.logger);\n      expectValidOptimisticMutationsConfig(\n        this.schema,\n        this.optimisticMutations,\n        this.logger\n      );\n    }\n  }\n\n  keyOfField(fieldName: string, fieldArgs?: FieldArgs) {\n    return keyOfField(fieldName, fieldArgs);\n  }\n\n  keyOfEntity(data: Entity) {\n    // In resolvers and updaters we may have a specific parent\n    // object available that can be used to skip to a specific parent\n    // key directly without looking at its incomplete properties\n    if (contextRef && data === contextRef.parent) {\n      return contextRef.parentKey;\n    } else if (data == null || typeof data === 'string') {\n      return data || null;\n    } else if (!data.__typename) {\n      return null;\n    } else if (this.rootNames[data.__typename]) {\n      return data.__typename;\n    }\n\n    let key: string | null = null;\n    if (this.keys[data.__typename]) {\n      key = this.keys[data.__typename](data) || null;\n    } else if (data.id != null) {\n      key = `${data.id}`;\n    } else if (data._id != null) {\n      key = `${data._id}`;\n    }\n\n    const typename = data.__typename;\n    const globalID =\n      this.globalIDs === true ||\n      (this.globalIDs && this.globalIDs.has(typename));\n    return globalID || !key ? key : `${typename}:${key}`;\n  }\n\n  resolve(\n    entity: Entity,\n    field: string,\n    args?: FieldArgs\n  ): DataField | undefined {\n    const entityKey = this.keyOfEntity(entity);\n    if (entityKey) {\n      const fieldKey = keyOfField(field, args);\n      const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n      if (fieldValue !== undefined) return fieldValue;\n      let fieldLink = InMemoryData.readLink(entityKey, fieldKey);\n      if (fieldLink !== undefined) fieldLink = ensureLink(this, fieldLink);\n      return fieldLink;\n    }\n  }\n\n  resolveFieldByKey(entity: Entity, field: string, args?: FieldArgs) {\n    return this.resolve(entity, field, args);\n  }\n\n  invalidate(entity: Entity, field?: string, args?: FieldArgs) {\n    const entityKey = this.keyOfEntity(entity);\n    const shouldInvalidateType =\n      entity &&\n      typeof entity === 'string' &&\n      !field &&\n      !args &&\n      !this.resolve(entity, '__typename');\n\n    if (shouldInvalidateType) {\n      invalidateType(entity);\n    } else {\n      invariant(\n        entityKey,\n        \"Can't generate a key for invalidate(...).\\n\" +\n          'You have to pass an id or _id field or create a custom `keys` field for `' +\n          (typeof entity === 'object'\n            ? (entity as Data).__typename\n            : entity + '`.'),\n        19\n      );\n\n      invalidateEntity(entityKey, field, args);\n    }\n  }\n\n  inspectFields(entity: Entity): FieldInfo[] {\n    const entityKey = this.keyOfEntity(entity);\n    return entityKey ? InMemoryData.inspectFields(entityKey) : [];\n  }\n\n  updateQuery<T = Data, V = Variables>(\n    input: QueryInput<T, V>,\n    updater: (data: T | null) => T | null\n  ): void {\n    const request = createRequest(input.query, input.variables!);\n    const output = updater(this.readQuery(request));\n    if (output !== null) {\n      _write(this, request, output as any, undefined);\n    }\n  }\n\n  readQuery<T = Data, V = Variables>(input: QueryInput<T, V>): T | null {\n    const request = createRequest(input.query, input.variables!);\n    return _query(this, request, undefined, undefined).data as T | null;\n  }\n\n  readFragment<T = Data, V = Variables>(\n    fragment: DocumentNode | TypedDocumentNode<T, V>,\n    entity: string | Data | T,\n    variables?: V,\n    fragmentName?: string\n  ): T | null {\n    return _queryFragment(\n      this,\n      formatDocument(fragment),\n      entity as Data,\n      variables as any,\n      fragmentName\n    ) as T | null;\n  }\n\n  writeFragment<T = Data, V = Variables>(\n    fragment: DocumentNode | TypedDocumentNode<T, V>,\n    data: T,\n    variables?: V,\n    fragmentName?: string\n  ): void {\n    _writeFragment(\n      this,\n      formatDocument(fragment),\n      data as Data,\n      variables as any,\n      fragmentName\n    );\n  }\n\n  link(\n    entity: Entity,\n    field: string,\n    args: FieldArgs,\n    link: Link<Entity>\n  ): void;\n\n  link(entity: Entity, field: string, link: Link<Entity>): void;\n\n  link(\n    entity: Entity,\n    field: string,\n    ...rest: [FieldArgs, Link<Entity>] | [Link<Entity>]\n  ): void {\n    const args = rest.length === 2 ? rest[0] : null;\n    const link = rest.length === 2 ? rest[1] : rest[0];\n    const entityKey = this.keyOfEntity(entity);\n    if (entityKey) {\n      InMemoryData.writeLink(\n        entityKey,\n        keyOfField(field, args),\n        ensureLink(this, link)\n      );\n    }\n  }\n}\n","import type {\n  IntrospectionQuery,\n  IntrospectionTypeRef,\n  IntrospectionInputValue,\n  IntrospectionType,\n} from './graphql';\n\nexport interface SchemaField {\n  name: string;\n  type: IntrospectionTypeRef;\n  args(): Record<string, IntrospectionInputValue | void>;\n}\n\nexport interface SchemaObject {\n  name: string;\n  kind: 'INTERFACE' | 'OBJECT';\n  interfaces(): Record<string, unknown>;\n  fields(): Record<string, SchemaField | void>;\n}\n\nexport interface SchemaUnion {\n  name: string;\n  kind: 'UNION';\n  types(): Record<string, unknown>;\n}\n\nexport interface SchemaIntrospector {\n  query: string | null;\n  mutation: string | null;\n  subscription: string | null;\n  types?: Map<string, SchemaObject | SchemaUnion>;\n  isSubType(abstract: string, possible: string): boolean;\n}\n\nexport interface PartialIntrospectionSchema {\n  queryType: { name: string; kind?: any };\n  mutationType?: { name: string; kind?: any } | null;\n  subscriptionType?: { name: string; kind?: any } | null;\n  types?: readonly any[];\n}\n\nexport type IntrospectionData =\n  | IntrospectionQuery\n  | { __schema: PartialIntrospectionSchema };\n\nexport const buildClientSchema = ({\n  __schema,\n}: IntrospectionData): SchemaIntrospector => {\n  const typemap: Map<string, SchemaObject | SchemaUnion> = new Map();\n\n  const buildNameMap = <T extends { name: string }>(\n    arr: ReadonlyArray<T>\n  ): (() => { [name: string]: T }) => {\n    let map: Record<string, T> | void;\n    return () => {\n      if (!map) {\n        map = {};\n        for (let i = 0; i < arr.length; i++) map[arr[i].name] = arr[i];\n      }\n      return map;\n    };\n  };\n\n  const buildType = (\n    type: IntrospectionType\n  ): SchemaObject | SchemaUnion | void => {\n    switch (type.kind) {\n      case 'OBJECT':\n      case 'INTERFACE':\n        return {\n          name: type.name,\n          kind: type.kind as 'OBJECT' | 'INTERFACE',\n          interfaces: buildNameMap(type.interfaces || []),\n          fields: buildNameMap(\n            type.fields!.map((field: any) => ({\n              name: field.name,\n              type: field.type,\n              args: buildNameMap(field.args),\n            }))\n          ),\n        } as SchemaObject;\n      case 'UNION':\n        return {\n          name: type.name,\n          kind: type.kind as 'UNION',\n          types: buildNameMap(type.possibleTypes || []),\n        } as SchemaUnion;\n    }\n  };\n\n  const schema: SchemaIntrospector = {\n    query: __schema.queryType ? __schema.queryType.name : null,\n    mutation: __schema.mutationType ? __schema.mutationType.name : null,\n    subscription: __schema.subscriptionType\n      ? __schema.subscriptionType.name\n      : null,\n    types: undefined,\n    isSubType(abstract: string, possible: string) {\n      const abstractType = typemap.get(abstract);\n      const possibleType = typemap.get(possible);\n      if (!abstractType || !possibleType) {\n        return false;\n      } else if (abstractType.kind === 'UNION') {\n        return !!abstractType.types()[possible];\n      } else if (\n        abstractType.kind !== 'OBJECT' &&\n        possibleType.kind === 'OBJECT'\n      ) {\n        return !!possibleType.interfaces()[abstract];\n      } else {\n        return abstract === possible;\n      }\n    },\n  };\n\n  if (__schema.types) {\n    schema.types = typemap;\n    for (let i = 0; i < __schema.types.length; i++) {\n      const type = __schema.types[i];\n      if (type && type.name) {\n        const out = buildType(type);\n        if (out) typemap.set(type.name, out);\n      }\n    }\n  }\n\n  return schema;\n};\n","import type { Operation, RequestPolicy, OperationDebugMeta } from '@urql/core';\nimport { makeOperation } from '@urql/core';\n\n// Returns the given operation result with added cacheOutcome meta field\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationDebugMeta\n): Operation =>\n  makeOperation(operation.kind, operation, {\n    ...operation.context,\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n\n// Copy an operation and change the requestPolicy to skip the cache\nexport const toRequestPolicy = (\n  operation: Operation,\n  requestPolicy: RequestPolicy\n): Operation => {\n  return makeOperation(operation.kind, operation, {\n    ...operation.context,\n    requestPolicy,\n  });\n};\n","import type {\n  Exchange,\n  Operation,\n  OperationResult,\n  RequestPolicy,\n  CacheOutcome,\n} from '@urql/core';\nimport { formatDocument, makeOperation } from '@urql/core';\n\nimport type { Source } from 'wonka';\nimport {\n  filter,\n  map,\n  merge,\n  pipe,\n  share,\n  fromArray,\n  mergeMap,\n  empty,\n} from 'wonka';\n\nimport { _query } from './operations/query';\nimport { _write } from './operations/write';\nimport { addMetadata, toRequestPolicy } from './helpers/operation';\nimport { filterVariables, getMainOperation } from './ast';\nimport { Store } from './store/store';\nimport type { Data, Dependencies, CacheExchangeOpts } from './types';\n\nimport {\n  initDataState,\n  clearDataState,\n  noopDataState,\n  hydrateData,\n  reserveLayer,\n  hasLayer,\n} from './store/data';\n\ninterface OperationResultWithMeta extends Partial<OperationResult> {\n  operation: Operation;\n  outcome: CacheOutcome;\n  dependencies: Dependencies;\n  hasNext: boolean;\n}\n\ntype Operations = Set<number>;\ntype OperationMap = Map<number, Operation>;\ntype ResultMap = Map<number, Data | null>;\ntype OptimisticDependencies = Map<number, Dependencies>;\ntype DependentOperations = Map<string, Operations>;\n\n/** Exchange factory that creates a normalized cache exchange.\n *\n * @param opts - A {@link CacheExchangeOpts} configuration object.\n * @returns the created normalized cache {@link Exchange}.\n *\n * @remarks\n * Graphcache is a normalized cache, enabled by using the `cacheExchange`\n * in place of `@urql/core`’s. A normalized GraphQL cache uses typenames\n * and key fields in the result to share a single copy for each unique\n * entity across all queries.\n *\n * The `cacheExchange` may be passed a {@link CacheExchangeOpts} object\n * to define custom resolvers, custom updates for mutations,\n * optimistic updates, or to add custom key fields per type.\n *\n * @see {@link https://urql.dev/goto/docs/graphcache} for the full Graphcache docs.\n */\nexport const cacheExchange =\n  <C extends Partial<CacheExchangeOpts>>(opts?: C): Exchange =>\n  ({ forward, client, dispatchDebug }) => {\n    const store = new Store<C>(opts);\n\n    if (opts && opts.storage) {\n      store.data.hydrating = true;\n      opts.storage.readData().then(entries => {\n        hydrateData(store.data, opts!.storage!, entries);\n        if (opts.storage!.onCacheHydrated) opts.storage!.onCacheHydrated();\n      });\n    }\n\n    const optimisticKeysToDependencies: OptimisticDependencies = new Map();\n    const mutationResultBuffer: OperationResult[] = [];\n    const operations: OperationMap = new Map();\n    const results: ResultMap = new Map();\n    const blockedDependencies: Dependencies = new Set();\n    const requestedRefetch: Operations = new Set();\n    const deps: DependentOperations = new Map();\n\n    let reexecutingOperations: Operations = new Set();\n    let dependentOperations: Operations = new Set();\n\n    const isBlockedByOptimisticUpdate = (\n      dependencies: Dependencies\n    ): boolean => {\n      for (const dep of dependencies.values())\n        if (blockedDependencies.has(dep)) return true;\n      return false;\n    };\n\n    const collectPendingOperations = (\n      pendingOperations: Operations,\n      dependencies: undefined | Dependencies\n    ) => {\n      if (dependencies) {\n        // Collect operations that will be updated due to cache changes\n        for (const dep of dependencies.values()) {\n          const keys = deps.get(dep);\n          if (keys) for (const key of keys.values()) pendingOperations.add(key);\n        }\n      }\n    };\n\n    const executePendingOperations = (\n      operation: Operation,\n      pendingOperations: Operations,\n      isOptimistic: boolean\n    ) => {\n      // Reexecute collected operations and delete them from the mapping\n      for (const key of pendingOperations.values()) {\n        if (key !== operation.key) {\n          const op = operations.get(key);\n          if (op) {\n            // Collect all dependent operations if the reexecuting operation is a query\n            if (operation.kind === 'query') dependentOperations.add(key);\n            let policy: RequestPolicy = 'cache-first';\n            if (requestedRefetch.has(key)) {\n              requestedRefetch.delete(key);\n              policy = 'cache-and-network';\n            }\n            client.reexecuteOperation(toRequestPolicy(op, policy));\n          }\n        }\n      }\n\n      if (!isOptimistic) {\n        // Upon completion, all dependent operations become reexecuting operations, preventing\n        // them from reexecuting prior operations again, causing infinite loops\n        const _reexecutingOperations = reexecutingOperations;\n        if (operation.kind === 'query') {\n          (reexecutingOperations = dependentOperations).add(operation.key);\n        }\n        (dependentOperations = _reexecutingOperations).clear();\n      }\n    };\n\n    // This registers queries with the data layer to ensure commutativity\n    const prepareForwardedOperation = (operation: Operation) => {\n      let optimistic = false;\n      if (operation.kind === 'query') {\n        // Pre-reserve the position of the result layer\n        reserveLayer(store.data, operation.key);\n        operations.set(operation.key, operation);\n      } else if (operation.kind === 'teardown') {\n        // Delete reference to operation if any exists to release it\n        operations.delete(operation.key);\n        results.delete(operation.key);\n        reexecutingOperations.delete(operation.key);\n        // Mark operation layer as done\n        noopDataState(store.data, operation.key);\n        return operation;\n      } else if (\n        operation.kind === 'mutation' &&\n        operation.context.requestPolicy !== 'network-only'\n      ) {\n        operations.set(operation.key, operation);\n        // This executes an optimistic update for mutations and registers it if necessary\n        initDataState('write', store.data, operation.key, true, false);\n        const { dependencies } = _write(\n          store,\n          operation as any,\n          undefined,\n          undefined\n        );\n        clearDataState();\n        if (dependencies.size) {\n          // Update blocked optimistic dependencies\n          for (const dep of dependencies.values()) blockedDependencies.add(dep);\n          // Store optimistic dependencies for update\n          optimisticKeysToDependencies.set(operation.key, dependencies);\n          // Update related queries\n          const pendingOperations: Operations = new Set();\n          collectPendingOperations(pendingOperations, dependencies);\n          executePendingOperations(operation, pendingOperations, true);\n          // Mark operation as optimistic\n          optimistic = true;\n        }\n      }\n\n      return makeOperation(\n        operation.kind,\n        {\n          key: operation.key,\n          query: formatDocument(operation.query),\n          variables: operation.variables\n            ? filterVariables(\n                getMainOperation(operation.query),\n                operation.variables\n              )\n            : operation.variables,\n        },\n        { ...operation.context, optimistic }\n      );\n    };\n\n    // This updates the known dependencies for the passed operation\n    const updateDependencies = (op: Operation, dependencies: Dependencies) => {\n      for (const dep of dependencies.values()) {\n        let depOps = deps.get(dep);\n        if (!depOps) deps.set(dep, (depOps = new Set()));\n        depOps.add(op.key);\n      }\n    };\n\n    // Retrieves a query result from cache and adds an `isComplete` hint\n    // This hint indicates whether the result is \"complete\" or not\n    const operationResultFromCache = (\n      operation: Operation\n    ): OperationResultWithMeta => {\n      initDataState('read', store.data, undefined, false, false);\n      const result = _query(\n        store,\n        operation,\n        results.get(operation.key),\n        undefined\n      );\n      clearDataState();\n      const cacheOutcome: CacheOutcome = result.data\n        ? !result.partial && !result.hasNext\n          ? 'hit'\n          : 'partial'\n        : 'miss';\n\n      results.set(operation.key, result.data);\n      operations.set(operation.key, operation);\n      updateDependencies(operation, result.dependencies);\n\n      return {\n        outcome: cacheOutcome,\n        operation,\n        data: result.data,\n        dependencies: result.dependencies,\n        hasNext: result.hasNext,\n      };\n    };\n\n    // Take any OperationResult and update the cache with it\n    const updateCacheWithResult = (\n      result: OperationResult,\n      pendingOperations: Operations\n    ): OperationResult => {\n      // Retrieve the original operation to get unfiltered variables\n      const operation =\n        operations.get(result.operation.key) || result.operation;\n      if (operation.kind === 'mutation') {\n        // Collect previous dependencies that have been written for optimistic updates\n        const dependencies = optimisticKeysToDependencies.get(operation.key);\n        collectPendingOperations(pendingOperations, dependencies);\n        optimisticKeysToDependencies.delete(operation.key);\n      }\n\n      if (operation.kind === 'subscription' || result.hasNext)\n        reserveLayer(store.data, operation.key, true);\n\n      let queryDependencies: undefined | Dependencies;\n      let data: Data | null = result.data;\n      if (data) {\n        // Write the result to cache and collect all dependencies that need to be\n        // updated\n        initDataState('write', store.data, operation.key, false, false);\n        const writeDependencies = _write(\n          store,\n          operation,\n          data,\n          result.error\n        ).dependencies;\n        clearDataState();\n        collectPendingOperations(pendingOperations, writeDependencies);\n        const prevData =\n          operation.kind === 'query' ? results.get(operation.key) : null;\n        initDataState(\n          'read',\n          store.data,\n          operation.key,\n          false,\n          prevData !== data\n        );\n        const queryResult = _query(\n          store,\n          operation,\n          prevData || data,\n          result.error\n        );\n        clearDataState();\n        data = queryResult.data;\n        if (operation.kind === 'query') {\n          // Collect the query's dependencies for future pending operation updates\n          queryDependencies = queryResult.dependencies;\n          collectPendingOperations(pendingOperations, queryDependencies);\n          results.set(operation.key, data);\n        }\n      } else {\n        noopDataState(store.data, operation.key);\n      }\n\n      // Update this operation's dependencies if it's a query\n      if (queryDependencies) {\n        updateDependencies(result.operation, queryDependencies);\n      }\n\n      return {\n        operation,\n        data,\n        error: result.error,\n        extensions: result.extensions,\n        hasNext: result.hasNext,\n        stale: result.stale,\n      };\n    };\n\n    return operations$ => {\n      // Filter by operations that are cacheable and attempt to query them from the cache\n      const cacheOps$ = pipe(\n        operations$,\n        filter(\n          op =>\n            op.kind === 'query' && op.context.requestPolicy !== 'network-only'\n        ),\n        map(operationResultFromCache),\n        share\n      );\n\n      const nonCacheOps$ = pipe(\n        operations$,\n        filter(\n          op =>\n            op.kind !== 'query' || op.context.requestPolicy === 'network-only'\n        )\n      );\n\n      // Rebound operations that are incomplete, i.e. couldn't be queried just from the cache\n      const cacheMissOps$ = pipe(\n        cacheOps$,\n        filter(\n          res =>\n            res.outcome === 'miss' &&\n            res.operation.context.requestPolicy !== 'cache-only' &&\n            !isBlockedByOptimisticUpdate(res.dependencies) &&\n            !reexecutingOperations.has(res.operation.key)\n        ),\n        map(res => {\n          dispatchDebug({\n            type: 'cacheMiss',\n            message: 'The result could not be retrieved from the cache',\n            operation: res.operation,\n          });\n          return addMetadata(res.operation, { cacheOutcome: 'miss' });\n        })\n      );\n\n      // Resolve OperationResults that the cache was able to assemble completely and trigger\n      // a network request if the current operation's policy is cache-and-network\n      const cacheResult$ = pipe(\n        cacheOps$,\n        filter(\n          res =>\n            res.outcome !== 'miss' ||\n            res.operation.context.requestPolicy === 'cache-only'\n        ),\n        map((res: OperationResultWithMeta): OperationResult => {\n          const { requestPolicy } = res.operation.context;\n\n          // We reexecute requests marked as `cache-and-network`, and partial responses,\n          // if we wouldn't cause a request loop\n          const shouldReexecute =\n            requestPolicy !== 'cache-only' &&\n            (res.hasNext ||\n              requestPolicy === 'cache-and-network' ||\n              (requestPolicy === 'cache-first' &&\n                res.outcome === 'partial' &&\n                !reexecutingOperations.has(res.operation.key)));\n          // Set stale to true anyway, even if the reexecute will be blocked, if the operation\n          // is in progress. We can be reasonably sure of that if a layer has been reserved for it.\n          const stale =\n            requestPolicy !== 'cache-only' &&\n            (shouldReexecute ||\n              (res.outcome === 'partial' &&\n                reexecutingOperations.has(res.operation.key) &&\n                hasLayer(store.data, res.operation.key)));\n\n          const result: OperationResult = {\n            operation: addMetadata(res.operation, {\n              cacheOutcome: res.outcome,\n            }),\n            data: res.data,\n            error: res.error,\n            extensions: res.extensions,\n            stale: stale && !res.hasNext,\n            hasNext: shouldReexecute && res.hasNext,\n          };\n\n          if (!shouldReexecute) {\n            /*noop*/\n          } else if (!isBlockedByOptimisticUpdate(res.dependencies)) {\n            client.reexecuteOperation(\n              toRequestPolicy(\n                operations.get(res.operation.key) || res.operation,\n                'network-only'\n              )\n            );\n          } else if (requestPolicy === 'cache-and-network') {\n            requestedRefetch.add(res.operation.key);\n          }\n\n          dispatchDebug({\n            type: 'cacheHit',\n            message: `A requested operation was found and returned from the cache.`,\n            operation: res.operation,\n            data: {\n              value: result,\n            },\n          });\n\n          return result;\n        })\n      );\n\n      // Forward operations that aren't cacheable and rebound operations\n      // Also update the cache with any network results\n      const result$ = pipe(\n        merge([nonCacheOps$, cacheMissOps$]),\n        map(prepareForwardedOperation),\n        forward\n      );\n\n      // Results that can immediately be resolved\n      const nonOptimisticResults$ = pipe(\n        result$,\n        filter(\n          result => !optimisticKeysToDependencies.has(result.operation.key)\n        ),\n        map(result => {\n          const pendingOperations: Operations = new Set();\n          // Update the cache with the incoming API result\n          const cacheResult = updateCacheWithResult(result, pendingOperations);\n          // Execute all dependent queries\n          executePendingOperations(result.operation, pendingOperations, false);\n          return cacheResult;\n        })\n      );\n\n      // Prevent mutations that were previously optimistic from being flushed\n      // immediately and instead clear them out slowly\n      const optimisticMutationCompletion$ = pipe(\n        result$,\n        filter(result =>\n          optimisticKeysToDependencies.has(result.operation.key)\n        ),\n        mergeMap((result: OperationResult): Source<OperationResult> => {\n          const length = mutationResultBuffer.push(result);\n          if (length < optimisticKeysToDependencies.size) {\n            return empty;\n          }\n\n          for (let i = 0; i < mutationResultBuffer.length; i++) {\n            reserveLayer(store.data, mutationResultBuffer[i].operation.key);\n          }\n\n          blockedDependencies.clear();\n\n          const results: OperationResult[] = [];\n          const pendingOperations: Operations = new Set();\n\n          let bufferedResult: OperationResult | void;\n          while ((bufferedResult = mutationResultBuffer.shift()))\n            results.push(\n              updateCacheWithResult(bufferedResult, pendingOperations)\n            );\n\n          // Execute all dependent queries as a single batch\n          executePendingOperations(result.operation, pendingOperations, false);\n\n          return fromArray(results);\n        })\n      );\n\n      return merge([\n        nonOptimisticResults$,\n        optimisticMutationCompletion$,\n        cacheResult$,\n      ]);\n    };\n  };\n","import { pipe, share, merge, makeSubject, filter, onPush } from 'wonka';\n\nimport type {\n  Operation,\n  OperationResult,\n  Exchange,\n  ExchangeIO,\n  CombinedError,\n  RequestPolicy,\n} from '@urql/core';\nimport { stringifyDocument, createRequest, makeOperation } from '@urql/core';\n\nimport type {\n  SerializedRequest,\n  CacheExchangeOpts,\n  StorageAdapter,\n} from './types';\nimport { cacheExchange } from './cacheExchange';\nimport { toRequestPolicy } from './helpers/operation';\n\nconst policyLevel = {\n  'cache-only': 0,\n  'cache-first': 1,\n  'network-only': 2,\n  'cache-and-network': 3,\n} as const;\n\n/** Input parameters for the {@link offlineExchange}.\n * @remarks\n * This configuration object extends the {@link CacheExchangeOpts}\n * as the `offlineExchange` extends the regular {@link cacheExchange}.\n */\nexport interface OfflineExchangeOpts extends CacheExchangeOpts {\n  /** Configures an offline storage adapter for Graphcache.\n   *\n   * @remarks\n   * A {@link StorageAdapter} allows Graphcache to write data to an external,\n   * asynchronous storage, and hydrate data from it when it first loads.\n   * This allows you to preserve normalized data between restarts/reloads.\n   *\n   * @see {@link https://urql.dev/goto/docs/graphcache/offline} for the full Offline Support docs.\n   */\n  storage: StorageAdapter;\n  /** Predicate function to determine whether a {@link CombinedError} hints at a network error.\n   *\n   * @remarks\n   * Not ever {@link CombinedError} means that the device is offline and by default\n   * the `offlineExchange` will check for common network error messages and check\n   * `navigator.onLine`. However, when `isOfflineError` is passed it can replace\n   * the default offline detection.\n   */\n  isOfflineError?(\n    error: undefined | CombinedError,\n    result: OperationResult\n  ): boolean;\n}\n\n/** Exchange factory that creates a normalized cache exchange in Offline Support mode.\n *\n * @param opts - A {@link OfflineExchangeOpts} configuration object.\n * @returns the created normalized, offline cache {@link Exchange}.\n *\n * @remarks\n * The `offlineExchange` is a wrapper around the regular {@link cacheExchange}\n * which adds logic via the {@link OfflineExchangeOpts.storage} adapter to\n * recognize when it’s offline, when to retry failed mutations, and how\n * to handle longer periods of being offline.\n *\n * @see {@link https://urql.dev/goto/docs/graphcache/offline} for the full Offline Support docs.\n */\nexport const offlineExchange =\n  <C extends OfflineExchangeOpts>(opts: C): Exchange =>\n  input => {\n    const { storage } = opts;\n\n    const isOfflineError =\n      opts.isOfflineError ||\n      ((error: undefined | CombinedError) =>\n        error &&\n        error.networkError &&\n        !error.response &&\n        ((typeof navigator !== 'undefined' && navigator.onLine === false) ||\n          /request failed|failed to fetch|network\\s?error/i.test(\n            error.networkError.message\n          )));\n\n    if (\n      storage &&\n      storage.onOnline &&\n      storage.readMetadata &&\n      storage.writeMetadata\n    ) {\n      const { forward: outerForward, client, dispatchDebug } = input;\n      const { source: reboundOps$, next } = makeSubject<Operation>();\n      const failedQueue: Operation[] = [];\n      let hasRehydrated = false;\n      let isFlushingQueue = false;\n\n      const updateMetadata = () => {\n        if (hasRehydrated) {\n          const requests: SerializedRequest[] = [];\n          for (let i = 0; i < failedQueue.length; i++) {\n            const operation = failedQueue[i];\n            if (operation.kind === 'mutation') {\n              requests.push({\n                query: stringifyDocument(operation.query),\n                variables: operation.variables,\n                extensions: operation.extensions,\n              });\n            }\n          }\n          storage.writeMetadata!(requests);\n        }\n      };\n\n      const filterQueue = (key: number) => {\n        for (let i = failedQueue.length - 1; i >= 0; i--)\n          if (failedQueue[i].key === key) failedQueue.splice(i, 1);\n      };\n\n      const flushQueue = () => {\n        if (!isFlushingQueue) {\n          const sent = new Set<number>();\n          isFlushingQueue = true;\n          for (let i = 0; i < failedQueue.length; i++) {\n            const operation = failedQueue[i];\n            if (operation.kind === 'mutation' || !sent.has(operation.key)) {\n              sent.add(operation.key);\n              if (operation.kind !== 'subscription') {\n                next(makeOperation('teardown', operation));\n                let overridePolicy: RequestPolicy = 'cache-first';\n                for (let i = 0; i < failedQueue.length; i++) {\n                  const { requestPolicy } = failedQueue[i].context;\n                  if (policyLevel[requestPolicy] > policyLevel[overridePolicy])\n                    overridePolicy = requestPolicy;\n                }\n                next(toRequestPolicy(operation, overridePolicy));\n              } else {\n                next(toRequestPolicy(operation, 'cache-first'));\n              }\n            }\n          }\n          isFlushingQueue = false;\n          failedQueue.length = 0;\n          updateMetadata();\n        }\n      };\n\n      const forward: ExchangeIO = ops$ => {\n        return pipe(\n          outerForward(ops$),\n          filter(res => {\n            if (\n              hasRehydrated &&\n              res.operation.kind === 'mutation' &&\n              res.operation.context.optimistic &&\n              isOfflineError(res.error, res)\n            ) {\n              failedQueue.push(res.operation);\n              updateMetadata();\n              return false;\n            }\n\n            return true;\n          }),\n          share\n        );\n      };\n\n      const cacheResults$ = cacheExchange({\n        ...opts,\n        storage: {\n          ...storage,\n          readData() {\n            const hydrate = storage.readData();\n            return {\n              async then(onEntries) {\n                const mutations = await storage.readMetadata!();\n                for (let i = 0; mutations && i < mutations.length; i++) {\n                  failedQueue.push(\n                    client.createRequestOperation(\n                      'mutation',\n                      createRequest(mutations[i].query, mutations[i].variables),\n                      mutations[i].extensions\n                    )\n                  );\n                }\n                onEntries!(await hydrate);\n                storage.onOnline!(flushQueue);\n                hasRehydrated = true;\n                flushQueue();\n              },\n            };\n          },\n        },\n      })({\n        client,\n        dispatchDebug,\n        forward,\n      });\n\n      return operations$ => {\n        const opsAndRebound$ = merge([\n          reboundOps$,\n          pipe(\n            operations$,\n            onPush(operation => {\n              if (operation.kind === 'query' && !hasRehydrated) {\n                failedQueue.push(operation);\n              } else if (operation.kind === 'teardown') {\n                filterQueue(operation.key);\n              }\n            })\n          ),\n        ]);\n\n        return pipe(\n          cacheResults$(opsAndRebound$),\n          filter(res => {\n            if (res.operation.kind === 'query') {\n              if (isOfflineError(res.error, res)) {\n                next(toRequestPolicy(res.operation, 'cache-only'));\n                failedQueue.push(res.operation);\n                return false;\n              } else if (!hasRehydrated) {\n                filterQueue(res.operation.key);\n              }\n            }\n            return true;\n          })\n        );\n      };\n    }\n\n    return cacheExchange(opts)(input);\n  };\n"],"names":["helpUrl","cache","Set","currentDebugStack","popDebugNode","pop","pushDebugNode","typename","node","identifier","kind","Kind","INLINE_FRAGMENT","OPERATION_DEFINITION","name","value","operation","FRAGMENT_DEFINITION","push","getDebugOutput","length","join","invariant","condition","message","code","errorMessage","process","env","NODE_ENV","error","Error","warn","logger","has","console","add","EMPTY_DIRECTIVES","getDirectives","_directives","getName","getFragmentTypeName","typeCondition","getFieldAlias","alias","emptySelectionSet","getSelectionSet","selectionSet","selections","getTypeCondition","getFieldArguments","vars","args","arguments","i","l","arg","valueFromASTUntyped","filterVariables","input","variableDefinitions","variable","normalizeVariables","def","undefined","defaultValue","key","getMainOperation","doc","definitions","getFragments","fragments","shouldInclude","directives","include","skip","directive","isDeferred","defer","argument","isOptional","optional","required","BUILTIN_NAME","isFieldNullable","schema","fieldName","field","getField","type","isListNullable","ofType","isFieldAvailableOnType","indexOf","isInterfaceOfType","types","get","expectAbstractType","expectObjectType","isSubType","fields","warnAboutResolver","warnAboutAbstractResolver","keyOfField","stringifyVariables","joinKeys","parentKey","fieldInfoOfKey","fieldKey","parenIndex","slice","JSON","parse","deserializeKeyInfo","dotIndex","entityKey","replace","currentOwnership","currentDataMapping","currentData","currentOptimisticKey","currentOperation","currentDependencies","currentForeignData","currentOptimistic","makeData","data","isArray","newData","set","ownsData","initDataState","operationType","layerKey","isOptimistic","isForeignData","WeakSet","WeakMap","hydrating","optimisticOrder","commutativeKeys","reserveLayer","splice","delete","createLayer","deleteLayer","clearDataState","getCurrentDependencies","dirtyKeys","squashLayer","storage","setTimeout","gc","persistData","noopDataState","deferredKeys","DEFAULT_EMPTY_SET","setNode","map","keymap","optimistic","base","entity","Object","create","getNode","updateRCForLink","link","by","Array","updateRCForEntity","count","refCount","newCount","extractNodeFields","fieldInfos","seenFieldKeys","extractNodeMapFields","keys","record","records","__typename","linkNode","links","updateDependencies","queryRootKey","updatePersist","persist","serializeKeys","readRecord","readLink","writeRecord","hasField","writeLink","entityLinks","hasNext","index","clearLayer","unshift","Map","previousDependencies","entry","entries","keyMap","inspectFields","x","writeData","clear","contextRef","deferRef","optionalRef","getFieldError","ctx","__internal","path","errorMap","makeContext","store","variables","parent","parentTypeName","parentFieldKey","partial","graphQLErrors","graphQLError","updateContext","isFragmentHeuristicallyMatching","some","FIELD","makeSelectionIterator","_defer","_optional","child","next","select","fragment","isFragmentOptional","_generated","ensureData","ensureLink","ref","keyOfEntity","_query","request","query","formatDocument","rootKey","rootFields","rootSelect","readRoot","InMemoryData","readSelection","dependencies","rootNames","iterate","hasChanged","output","fieldAlias","fieldValue","dataFieldValue","readRootField","originalData","getFieldResolver","resolvers","fieldResolver","directiveResolver","directiveNode","result","isQuery","mutation","subscription","hasFields","hasPartials","fieldArgs","resolver","resultValue","resolveResolverResult","resolveLink","stringify","prevData","isOwnedData","_isListNullable","childResult","isDataOrKey","newLink","childLink","_write","writeSelection","rootField","isRoot","writeType","existingTypes","typeSet","updates","optimisticMutations","writeField","updater","KEYLESS_TYPE_RE","prevLink","indexKey","test","childKey","invalidateEntity","invalidateType","Store","constructor","opts","this","globalIDs","queryName","mutationName","subscriptionName","buildClientSchema","__schema","typemap","buildNameMap","arr","buildType","interfaces","possibleTypes","queryType","mutationType","subscriptionType","abstract","possible","abstractType","possibleType","out","expectValidKeyingConfig","expectValidUpdatesConfig","addition","expectValidResolversConfig","validQueries","resolverQuery","Query","validTypeProperties","resolverProperty","expectValidOptimisticMutationsConfig","validMutations","id","_id","resolve","fieldLink","resolveFieldByKey","invalidate","updateQuery","createRequest","readQuery","readFragment","fragmentName","_queryFragment","writeFragment","_writeFragment","dataToWrite","rest","addMetadata","meta","makeOperation","context","toRequestPolicy","requestPolicy","cacheExchange","forward","client","dispatchDebug","readData","then","hydrateData","onCacheHydrated","optimisticKeysToDependencies","mutationResultBuffer","operations","results","blockedDependencies","requestedRefetch","deps","reexecutingOperations","dependentOperations","isBlockedByOptimisticUpdate","dep","values","collectPendingOperations","pendingOperations","executePendingOperations","op","policy","reexecuteOperation","_reexecutingOperations","prepareForwardedOperation","size","depOps","operationResultFromCache","cacheOutcome","outcome","updateCacheWithResult","queryDependencies","writeDependencies","queryResult","extensions","stale","operations$","cacheOps$","share","filter","nonCacheOps$","cacheMissOps$","res","source","cacheResult$","shouldReexecute","hasLayer","result$","merge","nonOptimisticResults$","cacheResult","optimisticMutationCompletion$","mergeMap","empty","bufferedResult","shift","fromArray","policyLevel","offlineExchange","isOfflineError","networkError","response","navigator","onLine","onOnline","readMetadata","writeMetadata","outerForward","reboundOps$","makeSubject","failedQueue","hasRehydrated","isFlushingQueue","updateMetadata","requests","stringifyDocument","filterQueue","flushQueue","sent","overridePolicy","cacheResults$","hydrate","async","onEntries","mutations","createRequestOperation","ops$","opsAndRebound$","onPush"],"mappings":"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"}