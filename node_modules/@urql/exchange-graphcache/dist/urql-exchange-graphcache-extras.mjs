import { stringifyVariables as e } from "@urql/core";

var r = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: !1,
  hasPreviousPage: !1
};

var ensureKey = e => "string" == typeof e ? e : null;

var concatEdges = (e, r, a) => {
  var n = new Set;
  for (var t = 0, s = r.length; t < s; t++) {
    var o = e.resolve(r[t], "node");
    if ("string" == typeof o) {
      n.add(o);
    }
  }
  var f = r.slice();
  for (var i = 0, v = a.length; i < v; i++) {
    var l = a[i];
    var u = e.resolve(l, "node");
    if ("string" == typeof u && !n.has(u)) {
      n.add(u);
      f.push(l);
    }
  }
  return f;
};

var concatNodes = (e, r) => {
  var a = new Set;
  for (var n = 0, t = e.length; n < t; n++) {
    var s = e[n];
    if ("string" == typeof s) {
      a.add(s);
    }
  }
  var o = e.slice();
  for (var f = 0, i = r.length; f < i; f++) {
    var v = r[f];
    if ("string" == typeof v && !a.has(v)) {
      a.add(v);
      o.push(v);
    }
  }
  return o;
};

var compareArgs = (r, a) => {
  for (var n in a) {
    if ("first" === n || "last" === n || "after" === n || "before" === n) {
      continue;
    } else if (!(n in r)) {
      return !1;
    }
    var t = r[n];
    var s = a[n];
    if (typeof t != typeof s || "object" != typeof t ? t !== s : e(t) !== e(s)) {
      return !1;
    }
  }
  for (var o in r) {
    if ("first" === o || "last" === o || "after" === o || "before" === o) {
      continue;
    }
    if (!(o in a)) {
      return !1;
    }
  }
  return !0;
};

var getPage = (e, a, n) => {
  var t = ensureKey(e.resolve(a, n));
  if (!t) {
    return null;
  }
  var s = e.resolve(t, "__typename");
  var o = e.resolve(t, "edges") || [];
  var f = e.resolve(t, "nodes") || [];
  if ("string" != typeof s) {
    return null;
  }
  var i = {
    __typename: s,
    edges: o,
    nodes: f,
    pageInfo: r
  };
  var v = e.resolve(t, "pageInfo");
  if ("string" == typeof v) {
    var l = ensureKey(e.resolve(v, "__typename"));
    var u = ensureKey(e.resolve(v, "endCursor"));
    var g = ensureKey(e.resolve(v, "startCursor"));
    var p = e.resolve(v, "hasNextPage");
    var d = e.resolve(v, "hasPreviousPage");
    var y = i.pageInfo = {
      __typename: "string" == typeof l ? l : "PageInfo",
      hasNextPage: "boolean" == typeof p ? p : !!u,
      hasPreviousPage: "boolean" == typeof d ? d : !!g,
      endCursor: u,
      startCursor: g
    };
    if (null === y.endCursor) {
      var m = o[o.length - 1];
      if (m) {
        var h = e.resolve(m, "cursor");
        y.endCursor = ensureKey(h);
      }
    }
    if (null === y.startCursor) {
      var _ = o[0];
      if (_) {
        var c = e.resolve(_, "cursor");
        y.startCursor = ensureKey(c);
      }
    }
  }
  return i;
};

var relayPagination = (e = {}) => {
  var a = e.mergeMode || "inwards";
  return (e, n, t, s) => {
    var {parentKey: o, fieldName: f} = s;
    var i = t.inspectFields(o).filter((e => e.fieldName === f));
    var v = i.length;
    if (0 === v) {
      return;
    }
    var l = null;
    var u = [];
    var g = [];
    var p = [];
    var d = [];
    var y = {
      ...r
    };
    for (var m = 0; m < v; m++) {
      var {fieldKey: h, arguments: _} = i[m];
      if (null === _ || !compareArgs(n, _)) {
        continue;
      }
      var c = getPage(t, o, h);
      if (null === c) {
        continue;
      }
      if (0 === c.nodes.length && 0 === c.edges.length && l) {
        continue;
      }
      if ("inwards" === a && "number" == typeof _.last && "number" == typeof _.first) {
        var P = c.edges.slice(0, _.first + 1);
        var C = c.edges.slice(-_.last);
        var I = c.nodes.slice(0, _.first + 1);
        var b = c.nodes.slice(-_.last);
        u = concatEdges(t, u, P);
        g = concatEdges(t, C, g);
        p = concatNodes(p, I);
        d = concatNodes(b, d);
        y = c.pageInfo;
      } else if (_.after) {
        u = concatEdges(t, u, c.edges);
        p = concatNodes(p, c.nodes);
        y.endCursor = c.pageInfo.endCursor;
        y.hasNextPage = c.pageInfo.hasNextPage;
      } else if (_.before) {
        g = concatEdges(t, c.edges, g);
        d = concatNodes(c.nodes, d);
        y.startCursor = c.pageInfo.startCursor;
        y.hasPreviousPage = c.pageInfo.hasPreviousPage;
      } else if ("number" == typeof _.last) {
        g = concatEdges(t, c.edges, g);
        d = concatNodes(c.nodes, d);
        y = c.pageInfo;
      } else {
        u = concatEdges(t, u, c.edges);
        p = concatNodes(p, c.nodes);
        y = c.pageInfo;
      }
      if (c.pageInfo.__typename !== y.__typename) {
        y.__typename = c.pageInfo.__typename;
      }
      if (l !== c.__typename) {
        l = c.__typename;
      }
    }
    if ("string" != typeof l) {
      return;
    }
    if (!!!ensureKey(t.resolve(o, f, n))) {
      if (!s.store.schema) {
        return;
      } else {
        s.partial = !0;
      }
    }
    return {
      __typename: l,
      edges: "inwards" === a ? concatEdges(t, u, g) : concatEdges(t, g, u),
      nodes: "inwards" === a ? concatNodes(p, d) : concatNodes(d, p),
      pageInfo: {
        __typename: y.__typename,
        endCursor: y.endCursor,
        startCursor: y.startCursor,
        hasNextPage: y.hasNextPage,
        hasPreviousPage: y.hasPreviousPage
      }
    };
  };
};

var simplePagination = ({offsetArgument: r = "skip", limitArgument: a = "limit", mergeMode: n = "after"} = {}) => {
  var compareArgs = (n, t) => {
    for (var s in t) {
      if (s === r || s === a) {
        continue;
      } else if (!(s in n)) {
        return !1;
      }
      var o = n[s];
      var f = t[s];
      if (typeof o != typeof f || "object" != typeof o ? o !== f : e(o) !== e(f)) {
        return !1;
      }
    }
    for (var i in n) {
      if (i === r || i === a) {
        continue;
      }
      if (!(i in t)) {
        return !1;
      }
    }
    return !0;
  };
  return (e, a, t, s) => {
    var {parentKey: o, fieldName: f} = s;
    var i = t.inspectFields(o).filter((e => e.fieldName === f));
    var v = i.length;
    if (0 === v) {
      return;
    }
    var l = new Set;
    var u = [];
    var g = null;
    for (var p = 0; p < v; p++) {
      var {fieldKey: d, arguments: y} = i[p];
      if (null === y || !compareArgs(a, y)) {
        continue;
      }
      var m = t.resolve(o, d);
      var h = y[r];
      if (null === m || 0 === m.length || "number" != typeof h) {
        continue;
      }
      var _ = [];
      for (var c = 0; c < m.length; c++) {
        var P = m[c];
        if (l.has(P)) {
          continue;
        }
        _.push(P);
        l.add(P);
      }
      if ((!g || h > g) == ("after" === n)) {
        u = [ ...u, ..._ ];
      } else {
        u = [ ..._, ...u ];
      }
      g = h;
    }
    if (t.resolve(o, f, a)) {
      return u;
    } else if (!s.store.schema) {
      return;
    } else {
      s.partial = !0;
      return u;
    }
  };
};

export { relayPagination, simplePagination };
//# sourceMappingURL=urql-exchange-graphcache-extras.mjs.map
