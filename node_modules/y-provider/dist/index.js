import { applyUpdate as m, encodeStateAsUpdate as q, encodeStateVector as z } from "yjs";
async function I(t, n) {
  const r = async (a) => {
    const o = await n.queryDocState(a.guid);
    o && m(a, o.missing, "sync-doc-from-datasource"), await Promise.all(
      [...a.subdocs].map(async (f) => {
        await r(f);
      })
    );
  };
  await r(t);
}
async function O(t, n) {
  const r = async (a) => {
    await n.sendDocUpdate(a.guid, q(a)), await Promise.all(
      [...a.subdocs].map(async (o) => {
        await r(o);
      })
    );
  };
  await r(t);
}
async function W(t, n, r) {
  const a = t();
  await Promise.all(
    a.map((o) => r.queryDocState(o).then(async (f) => {
      const g = await (async () => f ? n.queryDocState(o, {
        stateVector: f.state
      }) : n.queryDocState(o))();
      if (g) {
        const y = g.missing;
        if (y.length === 2 && y[0] === 0 && y[1] === 0)
          return;
        await r.sendDocUpdate(o, g.missing);
      }
    }))
  );
}
function A(t, n = "val does not exist") {
  if (t == null)
    throw n instanceof Error ? n : new Error(n);
}
function x(t, n) {
  if (t.guid === n)
    return t;
  for (const r of t.subdocs) {
    const a = x(r, n);
    if (a)
      return a;
  }
}
const j = (t, n, r = {}) => {
  let a = !1;
  const o = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set();
  let y = null;
  const { origin: h = "lazy-provider" } = r;
  let b = {
    type: "idle"
  }, D = 0;
  const v = /* @__PURE__ */ new Set(), l = (e) => {
    e.type === "syncing" ? D++ : (e.type === "synced" || e.type === "error") && D--, D < 0 && console.error(
      "syncingStatus < 0, this should not happen",
      r.origin
    ), D === 0 && (b = e), e.type !== "synced" && (b = e), D === 0 && (a ? b = {
      type: "synced"
    } : b = {
      type: "idle"
    }), v.forEach((s) => s());
  };
  async function S(e) {
    const s = e.guid;
    {
      const c = s.startsWith("space:") ? s.slice(6) : s, d = `${t.guid}:space:${c}`, p = `space:${c}`, u = await n.queryDocState(d), w = await n.queryDocState(p);
      let U = !1;
      u && u.missing.length !== 2 && u.missing[0] !== 0 && u.missing[1] !== 0 && (m(e, u.missing, h), U = !0), w && w.missing.length !== 2 && w.missing[0] !== 0 && w.missing[1] !== 0 && (m(e, w.missing, h), U = !0), U && await n.sendDocUpdate(
        s,
        q(
          e,
          u ? u.state : w ? w.state : void 0
        )
      );
    }
    if (!a)
      return;
    l({
      type: "syncing"
    });
    const i = await n.queryDocState(s, {
      stateVector: z(e)
    }).then((c) => (l({
      type: "synced"
    }), c)).catch((c) => {
      throw l({
        type: "error",
        error: c
      }), c;
    });
    o.set(s, []), i && m(e, i.missing, h), a && (await n.sendDocUpdate(
      s,
      q(e, i ? i.state : void 0)
    ), e.emit("sync", []));
  }
  function M(e) {
    const s = /* @__PURE__ */ new Set();
    f.set(e.guid, s);
    const i = async (d, p) => {
      h !== p && (l({
        type: "syncing"
      }), n.sendDocUpdate(e.guid, d).then(() => {
        l({
          type: "synced"
        });
      }).catch((u) => {
        l({
          type: "error",
          error: u
        }), console.error(u);
      }));
    }, c = (d) => {
      d.loaded.forEach((p) => {
        E(p).catch(console.error);
      }), d.removed.forEach((p) => {
        L(p);
      });
    };
    e.on("update", i), e.on("subdocs", c), s.add(() => {
      e.off("update", i), e.off("subdocs", c);
    });
  }
  function V() {
    var s;
    A(y, "abortController should be defined");
    const e = (s = n.onDocUpdate) == null ? void 0 : s.call(n, (i, c) => {
      var p;
      l({
        type: "syncing"
      });
      const d = x(t, i);
      d ? (m(d, c, h), o.has(i) && ((p = o.get(i)) == null || p.forEach((u) => m(d, u, h)), o.delete(i))) : (console.warn("doc not found", i), o.set(i, (o.get(i) ?? []).concat(c))), l({
        type: "synced"
      });
    });
    y.signal.addEventListener("abort", () => {
      e == null || e();
    });
  }
  async function E(e) {
    g.has(e.guid) || (g.add(e.guid), M(e), await S(e), await Promise.all(
      [...e.subdocs].filter((s) => s.shouldLoad).map((s) => E(s))
    ));
  }
  function L(e) {
    g.delete(e.guid);
    const s = f.get(e.guid);
    s && (s.forEach((i) => i()), f.delete(e.guid)), e.subdocs.forEach(L);
  }
  function $() {
    f.forEach((e) => {
      e.forEach((s) => s());
    }), f.clear(), g.clear();
  }
  function R() {
    a = !0, y = new AbortController(), l({
      type: "syncing"
    }), E(t).then(() => {
      l({
        type: "synced"
      });
    }).catch((e) => {
      l({
        type: "error",
        error: e
      }), console.error(e);
    }), V();
  }
  async function k() {
    a = !1, $(), A(y, "abortController should be defined"), y.abort(), y = null;
  }
  const P = async (e) => {
    await S(e), await Promise.all(
      [...e.subdocs.values()].map((s) => P(s))
    );
  };
  return {
    sync: async (e) => {
      a = !0;
      try {
        e ? await S(t) : await P(t);
      } finally {
        a = !1;
      }
    },
    get status() {
      return b;
    },
    subscribeStatusChange(e) {
      return v.add(e), () => {
        v.delete(e);
      };
    },
    get connected() {
      return a;
    },
    passive: !0,
    connect: R,
    disconnect: k,
    datasource: n
  };
};
function F(t, n) {
  if (t.guid === n)
    return t;
  for (const r of t.subdocs) {
    const a = F(r, n);
    if (a)
      return a;
  }
}
const C = (t) => (t.preventDefault(), t.returnValue = "Data is not saved. Are you sure you want to leave?"), B = async (t) => {
  window.addEventListener("beforeunload", C, {
    capture: !0
  }), await t, window.removeEventListener("beforeunload", C, {
    capture: !0
  });
};
export {
  j as createLazyProvider,
  F as getDoc,
  W as syncDataSource,
  O as syncDataSourceFromDoc,
  I as syncDocFromDataSource,
  B as writeOperation
};
//# sourceMappingURL=index.js.map
