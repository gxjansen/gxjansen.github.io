{"version":3,"file":"index.umd.cjs","sources":["../src/data-source.ts","../../../../node_modules/@blocksuite/global/dist/utils/assert.js","../src/lazy-provider.ts","../src/utils.ts"],"sourcesContent":["import type { Doc as YDoc } from 'yjs';\nimport { applyUpdate, encodeStateAsUpdate } from 'yjs';\n\nimport type { DocState } from './types';\n\nexport interface DocDataSource {\n  /**\n   * request diff update from other clients\n   */\n  queryDocState: (\n    guid: string,\n    options?: {\n      stateVector?: Uint8Array;\n      targetClientId?: number;\n    }\n  ) => Promise<DocState | false>;\n\n  /**\n   * send update to the datasource\n   */\n  sendDocUpdate: (guid: string, update: Uint8Array) => Promise<void>;\n\n  /**\n   * listen to update from the datasource. Returns a function to unsubscribe.\n   * this is optional because some datasource might not support it\n   */\n  onDocUpdate?(\n    callback: (guid: string, update: Uint8Array) => void\n  ): () => void;\n}\n\nexport async function syncDocFromDataSource(\n  rootDoc: YDoc,\n  datasource: DocDataSource\n) {\n  const downloadDocStateRecursively = async (doc: YDoc) => {\n    const docState = await datasource.queryDocState(doc.guid);\n    if (docState) {\n      applyUpdate(doc, docState.missing, 'sync-doc-from-datasource');\n    }\n    await Promise.all(\n      [...doc.subdocs].map(async subdoc => {\n        await downloadDocStateRecursively(subdoc);\n      })\n    );\n  };\n  await downloadDocStateRecursively(rootDoc);\n}\n\nexport async function syncDataSourceFromDoc(\n  rootDoc: YDoc,\n  datasource: DocDataSource\n) {\n  const uploadDocStateRecursively = async (doc: YDoc) => {\n    await datasource.sendDocUpdate(doc.guid, encodeStateAsUpdate(doc));\n    await Promise.all(\n      [...doc.subdocs].map(async subdoc => {\n        await uploadDocStateRecursively(subdoc);\n      })\n    );\n  };\n\n  await uploadDocStateRecursively(rootDoc);\n}\n\n/**\n * query the datasource from source, and save the latest update to target\n *\n * @example\n *  bindDataSource(socketIO, indexedDB)\n *  bindDataSource(socketIO, sqlite)\n */\nexport async function syncDataSource(\n  listDocGuids: () => string[],\n  remoteDataSource: DocDataSource,\n  localDataSource: DocDataSource\n) {\n  const guids = listDocGuids();\n  await Promise.all(\n    guids.map(guid => {\n      return localDataSource.queryDocState(guid).then(async docState => {\n        const remoteDocState = await (async () => {\n          if (docState) {\n            return remoteDataSource.queryDocState(guid, {\n              stateVector: docState.state,\n            });\n          } else {\n            return remoteDataSource.queryDocState(guid);\n          }\n        })();\n        if (remoteDocState) {\n          const missing = remoteDocState.missing;\n          if (missing.length === 2 && missing[0] === 0 && missing[1] === 0) {\n            // empty update\n            return;\n          }\n          await localDataSource.sendDocUpdate(guid, remoteDocState.missing);\n        }\n      });\n    })\n  );\n}\n","// https://stackoverflow.com/questions/31538010/test-if-a-variable-is-a-primitive-rather-than-an-object\nexport function isPrimitive(a) {\n    return a !== Object(a);\n}\nexport function assertExists(val, message = 'val does not exist') {\n    if (val === null || val === undefined) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw new Error(message);\n    }\n}\nexport function assertNotExists(val, message = 'val exists') {\n    if (val !== null && val !== undefined) {\n        throw new Error(message);\n    }\n}\nexport function isEqual(val, expected) {\n    const a = isPrimitive(val);\n    const b = isPrimitive(expected);\n    if (a && b) {\n        if (!Object.is(val, expected)) {\n            return false;\n        }\n    }\n    else if (a !== b) {\n        return false;\n    }\n    else {\n        if (Array.isArray(val) && Array.isArray(expected)) {\n            if (val.length !== expected.length) {\n                return false;\n            }\n            return val.every((x, i) => isEqual(x, expected[i]));\n        }\n        else if (typeof val === 'object' && typeof expected === 'object') {\n            const obj1 = Object.entries(val);\n            const obj2 = Object.entries(expected);\n            if (obj1.length !== obj2.length) {\n                return false;\n            }\n            return obj1.every((x, i) => isEqual(x, obj2[i]));\n        }\n    }\n    return true;\n}\nexport function assertEquals(val, expected, message = 'val is not same as expected') {\n    if (!isEqual(val, expected)) {\n        throw new Error(message);\n    }\n}\nexport function assertInstanceOf(val, expected, message = 'val is not instance of expected') {\n    if (!(val instanceof expected)) {\n        throw new Error(message);\n    }\n}\n//# sourceMappingURL=assert.js.map","import { assertExists } from '@blocksuite/global/utils';\nimport {\n  applyUpdate,\n  type Doc,\n  encodeStateAsUpdate,\n  encodeStateVector,\n} from 'yjs';\n\nimport type { DocDataSource } from './data-source';\nimport type { DataSourceAdapter } from './types';\nimport type { Status } from './types';\n\nfunction getDoc(doc: Doc, guid: string): Doc | undefined {\n  if (doc.guid === guid) {\n    return doc;\n  }\n  for (const subdoc of doc.subdocs) {\n    const found = getDoc(subdoc, guid);\n    if (found) {\n      return found;\n    }\n  }\n  return undefined;\n}\n\ninterface LazyProviderOptions {\n  origin?: string;\n}\n\nexport type DocProvider = {\n  // backport from `@blocksuite/store`\n  passive: true;\n\n  sync(onlyRootDoc?: boolean): Promise<void>;\n\n  get connected(): boolean;\n  connect(): void;\n  disconnect(): void;\n};\n\n/**\n * Creates a lazy provider that connects to a datasource and synchronizes a root document.\n */\nexport const createLazyProvider = (\n  rootDoc: Doc,\n  datasource: DocDataSource,\n  options: LazyProviderOptions = {}\n): DocProvider & DataSourceAdapter => {\n  let connected = false;\n  const pendingMap = new Map<string, Uint8Array[]>(); // guid -> pending-updates\n  const disposableMap = new Map<string, Set<() => void>>();\n  const connectedDocs = new Set<string>();\n  let abortController: AbortController | null = null;\n\n  const { origin = 'lazy-provider' } = options;\n\n  // todo: should we use a real state machine here like `xstate`?\n  let currentStatus: Status = {\n    type: 'idle',\n  };\n  let syncingStack = 0;\n  const callbackSet = new Set<() => void>();\n  const changeStatus = (newStatus: Status) => {\n    // simulate a stack, each syncing and synced should be paired\n    if (newStatus.type === 'syncing') {\n      syncingStack++;\n    } else if (newStatus.type === 'synced' || newStatus.type === 'error') {\n      syncingStack--;\n    }\n\n    if (syncingStack < 0) {\n      console.error(\n        'syncingStatus < 0, this should not happen',\n        options.origin\n      );\n    }\n\n    if (syncingStack === 0) {\n      currentStatus = newStatus;\n    }\n    if (newStatus.type !== 'synced') {\n      currentStatus = newStatus;\n    }\n    if (syncingStack === 0) {\n      if (!connected) {\n        currentStatus = {\n          type: 'idle',\n        };\n      } else {\n        currentStatus = {\n          type: 'synced',\n        };\n      }\n    }\n    callbackSet.forEach(cb => cb());\n  };\n\n  async function syncDoc(doc: Doc) {\n    const guid = doc.guid;\n    {\n      // backport from `@blocksuite/store`\n      const prefixId = guid.startsWith('space:') ? guid.slice(6) : guid;\n      const possible1 = `${rootDoc.guid}:space:${prefixId}`;\n      const possible2 = `space:${prefixId}`;\n      const update1 = await datasource.queryDocState(possible1);\n      const update2 = await datasource.queryDocState(possible2);\n      let hasUpdate = false;\n      if (\n        update1 &&\n        update1.missing.length !== 2 &&\n        update1.missing[0] !== 0 &&\n        update1.missing[1] !== 0\n      ) {\n        applyUpdate(doc, update1.missing, origin);\n        hasUpdate = true;\n      }\n      if (\n        update2 &&\n        update2.missing.length !== 2 &&\n        update2.missing[0] !== 0 &&\n        update2.missing[1] !== 0\n      ) {\n        applyUpdate(doc, update2.missing, origin);\n        hasUpdate = true;\n      }\n      if (hasUpdate) {\n        await datasource.sendDocUpdate(\n          guid,\n          encodeStateAsUpdate(\n            doc,\n            update1 ? update1.state : update2 ? update2.state : undefined\n          )\n        );\n      }\n    }\n    if (!connected) {\n      return;\n    }\n\n    changeStatus({\n      type: 'syncing',\n    });\n    const remoteUpdate = await datasource\n      .queryDocState(guid, {\n        stateVector: encodeStateVector(doc),\n      })\n      .then(remoteUpdate => {\n        changeStatus({\n          type: 'synced',\n        });\n        return remoteUpdate;\n      })\n      .catch(error => {\n        changeStatus({\n          type: 'error',\n          error,\n        });\n        throw error;\n      });\n\n    pendingMap.set(guid, []);\n\n    if (remoteUpdate) {\n      applyUpdate(doc, remoteUpdate.missing, origin);\n    }\n\n    if (!connected) {\n      return;\n    }\n\n    // perf: optimize me\n    // it is possible the doc is only in memory but not yet in the datasource\n    // we need to send the whole update to the datasource\n    await datasource.sendDocUpdate(\n      guid,\n      encodeStateAsUpdate(doc, remoteUpdate ? remoteUpdate.state : undefined)\n    );\n\n    doc.emit('sync', []);\n  }\n\n  /**\n   * Sets up event listeners for a Yjs document.\n   * @param doc - The Yjs document to set up listeners for.\n   */\n  function setupDocListener(doc: Doc) {\n    const disposables = new Set<() => void>();\n    disposableMap.set(doc.guid, disposables);\n    const updateHandler = async (update: Uint8Array, updateOrigin: unknown) => {\n      if (origin === updateOrigin) {\n        return;\n      }\n      changeStatus({\n        type: 'syncing',\n      });\n      datasource\n        .sendDocUpdate(doc.guid, update)\n        .then(() => {\n          changeStatus({\n            type: 'synced',\n          });\n        })\n        .catch(error => {\n          changeStatus({\n            type: 'error',\n            error,\n          });\n          console.error(error);\n        });\n    };\n\n    const subdocsHandler = (event: {\n      loaded: Set<Doc>;\n      removed: Set<Doc>;\n      added: Set<Doc>;\n    }) => {\n      event.loaded.forEach(subdoc => {\n        connectDoc(subdoc).catch(console.error);\n      });\n      event.removed.forEach(subdoc => {\n        disposeDoc(subdoc);\n      });\n    };\n\n    doc.on('update', updateHandler);\n    doc.on('subdocs', subdocsHandler);\n    // todo: handle destroy?\n    disposables.add(() => {\n      doc.off('update', updateHandler);\n      doc.off('subdocs', subdocsHandler);\n    });\n  }\n\n  /**\n   * Sets up event listeners for the datasource.\n   * Specifically, listens for updates to documents and applies them to the corresponding Yjs document.\n   */\n  function setupDatasourceListeners() {\n    assertExists(abortController, 'abortController should be defined');\n    const unsubscribe = datasource.onDocUpdate?.((guid, update) => {\n      changeStatus({\n        type: 'syncing',\n      });\n      const doc = getDoc(rootDoc, guid);\n      if (doc) {\n        applyUpdate(doc, update, origin);\n        //\n        if (pendingMap.has(guid)) {\n          pendingMap\n            .get(guid)\n            ?.forEach(update => applyUpdate(doc, update, origin));\n          pendingMap.delete(guid);\n        }\n      } else {\n        // This case happens when the father doc is not yet updated,\n        //  so that the child doc is not yet created.\n        //  We need to put it into cache so that it can be applied later.\n        console.warn('doc not found', guid);\n        pendingMap.set(guid, (pendingMap.get(guid) ?? []).concat(update));\n      }\n      changeStatus({\n        type: 'synced',\n      });\n    });\n    abortController.signal.addEventListener('abort', () => {\n      unsubscribe?.();\n    });\n  }\n\n  // when a subdoc is loaded, we need to sync it with the datasource and setup listeners\n  async function connectDoc(doc: Doc) {\n    // skip if already connected\n    if (connectedDocs.has(doc.guid)) {\n      return;\n    }\n    connectedDocs.add(doc.guid);\n    setupDocListener(doc);\n    await syncDoc(doc);\n\n    await Promise.all(\n      [...doc.subdocs]\n        .filter(subdoc => subdoc.shouldLoad)\n        .map(subdoc => connectDoc(subdoc))\n    );\n  }\n\n  function disposeDoc(doc: Doc) {\n    connectedDocs.delete(doc.guid);\n    const disposables = disposableMap.get(doc.guid);\n    if (disposables) {\n      disposables.forEach(dispose => dispose());\n      disposableMap.delete(doc.guid);\n    }\n    // also dispose all subdocs\n    doc.subdocs.forEach(disposeDoc);\n  }\n\n  function disposeAll() {\n    disposableMap.forEach(disposables => {\n      disposables.forEach(dispose => dispose());\n    });\n    disposableMap.clear();\n    connectedDocs.clear();\n  }\n\n  /**\n   * Connects to the datasource and sets up event listeners for document updates.\n   */\n  function connect() {\n    connected = true;\n    abortController = new AbortController();\n\n    changeStatus({\n      type: 'syncing',\n    });\n    // root doc should be already loaded,\n    // but we want to populate the cache for later update events\n    connectDoc(rootDoc)\n      .then(() => {\n        changeStatus({\n          type: 'synced',\n        });\n      })\n      .catch(error => {\n        changeStatus({\n          type: 'error',\n          error,\n        });\n        console.error(error);\n      });\n    setupDatasourceListeners();\n  }\n\n  async function disconnect() {\n    connected = false;\n    disposeAll();\n    assertExists(abortController, 'abortController should be defined');\n    abortController.abort();\n    abortController = null;\n  }\n\n  const syncDocRecursive = async (doc: Doc) => {\n    await syncDoc(doc);\n    await Promise.all(\n      [...doc.subdocs.values()].map(subdoc => syncDocRecursive(subdoc))\n    );\n  };\n\n  return {\n    sync: async onlyRootDoc => {\n      connected = true;\n      try {\n        if (onlyRootDoc) {\n          await syncDoc(rootDoc);\n        } else {\n          await syncDocRecursive(rootDoc);\n        }\n      } finally {\n        connected = false;\n      }\n    },\n    get status() {\n      return currentStatus;\n    },\n    subscribeStatusChange(cb: () => void) {\n      callbackSet.add(cb);\n      return () => {\n        callbackSet.delete(cb);\n      };\n    },\n    get connected() {\n      return connected;\n    },\n    passive: true,\n    connect,\n    disconnect,\n\n    datasource,\n  };\n};\n","import type { Doc } from 'yjs';\n\nexport function getDoc(doc: Doc, guid: string): Doc | undefined {\n  if (doc.guid === guid) {\n    return doc;\n  }\n  for (const subdoc of doc.subdocs) {\n    const found = getDoc(subdoc, guid);\n    if (found) {\n      return found;\n    }\n  }\n  return undefined;\n}\n\nconst saveAlert = (event: BeforeUnloadEvent) => {\n  event.preventDefault();\n  return (event.returnValue =\n    'Data is not saved. Are you sure you want to leave?');\n};\n\nexport const writeOperation = async (op: Promise<unknown>) => {\n  window.addEventListener('beforeunload', saveAlert, {\n    capture: true,\n  });\n  await op;\n  window.removeEventListener('beforeunload', saveAlert, {\n    capture: true,\n  });\n};\n"],"names":["syncDocFromDataSource","rootDoc","datasource","downloadDocStateRecursively","doc","docState","applyUpdate","subdoc","syncDataSourceFromDoc","uploadDocStateRecursively","encodeStateAsUpdate","syncDataSource","listDocGuids","remoteDataSource","localDataSource","guids","guid","remoteDocState","missing","assertExists","val","message","getDoc","found","createLazyProvider","options","connected","pendingMap","disposableMap","connectedDocs","abortController","origin","currentStatus","syncingStack","callbackSet","changeStatus","newStatus","cb","syncDoc","prefixId","possible1","possible2","update1","update2","hasUpdate","remoteUpdate","encodeStateVector","error","setupDocListener","disposables","updateHandler","update","updateOrigin","subdocsHandler","event","connectDoc","disposeDoc","setupDatasourceListeners","unsubscribe","_a","dispose","disposeAll","connect","disconnect","syncDocRecursive","onlyRootDoc","saveAlert","writeOperation","op"],"mappings":"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","x_google_ignoreList":[1]}