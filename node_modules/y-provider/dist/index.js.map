{"version":3,"file":"index.js","sources":["../src/data-source.ts","../../../../node_modules/@blocksuite/global/dist/utils/assert.js","../src/lazy-provider.ts","../src/utils.ts"],"sourcesContent":["import type { Doc as YDoc } from 'yjs';\nimport { applyUpdate, encodeStateAsUpdate } from 'yjs';\n\nimport type { DocState } from './types';\n\nexport interface DocDataSource {\n  /**\n   * request diff update from other clients\n   */\n  queryDocState: (\n    guid: string,\n    options?: {\n      stateVector?: Uint8Array;\n      targetClientId?: number;\n    }\n  ) => Promise<DocState | false>;\n\n  /**\n   * send update to the datasource\n   */\n  sendDocUpdate: (guid: string, update: Uint8Array) => Promise<void>;\n\n  /**\n   * listen to update from the datasource. Returns a function to unsubscribe.\n   * this is optional because some datasource might not support it\n   */\n  onDocUpdate?(\n    callback: (guid: string, update: Uint8Array) => void\n  ): () => void;\n}\n\nexport async function syncDocFromDataSource(\n  rootDoc: YDoc,\n  datasource: DocDataSource\n) {\n  const downloadDocStateRecursively = async (doc: YDoc) => {\n    const docState = await datasource.queryDocState(doc.guid);\n    if (docState) {\n      applyUpdate(doc, docState.missing, 'sync-doc-from-datasource');\n    }\n    await Promise.all(\n      [...doc.subdocs].map(async subdoc => {\n        await downloadDocStateRecursively(subdoc);\n      })\n    );\n  };\n  await downloadDocStateRecursively(rootDoc);\n}\n\nexport async function syncDataSourceFromDoc(\n  rootDoc: YDoc,\n  datasource: DocDataSource\n) {\n  const uploadDocStateRecursively = async (doc: YDoc) => {\n    await datasource.sendDocUpdate(doc.guid, encodeStateAsUpdate(doc));\n    await Promise.all(\n      [...doc.subdocs].map(async subdoc => {\n        await uploadDocStateRecursively(subdoc);\n      })\n    );\n  };\n\n  await uploadDocStateRecursively(rootDoc);\n}\n\n/**\n * query the datasource from source, and save the latest update to target\n *\n * @example\n *  bindDataSource(socketIO, indexedDB)\n *  bindDataSource(socketIO, sqlite)\n */\nexport async function syncDataSource(\n  listDocGuids: () => string[],\n  remoteDataSource: DocDataSource,\n  localDataSource: DocDataSource\n) {\n  const guids = listDocGuids();\n  await Promise.all(\n    guids.map(guid => {\n      return localDataSource.queryDocState(guid).then(async docState => {\n        const remoteDocState = await (async () => {\n          if (docState) {\n            return remoteDataSource.queryDocState(guid, {\n              stateVector: docState.state,\n            });\n          } else {\n            return remoteDataSource.queryDocState(guid);\n          }\n        })();\n        if (remoteDocState) {\n          const missing = remoteDocState.missing;\n          if (missing.length === 2 && missing[0] === 0 && missing[1] === 0) {\n            // empty update\n            return;\n          }\n          await localDataSource.sendDocUpdate(guid, remoteDocState.missing);\n        }\n      });\n    })\n  );\n}\n","// https://stackoverflow.com/questions/31538010/test-if-a-variable-is-a-primitive-rather-than-an-object\nexport function isPrimitive(a) {\n    return a !== Object(a);\n}\nexport function assertExists(val, message = 'val does not exist') {\n    if (val === null || val === undefined) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw new Error(message);\n    }\n}\nexport function assertNotExists(val, message = 'val exists') {\n    if (val !== null && val !== undefined) {\n        throw new Error(message);\n    }\n}\nexport function isEqual(val, expected) {\n    const a = isPrimitive(val);\n    const b = isPrimitive(expected);\n    if (a && b) {\n        if (!Object.is(val, expected)) {\n            return false;\n        }\n    }\n    else if (a !== b) {\n        return false;\n    }\n    else {\n        if (Array.isArray(val) && Array.isArray(expected)) {\n            if (val.length !== expected.length) {\n                return false;\n            }\n            return val.every((x, i) => isEqual(x, expected[i]));\n        }\n        else if (typeof val === 'object' && typeof expected === 'object') {\n            const obj1 = Object.entries(val);\n            const obj2 = Object.entries(expected);\n            if (obj1.length !== obj2.length) {\n                return false;\n            }\n            return obj1.every((x, i) => isEqual(x, obj2[i]));\n        }\n    }\n    return true;\n}\nexport function assertEquals(val, expected, message = 'val is not same as expected') {\n    if (!isEqual(val, expected)) {\n        throw new Error(message);\n    }\n}\nexport function assertInstanceOf(val, expected, message = 'val is not instance of expected') {\n    if (!(val instanceof expected)) {\n        throw new Error(message);\n    }\n}\n//# sourceMappingURL=assert.js.map","import { assertExists } from '@blocksuite/global/utils';\nimport {\n  applyUpdate,\n  type Doc,\n  encodeStateAsUpdate,\n  encodeStateVector,\n} from 'yjs';\n\nimport type { DocDataSource } from './data-source';\nimport type { DataSourceAdapter } from './types';\nimport type { Status } from './types';\n\nfunction getDoc(doc: Doc, guid: string): Doc | undefined {\n  if (doc.guid === guid) {\n    return doc;\n  }\n  for (const subdoc of doc.subdocs) {\n    const found = getDoc(subdoc, guid);\n    if (found) {\n      return found;\n    }\n  }\n  return undefined;\n}\n\ninterface LazyProviderOptions {\n  origin?: string;\n}\n\nexport type DocProvider = {\n  // backport from `@blocksuite/store`\n  passive: true;\n\n  sync(onlyRootDoc?: boolean): Promise<void>;\n\n  get connected(): boolean;\n  connect(): void;\n  disconnect(): void;\n};\n\n/**\n * Creates a lazy provider that connects to a datasource and synchronizes a root document.\n */\nexport const createLazyProvider = (\n  rootDoc: Doc,\n  datasource: DocDataSource,\n  options: LazyProviderOptions = {}\n): DocProvider & DataSourceAdapter => {\n  let connected = false;\n  const pendingMap = new Map<string, Uint8Array[]>(); // guid -> pending-updates\n  const disposableMap = new Map<string, Set<() => void>>();\n  const connectedDocs = new Set<string>();\n  let abortController: AbortController | null = null;\n\n  const { origin = 'lazy-provider' } = options;\n\n  // todo: should we use a real state machine here like `xstate`?\n  let currentStatus: Status = {\n    type: 'idle',\n  };\n  let syncingStack = 0;\n  const callbackSet = new Set<() => void>();\n  const changeStatus = (newStatus: Status) => {\n    // simulate a stack, each syncing and synced should be paired\n    if (newStatus.type === 'syncing') {\n      syncingStack++;\n    } else if (newStatus.type === 'synced' || newStatus.type === 'error') {\n      syncingStack--;\n    }\n\n    if (syncingStack < 0) {\n      console.error(\n        'syncingStatus < 0, this should not happen',\n        options.origin\n      );\n    }\n\n    if (syncingStack === 0) {\n      currentStatus = newStatus;\n    }\n    if (newStatus.type !== 'synced') {\n      currentStatus = newStatus;\n    }\n    if (syncingStack === 0) {\n      if (!connected) {\n        currentStatus = {\n          type: 'idle',\n        };\n      } else {\n        currentStatus = {\n          type: 'synced',\n        };\n      }\n    }\n    callbackSet.forEach(cb => cb());\n  };\n\n  async function syncDoc(doc: Doc) {\n    const guid = doc.guid;\n    {\n      // backport from `@blocksuite/store`\n      const prefixId = guid.startsWith('space:') ? guid.slice(6) : guid;\n      const possible1 = `${rootDoc.guid}:space:${prefixId}`;\n      const possible2 = `space:${prefixId}`;\n      const update1 = await datasource.queryDocState(possible1);\n      const update2 = await datasource.queryDocState(possible2);\n      let hasUpdate = false;\n      if (\n        update1 &&\n        update1.missing.length !== 2 &&\n        update1.missing[0] !== 0 &&\n        update1.missing[1] !== 0\n      ) {\n        applyUpdate(doc, update1.missing, origin);\n        hasUpdate = true;\n      }\n      if (\n        update2 &&\n        update2.missing.length !== 2 &&\n        update2.missing[0] !== 0 &&\n        update2.missing[1] !== 0\n      ) {\n        applyUpdate(doc, update2.missing, origin);\n        hasUpdate = true;\n      }\n      if (hasUpdate) {\n        await datasource.sendDocUpdate(\n          guid,\n          encodeStateAsUpdate(\n            doc,\n            update1 ? update1.state : update2 ? update2.state : undefined\n          )\n        );\n      }\n    }\n    if (!connected) {\n      return;\n    }\n\n    changeStatus({\n      type: 'syncing',\n    });\n    const remoteUpdate = await datasource\n      .queryDocState(guid, {\n        stateVector: encodeStateVector(doc),\n      })\n      .then(remoteUpdate => {\n        changeStatus({\n          type: 'synced',\n        });\n        return remoteUpdate;\n      })\n      .catch(error => {\n        changeStatus({\n          type: 'error',\n          error,\n        });\n        throw error;\n      });\n\n    pendingMap.set(guid, []);\n\n    if (remoteUpdate) {\n      applyUpdate(doc, remoteUpdate.missing, origin);\n    }\n\n    if (!connected) {\n      return;\n    }\n\n    // perf: optimize me\n    // it is possible the doc is only in memory but not yet in the datasource\n    // we need to send the whole update to the datasource\n    await datasource.sendDocUpdate(\n      guid,\n      encodeStateAsUpdate(doc, remoteUpdate ? remoteUpdate.state : undefined)\n    );\n\n    doc.emit('sync', []);\n  }\n\n  /**\n   * Sets up event listeners for a Yjs document.\n   * @param doc - The Yjs document to set up listeners for.\n   */\n  function setupDocListener(doc: Doc) {\n    const disposables = new Set<() => void>();\n    disposableMap.set(doc.guid, disposables);\n    const updateHandler = async (update: Uint8Array, updateOrigin: unknown) => {\n      if (origin === updateOrigin) {\n        return;\n      }\n      changeStatus({\n        type: 'syncing',\n      });\n      datasource\n        .sendDocUpdate(doc.guid, update)\n        .then(() => {\n          changeStatus({\n            type: 'synced',\n          });\n        })\n        .catch(error => {\n          changeStatus({\n            type: 'error',\n            error,\n          });\n          console.error(error);\n        });\n    };\n\n    const subdocsHandler = (event: {\n      loaded: Set<Doc>;\n      removed: Set<Doc>;\n      added: Set<Doc>;\n    }) => {\n      event.loaded.forEach(subdoc => {\n        connectDoc(subdoc).catch(console.error);\n      });\n      event.removed.forEach(subdoc => {\n        disposeDoc(subdoc);\n      });\n    };\n\n    doc.on('update', updateHandler);\n    doc.on('subdocs', subdocsHandler);\n    // todo: handle destroy?\n    disposables.add(() => {\n      doc.off('update', updateHandler);\n      doc.off('subdocs', subdocsHandler);\n    });\n  }\n\n  /**\n   * Sets up event listeners for the datasource.\n   * Specifically, listens for updates to documents and applies them to the corresponding Yjs document.\n   */\n  function setupDatasourceListeners() {\n    assertExists(abortController, 'abortController should be defined');\n    const unsubscribe = datasource.onDocUpdate?.((guid, update) => {\n      changeStatus({\n        type: 'syncing',\n      });\n      const doc = getDoc(rootDoc, guid);\n      if (doc) {\n        applyUpdate(doc, update, origin);\n        //\n        if (pendingMap.has(guid)) {\n          pendingMap\n            .get(guid)\n            ?.forEach(update => applyUpdate(doc, update, origin));\n          pendingMap.delete(guid);\n        }\n      } else {\n        // This case happens when the father doc is not yet updated,\n        //  so that the child doc is not yet created.\n        //  We need to put it into cache so that it can be applied later.\n        console.warn('doc not found', guid);\n        pendingMap.set(guid, (pendingMap.get(guid) ?? []).concat(update));\n      }\n      changeStatus({\n        type: 'synced',\n      });\n    });\n    abortController.signal.addEventListener('abort', () => {\n      unsubscribe?.();\n    });\n  }\n\n  // when a subdoc is loaded, we need to sync it with the datasource and setup listeners\n  async function connectDoc(doc: Doc) {\n    // skip if already connected\n    if (connectedDocs.has(doc.guid)) {\n      return;\n    }\n    connectedDocs.add(doc.guid);\n    setupDocListener(doc);\n    await syncDoc(doc);\n\n    await Promise.all(\n      [...doc.subdocs]\n        .filter(subdoc => subdoc.shouldLoad)\n        .map(subdoc => connectDoc(subdoc))\n    );\n  }\n\n  function disposeDoc(doc: Doc) {\n    connectedDocs.delete(doc.guid);\n    const disposables = disposableMap.get(doc.guid);\n    if (disposables) {\n      disposables.forEach(dispose => dispose());\n      disposableMap.delete(doc.guid);\n    }\n    // also dispose all subdocs\n    doc.subdocs.forEach(disposeDoc);\n  }\n\n  function disposeAll() {\n    disposableMap.forEach(disposables => {\n      disposables.forEach(dispose => dispose());\n    });\n    disposableMap.clear();\n    connectedDocs.clear();\n  }\n\n  /**\n   * Connects to the datasource and sets up event listeners for document updates.\n   */\n  function connect() {\n    connected = true;\n    abortController = new AbortController();\n\n    changeStatus({\n      type: 'syncing',\n    });\n    // root doc should be already loaded,\n    // but we want to populate the cache for later update events\n    connectDoc(rootDoc)\n      .then(() => {\n        changeStatus({\n          type: 'synced',\n        });\n      })\n      .catch(error => {\n        changeStatus({\n          type: 'error',\n          error,\n        });\n        console.error(error);\n      });\n    setupDatasourceListeners();\n  }\n\n  async function disconnect() {\n    connected = false;\n    disposeAll();\n    assertExists(abortController, 'abortController should be defined');\n    abortController.abort();\n    abortController = null;\n  }\n\n  const syncDocRecursive = async (doc: Doc) => {\n    await syncDoc(doc);\n    await Promise.all(\n      [...doc.subdocs.values()].map(subdoc => syncDocRecursive(subdoc))\n    );\n  };\n\n  return {\n    sync: async onlyRootDoc => {\n      connected = true;\n      try {\n        if (onlyRootDoc) {\n          await syncDoc(rootDoc);\n        } else {\n          await syncDocRecursive(rootDoc);\n        }\n      } finally {\n        connected = false;\n      }\n    },\n    get status() {\n      return currentStatus;\n    },\n    subscribeStatusChange(cb: () => void) {\n      callbackSet.add(cb);\n      return () => {\n        callbackSet.delete(cb);\n      };\n    },\n    get connected() {\n      return connected;\n    },\n    passive: true,\n    connect,\n    disconnect,\n\n    datasource,\n  };\n};\n","import type { Doc } from 'yjs';\n\nexport function getDoc(doc: Doc, guid: string): Doc | undefined {\n  if (doc.guid === guid) {\n    return doc;\n  }\n  for (const subdoc of doc.subdocs) {\n    const found = getDoc(subdoc, guid);\n    if (found) {\n      return found;\n    }\n  }\n  return undefined;\n}\n\nconst saveAlert = (event: BeforeUnloadEvent) => {\n  event.preventDefault();\n  return (event.returnValue =\n    'Data is not saved. Are you sure you want to leave?');\n};\n\nexport const writeOperation = async (op: Promise<unknown>) => {\n  window.addEventListener('beforeunload', saveAlert, {\n    capture: true,\n  });\n  await op;\n  window.removeEventListener('beforeunload', saveAlert, {\n    capture: true,\n  });\n};\n"],"names":["syncDocFromDataSource","rootDoc","datasource","downloadDocStateRecursively","doc","docState","applyUpdate","subdoc","syncDataSourceFromDoc","uploadDocStateRecursively","encodeStateAsUpdate","syncDataSource","listDocGuids","remoteDataSource","localDataSource","guids","guid","remoteDocState","missing","assertExists","val","message","getDoc","found","createLazyProvider","options","connected","pendingMap","disposableMap","connectedDocs","abortController","origin","currentStatus","syncingStack","callbackSet","changeStatus","newStatus","cb","syncDoc","prefixId","possible1","possible2","update1","update2","hasUpdate","remoteUpdate","encodeStateVector","error","setupDocListener","disposables","updateHandler","update","updateOrigin","subdocsHandler","event","connectDoc","disposeDoc","setupDatasourceListeners","unsubscribe","_a","dispose","disposeAll","connect","disconnect","syncDocRecursive","onlyRootDoc","saveAlert","writeOperation","op"],"mappings":"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","x_google_ignoreList":[1]}