{"mappings":"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","sources":["packages/@react-stately/layout/src/GridLayout.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DropTarget, DropTargetDelegate, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {Layout, LayoutInfo, Rect, Size} from '@react-stately/virtualizer';\n\nexport interface GridLayoutOptions {\n  /**\n   * The minimum item size.\n   * @default 200 x 200\n   */\n  minItemSize?: Size,\n  /**\n   * The maximum item size.\n   * @default Infinity\n   */\n  maxItemSize?: Size,\n  /**\n   * The minimum space required between items.\n   * @default 18 x 18\n   */\n  minSpace?: Size,\n  /**\n   * The maximum number of columns.\n   * @default Infinity\n   */\n  maxColumns?: number,\n  /**\n   * The thickness of the drop indicator.\n   * @default 2\n   */\n  dropIndicatorThickness?: number\n}\n\nexport class GridLayout<T, O = any> extends Layout<Node<T>, O> implements DropTargetDelegate {\n  protected minItemSize: Size;\n  protected maxItemSize: Size;\n  protected minSpace: Size;\n  protected maxColumns: number;\n  protected dropIndicatorThickness: number;\n  protected itemSize: Size;\n  protected numColumns: number;\n  protected horizontalSpacing: number;\n  protected layoutInfos: LayoutInfo[];\n\n  constructor(options: GridLayoutOptions) {\n    super();\n    this.minItemSize = options.minItemSize || new Size(200, 200);\n    this.maxItemSize = options.maxItemSize || new Size(Infinity, Infinity);\n    this.minSpace = options.minSpace || new Size(18, 18);\n    this.maxColumns = options.maxColumns || Infinity;\n    this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n  }\n\n  update(): void {\n    let visibleWidth = this.virtualizer.visibleRect.width;\n\n    // The max item width is always the entire viewport.\n    // If the max item height is infinity, scale in proportion to the max width.\n    let maxItemWidth = Math.min(this.maxItemSize.width, visibleWidth);\n    let maxItemHeight = Number.isFinite(this.maxItemSize.height) \n      ? this.maxItemSize.height\n      : Math.floor((this.minItemSize.height / this.minItemSize.width) * maxItemWidth);\n\n    // Compute the number of rows and columns needed to display the content\n    let columns = Math.floor(visibleWidth / (this.minItemSize.width + this.minSpace.width));\n    this.numColumns = Math.max(1, Math.min(this.maxColumns, columns));\n\n    // Compute the available width (minus the space between items)\n    let width = visibleWidth - (this.minSpace.width * Math.max(0, this.numColumns));\n\n    // Compute the item width based on the space available\n    let itemWidth = Math.floor(width / this.numColumns);\n    itemWidth = Math.max(this.minItemSize.width, Math.min(maxItemWidth, itemWidth));\n\n    // Compute the item height, which is proportional to the item width\n    let t = ((itemWidth - this.minItemSize.width) / Math.max(1, maxItemWidth - this.minItemSize.width));\n    let itemHeight = this.minItemSize.height +  Math.floor((maxItemHeight - this.minItemSize.height) * t);\n    itemHeight = Math.max(this.minItemSize.height, Math.min(maxItemHeight, itemHeight));\n    this.itemSize = new Size(itemWidth, itemHeight);\n\n    // Compute the horizontal spacing and content height\n    this.horizontalSpacing = Math.floor((visibleWidth - this.numColumns * this.itemSize.width) / (this.numColumns + 1));\n\n    this.layoutInfos = [];\n    for (let node of this.virtualizer.collection) {\n      this.layoutInfos.push(this.getLayoutInfoForNode(node));\n    }\n  }\n\n  getVisibleLayoutInfos(rect: Rect): LayoutInfo[] {\n    let firstVisibleItem = this.getIndexAtPoint(rect.x, rect.y);\n    let lastVisibleItem = this.getIndexAtPoint(rect.maxX, rect.maxY);\n    let result = this.layoutInfos.slice(firstVisibleItem, lastVisibleItem + 1);\n    let persistedIndices: number[] = [];\n    for (let key of this.virtualizer.persistedKeys) {\n      let item = this.virtualizer.collection.getItem(key);\n      if (item?.index != null) {\n        persistedIndices.push(item.index);\n      }\n    }\n    persistedIndices.sort((a, b) => a - b);\n    \n    let persistedBefore: LayoutInfo[] = [];\n    for (let index of persistedIndices) {\n      if (index < firstVisibleItem) {\n        persistedBefore.push(this.layoutInfos[index]);\n      } else if (index > lastVisibleItem) {\n        result.push(this.layoutInfos[index]);\n      }\n    }\n    result.unshift(...persistedBefore);\n    return result;\n  }\n\n  protected getIndexAtPoint(x: number, y: number) {\n    let itemHeight = this.itemSize.height + this.minSpace.height;\n    let itemWidth = this.itemSize.width + this.horizontalSpacing;\n    return Math.max(0,\n      Math.min(\n        this.virtualizer.collection.size - 1,\n        Math.floor(y / itemHeight) * this.numColumns + Math.floor((x - this.horizontalSpacing) / itemWidth)\n      )\n    );\n  }\n\n  getLayoutInfo(key: Key): LayoutInfo | null {\n    let node = this.virtualizer.collection.getItem(key);\n    return node ? this.layoutInfos[node.index] : null;\n  }\n\n  protected getLayoutInfoForNode(node: Node<T>): LayoutInfo {\n    let idx = node.index;\n    let row = Math.floor(idx / this.numColumns);\n    let column = idx % this.numColumns;\n    let x = this.horizontalSpacing + column * (this.itemSize.width + this.horizontalSpacing);\n    let y = this.minSpace.height + row * (this.itemSize.height + this.minSpace.height);\n    let rect = new Rect(x, y, this.itemSize.width, this.itemSize.height);\n    return new LayoutInfo(node.type, node.key, rect);\n  }\n\n  getContentSize(): Size {\n    let numRows = Math.ceil(this.virtualizer.collection.size / this.numColumns);\n    let contentHeight = this.minSpace.height + numRows * (this.itemSize.height + this.minSpace.height);  \n    return new Size(this.virtualizer.visibleRect.width, contentHeight);\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    if (this.layoutInfos.length === 0) {\n      return {type: 'root'};\n    }\n\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n    let index = this.getIndexAtPoint(x, y);\n\n    let layoutInfo = this.layoutInfos[index];\n    let target: DropTarget =  {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    let pos = this.numColumns === 1 ? y : x;\n    let layoutInfoPos = this.numColumns === 1 ? layoutInfo.rect.y : layoutInfo.rect.x;\n    let size = this.numColumns === 1 ? layoutInfo.rect.height : layoutInfo.rect.width;\n    if (isValidDropTarget(target)) {\n      // If dropping on the item is accepted, try the before/after positions\n      // if within 5px of the start or end of the item.\n      if (pos < layoutInfoPos + 5) {\n        target.dropPosition = 'before';\n      } else if (pos > layoutInfoPos + size - 5) {\n        target.dropPosition = 'after';\n      }\n    } else {\n      // If dropping on the item isn't accepted, try the target before or after depending on the position.\n      let mid = layoutInfoPos + size / 2;\n      if (pos <= mid && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (pos >= mid && isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    }\n\n    return target;\n  }\n\n  getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo {\n    let layoutInfo = this.getLayoutInfo(target.key);\n    let rect: Rect;\n    if (this.numColumns === 1) {\n      // Flip from vertical to horizontal if only one column is visible.\n      rect = new Rect(\n        layoutInfo.rect.x,\n        target.dropPosition === 'before' \n          ? layoutInfo.rect.y - this.minSpace.height / 2 - this.dropIndicatorThickness / 2\n          : layoutInfo.rect.maxY + this.minSpace.height / 2 - this.dropIndicatorThickness / 2,\n        layoutInfo.rect.width,\n        this.dropIndicatorThickness\n      );\n    } else {\n      rect = new Rect(\n        target.dropPosition === 'before' \n          ? layoutInfo.rect.x - this.horizontalSpacing / 2 - this.dropIndicatorThickness / 2 \n          : layoutInfo.rect.maxX + this.horizontalSpacing / 2 - this.dropIndicatorThickness / 2,\n        layoutInfo.rect.y,\n        this.dropIndicatorThickness,\n        layoutInfo.rect.height\n      );\n    }\n\n    return new LayoutInfo('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n}\n"],"names":[],"version":3,"file":"GridLayout.main.js.map"}