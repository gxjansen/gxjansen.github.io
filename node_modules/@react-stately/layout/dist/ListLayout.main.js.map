{"mappings":"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","sources":["packages/@react-stately/layout/src/ListLayout.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DropTarget, DropTargetDelegate, Key, KeyboardDelegate, Node} from '@react-types/shared';\nimport {getChildNodes} from '@react-stately/collections';\nimport {InvalidationContext, Layout, LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\n\nexport type ListLayoutOptions<T> = {\n  /** The height of a row in px. */\n  rowHeight?: number,\n  estimatedRowHeight?: number,\n  headingHeight?: number,\n  estimatedHeadingHeight?: number,\n  padding?: number,\n  indentationForItem?: (collection: Collection<Node<T>>, key: Key) => number,\n  collator?: Intl.Collator,\n  loaderHeight?: number,\n  placeholderHeight?: number,\n  allowDisabledKeyFocus?: boolean\n};\n\n// A wrapper around LayoutInfo that supports hierarchy\nexport interface LayoutNode {\n  node?: Node<unknown>,\n  layoutInfo: LayoutInfo,\n  header?: LayoutInfo,\n  children?: LayoutNode[],\n  validRect: Rect,\n  index?: number\n}\n\nconst DEFAULT_HEIGHT = 48;\n\n/**\n * The ListLayout class is an implementation of a collection view {@link Layout}\n * it is used for creating lists and lists with indented sub-lists.\n *\n * To configure a ListLayout, you can use the properties to define the\n * layouts and/or use the method for defining indentation.\n * The {@link ListKeyboardDelegate} extends the existing collection view\n * delegate with an additional method to do this (it uses the same delegate object as\n * the collection view itself).\n */\nexport class ListLayout<T> extends Layout<Node<T>> implements KeyboardDelegate, DropTargetDelegate {\n  protected rowHeight: number;\n  protected estimatedRowHeight: number;\n  protected headingHeight: number;\n  protected estimatedHeadingHeight: number;\n  protected padding: number;\n  protected indentationForItem?: (collection: Collection<Node<T>>, key: Key) => number;\n  protected layoutInfos: Map<Key, LayoutInfo>;\n  protected layoutNodes: Map<Key, LayoutNode>;\n  protected contentSize: Size;\n  collection: Collection<Node<T>>;\n  disabledKeys: Set<Key> = new Set();\n  allowDisabledKeyFocus: boolean = false;\n  isLoading: boolean;\n  protected lastWidth: number;\n  protected lastCollection: Collection<Node<T>>;\n  protected rootNodes: LayoutNode[];\n  protected collator: Intl.Collator;\n  protected invalidateEverything: boolean;\n  protected loaderHeight: number;\n  protected placeholderHeight: number;\n  protected lastValidRect: Rect;\n  protected validRect: Rect;\n\n  /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */\n  constructor(options: ListLayoutOptions<T> = {}) {\n    super();\n    this.rowHeight = options.rowHeight;\n    this.estimatedRowHeight = options.estimatedRowHeight;\n    this.headingHeight = options.headingHeight;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n    this.padding = options.padding || 0;\n    this.indentationForItem = options.indentationForItem;\n    this.collator = options.collator;\n    this.loaderHeight = options.loaderHeight;\n    this.placeholderHeight = options.placeholderHeight;\n    this.layoutInfos = new Map();\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n    this.allowDisabledKeyFocus = options.allowDisabledKeyFocus;\n    this.lastValidRect = new Rect();\n    this.validRect = new Rect();\n    this.contentSize = new Size();\n  }\n\n  getLayoutInfo(key: Key) {\n    let res = this.layoutInfos.get(key);\n\n    // If the layout info wasn't found, it might be outside the bounds of the area that we've\n    // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n    // Compute the full layout and try again.\n    if (!res && this.validRect.area < this.contentSize.area && this.lastCollection) {\n      this.lastValidRect = this.validRect;\n      this.validRect = new Rect(0, 0, Infinity, Infinity);\n      this.rootNodes = this.buildCollection();\n      this.validRect = new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n      res = this.layoutInfos.get(key);\n    }\n\n    return res;\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    if (!this.validRect.containsRect(rect) && this.lastCollection) {\n      this.lastValidRect = this.validRect;\n      this.validRect = this.validRect.union(rect);\n      this.rootNodes = this.buildCollection();\n    }\n\n    let res: LayoutInfo[] = [];\n\n    let addNodes = (nodes: LayoutNode[]) => {\n      for (let node of nodes) {\n        if (this.isVisible(node, rect)) {\n          res.push(node.layoutInfo);\n          if (node.header) {\n            res.push(node.header);\n          }\n\n          if (node.children) {\n            addNodes(node.children);\n          }\n        }\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  isVisible(node: LayoutNode, rect: Rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || this.virtualizer.isPersistedKey(node.layoutInfo.key);\n  }\n\n  protected shouldInvalidateEverything(invalidationContext: InvalidationContext<Node<T>, unknown>) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    return invalidationContext.sizeChanged;\n  }\n\n  validate(invalidationContext: InvalidationContext<Node<T>, unknown>) {\n    this.collection = this.virtualizer.collection;\n\n    // Reset valid rect if we will have to invalidate everything.\n    // Otherwise we can reuse cached layout infos outside the current visible rect.\n    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n    if (this.invalidateEverything) {\n      this.lastValidRect = this.validRect;\n      this.validRect = this.virtualizer.getVisibleRect();\n    }\n\n    this.rootNodes = this.buildCollection();\n\n    // Remove deleted layout nodes\n    if (this.lastCollection && this.collection !== this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) {\n        if (!this.collection.getItem(key)) {\n          let layoutNode = this.layoutNodes.get(key);\n          if (layoutNode) {\n            this.layoutInfos.delete(layoutNode.layoutInfo.key);\n            this.layoutInfos.delete(layoutNode.header?.key);\n            this.layoutNodes.delete(key);\n          }\n        }\n      }\n    }\n\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = this.collection;\n    this.invalidateEverything = false;\n  }\n\n  buildCollection(): LayoutNode[] {\n    let y = this.padding;\n    let skipped = 0;\n    let nodes = [];\n    for (let node of this.collection) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight);\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (node.type === 'item' && y + rowHeight < this.validRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(node, 0, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n\n      if (node.type === 'item' && y > this.validRect.maxY) {\n        y += (this.collection.size - (nodes.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    if (this.isLoading) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width,\n        this.loaderHeight ?? this.virtualizer.visibleRect.height);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      this.layoutInfos.set('loader', loader);\n      nodes.push({layoutInfo: loader});\n      y = loader.rect.maxY;\n    }\n\n    if (nodes.length === 0) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width,\n        this.placeholderHeight ?? this.virtualizer.visibleRect.height);\n      let placeholder = new LayoutInfo('placeholder', 'placeholder', rect);\n      this.layoutInfos.set('placeholder', placeholder);\n      nodes.push({layoutInfo: placeholder});\n      y = placeholder.rect.maxY;\n    }\n\n    this.contentSize = new Size(this.virtualizer.visibleRect.width, y + this.padding);\n    return nodes;\n  }\n\n  isValid(node: Node<T>, y: number) {\n    let cached = this.layoutNodes.get(node.key);\n    return (\n      !this.invalidateEverything &&\n      cached &&\n      cached.node === node &&\n      y === (cached.header || cached.layoutInfo).rect.y &&\n      cached.layoutInfo.rect.intersects(this.lastValidRect) &&\n      cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.validRect))\n    );\n  }\n\n  buildChild(node: Node<T>, x: number, y: number): LayoutNode {\n    if (this.isValid(node, y)) {\n      return this.layoutNodes.get(node.key);\n    }\n\n    let layoutNode = this.buildNode(node, x, y);\n    layoutNode.node = node;\n\n    layoutNode.layoutInfo.parentKey = node.parentKey ?? null;\n    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);\n    if (layoutNode.header) {\n      this.layoutInfos.set(layoutNode.header.key, layoutNode.header);\n    }\n\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  buildNode(node: Node<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n    }\n  }\n\n  buildSection(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode && previousLayoutNode.header) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.header.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;\n      } else {\n        rectHeight = (node.rendered ? this.estimatedHeadingHeight : 0);\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let headerRect = new Rect(0, y, width, rectHeight);\n    let header = new LayoutInfo('header', node.key + ':header', headerRect);\n    header.estimatedSize = isEstimated;\n    header.parentKey = node.key;\n    y += header.rect.height;\n\n    let rect = new Rect(0, y, width, 0);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n\n    let startY = y;\n    let skipped = 0;\n    let children = [];\n    for (let child of getChildNodes(node, this.collection)) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight);\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.validRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(child, x, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n\n      if (y > this.validRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += ([...getChildNodes(node, this.collection)].length - (children.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    rect.height = y - startY;\n\n    return {\n      header,\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect.intersection(this.validRect)\n    };\n  }\n\n  buildItem(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    if (typeof this.indentationForItem === 'function') {\n      x += this.indentationForItem(this.collection, node.key) || 0;\n    }\n\n    let rect = new Rect(x, y, width - x, rectHeight);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    // allow overflow so the focus ring/selection ring can extend outside to overlap with the adjacent items borders\n    layoutInfo.allowOverflow = true;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo,\n      validRect: layoutInfo.rect\n    };\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    let layoutInfo = this.layoutInfos.get(key);\n    // If no layoutInfo, item has been deleted/removed.\n    if (!layoutInfo) {\n      return false;\n    }\n\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      this.layoutInfos.set(key, newLayoutInfo);\n\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n\n      let node = this.collection.getItem(layoutInfo.parentKey);\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = this.collection.getItem(node.parentKey);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  updateLayoutNode(key: Key, oldLayoutInfo: LayoutInfo, newLayoutInfo: LayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by reseting validRect.\n      n.validRect = new Rect();\n\n      // Replace layout info in LayoutNode\n      if (n.header === oldLayoutInfo) {\n        n.header = newLayoutInfo;\n      } else if (n.layoutInfo === oldLayoutInfo) {\n        n.layoutInfo = newLayoutInfo;\n      }\n    }\n  }\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getKeyAbove(key: Key): Key | null {\n    let collection = this.collection;\n\n    key = collection.getKeyBefore(key);\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyBelow(key: Key): Key | null {\n    let collection = this.collection;\n\n    key = collection.getKeyAfter(key);\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyPageAbove(key: Key): Key | null {\n    let layoutInfo = this.getLayoutInfo(key);\n\n    if (layoutInfo) {\n      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);\n      while (layoutInfo && layoutInfo.rect.y > pageY) {\n        let keyAbove = this.getKeyAbove(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyAbove);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getFirstKey();\n  }\n\n  getKeyPageBelow(key: Key): Key | null {\n    let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());\n\n    if (layoutInfo) {\n      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);\n      while (layoutInfo && layoutInfo.rect.y < pageY) {\n        let keyBelow = this.getKeyBelow(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyBelow);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getLastKey();\n  }\n\n  getFirstKey(): Key | null {\n    let collection = this.collection;\n    let key = collection.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey(): Key | null {\n    let collection = this.collection;\n    let key = collection.getLastKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item.key))) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key): Key | null {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n\n  getInitialLayoutInfo(layoutInfo: LayoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n  getFinalLayoutInfo(layoutInfo: LayoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n\n    let key = this.virtualizer.keyAtPoint(new Point(x, y));\n    if (key == null || this.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let layoutInfo = this.getLayoutInfo(key);\n    let rect = layoutInfo.rect;\n    let target: DropTarget = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    } else if (y <= rect.y + 10 && isValidDropTarget({...target, dropPosition: 'before'})) {\n      target.dropPosition = 'before';\n    } else if (y >= rect.maxY - 10 && isValidDropTarget({...target, dropPosition: 'after'})) {\n      target.dropPosition = 'after';\n    }\n\n    return target;\n  }\n}\n"],"names":[],"version":3,"file":"ListLayout.main.js.map"}