import { openDB as p } from "idb";
import { Doc as A, applyUpdate as S, encodeStateAsUpdate as D, diffUpdate as U, encodeStateVectorFromUpdate as B, encodeStateVector as P, UndoManager as M } from "yjs";
import { writeOperation as C, createLazyProvider as V } from "y-provider";
const m = 1, l = "affine-local";
function f(e) {
  e.createObjectStore("workspace", { keyPath: "id" }), e.createObjectStore("milestone", { keyPath: "id" });
}
function E(e, n = "val does not exist") {
  if (e == null)
    throw n instanceof Error ? n : new Error(n);
}
let y;
function g(e) {
  const n = new A();
  return e.forEach((a) => {
    S(n, a);
  }), D(n);
}
async function O(e) {
  return new Promise((n) => {
    const a = indexedDB.open(e);
    let t = !0;
    a.onsuccess = function() {
      a.result.close(), t || indexedDB.deleteDatabase(e), n(t);
    }, a.onupgradeneeded = function() {
      t = !1;
    };
  });
}
async function q(e, n, a = l) {
  do
    if (!y || localStorage.getItem(`${a}-migration`) !== "true") {
      try {
        y = await indexedDB.databases();
      } catch {
        if (await O(n)) {
          await p(n, 1).then(async (t) => {
            if (!t.objectStoreNames.contains("updates"))
              return;
            const r = await t.transaction("updates", "readonly").objectStore("updates").getAll();
            if (!Array.isArray(r) || !r.every((d) => d instanceof Uint8Array))
              return;
            const o = g(r), i = e.transaction("workspace", "readwrite").objectStore("workspace");
            await i.get(n) || (console.log("upgrading the database"), await i.put({
              id: n,
              updates: [
                {
                  timestamp: Date.now(),
                  update: o
                }
              ]
            }));
          });
          break;
        }
      }
      await Promise.all(
        y && y.map((t) => {
          if (t.name && t.version === 1) {
            const c = t.name, r = t.version;
            return p(c, r).then(
              async (o) => {
                if (!o.objectStoreNames.contains("updates"))
                  return;
                const s = await o.transaction("updates", "readonly").objectStore("updates").getAll();
                if (!Array.isArray(s) || !s.every((b) => b instanceof Uint8Array))
                  return;
                const d = g(s), u = e.transaction("workspace", "readwrite").objectStore("workspace");
                await u.get(c) || (console.log("upgrading the database"), await u.put({
                  id: c,
                  updates: [
                    {
                      timestamp: Date.now(),
                      update: d
                    }
                  ]
                }));
              }
            );
          }
        })
      ), localStorage.setItem(`${a}-migration`, "true");
      break;
    }
  while (!1);
}
async function F(e, n = l) {
  const r = await (await p(n, m, {
    upgrade: f
  })).transaction("workspace", "readonly").objectStore("workspace").get(e);
  return r ? g(r.updates.map(({ update: o }) => o)) : !1;
}
async function N(e, n, a = l) {
  await (await p(a, m, {
    upgrade: f
  })).transaction("workspace", "readwrite").objectStore("workspace").put({
    id: e,
    updates: [
      {
        timestamp: Date.now(),
        update: n
      }
    ]
  });
}
async function _(e, n, a = l) {
  const r = (await p(a, m, {
    upgrade: f
  })).transaction("workspace", "readwrite").objectStore("workspace"), o = await r.get(e);
  o ? (o.updates.push({
    timestamp: Date.now(),
    update: n
  }), await r.put(o)) : await r.put({
    id: e,
    updates: [
      {
        timestamp: Date.now(),
        update: n
      }
    ]
  });
}
let v = 500;
function z(e) {
  v = e;
}
const T = ({
  dbName: e = l,
  mergeCount: n
}) => {
  let a = null;
  const t = async () => (a === null && (a = p(e, m, {
    upgrade: f
  })), a);
  return {
    ...{
      queryDocState: async (r, o) => {
        var i;
        try {
          const u = await (await t()).transaction("workspace", "readonly").objectStore("workspace").get(r);
          if (!u)
            return !1;
          const { updates: w } = u, b = g(w.map(({ update: x }) => x));
          return { missing: o != null && o.stateVector ? U(b, o == null ? void 0 : o.stateVector) : b, state: B(b) };
        } catch (s) {
          if (!((i = s.message) != null && i.includes("The database connection is closing.")))
            throw s;
          return !1;
        }
      },
      sendDocUpdate: async (r, o) => {
        var i;
        try {
          const d = (await t()).transaction("workspace", "readwrite").objectStore("workspace"), { updates: u } = await d.get(r) ?? { updates: [] };
          let w = [
            ...u,
            { timestamp: Date.now(), update: o }
          ];
          if (n && w.length >= n) {
            const b = g(w.map(({ update: k }) => k));
            w = [{ timestamp: Date.now(), update: b }];
          }
          await C(
            d.put({
              id: r,
              updates: w
            })
          );
        } catch (s) {
          if (!((i = s.message) != null && i.includes("The database connection is closing.")))
            throw s;
        }
      }
    },
    disconnect: () => {
      t().then((r) => r.close()).then(() => {
        a = null;
      }).catch(console.error);
    },
    cleanup: async () => {
      await (await t()).clear("workspace");
    }
  };
}, W = (e, n = l) => {
  const a = T({ dbName: n, mergeCount: v });
  let t = null;
  const c = {
    get status() {
      return E(t), t.status;
    },
    subscribeStatusChange(r) {
      return E(t), t.subscribeStatusChange(r);
    },
    connect: () => {
      c.connected && c.disconnect(), t = V(e, a, { origin: "idb" }), t.connect();
    },
    disconnect: () => {
      a == null || a.disconnect(), t == null || t.disconnect(), t = null;
    },
    cleanup: async () => {
      await (a == null ? void 0 : a.cleanup());
    },
    get connected() {
      return (t == null ? void 0 : t.connected) || !1;
    },
    datasource: a
  };
  return c;
}, h = "snapshot-origin", j = (e) => (e.preventDefault(), e.returnValue = "Data is not saved. Are you sure you want to leave?"), G = async (e) => {
  window.addEventListener("beforeunload", j, {
    capture: !0
  }), await e, window.removeEventListener("beforeunload", j, {
    capture: !0
  });
};
function H(e, n, a) {
  const t = new A();
  S(t, n, h);
  const c = P(e), r = P(t), o = D(
    e,
    r
  ), i = new M(
    [...t.share.keys()].map((d) => {
      const u = a(d);
      if (u === "Text")
        return t.getText(d);
      if (u === "Map")
        return t.getMap(d);
      if (u === "Array")
        return t.getArray(d);
      throw new Error("Unknown type");
    }),
    {
      trackedOrigins: /* @__PURE__ */ new Set([h])
    }
  );
  S(t, o, h), i.undo();
  const s = D(
    t,
    c
  );
  S(e, s, h);
}
class J extends Error {
  constructor() {
    super("Early disconnect");
  }
}
class K extends Error {
  constructor() {
    super("Cleanup when connecting");
  }
}
const Q = async (e, n, a, t = l) => {
  const o = (await p(t, m, {
    upgrade: f
  })).transaction("milestone", "readwrite").objectStore("milestone"), i = await o.get("id"), s = D(n);
  i ? (i.milestone[a] = s, await o.put(i)) : await o.put({
    id: e,
    milestone: {
      [a]: s
    }
  });
}, R = async (e, n = l) => {
  const r = await (await p(n, m, {
    upgrade: f
  })).transaction("milestone", "readonly").objectStore("milestone").get(e);
  return r ? r.milestone : null;
};
export {
  K as CleanupWhenConnectingError,
  l as DEFAULT_DB_NAME,
  J as EarlyDisconnectError,
  T as createIndexedDBDatasource,
  W as createIndexedDBProvider,
  m as dbVersion,
  F as downloadBinary,
  R as getMilestones,
  Q as markMilestone,
  g as mergeUpdates,
  N as overwriteBinary,
  _ as pushBinary,
  H as revertUpdate,
  z as setMergeCount,
  q as tryMigrate,
  f as upgradeDB,
  G as writeOperation
};
//# sourceMappingURL=index.js.map
