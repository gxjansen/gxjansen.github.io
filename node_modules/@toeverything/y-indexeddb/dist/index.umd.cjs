(function(o,p){typeof exports=="object"&&typeof module<"u"?p(exports,require("idb"),require("yjs"),require("y-provider")):typeof define=="function"&&define.amd?define(["exports","idb","yjs","y-provider"],p):(o=typeof globalThis<"u"?globalThis:o||self,p(o.ToEverythingIndexedDBProvider={},o.idb,o.yjs,o.yProvider))})(this,function(o,p,d,S){"use strict";const f="affine-local";function b(t){t.createObjectStore("workspace",{keyPath:"id"}),t.createObjectStore("milestone",{keyPath:"id"})}function k(t,a="val does not exist"){if(t==null)throw a instanceof Error?a:new Error(a)}let h;function y(t){const a=new d.Doc;return t.forEach(n=>{d.applyUpdate(a,n)}),d.encodeStateAsUpdate(a)}async function A(t){return new Promise(a=>{const n=indexedDB.open(t);let e=!0;n.onsuccess=function(){n.result.close(),e||indexedDB.deleteDatabase(t),a(e)},n.onupgradeneeded=function(){e=!1}})}async function P(t,a,n=f){do if(!h||localStorage.getItem(`${n}-migration`)!=="true"){try{h=await indexedDB.databases()}catch{if(await A(a)){await p.openDB(a,1).then(async e=>{if(!e.objectStoreNames.contains("updates"))return;const r=await e.transaction("updates","readonly").objectStore("updates").getAll();if(!Array.isArray(r)||!r.every(l=>l instanceof Uint8Array))return;const s=y(r),u=t.transaction("workspace","readwrite").objectStore("workspace");await u.get(a)||(console.log("upgrading the database"),await u.put({id:a,updates:[{timestamp:Date.now(),update:s}]}))});break}}await Promise.all(h&&h.map(e=>{if(e.name&&e.version===1){const i=e.name,r=e.version;return p.openDB(i,r).then(async s=>{if(!s.objectStoreNames.contains("updates"))return;const c=await s.transaction("updates","readonly").objectStore("updates").getAll();if(!Array.isArray(c)||!c.every(m=>m instanceof Uint8Array))return;const l=y(c),w=t.transaction("workspace","readwrite").objectStore("workspace");await w.get(i)||(console.log("upgrading the database"),await w.put({id:i,updates:[{timestamp:Date.now(),update:l}]}))})}})),localStorage.setItem(`${n}-migration`,"true");break}while(!1)}async function V(t,a=f){const r=await(await p.openDB(a,1,{upgrade:b})).transaction("workspace","readonly").objectStore("workspace").get(t);return r?y(r.updates.map(({update:s})=>s)):!1}async function M(t,a,n=f){await(await p.openDB(n,1,{upgrade:b})).transaction("workspace","readwrite").objectStore("workspace").put({id:t,updates:[{timestamp:Date.now(),update:a}]})}async function T(t,a,n=f){const r=(await p.openDB(n,1,{upgrade:b})).transaction("workspace","readwrite").objectStore("workspace"),s=await r.get(t);s?(s.updates.push({timestamp:Date.now(),update:a}),await r.put(s)):await r.put({id:t,updates:[{timestamp:Date.now(),update:a}]})}let B=500;function C(t){B=t}const U=({dbName:t=f,mergeCount:a})=>{let n=null;const e=async()=>(n===null&&(n=p.openDB(t,1,{upgrade:b})),n);return{...{queryDocState:async(r,s)=>{var u;try{const w=await(await e()).transaction("workspace","readonly").objectStore("workspace").get(r);if(!w)return!1;const{updates:g}=w,m=y(g.map(({update:N})=>N));return{missing:s!=null&&s.stateVector?d.diffUpdate(m,s==null?void 0:s.stateVector):m,state:d.encodeStateVectorFromUpdate(m)}}catch(c){if(!((u=c.message)!=null&&u.includes("The database connection is closing.")))throw c;return!1}},sendDocUpdate:async(r,s)=>{var u;try{const l=(await e()).transaction("workspace","readwrite").objectStore("workspace"),{updates:w}=await l.get(r)??{updates:[]};let g=[...w,{timestamp:Date.now(),update:s}];if(a&&g.length>=a){const m=y(g.map(({update:E})=>E));g=[{timestamp:Date.now(),update:m}]}await S.writeOperation(l.put({id:r,updates:g}))}catch(c){if(!((u=c.message)!=null&&u.includes("The database connection is closing.")))throw c}}},disconnect:()=>{e().then(r=>r.close()).then(()=>{n=null}).catch(console.error)},cleanup:async()=>{await(await e()).clear("workspace")}}},O=(t,a=f)=>{const n=U({dbName:a,mergeCount:B});let e=null;const i={get status(){return k(e),e.status},subscribeStatusChange(r){return k(e),e.subscribeStatusChange(r)},connect:()=>{i.connected&&i.disconnect(),e=S.createLazyProvider(t,n,{origin:"idb"}),e.connect()},disconnect:()=>{n==null||n.disconnect(),e==null||e.disconnect(),e=null},cleanup:async()=>{await(n==null?void 0:n.cleanup())},get connected(){return(e==null?void 0:e.connected)||!1},datasource:n};return i},D="snapshot-origin",v=t=>(t.preventDefault(),t.returnValue="Data is not saved. Are you sure you want to leave?"),I=async t=>{window.addEventListener("beforeunload",v,{capture:!0}),await t,window.removeEventListener("beforeunload",v,{capture:!0})};function j(t,a,n){const e=new d.Doc;d.applyUpdate(e,a,D);const i=d.encodeStateVector(t),r=d.encodeStateVector(e),s=d.encodeStateAsUpdate(t,r),u=new d.UndoManager([...e.share.keys()].map(l=>{const w=n(l);if(w==="Text")return e.getText(l);if(w==="Map")return e.getMap(l);if(w==="Array")return e.getArray(l);throw new Error("Unknown type")}),{trackedOrigins:new Set([D])});d.applyUpdate(e,s,D),u.undo();const c=d.encodeStateAsUpdate(e,i);d.applyUpdate(t,c,D)}class q extends Error{constructor(){super("Early disconnect")}}class L extends Error{constructor(){super("Cleanup when connecting")}}const _=async(t,a,n,e=f)=>{const s=(await p.openDB(e,1,{upgrade:b})).transaction("milestone","readwrite").objectStore("milestone"),u=await s.get("id"),c=d.encodeStateAsUpdate(a);u?(u.milestone[n]=c,await s.put(u)):await s.put({id:t,milestone:{[n]:c}})},F=async(t,a=f)=>{const r=await(await p.openDB(a,1,{upgrade:b})).transaction("milestone","readonly").objectStore("milestone").get(t);return r?r.milestone:null};o.CleanupWhenConnectingError=L,o.DEFAULT_DB_NAME=f,o.EarlyDisconnectError=q,o.createIndexedDBDatasource=U,o.createIndexedDBProvider=O,o.dbVersion=1,o.downloadBinary=V,o.getMilestones=F,o.markMilestone=_,o.mergeUpdates=y,o.overwriteBinary=M,o.pushBinary=T,o.revertUpdate=j,o.setMergeCount=C,o.tryMigrate=P,o.upgradeDB=b,o.writeOperation=I,Object.defineProperty(o,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=index.umd.cjs.map
