{"version":3,"file":"index.js","sources":["../src/shared.ts","../../../../node_modules/@blocksuite/global/dist/utils/assert.js","../src/utils.ts","../src/provider.ts","../src/index.ts"],"sourcesContent":["import type { DBSchema, IDBPDatabase } from 'idb';\nimport type { DataSourceAdapter } from 'y-provider';\n\nexport const dbVersion = 1;\nexport const DEFAULT_DB_NAME = 'affine-local';\n\nexport function upgradeDB(db: IDBPDatabase<BlockSuiteBinaryDB>) {\n  db.createObjectStore('workspace', { keyPath: 'id' });\n  db.createObjectStore('milestone', { keyPath: 'id' });\n}\n\nexport interface IndexedDBProvider extends DataSourceAdapter {\n  connect: () => void;\n  disconnect: () => void;\n  cleanup: () => Promise<void>;\n  readonly connected: boolean;\n}\n\nexport type UpdateMessage = {\n  timestamp: number;\n  update: Uint8Array;\n};\n\nexport type WorkspacePersist = {\n  id: string;\n  updates: UpdateMessage[];\n};\n\nexport type WorkspaceMilestone = {\n  id: string;\n  milestone: Record<string, Uint8Array>;\n};\n\nexport interface BlockSuiteBinaryDB extends DBSchema {\n  workspace: {\n    key: string;\n    value: WorkspacePersist;\n  };\n  milestone: {\n    key: string;\n    value: WorkspaceMilestone;\n  };\n}\n\nexport interface OldYjsDB extends DBSchema {\n  updates: {\n    key: number;\n    value: Uint8Array;\n  };\n}\n","// https://stackoverflow.com/questions/31538010/test-if-a-variable-is-a-primitive-rather-than-an-object\nexport function isPrimitive(a) {\n    return a !== Object(a);\n}\nexport function assertExists(val, message = 'val does not exist') {\n    if (val === null || val === undefined) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw new Error(message);\n    }\n}\nexport function assertNotExists(val, message = 'val exists') {\n    if (val !== null && val !== undefined) {\n        throw new Error(message);\n    }\n}\nexport function isEqual(val, expected) {\n    const a = isPrimitive(val);\n    const b = isPrimitive(expected);\n    if (a && b) {\n        if (!Object.is(val, expected)) {\n            return false;\n        }\n    }\n    else if (a !== b) {\n        return false;\n    }\n    else {\n        if (Array.isArray(val) && Array.isArray(expected)) {\n            if (val.length !== expected.length) {\n                return false;\n            }\n            return val.every((x, i) => isEqual(x, expected[i]));\n        }\n        else if (typeof val === 'object' && typeof expected === 'object') {\n            const obj1 = Object.entries(val);\n            const obj2 = Object.entries(expected);\n            if (obj1.length !== obj2.length) {\n                return false;\n            }\n            return obj1.every((x, i) => isEqual(x, obj2[i]));\n        }\n    }\n    return true;\n}\nexport function assertEquals(val, expected, message = 'val is not same as expected') {\n    if (!isEqual(val, expected)) {\n        throw new Error(message);\n    }\n}\nexport function assertInstanceOf(val, expected, message = 'val is not instance of expected') {\n    if (!(val instanceof expected)) {\n        throw new Error(message);\n    }\n}\n//# sourceMappingURL=assert.js.map","import type { IDBPDatabase } from 'idb';\nimport { openDB } from 'idb';\nimport { applyUpdate, Doc, encodeStateAsUpdate } from 'yjs';\n\nimport type { BlockSuiteBinaryDB, OldYjsDB, UpdateMessage } from './shared';\nimport { dbVersion, DEFAULT_DB_NAME, upgradeDB } from './shared';\n\nlet allDb: IDBDatabaseInfo[];\n\nexport function mergeUpdates(updates: Uint8Array[]) {\n  const doc = new Doc();\n  updates.forEach(update => {\n    applyUpdate(doc, update);\n  });\n  return encodeStateAsUpdate(doc);\n}\n\nasync function databaseExists(name: string): Promise<boolean> {\n  return new Promise(resolve => {\n    const req = indexedDB.open(name);\n    let existed = true;\n    req.onsuccess = function () {\n      req.result.close();\n      if (!existed) {\n        indexedDB.deleteDatabase(name);\n      }\n      resolve(existed);\n    };\n    req.onupgradeneeded = function () {\n      existed = false;\n    };\n  });\n}\n\n/**\n * try to migrate the old database to the new database\n * this function will be removed in the future\n * since we don't need to support the old database\n */\nexport async function tryMigrate(\n  db: IDBPDatabase<BlockSuiteBinaryDB>,\n  id: string,\n  dbName = DEFAULT_DB_NAME\n) {\n  do {\n    if (!allDb || localStorage.getItem(`${dbName}-migration`) !== 'true') {\n      try {\n        allDb = await indexedDB.databases();\n      } catch {\n        // in firefox, `indexedDB.databases` is not existed\n        if (await databaseExists(id)) {\n          await openDB<IDBPDatabase<OldYjsDB>>(id, 1).then(async oldDB => {\n            if (!oldDB.objectStoreNames.contains('updates')) {\n              return;\n            }\n            const t = oldDB\n              .transaction('updates', 'readonly')\n              .objectStore('updates');\n            const updates = await t.getAll();\n            if (\n              !Array.isArray(updates) ||\n              !updates.every(update => update instanceof Uint8Array)\n            ) {\n              return;\n            }\n            const update = mergeUpdates(updates);\n            const workspaceTransaction = db\n              .transaction('workspace', 'readwrite')\n              .objectStore('workspace');\n            const data = await workspaceTransaction.get(id);\n            if (!data) {\n              console.log('upgrading the database');\n              await workspaceTransaction.put({\n                id,\n                updates: [\n                  {\n                    timestamp: Date.now(),\n                    update,\n                  },\n                ],\n              });\n            }\n          });\n          break;\n        }\n      }\n      // run the migration\n      await Promise.all(\n        allDb &&\n          allDb.map(meta => {\n            if (meta.name && meta.version === 1) {\n              const name = meta.name;\n              const version = meta.version;\n              return openDB<IDBPDatabase<OldYjsDB>>(name, version).then(\n                async oldDB => {\n                  if (!oldDB.objectStoreNames.contains('updates')) {\n                    return;\n                  }\n                  const t = oldDB\n                    .transaction('updates', 'readonly')\n                    .objectStore('updates');\n                  const updates = await t.getAll();\n                  if (\n                    !Array.isArray(updates) ||\n                    !updates.every(update => update instanceof Uint8Array)\n                  ) {\n                    return;\n                  }\n                  const update = mergeUpdates(updates);\n                  const workspaceTransaction = db\n                    .transaction('workspace', 'readwrite')\n                    .objectStore('workspace');\n                  const data = await workspaceTransaction.get(name);\n                  if (!data) {\n                    console.log('upgrading the database');\n                    await workspaceTransaction.put({\n                      id: name,\n                      updates: [\n                        {\n                          timestamp: Date.now(),\n                          update,\n                        },\n                      ],\n                    });\n                  }\n                }\n              );\n            }\n            return void 0;\n          })\n      );\n      localStorage.setItem(`${dbName}-migration`, 'true');\n      break;\n    }\n    // eslint-disable-next-line no-constant-condition\n  } while (false);\n}\n\nexport async function downloadBinary(\n  guid: string,\n  dbName = DEFAULT_DB_NAME\n): Promise<UpdateMessage['update'] | false> {\n  const dbPromise = openDB<BlockSuiteBinaryDB>(dbName, dbVersion, {\n    upgrade: upgradeDB,\n  });\n  const db = await dbPromise;\n  const t = db.transaction('workspace', 'readonly').objectStore('workspace');\n  const doc = await t.get(guid);\n  if (!doc) {\n    return false;\n  } else {\n    return mergeUpdates(doc.updates.map(({ update }) => update));\n  }\n}\n\nexport async function overwriteBinary(\n  guid: string,\n  update: UpdateMessage['update'],\n  dbName = DEFAULT_DB_NAME\n) {\n  const dbPromise = openDB<BlockSuiteBinaryDB>(dbName, dbVersion, {\n    upgrade: upgradeDB,\n  });\n  const db = await dbPromise;\n  const t = db.transaction('workspace', 'readwrite').objectStore('workspace');\n  await t.put({\n    id: guid,\n    updates: [\n      {\n        timestamp: Date.now(),\n        update,\n      },\n    ],\n  });\n}\n\nexport async function pushBinary(\n  guid: string,\n  update: UpdateMessage['update'],\n  dbName = DEFAULT_DB_NAME\n) {\n  const dbPromise = openDB<BlockSuiteBinaryDB>(dbName, dbVersion, {\n    upgrade: upgradeDB,\n  });\n  const db = await dbPromise;\n  const t = db.transaction('workspace', 'readwrite').objectStore('workspace');\n  const doc = await t.get(guid);\n  if (!doc) {\n    await t.put({\n      id: guid,\n      updates: [\n        {\n          timestamp: Date.now(),\n          update,\n        },\n      ],\n    });\n  } else {\n    doc.updates.push({\n      timestamp: Date.now(),\n      update,\n    });\n    await t.put(doc);\n  }\n}\n","import { assertExists } from '@blocksuite/global/utils';\nimport type { IDBPDatabase } from 'idb';\nimport { openDB } from 'idb';\nimport {\n  createLazyProvider,\n  type DocDataSource,\n  writeOperation,\n} from 'y-provider';\nimport type { Doc } from 'yjs';\nimport { diffUpdate, encodeStateVectorFromUpdate } from 'yjs';\n\nimport {\n  type BlockSuiteBinaryDB,\n  dbVersion,\n  DEFAULT_DB_NAME,\n  type IndexedDBProvider,\n  type UpdateMessage,\n  upgradeDB,\n} from './shared';\nimport { mergeUpdates } from './utils';\n\nlet mergeCount = 500;\n\nexport function setMergeCount(count: number) {\n  mergeCount = count;\n}\n\nexport const createIndexedDBDatasource = ({\n  dbName = DEFAULT_DB_NAME,\n  mergeCount,\n}: {\n  dbName?: string;\n  mergeCount?: number;\n}) => {\n  let dbPromise: Promise<IDBPDatabase<BlockSuiteBinaryDB>> | null = null;\n  const getDb = async () => {\n    if (dbPromise === null) {\n      dbPromise = openDB<BlockSuiteBinaryDB>(dbName, dbVersion, {\n        upgrade: upgradeDB,\n      });\n    }\n    return dbPromise;\n  };\n\n  const adapter = {\n    queryDocState: async (guid, options) => {\n      try {\n        const db = await getDb();\n        const store = db\n          .transaction('workspace', 'readonly')\n          .objectStore('workspace');\n        const data = await store.get(guid);\n\n        if (!data) {\n          return false;\n        }\n\n        const { updates } = data;\n        const update = mergeUpdates(updates.map(({ update }) => update));\n\n        const missing = options?.stateVector\n          ? diffUpdate(update, options?.stateVector)\n          : update;\n\n        return { missing, state: encodeStateVectorFromUpdate(update) };\n      } catch (err: any) {\n        if (!err.message?.includes('The database connection is closing.')) {\n          throw err;\n        }\n        return false;\n      }\n    },\n    sendDocUpdate: async (guid, update) => {\n      try {\n        const db = await getDb();\n        const store = db\n          .transaction('workspace', 'readwrite')\n          .objectStore('workspace');\n\n        // TODO: maybe we do not need to get data every time\n        const { updates } = (await store.get(guid)) ?? { updates: [] };\n        let rows: UpdateMessage[] = [\n          ...updates,\n          { timestamp: Date.now(), update },\n        ];\n        if (mergeCount && rows.length >= mergeCount) {\n          const merged = mergeUpdates(rows.map(({ update }) => update));\n          rows = [{ timestamp: Date.now(), update: merged }];\n        }\n        await writeOperation(\n          store.put({\n            id: guid,\n            updates: rows,\n          })\n        );\n      } catch (err: any) {\n        if (!err.message?.includes('The database connection is closing.')) {\n          throw err;\n        }\n      }\n    },\n  } satisfies DocDataSource;\n\n  return {\n    ...adapter,\n    disconnect: () => {\n      getDb()\n        .then(db => db.close())\n        .then(() => {\n          dbPromise = null;\n        })\n        .catch(console.error);\n    },\n    cleanup: async () => {\n      const db = await getDb();\n      await db.clear('workspace');\n    },\n  };\n};\n\n/**\n * We use `doc.guid` as the unique key, please make sure it not changes.\n */\nexport const createIndexedDBProvider = (\n  doc: Doc,\n  dbName: string = DEFAULT_DB_NAME\n): IndexedDBProvider => {\n  const datasource = createIndexedDBDatasource({ dbName, mergeCount });\n  let provider: ReturnType<typeof createLazyProvider> | null = null;\n\n  const apis = {\n    get status() {\n      assertExists(provider);\n      return provider.status;\n    },\n    subscribeStatusChange(onStatusChange) {\n      assertExists(provider);\n      return provider.subscribeStatusChange(onStatusChange);\n    },\n    connect: () => {\n      if (apis.connected) {\n        apis.disconnect();\n      }\n      provider = createLazyProvider(doc, datasource, { origin: 'idb' });\n      provider.connect();\n    },\n    disconnect: () => {\n      datasource?.disconnect();\n      provider?.disconnect();\n      provider = null;\n    },\n    cleanup: async () => {\n      await datasource?.cleanup();\n    },\n    get connected() {\n      return provider?.connected || false;\n    },\n    datasource,\n  } satisfies IndexedDBProvider;\n\n  return apis;\n};\n","import { openDB } from 'idb';\nimport {\n  applyUpdate,\n  Doc,\n  encodeStateAsUpdate,\n  encodeStateVector,\n  UndoManager,\n} from 'yjs';\n\nimport type { BlockSuiteBinaryDB, WorkspaceMilestone } from './shared';\nimport { dbVersion, DEFAULT_DB_NAME, upgradeDB } from './shared';\n\nconst snapshotOrigin = 'snapshot-origin';\n\n/**\n * @internal\n */\nconst saveAlert = (event: BeforeUnloadEvent) => {\n  event.preventDefault();\n  return (event.returnValue =\n    'Data is not saved. Are you sure you want to leave?');\n};\n\nexport const writeOperation = async (op: Promise<unknown>) => {\n  window.addEventListener('beforeunload', saveAlert, {\n    capture: true,\n  });\n  await op;\n  window.removeEventListener('beforeunload', saveAlert, {\n    capture: true,\n  });\n};\n\nexport function revertUpdate(\n  doc: Doc,\n  snapshotUpdate: Uint8Array,\n  getMetadata: (key: string) => 'Text' | 'Map' | 'Array'\n) {\n  const snapshotDoc = new Doc();\n  applyUpdate(snapshotDoc, snapshotUpdate, snapshotOrigin);\n\n  const currentStateVector = encodeStateVector(doc);\n  const snapshotStateVector = encodeStateVector(snapshotDoc);\n\n  const changesSinceSnapshotUpdate = encodeStateAsUpdate(\n    doc,\n    snapshotStateVector\n  );\n  const undoManager = new UndoManager(\n    [...snapshotDoc.share.keys()].map(key => {\n      const type = getMetadata(key);\n      if (type === 'Text') {\n        return snapshotDoc.getText(key);\n      } else if (type === 'Map') {\n        return snapshotDoc.getMap(key);\n      } else if (type === 'Array') {\n        return snapshotDoc.getArray(key);\n      }\n      throw new Error('Unknown type');\n    }),\n    {\n      trackedOrigins: new Set([snapshotOrigin]),\n    }\n  );\n  applyUpdate(snapshotDoc, changesSinceSnapshotUpdate, snapshotOrigin);\n  undoManager.undo();\n  const revertChangesSinceSnapshotUpdate = encodeStateAsUpdate(\n    snapshotDoc,\n    currentStateVector\n  );\n  applyUpdate(doc, revertChangesSinceSnapshotUpdate, snapshotOrigin);\n}\n\nexport class EarlyDisconnectError extends Error {\n  constructor() {\n    super('Early disconnect');\n  }\n}\n\nexport class CleanupWhenConnectingError extends Error {\n  constructor() {\n    super('Cleanup when connecting');\n  }\n}\n\nexport const markMilestone = async (\n  id: string,\n  doc: Doc,\n  name: string,\n  dbName = DEFAULT_DB_NAME\n): Promise<void> => {\n  const dbPromise = openDB<BlockSuiteBinaryDB>(dbName, dbVersion, {\n    upgrade: upgradeDB,\n  });\n  const db = await dbPromise;\n  const store = db\n    .transaction('milestone', 'readwrite')\n    .objectStore('milestone');\n  const milestone = await store.get('id');\n  const binary = encodeStateAsUpdate(doc);\n  if (!milestone) {\n    await store.put({\n      id,\n      milestone: {\n        [name]: binary,\n      },\n    });\n  } else {\n    milestone.milestone[name] = binary;\n    await store.put(milestone);\n  }\n};\n\nexport const getMilestones = async (\n  id: string,\n  dbName: string = DEFAULT_DB_NAME\n): Promise<null | WorkspaceMilestone['milestone']> => {\n  const dbPromise = openDB<BlockSuiteBinaryDB>(dbName, dbVersion, {\n    upgrade: upgradeDB,\n  });\n  const db = await dbPromise;\n  const store = db\n    .transaction('milestone', 'readonly')\n    .objectStore('milestone');\n  const milestone = await store.get(id);\n  if (!milestone) {\n    return null;\n  }\n  return milestone.milestone;\n};\n\nexport * from './provider';\nexport * from './shared';\nexport * from './utils';\n"],"names":["dbVersion","DEFAULT_DB_NAME","upgradeDB","db","assertExists","val","message","allDb","mergeUpdates","updates","doc","Doc","update","applyUpdate","encodeStateAsUpdate","databaseExists","name","resolve","req","existed","tryMigrate","id","dbName","openDB","oldDB","workspaceTransaction","meta","version","downloadBinary","guid","overwriteBinary","pushBinary","t","mergeCount","setMergeCount","count","createIndexedDBDatasource","dbPromise","getDb","options","data","diffUpdate","encodeStateVectorFromUpdate","err","_a","store","rows","merged","writeOperation","createIndexedDBProvider","datasource","provider","apis","onStatusChange","createLazyProvider","snapshotOrigin","saveAlert","event","op","revertUpdate","snapshotUpdate","getMetadata","snapshotDoc","currentStateVector","encodeStateVector","snapshotStateVector","changesSinceSnapshotUpdate","undoManager","UndoManager","key","type","revertChangesSinceSnapshotUpdate","EarlyDisconnectError","CleanupWhenConnectingError","markMilestone","milestone","binary","getMilestones"],"mappings":"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","x_google_ignoreList":[1]}