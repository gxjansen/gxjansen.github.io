"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const w=require("idb"),d=require("yjs"),U=require("y-provider"),y=1,l="affine-local";function f(t){t.createObjectStore("workspace",{keyPath:"id"}),t.createObjectStore("milestone",{keyPath:"id"})}function k(t,n="val does not exist"){if(t==null)throw n instanceof Error?n:new Error(n)}let D;function m(t){const n=new d.Doc;return t.forEach(a=>{d.applyUpdate(n,a)}),d.encodeStateAsUpdate(n)}async function v(t){return new Promise(n=>{const a=indexedDB.open(t);let e=!0;a.onsuccess=function(){a.result.close(),e||indexedDB.deleteDatabase(t),n(e)},a.onupgradeneeded=function(){e=!1}})}async function j(t,n,a=l){do if(!D||localStorage.getItem(`${a}-migration`)!=="true"){try{D=await indexedDB.databases()}catch{if(await v(n)){await w.openDB(n,1).then(async e=>{if(!e.objectStoreNames.contains("updates"))return;const r=await e.transaction("updates","readonly").objectStore("updates").getAll();if(!Array.isArray(r)||!r.every(u=>u instanceof Uint8Array))return;const o=m(r),i=t.transaction("workspace","readwrite").objectStore("workspace");await i.get(n)||(console.log("upgrading the database"),await i.put({id:n,updates:[{timestamp:Date.now(),update:o}]}))});break}}await Promise.all(D&&D.map(e=>{if(e.name&&e.version===1){const c=e.name,r=e.version;return w.openDB(c,r).then(async o=>{if(!o.objectStoreNames.contains("updates"))return;const s=await o.transaction("updates","readonly").objectStore("updates").getAll();if(!Array.isArray(s)||!s.every(b=>b instanceof Uint8Array))return;const u=m(s),p=t.transaction("workspace","readwrite").objectStore("workspace");await p.get(c)||(console.log("upgrading the database"),await p.put({id:c,updates:[{timestamp:Date.now(),update:u}]}))})}})),localStorage.setItem(`${a}-migration`,"true");break}while(!1)}async function x(t,n=l){const r=await(await w.openDB(n,y,{upgrade:f})).transaction("workspace","readonly").objectStore("workspace").get(t);return r?m(r.updates.map(({update:o})=>o)):!1}async function M(t,n,a=l){await(await w.openDB(a,y,{upgrade:f})).transaction("workspace","readwrite").objectStore("workspace").put({id:t,updates:[{timestamp:Date.now(),update:n}]})}async function C(t,n,a=l){const r=(await w.openDB(a,y,{upgrade:f})).transaction("workspace","readwrite").objectStore("workspace"),o=await r.get(t);o?(o.updates.push({timestamp:Date.now(),update:n}),await r.put(o)):await r.put({id:t,updates:[{timestamp:Date.now(),update:n}]})}let E=500;function V(t){E=t}const A=({dbName:t=l,mergeCount:n})=>{let a=null;const e=async()=>(a===null&&(a=w.openDB(t,y,{upgrade:f})),a);return{...{queryDocState:async(r,o)=>{var i;try{const p=await(await e()).transaction("workspace","readonly").objectStore("workspace").get(r);if(!p)return!1;const{updates:g}=p,b=m(g.map(({update:P})=>P));return{missing:o!=null&&o.stateVector?d.diffUpdate(b,o==null?void 0:o.stateVector):b,state:d.encodeStateVectorFromUpdate(b)}}catch(s){if(!((i=s.message)!=null&&i.includes("The database connection is closing.")))throw s;return!1}},sendDocUpdate:async(r,o)=>{var i;try{const u=(await e()).transaction("workspace","readwrite").objectStore("workspace"),{updates:p}=await u.get(r)??{updates:[]};let g=[...p,{timestamp:Date.now(),update:o}];if(n&&g.length>=n){const b=m(g.map(({update:S})=>S));g=[{timestamp:Date.now(),update:b}]}await U.writeOperation(u.put({id:r,updates:g}))}catch(s){if(!((i=s.message)!=null&&i.includes("The database connection is closing.")))throw s}}},disconnect:()=>{e().then(r=>r.close()).then(()=>{a=null}).catch(console.error)},cleanup:async()=>{await(await e()).clear("workspace")}}},T=(t,n=l)=>{const a=A({dbName:n,mergeCount:E});let e=null;const c={get status(){return k(e),e.status},subscribeStatusChange(r){return k(e),e.subscribeStatusChange(r)},connect:()=>{c.connected&&c.disconnect(),e=U.createLazyProvider(t,a,{origin:"idb"}),e.connect()},disconnect:()=>{a==null||a.disconnect(),e==null||e.disconnect(),e=null},cleanup:async()=>{await(a==null?void 0:a.cleanup())},get connected(){return(e==null?void 0:e.connected)||!1},datasource:a};return c},h="snapshot-origin",B=t=>(t.preventDefault(),t.returnValue="Data is not saved. Are you sure you want to leave?"),O=async t=>{window.addEventListener("beforeunload",B,{capture:!0}),await t,window.removeEventListener("beforeunload",B,{capture:!0})};function I(t,n,a){const e=new d.Doc;d.applyUpdate(e,n,h);const c=d.encodeStateVector(t),r=d.encodeStateVector(e),o=d.encodeStateAsUpdate(t,r),i=new d.UndoManager([...e.share.keys()].map(u=>{const p=a(u);if(p==="Text")return e.getText(u);if(p==="Map")return e.getMap(u);if(p==="Array")return e.getArray(u);throw new Error("Unknown type")}),{trackedOrigins:new Set([h])});d.applyUpdate(e,o,h),i.undo();const s=d.encodeStateAsUpdate(e,c);d.applyUpdate(t,s,h)}class q extends Error{constructor(){super("Early disconnect")}}class L extends Error{constructor(){super("Cleanup when connecting")}}const _=async(t,n,a,e=l)=>{const o=(await w.openDB(e,y,{upgrade:f})).transaction("milestone","readwrite").objectStore("milestone"),i=await o.get("id"),s=d.encodeStateAsUpdate(n);i?(i.milestone[a]=s,await o.put(i)):await o.put({id:t,milestone:{[a]:s}})},F=async(t,n=l)=>{const r=await(await w.openDB(n,y,{upgrade:f})).transaction("milestone","readonly").objectStore("milestone").get(t);return r?r.milestone:null};exports.CleanupWhenConnectingError=L;exports.DEFAULT_DB_NAME=l;exports.EarlyDisconnectError=q;exports.createIndexedDBDatasource=A;exports.createIndexedDBProvider=T;exports.dbVersion=y;exports.downloadBinary=x;exports.getMilestones=F;exports.markMilestone=_;exports.mergeUpdates=m;exports.overwriteBinary=M;exports.pushBinary=C;exports.revertUpdate=I;exports.setMergeCount=V;exports.tryMigrate=j;exports.upgradeDB=f;exports.writeOperation=O;
//# sourceMappingURL=index.cjs.map
