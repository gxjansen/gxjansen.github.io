import {
  $18f2051aff69b9bf$export$43bb16f9c6d9e3f7,
  $1dbecbe27a04f9af$export$14d238f342723f25,
  $298d61e98472621b$export$dcf14c9974fe2767,
  $2baaea4c71418dea$export$294aa081a6c6f55d,
  $2d73ec29415bd339$export$712718f7aec83d5,
  $2f04cbc44ee30ce0$export$53a0910f038337bd,
  $2f04cbc44ee30ce0$export$c826860796309d1b,
  $3017fa7ffdddec74$export$8042c6c013fd5226,
  $313b98861ee5dd6c$export$d6875122194c7b44,
  $319e236875307eab$export$a9b970dcc4ae71a9,
  $325a3faab7a68acd$export$a16aca283550c30d,
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $40df3f8667284809$export$d55e7ee900f34e93,
  $458b0a5536c1a7cf$export$40bfa8c7b0832715,
  $46d819fcbaf35654$export$8f71654801c2f7cd,
  $4f58c5f72bcf79f7$export$496315a1608d9602,
  $507fabe10e71c6fb$export$630ff653c5ada6a9,
  $507fabe10e71c6fb$export$8397ddfc504fdb9a,
  $507fabe10e71c6fb$export$98e20ec92f614cfe,
  $507fabe10e71c6fb$export$b9b3dfddab17db27,
  $5c3e21d68f1c4674$export$a966af930f325cab,
  $5e3802645cc19319$export$1c3ebcada18427bf,
  $6179b936705e76d3$export$ae780daf29e6d456,
  $628037886ba31236$export$f9d5c8beee7d008d,
  $62d8ded9296f3872$export$cfa2225e87938781,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f,
  $6a99195332edec8b$export$80f3e147d781571c,
  $701a24aa0da5b062$export$ea18c227d4417cc3,
  $7215afc6de606d6b$export$de79e2c695e052f3,
  $83013635b024ae3d$export$eac1895992b9f3d6,
  $86ea4cb521eb2e37$export$2317d149ed6f78c4,
  $8a26561d2877236e$export$c24ed0104d07eab9,
  $8ac8429251c45e4b$export$dbc0f175b25fb0fb,
  $8ae05eaa5c114e9c$export$7f54fc3180508a52,
  $9446cca9a3875146$export$7d15b64cf5a3a4c4,
  $99facab73266f662$export$5add1d006293d136,
  $9ab94262bd0047c7$export$420e68273165f4ec,
  $9bf71ea28793e738$export$20e40289641fbbb6,
  $9bf71ea28793e738$export$2d6ec8fc375ceafa,
  $9bf71ea28793e738$export$c5251b9e124bf29,
  $9daab02d461809db$export$683480f191c0e3ea,
  $a1ea59d68270f0dd$export$f8168d8dd8fd66e6,
  $bb77f239b46e8c72$export$3274cf84b703fff,
  $bdb11010cef70236$export$b4cc09c592e8fdb8,
  $bdb11010cef70236$export$f680877a34711e37,
  $c87311424ea30a05$export$78551043582a6a98,
  $c87311424ea30a05$export$9ac100e40613ea10,
  $c87311424ea30a05$export$e1865c3bedcd822b,
  $cc38e7bd3fc7b213$export$2bb74740c4e19def,
  $d191a55c9702f145$export$8467354a121f1b9f,
  $df56164dff5785e2$export$4338b53315abf666,
  $e5be200c675c3b3a$export$75ee7c75d68f5b0e,
  $e5be200c675c3b3a$export$a763b9476acd3eb,
  $e5be200c675c3b3a$export$dad6ae84456c676a,
  $e5be200c675c3b3a$export$fc1a364ae1f3ff10,
  $e6afbd83fe6ebbd2$export$4c014de7c8940b4c,
  $e7801be82b4b2a53$export$4debdb1a3f0fa79e,
  $e93e671b31057976$export$b8473d3665f3a75a,
  $e9faafb641e167db$export$90fc3a17d93f704c,
  $ea8dcbcb9ea1b556$export$51437d503373d223,
  $ea8dcbcb9ea1b556$export$7e924b3091a3bd18,
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7,
  $ea8dcbcb9ea1b556$export$9a302a45f65d0572,
  $ef06256079686ba0$export$f8aeda7b10753fa1,
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c,
  $f1ab8c75478c6f73$export$3351871ee4b288b8,
  $f4b273590fab9f93$export$52210f68a14655d0,
  $f6c31cce2adf654f$export$45712eceda6fad21,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  $fc909762b330b746$export$61c6a8c84e605fb6,
  $fca6afa0e843324b$export$f12b703ca79dfbb1,
  $ff5963eb1fccf552$export$e08e3b67e392101e,
  ActionButton,
  ActiveBlockPopoverProvider,
  AddToPathProvider,
  AlertDialog,
  Avatar,
  Blanket,
  BlockPopover,
  BlockPopoverTrigger,
  Box,
  BranchInfoContext,
  Button,
  ButtonGroup,
  ClassList,
  ClearButton,
  ClearSlots,
  Content,
  ContentFormat,
  ContentString,
  ContentType,
  Dialog,
  DialogContainer,
  Divider,
  Editable,
  Editor,
  EditorAfterButIgnoringingPointsWithNoContent,
  Element as Element2,
  Field,
  FieldButton,
  FieldDataError,
  FieldLabel,
  FieldMessage,
  FieldPrimitive,
  Flex,
  FocusRing,
  Footer,
  GitHubAppShellDataContext,
  Grid,
  HStack,
  Heading,
  Icon,
  Item,
  KEYSTATIC_CLOUD_API_URL,
  KEYSTATIC_CLOUD_HEADERS,
  Kbd,
  KeystarProvider,
  Node as Node2,
  NotEditable,
  Operation,
  Path,
  PathContextProvider,
  Point,
  Popover,
  ProgressCircle,
  Prose,
  Range,
  ReactEditor,
  Ref_base,
  RelativePosition,
  ScrollView,
  Slate,
  SlotProvider,
  SlugFieldProvider,
  Snapshot,
  Text,
  Text2,
  TextField,
  TextFieldPrimitive,
  ToggleButton,
  Tooltip,
  Transforms,
  Transition,
  Tray,
  UndoManager,
  VStack,
  YArray,
  YMap,
  YText,
  YXmlElement,
  YXmlFragment,
  YXmlText,
  _TooltipTrigger,
  actionButtonClassList,
  allMarks,
  areArraysEqual,
  assert,
  assertNever,
  basicFormFieldWithSimpleReaderParse,
  blockElementSpacing,
  breakpointQueries$1,
  breakpoints,
  chevronDownIcon,
  classNames,
  clear,
  clearFormatting,
  clearObjectCache,
  cloneDescendent,
  collectDirectoriesUsedInSchema,
  compareRelativePositions,
  containerQueries,
  create,
  create2,
  createAbsolutePositionFromRelativePosition,
  createDeleteSet,
  createEditor,
  createID,
  createMutex,
  createRelativePositionFromJSON,
  createRelativePositionFromTypeIndex,
  createSnapshot,
  createStore,
  css,
  del,
  doc,
  editorSchema,
  findRootTypeKey,
  fixPath,
  focusWithPreviousSelection,
  forwardRefWithAs,
  get,
  getAncestorComponentChildFieldDocumentFeatures,
  getAncestorSchemas,
  getBranchPrefix,
  getCloudAuth,
  getDocumentFeaturesForChildField,
  getEntriesInCollectionWithTreeKey,
  getPlaceholderTextForPropPath,
  getRepoUrl,
  getSchemaAtPropPath,
  getSlugFromState,
  getWholeDocumentFeaturesForChildField,
  imageIcon,
  injectGlobal,
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading,
  isBlock,
  isBrowser,
  isDeleted,
  isElementActive,
  isGitHubConfig,
  isInlineContainer,
  isLocalConfig,
  isParentOf,
  isPlainObject,
  isReactText,
  iterateDeletedStructs,
  keys,
  lib_default,
  max,
  methodUnimplemented,
  min,
  minusIcon,
  moveChildren,
  nodeTypeMatcher,
  normalizeElementBasedOnDocumentFeatures,
  normalizeInlineBasedOnLinks,
  normalizeTextBasedOnInlineMarksAndSoftBreaks,
  object,
  oneOf,
  onlyStyleProps,
  pencilIcon,
  pluralize,
  plusIcon,
  redirectToCloudAuth,
  resetClassName,
  serializeRepoConfig,
  set,
  setIfUndefined,
  snapshot,
  text,
  timeout,
  toDataAttributes,
  toastQueue,
  tokenSchema,
  transition,
  trash2Icon,
  typeListToArraySnapshot,
  typedKeys,
  unexpectedCase,
  useActiveBlockPopover,
  useAppState,
  useBranchInfo,
  useBreakpoint,
  useChanged,
  useCloudInfo,
  useConfig,
  useContentPanelQuery,
  useContentPanelSize,
  useDialogContainer,
  useDragAndDrop,
  useElementWithSetNodes,
  useEventCallback,
  useFieldButton,
  useId,
  useImageLibraryURL,
  useIsMobileDevice,
  useIsMounted,
  useMediaQuery,
  useMutation,
  usePrevious,
  useProseStyleProps,
  useProvider,
  useProviderProps,
  useQuery,
  useRawCloudInfo,
  useRepositoryId,
  useRouter,
  useSelected,
  useSlate,
  useSlateStatic,
  useSlotProps,
  useStyleProps,
  useTree,
  useViewer,
  validateFieldProps,
  validateTextFieldProps,
  weakMemoize,
  withDocumentFeaturesNormalization,
  withReact,
  xIcon
} from "./chunk-CGMUFSJF.js";
import {
  base64UrlDecode,
  base64UrlEncode
} from "./chunk-A6OZGVLF.js";
import {
  require_jsx_runtime
} from "./chunk-QRIEPQWS.js";
import {
  require_react_dom
} from "./chunk-XQLYTHWV.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/is-hotkey/lib/index.js
var require_lib = __commonJS({
  "node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f = 1; f < 20; f++) {
      CODES["f" + f] = 111 + f;
    }
    var f;
    function isHotkey2(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array = hotkey.map(function(string3) {
        return parseHotkey(string3, options);
      });
      var check = function check2(e3) {
        return array.some(function(object2) {
          return compareHotkey(object2, e3);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey2(hotkey, event);
    }
    function isKeyHotkey(hotkey, event) {
      return isHotkey2(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values3 = hotkey.split("+");
      var length = values3.length;
      for (var k in MODIFIERS) {
        ret[MODIFIERS[k]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;
          var optional = value.endsWith("?") && value.length > 1;
          if (optional) {
            value = value.slice(0, -1);
          }
          var name2 = toKeyName(value);
          var modifier = MODIFIERS[name2];
          if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name2]) {
            throw new TypeError('Unknown modifier: "' + value + '"');
          }
          if (length === 1 || !modifier) {
            if (byKey) {
              ret.key = name2;
            } else {
              ret.which = toKeyCode(value);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key3 in object2) {
        var expected = object2[key3];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key3 === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key3 === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key3];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name2) {
      name2 = toKeyName(name2);
      var code4 = CODES[name2] || name2.toUpperCase().charCodeAt(0);
      return code4;
    }
    function toKeyName(name2) {
      name2 = name2.toLowerCase();
      name2 = ALIASES[name2] || name2;
      return name2;
    }
    exports.default = isHotkey2;
    exports.isHotkey = isHotkey2;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/@braintree/sanitize-url/dist/index.js
var require_dist = __commonJS({
  "node_modules/@braintree/sanitize-url/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeUrl = exports.BLANK_URL = void 0;
    var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
    var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
    var htmlCtrlEntityRegex = /&(newline|tab);/gi;
    var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    var urlSchemeRegex = /^.+(:|&colon;)/gim;
    var relativeFirstCharacters = [".", "/"];
    exports.BLANK_URL = "about:blank";
    function isRelativeUrlWithoutProtocol(url) {
      return relativeFirstCharacters.indexOf(url[0]) > -1;
    }
    function decodeHtmlCharacters(str) {
      var removedNullByte = str.replace(ctrlCharactersRegex, "");
      return removedNullByte.replace(htmlEntitiesRegex, function(match2, dec) {
        return String.fromCharCode(dec);
      });
    }
    function sanitizeUrl2(url) {
      if (!url) {
        return exports.BLANK_URL;
      }
      var sanitizedUrl = decodeHtmlCharacters(url).replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
      if (!sanitizedUrl) {
        return exports.BLANK_URL;
      }
      if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
        return sanitizedUrl;
      }
      var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
      if (!urlSchemeParseResults) {
        return sanitizedUrl;
      }
      var urlScheme = urlSchemeParseResults[0];
      if (invalidProtocolRegex.test(urlScheme)) {
        return exports.BLANK_URL;
      }
      return sanitizedUrl;
    }
    exports.sanitizeUrl = sanitizeUrl2;
  }
});

// node_modules/remove-accents/index.js
var require_remove_accents = __commonJS({
  "node_modules/remove-accents/index.js"(exports, module) {
    var characterMap = {
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "Ấ": "A",
      "Ắ": "A",
      "Ẳ": "A",
      "Ẵ": "A",
      "Ặ": "A",
      "Æ": "AE",
      "Ầ": "A",
      "Ằ": "A",
      "Ȃ": "A",
      "Ả": "A",
      "Ạ": "A",
      "Ẩ": "A",
      "Ẫ": "A",
      "Ậ": "A",
      "Ç": "C",
      "Ḉ": "C",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "Ế": "E",
      "Ḗ": "E",
      "Ề": "E",
      "Ḕ": "E",
      "Ḝ": "E",
      "Ȇ": "E",
      "Ẻ": "E",
      "Ẽ": "E",
      "Ẹ": "E",
      "Ể": "E",
      "Ễ": "E",
      "Ệ": "E",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "Ḯ": "I",
      "Ȋ": "I",
      "Ỉ": "I",
      "Ị": "I",
      "Ð": "D",
      "Ñ": "N",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "Ố": "O",
      "Ṍ": "O",
      "Ṓ": "O",
      "Ȏ": "O",
      "Ỏ": "O",
      "Ọ": "O",
      "Ổ": "O",
      "Ỗ": "O",
      "Ộ": "O",
      "Ờ": "O",
      "Ở": "O",
      "Ỡ": "O",
      "Ớ": "O",
      "Ợ": "O",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "Ủ": "U",
      "Ụ": "U",
      "Ử": "U",
      "Ữ": "U",
      "Ự": "U",
      "Ý": "Y",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "ấ": "a",
      "ắ": "a",
      "ẳ": "a",
      "ẵ": "a",
      "ặ": "a",
      "æ": "ae",
      "ầ": "a",
      "ằ": "a",
      "ȃ": "a",
      "ả": "a",
      "ạ": "a",
      "ẩ": "a",
      "ẫ": "a",
      "ậ": "a",
      "ç": "c",
      "ḉ": "c",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "ế": "e",
      "ḗ": "e",
      "ề": "e",
      "ḕ": "e",
      "ḝ": "e",
      "ȇ": "e",
      "ẻ": "e",
      "ẽ": "e",
      "ẹ": "e",
      "ể": "e",
      "ễ": "e",
      "ệ": "e",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "ḯ": "i",
      "ȋ": "i",
      "ỉ": "i",
      "ị": "i",
      "ð": "d",
      "ñ": "n",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "ố": "o",
      "ṍ": "o",
      "ṓ": "o",
      "ȏ": "o",
      "ỏ": "o",
      "ọ": "o",
      "ổ": "o",
      "ỗ": "o",
      "ộ": "o",
      "ờ": "o",
      "ở": "o",
      "ỡ": "o",
      "ớ": "o",
      "ợ": "o",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "ủ": "u",
      "ụ": "u",
      "ử": "u",
      "ữ": "u",
      "ự": "u",
      "ý": "y",
      "ÿ": "y",
      "Ā": "A",
      "ā": "a",
      "Ă": "A",
      "ă": "a",
      "Ą": "A",
      "ą": "a",
      "Ć": "C",
      "ć": "c",
      "Ĉ": "C",
      "ĉ": "c",
      "Ċ": "C",
      "ċ": "c",
      "Č": "C",
      "č": "c",
      "C̆": "C",
      "c̆": "c",
      "Ď": "D",
      "ď": "d",
      "Đ": "D",
      "đ": "d",
      "Ē": "E",
      "ē": "e",
      "Ĕ": "E",
      "ĕ": "e",
      "Ė": "E",
      "ė": "e",
      "Ę": "E",
      "ę": "e",
      "Ě": "E",
      "ě": "e",
      "Ĝ": "G",
      "Ǵ": "G",
      "ĝ": "g",
      "ǵ": "g",
      "Ğ": "G",
      "ğ": "g",
      "Ġ": "G",
      "ġ": "g",
      "Ģ": "G",
      "ģ": "g",
      "Ĥ": "H",
      "ĥ": "h",
      "Ħ": "H",
      "ħ": "h",
      "Ḫ": "H",
      "ḫ": "h",
      "Ĩ": "I",
      "ĩ": "i",
      "Ī": "I",
      "ī": "i",
      "Ĭ": "I",
      "ĭ": "i",
      "Į": "I",
      "į": "i",
      "İ": "I",
      "ı": "i",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "Ḱ": "K",
      "ḱ": "k",
      "K̆": "K",
      "k̆": "k",
      "Ĺ": "L",
      "ĺ": "l",
      "Ļ": "L",
      "ļ": "l",
      "Ľ": "L",
      "ľ": "l",
      "Ŀ": "L",
      "ŀ": "l",
      "Ł": "l",
      "ł": "l",
      "Ḿ": "M",
      "ḿ": "m",
      "M̆": "M",
      "m̆": "m",
      "Ń": "N",
      "ń": "n",
      "Ņ": "N",
      "ņ": "n",
      "Ň": "N",
      "ň": "n",
      "ŉ": "n",
      "N̆": "N",
      "n̆": "n",
      "Ō": "O",
      "ō": "o",
      "Ŏ": "O",
      "ŏ": "o",
      "Ő": "O",
      "ő": "o",
      "Œ": "OE",
      "œ": "oe",
      "P̆": "P",
      "p̆": "p",
      "Ŕ": "R",
      "ŕ": "r",
      "Ŗ": "R",
      "ŗ": "r",
      "Ř": "R",
      "ř": "r",
      "R̆": "R",
      "r̆": "r",
      "Ȓ": "R",
      "ȓ": "r",
      "Ś": "S",
      "ś": "s",
      "Ŝ": "S",
      "ŝ": "s",
      "Ş": "S",
      "Ș": "S",
      "ș": "s",
      "ş": "s",
      "Š": "S",
      "š": "s",
      "Ţ": "T",
      "ţ": "t",
      "ț": "t",
      "Ț": "T",
      "Ť": "T",
      "ť": "t",
      "Ŧ": "T",
      "ŧ": "t",
      "T̆": "T",
      "t̆": "t",
      "Ũ": "U",
      "ũ": "u",
      "Ū": "U",
      "ū": "u",
      "Ŭ": "U",
      "ŭ": "u",
      "Ů": "U",
      "ů": "u",
      "Ű": "U",
      "ű": "u",
      "Ų": "U",
      "ų": "u",
      "Ȗ": "U",
      "ȗ": "u",
      "V̆": "V",
      "v̆": "v",
      "Ŵ": "W",
      "ŵ": "w",
      "Ẃ": "W",
      "ẃ": "w",
      "X̆": "X",
      "x̆": "x",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Y̆": "Y",
      "y̆": "y",
      "Ź": "Z",
      "ź": "z",
      "Ż": "Z",
      "ż": "z",
      "Ž": "Z",
      "ž": "z",
      "ſ": "s",
      "ƒ": "f",
      "Ơ": "O",
      "ơ": "o",
      "Ư": "U",
      "ư": "u",
      "Ǎ": "A",
      "ǎ": "a",
      "Ǐ": "I",
      "ǐ": "i",
      "Ǒ": "O",
      "ǒ": "o",
      "Ǔ": "U",
      "ǔ": "u",
      "Ǖ": "U",
      "ǖ": "u",
      "Ǘ": "U",
      "ǘ": "u",
      "Ǚ": "U",
      "ǚ": "u",
      "Ǜ": "U",
      "ǜ": "u",
      "Ứ": "U",
      "ứ": "u",
      "Ṹ": "U",
      "ṹ": "u",
      "Ǻ": "A",
      "ǻ": "a",
      "Ǽ": "AE",
      "ǽ": "ae",
      "Ǿ": "O",
      "ǿ": "o",
      "Þ": "TH",
      "þ": "th",
      "Ṕ": "P",
      "ṕ": "p",
      "Ṥ": "S",
      "ṥ": "s",
      "X́": "X",
      "x́": "x",
      "Ѓ": "Г",
      "ѓ": "г",
      "Ќ": "К",
      "ќ": "к",
      "A̋": "A",
      "a̋": "a",
      "E̋": "E",
      "e̋": "e",
      "I̋": "I",
      "i̋": "i",
      "Ǹ": "N",
      "ǹ": "n",
      "Ồ": "O",
      "ồ": "o",
      "Ṑ": "O",
      "ṑ": "o",
      "Ừ": "U",
      "ừ": "u",
      "Ẁ": "W",
      "ẁ": "w",
      "Ỳ": "Y",
      "ỳ": "y",
      "Ȁ": "A",
      "ȁ": "a",
      "Ȅ": "E",
      "ȅ": "e",
      "Ȉ": "I",
      "ȉ": "i",
      "Ȍ": "O",
      "ȍ": "o",
      "Ȑ": "R",
      "ȑ": "r",
      "Ȕ": "U",
      "ȕ": "u",
      "B̌": "B",
      "b̌": "b",
      "Č̣": "C",
      "č̣": "c",
      "Ê̌": "E",
      "ê̌": "e",
      "F̌": "F",
      "f̌": "f",
      "Ǧ": "G",
      "ǧ": "g",
      "Ȟ": "H",
      "ȟ": "h",
      "J̌": "J",
      "ǰ": "j",
      "Ǩ": "K",
      "ǩ": "k",
      "M̌": "M",
      "m̌": "m",
      "P̌": "P",
      "p̌": "p",
      "Q̌": "Q",
      "q̌": "q",
      "Ř̩": "R",
      "ř̩": "r",
      "Ṧ": "S",
      "ṧ": "s",
      "V̌": "V",
      "v̌": "v",
      "W̌": "W",
      "w̌": "w",
      "X̌": "X",
      "x̌": "x",
      "Y̌": "Y",
      "y̌": "y",
      "A̧": "A",
      "a̧": "a",
      "B̧": "B",
      "b̧": "b",
      "Ḑ": "D",
      "ḑ": "d",
      "Ȩ": "E",
      "ȩ": "e",
      "Ɛ̧": "E",
      "ɛ̧": "e",
      "Ḩ": "H",
      "ḩ": "h",
      "I̧": "I",
      "i̧": "i",
      "Ɨ̧": "I",
      "ɨ̧": "i",
      "M̧": "M",
      "m̧": "m",
      "O̧": "O",
      "o̧": "o",
      "Q̧": "Q",
      "q̧": "q",
      "U̧": "U",
      "u̧": "u",
      "X̧": "X",
      "x̧": "x",
      "Z̧": "Z",
      "z̧": "z",
      "й": "и",
      "Й": "И",
      "ё": "е",
      "Ё": "Е"
    };
    var chars = Object.keys(characterMap).join("|");
    var allAccents = new RegExp(chars, "g");
    var firstAccent = new RegExp(chars, "");
    function matcher(match2) {
      return characterMap[match2];
    }
    var removeAccents2 = function(string3) {
      return string3.replace(allAccents, matcher);
    };
    var hasAccents = function(string3) {
      return !!string3.match(firstAccent);
    };
    module.exports = removeAccents2;
    module.exports.has = hasAccents;
    module.exports.remove = removeAccents2;
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r2 = range(a, b, str);
      return r2 && {
        start: r2[0],
        end: r2[1],
        pre: str.slice(0, r2[0]),
        body: str.slice(r2[0] + a.length, r2[1]),
        post: str.slice(r2[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/@keystatic/core/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/@keystatic/core/node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i2, y) {
      return i2 <= y;
    }
    function gte(i2, y) {
      return i2 >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n2;
        if (isSequence) {
          n2 = m.body.split(/\.\./);
        } else {
          n2 = parseCommaParts(m.body);
          if (n2.length === 1) {
            n2 = expand2(n2[0], false).map(embrace);
            if (n2.length === 1) {
              return post.map(function(p) {
                return m.pre + n2[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n2[0]);
          var y = numeric(n2[1]);
          var width = Math.max(n2[0].length, n2[1].length);
          var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n2.some(isPadded);
          N = [];
          for (var i2 = x; test(i2, y); i2 += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i2);
              if (c === "\\")
                c = "";
            } else {
              c = String(i2);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i2 < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n2.length; j++) {
            N.push.apply(N, expand2(n2[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/@sindresorhus/slugify/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/@sindresorhus/slugify/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    module.exports = (string3) => {
      if (typeof string3 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/lodash.deburr/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.deburr/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object2) {
      return function(key3) {
        return object2 == null ? void 0 : object2[key3];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root2.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString4(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string3) {
      string3 = toString4(string3);
      return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string3) => {
      if (typeof string3 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string3.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/@sindresorhus/transliterate/replacements.js
var require_replacements2 = __commonJS({
  "node_modules/@sindresorhus/transliterate/replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      // German umlauts
      ["ß", "ss"],
      ["ä", "ae"],
      ["Ä", "Ae"],
      ["ö", "oe"],
      ["Ö", "Oe"],
      ["ü", "ue"],
      ["Ü", "Ue"],
      // Latin
      ["À", "A"],
      ["Á", "A"],
      ["Â", "A"],
      ["Ã", "A"],
      ["Ä", "Ae"],
      ["Å", "A"],
      ["Æ", "AE"],
      ["Ç", "C"],
      ["È", "E"],
      ["É", "E"],
      ["Ê", "E"],
      ["Ë", "E"],
      ["Ì", "I"],
      ["Í", "I"],
      ["Î", "I"],
      ["Ï", "I"],
      ["Ð", "D"],
      ["Ñ", "N"],
      ["Ò", "O"],
      ["Ó", "O"],
      ["Ô", "O"],
      ["Õ", "O"],
      ["Ö", "Oe"],
      ["Ő", "O"],
      ["Ø", "O"],
      ["Ù", "U"],
      ["Ú", "U"],
      ["Û", "U"],
      ["Ü", "Ue"],
      ["Ű", "U"],
      ["Ý", "Y"],
      ["Þ", "TH"],
      ["ß", "ss"],
      ["à", "a"],
      ["á", "a"],
      ["â", "a"],
      ["ã", "a"],
      ["ä", "ae"],
      ["å", "a"],
      ["æ", "ae"],
      ["ç", "c"],
      ["è", "e"],
      ["é", "e"],
      ["ê", "e"],
      ["ë", "e"],
      ["ì", "i"],
      ["í", "i"],
      ["î", "i"],
      ["ï", "i"],
      ["ð", "d"],
      ["ñ", "n"],
      ["ò", "o"],
      ["ó", "o"],
      ["ô", "o"],
      ["õ", "o"],
      ["ö", "oe"],
      ["ő", "o"],
      ["ø", "o"],
      ["ù", "u"],
      ["ú", "u"],
      ["û", "u"],
      ["ü", "ue"],
      ["ű", "u"],
      ["ý", "y"],
      ["þ", "th"],
      ["ÿ", "y"],
      ["ẞ", "SS"],
      // Vietnamese
      ["à", "a"],
      ["À", "A"],
      ["á", "a"],
      ["Á", "A"],
      ["â", "a"],
      ["Â", "A"],
      ["ã", "a"],
      ["Ã", "A"],
      ["è", "e"],
      ["È", "E"],
      ["é", "e"],
      ["É", "E"],
      ["ê", "e"],
      ["Ê", "E"],
      ["ì", "i"],
      ["Ì", "I"],
      ["í", "i"],
      ["Í", "I"],
      ["ò", "o"],
      ["Ò", "O"],
      ["ó", "o"],
      ["Ó", "O"],
      ["ô", "o"],
      ["Ô", "O"],
      ["õ", "o"],
      ["Õ", "O"],
      ["ù", "u"],
      ["Ù", "U"],
      ["ú", "u"],
      ["Ú", "U"],
      ["ý", "y"],
      ["Ý", "Y"],
      ["ă", "a"],
      ["Ă", "A"],
      ["Đ", "D"],
      ["đ", "d"],
      ["ĩ", "i"],
      ["Ĩ", "I"],
      ["ũ", "u"],
      ["Ũ", "U"],
      ["ơ", "o"],
      ["Ơ", "O"],
      ["ư", "u"],
      ["Ư", "U"],
      ["ạ", "a"],
      ["Ạ", "A"],
      ["ả", "a"],
      ["Ả", "A"],
      ["ấ", "a"],
      ["Ấ", "A"],
      ["ầ", "a"],
      ["Ầ", "A"],
      ["ẩ", "a"],
      ["Ẩ", "A"],
      ["ẫ", "a"],
      ["Ẫ", "A"],
      ["ậ", "a"],
      ["Ậ", "A"],
      ["ắ", "a"],
      ["Ắ", "A"],
      ["ằ", "a"],
      ["Ằ", "A"],
      ["ẳ", "a"],
      ["Ẳ", "A"],
      ["ẵ", "a"],
      ["Ẵ", "A"],
      ["ặ", "a"],
      ["Ặ", "A"],
      ["ẹ", "e"],
      ["Ẹ", "E"],
      ["ẻ", "e"],
      ["Ẻ", "E"],
      ["ẽ", "e"],
      ["Ẽ", "E"],
      ["ế", "e"],
      ["Ế", "E"],
      ["ề", "e"],
      ["Ề", "E"],
      ["ể", "e"],
      ["Ể", "E"],
      ["ễ", "e"],
      ["Ễ", "E"],
      ["ệ", "e"],
      ["Ệ", "E"],
      ["ỉ", "i"],
      ["Ỉ", "I"],
      ["ị", "i"],
      ["Ị", "I"],
      ["ọ", "o"],
      ["Ọ", "O"],
      ["ỏ", "o"],
      ["Ỏ", "O"],
      ["ố", "o"],
      ["Ố", "O"],
      ["ồ", "o"],
      ["Ồ", "O"],
      ["ổ", "o"],
      ["Ổ", "O"],
      ["ỗ", "o"],
      ["Ỗ", "O"],
      ["ộ", "o"],
      ["Ộ", "O"],
      ["ớ", "o"],
      ["Ớ", "O"],
      ["ờ", "o"],
      ["Ờ", "O"],
      ["ở", "o"],
      ["Ở", "O"],
      ["ỡ", "o"],
      ["Ỡ", "O"],
      ["ợ", "o"],
      ["Ợ", "O"],
      ["ụ", "u"],
      ["Ụ", "U"],
      ["ủ", "u"],
      ["Ủ", "U"],
      ["ứ", "u"],
      ["Ứ", "U"],
      ["ừ", "u"],
      ["Ừ", "U"],
      ["ử", "u"],
      ["Ử", "U"],
      ["ữ", "u"],
      ["Ữ", "U"],
      ["ự", "u"],
      ["Ự", "U"],
      ["ỳ", "y"],
      ["Ỳ", "Y"],
      ["ỵ", "y"],
      ["Ỵ", "Y"],
      ["ỷ", "y"],
      ["Ỷ", "Y"],
      ["ỹ", "y"],
      ["Ỹ", "Y"],
      // Arabic
      ["ء", "e"],
      ["آ", "a"],
      ["أ", "a"],
      ["ؤ", "w"],
      ["إ", "i"],
      ["ئ", "y"],
      ["ا", "a"],
      ["ب", "b"],
      ["ة", "t"],
      ["ت", "t"],
      ["ث", "th"],
      ["ج", "j"],
      ["ح", "h"],
      ["خ", "kh"],
      ["د", "d"],
      ["ذ", "dh"],
      ["ر", "r"],
      ["ز", "z"],
      ["س", "s"],
      ["ش", "sh"],
      ["ص", "s"],
      ["ض", "d"],
      ["ط", "t"],
      ["ظ", "z"],
      ["ع", "e"],
      ["غ", "gh"],
      ["ـ", "_"],
      ["ف", "f"],
      ["ق", "q"],
      ["ك", "k"],
      ["ل", "l"],
      ["م", "m"],
      ["ن", "n"],
      ["ه", "h"],
      ["و", "w"],
      ["ى", "a"],
      ["ي", "y"],
      ["َ‎", "a"],
      ["ُ", "u"],
      ["ِ‎", "i"],
      ["٠", "0"],
      ["١", "1"],
      ["٢", "2"],
      ["٣", "3"],
      ["٤", "4"],
      ["٥", "5"],
      ["٦", "6"],
      ["٧", "7"],
      ["٨", "8"],
      ["٩", "9"],
      // Persian / Farsi
      ["چ", "ch"],
      ["ک", "k"],
      ["گ", "g"],
      ["پ", "p"],
      ["ژ", "zh"],
      ["ی", "y"],
      ["۰", "0"],
      ["۱", "1"],
      ["۲", "2"],
      ["۳", "3"],
      ["۴", "4"],
      ["۵", "5"],
      ["۶", "6"],
      ["۷", "7"],
      ["۸", "8"],
      ["۹", "9"],
      // Pashto
      ["ټ", "p"],
      ["ځ", "z"],
      ["څ", "c"],
      ["ډ", "d"],
      ["ﺫ", "d"],
      ["ﺭ", "r"],
      ["ړ", "r"],
      ["ﺯ", "z"],
      ["ږ", "g"],
      ["ښ", "x"],
      ["ګ", "g"],
      ["ڼ", "n"],
      ["ۀ", "e"],
      ["ې", "e"],
      ["ۍ", "ai"],
      // Urdu
      ["ٹ", "t"],
      ["ڈ", "d"],
      ["ڑ", "r"],
      ["ں", "n"],
      ["ہ", "h"],
      ["ھ", "h"],
      ["ے", "e"],
      // Russian
      ["А", "A"],
      ["а", "a"],
      ["Б", "B"],
      ["б", "b"],
      ["В", "V"],
      ["в", "v"],
      ["Г", "G"],
      ["г", "g"],
      ["Д", "D"],
      ["д", "d"],
      ["Е", "E"],
      ["е", "e"],
      ["Ж", "Zh"],
      ["ж", "zh"],
      ["З", "Z"],
      ["з", "z"],
      ["И", "I"],
      ["и", "i"],
      ["Й", "J"],
      ["й", "j"],
      ["К", "K"],
      ["к", "k"],
      ["Л", "L"],
      ["л", "l"],
      ["М", "M"],
      ["м", "m"],
      ["Н", "N"],
      ["н", "n"],
      ["О", "O"],
      ["о", "o"],
      ["П", "P"],
      ["п", "p"],
      ["Р", "R"],
      ["р", "r"],
      ["С", "S"],
      ["с", "s"],
      ["Т", "T"],
      ["т", "t"],
      ["У", "U"],
      ["у", "u"],
      ["Ф", "F"],
      ["ф", "f"],
      ["Х", "H"],
      ["х", "h"],
      ["Ц", "Cz"],
      ["ц", "cz"],
      ["Ч", "Ch"],
      ["ч", "ch"],
      ["Ш", "Sh"],
      ["ш", "sh"],
      ["Щ", "Shh"],
      ["щ", "shh"],
      ["Ъ", ""],
      ["ъ", ""],
      ["Ы", "Y"],
      ["ы", "y"],
      ["Ь", ""],
      ["ь", ""],
      ["Э", "E"],
      ["э", "e"],
      ["Ю", "Yu"],
      ["ю", "yu"],
      ["Я", "Ya"],
      ["я", "ya"],
      ["Ё", "Yo"],
      ["ё", "yo"],
      // Romanian
      ["ă", "a"],
      ["Ă", "A"],
      ["ș", "s"],
      ["Ș", "S"],
      ["ț", "t"],
      ["Ț", "T"],
      ["ţ", "t"],
      ["Ţ", "T"],
      // Turkish
      ["ş", "s"],
      ["Ş", "S"],
      ["ç", "c"],
      ["Ç", "C"],
      ["ğ", "g"],
      ["Ğ", "G"],
      ["ı", "i"],
      ["İ", "I"],
      // Armenian
      ["ա", "a"],
      ["Ա", "A"],
      ["բ", "b"],
      ["Բ", "B"],
      ["գ", "g"],
      ["Գ", "G"],
      ["դ", "d"],
      ["Դ", "D"],
      ["ե", "ye"],
      ["Ե", "Ye"],
      ["զ", "z"],
      ["Զ", "Z"],
      ["է", "e"],
      ["Է", "E"],
      ["ը", "y"],
      ["Ը", "Y"],
      ["թ", "t"],
      ["Թ", "T"],
      ["ժ", "zh"],
      ["Ժ", "Zh"],
      ["ի", "i"],
      ["Ի", "I"],
      ["լ", "l"],
      ["Լ", "L"],
      ["խ", "kh"],
      ["Խ", "Kh"],
      ["ծ", "ts"],
      ["Ծ", "Ts"],
      ["կ", "k"],
      ["Կ", "K"],
      ["հ", "h"],
      ["Հ", "H"],
      ["ձ", "dz"],
      ["Ձ", "Dz"],
      ["ղ", "gh"],
      ["Ղ", "Gh"],
      ["ճ", "tch"],
      ["Ճ", "Tch"],
      ["մ", "m"],
      ["Մ", "M"],
      ["յ", "y"],
      ["Յ", "Y"],
      ["ն", "n"],
      ["Ն", "N"],
      ["շ", "sh"],
      ["Շ", "Sh"],
      ["ո", "vo"],
      ["Ո", "Vo"],
      ["չ", "ch"],
      ["Չ", "Ch"],
      ["պ", "p"],
      ["Պ", "P"],
      ["ջ", "j"],
      ["Ջ", "J"],
      ["ռ", "r"],
      ["Ռ", "R"],
      ["ս", "s"],
      ["Ս", "S"],
      ["վ", "v"],
      ["Վ", "V"],
      ["տ", "t"],
      ["Տ", "T"],
      ["ր", "r"],
      ["Ր", "R"],
      ["ց", "c"],
      ["Ց", "C"],
      ["ու", "u"],
      ["ՈՒ", "U"],
      ["Ու", "U"],
      ["փ", "p"],
      ["Փ", "P"],
      ["ք", "q"],
      ["Ք", "Q"],
      ["օ", "o"],
      ["Օ", "O"],
      ["ֆ", "f"],
      ["Ֆ", "F"],
      ["և", "yev"],
      // Georgian
      ["ა", "a"],
      ["ბ", "b"],
      ["გ", "g"],
      ["დ", "d"],
      ["ე", "e"],
      ["ვ", "v"],
      ["ზ", "z"],
      ["თ", "t"],
      ["ი", "i"],
      ["კ", "k"],
      ["ლ", "l"],
      ["მ", "m"],
      ["ნ", "n"],
      ["ო", "o"],
      ["პ", "p"],
      ["ჟ", "zh"],
      ["რ", "r"],
      ["ს", "s"],
      ["ტ", "t"],
      ["უ", "u"],
      ["ფ", "ph"],
      ["ქ", "q"],
      ["ღ", "gh"],
      ["ყ", "k"],
      ["შ", "sh"],
      ["ჩ", "ch"],
      ["ც", "ts"],
      ["ძ", "dz"],
      ["წ", "ts"],
      ["ჭ", "tch"],
      ["ხ", "kh"],
      ["ჯ", "j"],
      ["ჰ", "h"],
      // Czech
      ["č", "c"],
      ["ď", "d"],
      ["ě", "e"],
      ["ň", "n"],
      ["ř", "r"],
      ["š", "s"],
      ["ť", "t"],
      ["ů", "u"],
      ["ž", "z"],
      ["Č", "C"],
      ["Ď", "D"],
      ["Ě", "E"],
      ["Ň", "N"],
      ["Ř", "R"],
      ["Š", "S"],
      ["Ť", "T"],
      ["Ů", "U"],
      ["Ž", "Z"],
      // Dhivehi
      ["ހ", "h"],
      ["ށ", "sh"],
      ["ނ", "n"],
      ["ރ", "r"],
      ["ބ", "b"],
      ["ޅ", "lh"],
      ["ކ", "k"],
      ["އ", "a"],
      ["ވ", "v"],
      ["މ", "m"],
      ["ފ", "f"],
      ["ދ", "dh"],
      ["ތ", "th"],
      ["ލ", "l"],
      ["ގ", "g"],
      ["ޏ", "gn"],
      ["ސ", "s"],
      ["ޑ", "d"],
      ["ޒ", "z"],
      ["ޓ", "t"],
      ["ޔ", "y"],
      ["ޕ", "p"],
      ["ޖ", "j"],
      ["ޗ", "ch"],
      ["ޘ", "tt"],
      ["ޙ", "hh"],
      ["ޚ", "kh"],
      ["ޛ", "th"],
      ["ޜ", "z"],
      ["ޝ", "sh"],
      ["ޞ", "s"],
      ["ޟ", "d"],
      ["ޠ", "t"],
      ["ޡ", "z"],
      ["ޢ", "a"],
      ["ޣ", "gh"],
      ["ޤ", "q"],
      ["ޥ", "w"],
      ["ަ", "a"],
      ["ާ", "aa"],
      ["ި", "i"],
      ["ީ", "ee"],
      ["ު", "u"],
      ["ޫ", "oo"],
      ["ެ", "e"],
      ["ޭ", "ey"],
      ["ޮ", "o"],
      ["ޯ", "oa"],
      ["ް", ""],
      // Greek
      ["α", "a"],
      ["β", "v"],
      ["γ", "g"],
      ["δ", "d"],
      ["ε", "e"],
      ["ζ", "z"],
      ["η", "i"],
      ["θ", "th"],
      ["ι", "i"],
      ["κ", "k"],
      ["λ", "l"],
      ["μ", "m"],
      ["ν", "n"],
      ["ξ", "ks"],
      ["ο", "o"],
      ["π", "p"],
      ["ρ", "r"],
      ["σ", "s"],
      ["τ", "t"],
      ["υ", "y"],
      ["φ", "f"],
      ["χ", "x"],
      ["ψ", "ps"],
      ["ω", "o"],
      ["ά", "a"],
      ["έ", "e"],
      ["ί", "i"],
      ["ό", "o"],
      ["ύ", "y"],
      ["ή", "i"],
      ["ώ", "o"],
      ["ς", "s"],
      ["ϊ", "i"],
      ["ΰ", "y"],
      ["ϋ", "y"],
      ["ΐ", "i"],
      ["Α", "A"],
      ["Β", "B"],
      ["Γ", "G"],
      ["Δ", "D"],
      ["Ε", "E"],
      ["Ζ", "Z"],
      ["Η", "I"],
      ["Θ", "TH"],
      ["Ι", "I"],
      ["Κ", "K"],
      ["Λ", "L"],
      ["Μ", "M"],
      ["Ν", "N"],
      ["Ξ", "KS"],
      ["Ο", "O"],
      ["Π", "P"],
      ["Ρ", "R"],
      ["Σ", "S"],
      ["Τ", "T"],
      ["Υ", "Y"],
      ["Φ", "F"],
      ["Χ", "X"],
      ["Ψ", "PS"],
      ["Ω", "O"],
      ["Ά", "A"],
      ["Έ", "E"],
      ["Ί", "I"],
      ["Ό", "O"],
      ["Ύ", "Y"],
      ["Ή", "I"],
      ["Ώ", "O"],
      ["Ϊ", "I"],
      ["Ϋ", "Y"],
      // Disabled as it conflicts with German and Latin.
      // Hungarian
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ö', 'o'],
      // ['Ö', 'O'],
      // ['ü', 'u'],
      // ['Ü', 'U'],
      // ['ű', 'u'],
      // ['Ű', 'U'],
      // Latvian
      ["ā", "a"],
      ["ē", "e"],
      ["ģ", "g"],
      ["ī", "i"],
      ["ķ", "k"],
      ["ļ", "l"],
      ["ņ", "n"],
      ["ū", "u"],
      ["Ā", "A"],
      ["Ē", "E"],
      ["Ģ", "G"],
      ["Ī", "I"],
      ["Ķ", "K"],
      ["Ļ", "L"],
      ["Ņ", "N"],
      ["Ū", "U"],
      ["č", "c"],
      ["š", "s"],
      ["ž", "z"],
      ["Č", "C"],
      ["Š", "S"],
      ["Ž", "Z"],
      // Lithuanian
      ["ą", "a"],
      ["č", "c"],
      ["ę", "e"],
      ["ė", "e"],
      ["į", "i"],
      ["š", "s"],
      ["ų", "u"],
      ["ū", "u"],
      ["ž", "z"],
      ["Ą", "A"],
      ["Č", "C"],
      ["Ę", "E"],
      ["Ė", "E"],
      ["Į", "I"],
      ["Š", "S"],
      ["Ų", "U"],
      ["Ū", "U"],
      // Macedonian
      ["Ќ", "Kj"],
      ["ќ", "kj"],
      ["Љ", "Lj"],
      ["љ", "lj"],
      ["Њ", "Nj"],
      ["њ", "nj"],
      ["Тс", "Ts"],
      ["тс", "ts"],
      // Polish
      ["ą", "a"],
      ["ć", "c"],
      ["ę", "e"],
      ["ł", "l"],
      ["ń", "n"],
      ["ś", "s"],
      ["ź", "z"],
      ["ż", "z"],
      ["Ą", "A"],
      ["Ć", "C"],
      ["Ę", "E"],
      ["Ł", "L"],
      ["Ń", "N"],
      ["Ś", "S"],
      ["Ź", "Z"],
      ["Ż", "Z"],
      // Disabled as it conflicts with Vietnamese.
      // Serbian
      // ['љ', 'lj'],
      // ['њ', 'nj'],
      // ['Љ', 'Lj'],
      // ['Њ', 'Nj'],
      // ['đ', 'dj'],
      // ['Đ', 'Dj'],
      // ['ђ', 'dj'],
      // ['ј', 'j'],
      // ['ћ', 'c'],
      // ['џ', 'dz'],
      // ['Ђ', 'Dj'],
      // ['Ј', 'j'],
      // ['Ћ', 'C'],
      // ['Џ', 'Dz'],
      // Disabled as it conflicts with German and Latin.
      // Slovak
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ľ', 'l'],
      // ['ĺ', 'l'],
      // ['ŕ', 'r'],
      // ['Ľ', 'L'],
      // ['Ĺ', 'L'],
      // ['Ŕ', 'R'],
      // Disabled as it conflicts with German and Latin.
      // Swedish
      // ['å', 'o'],
      // ['Å', 'o'],
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ë', 'e'],
      // ['Ë', 'E'],
      // ['ö', 'o'],
      // ['Ö', 'O'],
      // Ukrainian
      ["Є", "Ye"],
      ["І", "I"],
      ["Ї", "Yi"],
      ["Ґ", "G"],
      ["є", "ye"],
      ["і", "i"],
      ["ї", "yi"],
      ["ґ", "g"]
      // Danish
      // ['Æ', 'Ae'],
      // ['Ø', 'Oe'],
      // ['Å', 'Aa'],
      // ['æ', 'ae'],
      // ['ø', 'oe'],
      // ['å', 'aa']
    ];
  }
});

// node_modules/@sindresorhus/transliterate/index.js
var require_transliterate = __commonJS({
  "node_modules/@sindresorhus/transliterate/index.js"(exports, module) {
    "use strict";
    var deburr = require_lodash();
    var escapeStringRegexp2 = require_escape_string_regexp2();
    var builtinReplacements = require_replacements2();
    var doCustomReplacements = (string3, replacements) => {
      for (const [key3, value] of replacements) {
        string3 = string3.replace(new RegExp(escapeStringRegexp2(key3), "g"), value);
      }
      return string3;
    };
    module.exports = (string3, options) => {
      if (typeof string3 !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string3}\``);
      }
      options = {
        customReplacements: [],
        ...options
      };
      const customReplacements = new Map([
        ...builtinReplacements,
        ...options.customReplacements
      ]);
      string3 = string3.normalize();
      string3 = doCustomReplacements(string3, customReplacements);
      string3 = deburr(string3);
      return string3;
    };
  }
});

// node_modules/@sindresorhus/slugify/overridable-replacements.js
var require_overridable_replacements = __commonJS({
  "node_modules/@sindresorhus/slugify/overridable-replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      ["&", " and "],
      ["🦄", " unicorn "],
      ["♥", " love "]
    ];
  }
});

// node_modules/@sindresorhus/slugify/index.js
var require_slugify = __commonJS({
  "node_modules/@sindresorhus/slugify/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp2 = require_escape_string_regexp();
    var transliterate = require_transliterate();
    var builtinOverridableReplacements = require_overridable_replacements();
    var decamelize = (string3) => {
      return string3.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
    };
    var removeMootSeparators = (string3, separator) => {
      const escapedSeparator = escapeStringRegexp2(separator);
      return string3.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
    };
    var slugify = (string3, options) => {
      if (typeof string3 !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string3}\``);
      }
      options = {
        separator: "-",
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false,
        ...options
      };
      const shouldPrependUnderscore = options.preserveLeadingUnderscore && string3.startsWith("_");
      const customReplacements = new Map([
        ...builtinOverridableReplacements,
        ...options.customReplacements
      ]);
      string3 = transliterate(string3, { customReplacements });
      if (options.decamelize) {
        string3 = decamelize(string3);
      }
      let patternSlug = /[^a-zA-Z\d]+/g;
      if (options.lowercase) {
        string3 = string3.toLowerCase();
        patternSlug = /[^a-z\d]+/g;
      }
      string3 = string3.replace(patternSlug, options.separator);
      string3 = string3.replace(/\\/g, "");
      if (options.separator) {
        string3 = removeMootSeparators(string3, options.separator);
      }
      if (shouldPrependUnderscore) {
        string3 = `_${string3}`;
      }
      return string3;
    };
    var counter2 = () => {
      const occurrences = /* @__PURE__ */ new Map();
      const countable = (string3, options) => {
        string3 = slugify(string3, options);
        if (!string3) {
          return "";
        }
        const stringLower = string3.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
        const counter3 = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter3 === "number" ? counter3 + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
          string3 = `${string3}-${newCounter}`;
        }
        return string3;
      };
      countable.reset = () => {
        occurrences.clear();
      };
      return countable;
    };
    module.exports = slugify;
    module.exports.counter = counter2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n2 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name2) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env).forEach((key3) => {
        createDebug2[key3] = env[key3];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self2 = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index4 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index4++;
            const formatter = createDebug2.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index4];
              match2 = formatter.call(self2, val);
              args.splice(index4, 1);
              index4--;
            }
            return match2;
          });
          createDebug2.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.useColors = createDebug2.useColors();
        debug3.color = createDebug2.selectColor(namespace);
        debug3.extend = extend2;
        debug3.destroy = createDebug2.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug3);
        }
        return debug3;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        let i2;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split2[i2]) {
            continue;
          }
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug2.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug2.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names.map(toNamespace),
          ...createDebug2.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug2.skips.length; i2 < len; i2++) {
          if (createDebug2.skips[i2].test(name2)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug2.names.length; i2 < len; i2++) {
          if (createDebug2.names[i2].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index4 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index4++;
        if (match2 === "%c") {
          lastC = index4;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  }
});

// node_modules/@keystatic/core/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp3 = __commonJS({
  "node_modules/@keystatic/core/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    module.exports = (string3) => {
      if (typeof string3 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/acorn-jsx/xhtml.js
var require_xhtml = __commonJS({
  "node_modules/acorn-jsx/xhtml.js"(exports, module) {
    module.exports = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: " ",
      iexcl: "¡",
      cent: "¢",
      pound: "£",
      curren: "¤",
      yen: "¥",
      brvbar: "¦",
      sect: "§",
      uml: "¨",
      copy: "©",
      ordf: "ª",
      laquo: "«",
      not: "¬",
      shy: "­",
      reg: "®",
      macr: "¯",
      deg: "°",
      plusmn: "±",
      sup2: "²",
      sup3: "³",
      acute: "´",
      micro: "µ",
      para: "¶",
      middot: "·",
      cedil: "¸",
      sup1: "¹",
      ordm: "º",
      raquo: "»",
      frac14: "¼",
      frac12: "½",
      frac34: "¾",
      iquest: "¿",
      Agrave: "À",
      Aacute: "Á",
      Acirc: "Â",
      Atilde: "Ã",
      Auml: "Ä",
      Aring: "Å",
      AElig: "Æ",
      Ccedil: "Ç",
      Egrave: "È",
      Eacute: "É",
      Ecirc: "Ê",
      Euml: "Ë",
      Igrave: "Ì",
      Iacute: "Í",
      Icirc: "Î",
      Iuml: "Ï",
      ETH: "Ð",
      Ntilde: "Ñ",
      Ograve: "Ò",
      Oacute: "Ó",
      Ocirc: "Ô",
      Otilde: "Õ",
      Ouml: "Ö",
      times: "×",
      Oslash: "Ø",
      Ugrave: "Ù",
      Uacute: "Ú",
      Ucirc: "Û",
      Uuml: "Ü",
      Yacute: "Ý",
      THORN: "Þ",
      szlig: "ß",
      agrave: "à",
      aacute: "á",
      acirc: "â",
      atilde: "ã",
      auml: "ä",
      aring: "å",
      aelig: "æ",
      ccedil: "ç",
      egrave: "è",
      eacute: "é",
      ecirc: "ê",
      euml: "ë",
      igrave: "ì",
      iacute: "í",
      icirc: "î",
      iuml: "ï",
      eth: "ð",
      ntilde: "ñ",
      ograve: "ò",
      oacute: "ó",
      ocirc: "ô",
      otilde: "õ",
      ouml: "ö",
      divide: "÷",
      oslash: "ø",
      ugrave: "ù",
      uacute: "ú",
      ucirc: "û",
      uuml: "ü",
      yacute: "ý",
      thorn: "þ",
      yuml: "ÿ",
      OElig: "Œ",
      oelig: "œ",
      Scaron: "Š",
      scaron: "š",
      Yuml: "Ÿ",
      fnof: "ƒ",
      circ: "ˆ",
      tilde: "˜",
      Alpha: "Α",
      Beta: "Β",
      Gamma: "Γ",
      Delta: "Δ",
      Epsilon: "Ε",
      Zeta: "Ζ",
      Eta: "Η",
      Theta: "Θ",
      Iota: "Ι",
      Kappa: "Κ",
      Lambda: "Λ",
      Mu: "Μ",
      Nu: "Ν",
      Xi: "Ξ",
      Omicron: "Ο",
      Pi: "Π",
      Rho: "Ρ",
      Sigma: "Σ",
      Tau: "Τ",
      Upsilon: "Υ",
      Phi: "Φ",
      Chi: "Χ",
      Psi: "Ψ",
      Omega: "Ω",
      alpha: "α",
      beta: "β",
      gamma: "γ",
      delta: "δ",
      epsilon: "ε",
      zeta: "ζ",
      eta: "η",
      theta: "θ",
      iota: "ι",
      kappa: "κ",
      lambda: "λ",
      mu: "μ",
      nu: "ν",
      xi: "ξ",
      omicron: "ο",
      pi: "π",
      rho: "ρ",
      sigmaf: "ς",
      sigma: "σ",
      tau: "τ",
      upsilon: "υ",
      phi: "φ",
      chi: "χ",
      psi: "ψ",
      omega: "ω",
      thetasym: "ϑ",
      upsih: "ϒ",
      piv: "ϖ",
      ensp: " ",
      emsp: " ",
      thinsp: " ",
      zwnj: "‌",
      zwj: "‍",
      lrm: "‎",
      rlm: "‏",
      ndash: "–",
      mdash: "—",
      lsquo: "‘",
      rsquo: "’",
      sbquo: "‚",
      ldquo: "“",
      rdquo: "”",
      bdquo: "„",
      dagger: "†",
      Dagger: "‡",
      bull: "•",
      hellip: "…",
      permil: "‰",
      prime: "′",
      Prime: "″",
      lsaquo: "‹",
      rsaquo: "›",
      oline: "‾",
      frasl: "⁄",
      euro: "€",
      image: "ℑ",
      weierp: "℘",
      real: "ℜ",
      trade: "™",
      alefsym: "ℵ",
      larr: "←",
      uarr: "↑",
      rarr: "→",
      darr: "↓",
      harr: "↔",
      crarr: "↵",
      lArr: "⇐",
      uArr: "⇑",
      rArr: "⇒",
      dArr: "⇓",
      hArr: "⇔",
      forall: "∀",
      part: "∂",
      exist: "∃",
      empty: "∅",
      nabla: "∇",
      isin: "∈",
      notin: "∉",
      ni: "∋",
      prod: "∏",
      sum: "∑",
      minus: "−",
      lowast: "∗",
      radic: "√",
      prop: "∝",
      infin: "∞",
      ang: "∠",
      and: "∧",
      or: "∨",
      cap: "∩",
      cup: "∪",
      "int": "∫",
      there4: "∴",
      sim: "∼",
      cong: "≅",
      asymp: "≈",
      ne: "≠",
      equiv: "≡",
      le: "≤",
      ge: "≥",
      sub: "⊂",
      sup: "⊃",
      nsub: "⊄",
      sube: "⊆",
      supe: "⊇",
      oplus: "⊕",
      otimes: "⊗",
      perp: "⊥",
      sdot: "⋅",
      lceil: "⌈",
      rceil: "⌉",
      lfloor: "⌊",
      rfloor: "⌋",
      lang: "〈",
      rang: "〉",
      loz: "◊",
      spades: "♠",
      clubs: "♣",
      hearts: "♥",
      diams: "♦"
    };
  }
});

// node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "node_modules/acorn/dist/acorn.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports, function(exports2) {
      "use strict";
      var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars2 = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
      var nonASCIIidentifierStartChars2 = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
      var reservedWords2 = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$12 = {
        5: ecma5AndLessKeywords2,
        "5module": ecma5AndLessKeywords2 + " export import",
        6: ecma5AndLessKeywords2 + " const class extends export import super"
      };
      var keywordRelationalOperator2 = /^in(stanceof)?$/;
      var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
      var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
      function isInAstralSet2(code4, set2) {
        var pos = 65536;
        for (var i3 = 0; i3 < set2.length; i3 += 2) {
          pos += set2[i3];
          if (pos > code4) {
            return false;
          }
          pos += set2[i3 + 1];
          if (pos >= code4) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart2(code4, astral) {
        if (code4 < 65) {
          return code4 === 36;
        }
        if (code4 < 91) {
          return true;
        }
        if (code4 < 97) {
          return code4 === 95;
        }
        if (code4 < 123) {
          return true;
        }
        if (code4 <= 65535) {
          return code4 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code4));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet2(code4, astralIdentifierStartCodes2);
      }
      function isIdentifierChar2(code4, astral) {
        if (code4 < 48) {
          return code4 === 36;
        }
        if (code4 < 58) {
          return true;
        }
        if (code4 < 65) {
          return false;
        }
        if (code4 < 91) {
          return true;
        }
        if (code4 < 97) {
          return code4 === 95;
        }
        if (code4 < 123) {
          return true;
        }
        if (code4 <= 65535) {
          return code4 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code4));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet2(code4, astralIdentifierStartCodes2) || isInAstralSet2(code4, astralIdentifierCodes2);
      }
      var TokenType3 = function TokenType4(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop2(name2, prec) {
        return new TokenType3(name2, { beforeExpr: true, binop: prec });
      }
      var beforeExpr2 = { beforeExpr: true }, startsExpr2 = { startsExpr: true };
      var keywords2 = {};
      function kw2(name2, options) {
        if (options === void 0) options = {};
        options.keyword = name2;
        return keywords2[name2] = new TokenType3(name2, options);
      }
      var types$12 = {
        num: new TokenType3("num", startsExpr2),
        regexp: new TokenType3("regexp", startsExpr2),
        string: new TokenType3("string", startsExpr2),
        name: new TokenType3("name", startsExpr2),
        privateId: new TokenType3("privateId", startsExpr2),
        eof: new TokenType3("eof"),
        // Punctuation token types.
        bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType3("]"),
        braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType3("}"),
        parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType3(")"),
        comma: new TokenType3(",", beforeExpr2),
        semi: new TokenType3(";", beforeExpr2),
        colon: new TokenType3(":", beforeExpr2),
        dot: new TokenType3("."),
        question: new TokenType3("?", beforeExpr2),
        questionDot: new TokenType3("?."),
        arrow: new TokenType3("=>", beforeExpr2),
        template: new TokenType3("template"),
        invalidTemplate: new TokenType3("invalidTemplate"),
        ellipsis: new TokenType3("...", beforeExpr2),
        backQuote: new TokenType3("`", startsExpr2),
        dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType3("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop2("||", 1),
        logicalAND: binop2("&&", 2),
        bitwiseOR: binop2("|", 3),
        bitwiseXOR: binop2("^", 4),
        bitwiseAND: binop2("&", 5),
        equality: binop2("==/!=/===/!==", 6),
        relational: binop2("</>/<=/>=", 7),
        bitShift: binop2("<</>>/>>>", 8),
        plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop2("%", 10),
        star: binop2("*", 10),
        slash: binop2("/", 10),
        starstar: new TokenType3("**", { beforeExpr: true }),
        coalesce: binop2("??", 1),
        // Keyword token types.
        _break: kw2("break"),
        _case: kw2("case", beforeExpr2),
        _catch: kw2("catch"),
        _continue: kw2("continue"),
        _debugger: kw2("debugger"),
        _default: kw2("default", beforeExpr2),
        _do: kw2("do", { isLoop: true, beforeExpr: true }),
        _else: kw2("else", beforeExpr2),
        _finally: kw2("finally"),
        _for: kw2("for", { isLoop: true }),
        _function: kw2("function", startsExpr2),
        _if: kw2("if"),
        _return: kw2("return", beforeExpr2),
        _switch: kw2("switch"),
        _throw: kw2("throw", beforeExpr2),
        _try: kw2("try"),
        _var: kw2("var"),
        _const: kw2("const"),
        _while: kw2("while", { isLoop: true }),
        _with: kw2("with"),
        _new: kw2("new", { beforeExpr: true, startsExpr: true }),
        _this: kw2("this", startsExpr2),
        _super: kw2("super", startsExpr2),
        _class: kw2("class", startsExpr2),
        _extends: kw2("extends", beforeExpr2),
        _export: kw2("export"),
        _import: kw2("import", startsExpr2),
        _null: kw2("null", startsExpr2),
        _true: kw2("true", startsExpr2),
        _false: kw2("false", startsExpr2),
        _in: kw2("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak2 = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG2 = new RegExp(lineBreak2.source, "g");
      function isNewLine2(code4) {
        return code4 === 10 || code4 === 13 || code4 === 8232 || code4 === 8233;
      }
      function nextLineBreak2(code4, from2, end) {
        if (end === void 0) end = code4.length;
        for (var i3 = from2; i3 < end; i3++) {
          var next = code4.charCodeAt(i3);
          if (isNewLine2(next)) {
            return i3 < end - 1 && next === 13 && code4.charCodeAt(i3 + 1) === 10 ? i3 + 2 : i3 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref2 = Object.prototype;
      var hasOwnProperty4 = ref2.hasOwnProperty;
      var toString4 = ref2.toString;
      var hasOwn2 = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty4.call(obj, propName);
      };
      var isArray3 = Array.isArray || function(obj) {
        return toString4.call(obj) === "[object Array]";
      };
      var regexpCache2 = /* @__PURE__ */ Object.create(null);
      function wordsRegexp2(words) {
        return regexpCache2[words] || (regexpCache2[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString2(code4) {
        if (code4 <= 65535) {
          return String.fromCharCode(code4);
        }
        code4 -= 65536;
        return String.fromCharCode((code4 >> 10) + 55296, (code4 & 1023) + 56320);
      }
      var loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position3 = function Position4(line, col) {
        this.line = line;
        this.column = col;
      };
      Position3.prototype.offset = function offset5(n2) {
        return new Position3(this.line, this.column + n2);
      };
      var SourceLocation3 = function SourceLocation4(p, start2, end) {
        this.start = start2;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo2(input, offset5) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak2(input, cur, offset5);
          if (nextBreak < 0) {
            return new Position3(line, offset5 - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions2 = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion2 = false;
      function getOptions3(opts) {
        var options = {};
        for (var opt in defaultOptions2) {
          options[opt] = opts && hasOwn2(opts, opt) ? opts[opt] : defaultOptions2[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion2 && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion2 = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray3(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray3(options.onComment)) {
          options.onComment = pushComment2(options, options.onComment);
        }
        return options;
      }
      function pushComment2(options, array) {
        return function(block4, text7, start2, end, startLoc, endLoc) {
          var comment2 = {
            type: block4 ? "Block" : "Line",
            value: text7,
            start: start2,
            end
          };
          if (options.locations) {
            comment2.loc = new SourceLocation3(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment2.range = [start2, end];
          }
          array.push(comment2);
        };
      }
      var SCOPE_TOP2 = 1, SCOPE_FUNCTION2 = 2, SCOPE_ASYNC2 = 4, SCOPE_GENERATOR2 = 8, SCOPE_ARROW2 = 16, SCOPE_SIMPLE_CATCH2 = 32, SCOPE_SUPER2 = 64, SCOPE_DIRECT_SUPER2 = 128, SCOPE_CLASS_STATIC_BLOCK2 = 256, SCOPE_VAR2 = SCOPE_TOP2 | SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2;
      function functionFlags2(async, generator) {
        return SCOPE_FUNCTION2 | (async ? SCOPE_ASYNC2 : 0) | (generator ? SCOPE_GENERATOR2 : 0);
      }
      var BIND_NONE2 = 0, BIND_VAR2 = 1, BIND_LEXICAL2 = 2, BIND_FUNCTION2 = 3, BIND_SIMPLE_CATCH2 = 4, BIND_OUTSIDE2 = 5;
      var Parser3 = function Parser4(options, input, startPos) {
        this.options = options = getOptions3(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp2(keywords$12[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords2[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp2(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
        this.reservedWordsStrict = wordsRegexp2(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$12.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP2);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser3.prototype.parse = function parse6() {
        var node3 = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node3);
      };
      prototypeAccessors2.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION2) > 0;
      };
      prototypeAccessors2.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR2) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors2.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC2) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors2.canAwait.get = function() {
        for (var i3 = this.scopeStack.length - 1; i3 >= 0; i3--) {
          var scope = this.scopeStack[i3];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK2) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION2) {
            return (scope.flags & SCOPE_ASYNC2) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors2.allowSuper.get = function() {
        var ref3 = this.currentThisScope();
        var flags = ref3.flags;
        var inClassFieldInit = ref3.inClassFieldInit;
        return (flags & SCOPE_SUPER2) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors2.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER2) > 0;
      };
      prototypeAccessors2.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors2.allowNewDotTarget.get = function() {
        var ref3 = this.currentThisScope();
        var flags = ref3.flags;
        var inClassFieldInit = ref3.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2)) > 0 || inClassFieldInit;
      };
      prototypeAccessors2.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK2) > 0;
      };
      Parser3.extend = function extend2() {
        var plugins = [], len = arguments.length;
        while (len--) plugins[len] = arguments[len];
        var cls = this;
        for (var i3 = 0; i3 < plugins.length; i3++) {
          cls = plugins[i3](cls);
        }
        return cls;
      };
      Parser3.parse = function parse6(input, options) {
        return new this(options, input).parse();
      };
      Parser3.parseExpressionAt = function parseExpressionAt3(input, pos, options) {
        var parser2 = new this(options, input, pos);
        parser2.nextToken();
        return parser2.parseExpression();
      };
      Parser3.tokenizer = function tokenizer4(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser3.prototype, prototypeAccessors2);
      var pp$92 = Parser3.prototype;
      var literal2 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/s;
      pp$92.strictDirective = function(start2) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace2.lastIndex = start2;
          start2 += skipWhiteSpace2.exec(this.input)[0].length;
          var match2 = literal2.exec(this.input.slice(start2));
          if (!match2) {
            return false;
          }
          if ((match2[1] || match2[2]) === "use strict") {
            skipWhiteSpace2.lastIndex = start2 + match2[0].length;
            var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start2 += match2[0].length;
          skipWhiteSpace2.lastIndex = start2;
          start2 += skipWhiteSpace2.exec(this.input)[0].length;
          if (this.input[start2] === ";") {
            start2++;
          }
        }
      };
      pp$92.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$92.isContextual = function(name2) {
        return this.type === types$12.name && this.value === name2 && !this.containsEsc;
      };
      pp$92.eatContextual = function(name2) {
        if (!this.isContextual(name2)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$92.expectContextual = function(name2) {
        if (!this.eatContextual(name2)) {
          this.unexpected();
        }
      };
      pp$92.canInsertSemicolon = function() {
        return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$92.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$92.semicolon = function() {
        if (!this.eat(types$12.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$92.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$92.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$92.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors3 = function DestructuringErrors4() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$92.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$92.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$82 = Parser3.prototype;
      pp$82.parseTopLevel = function(node3) {
        var exports3 = /* @__PURE__ */ Object.create(null);
        if (!node3.body) {
          node3.body = [];
        }
        while (this.type !== types$12.eof) {
          var stmt = this.parseStatement(null, true, exports3);
          node3.body.push(stmt);
        }
        if (this.inModule) {
          for (var i3 = 0, list6 = Object.keys(this.undefinedExports); i3 < list6.length; i3 += 1) {
            var name2 = list6[i3];
            this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node3.body);
        this.next();
        node3.sourceType = this.options.sourceType;
        return this.finishNode(node3, "Program");
      };
      var loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" };
      pp$82.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart2(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator2.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$82.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak2.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar2(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$82.parseStatement = function(context, topLevel, exports3) {
        var starttype = this.type, node3 = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$12._var;
          kind = "let";
        }
        switch (starttype) {
          case types$12._break:
          case types$12._continue:
            return this.parseBreakContinueStatement(node3, starttype.keyword);
          case types$12._debugger:
            return this.parseDebuggerStatement(node3);
          case types$12._do:
            return this.parseDoStatement(node3);
          case types$12._for:
            return this.parseForStatement(node3);
          case types$12._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node3, false, !context);
          case types$12._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node3, true);
          case types$12._if:
            return this.parseIfStatement(node3);
          case types$12._return:
            return this.parseReturnStatement(node3);
          case types$12._switch:
            return this.parseSwitchStatement(node3);
          case types$12._throw:
            return this.parseThrowStatement(node3);
          case types$12._try:
            return this.parseTryStatement(node3);
          case types$12._const:
          case types$12._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node3, kind);
          case types$12._while:
            return this.parseWhileStatement(node3);
          case types$12._with:
            return this.parseWithStatement(node3);
          case types$12.braceL:
            return this.parseBlock(true, node3);
          case types$12.semi:
            return this.parseEmptyStatement(node3);
          case types$12._export:
          case types$12._import:
            if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
              skipWhiteSpace2.lastIndex = this.pos;
              var skip = skipWhiteSpace2.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node3, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$12._import ? this.parseImport(node3) : this.parseExport(node3, exports3);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node3, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$12.name && expr.type === "Identifier" && this.eat(types$12.colon)) {
              return this.parseLabeledStatement(node3, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node3, expr);
            }
        }
      };
      pp$82.parseBreakContinueStatement = function(node3, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$12.semi) || this.insertSemicolon()) {
          node3.label = null;
        } else if (this.type !== types$12.name) {
          this.unexpected();
        } else {
          node3.label = this.parseIdent();
          this.semicolon();
        }
        var i3 = 0;
        for (; i3 < this.labels.length; ++i3) {
          var lab = this.labels[i3];
          if (node3.label == null || lab.name === node3.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node3.label && isBreak) {
              break;
            }
          }
        }
        if (i3 === this.labels.length) {
          this.raise(node3.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node3, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$82.parseDebuggerStatement = function(node3) {
        this.next();
        this.semicolon();
        return this.finishNode(node3, "DebuggerStatement");
      };
      pp$82.parseDoStatement = function(node3) {
        this.next();
        this.labels.push(loopLabel2);
        node3.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$12._while);
        node3.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$12.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node3, "DoWhileStatement");
      };
      pp$82.parseForStatement = function(node3) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel2);
        this.enterScope(0);
        this.expect(types$12.parenL);
        if (this.type === types$12.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node3, null);
        }
        var isLet = this.isLet();
        if (this.type === types$12._var || this.type === types$12._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$12._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node3.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node3, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node3, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors3();
        var initPos = this.start;
        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$12._in) {
              this.unexpected(awaitAt);
            }
            node3.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node3.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node3, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node3, init);
      };
      pp$82.parseFunctionStatement = function(node3, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node3, FUNC_STATEMENT2 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
      };
      pp$82.parseIfStatement = function(node3) {
        this.next();
        node3.test = this.parseParenExpression();
        node3.consequent = this.parseStatement("if");
        node3.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null;
        return this.finishNode(node3, "IfStatement");
      };
      pp$82.parseReturnStatement = function(node3) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$12.semi) || this.insertSemicolon()) {
          node3.argument = null;
        } else {
          node3.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node3, "ReturnStatement");
      };
      pp$82.parseSwitchStatement = function(node3) {
        this.next();
        node3.discriminant = this.parseParenExpression();
        node3.cases = [];
        this.expect(types$12.braceL);
        this.labels.push(switchLabel2);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$12.braceR; ) {
          if (this.type === types$12._case || this.type === types$12._default) {
            var isCase = this.type === types$12._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node3.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$12.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node3, "SwitchStatement");
      };
      pp$82.parseThrowStatement = function(node3) {
        this.next();
        if (lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node3.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node3, "ThrowStatement");
      };
      var empty$12 = [];
      pp$82.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH2 : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH2 : BIND_LEXICAL2);
        this.expect(types$12.parenR);
        return param;
      };
      pp$82.parseTryStatement = function(node3) {
        this.next();
        node3.block = this.parseBlock();
        node3.handler = null;
        if (this.type === types$12._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$12.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node3.handler = this.finishNode(clause, "CatchClause");
        }
        node3.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null;
        if (!node3.handler && !node3.finalizer) {
          this.raise(node3.start, "Missing catch or finally clause");
        }
        return this.finishNode(node3, "TryStatement");
      };
      pp$82.parseVarStatement = function(node3, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node3, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node3, "VariableDeclaration");
      };
      pp$82.parseWhileStatement = function(node3) {
        this.next();
        node3.test = this.parseParenExpression();
        this.labels.push(loopLabel2);
        node3.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node3, "WhileStatement");
      };
      pp$82.parseWithStatement = function(node3) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node3.object = this.parseParenExpression();
        node3.body = this.parseStatement("with");
        return this.finishNode(node3, "WithStatement");
      };
      pp$82.parseEmptyStatement = function(node3) {
        this.next();
        return this.finishNode(node3, "EmptyStatement");
      };
      pp$82.parseLabeledStatement = function(node3, maybeName, expr, context) {
        for (var i$12 = 0, list6 = this.labels; i$12 < list6.length; i$12 += 1) {
          var label = list6[i$12];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null;
        for (var i3 = this.labels.length - 1; i3 >= 0; i3--) {
          var label$1 = this.labels[i3];
          if (label$1.statementStart === node3.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node3.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node3.label = expr;
        return this.finishNode(node3, "LabeledStatement");
      };
      pp$82.parseExpressionStatement = function(node3, expr) {
        node3.expression = expr;
        this.semicolon();
        return this.finishNode(node3, "ExpressionStatement");
      };
      pp$82.parseBlock = function(createNewLexicalScope, node3, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node3 === void 0) node3 = this.startNode();
        node3.body = [];
        this.expect(types$12.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$12.braceR) {
          var stmt = this.parseStatement(null);
          node3.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node3, "BlockStatement");
      };
      pp$82.parseFor = function(node3, init) {
        node3.init = init;
        this.expect(types$12.semi);
        node3.test = this.type === types$12.semi ? null : this.parseExpression();
        this.expect(types$12.semi);
        node3.update = this.type === types$12.parenR ? null : this.parseExpression();
        this.expect(types$12.parenR);
        node3.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node3, "ForStatement");
      };
      pp$82.parseForIn = function(node3, init) {
        var isForIn = this.type === types$12._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node3.left = init;
        node3.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$12.parenR);
        node3.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node3, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$82.parseVar = function(node3, isFor, kind, allowMissingInitializer) {
        node3.declarations = [];
        node3.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$12.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$12._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node3.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$12.comma)) {
            break;
          }
        }
        return node3;
      };
      pp$82.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR2 : BIND_LEXICAL2, false);
      };
      var FUNC_STATEMENT2 = 1, FUNC_HANGING_STATEMENT2 = 2, FUNC_NULLABLE_ID2 = 4;
      pp$82.parseFunction = function(node3, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node3);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2) {
            this.unexpected();
          }
          node3.generator = this.eat(types$12.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node3.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT2) {
          node3.id = statement & FUNC_NULLABLE_ID2 && this.type !== types$12.name ? null : this.parseIdent();
          if (node3.id && !(statement & FUNC_HANGING_STATEMENT2)) {
            this.checkLValSimple(node3.id, this.strict || node3.generator || node3.async ? this.treatFunctionsAsVar ? BIND_VAR2 : BIND_LEXICAL2 : BIND_FUNCTION2);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(node3.async, node3.generator));
        if (!(statement & FUNC_STATEMENT2)) {
          node3.id = this.type === types$12.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node3);
        this.parseFunctionBody(node3, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node3, statement & FUNC_STATEMENT2 ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$82.parseFunctionParams = function(node3) {
        this.expect(types$12.parenL);
        node3.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$82.parseClass = function(node3, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node3, isStatement);
        this.parseClassSuper(node3);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$12.braceL);
        while (this.type !== types$12.braceR) {
          var element3 = this.parseClassElement(node3.superClass !== null);
          if (element3) {
            classBody.body.push(element3);
            if (element3.type === "MethodDefinition" && element3.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element3.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element3.key && element3.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element3)) {
              this.raiseRecoverable(element3.key.start, "Identifier '#" + element3.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node3.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node3, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$82.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$12.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node3 = this.startNode();
        var keyName2 = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$12.braceL)) {
            this.parseClassStaticBlock(node3);
            return node3;
          }
          if (this.isClassElementNameStart() || this.type === types$12.star) {
            isStatic = true;
          } else {
            keyName2 = "static";
          }
        }
        node3.static = isStatic;
        if (!keyName2 && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$12.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName2 = "async";
          }
        }
        if (!keyName2 && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$12.star)) {
          isGenerator = true;
        }
        if (!keyName2 && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName2 = lastValue;
            }
          }
        }
        if (keyName2) {
          node3.computed = false;
          node3.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node3.key.name = keyName2;
          this.finishNode(node3.key, "Identifier");
        } else {
          this.parseClassElementName(node3);
        }
        if (ecmaVersion2 < 13 || this.type === types$12.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node3.static && checkKeyName2(node3, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node3.key.start, "Constructor can't have get/set modifier");
          }
          node3.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node3, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node3);
        }
        return node3;
      };
      pp$82.isClassElementNameStart = function() {
        return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
      };
      pp$82.parseClassElementName = function(element3) {
        if (this.type === types$12.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element3.computed = false;
          element3.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element3);
        }
      };
      pp$82.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key3 = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key3.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key3.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName2(method, "prototype")) {
          this.raise(key3.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$82.parseClassField = function(field) {
        if (checkKeyName2(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName2(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$12.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$82.parseClassStaticBlock = function(node3) {
        node3.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_SUPER2);
        while (this.type !== types$12.braceR) {
          var stmt = this.parseStatement(null);
          node3.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node3, "StaticBlock");
      };
      pp$82.parseClassId = function(node3, isStatement) {
        if (this.type === types$12.name) {
          node3.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node3.id, BIND_LEXICAL2, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node3.id = null;
        }
      };
      pp$82.parseClassSuper = function(node3) {
        node3.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$82.enterClassBody = function() {
        var element3 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element3);
        return element3.declared;
      };
      pp$82.exitClassBody = function() {
        var ref3 = this.privateNameStack.pop();
        var declared = ref3.declared;
        var used = ref3.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i3 = 0; i3 < used.length; ++i3) {
          var id = used[i3];
          if (!hasOwn2(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted2(privateNameMap, element3) {
        var name2 = element3.key.name;
        var curr = privateNameMap[name2];
        var next = "true";
        if (element3.type === "MethodDefinition" && (element3.kind === "get" || element3.kind === "set")) {
          next = (element3.static ? "s" : "i") + element3.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name2] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name2] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName2(node3, name2) {
        var computed = node3.computed;
        var key3 = node3.key;
        return !computed && (key3.type === "Identifier" && key3.name === name2 || key3.type === "Literal" && key3.value === name2);
      }
      pp$82.parseExportAllDeclaration = function(node3, exports3) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node3.exported = this.parseModuleExportName();
            this.checkExport(exports3, node3.exported, this.lastTokStart);
          } else {
            node3.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$12.string) {
          this.unexpected();
        }
        node3.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node3, "ExportAllDeclaration");
      };
      pp$82.parseExport = function(node3, exports3) {
        this.next();
        if (this.eat(types$12.star)) {
          return this.parseExportAllDeclaration(node3, exports3);
        }
        if (this.eat(types$12._default)) {
          this.checkExport(exports3, "default", this.lastTokStart);
          node3.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node3, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node3.declaration = this.parseExportDeclaration(node3);
          if (node3.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports3, node3.declaration.declarations);
          } else {
            this.checkExport(exports3, node3.declaration.id, node3.declaration.id.start);
          }
          node3.specifiers = [];
          node3.source = null;
        } else {
          node3.declaration = null;
          node3.specifiers = this.parseExportSpecifiers(exports3);
          if (this.eatContextual("from")) {
            if (this.type !== types$12.string) {
              this.unexpected();
            }
            node3.source = this.parseExprAtom();
          } else {
            for (var i3 = 0, list6 = node3.specifiers; i3 < list6.length; i3 += 1) {
              var spec = list6[i3];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node3.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node3, "ExportNamedDeclaration");
      };
      pp$82.parseExportDeclaration = function(node3) {
        return this.parseStatement(null);
      };
      pp$82.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT2 | FUNC_NULLABLE_ID2, false, isAsync);
        } else if (this.type === types$12._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$82.checkExport = function(exports3, name2, pos) {
        if (!exports3) {
          return;
        }
        if (typeof name2 !== "string") {
          name2 = name2.type === "Identifier" ? name2.name : name2.value;
        }
        if (hasOwn2(exports3, name2)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
        }
        exports3[name2] = true;
      };
      pp$82.checkPatternExport = function(exports3, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports3, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i3 = 0, list6 = pat.properties; i3 < list6.length; i3 += 1) {
            var prop = list6[i3];
            this.checkPatternExport(exports3, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$12 = 0, list$1 = pat.elements; i$12 < list$1.length; i$12 += 1) {
            var elt = list$1[i$12];
            if (elt) {
              this.checkPatternExport(exports3, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports3, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports3, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports3, pat.argument);
        }
      };
      pp$82.checkVariableExport = function(exports3, decls) {
        if (!exports3) {
          return;
        }
        for (var i3 = 0, list6 = decls; i3 < list6.length; i3 += 1) {
          var decl = list6[i3];
          this.checkPatternExport(exports3, decl.id);
        }
      };
      pp$82.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$82.parseExportSpecifier = function(exports3) {
        var node3 = this.startNode();
        node3.local = this.parseModuleExportName();
        node3.exported = this.eatContextual("as") ? this.parseModuleExportName() : node3.local;
        this.checkExport(
          exports3,
          node3.exported,
          node3.exported.start
        );
        return this.finishNode(node3, "ExportSpecifier");
      };
      pp$82.parseExportSpecifiers = function(exports3) {
        var nodes = [], first = true;
        this.expect(types$12.braceL);
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports3));
        }
        return nodes;
      };
      pp$82.parseImport = function(node3) {
        this.next();
        if (this.type === types$12.string) {
          node3.specifiers = empty$12;
          node3.source = this.parseExprAtom();
        } else {
          node3.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node3.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node3, "ImportDeclaration");
      };
      pp$82.parseImportSpecifier = function() {
        var node3 = this.startNode();
        node3.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node3.local = this.parseIdent();
        } else {
          this.checkUnreserved(node3.imported);
          node3.local = node3.imported;
        }
        this.checkLValSimple(node3.local, BIND_LEXICAL2);
        return this.finishNode(node3, "ImportSpecifier");
      };
      pp$82.parseImportDefaultSpecifier = function() {
        var node3 = this.startNode();
        node3.local = this.parseIdent();
        this.checkLValSimple(node3.local, BIND_LEXICAL2);
        return this.finishNode(node3, "ImportDefaultSpecifier");
      };
      pp$82.parseImportNamespaceSpecifier = function() {
        var node3 = this.startNode();
        this.next();
        this.expectContextual("as");
        node3.local = this.parseIdent();
        this.checkLValSimple(node3.local, BIND_LEXICAL2);
        return this.finishNode(node3, "ImportNamespaceSpecifier");
      };
      pp$82.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$12.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$12.comma)) {
            return nodes;
          }
        }
        if (this.type === types$12.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$12.braceL);
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$82.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate2.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$82.adaptDirectivePrologue = function(statements) {
        for (var i3 = 0; i3 < statements.length && this.isDirectiveCandidate(statements[i3]); ++i3) {
          statements[i3].directive = statements[i3].expression.raw.slice(1, -1);
        }
      };
      pp$82.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$72 = Parser3.prototype;
      pp$72.toAssignable = function(node3, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node3) {
          switch (node3.type) {
            case "Identifier":
              if (this.inAsync && node3.name === "await") {
                this.raise(node3.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node3.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i3 = 0, list6 = node3.properties; i3 < list6.length; i3 += 1) {
                var prop = list6[i3];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node3.kind !== "init") {
                this.raise(node3.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node3.value, isBinding);
              break;
            case "ArrayExpression":
              node3.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node3.elements, isBinding);
              break;
            case "SpreadElement":
              node3.type = "RestElement";
              this.toAssignable(node3.argument, isBinding);
              if (node3.argument.type === "AssignmentPattern") {
                this.raise(node3.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node3.operator !== "=") {
                this.raise(node3.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node3.type = "AssignmentPattern";
              delete node3.operator;
              this.toAssignable(node3.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node3.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node3.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node3.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node3;
      };
      pp$72.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i3 = 0; i3 < end; i3++) {
          var elt = exprList[i3];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$72.parseSpread = function(refDestructuringErrors) {
        var node3 = this.startNode();
        this.next();
        node3.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node3, "SpreadElement");
      };
      pp$72.parseRestBinding = function() {
        var node3 = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$12.name) {
          this.unexpected();
        }
        node3.argument = this.parseBindingAtom();
        return this.finishNode(node3, "RestElement");
      };
      pp$72.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$12.bracketL:
              var node3 = this.startNode();
              this.next();
              node3.elements = this.parseBindingList(types$12.bracketR, true, true);
              return this.finishNode(node3, "ArrayPattern");
            case types$12.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$72.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close2)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$12.comma);
          }
          if (allowEmpty && this.type === types$12.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
            break;
          } else if (this.type === types$12.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$12.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close2);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$72.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$72.parseBindingListItem = function(param) {
        return param;
      };
      pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$12.eq)) {
          return left;
        }
        var node3 = this.startNodeAt(startPos, startLoc);
        node3.left = left;
        node3.right = this.parseMaybeAssign();
        return this.finishNode(node3, "AssignmentPattern");
      };
      pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        var isBind = bindingType !== BIND_NONE2;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL2 && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn2(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE2) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i3 = 0, list6 = expr.properties; i3 < list6.length; i3 += 1) {
              var prop = list6[i3];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$12 = 0, list$1 = expr.elements; i$12 < list$1.length; i$12 += 1) {
              var elem = list$1[i$12];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext3 = function TokContext4(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types4 = {
        b_stat: new TokContext3("{", false),
        b_expr: new TokContext3("{", true),
        b_tmpl: new TokContext3("${", false),
        p_stat: new TokContext3("(", false),
        p_expr: new TokContext3("(", true),
        q_tmpl: new TokContext3("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext3("function", false),
        f_expr: new TokContext3("function", true),
        f_expr_gen: new TokContext3("function", true, false, null, true),
        f_gen: new TokContext3("function", false, false, null, true)
      };
      var pp$62 = Parser3.prototype;
      pp$62.initialContext = function() {
        return [types4.b_stat];
      };
      pp$62.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$62.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types4.f_expr || parent === types4.f_stat) {
          return true;
        }
        if (prevType === types$12.colon && (parent === types4.b_stat || parent === types4.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$12._return || prevType === types$12.name && this.exprAllowed) {
          return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow) {
          return true;
        }
        if (prevType === types$12.braceL) {
          return parent === types4.b_stat;
        }
        if (prevType === types$12._var || prevType === types$12._const || prevType === types$12.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$62.inGeneratorContext = function() {
        for (var i3 = this.context.length - 1; i3 >= 1; i3--) {
          var context = this.context[i3];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$62.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$12.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$62.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types4.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$12.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types4.b_stat : types4.b_expr);
        this.exprAllowed = true;
      };
      types$12.dollarBraceL.updateContext = function() {
        this.context.push(types4.b_tmpl);
        this.exprAllowed = true;
      };
      types$12.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
        this.context.push(statementParens ? types4.p_stat : types4.p_expr);
        this.exprAllowed = true;
      };
      types$12.incDec.updateContext = function() {
      };
      types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$12._else && !(prevType === types$12.semi && this.curContext() !== types4.p_stat) && !(prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types4.b_stat)) {
          this.context.push(types4.f_expr);
        } else {
          this.context.push(types4.f_stat);
        }
        this.exprAllowed = false;
      };
      types$12.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$12.backQuote.updateContext = function() {
        if (this.curContext() === types4.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types4.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$12.star.updateContext = function(prevType) {
        if (prevType === types$12._function) {
          var index4 = this.context.length - 1;
          if (this.context[index4] === types4.f_expr) {
            this.context[index4] = types4.f_expr_gen;
          } else {
            this.context[index4] = types4.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$12.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$12.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$52 = Parser3.prototype;
      pp$52.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key3 = prop.key;
        var name2;
        switch (key3.type) {
          case "Identifier":
            name2 = key3.name;
            break;
          case "Literal":
            name2 = String(key3.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name2 === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key3.start;
                }
              } else {
                this.raiseRecoverable(key3.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name2 = "$" + name2;
        var other = propHash[name2];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key3.start, "Redefinition of property");
          }
        } else {
          other = propHash[name2] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$52.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$12.comma) {
          var node3 = this.startNodeAt(startPos, startLoc);
          node3.expressions = [expr];
          while (this.eat(types$12.comma)) {
            node3.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node3, "SequenceExpression");
        }
        return expr;
      };
      pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors3();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$12.parenL || this.type === types$12.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node3 = this.startNodeAt(startPos, startLoc);
          node3.operator = this.value;
          if (this.type === types$12.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$12.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node3.left = left;
          this.next();
          node3.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node3, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$12.question)) {
          var node3 = this.startNodeAt(startPos, startLoc);
          node3.test = expr;
          node3.consequent = this.parseMaybeAssign();
          this.expect(types$12.colon);
          node3.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node3, "ConditionalExpression");
        }
        return expr;
      };
      pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$12._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND;
            var coalesce = this.type === types$12.coalesce;
            if (coalesce) {
              prec = types$12.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node3 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node3, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node3 = this.startNodeAt(startPos, startLoc);
        node3.left = left;
        node3.operator = op;
        node3.right = right;
        return this.finishNode(node3, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node3 = this.startNode(), update = this.type === types$12.incDec;
          node3.operator = this.value;
          node3.prefix = true;
          this.next();
          node3.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node3.argument);
          } else if (this.strict && node3.operator === "delete" && isLocalVariableAccess2(node3.argument)) {
            this.raiseRecoverable(node3.start, "Deleting local variable in strict mode");
          } else if (node3.operator === "delete" && isPrivateFieldAccess2(node3.argument)) {
            this.raiseRecoverable(node3.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node3, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$12.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$12._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$12.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess2(node3) {
        return node3.type === "Identifier" || node3.type === "ParenthesizedExpression" && isLocalVariableAccess2(node3.expression);
      }
      function isPrivateFieldAccess2(node3) {
        return node3.type === "MemberExpression" && node3.property.type === "PrivateIdentifier" || node3.type === "ChainExpression" && isPrivateFieldAccess2(node3.expression) || node3.type === "ParenthesizedExpression" && isPrivateFieldAccess2(node3.expression);
      }
      pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$52.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
        var optionalChained = false;
        while (true) {
          var element3 = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element3.optional) {
            optionalChained = true;
          }
          if (element3 === base2 || element3.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element3;
              element3 = this.finishNode(chainNode, "ChainExpression");
            }
            return element3;
          }
          base2 = element3;
        }
      };
      pp$52.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$12.arrow);
      };
      pp$52.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$52.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$12.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$12.bracketL);
        if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
          var node3 = this.startNodeAt(startPos, startLoc);
          node3.object = base2;
          if (computed) {
            node3.property = this.parseExpression();
            this.expect(types$12.bracketR);
          } else if (this.type === types$12.privateId && base2.type !== "Super") {
            node3.property = this.parsePrivateIdent();
          } else {
            node3.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node3.computed = !!computed;
          if (optionalSupported) {
            node3.optional = optional;
          }
          base2 = this.finishNode(node3, "MemberExpression");
        } else if (!noCalls && this.eat(types$12.parenL)) {
          var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base2;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base2 = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$12.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base2;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base2 = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base2;
      };
      pp$52.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$12.slash) {
          this.readRegexp();
        }
        var node3, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$12._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node3 = this.startNode();
            this.next();
            if (this.type === types$12.parenL && !this.allowDirectSuper) {
              this.raise(node3.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL) {
              this.unexpected();
            }
            return this.finishNode(node3, "Super");
          case types$12._this:
            node3 = this.startNode();
            this.next();
            return this.finishNode(node3, "ThisExpression");
          case types$12.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$12._function)) {
              this.overrideContext(types4.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$12.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$12.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$12.regexp:
            var value = this.value;
            node3 = this.parseLiteral(value.value);
            node3.regex = { pattern: value.pattern, flags: value.flags };
            return node3;
          case types$12.num:
          case types$12.string:
            return this.parseLiteral(this.value);
          case types$12._null:
          case types$12._true:
          case types$12._false:
            node3 = this.startNode();
            node3.value = this.type === types$12._null ? null : this.type === types$12._true;
            node3.raw = this.type.keyword;
            this.next();
            return this.finishNode(node3, "Literal");
          case types$12.parenL:
            var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start2;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start2;
              }
            }
            return expr;
          case types$12.bracketL:
            node3 = this.startNode();
            this.next();
            node3.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node3, "ArrayExpression");
          case types$12.braceL:
            this.overrideContext(types4.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$12._function:
            node3 = this.startNode();
            this.next();
            return this.parseFunction(node3, 0);
          case types$12._class:
            return this.parseClass(this.startNode(), false);
          case types$12._new:
            return this.parseNew();
          case types$12.backQuote:
            return this.parseTemplate();
          case types$12._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$52.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$52.parseExprImport = function(forNew) {
        var node3 = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$12.parenL && !forNew) {
          return this.parseDynamicImport(node3);
        } else if (this.type === types$12.dot) {
          var meta = this.startNodeAt(node3.start, node3.loc && node3.loc.start);
          meta.name = "import";
          node3.meta = this.finishNode(meta, "Identifier");
          return this.parseImportMeta(node3);
        } else {
          this.unexpected();
        }
      };
      pp$52.parseDynamicImport = function(node3) {
        this.next();
        node3.source = this.parseMaybeAssign();
        if (!this.eat(types$12.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$12.comma) && this.eat(types$12.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node3, "ImportExpression");
      };
      pp$52.parseImportMeta = function(node3) {
        this.next();
        var containsEsc = this.containsEsc;
        node3.property = this.parseIdent(true);
        if (node3.property.name !== "meta") {
          this.raiseRecoverable(node3.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node3.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node3.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node3, "MetaProperty");
      };
      pp$52.parseLiteral = function(value) {
        var node3 = this.startNode();
        node3.value = value;
        node3.raw = this.input.slice(this.start, this.end);
        if (node3.raw.charCodeAt(node3.raw.length - 1) === 110) {
          node3.bigint = node3.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node3, "Literal");
      };
      pp$52.parseParenExpression = function() {
        this.expect(types$12.parenL);
        var val = this.parseExpression();
        this.expect(types$12.parenR);
        return val;
      };
      pp$52.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$12.parenR) {
            first ? first = false : this.expect(types$12.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$12.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$12.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$12.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$12.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$52.parseParenItem = function(item2) {
        return item2;
      };
      pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty5 = [];
      pp$52.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node3 = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$12.dot) {
          var meta = this.startNodeAt(node3.start, node3.loc && node3.loc.start);
          meta.name = "new";
          node3.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node3.property = this.parseIdent(true);
          if (node3.property.name !== "target") {
            this.raiseRecoverable(node3.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node3.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node3.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node3, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node3.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$12.parenL)) {
          node3.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node3.arguments = empty5;
        }
        return this.finishNode(node3, "NewExpression");
      };
      pp$52.parseTemplateElement = function(ref3) {
        var isTagged = ref3.isTagged;
        var elem = this.startNode();
        if (this.type === types$12.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$12.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$52.parseTemplate = function(ref3) {
        if (ref3 === void 0) ref3 = {};
        var isTagged = ref3.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node3 = this.startNode();
        this.next();
        node3.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node3.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$12.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$12.dollarBraceL);
          node3.expressions.push(this.parseExpression());
          this.expect(types$12.braceR);
          node3.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node3, "TemplateLiteral");
      };
      pp$52.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$52.parseObj = function(isPattern, refDestructuringErrors) {
        var node3 = this.startNode(), first = true, propHash = {};
        node3.properties = [];
        this.next();
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node3.properties.push(prop);
        }
        return this.finishNode(node3, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$12.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$12.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$12.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$52.parseGetterSetter = function(prop) {
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start2 = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start2, "getter should have no params");
          } else {
            this.raiseRecoverable(start2, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$52.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$12.colon) {
          this.unexpected();
        }
        if (this.eat(types$12.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$12.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$12.comma && this.type !== types$12.braceR && this.type !== types$12.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$12.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$52.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$12.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$12.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$52.initFunction = function(node3) {
        node3.id = null;
        if (this.options.ecmaVersion >= 6) {
          node3.generator = node3.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node3.async = false;
        }
      };
      pp$52.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node3 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node3);
        if (this.options.ecmaVersion >= 6) {
          node3.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node3.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(isAsync, node3.generator) | SCOPE_SUPER2 | (allowDirectSuper ? SCOPE_DIRECT_SUPER2 : 0));
        this.expect(types$12.parenL);
        node3.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node3, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node3, "FunctionExpression");
      };
      pp$52.parseArrowExpression = function(node3, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags2(isAsync, false) | SCOPE_ARROW2);
        this.initFunction(node3);
        if (this.options.ecmaVersion >= 8) {
          node3.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node3.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node3, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node3, "ArrowFunctionExpression");
      };
      pp$52.parseFunctionBody = function(node3, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$12.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node3.body = this.parseMaybeAssign(forInit);
          node3.expression = true;
          this.checkParams(node3, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node3.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node3.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node3, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node3.params));
          if (this.strict && node3.id) {
            this.checkLValSimple(node3.id, BIND_OUTSIDE2);
          }
          node3.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node3.expression = false;
          this.adaptDirectivePrologue(node3.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$52.isSimpleParamList = function(params) {
        for (var i3 = 0, list6 = params; i3 < list6.length; i3 += 1) {
          var param = list6[i3];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$52.checkParams = function(node3, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i3 = 0, list6 = node3.params; i3 < list6.length; i3 += 1) {
          var param = list6[i3];
          this.checkLValInnerPattern(param, BIND_VAR2, allowDuplicates ? null : nameHash);
        }
      };
      pp$52.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close2)) {
          if (!first) {
            this.expect(types$12.comma);
            if (allowTrailingComma && this.afterTrailingComma(close2)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$12.comma) {
            elt = null;
          } else if (this.type === types$12.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$52.checkUnreserved = function(ref3) {
        var start2 = ref3.start;
        var end = ref3.end;
        var name2 = ref3.name;
        if (this.inGenerator && name2 === "yield") {
          this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name2 === "await") {
          this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
          this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
          this.raise(start2, "Cannot use " + name2 + " in class static initialization block");
        }
        if (this.keywords.test(name2)) {
          this.raise(start2, "Unexpected keyword '" + name2 + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start2, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name2)) {
          if (!this.inAsync && name2 === "await") {
            this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start2, "The keyword '" + name2 + "' is reserved");
        }
      };
      pp$52.parseIdent = function(liberal) {
        var node3 = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node3, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node3);
          if (node3.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node3.start;
          }
        }
        return node3;
      };
      pp$52.parseIdentNode = function() {
        var node3 = this.startNode();
        if (this.type === types$12.name) {
          node3.name = this.value;
        } else if (this.type.keyword) {
          node3.name = this.type.keyword;
          if ((node3.name === "class" || node3.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$12.name;
        } else {
          this.unexpected();
        }
        return node3;
      };
      pp$52.parsePrivateIdent = function() {
        var node3 = this.startNode();
        if (this.type === types$12.privateId) {
          node3.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node3, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node3.start, "Private field '#" + node3.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node3);
          }
        }
        return node3;
      };
      pp$52.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node3 = this.startNode();
        this.next();
        if (this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr) {
          node3.delegate = false;
          node3.argument = null;
        } else {
          node3.delegate = this.eat(types$12.star);
          node3.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node3, "YieldExpression");
      };
      pp$52.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node3 = this.startNode();
        this.next();
        node3.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node3, "AwaitExpression");
      };
      var pp$42 = Parser3.prototype;
      pp$42.raise = function(pos, message) {
        var loc = getLineInfo2(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$42.raiseRecoverable = pp$42.raise;
      pp$42.curPosition = function() {
        if (this.options.locations) {
          return new Position3(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$32 = Parser3.prototype;
      var Scope3 = function Scope4(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$32.enterScope = function(flags) {
        this.scopeStack.push(new Scope3(flags));
      };
      pp$32.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$32.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION2 || !this.inModule && scope.flags & SCOPE_TOP2;
      };
      pp$32.declareName = function(name2, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL2) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
          scope.lexical.push(name2);
          if (this.inModule && scope.flags & SCOPE_TOP2) {
            delete this.undefinedExports[name2];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH2) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name2);
        } else if (bindingType === BIND_FUNCTION2) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name2) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
          }
          scope$2.functions.push(name2);
        } else {
          for (var i3 = this.scopeStack.length - 1; i3 >= 0; --i3) {
            var scope$3 = this.scopeStack[i3];
            if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH2 && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name2);
            if (this.inModule && scope$3.flags & SCOPE_TOP2) {
              delete this.undefinedExports[name2];
            }
            if (scope$3.flags & SCOPE_VAR2) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
        }
      };
      pp$32.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$32.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$32.currentVarScope = function() {
        for (var i3 = this.scopeStack.length - 1; ; i3--) {
          var scope = this.scopeStack[i3];
          if (scope.flags & SCOPE_VAR2) {
            return scope;
          }
        }
      };
      pp$32.currentThisScope = function() {
        for (var i3 = this.scopeStack.length - 1; ; i3--) {
          var scope = this.scopeStack[i3];
          if (scope.flags & SCOPE_VAR2 && !(scope.flags & SCOPE_ARROW2)) {
            return scope;
          }
        }
      };
      var Node7 = function Node8(parser2, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser2.options.locations) {
          this.loc = new SourceLocation3(parser2, loc);
        }
        if (parser2.options.directSourceFile) {
          this.sourceFile = parser2.options.directSourceFile;
        }
        if (parser2.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$22 = Parser3.prototype;
      pp$22.startNode = function() {
        return new Node7(this, this.start, this.startLoc);
      };
      pp$22.startNodeAt = function(pos, loc) {
        return new Node7(this, pos, loc);
      };
      function finishNodeAt2(node3, type, pos, loc) {
        node3.type = type;
        node3.end = pos;
        if (this.options.locations) {
          node3.loc.end = loc;
        }
        if (this.options.ranges) {
          node3.range[1] = pos;
        }
        return node3;
      }
      pp$22.finishNode = function(node3, type) {
        return finishNodeAt2.call(this, node3, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$22.finishNodeAt = function(node3, type, pos, loc) {
        return finishNodeAt2.call(this, node3, type, pos, loc);
      };
      pp$22.copyNode = function(node3) {
        var newNode = new Node7(this, node3.start, this.startLoc);
        for (var prop in node3) {
          newNode[prop] = node3[prop];
        }
        return newNode;
      };
      var ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic";
      var ecma11BinaryProperties2 = ecma10BinaryProperties2;
      var ecma12BinaryProperties2 = ecma11BinaryProperties2 + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties2 = ecma12BinaryProperties2;
      var ecma14BinaryProperties2 = ecma13BinaryProperties2;
      var unicodeBinaryProperties2 = {
        9: ecma9BinaryProperties2,
        10: ecma10BinaryProperties2,
        11: ecma11BinaryProperties2,
        12: ecma12BinaryProperties2,
        13: ecma13BinaryProperties2,
        14: ecma14BinaryProperties2
      };
      var ecma14BinaryPropertiesOfStrings2 = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings2 = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings2
      };
      var unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues2 = ecma13ScriptValues2 + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
      var unicodeScriptValues2 = {
        9: ecma9ScriptValues2,
        10: ecma10ScriptValues2,
        11: ecma11ScriptValues2,
        12: ecma12ScriptValues2,
        13: ecma13ScriptValues2,
        14: ecma14ScriptValues2
      };
      var data2 = {};
      function buildUnicodeData2(ecmaVersion2) {
        var d = data2[ecmaVersion2] = {
          binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion2] + " " + unicodeGeneralCategoryValues2),
          binaryOfStrings: wordsRegexp2(unicodeBinaryPropertiesOfStrings2[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp2(unicodeGeneralCategoryValues2),
            Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i2 = 0, list5 = [9, 10, 11, 12, 13, 14]; i2 < list5.length; i2 += 1) {
        var ecmaVersion = list5[i2];
        buildUnicodeData2(ecmaVersion);
      }
      var pp$12 = Parser3.prototype;
      var BranchID3 = function BranchID4(parent, base2) {
        this.parent = parent;
        this.base = base2 || this;
      };
      BranchID3.prototype.separatedFrom = function separatedFrom2(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID3.prototype.sibling = function sibling2() {
        return new BranchID3(this.parent, this.base);
      };
      var RegExpValidationState3 = function RegExpValidationState4(parser2) {
        this.parser = parser2;
        this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "") + (parser2.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data2[parser2.options.ecmaVersion >= 14 ? 14 : parser2.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState3.prototype.reset = function reset2(start2, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start2 | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState3.prototype.raise = function raise2(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState3.prototype.at = function at2(i3, forceU) {
        if (forceU === void 0) forceU = false;
        var s2 = this.source;
        var l2 = s2.length;
        if (i3 >= l2) {
          return -1;
        }
        var c = s2.charCodeAt(i3);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i3 + 1 >= l2) {
          return c;
        }
        var next = s2.charCodeAt(i3 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState3.prototype.nextIndex = function nextIndex2(i3, forceU) {
        if (forceU === void 0) forceU = false;
        var s2 = this.source;
        var l2 = s2.length;
        if (i3 >= l2) {
          return l2;
        }
        var c = s2.charCodeAt(i3), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i3 + 1 >= l2 || (next = s2.charCodeAt(i3 + 1)) < 56320 || next > 57343) {
          return i3 + 1;
        }
        return i3 + 2;
      };
      RegExpValidationState3.prototype.current = function current2(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState3.prototype.lookahead = function lookahead2(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState3.prototype.advance = function advance2(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState3.prototype.eat = function eat2(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState3.prototype.eatChars = function eatChars2(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for (var i3 = 0, list6 = chs; i3 < list6.length; i3 += 1) {
          var ch = list6[i3];
          var current2 = this.at(pos, forceU);
          if (current2 === -1 || current2 !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$12.validateRegExpFlags = function(state2) {
        var validFlags = state2.validFlags;
        var flags = state2.flags;
        var u = false;
        var v = false;
        for (var i3 = 0; i3 < flags.length; i3++) {
          var flag = flags.charAt(i3);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state2.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i3 + 1) > -1) {
            this.raise(state2.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state2.start, "Invalid regular expression flag");
        }
      };
      function hasProp2(obj) {
        for (var _ in obj) {
          return true;
        }
        return false;
      }
      pp$12.validateRegExpPattern = function(state2) {
        this.regexp_pattern(state2);
        if (!state2.switchN && this.options.ecmaVersion >= 9 && hasProp2(state2.groupNames)) {
          state2.switchN = true;
          this.regexp_pattern(state2);
        }
      };
      pp$12.regexp_pattern = function(state2) {
        state2.pos = 0;
        state2.lastIntValue = 0;
        state2.lastStringValue = "";
        state2.lastAssertionIsQuantifiable = false;
        state2.numCapturingParens = 0;
        state2.maxBackReference = 0;
        state2.groupNames = /* @__PURE__ */ Object.create(null);
        state2.backReferenceNames.length = 0;
        state2.branchID = null;
        this.regexp_disjunction(state2);
        if (state2.pos !== state2.source.length) {
          if (state2.eat(
            41
            /* ) */
          )) {
            state2.raise("Unmatched ')'");
          }
          if (state2.eat(
            93
            /* ] */
          ) || state2.eat(
            125
            /* } */
          )) {
            state2.raise("Lone quantifier brackets");
          }
        }
        if (state2.maxBackReference > state2.numCapturingParens) {
          state2.raise("Invalid escape");
        }
        for (var i3 = 0, list6 = state2.backReferenceNames; i3 < list6.length; i3 += 1) {
          var name2 = list6[i3];
          if (!state2.groupNames[name2]) {
            state2.raise("Invalid named capture referenced");
          }
        }
      };
      pp$12.regexp_disjunction = function(state2) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state2.branchID = new BranchID3(state2.branchID, null);
        }
        this.regexp_alternative(state2);
        while (state2.eat(
          124
          /* | */
        )) {
          if (trackDisjunction) {
            state2.branchID = state2.branchID.sibling();
          }
          this.regexp_alternative(state2);
        }
        if (trackDisjunction) {
          state2.branchID = state2.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state2, true)) {
          state2.raise("Nothing to repeat");
        }
        if (state2.eat(
          123
          /* { */
        )) {
          state2.raise("Lone quantifier brackets");
        }
      };
      pp$12.regexp_alternative = function(state2) {
        while (state2.pos < state2.source.length && this.regexp_eatTerm(state2)) {
        }
      };
      pp$12.regexp_eatTerm = function(state2) {
        if (this.regexp_eatAssertion(state2)) {
          if (state2.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state2)) {
            if (state2.switchU) {
              state2.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state2.switchU ? this.regexp_eatAtom(state2) : this.regexp_eatExtendedAtom(state2)) {
          this.regexp_eatQuantifier(state2);
          return true;
        }
        return false;
      };
      pp$12.regexp_eatAssertion = function(state2) {
        var start2 = state2.pos;
        state2.lastAssertionIsQuantifiable = false;
        if (state2.eat(
          94
          /* ^ */
        ) || state2.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state2.eat(
          92
          /* \ */
        )) {
          if (state2.eat(
            66
            /* B */
          ) || state2.eat(
            98
            /* b */
          )) {
            return true;
          }
          state2.pos = start2;
        }
        if (state2.eat(
          40
          /* ( */
        ) && state2.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state2.eat(
              60
              /* < */
            );
          }
          if (state2.eat(
            61
            /* = */
          ) || state2.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state2);
            if (!state2.eat(
              41
              /* ) */
            )) {
              state2.raise("Unterminated group");
            }
            state2.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state2.pos = start2;
        return false;
      };
      pp$12.regexp_eatQuantifier = function(state2, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state2, noError)) {
          state2.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$12.regexp_eatQuantifierPrefix = function(state2, noError) {
        return state2.eat(
          42
          /* * */
        ) || state2.eat(
          43
          /* + */
        ) || state2.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state2, noError);
      };
      pp$12.regexp_eatBracedQuantifier = function(state2, noError) {
        var start2 = state2.pos;
        if (state2.eat(
          123
          /* { */
        )) {
          var min3 = 0, max4 = -1;
          if (this.regexp_eatDecimalDigits(state2)) {
            min3 = state2.lastIntValue;
            if (state2.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state2)) {
              max4 = state2.lastIntValue;
            }
            if (state2.eat(
              125
              /* } */
            )) {
              if (max4 !== -1 && max4 < min3 && !noError) {
                state2.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state2.switchU && !noError) {
            state2.raise("Incomplete quantifier");
          }
          state2.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatAtom = function(state2) {
        return this.regexp_eatPatternCharacters(state2) || state2.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state2) || this.regexp_eatCharacterClass(state2) || this.regexp_eatUncapturingGroup(state2) || this.regexp_eatCapturingGroup(state2);
      };
      pp$12.regexp_eatReverseSolidusAtomEscape = function(state2) {
        var start2 = state2.pos;
        if (state2.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state2)) {
            return true;
          }
          state2.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatUncapturingGroup = function(state2) {
        var start2 = state2.pos;
        if (state2.eat(
          40
          /* ( */
        )) {
          if (state2.eat(
            63
            /* ? */
          ) && state2.eat(
            58
            /* : */
          )) {
            this.regexp_disjunction(state2);
            if (state2.eat(
              41
              /* ) */
            )) {
              return true;
            }
            state2.raise("Unterminated group");
          }
          state2.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatCapturingGroup = function(state2) {
        if (state2.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state2);
          } else if (state2.current() === 63) {
            state2.raise("Invalid group");
          }
          this.regexp_disjunction(state2);
          if (state2.eat(
            41
            /* ) */
          )) {
            state2.numCapturingParens += 1;
            return true;
          }
          state2.raise("Unterminated group");
        }
        return false;
      };
      pp$12.regexp_eatExtendedAtom = function(state2) {
        return state2.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state2) || this.regexp_eatCharacterClass(state2) || this.regexp_eatUncapturingGroup(state2) || this.regexp_eatCapturingGroup(state2) || this.regexp_eatInvalidBracedQuantifier(state2) || this.regexp_eatExtendedPatternCharacter(state2);
      };
      pp$12.regexp_eatInvalidBracedQuantifier = function(state2) {
        if (this.regexp_eatBracedQuantifier(state2, true)) {
          state2.raise("Nothing to repeat");
        }
        return false;
      };
      pp$12.regexp_eatSyntaxCharacter = function(state2) {
        var ch = state2.current();
        if (isSyntaxCharacter2(ch)) {
          state2.lastIntValue = ch;
          state2.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter2(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$12.regexp_eatPatternCharacters = function(state2) {
        var start2 = state2.pos;
        var ch = 0;
        while ((ch = state2.current()) !== -1 && !isSyntaxCharacter2(ch)) {
          state2.advance();
        }
        return state2.pos !== start2;
      };
      pp$12.regexp_eatExtendedPatternCharacter = function(state2) {
        var ch = state2.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state2.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_groupSpecifier = function(state2) {
        if (state2.eat(
          63
          /* ? */
        )) {
          if (!this.regexp_eatGroupName(state2)) {
            state2.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state2.groupNames[state2.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i3 = 0, list6 = known; i3 < list6.length; i3 += 1) {
                var altID = list6[i3];
                if (!altID.separatedFrom(state2.branchID)) {
                  state2.raise("Duplicate capture group name");
                }
              }
            } else {
              state2.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state2.groupNames[state2.lastStringValue] = [])).push(state2.branchID);
          } else {
            state2.groupNames[state2.lastStringValue] = true;
          }
        }
      };
      pp$12.regexp_eatGroupName = function(state2) {
        state2.lastStringValue = "";
        if (state2.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state2) && state2.eat(
            62
            /* > */
          )) {
            return true;
          }
          state2.raise("Invalid capture group name");
        }
        return false;
      };
      pp$12.regexp_eatRegExpIdentifierName = function(state2) {
        state2.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state2)) {
          state2.lastStringValue += codePointToString2(state2.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state2)) {
            state2.lastStringValue += codePointToString2(state2.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_eatRegExpIdentifierStart = function(state2) {
        var start2 = state2.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state2.current(forceU);
        state2.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state2, forceU)) {
          ch = state2.lastIntValue;
        }
        if (isRegExpIdentifierStart2(ch)) {
          state2.lastIntValue = ch;
          return true;
        }
        state2.pos = start2;
        return false;
      };
      function isRegExpIdentifierStart2(ch) {
        return isIdentifierStart2(ch, true) || ch === 36 || ch === 95;
      }
      pp$12.regexp_eatRegExpIdentifierPart = function(state2) {
        var start2 = state2.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state2.current(forceU);
        state2.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state2, forceU)) {
          ch = state2.lastIntValue;
        }
        if (isRegExpIdentifierPart2(ch)) {
          state2.lastIntValue = ch;
          return true;
        }
        state2.pos = start2;
        return false;
      };
      function isRegExpIdentifierPart2(ch) {
        return isIdentifierChar2(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$12.regexp_eatAtomEscape = function(state2) {
        if (this.regexp_eatBackReference(state2) || this.regexp_eatCharacterClassEscape(state2) || this.regexp_eatCharacterEscape(state2) || state2.switchN && this.regexp_eatKGroupName(state2)) {
          return true;
        }
        if (state2.switchU) {
          if (state2.current() === 99) {
            state2.raise("Invalid unicode escape");
          }
          state2.raise("Invalid escape");
        }
        return false;
      };
      pp$12.regexp_eatBackReference = function(state2) {
        var start2 = state2.pos;
        if (this.regexp_eatDecimalEscape(state2)) {
          var n2 = state2.lastIntValue;
          if (state2.switchU) {
            if (n2 > state2.maxBackReference) {
              state2.maxBackReference = n2;
            }
            return true;
          }
          if (n2 <= state2.numCapturingParens) {
            return true;
          }
          state2.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatKGroupName = function(state2) {
        if (state2.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state2)) {
            state2.backReferenceNames.push(state2.lastStringValue);
            return true;
          }
          state2.raise("Invalid named reference");
        }
        return false;
      };
      pp$12.regexp_eatCharacterEscape = function(state2) {
        return this.regexp_eatControlEscape(state2) || this.regexp_eatCControlLetter(state2) || this.regexp_eatZero(state2) || this.regexp_eatHexEscapeSequence(state2) || this.regexp_eatRegExpUnicodeEscapeSequence(state2, false) || !state2.switchU && this.regexp_eatLegacyOctalEscapeSequence(state2) || this.regexp_eatIdentityEscape(state2);
      };
      pp$12.regexp_eatCControlLetter = function(state2) {
        var start2 = state2.pos;
        if (state2.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state2)) {
            return true;
          }
          state2.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatZero = function(state2) {
        if (state2.current() === 48 && !isDecimalDigit2(state2.lookahead())) {
          state2.lastIntValue = 0;
          state2.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatControlEscape = function(state2) {
        var ch = state2.current();
        if (ch === 116) {
          state2.lastIntValue = 9;
          state2.advance();
          return true;
        }
        if (ch === 110) {
          state2.lastIntValue = 10;
          state2.advance();
          return true;
        }
        if (ch === 118) {
          state2.lastIntValue = 11;
          state2.advance();
          return true;
        }
        if (ch === 102) {
          state2.lastIntValue = 12;
          state2.advance();
          return true;
        }
        if (ch === 114) {
          state2.lastIntValue = 13;
          state2.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatControlLetter = function(state2) {
        var ch = state2.current();
        if (isControlLetter2(ch)) {
          state2.lastIntValue = ch % 32;
          state2.advance();
          return true;
        }
        return false;
      };
      function isControlLetter2(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state2, forceU) {
        if (forceU === void 0) forceU = false;
        var start2 = state2.pos;
        var switchU = forceU || state2.switchU;
        if (state2.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state2, 4)) {
            var lead = state2.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state2.pos;
              if (state2.eat(
                92
                /* \ */
              ) && state2.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state2, 4)) {
                var trail2 = state2.lastIntValue;
                if (trail2 >= 56320 && trail2 <= 57343) {
                  state2.lastIntValue = (lead - 55296) * 1024 + (trail2 - 56320) + 65536;
                  return true;
                }
              }
              state2.pos = leadSurrogateEnd;
              state2.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state2.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state2) && state2.eat(
            125
            /* } */
          ) && isValidUnicode2(state2.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state2.raise("Invalid unicode escape");
          }
          state2.pos = start2;
        }
        return false;
      };
      function isValidUnicode2(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$12.regexp_eatIdentityEscape = function(state2) {
        if (state2.switchU) {
          if (this.regexp_eatSyntaxCharacter(state2)) {
            return true;
          }
          if (state2.eat(
            47
            /* / */
          )) {
            state2.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state2.current();
        if (ch !== 99 && (!state2.switchN || ch !== 107)) {
          state2.lastIntValue = ch;
          state2.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatDecimalEscape = function(state2) {
        state2.lastIntValue = 0;
        var ch = state2.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state2.lastIntValue = 10 * state2.lastIntValue + (ch - 48);
            state2.advance();
          } while ((ch = state2.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone2 = 0;
      var CharSetOk2 = 1;
      var CharSetString2 = 2;
      pp$12.regexp_eatCharacterClassEscape = function(state2) {
        var ch = state2.current();
        if (isCharacterClassEscape2(ch)) {
          state2.lastIntValue = -1;
          state2.advance();
          return CharSetOk2;
        }
        var negate = false;
        if (state2.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state2.lastIntValue = -1;
          state2.advance();
          var result;
          if (state2.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state2)) && state2.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString2) {
              state2.raise("Invalid property name");
            }
            return result;
          }
          state2.raise("Invalid property name");
        }
        return CharSetNone2;
      };
      function isCharacterClassEscape2(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$12.regexp_eatUnicodePropertyValueExpression = function(state2) {
        var start2 = state2.pos;
        if (this.regexp_eatUnicodePropertyName(state2) && state2.eat(
          61
          /* = */
        )) {
          var name2 = state2.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state2)) {
            var value = state2.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state2, name2, value);
            return CharSetOk2;
          }
        }
        state2.pos = start2;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state2)) {
          var nameOrValue = state2.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state2, nameOrValue);
        }
        return CharSetNone2;
      };
      pp$12.regexp_validateUnicodePropertyNameAndValue = function(state2, name2, value) {
        if (!hasOwn2(state2.unicodeProperties.nonBinary, name2)) {
          state2.raise("Invalid property name");
        }
        if (!state2.unicodeProperties.nonBinary[name2].test(value)) {
          state2.raise("Invalid property value");
        }
      };
      pp$12.regexp_validateUnicodePropertyNameOrValue = function(state2, nameOrValue) {
        if (state2.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk2;
        }
        if (state2.switchV && state2.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString2;
        }
        state2.raise("Invalid property name");
      };
      pp$12.regexp_eatUnicodePropertyName = function(state2) {
        var ch = 0;
        state2.lastStringValue = "";
        while (isUnicodePropertyNameCharacter2(ch = state2.current())) {
          state2.lastStringValue += codePointToString2(ch);
          state2.advance();
        }
        return state2.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter2(ch) {
        return isControlLetter2(ch) || ch === 95;
      }
      pp$12.regexp_eatUnicodePropertyValue = function(state2) {
        var ch = 0;
        state2.lastStringValue = "";
        while (isUnicodePropertyValueCharacter2(ch = state2.current())) {
          state2.lastStringValue += codePointToString2(ch);
          state2.advance();
        }
        return state2.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter2(ch) {
        return isUnicodePropertyNameCharacter2(ch) || isDecimalDigit2(ch);
      }
      pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state2) {
        return this.regexp_eatUnicodePropertyValue(state2);
      };
      pp$12.regexp_eatCharacterClass = function(state2) {
        if (state2.eat(
          91
          /* [ */
        )) {
          var negate = state2.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state2);
          if (!state2.eat(
            93
            /* ] */
          )) {
            state2.raise("Unterminated character class");
          }
          if (negate && result === CharSetString2) {
            state2.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_classContents = function(state2) {
        if (state2.current() === 93) {
          return CharSetOk2;
        }
        if (state2.switchV) {
          return this.regexp_classSetExpression(state2);
        }
        this.regexp_nonEmptyClassRanges(state2);
        return CharSetOk2;
      };
      pp$12.regexp_nonEmptyClassRanges = function(state2) {
        while (this.regexp_eatClassAtom(state2)) {
          var left = state2.lastIntValue;
          if (state2.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state2)) {
            var right = state2.lastIntValue;
            if (state2.switchU && (left === -1 || right === -1)) {
              state2.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state2.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$12.regexp_eatClassAtom = function(state2) {
        var start2 = state2.pos;
        if (state2.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state2)) {
            return true;
          }
          if (state2.switchU) {
            var ch$1 = state2.current();
            if (ch$1 === 99 || isOctalDigit2(ch$1)) {
              state2.raise("Invalid class escape");
            }
            state2.raise("Invalid escape");
          }
          state2.pos = start2;
        }
        var ch = state2.current();
        if (ch !== 93) {
          state2.lastIntValue = ch;
          state2.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatClassEscape = function(state2) {
        var start2 = state2.pos;
        if (state2.eat(
          98
          /* b */
        )) {
          state2.lastIntValue = 8;
          return true;
        }
        if (state2.switchU && state2.eat(
          45
          /* - */
        )) {
          state2.lastIntValue = 45;
          return true;
        }
        if (!state2.switchU && state2.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state2)) {
            return true;
          }
          state2.pos = start2;
        }
        return this.regexp_eatCharacterClassEscape(state2) || this.regexp_eatCharacterEscape(state2);
      };
      pp$12.regexp_classSetExpression = function(state2) {
        var result = CharSetOk2, subResult;
        if (this.regexp_eatClassSetRange(state2)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state2)) {
          if (subResult === CharSetString2) {
            result = CharSetString2;
          }
          var start2 = state2.pos;
          while (state2.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state2.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state2))) {
              if (subResult !== CharSetString2) {
                result = CharSetOk2;
              }
              continue;
            }
            state2.raise("Invalid character in character class");
          }
          if (start2 !== state2.pos) {
            return result;
          }
          while (state2.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state2)) {
              continue;
            }
            state2.raise("Invalid character in character class");
          }
          if (start2 !== state2.pos) {
            return result;
          }
        } else {
          state2.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state2)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state2);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString2) {
            result = CharSetString2;
          }
        }
      };
      pp$12.regexp_eatClassSetRange = function(state2) {
        var start2 = state2.pos;
        if (this.regexp_eatClassSetCharacter(state2)) {
          var left = state2.lastIntValue;
          if (state2.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state2)) {
            var right = state2.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state2.raise("Range out of order in character class");
            }
            return true;
          }
          state2.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatClassSetOperand = function(state2) {
        if (this.regexp_eatClassSetCharacter(state2)) {
          return CharSetOk2;
        }
        return this.regexp_eatClassStringDisjunction(state2) || this.regexp_eatNestedClass(state2);
      };
      pp$12.regexp_eatNestedClass = function(state2) {
        var start2 = state2.pos;
        if (state2.eat(
          91
          /* [ */
        )) {
          var negate = state2.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state2);
          if (state2.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString2) {
              state2.raise("Negated character class may contain strings");
            }
            return result;
          }
          state2.pos = start2;
        }
        if (state2.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state2);
          if (result$1) {
            return result$1;
          }
          state2.pos = start2;
        }
        return null;
      };
      pp$12.regexp_eatClassStringDisjunction = function(state2) {
        var start2 = state2.pos;
        if (state2.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state2.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state2);
            if (state2.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state2.raise("Invalid escape");
          }
          state2.pos = start2;
        }
        return null;
      };
      pp$12.regexp_classStringDisjunctionContents = function(state2) {
        var result = this.regexp_classString(state2);
        while (state2.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state2) === CharSetString2) {
            result = CharSetString2;
          }
        }
        return result;
      };
      pp$12.regexp_classString = function(state2) {
        var count2 = 0;
        while (this.regexp_eatClassSetCharacter(state2)) {
          count2++;
        }
        return count2 === 1 ? CharSetOk2 : CharSetString2;
      };
      pp$12.regexp_eatClassSetCharacter = function(state2) {
        var start2 = state2.pos;
        if (state2.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state2) || this.regexp_eatClassSetReservedPunctuator(state2)) {
            return true;
          }
          if (state2.eat(
            98
            /* b */
          )) {
            state2.lastIntValue = 8;
            return true;
          }
          state2.pos = start2;
          return false;
        }
        var ch = state2.current();
        if (ch < 0 || ch === state2.lookahead() && isClassSetReservedDoublePunctuatorCharacter2(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter2(ch)) {
          return false;
        }
        state2.advance();
        state2.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter2(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter2(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$12.regexp_eatClassSetReservedPunctuator = function(state2) {
        var ch = state2.current();
        if (isClassSetReservedPunctuator2(ch)) {
          state2.lastIntValue = ch;
          state2.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator2(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$12.regexp_eatClassControlLetter = function(state2) {
        var ch = state2.current();
        if (isDecimalDigit2(ch) || ch === 95) {
          state2.lastIntValue = ch % 32;
          state2.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatHexEscapeSequence = function(state2) {
        var start2 = state2.pos;
        if (state2.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state2, 2)) {
            return true;
          }
          if (state2.switchU) {
            state2.raise("Invalid escape");
          }
          state2.pos = start2;
        }
        return false;
      };
      pp$12.regexp_eatDecimalDigits = function(state2) {
        var start2 = state2.pos;
        var ch = 0;
        state2.lastIntValue = 0;
        while (isDecimalDigit2(ch = state2.current())) {
          state2.lastIntValue = 10 * state2.lastIntValue + (ch - 48);
          state2.advance();
        }
        return state2.pos !== start2;
      };
      function isDecimalDigit2(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$12.regexp_eatHexDigits = function(state2) {
        var start2 = state2.pos;
        var ch = 0;
        state2.lastIntValue = 0;
        while (isHexDigit2(ch = state2.current())) {
          state2.lastIntValue = 16 * state2.lastIntValue + hexToInt2(ch);
          state2.advance();
        }
        return state2.pos !== start2;
      };
      function isHexDigit2(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt2(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$12.regexp_eatLegacyOctalEscapeSequence = function(state2) {
        if (this.regexp_eatOctalDigit(state2)) {
          var n1 = state2.lastIntValue;
          if (this.regexp_eatOctalDigit(state2)) {
            var n2 = state2.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state2)) {
              state2.lastIntValue = n1 * 64 + n2 * 8 + state2.lastIntValue;
            } else {
              state2.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state2.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_eatOctalDigit = function(state2) {
        var ch = state2.current();
        if (isOctalDigit2(ch)) {
          state2.lastIntValue = ch - 48;
          state2.advance();
          return true;
        }
        state2.lastIntValue = 0;
        return false;
      };
      function isOctalDigit2(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$12.regexp_eatFixedHexDigits = function(state2, length) {
        var start2 = state2.pos;
        state2.lastIntValue = 0;
        for (var i3 = 0; i3 < length; ++i3) {
          var ch = state2.current();
          if (!isHexDigit2(ch)) {
            state2.pos = start2;
            return false;
          }
          state2.lastIntValue = 16 * state2.lastIntValue + hexToInt2(ch);
          state2.advance();
        }
        return true;
      };
      var Token3 = function Token4(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation3(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp2 = Parser3.prototype;
      pp2.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token3(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp2.getToken = function() {
        this.next();
        return new Token3(this);
      };
      if (typeof Symbol !== "undefined") {
        pp2[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$12.eof,
                value: token
              };
            }
          };
        };
      }
      pp2.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$12.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp2.readToken = function(code4) {
        if (isIdentifierStart2(code4, this.options.ecmaVersion >= 6) || code4 === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code4);
      };
      pp2.fullCharCodeAtPos = function() {
        var code4 = this.input.charCodeAt(this.pos);
        if (code4 <= 55295 || code4 >= 56320) {
          return code4;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code4 : (code4 << 10) + next - 56613888;
      };
      pp2.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start2 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start2 + 2, end),
            start2,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp2.skipLineComment = function(startSkip) {
        var start2 = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine2(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start2 + startSkip, this.pos),
            start2,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp2.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
      };
      pp2.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp2.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$12.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$12.dot);
        }
      };
      pp2.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.slash, 1);
      };
      pp2.readToken_mult_modulo_exp = function(code4) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size4 = 1;
        var tokentype = code4 === 42 ? types$12.star : types$12.modulo;
        if (this.options.ecmaVersion >= 7 && code4 === 42 && next === 42) {
          ++size4;
          tokentype = types$12.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, size4 + 1);
        }
        return this.finishOp(tokentype, size4);
      };
      pp2.readToken_pipe_amp = function(code4) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code4) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$12.assign, 3);
            }
          }
          return this.finishOp(code4 === 124 ? types$12.logicalOR : types$12.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(code4 === 124 ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
      };
      pp2.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.bitwiseXOR, 1);
      };
      pp2.readToken_plus_min = function(code4) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code4) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$12.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.plusMin, 1);
      };
      pp2.readToken_lt_gt = function(code4) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size4 = 1;
        if (next === code4) {
          size4 = code4 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size4) === 61) {
            return this.finishOp(types$12.assign, size4 + 1);
          }
          return this.finishOp(types$12.bitShift, size4);
        }
        if (next === 33 && code4 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size4 = 2;
        }
        return this.finishOp(types$12.relational, size4);
      };
      pp2.readToken_eq_excl = function(code4) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$12.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code4 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$12.arrow);
        }
        return this.finishOp(code4 === 61 ? types$12.eq : types$12.prefix, 1);
      };
      pp2.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$12.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$12.assign, 3);
              }
            }
            return this.finishOp(types$12.coalesce, 2);
          }
        }
        return this.finishOp(types$12.question, 1);
      };
      pp2.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code4 = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code4 = this.fullCharCodeAtPos();
          if (isIdentifierStart2(code4, true) || code4 === 92) {
            return this.finishToken(types$12.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString2(code4) + "'");
      };
      pp2.getTokenFromCode = function(code4) {
        switch (code4) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types$12.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$12.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$12.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$12.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$12.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$12.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$12.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$12.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$12.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$12.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code4);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code4);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code4);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code4);
          case 60:
          case 62:
            return this.readToken_lt_gt(code4);
          case 61:
          case 33:
            return this.readToken_eq_excl(code4);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$12.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString2(code4) + "'");
      };
      pp2.finishOp = function(type, size4) {
        var str = this.input.slice(this.pos, this.pos + size4);
        this.pos += size4;
        return this.finishToken(type, str);
      };
      pp2.readRegexp = function() {
        var escaped, inClass, start2 = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start2, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak2.test(ch)) {
            this.raise(start2, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start2, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state2 = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
        state2.reset(start2, pattern, flags);
        this.validateRegExpFlags(state2);
        this.validateRegExpPattern(state2);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e3) {
        }
        return this.finishToken(types$12.regexp, { pattern, flags, value });
      };
      pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start2 = this.pos, total = 0, lastCode = 0;
        for (var i3 = 0, e3 = len == null ? Infinity : len; i3 < e3; ++i3, ++this.pos) {
          var code4 = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code4 === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i3 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code4;
            continue;
          }
          if (code4 >= 97) {
            val = code4 - 97 + 10;
          } else if (code4 >= 65) {
            val = code4 - 65 + 10;
          } else if (code4 >= 48 && code4 <= 57) {
            val = code4 - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code4;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start2 || len != null && this.pos - start2 !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber2(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt2(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp2.readRadixNumber = function(radix) {
        var start2 = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt2(this.input.slice(start2, this.pos));
          ++this.pos;
        } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$12.num, val);
      };
      pp2.readNumber = function(startsWithDot) {
        var start2 = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start2, "Invalid number");
        }
        var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
        if (octal && this.strict) {
          this.raise(start2, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt2(this.input.slice(start2, this.pos));
          ++this.pos;
          if (isIdentifierStart2(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$12.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start2, "Invalid number");
          }
        }
        if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber2(this.input.slice(start2, this.pos), octal);
        return this.finishToken(types$12.num, val);
      };
      pp2.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code4;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code4 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code4 > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code4 = this.readHexChar(4);
        }
        return code4;
      };
      pp2.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine2(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$12.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
      pp2.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR2) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp2.invalidStringToken = function(position2, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR2;
        } else {
          this.raise(position2, message);
        }
      };
      pp2.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$12.template || this.type === types$12.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$12.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$12.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$12.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine2(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp2.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp2.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString2(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine2(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp2.readHexChar = function(len) {
        var codePos = this.pos;
        var n2 = this.readInt(16, len);
        if (n2 === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n2;
      };
      pp2.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar2(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart2 : isIdentifierChar2)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString2(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp2.readWord = function() {
        var word = this.readWord1();
        var type = types$12.name;
        if (this.keywords.test(word)) {
          type = keywords2[word];
        }
        return this.finishToken(type, word);
      };
      var version2 = "8.12.0";
      Parser3.acorn = {
        Parser: Parser3,
        version: version2,
        defaultOptions: defaultOptions2,
        Position: Position3,
        SourceLocation: SourceLocation3,
        getLineInfo: getLineInfo2,
        Node: Node7,
        TokenType: TokenType3,
        tokTypes: types$12,
        keywordTypes: keywords2,
        TokContext: TokContext3,
        tokContexts: types4,
        isIdentifierChar: isIdentifierChar2,
        isIdentifierStart: isIdentifierStart2,
        Token: Token3,
        isNewLine: isNewLine2,
        lineBreak: lineBreak2,
        lineBreakG: lineBreakG2,
        nonASCIIwhitespace: nonASCIIwhitespace2
      };
      function parse5(input, options) {
        return Parser3.parse(input, options);
      }
      function parseExpressionAt2(input, pos, options) {
        return Parser3.parseExpressionAt(input, pos, options);
      }
      function tokenizer3(input, options) {
        return Parser3.tokenizer(input, options);
      }
      exports2.Node = Node7;
      exports2.Parser = Parser3;
      exports2.Position = Position3;
      exports2.SourceLocation = SourceLocation3;
      exports2.TokContext = TokContext3;
      exports2.Token = Token3;
      exports2.TokenType = TokenType3;
      exports2.defaultOptions = defaultOptions2;
      exports2.getLineInfo = getLineInfo2;
      exports2.isIdentifierChar = isIdentifierChar2;
      exports2.isIdentifierStart = isIdentifierStart2;
      exports2.isNewLine = isNewLine2;
      exports2.keywordTypes = keywords2;
      exports2.lineBreak = lineBreak2;
      exports2.lineBreakG = lineBreakG2;
      exports2.nonASCIIwhitespace = nonASCIIwhitespace2;
      exports2.parse = parse5;
      exports2.parseExpressionAt = parseExpressionAt2;
      exports2.tokContexts = types4;
      exports2.tokTypes = types$12;
      exports2.tokenizer = tokenizer3;
      exports2.version = version2;
    });
  }
});

// node_modules/acorn-jsx/index.js
var require_acorn_jsx = __commonJS({
  "node_modules/acorn-jsx/index.js"(exports, module) {
    "use strict";
    var XHTMLEntities = require_xhtml();
    var hexNumber = /^[\da-fA-F]+$/;
    var decimalNumber = /^\d+$/;
    var acornJsxMap = /* @__PURE__ */ new WeakMap();
    function getJsxTokens(acorn) {
      acorn = acorn.Parser.acorn || acorn;
      let acornJsx2 = acornJsxMap.get(acorn);
      if (!acornJsx2) {
        const tt = acorn.tokTypes;
        const TokContext3 = acorn.TokContext;
        const TokenType3 = acorn.TokenType;
        const tc_oTag = new TokContext3("<tag", false);
        const tc_cTag = new TokContext3("</tag", false);
        const tc_expr = new TokContext3("<tag>...</tag>", true, true);
        const tokContexts = {
          tc_oTag,
          tc_cTag,
          tc_expr
        };
        const tokTypes = {
          jsxName: new TokenType3("jsxName"),
          jsxText: new TokenType3("jsxText", { beforeExpr: true }),
          jsxTagStart: new TokenType3("jsxTagStart", { startsExpr: true }),
          jsxTagEnd: new TokenType3("jsxTagEnd")
        };
        tokTypes.jsxTagStart.updateContext = function() {
          this.context.push(tc_expr);
          this.context.push(tc_oTag);
          this.exprAllowed = false;
        };
        tokTypes.jsxTagEnd.updateContext = function(prevType) {
          let out = this.context.pop();
          if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
            this.context.pop();
            this.exprAllowed = this.curContext() === tc_expr;
          } else {
            this.exprAllowed = true;
          }
        };
        acornJsx2 = { tokContexts, tokTypes };
        acornJsxMap.set(acorn, acornJsx2);
      }
      return acornJsx2;
    }
    function getQualifiedJSXName(object2) {
      if (!object2)
        return object2;
      if (object2.type === "JSXIdentifier")
        return object2.name;
      if (object2.type === "JSXNamespacedName")
        return object2.namespace.name + ":" + object2.name.name;
      if (object2.type === "JSXMemberExpression")
        return getQualifiedJSXName(object2.object) + "." + getQualifiedJSXName(object2.property);
    }
    module.exports = function(options) {
      options = options || {};
      return function(Parser3) {
        return plugin4({
          allowNamespaces: options.allowNamespaces !== false,
          allowNamespacedObjects: !!options.allowNamespacedObjects
        }, Parser3);
      };
    };
    Object.defineProperty(module.exports, "tokTypes", {
      get: function get_tokTypes() {
        return getJsxTokens(require_acorn()).tokTypes;
      },
      configurable: true,
      enumerable: true
    });
    function plugin4(options, Parser3) {
      const acorn = Parser3.acorn || require_acorn();
      const acornJsx2 = getJsxTokens(acorn);
      const tt = acorn.tokTypes;
      const tok = acornJsx2.tokTypes;
      const tokContexts = acorn.tokContexts;
      const tc_oTag = acornJsx2.tokContexts.tc_oTag;
      const tc_cTag = acornJsx2.tokContexts.tc_cTag;
      const tc_expr = acornJsx2.tokContexts.tc_expr;
      const isNewLine2 = acorn.isNewLine;
      const isIdentifierStart2 = acorn.isIdentifierStart;
      const isIdentifierChar2 = acorn.isIdentifierChar;
      return class extends Parser3 {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return acornJsx2;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated JSX contents");
            let ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.pos === this.start) {
                  if (ch === 60 && this.exprAllowed) {
                    ++this.pos;
                    return this.finishToken(tok.jsxTagStart);
                  }
                  return this.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tok.jsxText, out);
              case 38:
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
                break;
              case 62:
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                if (isNewLine2(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readNewLine(true);
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
            }
          }
        }
        jsx_readNewLine(normalizeCRLF) {
          let ch = this.input.charCodeAt(this.pos);
          let out;
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          return out;
        }
        jsx_readString(quote) {
          let out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated string constant");
            let ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
            } else if (isNewLine2(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(false);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt.string, out);
        }
        jsx_readEntity() {
          let str = "", count2 = 0, entity;
          let ch = this.input[this.pos];
          if (ch !== "&")
            this.raise(this.pos, "Entity must start with an ampersand");
          let startPos = ++this.pos;
          while (this.pos < this.input.length && count2++ < 10) {
            ch = this.input[this.pos++];
            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);
                  if (hexNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 16));
                } else {
                  str = str.substr(1);
                  if (decimalNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 10));
                }
              } else {
                entity = XHTMLEntities[str];
              }
              break;
            }
            str += ch;
          }
          if (!entity) {
            this.pos = startPos;
            return "&";
          }
          return entity;
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let ch, start2 = this.pos;
          do {
            ch = this.input.charCodeAt(++this.pos);
          } while (isIdentifierChar2(ch) || ch === 45);
          return this.finishToken(tok.jsxName, this.input.slice(start2, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let node3 = this.startNode();
          if (this.type === tok.jsxName)
            node3.name = this.value;
          else if (this.type.keyword)
            node3.name = this.type.keyword;
          else
            this.unexpected();
          this.next();
          return this.finishNode(node3, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let startPos = this.start, startLoc = this.startLoc;
          let name2 = this.jsx_parseIdentifier();
          if (!options.allowNamespaces || !this.eat(tt.colon)) return name2;
          var node3 = this.startNodeAt(startPos, startLoc);
          node3.namespace = name2;
          node3.name = this.jsx_parseIdentifier();
          return this.finishNode(node3, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === tok.jsxTagEnd) return "";
          let startPos = this.start, startLoc = this.startLoc;
          let node3 = this.jsx_parseNamespacedName();
          if (this.type === tt.dot && node3.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
            this.unexpected();
          }
          while (this.eat(tt.dot)) {
            let newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node3;
            newNode.property = this.jsx_parseIdentifier();
            node3 = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node3;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case tt.braceL:
              let node3 = this.jsx_parseExpressionContainer();
              if (node3.expression.type === "JSXEmptyExpression")
                this.raise(node3.start, "JSX attributes must only be assigned a non-empty expression");
              return node3;
            case tok.jsxTagStart:
            case tt.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let node3 = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node3, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let node3 = this.startNode();
          this.next();
          node3.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
          this.expect(tt.braceR);
          return this.finishNode(node3, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let node3 = this.startNode();
          if (this.eat(tt.braceL)) {
            this.expect(tt.ellipsis);
            node3.argument = this.parseMaybeAssign();
            this.expect(tt.braceR);
            return this.finishNode(node3, "JSXSpreadAttribute");
          }
          node3.name = this.jsx_parseNamespacedName();
          node3.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
          return this.finishNode(node3, "JSXAttribute");
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(startPos, startLoc) {
          let node3 = this.startNodeAt(startPos, startLoc);
          node3.attributes = [];
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node3.name = nodeName;
          while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
            node3.attributes.push(this.jsx_parseAttribute());
          node3.selfClosing = this.eat(tt.slash);
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node3, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(startPos, startLoc) {
          let node3 = this.startNodeAt(startPos, startLoc);
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node3.name = nodeName;
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node3, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(startPos, startLoc) {
          let node3 = this.startNodeAt(startPos, startLoc);
          let children = [];
          let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents: for (; ; ) {
              switch (this.type) {
                case tok.jsxTagStart:
                  startPos = this.start;
                  startLoc = this.startLoc;
                  this.next();
                  if (this.eat(tt.slash)) {
                    closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsx_parseElementAt(startPos, startLoc));
                  break;
                case tok.jsxText:
                  children.push(this.parseExprAtom());
                  break;
                case tt.braceL:
                  children.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            }
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(
                closingElement.start,
                "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
              );
            }
          }
          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
          node3["opening" + fragmentOrElement] = openingElement;
          node3["closing" + fragmentOrElement] = closingElement;
          node3.children = children;
          if (this.type === tt.relational && this.value === "<") {
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
          }
          return this.finishNode(node3, "JSX" + fragmentOrElement);
        }
        // Parse JSX text
        jsx_parseText() {
          let node3 = this.parseLiteral(this.value);
          node3.type = "JSXText";
          return node3;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let startPos = this.start, startLoc = this.startLoc;
          this.next();
          return this.jsx_parseElementAt(startPos, startLoc);
        }
        parseExprAtom(refShortHandDefaultPos) {
          if (this.type === tok.jsxText)
            return this.jsx_parseText();
          else if (this.type === tok.jsxTagStart)
            return this.jsx_parseElement();
          else
            return super.parseExprAtom(refShortHandDefaultPos);
        }
        readToken(code4) {
          let context = this.curContext();
          if (context === tc_expr) return this.jsx_readToken();
          if (context === tc_oTag || context === tc_cTag) {
            if (isIdentifierStart2(code4)) return this.jsx_readWord();
            if (code4 == 62) {
              ++this.pos;
              return this.finishToken(tok.jsxTagEnd);
            }
            if ((code4 === 34 || code4 === 39) && context == tc_oTag)
              return this.jsx_readString(code4);
          }
          if (code4 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            return this.finishToken(tok.jsxTagStart);
          }
          return super.readToken(code4);
        }
        updateContext(prevType) {
          if (this.type == tt.braceL) {
            var curContext = this.curContext();
            if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);
            else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);
            else super.updateContext(prevType);
            this.exprAllowed = true;
          } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
            this.context.length -= 2;
            this.context.push(tc_cTag);
            this.exprAllowed = false;
          } else {
            return super.updateContext(prevType);
          }
        }
      };
    }
  }
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-githubIcon.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var githubIcon = (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
  children: [(0, import_jsx_runtime.jsx)("path", {
    d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"
  }), (0, import_jsx_runtime.jsx)("path", {
    d: "M9 18c-4.51 2-5-2-7-2"
  })]
});

// node_modules/@react-stately/collections/dist/Item.mjs
var import_react = __toESM(require_react(), 1);
function $c1d7fb2ec91bae71$var$Item(props) {
  return null;
}
$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
  let { childItems, title, children } = props;
  let rendered = props.title || props.children;
  let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"] || "";
  if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn("<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.");
  yield {
    type: "item",
    props,
    rendered,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),
    *childNodes() {
      if (childItems) for (let child of childItems) yield {
        type: "item",
        value: child
      };
      else if (title) {
        let items = [];
        (0, import_react.default).Children.forEach(children, (child) => {
          items.push({
            type: "item",
            element: child
          });
        });
        yield* items;
      }
    }
  };
};
function $c1d7fb2ec91bae71$var$hasChildItems(props) {
  if (props.hasChildItems != null) return props.hasChildItems;
  if (props.childItems) return true;
  if (props.title && (0, import_react.default).Children.count(props.children) > 0) return true;
  return false;
}
var $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;

// node_modules/@react-stately/collections/dist/Section.mjs
var import_react2 = __toESM(require_react(), 1);
function $9fc4852771d079eb$var$Section(props) {
  return null;
}
$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode2(props) {
  let { children, title, items } = props;
  yield {
    type: "section",
    props,
    hasChildNodes: true,
    rendered: title,
    "aria-label": props["aria-label"],
    *childNodes() {
      if (typeof children === "function") {
        if (!items) throw new Error("props.children was a function but props.items is missing");
        for (let item2 of items) yield {
          type: "item",
          value: item2,
          renderer: children
        };
      } else {
        let items2 = [];
        (0, import_react2.default).Children.forEach(children, (child) => {
          items2.push({
            type: "item",
            element: child
          });
        });
        yield* items2;
      }
    }
  };
};
var $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;

// node_modules/@react-stately/collections/dist/CollectionBuilder.mjs
var import_react3 = __toESM(require_react(), 1);
var $eb2240fc39a57fa5$export$bf788dd355e3a401 = class {
  build(props, context) {
    this.context = context;
    return $eb2240fc39a57fa5$var$iterable(() => this.iterateCollection(props));
  }
  *iterateCollection(props) {
    let { children, items } = props;
    if (typeof children === "function") {
      if (!items) throw new Error("props.children was a function but props.items is missing");
      for (let item2 of props.items) yield* this.getFullNode({
        value: item2
      }, {
        renderer: children
      });
    } else {
      let items2 = [];
      (0, import_react3.default).Children.forEach(children, (child) => {
        items2.push(child);
      });
      let index4 = 0;
      for (let item2 of items2) {
        let nodes = this.getFullNode({
          element: item2,
          index: index4
        }, {});
        for (let node3 of nodes) {
          index4++;
          yield node3;
        }
      }
    }
  }
  getKey(item2, partialNode, state2, parentKey) {
    if (item2.key != null) return item2.key;
    if (partialNode.type === "cell" && partialNode.key != null) return `${parentKey}${partialNode.key}`;
    let v = partialNode.value;
    if (v != null) {
      var _v_key;
      let key3 = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;
      if (key3 == null) throw new Error("No key found for item");
      return key3;
    }
    return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;
  }
  getChildState(state2, partialNode) {
    return {
      renderer: partialNode.renderer || state2.renderer
    };
  }
  *getFullNode(partialNode, state2, parentKey, parentNode2) {
    let element3 = partialNode.element;
    if (!element3 && partialNode.value && state2 && state2.renderer) {
      let cached = this.cache.get(partialNode.value);
      if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
        cached.index = partialNode.index;
        cached.parentKey = parentNode2 ? parentNode2.key : null;
        yield cached;
        return;
      }
      element3 = state2.renderer(partialNode.value);
    }
    if ((0, import_react3.default).isValidElement(element3)) {
      let type = element3.type;
      if (typeof type !== "function" && typeof type.getCollectionNode !== "function") {
        let name2 = typeof element3.type === "function" ? element3.type.name : element3.type;
        throw new Error(`Unknown element <${name2}> in collection.`);
      }
      let childNodes = type.getCollectionNode(element3.props, this.context);
      let index4 = partialNode.index;
      let result = childNodes.next();
      while (!result.done && result.value) {
        let childNode = result.value;
        partialNode.index = index4;
        let nodeKey = childNode.key;
        if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element3, partialNode, state2, parentKey);
        let nodes = this.getFullNode({
          ...childNode,
          key: nodeKey,
          index: index4,
          wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)
        }, this.getChildState(state2, childNode), parentKey ? `${parentKey}${element3.key}` : element3.key, parentNode2);
        let children = [
          ...nodes
        ];
        for (let node4 of children) {
          node4.value = childNode.value || partialNode.value;
          if (node4.value) this.cache.set(node4.value, node4);
          if (partialNode.type && node4.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node4.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode2.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);
          index4++;
          yield node4;
        }
        result = childNodes.next(children);
      }
      return;
    }
    if (partialNode.key == null) return;
    let builder = this;
    let node3 = {
      type: partialNode.type,
      props: partialNode.props,
      key: partialNode.key,
      parentKey: parentNode2 ? parentNode2.key : null,
      value: partialNode.value,
      level: parentNode2 ? parentNode2.level + 1 : 0,
      index: partialNode.index,
      rendered: partialNode.rendered,
      textValue: partialNode.textValue,
      "aria-label": partialNode["aria-label"],
      wrapper: partialNode.wrapper,
      shouldInvalidate: partialNode.shouldInvalidate,
      hasChildNodes: partialNode.hasChildNodes,
      childNodes: $eb2240fc39a57fa5$var$iterable(function* () {
        if (!partialNode.hasChildNodes) return;
        let index4 = 0;
        for (let child of partialNode.childNodes()) {
          if (child.key != null)
            child.key = `${node3.key}${child.key}`;
          child.index = index4;
          let nodes = builder.getFullNode(child, builder.getChildState(state2, child), node3.key, node3);
          for (let node4 of nodes) {
            index4++;
            yield node4;
          }
        }
      })
    };
    yield node3;
  }
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};
function $eb2240fc39a57fa5$var$iterable(iterator) {
  let cache = [];
  let iterable = null;
  return {
    *[Symbol.iterator]() {
      for (let item2 of cache) yield item2;
      if (!iterable) iterable = iterator();
      for (let item2 of iterable) {
        cache.push(item2);
        yield item2;
      }
    }
  };
}
function $eb2240fc39a57fa5$var$compose(outer, inner) {
  if (outer && inner) return (element3) => outer(inner(element3));
  if (outer) return outer;
  if (inner) return inner;
}
function $eb2240fc39a57fa5$var$capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}

// node_modules/@react-stately/collections/dist/useCollection.mjs
var import_react4 = __toESM(require_react(), 1);
function $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {
  let builder = (0, import_react4.useMemo)(() => new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);
  let { children, items, collection: collection2 } = props;
  let result = (0, import_react4.useMemo)(() => {
    if (collection2) return collection2;
    let nodes = builder.build({
      children,
      items
    }, context);
    return factory(nodes);
  }, [
    builder,
    children,
    items,
    collection2,
    context,
    factory
  ]);
  return result;
}

// node_modules/@react-stately/collections/dist/getChildNodes.mjs
function $c5a24bc478652b5f$export$1005530eda016c13(node3, collection2) {
  if (typeof collection2.getChildren === "function") return collection2.getChildren(node3.key);
  return node3.childNodes;
}
function $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {
  return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);
}
function $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index4) {
  if (index4 < 0) return void 0;
  let i2 = 0;
  for (let item2 of iterable) {
    if (i2 === index4) return item2;
    i2++;
  }
}
function $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {
  let lastItem = void 0;
  for (let value of iterable) lastItem = value;
  return lastItem;
}
function $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection2, a, b) {
  if (a.parentKey === b.parentKey) return a.index - b.index;
  let aAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection2, a),
    a
  ];
  let bAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection2, b),
    b
  ];
  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a2, i2) => a2 !== bAncestors[i2]);
  if (firstNonMatchingAncestor !== -1) {
    a = aAncestors[firstNonMatchingAncestor];
    b = bAncestors[firstNonMatchingAncestor];
    return a.index - b.index;
  }
  if (aAncestors.findIndex((node3) => node3 === b) >= 0) return 1;
  else if (bAncestors.findIndex((node3) => node3 === a) >= 0) return -1;
  return -1;
}
function $c5a24bc478652b5f$var$getAncestors(collection2, node3) {
  let parents = [];
  while ((node3 === null || node3 === void 0 ? void 0 : node3.parentKey) != null) {
    node3 = collection2.getItem(node3.parentKey);
    parents.unshift(node3);
  }
  return parents;
}

// node_modules/@react-stately/collections/dist/getItemCount.mjs
var $453cc9f0df89c0a5$var$cache = /* @__PURE__ */ new WeakMap();
function $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection2) {
  let count2 = $453cc9f0df89c0a5$var$cache.get(collection2);
  if (count2 != null) return count2;
  count2 = 0;
  let countItems = (items) => {
    for (let item2 of items) if (item2.type === "section") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, collection2));
    else count2++;
  };
  countItems(collection2);
  $453cc9f0df89c0a5$var$cache.set(collection2, count2);
  return count2;
}

// node_modules/@react-aria/selection/dist/utils.mjs
function $feb5ffebff200149$export$d3e3bd3e26688c04(e3) {
  return (0, $c87311424ea30a05$export$e1865c3bedcd822b)() ? e3.altKey : e3.ctrlKey;
}
function $feb5ffebff200149$export$16792effe837dba3(e3) {
  if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) return e3.metaKey;
  return e3.ctrlKey;
}

// node_modules/@react-aria/selection/dist/useTypeSelect.mjs
var import_react5 = __toESM(require_react(), 1);
var $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1e3;
function $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {
  let { keyboardDelegate, selectionManager, onTypeSelect } = options;
  let state2 = (0, import_react5.useRef)({
    search: "",
    timeout: null
  }).current;
  let onKeyDown = (e3) => {
    let character = $fb3050f43d946246$var$getStringForKey(e3.key);
    if (!character || e3.ctrlKey || e3.metaKey || !e3.currentTarget.contains(e3.target)) return;
    if (character === " " && state2.search.trim().length > 0) {
      e3.preventDefault();
      if (!("continuePropagation" in e3)) e3.stopPropagation();
    }
    state2.search += character;
    let key3 = keyboardDelegate.getKeyForSearch(state2.search, selectionManager.focusedKey);
    if (key3 == null) key3 = keyboardDelegate.getKeyForSearch(state2.search);
    if (key3 != null) {
      selectionManager.setFocusedKey(key3);
      if (onTypeSelect) onTypeSelect(key3);
    }
    clearTimeout(state2.timeout);
    state2.timeout = setTimeout(() => {
      state2.search = "";
    }, $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);
  };
  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null
    }
  };
}
function $fb3050f43d946246$var$getStringForKey(key3) {
  if (key3.length === 1 || !/^[A-Z]/i.test(key3)) return key3;
  return "";
}

// node_modules/@react-aria/selection/dist/useSelectableCollection.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var import_react6 = __toESM(require_react(), 1);
function $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {
  let { selectionManager: manager, keyboardDelegate: delegate, ref: ref2, autoFocus = false, shouldFocusWrap = false, disallowEmptySelection = false, disallowSelectAll = false, selectOnFocus = manager.selectionBehavior === "replace", disallowTypeAhead = false, shouldUseVirtualFocus, allowsTabNavigation = false, isVirtualized, scrollRef = ref2, linkBehavior = "action" } = options;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onKeyDown = (e3) => {
    if (e3.altKey && e3.key === "Tab") e3.preventDefault();
    if (!ref2.current.contains(e3.target)) return;
    const navigateToKey = (key3, childFocus) => {
      if (key3 != null) {
        if (manager.isLink(key3) && linkBehavior === "selection" && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e3)) {
          (0, import_react_dom.flushSync)(() => {
            manager.setFocusedKey(key3, childFocus);
          });
          let item2 = scrollRef.current.querySelector(`[data-key="${CSS.escape(key3.toString())}"]`);
          let itemProps = manager.getItemProps(key3);
          router.open(item2, e3, itemProps.href, itemProps.routerOptions);
          return;
        }
        manager.setFocusedKey(key3, childFocus);
        if (manager.isLink(key3) && linkBehavior === "override") return;
        if (e3.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(key3);
        else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e3)) manager.replaceSelection(key3);
      }
    };
    switch (e3.key) {
      case "ArrowDown":
        if (delegate.getKeyBelow) {
          var _delegate_getFirstKey, _delegate_getFirstKey1;
          e3.preventDefault();
          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);
          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "ArrowUp":
        if (delegate.getKeyAbove) {
          var _delegate_getLastKey, _delegate_getLastKey1;
          e3.preventDefault();
          let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);
          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "ArrowLeft":
        if (delegate.getKeyLeftOf) {
          var _delegate_getFirstKey2, _delegate_getLastKey2;
          e3.preventDefault();
          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);
          if (nextKey == null && shouldFocusWrap) nextKey = direction === "rtl" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);
          navigateToKey(nextKey, direction === "rtl" ? "first" : "last");
        }
        break;
      case "ArrowRight":
        if (delegate.getKeyRightOf) {
          var _delegate_getLastKey3, _delegate_getFirstKey3;
          e3.preventDefault();
          let nextKey = delegate.getKeyRightOf(manager.focusedKey);
          if (nextKey == null && shouldFocusWrap) nextKey = direction === "rtl" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);
          navigateToKey(nextKey, direction === "rtl" ? "last" : "first");
        }
        break;
      case "Home":
        if (delegate.getFirstKey) {
          e3.preventDefault();
          let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e3));
          manager.setFocusedKey(firstKey);
          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e3) && e3.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(firstKey);
          else if (selectOnFocus) manager.replaceSelection(firstKey);
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e3.preventDefault();
          let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e3));
          manager.setFocusedKey(lastKey);
          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e3) && e3.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(lastKey);
          else if (selectOnFocus) manager.replaceSelection(lastKey);
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow) {
          e3.preventDefault();
          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove) {
          e3.preventDefault();
          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e3) && manager.selectionMode === "multiple" && disallowSelectAll !== true) {
          e3.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        if (!disallowEmptySelection && manager.selectedKeys.size !== 0) {
          e3.stopPropagation();
          e3.preventDefault();
          manager.clearSelection();
        }
        break;
      case "Tab":
        if (!allowsTabNavigation) {
          if (e3.shiftKey) ref2.current.focus();
          else {
            let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref2.current, {
              tabbable: true
            });
            let next;
            let last;
            do {
              last = walker.lastChild();
              if (last) next = last;
            } while (last);
            if (next && !next.contains(document.activeElement)) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(next);
          }
          break;
        }
    }
  };
  let scrollPos = (0, import_react6.useRef)({
    top: 0,
    left: 0
  });
  (0, $e9faafb641e167db$export$90fc3a17d93f704c)(scrollRef, "scroll", isVirtualized ? null : () => {
    scrollPos.current = {
      top: scrollRef.current.scrollTop,
      left: scrollRef.current.scrollLeft
    };
  });
  let onFocus = (e3) => {
    if (manager.isFocused) {
      if (!e3.currentTarget.contains(e3.target)) manager.setFocused(false);
      return;
    }
    if (!e3.currentTarget.contains(e3.target)) return;
    manager.setFocused(true);
    if (manager.focusedKey == null) {
      let navigateToFirstKey = (key3) => {
        if (key3 != null) {
          manager.setFocusedKey(key3);
          if (selectOnFocus) manager.replaceSelection(key3);
        }
      };
      let relatedTarget = e3.relatedTarget;
      var _manager_lastSelectedKey, _manager_firstSelectedKey;
      if (relatedTarget && e3.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());
      else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());
    } else if (!isVirtualized) {
      scrollRef.current.scrollTop = scrollPos.current.top;
      scrollRef.current.scrollLeft = scrollPos.current.left;
    }
    if (!isVirtualized && manager.focusedKey != null) {
      let element3 = scrollRef.current.querySelector(`[data-key="${CSS.escape(manager.focusedKey.toString())}"]`);
      if (element3) {
        if (!element3.contains(document.activeElement)) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element3);
        let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
        if (modality === "keyboard") (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(element3, {
          containingElement: ref2.current
        });
      }
    }
  };
  let onBlur = (e3) => {
    if (!e3.currentTarget.contains(e3.relatedTarget)) manager.setFocused(false);
  };
  const autoFocusRef = (0, import_react6.useRef)(autoFocus);
  (0, import_react6.useEffect)(() => {
    if (autoFocusRef.current) {
      let focusedKey = null;
      if (autoFocus === "first") focusedKey = delegate.getFirstKey();
      if (autoFocus === "last") focusedKey = delegate.getLastKey();
      let selectedKeys = manager.selectedKeys;
      if (selectedKeys.size) {
        for (let key3 of selectedKeys) if (manager.canSelectItem(key3)) {
          focusedKey = key3;
          break;
        }
      }
      manager.setFocused(true);
      manager.setFocusedKey(focusedKey);
      if (focusedKey == null && !shouldUseVirtualFocus) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
    }
  }, []);
  let lastFocusedKey = (0, import_react6.useRef)(manager.focusedKey);
  (0, import_react6.useEffect)(() => {
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {
      let element3 = scrollRef.current.querySelector(`[data-key="${CSS.escape(manager.focusedKey.toString())}"]`);
      if (element3 && (modality === "keyboard" || autoFocusRef.current)) {
        if (!isVirtualized) (0, $2f04cbc44ee30ce0$export$53a0910f038337bd)(scrollRef.current, element3);
        if (modality !== "virtual") (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(element3, {
          containingElement: ref2.current
        });
      }
    }
    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
    lastFocusedKey.current = manager.focusedKey;
    autoFocusRef.current = false;
  }, [
    isVirtualized,
    scrollRef,
    manager.focusedKey,
    manager.isFocused,
    ref2
  ]);
  let handlers2 = {
    onKeyDown,
    onFocus,
    onBlur,
    onMouseDown(e3) {
      if (scrollRef.current === e3.target)
        e3.preventDefault();
    }
  };
  let { typeSelectProps } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({
    keyboardDelegate: delegate,
    selectionManager: manager
  });
  if (!disallowTypeAhead) handlers2 = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(typeSelectProps, handlers2);
  let tabIndex;
  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;
  return {
    collectionProps: {
      ...handlers2,
      tabIndex
    }
  };
}

// node_modules/@react-aria/selection/dist/useSelectableItem.mjs
var import_react7 = __toESM(require_react(), 1);
function $880e95eb8b93ba9a$export$ecf600387e221c37(options) {
  let { selectionManager: manager, key: key3, ref: ref2, shouldSelectOnPressUp, shouldUseVirtualFocus, focus, isDisabled, onAction, allowsDifferentPressOrigin, linkBehavior = "action" } = options;
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onSelect = (e3) => {
    if (e3.pointerType === "keyboard" && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e3)) manager.toggleSelection(key3);
    else {
      if (manager.selectionMode === "none") return;
      if (manager.isLink(key3)) {
        if (linkBehavior === "selection") {
          let itemProps2 = manager.getItemProps(key3);
          router.open(ref2.current, e3, itemProps2.href, itemProps2.routerOptions);
          manager.setSelectedKeys(manager.selectedKeys);
          return;
        } else if (linkBehavior === "override" || linkBehavior === "none") return;
      }
      if (manager.selectionMode === "single") {
        if (manager.isSelected(key3) && !manager.disallowEmptySelection) manager.toggleSelection(key3);
        else manager.replaceSelection(key3);
      } else if (e3 && e3.shiftKey) manager.extendSelection(key3);
      else if (manager.selectionBehavior === "toggle" || e3 && ((0, $feb5ffebff200149$export$16792effe837dba3)(e3) || e3.pointerType === "touch" || e3.pointerType === "virtual"))
        manager.toggleSelection(key3);
      else manager.replaceSelection(key3);
    }
  };
  (0, import_react7.useEffect)(() => {
    let isFocused = key3 === manager.focusedKey;
    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {
      if (focus) focus();
      else if (document.activeElement !== ref2.current) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
    }
  }, [
    ref2,
    key3,
    manager.focusedKey,
    manager.childFocusStrategy,
    manager.isFocused,
    shouldUseVirtualFocus
  ]);
  isDisabled = isDisabled || manager.isDisabled(key3);
  let itemProps = {};
  if (!shouldUseVirtualFocus && !isDisabled) itemProps = {
    tabIndex: key3 === manager.focusedKey ? 0 : -1,
    onFocus(e3) {
      if (e3.target === ref2.current) manager.setFocusedKey(key3);
    }
  };
  else if (isDisabled) itemProps.onMouseDown = (e3) => {
    e3.preventDefault();
  };
  let isLinkOverride = manager.isLink(key3) && linkBehavior === "override";
  let hasLinkAction = manager.isLink(key3) && linkBehavior !== "selection" && linkBehavior !== "none";
  let allowsSelection = !isDisabled && manager.canSelectItem(key3) && !isLinkOverride;
  let allowsActions = (onAction || hasLinkAction) && !isDisabled;
  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === "replace" ? !allowsSelection : !allowsSelection || manager.isEmpty);
  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === "replace";
  let hasAction = hasPrimaryAction || hasSecondaryAction;
  let modality = (0, import_react7.useRef)(null);
  let longPressEnabled = hasAction && allowsSelection;
  let longPressEnabledOnPressStart = (0, import_react7.useRef)(false);
  let hadPrimaryActionOnPressStart = (0, import_react7.useRef)(false);
  let performAction = (e3) => {
    if (onAction) onAction();
    if (hasLinkAction) {
      let itemProps2 = manager.getItemProps(key3);
      router.open(ref2.current, e3, itemProps2.href, itemProps2.routerOptions);
    }
  };
  let itemPressProps = {};
  if (shouldSelectOnPressUp) {
    itemPressProps.onPressStart = (e3) => {
      modality.current = e3.pointerType;
      longPressEnabledOnPressStart.current = longPressEnabled;
      if (e3.pointerType === "keyboard" && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e3);
    };
    if (!allowsDifferentPressOrigin) itemPressProps.onPress = (e3) => {
      if (hasPrimaryAction || hasSecondaryAction && e3.pointerType !== "mouse") {
        if (e3.pointerType === "keyboard" && !$880e95eb8b93ba9a$var$isActionKey()) return;
        performAction(e3);
      } else if (e3.pointerType !== "keyboard" && allowsSelection) onSelect(e3);
    };
    else {
      itemPressProps.onPressUp = hasPrimaryAction ? null : (e3) => {
        if (e3.pointerType !== "keyboard" && allowsSelection) onSelect(e3);
      };
      itemPressProps.onPress = hasPrimaryAction ? performAction : null;
    }
  } else {
    itemPressProps.onPressStart = (e3) => {
      modality.current = e3.pointerType;
      longPressEnabledOnPressStart.current = longPressEnabled;
      hadPrimaryActionOnPressStart.current = hasPrimaryAction;
      if (allowsSelection && (e3.pointerType === "mouse" && !hasPrimaryAction || e3.pointerType === "keyboard" && (!allowsActions || $880e95eb8b93ba9a$var$isSelectionKey()))) onSelect(e3);
    };
    itemPressProps.onPress = (e3) => {
      if (e3.pointerType === "touch" || e3.pointerType === "pen" || e3.pointerType === "virtual" || e3.pointerType === "keyboard" && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e3.pointerType === "mouse" && hadPrimaryActionOnPressStart.current) {
        if (hasAction) performAction(e3);
        else if (allowsSelection) onSelect(e3);
      }
    };
  }
  itemProps["data-key"] = key3;
  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)(itemPressProps);
  let onDoubleClick = hasSecondaryAction ? (e3) => {
    if (modality.current === "mouse") {
      e3.stopPropagation();
      e3.preventDefault();
      performAction(e3);
    }
  } : void 0;
  let { longPressProps } = (0, $8a26561d2877236e$export$c24ed0104d07eab9)({
    isDisabled: !longPressEnabled,
    onLongPress(e3) {
      if (e3.pointerType === "touch") {
        onSelect(e3);
        manager.setSelectionBehavior("toggle");
      }
    }
  });
  let onDragStartCapture = (e3) => {
    if (modality.current === "touch" && longPressEnabledOnPressStart.current) e3.preventDefault();
  };
  let onClick = manager.isLink(key3) ? (e3) => {
    if (!(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7).isOpening) e3.preventDefault();
  } : void 0;
  return {
    itemProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {
      onDoubleClick,
      onDragStartCapture,
      onClick
    }),
    isPressed,
    isSelected: manager.isSelected(key3),
    isFocused: manager.isFocused && manager.focusedKey === key3,
    isDisabled,
    allowsSelection,
    hasAction
  };
}
function $880e95eb8b93ba9a$var$isActionKey() {
  let event = window.event;
  return (event === null || event === void 0 ? void 0 : event.key) === "Enter";
}
function $880e95eb8b93ba9a$var$isSelectionKey() {
  let event = window.event;
  return (event === null || event === void 0 ? void 0 : event.key) === " " || (event === null || event === void 0 ? void 0 : event.code) === "Space";
}

// node_modules/@react-aria/selection/dist/ListKeyboardDelegate.mjs
var $2a25aae57d74318e$export$a05409b8bb224a5a = class {
  isDisabled(item2) {
    var _item_props;
    return this.disabledBehavior === "all" && (((_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || this.disabledKeys.has(item2.key));
  }
  getNextKey(key3) {
    key3 = this.collection.getKeyAfter(key3);
    while (key3 != null) {
      let item2 = this.collection.getItem(key3);
      if (item2.type === "item" && !this.isDisabled(item2)) return key3;
      key3 = this.collection.getKeyAfter(key3);
    }
    return null;
  }
  getPreviousKey(key3) {
    key3 = this.collection.getKeyBefore(key3);
    while (key3 != null) {
      let item2 = this.collection.getItem(key3);
      if (item2.type === "item" && !this.isDisabled(item2)) return key3;
      key3 = this.collection.getKeyBefore(key3);
    }
    return null;
  }
  findKey(key3, nextKey, shouldSkip) {
    let item2 = this.getItem(key3);
    if (!item2) return null;
    let prevRect = item2.getBoundingClientRect();
    do {
      key3 = nextKey(key3);
      item2 = this.getItem(key3);
    } while (item2 && shouldSkip(prevRect, item2.getBoundingClientRect()));
    return key3;
  }
  isSameRow(prevRect, itemRect) {
    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;
  }
  isSameColumn(prevRect, itemRect) {
    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;
  }
  getKeyBelow(key3) {
    if (this.layout === "grid" && this.orientation === "vertical") return this.findKey(key3, (key4) => this.getNextKey(key4), this.isSameRow);
    else return this.getNextKey(key3);
  }
  getKeyAbove(key3) {
    if (this.layout === "grid" && this.orientation === "vertical") return this.findKey(key3, (key4) => this.getPreviousKey(key4), this.isSameRow);
    else return this.getPreviousKey(key3);
  }
  getNextColumn(key3, right) {
    return right ? this.getPreviousKey(key3) : this.getNextKey(key3);
  }
  getKeyRightOf(key3) {
    if (this.layout === "grid") {
      if (this.orientation === "vertical") return this.getNextColumn(key3, this.direction === "rtl");
      else return this.findKey(key3, (key4) => this.getNextColumn(key4, this.direction === "rtl"), this.isSameColumn);
    } else if (this.orientation === "horizontal") return this.getNextColumn(key3, this.direction === "rtl");
    return null;
  }
  getKeyLeftOf(key3) {
    if (this.layout === "grid") {
      if (this.orientation === "vertical") return this.getNextColumn(key3, this.direction === "ltr");
      else return this.findKey(key3, (key4) => this.getNextColumn(key4, this.direction === "ltr"), this.isSameColumn);
    } else if (this.orientation === "horizontal") return this.getNextColumn(key3, this.direction === "ltr");
    return null;
  }
  getFirstKey() {
    let key3 = this.collection.getFirstKey();
    while (key3 != null) {
      let item2 = this.collection.getItem(key3);
      if ((item2 === null || item2 === void 0 ? void 0 : item2.type) === "item" && !this.isDisabled(item2)) return key3;
      key3 = this.collection.getKeyAfter(key3);
    }
    return null;
  }
  getLastKey() {
    let key3 = this.collection.getLastKey();
    while (key3 != null) {
      let item2 = this.collection.getItem(key3);
      if (item2.type === "item" && !this.isDisabled(item2)) return key3;
      key3 = this.collection.getKeyBefore(key3);
    }
    return null;
  }
  getItem(key3) {
    return key3 !== null ? this.ref.current.querySelector(`[data-key="${CSS.escape(key3.toString())}"]`) : null;
  }
  getKeyPageAbove(key3) {
    let menu = this.ref.current;
    let item2 = this.getItem(key3);
    if (!item2) return null;
    if (!(0, $cc38e7bd3fc7b213$export$2bb74740c4e19def)(menu)) return this.getFirstKey();
    let containerRect = menu.getBoundingClientRect();
    let itemRect = item2.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let containerX = containerRect.x - menu.scrollLeft;
      let pageX = Math.max(0, itemRect.x - containerX + itemRect.width - containerRect.width);
      while (item2 && itemRect.x - containerX > pageX) {
        key3 = this.getKeyAbove(key3);
        item2 = key3 == null ? null : this.getItem(key3);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    } else {
      let containerY = containerRect.y - menu.scrollTop;
      let pageY = Math.max(0, itemRect.y - containerY + itemRect.height - containerRect.height);
      while (item2 && itemRect.y - containerY > pageY) {
        key3 = this.getKeyAbove(key3);
        item2 = key3 == null ? null : this.getItem(key3);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    }
    return key3 !== null && key3 !== void 0 ? key3 : this.getFirstKey();
  }
  getKeyPageBelow(key3) {
    let menu = this.ref.current;
    let item2 = this.getItem(key3);
    if (!item2) return null;
    if (!(0, $cc38e7bd3fc7b213$export$2bb74740c4e19def)(menu)) return this.getLastKey();
    let containerRect = menu.getBoundingClientRect();
    let itemRect = item2.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let containerX = containerRect.x - menu.scrollLeft;
      let pageX = Math.min(menu.scrollWidth, itemRect.x - containerX - itemRect.width + containerRect.width);
      while (item2 && itemRect.x - containerX < pageX) {
        key3 = this.getKeyBelow(key3);
        item2 = key3 == null ? null : this.getItem(key3);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    } else {
      let containerY = containerRect.y - menu.scrollTop;
      let pageY = Math.min(menu.scrollHeight, itemRect.y - containerY - itemRect.height + containerRect.height);
      while (item2 && itemRect.y - containerY < pageY) {
        key3 = this.getKeyBelow(key3);
        item2 = key3 == null ? null : this.getItem(key3);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    }
    return key3 !== null && key3 !== void 0 ? key3 : this.getLastKey();
  }
  getKeyForSearch(search2, fromKey) {
    if (!this.collator) return null;
    let collection2 = this.collection;
    let key3 = fromKey || this.getFirstKey();
    while (key3 != null) {
      let item2 = collection2.getItem(key3);
      let substring = item2.textValue.slice(0, search2.length);
      if (item2.textValue && this.collator.compare(substring, search2) === 0) return key3;
      key3 = this.getKeyBelow(key3);
    }
    return null;
  }
  constructor(...args) {
    if (args.length === 1) {
      let opts = args[0];
      this.collection = opts.collection;
      this.ref = opts.ref;
      this.collator = opts.collator;
      this.disabledKeys = opts.disabledKeys || /* @__PURE__ */ new Set();
      this.disabledBehavior = opts.disabledBehavior || "all";
      this.orientation = opts.orientation;
      this.direction = opts.direction;
      this.layout = opts.layout || "stack";
    } else {
      this.collection = args[0];
      this.disabledKeys = args[1];
      this.ref = args[2];
      this.collator = args[3];
      this.layout = "stack";
      this.orientation = "vertical";
      this.disabledBehavior = "all";
    }
    if (this.layout === "stack" && this.orientation === "vertical") {
      this.getKeyLeftOf = void 0;
      this.getKeyRightOf = void 0;
    }
  }
};

// node_modules/@react-aria/selection/dist/useSelectableList.mjs
var import_react8 = __toESM(require_react(), 1);
function $982254629710d113$export$b95089534ab7c1fd(props) {
  let { selectionManager, collection: collection2, disabledKeys, ref: ref2, keyboardDelegate } = props;
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let disabledBehavior = selectionManager.disabledBehavior;
  let delegate = (0, import_react8.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)({
    collection: collection2,
    disabledKeys,
    disabledBehavior,
    ref: ref2,
    collator
  }), [
    keyboardDelegate,
    collection2,
    disabledKeys,
    ref2,
    collator,
    disabledBehavior
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    ...props,
    ref: ref2,
    selectionManager,
    keyboardDelegate: delegate
  });
  return {
    listProps: collectionProps
  };
}

// node_modules/@react-aria/checkbox/dist/useCheckbox.mjs
var import_react9 = __toESM(require_react(), 1);

// node_modules/@react-aria/toggle/dist/useToggle.mjs
function $d2c8e2b0480f3f34$export$cbe85ee05b554577(props, state2, ref2) {
  let { isDisabled = false, isReadOnly = false, value, name: name2, children, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, validationState = "valid", isInvalid } = props;
  let onChange = (e3) => {
    e3.stopPropagation();
    state2.setSelected(e3.target.checked);
  };
  let hasChildren = children != null;
  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;
  if (!hasChildren && !hasAriaLabel) console.warn("If you do not provide children, you must specify an aria-label for accessibility");
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled
  });
  let { pressProps: labelProps, isPressed: isLabelPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled: isDisabled || isReadOnly,
    onPress() {
      state2.toggle();
    }
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref2);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, focusableProps);
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  (0, $99facab73266f662$export$5add1d006293d136)(ref2, state2.isSelected, state2.setSelected);
  return {
    labelProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(labelProps, {
      onClick: (e3) => e3.preventDefault()
    }),
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      "aria-invalid": isInvalid || validationState === "invalid" || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-controls": props["aria-controls"],
      "aria-readonly": isReadOnly || void 0,
      onChange,
      disabled: isDisabled,
      ...value == null ? {} : {
        value
      },
      name: name2,
      type: "checkbox",
      ...interactions
    }),
    isSelected: state2.isSelected,
    isPressed: isPressed || isLabelPressed,
    isDisabled,
    isReadOnly,
    isInvalid: isInvalid || validationState === "invalid"
  };
}

// node_modules/@react-aria/checkbox/dist/useCheckbox.mjs
function $406796ff087fe49b$export$e375f10ce42261c5(props, state2, inputRef) {
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: state2.isSelected
  });
  let { isInvalid, validationErrors, validationDetails } = validationState.displayValidation;
  let { labelProps, inputProps, isSelected, isPressed, isDisabled, isReadOnly } = (0, $d2c8e2b0480f3f34$export$cbe85ee05b554577)({
    ...props,
    isInvalid
  }, state2, inputRef);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)(props, validationState, inputRef);
  let { isIndeterminate, isRequired, validationBehavior = "aria" } = props;
  (0, import_react9.useEffect)(() => {
    if (inputRef.current) inputRef.current.indeterminate = !!isIndeterminate;
  });
  return {
    labelProps,
    inputProps: {
      ...inputProps,
      checked: isSelected,
      "aria-required": isRequired && validationBehavior === "aria" || void 0,
      required: isRequired && validationBehavior === "native"
    },
    isSelected,
    isPressed,
    isDisabled,
    isReadOnly,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@react-aria/checkbox/dist/utils.mjs
var $1ae600c947479353$export$ec98120685d4f57d = /* @__PURE__ */ new WeakMap();

// node_modules/@react-aria/checkbox/dist/useCheckboxGroup.mjs
function $1e9fce0cfacc738b$export$49ff6f28c54f1cbe(props, state2) {
  let { isDisabled, name: name2, validationBehavior = "aria" } = props;
  let { isInvalid, validationErrors, validationDetails } = state2.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    // Checkbox group is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span",
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  (0, $1ae600c947479353$export$ec98120685d4f57d).set(state2, {
    name: name2,
    descriptionId: descriptionProps.id,
    errorMessageId: errorMessageProps.id,
    validationBehavior
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onBlurWithin: props.onBlur,
    onFocusWithin: props.onFocus,
    onFocusWithinChange: props.onFocusChange
  });
  return {
    groupProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      role: "group",
      "aria-disabled": isDisabled || void 0,
      ...fieldProps,
      ...focusWithinProps
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@react-aria/checkbox/dist/useCheckboxGroupItem.mjs
var import_react10 = __toESM(require_react(), 1);
function $fba3e38d5ca8983f$export$353b32fc6898d37d(props, state2, inputRef) {
  const toggleState = (0, $3017fa7ffdddec74$export$8042c6c013fd5226)({
    isReadOnly: props.isReadOnly || state2.isReadOnly,
    isSelected: state2.isSelected(props.value),
    onChange(isSelected) {
      if (isSelected) state2.addValue(props.value);
      else state2.removeValue(props.value);
      if (props.onChange) props.onChange(isSelected);
    }
  });
  let { name: name2, descriptionId, errorMessageId, validationBehavior } = (0, $1ae600c947479353$export$ec98120685d4f57d).get(state2);
  var _props_validationBehavior;
  validationBehavior = (_props_validationBehavior = props.validationBehavior) !== null && _props_validationBehavior !== void 0 ? _props_validationBehavior : validationBehavior;
  let { realtimeValidation } = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: toggleState.isSelected,
    // Server validation is handled at the group level.
    name: void 0,
    validationBehavior: "aria"
  });
  let nativeValidation = (0, import_react10.useRef)((0, $e5be200c675c3b3a$export$dad6ae84456c676a));
  let updateValidation = () => {
    state2.setInvalid(props.value, realtimeValidation.isInvalid ? realtimeValidation : nativeValidation.current);
  };
  (0, import_react10.useEffect)(updateValidation);
  let combinedRealtimeValidation = state2.realtimeValidation.isInvalid ? state2.realtimeValidation : realtimeValidation;
  let displayValidation = validationBehavior === "native" ? state2.displayValidation : combinedRealtimeValidation;
  var _props_isRequired;
  let res = (0, $406796ff087fe49b$export$e375f10ce42261c5)({
    ...props,
    isReadOnly: props.isReadOnly || state2.isReadOnly,
    isDisabled: props.isDisabled || state2.isDisabled,
    name: props.name || name2,
    isRequired: (_props_isRequired = props.isRequired) !== null && _props_isRequired !== void 0 ? _props_isRequired : state2.isRequired,
    validationBehavior,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: {
      realtimeValidation: combinedRealtimeValidation,
      displayValidation,
      resetValidation: state2.resetValidation,
      commitValidation: state2.commitValidation,
      updateValidation(v) {
        nativeValidation.current = v;
        updateValidation();
      }
    }
  }, toggleState, inputRef);
  return {
    ...res,
    inputProps: {
      ...res.inputProps,
      "aria-describedby": [
        props["aria-describedby"],
        state2.isInvalid ? errorMessageId : null,
        descriptionId
      ].filter(Boolean).join(" ") || void 0
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-checkbox.js
var import_react12 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-checkIcon.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var checkIcon = (0, import_jsx_runtime2.jsx)("path", {
  d: "M20 6 9 17l-5-5"
});

// node_modules/@keystar/ui/dist/keystar-ui-checkbox.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/checkbox/dist/useCheckboxGroupState.mjs
var import_react11 = __toESM(require_react(), 1);
function $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {
  let [selectedValues, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, props.defaultValue || [], props.onChange);
  let isRequired = !!props.isRequired && selectedValues.length === 0;
  let invalidValues = (0, import_react11.useRef)(/* @__PURE__ */ new Map());
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: selectedValues
  });
  let isInvalid = validation.displayValidation.isInvalid;
  var _props_validationState;
  const state2 = {
    ...validation,
    value: selectedValues,
    setValue(value) {
      if (props.isReadOnly || props.isDisabled) return;
      setValue(value);
    },
    isDisabled: props.isDisabled || false,
    isReadOnly: props.isReadOnly || false,
    isSelected(value) {
      return selectedValues.includes(value);
    },
    addValue(value) {
      if (props.isReadOnly || props.isDisabled) return;
      if (!selectedValues.includes(value)) setValue(selectedValues.concat(value));
    },
    removeValue(value) {
      if (props.isReadOnly || props.isDisabled) return;
      if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue) => existingValue !== value));
    },
    toggleValue(value) {
      if (props.isReadOnly || props.isDisabled) return;
      if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue) => existingValue !== value));
      else setValue(selectedValues.concat(value));
    },
    setInvalid(value, v) {
      let s2 = new Map(invalidValues.current);
      if (v.isInvalid) s2.set(value, v);
      else s2.delete(value);
      invalidValues.current = s2;
      validation.updateValidation((0, $e5be200c675c3b3a$export$75ee7c75d68f5b0e)(...s2.values()));
    },
    validationState: (_props_validationState = props.validationState) !== null && _props_validationState !== void 0 ? _props_validationState : isInvalid ? "invalid" : null,
    isInvalid,
    isRequired
  };
  return state2;
}

// node_modules/@keystar/ui/dist/keystar-ui-checkbox.js
var CheckboxGroupContext = import_react12.default.createContext(null);
var checkboxClassList = new ClassList("Checkbox", ["indicator"]);
function Checkbox(props) {
  let {
    isIndeterminate = false,
    isDisabled = false,
    autoFocus,
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let inputRef = (0, import_react12.useRef)(null);
  let groupState = (0, import_react12.useContext)(CheckboxGroupContext);
  let {
    inputProps
  } = groupState ? (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    $fba3e38d5ca8983f$export$353b32fc6898d37d({
      ...props,
      // Value is optional for standalone checkboxes, but required for
      // CheckboxGroup items; it's passed explicitly here to avoid
      // typescript error (requires ignore).
      // @ts-ignore
      value: props.value
    }, groupState.state, inputRef)
  ) : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    $406796ff087fe49b$export$e375f10ce42261c5(props, $3017fa7ffdddec74$export$8042c6c013fd5226(props), inputRef)
  );
  const labelClassName = css({
    alignItems: "flex-start",
    display: "inline-flex",
    gap: tokenSchema.size.space.regular,
    position: "relative",
    userSelect: "none"
  });
  const slots = (0, import_react12.useMemo)(() => ({
    text: {
      color: "inherit"
    },
    description: {
      color: "neutralTertiary"
    }
  }), []);
  return (0, import_jsx_runtime3.jsxs)("label", {
    "data-disabled": isDisabled,
    className: classNames(styleProps.className, labelClassName),
    style: styleProps.style,
    children: [(0, import_jsx_runtime3.jsx)(FocusRing, {
      autoFocus,
      children: (0, import_jsx_runtime3.jsx)("input", {
        ...inputProps,
        ref: inputRef,
        className: classNames(css({
          position: "absolute",
          zIndex: 1,
          inset: 0,
          opacity: 1e-4
        }))
      })
    }), (0, import_jsx_runtime3.jsx)(Indicator, {
      isIndeterminate
    }), (0, import_jsx_runtime3.jsx)(SlotProvider, {
      slots,
      children: children && (0, import_jsx_runtime3.jsx)(Content2, {
        children: isReactText(children) ? (0, import_jsx_runtime3.jsx)(Text, {
          children
        }) : children
      })
    })]
  });
}
var sizeToken = tokenSchema.size.element.xsmall;
var Indicator = (props) => {
  let {
    isIndeterminate
  } = props;
  return (0, import_jsx_runtime3.jsx)("span", {
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      borderRadius: tokenSchema.size.radius.small,
      color: tokenSchema.color.foreground.onEmphasis,
      display: "flex",
      flexShrink: 0,
      justifyContent: "center",
      alignItems: "center",
      position: "relative",
      height: sizeToken,
      width: sizeToken,
      // indicator icons
      [checkboxClassList.selector("indicator")]: {
        opacity: 0,
        transform: `scale(0) translate3d(0, 0, 0)`,
        transition: transition(["opacity", "transform"]),
        willChange: "opacity, transform"
      },
      // focus ring
      "::after": {
        borderRadius: `calc(${tokenSchema.size.alias.focusRingGap} + ${tokenSchema.size.radius.small})`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      'input[type="checkbox"][data-focus=visible] + &::after': {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // border / background
      "&::before": {
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.alias.borderIdle}`,
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["border-color", "border-width"])
      },
      'input[type="checkbox"]:disabled + &': {
        color: tokenSchema.color.alias.foregroundDisabled,
        "&::before": {
          borderColor: tokenSchema.color.alias.borderDisabled
        }
      },
      'input[type="checkbox"]:enabled:hover + &::before': {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      'input[type="checkbox"]:enabled:active + &::before': {
        borderColor: tokenSchema.color.alias.borderPressed
      },
      // checked states
      'input[type="checkbox"]:checked + &, input[type="checkbox"]:indeterminate + &': {
        "&::before": {
          borderWidth: `calc(${sizeToken} / 2)`
        },
        [checkboxClassList.selector("indicator")]: {
          opacity: 1,
          transform: `scale(1)`
        }
      },
      'input[type="checkbox"]:enabled:checked + &::before, input[type="checkbox"]:enabled:indeterminate + &::before': {
        borderColor: tokenSchema.color.scale.indigo9
      },
      'input[type="checkbox"]:enabled:checked:hover + &::before, input[type="checkbox"]:enabled:indeterminate:hover + &::before': {
        borderColor: tokenSchema.color.scale.indigo10
      },
      'input[type="checkbox"]:enabled:checked:active + &::before, input[type="checkbox"]:enabled:indeterminate:active + &::before': {
        borderColor: tokenSchema.color.scale.indigo11
      }
    })),
    children: (0, import_jsx_runtime3.jsx)("span", {
      className: checkboxClassList.element("indicator"),
      children: (0, import_jsx_runtime3.jsx)(Icon, {
        size: "small",
        src: isIndeterminate ? minusIcon : checkIcon,
        strokeScaling: false
      })
    })
  });
};
var Content2 = (props) => {
  return (0, import_jsx_runtime3.jsx)("div", {
    className: classNames(css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: "grid",
      paddingTop: `calc((${sizeToken} - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      gap: tokenSchema.size.space.large,
      'input[type="checkbox"]:hover ~ &': {
        color: tokenSchema.color.alias.foregroundHovered
      },
      'input[type="checkbox"]:disabled ~ &': {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    })),
    ...props
  });
};
var CheckboxGroup = (0, import_react12.forwardRef)(function CheckboxGroup2(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateFieldProps(props);
  let {
    children,
    orientation = "vertical",
    validationState
  } = props;
  let state2 = $587d3ad58be6d31f$export$daff6da51032a415(props);
  let {
    labelProps,
    groupProps,
    descriptionProps,
    errorMessageProps
  } = $1e9fce0cfacc738b$export$49ff6f28c54f1cbe(props, state2);
  return (0, import_jsx_runtime3.jsx)(FieldPrimitive, {
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    supplementRequiredState: true,
    children: (0, import_jsx_runtime3.jsx)("div", {
      ...groupProps,
      ...toDataAttributes({
        orientation
      }),
      className: classNames(css({
        display: "flex",
        gap: tokenSchema.size.space.large,
        '&[data-orientation="vertical"]': {
          flexDirection: "column"
        }
      })),
      children: (0, import_jsx_runtime3.jsx)(CheckboxGroupContext.Provider, {
        value: {
          validationState,
          state: state2
        },
        children
      })
    })
  });
});

// node_modules/@markdoc/markdoc/dist/index.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all2) => {
  __markAsModule(target);
  for (var name2 in all2)
    __defProp(target, name2, { get: all2[name2], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key3 of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key3) && key3 !== "default")
        __defProp(target, key3, { get: () => module[key3], enumerable: !(desc = __getOwnPropDesc(module, key3)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var require_tag = __commonJS2({
  "src/grammar/tag.js"(exports, module) {
    "use strict";
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found2, location) {
      this.message = message;
      this.expected = expected;
      this.found = found2;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found2, location) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        },
        not: function(expectation) {
          return "not " + describeExpectation(expectation.expected);
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i2, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i2 = 1, j = 1; i2 < descriptions.length; i2++) {
            if (descriptions[i2 - 1] !== descriptions[i2]) {
              descriptions[j] = descriptions[i2];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found22) {
        return found22 ? '"' + literalEscape(found22) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found2) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$startRuleFunctions = { Top: peg$parseTop };
      var peg$startRuleFunction = peg$parseTop;
      var peg$c0 = "/";
      var peg$c1 = ".";
      var peg$c2 = "#";
      var peg$c3 = "=";
      var peg$c4 = "(";
      var peg$c5 = ")";
      var peg$c6 = ",";
      var peg$c7 = "[";
      var peg$c8 = "]";
      var peg$c9 = "null";
      var peg$c10 = "true";
      var peg$c11 = "false";
      var peg$c12 = "{";
      var peg$c13 = "}";
      var peg$c14 = ":";
      var peg$c15 = "-";
      var peg$c16 = '"';
      var peg$c17 = "\\";
      var peg$c18 = "n";
      var peg$c19 = "r";
      var peg$c20 = "t";
      var peg$r0 = /^[$@]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[^\0-\x1F"\\]/;
      var peg$r3 = /^[a-zA-Z0-9_\-]/;
      var peg$r4 = /^[ \n\t]/;
      var peg$e0 = peg$literalExpectation("/", false);
      var peg$e1 = peg$otherExpectation("tag name");
      var peg$e2 = peg$otherExpectation("class");
      var peg$e3 = peg$otherExpectation("id");
      var peg$e4 = peg$literalExpectation("=", false);
      var peg$e5 = peg$literalExpectation("(", false);
      var peg$e6 = peg$literalExpectation(")", false);
      var peg$e7 = peg$literalExpectation(",", false);
      var peg$e8 = peg$otherExpectation("variable");
      var peg$e9 = peg$otherExpectation("null");
      var peg$e10 = peg$otherExpectation("boolean");
      var peg$e11 = peg$literalExpectation("[", false);
      var peg$e12 = peg$literalExpectation("]", false);
      var peg$e13 = peg$literalExpectation("{", false);
      var peg$e14 = peg$literalExpectation("}", false);
      var peg$e15 = peg$literalExpectation(":", false);
      var peg$e16 = peg$otherExpectation("number");
      var peg$e17 = peg$otherExpectation("string");
      var peg$e18 = peg$otherExpectation("identifier");
      var peg$e19 = peg$otherExpectation("whitespace");
      var peg$f0 = function(variable) {
        return { type: "variable", meta: { variable } };
      };
      var peg$f1 = function(attributes) {
        return { type: "annotation", meta: { attributes } };
      };
      var peg$f2 = function(tag, value) {
        return value;
      };
      var peg$f3 = function(tag, primary, attributes, close2) {
        if (primary) {
          attributes = attributes || [];
          attributes.unshift({
            type: "attribute",
            name: "primary",
            value: primary
          });
        }
        const [type, nesting] = close2 ? ["tag", 0] : ["tag_open", 1];
        return { type, nesting, meta: { tag, attributes } };
      };
      var peg$f4 = function(tag) {
        return { type: "tag_close", nesting: -1, meta: { tag } };
      };
      var peg$f5 = function(head, tail) {
        return !head ? [] : [head, ...tail];
      };
      var peg$f6 = function(item2) {
        return item2;
      };
      var peg$f7 = function(ids) {
        return ids;
      };
      var peg$f8 = function(classes2) {
        return classes2;
      };
      var peg$f9 = function(attribute) {
        return attribute;
      };
      var peg$f10 = function(name2) {
        return { type: "class", name: name2, value: true };
      };
      var peg$f11 = function(value) {
        return { type: "attribute", name: "id", value };
      };
      var peg$f12 = function(name2, value) {
        return { type: "attribute", name: name2, value };
      };
      var peg$f13 = function(name2, head, tail) {
        return head ? [head, ...tail] : [];
      };
      var peg$f14 = function(name2, params) {
        let parameters = {};
        for (let [index4, { name: name22, value }] of params.entries())
          parameters[name22 || index4] = value;
        return new Function3(name2, parameters);
      };
      var peg$f15 = function(name2) {
        return name2;
      };
      var peg$f16 = function(name2, value) {
        return { name: name2, value };
      };
      var peg$f17 = function(value) {
        return value;
      };
      var peg$f18 = function(prefix, head, tail) {
        if (prefix === "@")
          return [head, ...tail];
        return new Variable2([head, ...tail]);
      };
      var peg$f19 = function() {
        return null;
      };
      var peg$f20 = function() {
        return true;
      };
      var peg$f21 = function() {
        return false;
      };
      var peg$f22 = function(head, tail) {
        return [head, ...tail];
      };
      var peg$f23 = function(value) {
        return value || [];
      };
      var peg$f24 = function(head, tail) {
        return Object.assign(head, ...tail);
      };
      var peg$f25 = function(value) {
        return value || {};
      };
      var peg$f26 = function(key3, value) {
        return key3 === "$$mdtype" ? {} : { [key3]: value };
      };
      var peg$f27 = function() {
        return parseFloat(text22());
      };
      var peg$f28 = function(value) {
        return value.join("");
      };
      var peg$f29 = function() {
        return "\n";
      };
      var peg$f30 = function() {
        return "\r";
      };
      var peg$f31 = function() {
        return "	";
      };
      var peg$f32 = function(sequence) {
        return sequence;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$expected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text22() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset5() {
        return peg$savedPos;
      }
      function range() {
        return [peg$savedPos, peg$currPos];
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);
      }
      function error22(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text32, ignoreCase) {
        return { type: "literal", text: text32, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts,
          inverted,
          ignoreCase
        };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      var peg$VALIDFILENAME = typeof options.filename === "string" && options.filename.length > 0;
      function peg$computeLocation(startPos, endPos) {
        var loc = {};
        if (peg$VALIDFILENAME)
          loc.filename = options.filename;
        var startPosDetails = peg$computePosDetails(startPos);
        loc.start = {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        };
        var endPosDetails = peg$computePosDetails(endPos);
        loc.end = {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        };
        return loc;
      }
      function peg$begin() {
        peg$expected.push({ pos: peg$currPos, variants: [] });
      }
      function peg$expect(expected2) {
        var top = peg$expected[peg$expected.length - 1];
        if (peg$currPos < top.pos) {
          return;
        }
        if (peg$currPos > top.pos) {
          top.pos = peg$currPos;
          top.variants = [];
        }
        top.variants.push(expected2);
      }
      function peg$end(invert) {
        var expected2 = peg$expected.pop();
        var top = peg$expected[peg$expected.length - 1];
        var variants = expected2.variants;
        if (top.pos !== expected2.pos) {
          return;
        }
        if (invert) {
          variants = variants.map(function(e3) {
            return e3.type === "not" ? e3.expected : { type: "not", expected: e3 };
          });
        }
        Array.prototype.push.apply(top.variants, variants);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found2, location2) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found2, location2), expected2, found2, location2);
      }
      function peg$buildError() {
        var expected2 = peg$expected[0];
        var failPos = expected2.pos;
        return peg$buildStructuredError(expected2.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));
      }
      function peg$parseTop() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$parseTopLevelValue();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAnnotation();
          if (s0 === peg$FAILED) {
            s0 = peg$parseTagOpen();
            if (s0 === peg$FAILED) {
              s0 = peg$parseTagClose();
            }
          }
        }
        return s0;
      }
      function peg$parseTopLevelValue() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 === peg$FAILED) {
          s1 = peg$parseFunction();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseAnnotation() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagAttributes();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagOpen() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagName();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f2(s1, s4);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$parseTagAttributes();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          rule$expects(peg$e0);
          if (input.charCodeAt(peg$currPos) === 47) {
            s6 = peg$c0;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s3, s4, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagClose() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e0);
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseTagName();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagName() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e1);
        peg$silentFails++;
        s0 = peg$parseIdentifier();
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttributes() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagAttributesItem();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseTagAttributesTail();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseTagAttributesTail();
          }
          peg$savedPos = s0;
          s0 = peg$f5(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesTail() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseTagAttributesItem();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesItem() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagShortcutId();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f7(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseTagShortcutClass();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseTagAttribute();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f9(s1);
            }
            s0 = s1;
          }
        }
        return s0;
      }
      function peg$parseTagShortcutClass() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e2);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f10(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagShortcutId() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e3);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttribute() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c3;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseValue();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f12(s1, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunction() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e5);
          if (input.charCodeAt(peg$currPos) === 40) {
            s2 = peg$c4;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$currPos;
            s5 = peg$parseFunctionParameter();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s6 = [];
            s7 = peg$parseFunctionParameterTail();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parseFunctionParameterTail();
            }
            peg$savedPos = s4;
            s4 = peg$f13(s1, s5, s6);
            rule$expects(peg$e6);
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f14(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameter() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseIdentifier();
        if (s2 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c3;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f15(s2);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$parseValue();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f16(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameterTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseFunctionParameter();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTrailingComma() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        return s0;
      }
      function peg$parseVariable() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e8);
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseVariableTail();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseVariableTail();
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s2, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseVariableTail() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseValueNumber();
            if (s2 === peg$FAILED) {
              s2 = peg$parseValueString();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c8;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f17(s2);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseValue() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$parseValueNull();
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueBoolean();
          if (s0 === peg$FAILED) {
            s0 = peg$parseValueString();
            if (s0 === peg$FAILED) {
              s0 = peg$parseValueNumber();
              if (s0 === peg$FAILED) {
                s0 = peg$parseValueArray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseValueHash();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseFunction();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseVariable();
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseValueNull() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e9);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c9) {
          s1 = peg$c9;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueBoolean() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e10);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c10) {
          s1 = peg$c10;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f20();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c11) {
            s1 = peg$c11;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f21();
          }
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueArray() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e11);
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueArrayTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueArrayTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s3;
            s3 = peg$f22(s4, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e12);
          if (input.charCodeAt(peg$currPos) === 93) {
            s5 = peg$c8;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueArrayTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHash() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e13);
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parse_();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parse_();
          }
          s3 = peg$currPos;
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueHashTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueHashTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s3;
            s3 = peg$f24(s4, s5);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e14);
          if (input.charCodeAt(peg$currPos) === 125) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashTail() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashItem() {
        var s0, s1, s2, s3, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 === peg$FAILED) {
          s1 = peg$parseValueString();
        }
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e15);
          if (input.charCodeAt(peg$currPos) === 58) {
            s2 = peg$c14;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$parseValue();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f26(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueNumber() {
        var s0, s1, s2, s3, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e16);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c1;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f27();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueString() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e17);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseValueStringChars();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseValueStringChars();
          }
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c16;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueStringChars() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueStringEscapes();
        }
        return s0;
      }
      function peg$parseValueStringEscapes() {
        var s0, s1, s2, s3;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c17;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c16;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 92) {
              s2 = peg$c17;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 110) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$f29();
              }
              s2 = s3;
              if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 114) {
                  s3 = peg$c19;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$f30();
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 116) {
                    s3 = peg$c20;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$f31();
                  }
                  s2 = s3;
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f32(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseIdentifier() {
        var s0, s1, s2;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e18);
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parse_() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e19);
        peg$silentFails++;
        if (peg$r4.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      const { Variable: Variable2, Function: Function3 } = options;
      peg$begin();
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$expect(peg$endExpectation());
        }
        throw peg$buildError();
      }
    }
    module.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});
var require_entities = __commonJS2({
  "node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: "\n", nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "	", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
  }
});
var require_entities2 = __commonJS2({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module) {
    "use strict";
    module.exports = require_entities();
  }
});
var require_regex = __commonJS2({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module) {
    module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});
var require_encode = __commonJS2({
  "node_modules/mdurl/encode.js"(exports, module) {
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i2, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        cache[exclude.charCodeAt(i2)] = exclude[i2];
      }
      return cache;
    }
    function encode2(string3, exclude, keepEscaped) {
      var i2, l2, code22, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode2.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i2 = 0, l2 = string3.length; i2 < l2; i2++) {
        code22 = string3.charCodeAt(i2);
        if (keepEscaped && code22 === 37 && i2 + 2 < l2) {
          if (/^[0-9a-f]{2}$/i.test(string3.slice(i2 + 1, i2 + 3))) {
            result += string3.slice(i2, i2 + 3);
            i2 += 2;
            continue;
          }
        }
        if (code22 < 128) {
          result += cache[code22];
          continue;
        }
        if (code22 >= 55296 && code22 <= 57343) {
          if (code22 >= 55296 && code22 <= 56319 && i2 + 1 < l2) {
            nextCode = string3.charCodeAt(i2 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string3[i2] + string3[i2 + 1]);
              i2++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string3[i2]);
      }
      return result;
    }
    encode2.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode2.componentChars = "-_.!~*'()";
    module.exports = encode2;
  }
});
var require_decode = __commonJS2({
  "node_modules/mdurl/decode.js"(exports, module) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i2, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        cache.push(ch);
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        ch = exclude.charCodeAt(i2);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode2(string3, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode2.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string3.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i2, l2, b1, b2, b3, b4, chr, result = "";
        for (i2 = 0, l2 = seq.length; i2 < l2; i2 += 3) {
          b1 = parseInt(seq.slice(i2 + 1, i2 + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i2 + 3 < l2) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "��";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i2 + 6 < l2) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "���";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i2 + 9 < l2) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
            b4 = parseInt(seq.slice(i2 + 10, i2 + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "����";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i2 += 9;
              continue;
            }
          }
          result += "�";
        }
        return result;
      });
    }
    decode2.defaultChars = ";/?:@&=+$,#";
    decode2.componentChars = "";
    module.exports = decode2;
  }
});
var require_format = __commonJS2({
  "node_modules/mdurl/format.js"(exports, module) {
    "use strict";
    module.exports = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});
var require_parse = __commonJS2({
  "node_modules/mdurl/parse.js"(exports, module) {
    "use strict";
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i2, l2, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i2 = 0; i2 < hostEndingChars.length; i2++) {
          hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i2 = 0; i2 < nonHostChars.length; i2++) {
          hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
            var part = hostparts[i2];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module.exports = urlParse;
  }
});
var require_mdurl = __commonJS2({
  "node_modules/mdurl/index.js"(exports, module) {
    "use strict";
    module.exports.encode = require_encode();
    module.exports.decode = require_decode();
    module.exports.format = require_format();
    module.exports.parse = require_parse();
  }
});
var require_regex2 = __commonJS2({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module) {
    module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});
var require_regex3 = __commonJS2({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module) {
    module.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});
var require_regex4 = __commonJS2({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module) {
    module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});
var require_regex5 = __commonJS2({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module) {
    module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});
var require_uc = __commonJS2({
  "node_modules/uc.micro/index.js"(exports) {
    "use strict";
    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});
var require_utils = __commonJS2({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object2, key3) {
      return _hasOwnProperty.call(object2, key3);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key3) {
          obj[key3] = source[key3];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match2, name2) {
      var code22 = 0;
      if (has(entities, name2)) {
        return entities[name2];
      }
      if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
        code22 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
        if (isValidEntityCode(code22)) {
          return fromCodePoint(code22);
        }
      }
      return match2;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match2, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml2(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code22) {
      switch (code22) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code22) {
      if (code22 >= 8192 && code22 <= 8202) {
        return true;
      }
      switch (code22) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("ẞ".toLowerCase() === "Ṿ") {
        str = str.replace(/ẞ/g, "ß");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint;
    exports.escapeHtml = escapeHtml2;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});
var require_parse_link_label = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module) {
    "use strict";
    module.exports = function parseLinkLabel(state2, start2, disableNested) {
      var level, found2, marker, prevPos, labelEnd2 = -1, max22 = state2.posMax, oldPos = state2.pos;
      state2.pos = start2 + 1;
      level = 1;
      while (state2.pos < max22) {
        marker = state2.src.charCodeAt(state2.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found2 = true;
            break;
          }
        }
        prevPos = state2.pos;
        state2.md.inline.skipToken(state2);
        if (marker === 91) {
          if (prevPos === state2.pos - 1) {
            level++;
          } else if (disableNested) {
            state2.pos = oldPos;
            return -1;
          }
        }
      }
      if (found2) {
        labelEnd2 = state2.pos;
      }
      state2.pos = oldPos;
      return labelEnd2;
    };
  }
});
var require_parse_link_destination = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkDestination(str, pos, max22) {
      var code22, level, lines = 0, start2 = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max22) {
          code22 = str.charCodeAt(pos);
          if (code22 === 10) {
            return result;
          }
          if (code22 === 60) {
            return result;
          }
          if (code22 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start2 + 1, pos));
            result.ok = true;
            return result;
          }
          if (code22 === 92 && pos + 1 < max22) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max22) {
        code22 = str.charCodeAt(pos);
        if (code22 === 32) {
          break;
        }
        if (code22 < 32 || code22 === 127) {
          break;
        }
        if (code22 === 92 && pos + 1 < max22) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code22 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code22 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start2 === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start2, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});
var require_parse_link_title = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkTitle(str, pos, max22) {
      var code22, marker, lines = 0, start2 = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max22) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max22) {
        code22 = str.charCodeAt(pos);
        if (code22 === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start2 + 1, pos));
          result.ok = true;
          return result;
        } else if (code22 === 40 && marker === 41) {
          return result;
        } else if (code22 === 10) {
          lines++;
        } else if (code22 === 92 && pos + 1 < max22) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});
var require_helpers = __commonJS2({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});
var require_renderer = __commonJS2({
  "node_modules/markdown-it/lib/renderer.js"(exports, module) {
    "use strict";
    var assign = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml2 = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml2(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml2(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i2, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml2(token.content);
      } else {
        highlighted = escapeHtml2(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i2 = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i2 < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i2] = tmpAttrs[i2].slice();
          tmpAttrs[i2][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml2(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i2, l2, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i2 = 0, l2 = token.attrs.length; i2 < l2; i2++) {
        result += " " + escapeHtml2(token.attrs[i2][0]) + '="' + escapeHtml2(token.attrs[i2][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type, result = "", rules = this.rules;
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        type = tokens[i2].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i2, options, env, this);
        } else {
          result += this.renderToken(tokens, i2, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        if (tokens[i2].type === "text") {
          result += tokens[i2].content;
        } else if (tokens[i2].type === "image") {
          result += this.renderInlineAsText(tokens[i2].children, options, env);
        } else if (tokens[i2].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i2, len, type, result = "", rules = this.rules;
      for (i2 = 0, len = tokens.length; i2 < len; i2++) {
        type = tokens[i2].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i2].children, options, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[tokens[i2].type](tokens, i2, options, env, this);
        } else {
          result += this.renderToken(tokens, i2, options, env);
        }
      }
      return result;
    };
    module.exports = Renderer;
  }
});
var require_ruler = __commonJS2({
  "node_modules/markdown-it/lib/ruler.js"(exports, module) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name2) {
      for (var i2 = 0; i2 < this.__rules__.length; i2++) {
        if (this.__rules__[i2].name === name2) {
          return i2;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name2, fn, options) {
      var index4 = this.__find__(name2);
      var opt = options || {};
      if (index4 === -1) {
        throw new Error("Parser rule not found: " + name2);
      }
      this.__rules__[index4].fn = fn;
      this.__rules__[index4].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
      var index4 = this.__find__(beforeName);
      var opt = options || {};
      if (index4 === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index4, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options) {
      var index4 = this.__find__(afterName);
      var opt = options || {};
      if (index4 === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index4 + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list22, ignoreInvalid) {
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      var result = [];
      list22.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = true;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list22, ignoreInvalid) {
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list22, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list22, ignoreInvalid) {
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      var result = [];
      list22.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = false;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module.exports = Ruler;
  }
});
var require_normalize = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module.exports = function normalize2(state2) {
      var str;
      str = state2.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "�");
      state2.src = str;
    };
  }
});
var require_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module) {
    "use strict";
    module.exports = function block4(state2) {
      var token;
      if (state2.inlineMode) {
        token = new state2.Token("inline", "", 0);
        token.content = state2.src;
        token.map = [0, 1];
        token.children = [];
        state2.tokens.push(token);
      } else {
        state2.md.block.parse(state2.src, state2.md, state2.env, state2.tokens);
      }
    };
  }
});
var require_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module) {
    "use strict";
    module.exports = function inline42(state2) {
      var tokens = state2.tokens, tok, i2, l2;
      for (i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
        tok = tokens[i2];
        if (tok.type === "inline") {
          state2.md.inline.parse(tok.content, state2.md, state2.env, tok.children);
        }
      }
    };
  }
});
var require_linkify = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module) {
    "use strict";
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module.exports = function linkify(state2) {
      var i2, j, l2, tokens, token, currentToken, nodes, ln2, text22, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state2.tokens, links;
      if (!state2.md.options.linkify) {
        return;
      }
      for (j = 0, l2 = blockTokens.length; j < l2; j++) {
        if (blockTokens[j].type !== "inline" || !state2.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i2 = tokens.length - 1; i2 >= 0; i2--) {
          currentToken = tokens[i2];
          if (currentToken.type === "link_close") {
            i2--;
            while (tokens[i2].level !== currentToken.level && tokens[i2].type !== "link_open") {
              i2--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state2.md.linkify.test(currentToken.content)) {
            text22 = currentToken.content;
            links = state2.md.linkify.match(text22);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            for (ln2 = 0; ln2 < links.length; ln2++) {
              url = links[ln2].url;
              fullUrl = state2.md.normalizeLink(url);
              if (!state2.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln2].text;
              if (!links[ln2].schema) {
                urlText = state2.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln2].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state2.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state2.md.normalizeLinkText(urlText);
              }
              pos = links[ln2].index;
              if (pos > lastPos) {
                token = new state2.Token("text", "", 0);
                token.content = text22.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state2.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state2.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state2.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln2].lastIndex;
            }
            if (lastPos < text22.length) {
              token = new state2.Token("text", "", 0);
              token.content = text22.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i2, nodes);
          }
        }
      }
    };
  }
});
var require_replacements = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
    var SCOPED_ABBR = {
      c: "©",
      r: "®",
      p: "§",
      tm: "™"
    };
    function replaceFn(match2, name2) {
      return SCOPED_ABBR[name2.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i2, token, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token = inlineTokens[i2];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i2, token, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token = inlineTokens[i2];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module.exports = function replace3(state2) {
      var blkIdx;
      if (!state2.md.options.typographer) {
        return;
      }
      for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state2.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state2.tokens[blkIdx].content)) {
          replace_scoped(state2.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state2.tokens[blkIdx].content)) {
          replace_rare(state2.tokens[blkIdx].children);
        }
      }
    };
  }
});
var require_smartquotes = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module) {
    "use strict";
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "’";
    function replaceAt(str, index4, ch) {
      return str.substr(0, index4) + ch + str.substr(index4 + 1);
    }
    function process_inlines(tokens, state2) {
      var i2, token, text22, t2, pos, max22, thisLevel, item2, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i2 = 0; i2 < tokens.length; i2++) {
        token = tokens[i2];
        thisLevel = tokens[i2].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text22 = token.content;
        pos = 0;
        max22 = text22.length;
        OUTER:
          while (pos < max22) {
            QUOTE_RE.lastIndex = pos;
            t2 = QUOTE_RE.exec(text22);
            if (!t2) {
              break;
            }
            canOpen = canClose = true;
            pos = t2.index + 1;
            isSingle = t2[0] === "'";
            lastChar = 32;
            if (t2.index - 1 >= 0) {
              lastChar = text22.charCodeAt(t2.index - 1);
            } else {
              for (j = i2 - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max22) {
              nextChar = text22.charCodeAt(pos);
            } else {
              for (j = i2 + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t2[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t2.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item2 = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item2.single === isSingle && stack[j].level === thisLevel) {
                  item2 = stack[j];
                  if (isSingle) {
                    openQuote = state2.md.options.quotes[2];
                    closeQuote = state2.md.options.quotes[3];
                  } else {
                    openQuote = state2.md.options.quotes[0];
                    closeQuote = state2.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t2.index, closeQuote);
                  tokens[item2.token].content = replaceAt(tokens[item2.token].content, item2.pos, openQuote);
                  pos += closeQuote.length - 1;
                  if (item2.token === i2) {
                    pos += openQuote.length - 1;
                  }
                  text22 = token.content;
                  max22 = text22.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i2,
                pos: t2.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t2.index, APOSTROPHE);
            }
          }
      }
    }
    module.exports = function smartquotes(state2) {
      var blkIdx;
      if (!state2.md.options.typographer) {
        return;
      }
      for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state2.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state2.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state2.tokens[blkIdx].children, state2);
      }
    };
  }
});
var require_token = __commonJS2({
  "node_modules/markdown-it/lib/token.js"(exports, module) {
    "use strict";
    function Token3(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token3.prototype.attrIndex = function attrIndex(name2) {
      var attrs, i2, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i2 = 0, len = attrs.length; i2 < len; i2++) {
        if (attrs[i2][0] === name2) {
          return i2;
        }
      }
      return -1;
    };
    Token3.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token3.prototype.attrSet = function attrSet(name2, value) {
      var idx = this.attrIndex(name2), attrData = [name2, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token3.prototype.attrGet = function attrGet(name2) {
      var idx = this.attrIndex(name2), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token3.prototype.attrJoin = function attrJoin(name2, value) {
      var idx = this.attrIndex(name2);
      if (idx < 0) {
        this.attrPush([name2, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module.exports = Token3;
  }
});
var require_state_core = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module) {
    "use strict";
    var Token3 = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token3;
    module.exports = StateCore;
  }
});
var require_parser_core = __commonJS2({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
    }
    Core.prototype.process = function(state2) {
      var i2, l2, rules;
      rules = this.ruler.getRules("");
      for (i2 = 0, l2 = rules.length; i2 < l2; i2++) {
        rules[i2](state2);
      }
    };
    Core.prototype.State = require_state_core();
    module.exports = Core;
  }
});
var require_table = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function getLine2(state2, line) {
      var pos = state2.bMarks[line] + state2.tShift[line], max22 = state2.eMarks[line];
      return state2.src.substr(pos, max22 - pos);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max22 = str.length, ch, isEscaped = false, lastPos = 0, current2 = "";
      ch = str.charCodeAt(pos);
      while (pos < max22) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current2 + str.substring(lastPos, pos));
            current2 = "";
            lastPos = pos + 1;
          } else {
            current2 += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current2 + str.substring(lastPos));
      return result;
    }
    module.exports = function table3(state2, startLine, endLine, silent) {
      var ch, lineText, pos, i2, l2, nextLine, columns, columnCount, token, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state2.sCount[nextLine] < state2.blkIndent) {
        return false;
      }
      if (!state2.md.options.allowIndentation && state2.sCount[nextLine] - state2.blkIndent >= 4) {
        return false;
      }
      pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      if (pos >= state2.eMarks[nextLine]) {
        return false;
      }
      firstCh = state2.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state2.eMarks[nextLine]) {
        return false;
      }
      secondCh = state2.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state2.eMarks[nextLine]) {
        ch = state2.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine2(state2, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i2 = 0; i2 < columns.length; i2++) {
        t2 = columns[i2].trim();
        if (!t2) {
          if (i2 === 0 || i2 === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t2)) {
          return false;
        }
        if (t2.charCodeAt(t2.length - 1) === 58) {
          aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t2.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine2(state2, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state2.parentType;
      state2.parentType = "table";
      terminatorRules = state2.md.block.ruler.getRules("blockquote");
      token = state2.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state2.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state2.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i2 = 0; i2 < columns.length; i2++) {
        token = state2.push("th_open", "th", 1);
        if (aligns[i2]) {
          token.attrs = [["style", "text-align:" + aligns[i2]]];
        }
        token = state2.push("inline", "", 0);
        token.content = columns[i2].trim();
        token.children = [];
        token = state2.push("th_close", "th", -1);
      }
      token = state2.push("tr_close", "tr", -1);
      token = state2.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state2.sCount[nextLine] < state2.blkIndent) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state2, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine2(state2, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (!state2.md.options.allowIndentation && state2.sCount[nextLine] - state2.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state2.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state2.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i2 = 0; i2 < columnCount; i2++) {
          token = state2.push("td_open", "td", 1);
          if (aligns[i2]) {
            token.attrs = [["style", "text-align:" + aligns[i2]]];
          }
          token = state2.push("inline", "", 0);
          token.content = columns[i2] ? columns[i2].trim() : "";
          token.children = [];
          token = state2.push("td_close", "td", -1);
        }
        token = state2.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state2.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state2.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state2.parentType = oldParentType;
      state2.line = nextLine;
      return true;
    };
  }
});
var require_code = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module) {
    "use strict";
    module.exports = function code22(state2, startLine, endLine) {
      if (state2.md.options.allowIndentation) {
        return false;
      }
      var nextLine, last, token;
      if (state2.sCount[startLine] - state2.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state2.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state2.line = last;
      token = state2.push("code_block", "code", 0);
      token.content = state2.getLines(startLine, last, 4 + state2.blkIndent, false) + "\n";
      token.map = [startLine, state2.line];
      return true;
    };
  }
});
var require_fence = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module) {
    "use strict";
    module.exports = function fence3(state2, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state2.bMarks[startLine] + state2.tShift[startLine], max22 = state2.eMarks[startLine];
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max22) {
        return false;
      }
      marker = state2.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state2.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state2.src.slice(mem, pos);
      params = state2.src.slice(pos, max22);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state2.bMarks[nextLine] + state2.tShift[nextLine];
        max22 = state2.eMarks[nextLine];
        if (pos < max22 && state2.sCount[nextLine] < state2.blkIndent) {
          break;
        }
        if (state2.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (!state2.md.options.allowIndentation && state2.sCount[nextLine] - state2.blkIndent >= 4) {
          continue;
        }
        pos = state2.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state2.skipSpaces(pos);
        if (pos < max22) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state2.sCount[startLine];
      state2.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state2.push("fence", "code", 0);
      token.info = params;
      token.content = state2.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state2.line];
      return true;
    };
  }
});
var require_blockquote = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function blockquote22(state2, startLine, endLine, silent) {
      var adjustTab, ch, i2, initial, l2, lastLineEmpty, lines, nextLine, offset5, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state2.lineMax, pos = state2.bMarks[startLine] + state2.tShift[startLine], max22 = state2.eMarks[startLine];
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      if (state2.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset5 = state2.sCount[startLine] + 1;
      if (state2.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset5++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state2.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state2.bsCount[startLine] + offset5) % 4 === 3) {
          pos++;
          initial++;
          offset5++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state2.bMarks[startLine]];
      state2.bMarks[startLine] = pos;
      while (pos < max22) {
        ch = state2.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset5 += 4 - (offset5 + state2.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset5++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state2.bsCount[startLine]];
      state2.bsCount[startLine] = state2.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max22;
      oldSCount = [state2.sCount[startLine]];
      state2.sCount[startLine] = offset5 - initial;
      oldTShift = [state2.tShift[startLine]];
      state2.tShift[startLine] = pos - state2.bMarks[startLine];
      terminatorRules = state2.md.block.ruler.getRules("blockquote");
      oldParentType = state2.parentType;
      state2.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state2.sCount[nextLine] < state2.blkIndent;
        pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
        max22 = state2.eMarks[nextLine];
        if (pos >= max22) {
          break;
        }
        if (state2.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset5 = state2.sCount[nextLine] + 1;
          if (state2.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset5++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state2.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state2.bsCount[nextLine] + offset5) % 4 === 3) {
              pos++;
              initial++;
              offset5++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state2.bMarks[nextLine]);
          state2.bMarks[nextLine] = pos;
          while (pos < max22) {
            ch = state2.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset5 += 4 - (offset5 + state2.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset5++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max22;
          oldBSCount.push(state2.bsCount[nextLine]);
          state2.bsCount[nextLine] = state2.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state2.sCount[nextLine]);
          state2.sCount[nextLine] = offset5 - initial;
          oldTShift.push(state2.tShift[nextLine]);
          state2.tShift[nextLine] = pos - state2.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state2, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state2.lineMax = nextLine;
          if (state2.blkIndent !== 0) {
            oldBMarks.push(state2.bMarks[nextLine]);
            oldBSCount.push(state2.bsCount[nextLine]);
            oldTShift.push(state2.tShift[nextLine]);
            oldSCount.push(state2.sCount[nextLine]);
            state2.sCount[nextLine] -= state2.blkIndent;
          }
          break;
        }
        oldBMarks.push(state2.bMarks[nextLine]);
        oldBSCount.push(state2.bsCount[nextLine]);
        oldTShift.push(state2.tShift[nextLine]);
        oldSCount.push(state2.sCount[nextLine]);
        state2.sCount[nextLine] = -1;
      }
      oldIndent = state2.blkIndent;
      state2.blkIndent = 0;
      token = state2.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state2.md.block.tokenize(state2, startLine, nextLine);
      token = state2.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state2.lineMax = oldLineMax;
      state2.parentType = oldParentType;
      lines[1] = state2.line;
      for (i2 = 0; i2 < oldTShift.length; i2++) {
        state2.bMarks[i2 + startLine] = oldBMarks[i2];
        state2.tShift[i2 + startLine] = oldTShift[i2];
        state2.sCount[i2 + startLine] = oldSCount[i2];
        state2.bsCount[i2 + startLine] = oldBSCount[i2];
      }
      state2.blkIndent = oldIndent;
      return true;
    };
  }
});
var require_hr = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function hr2(state2, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state2.bMarks[startLine] + state2.tShift[startLine], max22 = state2.eMarks[startLine];
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      marker = state2.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max22) {
        ch = state2.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state2.line = startLine + 1;
      token = state2.push("hr", "hr", 0);
      token.map = [startLine, state2.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});
var require_list = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state2, startLine) {
      var marker, pos, max22, ch;
      pos = state2.bMarks[startLine] + state2.tShift[startLine];
      max22 = state2.eMarks[startLine];
      marker = state2.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max22) {
        ch = state2.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state2, startLine) {
      var ch, start2 = state2.bMarks[startLine] + state2.tShift[startLine], pos = start2, max22 = state2.eMarks[startLine];
      if (pos + 1 >= max22) {
        return -1;
      }
      ch = state2.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max22) {
          return -1;
        }
        ch = state2.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start2 >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max22) {
        ch = state2.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state2, idx) {
      var i2, l2, level = state2.level + 2;
      for (i2 = idx + 2, l2 = state2.tokens.length - 2; i2 < l2; i2++) {
        if (state2.tokens[i2].level === level && state2.tokens[i2].type === "paragraph_open") {
          state2.tokens[i2 + 2].hidden = true;
          state2.tokens[i2].hidden = true;
          i2 += 2;
        }
      }
    }
    module.exports = function list22(state2, startLine, endLine, silent) {
      var ch, contentStart, i2, indent3, indentAfterMarker, initial, isOrdered, itemLines, l2, listLines, listTokIdx, markerCharCode, markerValue, max22, nextLine, offset5, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start2, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      if (!state2.md.options.allowIndentation && state2.listIndent >= 0 && state2.sCount[startLine] - state2.listIndent >= 4 && state2.sCount[startLine] < state2.blkIndent) {
        return false;
      }
      if (silent && state2.parentType === "paragraph") {
        if (state2.sCount[startLine] >= state2.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state2, startLine)) >= 0) {
        isOrdered = true;
        start2 = state2.bMarks[startLine] + state2.tShift[startLine];
        markerValue = Number(state2.src.slice(start2, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state2, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state2.skipSpaces(posAfterMarker) >= state2.eMarks[startLine])
          return false;
      }
      markerCharCode = state2.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state2.tokens.length;
      if (isOrdered) {
        token = state2.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state2.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state2.md.block.ruler.getRules("list");
      oldParentType = state2.parentType;
      state2.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max22 = state2.eMarks[nextLine];
        initial = offset5 = state2.sCount[nextLine] + posAfterMarker - (state2.bMarks[startLine] + state2.tShift[startLine]);
        while (pos < max22) {
          ch = state2.src.charCodeAt(pos);
          if (ch === 9) {
            offset5 += 4 - (offset5 + state2.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset5++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max22) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset5 - initial;
        }
        if (!state2.md.options.allowIndentation && indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent3 = initial + indentAfterMarker;
        token = state2.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token.info = state2.src.slice(start2, posAfterMarker - 1);
        }
        oldTight = state2.tight;
        oldTShift = state2.tShift[startLine];
        oldSCount = state2.sCount[startLine];
        oldListIndent = state2.listIndent;
        state2.listIndent = state2.blkIndent;
        state2.blkIndent = indent3;
        state2.tight = true;
        state2.tShift[startLine] = contentStart - state2.bMarks[startLine];
        state2.sCount[startLine] = offset5;
        if (contentStart >= max22 && state2.isEmpty(startLine + 1)) {
          state2.line = Math.min(state2.line + 2, endLine);
        } else {
          state2.md.block.tokenize(state2, startLine, endLine, true);
        }
        if (!state2.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state2.line - startLine > 1 && state2.isEmpty(state2.line - 1);
        state2.blkIndent = state2.listIndent;
        state2.listIndent = oldListIndent;
        state2.tShift[startLine] = oldTShift;
        state2.sCount[startLine] = oldSCount;
        state2.tight = oldTight;
        token = state2.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state2.line;
        itemLines[1] = nextLine;
        contentStart = state2.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state2.sCount[nextLine] < state2.blkIndent) {
          break;
        }
        if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state2, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state2, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start2 = state2.bMarks[nextLine] + state2.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state2, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state2.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state2.push("ordered_list_close", "ol", -1);
      } else {
        token = state2.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state2.line = nextLine;
      state2.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state2, listTokIdx);
      }
      return true;
    };
  }
});
var require_reference = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function reference(state2, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i2, l2, label, labelEnd2, oldParentType, res, start2, str, terminate, terminatorRules, title, lines = 0, pos = state2.bMarks[startLine] + state2.tShift[startLine], max22 = state2.eMarks[startLine], nextLine = startLine + 1;
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      if (state2.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max22) {
        if (state2.src.charCodeAt(pos) === 93 && state2.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max22) {
            return false;
          }
          if (state2.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state2.lineMax;
      terminatorRules = state2.md.block.ruler.getRules("reference");
      oldParentType = state2.parentType;
      state2.parentType = "reference";
      for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
        if (!state2.md.options.allowIndentation && state2.sCount[nextLine] - state2.blkIndent > 3) {
          continue;
        }
        if (state2.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state2, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
      max22 = str.length;
      for (pos = 1; pos < max22; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd2 = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max22 && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd2 < 0 || str.charCodeAt(labelEnd2 + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd2 + 2; pos < max22; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state2.md.helpers.parseLinkDestination(str, pos, max22);
      if (!res.ok) {
        return false;
      }
      href = state2.md.normalizeLink(res.str);
      if (!state2.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start2 = pos;
      for (; pos < max22; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state2.md.helpers.parseLinkTitle(str, pos, max22);
      if (pos < max22 && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max22) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max22 && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max22) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max22 && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd2));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state2.env.references === "undefined") {
        state2.env.references = {};
      }
      if (typeof state2.env.references[label] === "undefined") {
        state2.env.references[label] = { title, href };
      }
      state2.parentType = oldParentType;
      state2.line = startLine + lines + 1;
      return true;
    };
  }
});
var require_html_blocks = __commonJS2({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module) {
    "use strict";
    module.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});
var require_html_re = __commonJS2({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module) {
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment2 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment2 + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module.exports.HTML_TAG_RE = HTML_TAG_RE;
    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});
var require_html_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module.exports = function html_block(state2, startLine, endLine, silent) {
      var i2, nextLine, token, lineText, pos = state2.bMarks[startLine] + state2.tShift[startLine], max22 = state2.eMarks[startLine];
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      if (!state2.md.options.html) {
        return false;
      }
      if (state2.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state2.src.slice(pos, max22);
      for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
        if (HTML_SEQUENCES[i2][0].test(lineText)) {
          break;
        }
      }
      if (i2 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i2][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i2][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state2.sCount[nextLine] < state2.blkIndent) {
            break;
          }
          pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
          max22 = state2.eMarks[nextLine];
          lineText = state2.src.slice(pos, max22);
          if (HTML_SEQUENCES[i2][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state2.line = nextLine;
      token = state2.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state2.getLines(startLine, nextLine, state2.blkIndent, true);
      return true;
    };
  }
});
var require_heading = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function heading22(state2, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state2.bMarks[startLine] + state2.tShift[startLine], max22 = state2.eMarks[startLine];
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      ch = state2.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max22) {
        return false;
      }
      level = 1;
      ch = state2.src.charCodeAt(++pos);
      while (ch === 35 && pos < max22 && level <= 6) {
        level++;
        ch = state2.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max22 && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max22 = state2.skipSpacesBack(max22, pos);
      tmp = state2.skipCharsBack(max22, 35, pos);
      if (tmp > pos && isSpace(state2.src.charCodeAt(tmp - 1))) {
        max22 = tmp;
      }
      state2.line = startLine + 1;
      token = state2.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state2.line];
      token = state2.push("inline", "", 0);
      token.content = state2.src.slice(pos, max22).trim();
      token.map = [startLine, state2.line];
      token.children = [];
      token = state2.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});
var require_lheading = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module) {
    "use strict";
    module.exports = function lheading(state2, startLine, endLine) {
      var content3, terminate, i2, l2, token, pos, max22, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state2.md.block.ruler.getRules("paragraph");
      if (!state2.md.options.allowIndentation && state2.sCount[startLine] - state2.blkIndent >= 4) {
        return false;
      }
      oldParentType = state2.parentType;
      state2.parentType = "paragraph";
      for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
        if (!state2.md.options.allowIndentation && state2.sCount[nextLine] - state2.blkIndent > 3) {
          continue;
        }
        if (state2.sCount[nextLine] >= state2.blkIndent) {
          pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
          max22 = state2.eMarks[nextLine];
          if (pos < max22) {
            marker = state2.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state2.skipChars(pos, marker);
              pos = state2.skipSpaces(pos);
              if (pos >= max22) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state2.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state2, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content3 = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
      state2.line = nextLine + 1;
      token = state2.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state2.line];
      token = state2.push("inline", "", 0);
      token.content = content3;
      token.map = [startLine, state2.line - 1];
      token.children = [];
      token = state2.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state2.parentType = oldParentType;
      return true;
    };
  }
});
var require_paragraph = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module) {
    "use strict";
    module.exports = function paragraph22(state2, startLine) {
      var content3, terminate, i2, l2, token, oldParentType, nextLine = startLine + 1, terminatorRules = state2.md.block.ruler.getRules("paragraph"), endLine = state2.lineMax;
      oldParentType = state2.parentType;
      state2.parentType = "paragraph";
      for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
        if (!state2.md.options.allowIndentation && state2.sCount[nextLine] - state2.blkIndent > 3) {
          continue;
        }
        if (state2.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state2, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content3 = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
      state2.line = nextLine;
      token = state2.push("paragraph_open", "p", 1);
      token.map = [startLine, state2.line];
      token = state2.push("inline", "", 0);
      token.content = content3;
      token.map = [startLine, state2.line];
      token.children = [];
      token = state2.push("paragraph_close", "p", -1);
      state2.parentType = oldParentType;
      return true;
    };
  }
});
var require_state_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module) {
    "use strict";
    var Token3 = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s2, start2, pos, len, indent3, offset5, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s2 = this.src;
      indent_found = false;
      for (start2 = pos = indent3 = offset5 = 0, len = s2.length; pos < len; pos++) {
        ch = s2.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent3++;
            if (ch === 9) {
              offset5 += 4 - offset5 % 4;
            } else {
              offset5++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start2);
          this.eMarks.push(pos);
          this.tShift.push(indent3);
          this.sCount.push(offset5);
          this.bsCount.push(0);
          indent_found = false;
          indent3 = 0;
          offset5 = 0;
          start2 = pos + 1;
        }
      }
      this.bMarks.push(s2.length);
      this.eMarks.push(s2.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token = new Token3(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from2) {
      for (var max22 = this.lineMax; from2 < max22; from2++) {
        if (this.bMarks[from2] + this.tShift[from2] < this.eMarks[from2]) {
          break;
        }
      }
      return from2;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max22 = this.src.length; pos < max22; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min3) {
      if (pos <= min3) {
        return pos;
      }
      while (pos > min3) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code22) {
      for (var max22 = this.src.length; pos < max22; pos++) {
        if (this.src.charCodeAt(pos) !== code22) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code22, min3) {
      if (pos <= min3) {
        return pos;
      }
      while (pos > min3) {
        if (code22 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent3, keepLastLF) {
      var i2, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i2 = 0; line < end; line++, i2++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent3) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent3) {
          queue[i2] = new Array(lineIndent - indent3 + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i2] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token3;
    module.exports = StateBlock;
  }
});
var require_parser_block = __commonJS2({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1], { alt: (_rules[i2][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state2, startLine, endLine) {
      var ok3, i2, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state2.md.options.maxNesting;
      while (line < endLine) {
        state2.line = line = state2.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state2.sCount[line] < state2.blkIndent) {
          break;
        }
        if (state2.level >= maxNesting) {
          state2.line = endLine;
          break;
        }
        for (i2 = 0; i2 < len; i2++) {
          ok3 = rules[i2](state2, line, endLine, false);
          if (ok3) {
            break;
          }
        }
        state2.tight = !hasEmptyLines;
        if (state2.isEmpty(state2.line - 1)) {
          hasEmptyLines = true;
        }
        line = state2.line;
        if (line < endLine && state2.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state2.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state2;
      if (!src) {
        return;
      }
      state2 = new this.State(src, md, env, outTokens);
      this.tokenize(state2, state2.line, state2.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module.exports = ParserBlock;
  }
});
var require_text = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module.exports = function text22(state2, silent) {
      var pos = state2.pos;
      while (pos < state2.posMax && !isTerminatorChar(state2.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state2.pos) {
        return false;
      }
      if (!silent) {
        state2.pending += state2.src.slice(state2.pos, pos);
      }
      state2.pos = pos;
      return true;
    };
  }
});
var require_newline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function newline(state2, silent) {
      var pmax, max22, ws, pos = state2.pos;
      if (state2.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state2.pending.length - 1;
      max22 = state2.posMax;
      if (!silent) {
        if (pmax >= 0 && state2.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state2.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state2.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state2.pending = state2.pending.slice(0, ws);
            state2.push("hardbreak", "br", 0);
          } else {
            state2.pending = state2.pending.slice(0, -1);
            state2.push("softbreak", "br", 0);
          }
        } else {
          state2.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max22 && isSpace(state2.src.charCodeAt(pos))) {
        pos++;
      }
      state2.pos = pos;
      return true;
    };
  }
});
var require_escape = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i2 = 0; i2 < 256; i2++) {
      ESCAPED.push(0);
    }
    var i2;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module.exports = function escape3(state2, silent) {
      var ch, pos = state2.pos, max22 = state2.posMax;
      if (state2.src.charCodeAt(pos) !== 92) {
        return false;
      }
      pos++;
      if (pos < max22) {
        ch = state2.src.charCodeAt(pos);
        if (ch < 256 && ESCAPED[ch] !== 0) {
          if (!silent) {
            state2.pending += state2.src[pos];
          }
          state2.pos += 2;
          return true;
        }
        if (ch === 10) {
          if (!silent) {
            state2.push("hardbreak", "br", 0);
          }
          pos++;
          while (pos < max22) {
            ch = state2.src.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
          state2.pos = pos;
          return true;
        }
      }
      if (!silent) {
        state2.pending += "\\";
      }
      state2.pos++;
      return true;
    };
  }
});
var require_backticks = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module) {
    "use strict";
    module.exports = function backtick(state2, silent) {
      var start2, max22, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state2.pos, ch = state2.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start2 = pos;
      pos++;
      max22 = state2.posMax;
      while (pos < max22 && state2.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state2.src.slice(start2, pos);
      openerLength = marker.length;
      if (state2.backticksScanned && (state2.backticks[openerLength] || 0) <= start2) {
        if (!silent)
          state2.pending += marker;
        state2.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state2.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max22 && state2.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state2.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state2.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state2.pos = matchEnd;
          return true;
        }
        state2.backticks[closerLength] = matchStart;
      }
      state2.backticksScanned = true;
      if (!silent)
        state2.pending += marker;
      state2.pos += openerLength;
      return true;
    };
  }
});
var require_strikethrough = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function strikethrough(state2, silent) {
      var i2, scanned, token, len, ch, start2 = state2.pos, marker = state2.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state2.scanDelims(state2.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state2.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i2 = 0; i2 < len; i2 += 2) {
        token = state2.push("text", "", 0);
        token.content = ch + ch;
        state2.delimiters.push({
          marker,
          length: 0,
          token: state2.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state2.pos += scanned.length;
      return true;
    };
    function postProcess(state2, delimiters) {
      var i2, j, startDelim, endDelim, token, loneMarkers = [], max22 = delimiters.length;
      for (i2 = 0; i2 < max22; i2++) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state2.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state2.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state2.tokens[endDelim.token - 1].type === "text" && state2.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i2 = loneMarkers.pop();
        j = i2 + 1;
        while (j < state2.tokens.length && state2.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i2 !== j) {
          token = state2.tokens[j];
          state2.tokens[j] = state2.tokens[i2];
          state2.tokens[i2] = token;
        }
      }
    }
    module.exports.postProcess = function strikethrough(state2) {
      var curr, tokens_meta = state2.tokens_meta, max22 = state2.tokens_meta.length;
      postProcess(state2, state2.delimiters);
      for (curr = 0; curr < max22; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state2, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_emphasis = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function emphasis2(state2, silent) {
      var i2, scanned, token, start2 = state2.pos, marker = state2.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state2.scanDelims(state2.pos, marker === 42);
      for (i2 = 0; i2 < scanned.length; i2++) {
        token = state2.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state2.delimiters.push({
          marker,
          length: scanned.length,
          token: state2.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state2.pos += scanned.length;
      return true;
    };
    function postProcess(state2, delimiters) {
      var i2, startDelim, endDelim, token, ch, isStrong, max22 = delimiters.length;
      for (i2 = max22 - 1; i2 >= 0; i2--) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state2.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state2.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state2.tokens[delimiters[i2 - 1].token].content = "";
          state2.tokens[delimiters[startDelim.end + 1].token].content = "";
          i2--;
        }
      }
    }
    module.exports.postProcess = function emphasis2(state2) {
      var curr, tokens_meta = state2.tokens_meta, max22 = state2.tokens_meta.length;
      postProcess(state2, state2.delimiters);
      for (curr = 0; curr < max22; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state2, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_link = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function link22(state2, silent) {
      var attrs, code22, label, labelEnd2, labelStart, pos, res, ref2, token, href = "", title = "", oldPos = state2.pos, max22 = state2.posMax, start2 = state2.pos, parseReference = true;
      if (state2.src.charCodeAt(state2.pos) !== 91) {
        return false;
      }
      labelStart = state2.pos + 1;
      labelEnd2 = state2.md.helpers.parseLinkLabel(state2, state2.pos, true);
      if (labelEnd2 < 0) {
        return false;
      }
      pos = labelEnd2 + 1;
      if (pos < max22 && state2.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max22; pos++) {
          code22 = state2.src.charCodeAt(pos);
          if (!isSpace(code22) && code22 !== 10) {
            break;
          }
        }
        if (pos >= max22) {
          return false;
        }
        start2 = pos;
        res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
        if (res.ok) {
          href = state2.md.normalizeLink(res.str);
          if (state2.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start2 = pos;
          for (; pos < max22; pos++) {
            code22 = state2.src.charCodeAt(pos);
            if (!isSpace(code22) && code22 !== 10) {
              break;
            }
          }
          res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
          if (pos < max22 && start2 !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max22; pos++) {
              code22 = state2.src.charCodeAt(pos);
              if (!isSpace(code22) && code22 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max22 || state2.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state2.env.references === "undefined") {
          return false;
        }
        if (pos < max22 && state2.src.charCodeAt(pos) === 91) {
          start2 = pos + 1;
          pos = state2.md.helpers.parseLinkLabel(state2, pos);
          if (pos >= 0) {
            label = state2.src.slice(start2, pos++);
          } else {
            pos = labelEnd2 + 1;
          }
        } else {
          pos = labelEnd2 + 1;
        }
        if (!label) {
          label = state2.src.slice(labelStart, labelEnd2);
        }
        ref2 = state2.env.references[normalizeReference(label)];
        if (!ref2) {
          state2.pos = oldPos;
          return false;
        }
        href = ref2.href;
        title = ref2.title;
      }
      if (!silent) {
        state2.pos = labelStart;
        state2.posMax = labelEnd2;
        token = state2.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state2.md.inline.tokenize(state2);
        token = state2.push("link_close", "a", -1);
      }
      state2.pos = pos;
      state2.posMax = max22;
      return true;
    };
  }
});
var require_image = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function image22(state2, silent) {
      var attrs, code22, content3, label, labelEnd2, labelStart, pos, ref2, res, title, token, tokens, start2, href = "", oldPos = state2.pos, max22 = state2.posMax;
      if (state2.src.charCodeAt(state2.pos) !== 33) {
        return false;
      }
      if (state2.src.charCodeAt(state2.pos + 1) !== 91) {
        return false;
      }
      labelStart = state2.pos + 2;
      labelEnd2 = state2.md.helpers.parseLinkLabel(state2, state2.pos + 1, false);
      if (labelEnd2 < 0) {
        return false;
      }
      pos = labelEnd2 + 1;
      if (pos < max22 && state2.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max22; pos++) {
          code22 = state2.src.charCodeAt(pos);
          if (!isSpace(code22) && code22 !== 10) {
            break;
          }
        }
        if (pos >= max22) {
          return false;
        }
        start2 = pos;
        res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
        if (res.ok) {
          href = state2.md.normalizeLink(res.str);
          if (state2.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start2 = pos;
        for (; pos < max22; pos++) {
          code22 = state2.src.charCodeAt(pos);
          if (!isSpace(code22) && code22 !== 10) {
            break;
          }
        }
        res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
        if (pos < max22 && start2 !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max22; pos++) {
            code22 = state2.src.charCodeAt(pos);
            if (!isSpace(code22) && code22 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max22 || state2.src.charCodeAt(pos) !== 41) {
          state2.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state2.env.references === "undefined") {
          return false;
        }
        if (pos < max22 && state2.src.charCodeAt(pos) === 91) {
          start2 = pos + 1;
          pos = state2.md.helpers.parseLinkLabel(state2, pos);
          if (pos >= 0) {
            label = state2.src.slice(start2, pos++);
          } else {
            pos = labelEnd2 + 1;
          }
        } else {
          pos = labelEnd2 + 1;
        }
        if (!label) {
          label = state2.src.slice(labelStart, labelEnd2);
        }
        ref2 = state2.env.references[normalizeReference(label)];
        if (!ref2) {
          state2.pos = oldPos;
          return false;
        }
        href = ref2.href;
        title = ref2.title;
      }
      if (!silent) {
        content3 = state2.src.slice(labelStart, labelEnd2);
        state2.md.inline.parse(content3, state2.md, state2.env, tokens = []);
        token = state2.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content3;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state2.pos = pos;
      state2.posMax = max22;
      return true;
    };
  }
});
var require_autolink = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module) {
    "use strict";
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module.exports = function autolink2(state2, silent) {
      var url, fullUrl, token, ch, start2, max22, pos = state2.pos;
      if (state2.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start2 = state2.pos;
      max22 = state2.posMax;
      for (; ; ) {
        if (++pos >= max22)
          return false;
        ch = state2.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state2.src.slice(start2 + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state2.md.normalizeLink(url);
        if (!state2.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state2.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state2.push("text", "", 0);
          token.content = state2.md.normalizeLinkText(url);
          token = state2.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state2.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state2.md.normalizeLink("mailto:" + url);
        if (!state2.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state2.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state2.push("text", "", 0);
          token.content = state2.md.normalizeLinkText(url);
          token = state2.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state2.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});
var require_html_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module) {
    "use strict";
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module.exports = function html_inline(state2, silent) {
      var ch, match2, max22, token, pos = state2.pos;
      if (!state2.md.options.html) {
        return false;
      }
      max22 = state2.posMax;
      if (state2.src.charCodeAt(pos) !== 60 || pos + 2 >= max22) {
        return false;
      }
      ch = state2.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match2 = state2.src.slice(pos).match(HTML_TAG_RE);
      if (!match2) {
        return false;
      }
      if (!silent) {
        token = state2.push("html_inline", "", 0);
        token.content = state2.src.slice(pos, pos + match2[0].length);
      }
      state2.pos += match2[0].length;
      return true;
    };
  }
});
var require_entity = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module) {
    "use strict";
    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module.exports = function entity(state2, silent) {
      var ch, code22, match2, pos = state2.pos, max22 = state2.posMax;
      if (state2.src.charCodeAt(pos) !== 38) {
        return false;
      }
      if (pos + 1 < max22) {
        ch = state2.src.charCodeAt(pos + 1);
        if (ch === 35) {
          match2 = state2.src.slice(pos).match(DIGITAL_RE);
          if (match2) {
            if (!silent) {
              code22 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
              state2.pending += isValidEntityCode(code22) ? fromCodePoint(code22) : fromCodePoint(65533);
            }
            state2.pos += match2[0].length;
            return true;
          }
        } else {
          match2 = state2.src.slice(pos).match(NAMED_RE);
          if (match2) {
            if (has(entities, match2[1])) {
              if (!silent) {
                state2.pending += entities[match2[1]];
              }
              state2.pos += match2[0].length;
              return true;
            }
          }
        }
      }
      if (!silent) {
        state2.pending += "&";
      }
      state2.pos++;
      return true;
    };
  }
});
var require_balance_pairs = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module) {
    "use strict";
    function processDelimiters(state2, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max22 = delimiters.length;
      if (!max22)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max22; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module.exports = function link_pairs(state2) {
      var curr, tokens_meta = state2.tokens_meta, max22 = state2.tokens_meta.length;
      processDelimiters(state2, state2.delimiters);
      for (curr = 0; curr < max22; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state2, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_text_collapse = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/text_collapse.js"(exports, module) {
    "use strict";
    module.exports = function text_collapse(state2) {
      var curr, last, level = 0, tokens = state2.tokens, max22 = state2.tokens.length;
      for (curr = last = 0; curr < max22; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max22 && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});
var require_state_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module) {
    "use strict";
    var Token3 = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token3("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token3(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start2, canSplitWord) {
      var pos = start2, lastChar, nextChar, count2, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max22 = this.posMax, marker = this.src.charCodeAt(start2);
      lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
      while (pos < max22 && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count2 = pos - start2;
      nextChar = pos < max22 ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count2
      };
    };
    StateInline.prototype.Token = Token3;
    module.exports = StateInline;
  }
});
var require_parser_inline = __commonJS2({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      ["text_collapse", require_text_collapse()]
    ];
    function ParserInline() {
      var i2;
      this.ruler = new Ruler();
      for (i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
      this.ruler2 = new Ruler();
      for (i2 = 0; i2 < _rules2.length; i2++) {
        this.ruler2.push(_rules2[i2][0], _rules2[i2][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state2) {
      var ok3, i2, pos = state2.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state2.md.options.maxNesting, cache = state2.cache;
      if (typeof cache[pos] !== "undefined") {
        state2.pos = cache[pos];
        return;
      }
      if (state2.level < maxNesting) {
        for (i2 = 0; i2 < len; i2++) {
          state2.level++;
          ok3 = rules[i2](state2, true);
          state2.level--;
          if (ok3) {
            break;
          }
        }
      } else {
        state2.pos = state2.posMax;
      }
      if (!ok3) {
        state2.pos++;
      }
      cache[pos] = state2.pos;
    };
    ParserInline.prototype.tokenize = function(state2) {
      var ok3, i2, rules = this.ruler.getRules(""), len = rules.length, end = state2.posMax, maxNesting = state2.md.options.maxNesting;
      while (state2.pos < end) {
        if (state2.level < maxNesting) {
          for (i2 = 0; i2 < len; i2++) {
            ok3 = rules[i2](state2, false);
            if (ok3) {
              break;
            }
          }
        }
        if (ok3) {
          if (state2.pos >= end) {
            break;
          }
          continue;
        }
        state2.pending += state2.src[state2.pos++];
      }
      if (state2.pending) {
        state2.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md, env, outTokens) {
      var i2, rules, len;
      var state2 = new this.State(str, md, env, outTokens);
      this.tokenize(state2);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i2 = 0; i2 < len; i2++) {
        rules[i2](state2);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module.exports = ParserInline;
  }
});
var require_re = __commonJS2({
  "node_modules/linkify-it/lib/re.js"(exports, module) {
    "use strict";
    module.exports = function(opts) {
      var re = {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><｜]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|;(?!" + re.src_ZCc + ").|\\!+(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});
var require_linkify_it = __commonJS2({
  "node_modules/linkify-it/index.js"(exports, module) {
    "use strict";
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key3) {
          obj[key3] = source[key3];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject2(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction2(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions2 = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions2.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text22[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text22[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text22, pos) {
        var tail = text22.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match2, self2) {
        self2.normalize(match2);
      };
    }
    function compile2(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name2, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name2) {
        var val = self2.__schemas__[name2];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name2] = compiled;
        if (isObject2(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction2(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name2, val);
          }
          if (isFunction2(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name2, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name2);
          return;
        }
        schemaError(name2, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name2) {
        return name2.length > 0 && self2.__compiled__[name2];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self2);
    }
    function Match(self2, shift5) {
      var start2 = self2.__index__, end = self2.__last_index__, text22 = self2.__text_cache__.slice(start2, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start2 + shift5;
      this.lastIndex = end + shift5;
      this.raw = text22;
      this.text = text22;
      this.url = text22;
    }
    function createMatch(self2, shift5) {
      var match2 = new Match(self2, shift5);
      self2.__compiled__[match2.schema].normalize(match2, self2);
      return match2;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions2, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile2(this);
    }
    LinkifyIt.prototype.add = function add2(schema, definition3) {
      this.__schemas__[schema] = definition3;
      compile2(this);
      return this;
    };
    LinkifyIt.prototype.set = function set2(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text22) {
      this.__text_cache__ = text22;
      this.__index__ = -1;
      if (!text22.length) {
        return false;
      }
      var m, ml, me, len, shift5, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text22)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text22)) !== null) {
          len = this.testSchemaAt(text22, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text22.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text22.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift5 = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift5 < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift5;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text22.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text22.match(this.re.email_fuzzy)) !== null) {
            shift5 = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift5 < this.__index__ || shift5 === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift5;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text22) {
      return this.re.pretest.test(text22);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text22, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text22, pos, this);
    };
    LinkifyIt.prototype.match = function match2(text22) {
      var shift5 = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text22) {
        result.push(createMatch(this, shift5));
        shift5 = this.__last_index__;
      }
      var tail = shift5 ? text22.slice(shift5) : text22;
      while (this.test(tail)) {
        result.push(createMatch(this, shift5));
        tail = tail.slice(this.__last_index__);
        shift5 += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.tlds = function tlds(list22, keepOld) {
      list22 = Array.isArray(list22) ? list22 : [list22];
      if (!keepOld) {
        this.__tlds__ = list22.slice();
        this.__tlds_replaced__ = true;
        compile2(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list22).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile2(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize2(match2) {
      if (!match2.schema) {
        match2.url = "http://" + match2.url;
      }
      if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
        match2.url = "mailto:" + match2.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module.exports = LinkifyIt;
  }
});
var require_punycode = __commonJS2({
  "node_modules/punycode/punycode.js"(exports, module) {
    "use strict";
    var maxInt = 2147483647;
    var base2 = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base2 - tMin;
    var floor2 = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error22(type) {
      throw new RangeError(errors[type]);
    }
    function map6(array, fn) {
      const result = [];
      let length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string3, fn) {
      const parts = string3.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string3 = parts[1];
      }
      string3 = string3.replace(regexSeparators, ".");
      const labels = string3.split(".");
      const encoded = map6(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string3) {
      const output = [];
      let counter2 = 0;
      const length = string3.length;
      while (counter2 < length) {
        const value = string3.charCodeAt(counter2++);
        if (value >= 55296 && value <= 56319 && counter2 < length) {
          const extra = string3.charCodeAt(counter2++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter2--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = (array) => String.fromCodePoint(...array);
    var basicToDigit = function(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base2;
    };
    var digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor2(delta / damp) : delta >> 1;
      delta += floor2(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base2) {
        delta = floor2(delta / baseMinusTMin);
      }
      return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode2 = function(input) {
      const output = [];
      const inputLength = input.length;
      let i2 = 0;
      let n2 = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error22("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index4 = basic > 0 ? basic + 1 : 0; index4 < inputLength; ) {
        let oldi = i2;
        for (let w = 1, k = base2; ; k += base2) {
          if (index4 >= inputLength) {
            error22("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index4++));
          if (digit >= base2 || digit > floor2((maxInt - i2) / w)) {
            error22("overflow");
          }
          i2 += digit * w;
          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          const baseMinusT = base2 - t2;
          if (w > floor2(maxInt / baseMinusT)) {
            error22("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor2(i2 / out) > maxInt - n2) {
          error22("overflow");
        }
        n2 += floor2(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n2);
      }
      return String.fromCodePoint(...output);
    };
    var encode2 = function(input) {
      const output = [];
      input = ucs2decode(input);
      let inputLength = input.length;
      let n2 = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      let basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n2 && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n2 > floor2((maxInt - delta) / handledCPCountPlusOne)) {
          error22("overflow");
        }
        delta += (m - n2) * handledCPCountPlusOne;
        n2 = m;
        for (const currentValue of input) {
          if (currentValue < n2 && ++delta > maxInt) {
            error22("overflow");
          }
          if (currentValue == n2) {
            let q = delta;
            for (let k = base2; ; k += base2) {
              const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t2) {
                break;
              }
              const qMinusT = q - t2;
              const baseMinusT = base2 - t2;
              output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
              q = floor2(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output.join("");
    };
    var toUnicode = function(input) {
      return mapDomain(input, function(string3) {
        return regexPunycode.test(string3) ? decode2(string3.slice(4).toLowerCase()) : string3;
      });
    };
    var toASCII = function(input) {
      return mapDomain(input, function(string3) {
        return regexNonASCII.test(string3) ? "xn--" + encode2(string3) : string3;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode2,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    module.exports = punycode;
  }
});
var require_default = __commonJS2({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});
var require_zero = __commonJS2({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "text_collapse"
          ]
        }
      }
    };
  }
});
var require_commonmark = __commonJS2({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "text_collapse"
          ]
        }
      }
    };
  }
});
var require_lib2 = __commonJS2({
  "node_modules/markdown-it/lib/index.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = require_punycode();
    var config3 = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt3(presetName, options) {
      if (!(this instanceof MarkdownIt3)) {
        return new MarkdownIt3(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt3.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt3.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config3[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name2) {
          if (presets.components[name2].rules) {
            self2[name2].ruler.enableOnly(presets.components[name2].rules);
          }
          if (presets.components[name2].rules2) {
            self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt3.prototype.enable = function(list22, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list22, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list22, true));
      var missed = list22.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.disable = function(list22, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list22)) {
        list22 = [list22];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list22, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list22, true));
      var missed = list22.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.use = function(plugin4) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin4.apply(plugin4, args);
      return this;
    };
    MarkdownIt3.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state2 = new this.core.State(src, this, env);
      this.core.process(state2);
      return state2.tokens;
    };
    MarkdownIt3.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt3.prototype.parseInline = function(src, env) {
      var state2 = new this.core.State(src, this, env);
      state2.inlineMode = true;
      this.core.process(state2);
      return state2.tokens;
    };
    MarkdownIt3.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module.exports = MarkdownIt3;
  }
});
var require_markdown_it = __commonJS2({
  "node_modules/markdown-it/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib2();
  }
});
var base_exports = {};
__export2(base_exports, {
  getAstValues: () => getAstValues,
  isAst: () => isAst,
  isFunction: () => isFunction,
  isVariable: () => isVariable,
  resolve: () => resolve
});
function isAst(value) {
  return !!(value == null ? void 0 : value.$$mdtype);
}
function isFunction(value) {
  return !!((value == null ? void 0 : value.$$mdtype) === "Function");
}
function isVariable(value) {
  return !!((value == null ? void 0 : value.$$mdtype) === "Variable");
}
function* getAstValues(value) {
  if (value == null || typeof value !== "object")
    return;
  if (Array.isArray(value))
    for (const v of value)
      yield* getAstValues(v);
  if (isAst(value))
    yield value;
  if (Object.getPrototypeOf(value) !== Object.prototype)
    return;
  for (const v of Object.values(value))
    yield* getAstValues(v);
}
function resolve(value, config3 = {}) {
  if (value == null || typeof value !== "object")
    return value;
  if (Array.isArray(value))
    return value.map((item2) => resolve(item2, config3));
  if (isAst(value) && (value == null ? void 0 : value.resolve) instanceof Function)
    return value.resolve(config3);
  if (Object.getPrototypeOf(value) !== Object.prototype)
    return value;
  const output = {};
  for (const [k, v] of Object.entries(value))
    output[k] = resolve(v, config3);
  return output;
}
var Tag = class {
  constructor(name2 = "div", attributes = {}, children = []) {
    this.$$mdtype = "Tag";
    this.name = name2;
    this.attributes = attributes;
    this.children = children;
  }
};
Tag.isTag = (tag) => {
  return !!((tag == null ? void 0 : tag.$$mdtype) === "Tag");
};
var Class = class {
  validate(value, _config, key3) {
    if (typeof value === "string" || typeof value === "object")
      return [];
    return [
      {
        id: "attribute-type-invalid",
        level: "error",
        message: `Attribute '${key3}' must be type 'string | object'`
      }
    ];
  }
  transform(value) {
    if (!value || typeof value === "string")
      return value;
    const classes2 = [];
    for (const [k, v] of Object.entries(value ?? {}))
      if (v)
        classes2.push(k);
    return classes2.join(" ");
  }
};
var Id = class {
  validate(value) {
    if (typeof value === "string" && value.match(/^[a-zA-Z]/))
      return [];
    return [
      {
        id: "attribute-value-invalid",
        level: "error",
        message: "The 'id' attribute must start with a letter"
      }
    ];
  }
};
var import_tag = __toModule(require_tag());
var Variable = class {
  constructor(path3 = []) {
    this.$$mdtype = "Variable";
    this.path = path3;
  }
  resolve({ variables } = {}) {
    return variables instanceof Function ? variables(this.path) : this.path.reduce((obj = {}, key3) => obj[key3], variables);
  }
};
var Function2 = class {
  constructor(name2, parameters) {
    this.$$mdtype = "Function";
    this.name = name2;
    this.parameters = parameters;
  }
  resolve(config3 = {}) {
    var _a, _b;
    const fn = (_a = config3 == null ? void 0 : config3.functions) == null ? void 0 : _a[this.name];
    if (!fn)
      return null;
    const parameters = resolve(this.parameters, config3);
    return (_b = fn.transform) == null ? void 0 : _b.call(fn, parameters, config3);
  }
};
var STATES;
(function(STATES2) {
  STATES2[STATES2["normal"] = 0] = "normal";
  STATES2[STATES2["string"] = 1] = "string";
  STATES2[STATES2["escape"] = 2] = "escape";
})(STATES || (STATES = {}));
var OPEN = "{%";
var CLOSE = "%}";
var IDENTIFIER_REGEX = /^[a-zA-Z0-9_-]+$/;
function isIdentifier(s2) {
  return typeof s2 === "string" && IDENTIFIER_REGEX.test(s2);
}
function isPromise(a) {
  return a && typeof a === "object" && typeof a.then === "function";
}
function findTagEnd(content3, start2 = 0) {
  let state2 = 0;
  for (let pos = start2; pos < content3.length; pos++) {
    const char = content3[pos];
    switch (state2) {
      case 1:
        switch (char) {
          case '"':
            state2 = 0;
            break;
          case "\\":
            state2 = 2;
            break;
        }
        break;
      case 2:
        state2 = 1;
        break;
      case 0:
        if (char === '"')
          state2 = 1;
        else if (content3.startsWith(CLOSE, pos))
          return pos;
    }
  }
  return null;
}
function parseTag(content3, line, contentStart) {
  try {
    return (0, import_tag.parse)(content3, { Variable, Function: Function2 });
  } catch (error22) {
    if (!(error22 instanceof import_tag.SyntaxError))
      throw error22;
    const {
      message,
      location: { start: start2, end }
    } = error22;
    const location = {
      start: { line, character: start2.offset + contentStart },
      end: { line: line + 1, character: end.offset + contentStart }
    };
    return { type: "error", meta: { error: { message, location } } };
  }
}
function parseTags(content3, firstLine = 0) {
  let line = firstLine + 1;
  const output = [];
  let start2 = 0;
  for (let pos = 0; pos < content3.length; pos++) {
    if (content3[pos] === "\n") {
      line++;
      continue;
    }
    if (!content3.startsWith(OPEN, pos))
      continue;
    const end = findTagEnd(content3, pos);
    if (end == null) {
      pos = pos + OPEN.length;
      continue;
    }
    const text22 = content3.slice(pos, end + CLOSE.length);
    const inner = content3.slice(pos + OPEN.length, end);
    const lineStart = content3.lastIndexOf("\n", pos);
    const lineEnd = content3.indexOf("\n", end);
    const lineContent = content3.slice(lineStart, lineEnd);
    const tag = parseTag(inner.trim(), line, pos - lineStart);
    const precedingTextEnd = lineContent.trim() === text22 ? lineStart : pos;
    const precedingText = content3.slice(start2, precedingTextEnd);
    output.push({
      type: "text",
      start: start2,
      end: pos - 1,
      content: precedingText
    });
    output.push({
      map: [line, line + 1],
      position: {
        start: pos - lineStart,
        end: pos - lineStart + text22.length
      },
      start: pos,
      end: pos + text22.length - 1,
      info: text22,
      ...tag
    });
    start2 = end + CLOSE.length;
    pos = start2 - 1;
  }
  output.push({
    type: "text",
    start: start2,
    end: content3.length - 1,
    content: content3.slice(start2)
  });
  return output;
}
var globalAttributes = {
  class: { type: Class, render: true },
  id: { type: Id, render: true }
};
var transformer_default = {
  findSchema(node22, { nodes = {}, tags = {} } = {}) {
    return node22.tag ? tags[node22.tag] : nodes[node22.type];
  },
  attributes(node22, config3 = {}) {
    const schema = this.findSchema(node22, config3) ?? {};
    const output = {};
    const attrs = { ...globalAttributes, ...schema.attributes };
    for (const [key3, attr] of Object.entries(attrs)) {
      if (attr.render == false)
        continue;
      const name2 = typeof attr.render === "string" ? attr.render : key3;
      let value = node22.attributes[key3];
      if (typeof attr.type === "function") {
        const instance = new attr.type();
        if (instance.transform) {
          value = instance.transform(value, config3);
        }
      }
      value = value === void 0 ? attr.default : value;
      if (value === void 0)
        continue;
      output[name2] = value;
    }
    if (schema.slots) {
      for (const [key3, slot2] of Object.entries(schema.slots)) {
        if (slot2.render === false)
          continue;
        const name2 = typeof slot2.render === "string" ? slot2.render : key3;
        if (node22.slots[key3])
          output[name2] = this.node(node22.slots[key3], config3);
      }
    }
    return output;
  },
  children(node22, config3 = {}) {
    const children = node22.children.flatMap((child) => this.node(child, config3));
    if (children.some(isPromise)) {
      return Promise.all(children);
    }
    return children;
  },
  node(node22, config3 = {}) {
    const schema = this.findSchema(node22, config3) ?? {};
    if (schema && schema.transform instanceof Function)
      return schema.transform(node22, config3);
    const children = this.children(node22, config3);
    if (!schema || !schema.render)
      return children;
    const attributes = this.attributes(node22, config3);
    if (isPromise(attributes) || isPromise(children)) {
      return Promise.all([attributes, children]).then((values3) => new Tag(schema.render, ...values3));
    }
    return new Tag(schema.render, attributes, children);
  }
};
var Node3 = class {
  constructor(type = "node", attributes = {}, children = [], tag) {
    this.$$mdtype = "Node";
    this.errors = [];
    this.lines = [];
    this.inline = false;
    this.attributes = attributes;
    this.children = children;
    this.type = type;
    this.tag = tag;
    this.annotations = [];
    this.slots = {};
  }
  *walk() {
    for (const child of [...Object.values(this.slots), ...this.children]) {
      yield child;
      yield* child.walk();
    }
  }
  push(node22) {
    this.children.push(node22);
  }
  resolve(config3 = {}) {
    return Object.assign(new Node3(), this, {
      children: this.children.map((child) => child.resolve(config3)),
      attributes: resolve(this.attributes, config3),
      slots: Object.fromEntries(Object.entries(this.slots).map(([name2, slot2]) => [
        name2,
        slot2.resolve(config3)
      ]))
    });
  }
  findSchema(config3 = {}) {
    return transformer_default.findSchema(this, config3);
  }
  transformAttributes(config3 = {}) {
    return transformer_default.attributes(this, config3);
  }
  transformChildren(config3) {
    return transformer_default.children(this, config3);
  }
  transform(config3) {
    return transformer_default.node(this, config3);
  }
};
var AstTypes = {
  Function: Function2,
  Node: Node3,
  Variable
};
function reviver(_, value) {
  if (!value)
    return value;
  const klass = AstTypes[value.$$mdtype];
  return klass ? Object.assign(new klass(), value) : value;
}
function fromJSON(text22) {
  return JSON.parse(text22, reviver);
}
var ast_default = {
  ...AstTypes,
  ...base_exports,
  fromJSON
};
var SPACE = " ";
var SEP = ", ";
var NL = "\n";
var OL = ".";
var UL = "-";
var MAX_TAG_OPENING_WIDTH = 80;
var WRAPPING_TYPES = ["strong", "em", "s"];
var max2 = (a, b) => Math.max(a, b);
var increment = (o3, n2 = 2) => ({
  ...o3,
  indent: (o3.indent || 0) + n2
});
function* formatChildren(a, options) {
  for (const child of a.children) {
    yield* formatValue(child, options);
  }
}
function* formatInline(g) {
  yield [...g].join("").trim();
}
function* formatTableRow(items) {
  yield `| ${items.join(" | ")} |`;
}
function formatScalar(v) {
  if (v === void 0) {
    return void 0;
  }
  if (ast_default.isAst(v)) {
    return format(v);
  }
  if (v === null) {
    return "null";
  }
  if (Array.isArray(v)) {
    return "[" + v.map(formatScalar).join(SEP) + "]";
  }
  if (typeof v === "object") {
    return "{" + Object.entries(v).map(([key3, value]) => `${isIdentifier(key3) ? key3 : `"${key3}"`}: ${formatScalar(value)}`).join(SEP) + "}";
  }
  return JSON.stringify(v);
}
function formatAnnotationValue(a) {
  const formattedValue = formatScalar(a.value);
  if (formattedValue === void 0)
    return void 0;
  if (a.name === "primary")
    return formattedValue;
  if (a.name === "id" && typeof a.value === "string" && isIdentifier(a.value))
    return "#" + a.value;
  if (a.type === "class" && isIdentifier(a.name))
    return "." + a.name;
  return `${a.name}=${formattedValue}`;
}
function* formatAttributes(n2) {
  for (const [key3, value] of Object.entries(n2.attributes)) {
    if (key3 === "class" && typeof value === "object" && !ast_default.isAst(value))
      for (const name2 of Object.keys(value)) {
        yield formatAnnotationValue({ type: "class", name: name2, value });
      }
    else
      yield formatAnnotationValue({ type: "attribute", name: key3, value });
  }
}
function* formatAnnotations(n2) {
  if (n2.annotations.length) {
    yield OPEN + SPACE;
    yield n2.annotations.map(formatAnnotationValue).join(SPACE);
    yield SPACE + CLOSE;
  }
}
function* formatVariable(v) {
  yield "$";
  yield v.path.map((p, i2) => {
    if (i2 === 0)
      return p;
    if (isIdentifier(p))
      return "." + p;
    if (typeof p === "number")
      return `[${p}]`;
    return `["${p}"]`;
  }).join("");
}
function* formatFunction(f) {
  yield f.name;
  yield "(";
  yield Object.values(f.parameters).map(formatScalar).join(SEP);
  yield ")";
}
function* trimStart(g) {
  let n2;
  do {
    const { value, done } = g.next();
    if (done)
      return;
    n2 = value.trimStart();
  } while (!n2.length);
  yield n2;
  yield* g;
}
function* escapeMarkdownCharacters(s2, characters2) {
  yield s2.replace(characters2, "\\$&").replace(new RegExp(" ", "g"), "&nbsp;");
}
function* formatNode(n2, o3 = {}) {
  const no = { ...o3, parent: n2 };
  const indent3 = SPACE.repeat(no.indent || 0);
  switch (n2.type) {
    case "document": {
      if (n2.attributes.frontmatter && n2.attributes.frontmatter.length) {
        yield "---" + NL + n2.attributes.frontmatter + NL + "---" + NL + NL;
      }
      yield* trimStart(formatChildren(n2, no));
      break;
    }
    case "heading": {
      yield NL;
      yield indent3;
      yield "#".repeat(n2.attributes.level || 1);
      yield SPACE;
      yield* trimStart(formatChildren(n2, no));
      yield* formatAnnotations(n2);
      yield NL;
      break;
    }
    case "paragraph": {
      yield NL;
      yield* formatChildren(n2, no);
      yield* formatAnnotations(n2);
      yield NL;
      break;
    }
    case "inline": {
      yield indent3;
      yield* formatChildren(n2, no);
      break;
    }
    case "image": {
      yield "!";
      yield "[";
      yield* formatValue(n2.attributes.alt, no);
      yield "]";
      yield "(";
      yield* typeof n2.attributes.src === "string" ? escapeMarkdownCharacters(n2.attributes.src, /[()]/) : formatValue(n2.attributes.src, no);
      if (n2.attributes.title) {
        yield SPACE + `"${n2.attributes.title}"`;
      }
      yield ")";
      break;
    }
    case "link": {
      yield "[";
      yield* formatChildren(n2, no);
      yield "]";
      yield "(";
      yield* typeof n2.attributes.href === "string" ? escapeMarkdownCharacters(n2.attributes.href, /[()]/g) : formatValue(n2.attributes.href, no);
      if (n2.attributes.title) {
        yield SPACE + `"${n2.attributes.title}"`;
      }
      yield ")";
      break;
    }
    case "text": {
      const { content: content3 } = n2.attributes;
      if (ast_default.isAst(content3)) {
        yield OPEN + SPACE;
        yield* formatValue(content3, no);
        yield SPACE + CLOSE;
      } else {
        if (o3.parent && WRAPPING_TYPES.includes(o3.parent.type)) {
          yield* escapeMarkdownCharacters(content3, /[*_~]/g);
        } else {
          yield* escapeMarkdownCharacters(content3, /^[*>#]/);
        }
      }
      break;
    }
    case "blockquote": {
      const prefix = ">" + SPACE;
      yield n2.children.map((child) => format(child, no).trimStart()).map((d) => NL + indent3 + prefix + d).join(indent3 + prefix);
      break;
    }
    case "hr": {
      yield NL;
      yield indent3;
      yield "---";
      yield NL;
      break;
    }
    case "fence": {
      yield NL;
      yield indent3;
      const innerFence = n2.attributes.content.match(/`{3,}/g) || [];
      const innerFenceLength = innerFence.map((s2) => s2.length).reduce(max2, 0);
      const boundary = "`".repeat(innerFenceLength ? innerFenceLength + 1 : 3);
      yield boundary;
      if (n2.attributes.language)
        yield n2.attributes.language;
      if (n2.annotations.length)
        yield SPACE;
      yield* formatAnnotations(n2);
      yield NL;
      yield indent3;
      yield n2.attributes.content.split(NL).join(NL + indent3);
      yield boundary;
      yield NL;
      break;
    }
    case "tag": {
      if (!n2.inline) {
        yield NL;
        yield indent3;
      }
      const open = OPEN + SPACE;
      const attributes = [...formatAttributes(n2)].filter((v) => v !== void 0);
      const tag = [open + n2.tag, ...attributes];
      const inlineTag = tag.join(SPACE);
      const isLongTagOpening = inlineTag.length + open.length * 2 > (o3.maxTagOpeningWidth || MAX_TAG_OPENING_WIDTH);
      yield (!n2.inline && isLongTagOpening ? tag.join(NL + SPACE.repeat(open.length) + indent3) : inlineTag) + SPACE + (n2.children.length ? "" : "/") + CLOSE;
      if (n2.children.length) {
        yield* formatChildren(n2, no.allowIndentation ? increment(no) : no);
        if (!n2.inline) {
          yield indent3;
        }
        yield OPEN + SPACE + "/" + n2.tag + SPACE + CLOSE;
      }
      if (!n2.inline) {
        yield NL;
      }
      break;
    }
    case "list": {
      const isLoose = n2.children.some((n22) => n22.children.some((c) => c.type === "paragraph"));
      for (let i2 = 0; i2 < n2.children.length; i2++) {
        const prefix = n2.attributes.ordered ? `${i2 === 0 ? n2.attributes.start ?? "1" : "1"}${n2.attributes.marker ?? OL}` : n2.attributes.marker ?? UL;
        let d = format(n2.children[i2], increment(no, prefix.length + 1));
        if (!isLoose || i2 === n2.children.length - 1) {
          d = d.trim();
        }
        yield NL + indent3 + prefix + " " + d;
      }
      yield NL;
      break;
    }
    case "item": {
      for (let i2 = 0; i2 < n2.children.length; i2++) {
        yield* formatValue(n2.children[i2], no);
        if (i2 === 0)
          yield* formatAnnotations(n2);
      }
      break;
    }
    case "strong": {
      yield n2.attributes.marker ?? "**";
      yield* formatInline(formatChildren(n2, no));
      yield n2.attributes.marker ?? "**";
      break;
    }
    case "em": {
      yield n2.attributes.marker ?? "*";
      yield* formatInline(formatChildren(n2, no));
      yield n2.attributes.marker ?? "*";
      break;
    }
    case "code": {
      yield "`";
      yield* formatInline(formatValue(n2.attributes.content, no));
      yield "`";
      break;
    }
    case "s": {
      yield "~~";
      yield* formatInline(formatChildren(n2, no));
      yield "~~";
      break;
    }
    case "hardbreak": {
      yield "\\" + NL;
      yield indent3;
      break;
    }
    case "softbreak": {
      yield NL;
      yield indent3;
      break;
    }
    case "table": {
      const table3 = [...formatChildren(n2, increment(no))];
      if (o3.parent && o3.parent.type === "tag" && o3.parent.tag === "table") {
        for (let i2 = 0; i2 < table3.length; i2++) {
          const row = table3[i2];
          if (typeof row === "string") {
            if (row.trim().length) {
              yield NL;
              yield row;
            }
          } else {
            if (i2 !== 0) {
              yield NL;
              yield indent3 + "---";
            }
            for (const d of row) {
              yield NL + indent3 + UL + " " + d;
            }
          }
        }
        yield NL;
      } else {
        const widths = [];
        for (const row of table3) {
          for (let i2 = 0; i2 < row.length; i2++) {
            widths[i2] = widths[i2] ? Math.max(widths[i2], row[i2].length) : row[i2].length;
          }
        }
        const [head, ...rows] = table3;
        yield NL;
        yield* formatTableRow(head.map((cell2, i2) => cell2 + SPACE.repeat(widths[i2] - cell2.length)));
        yield NL;
        yield* formatTableRow(head.map((cell2, i2) => "-".repeat(widths[i2])));
        yield NL;
        for (const row of rows) {
          yield* formatTableRow(row.map((cell2, i2) => cell2 + SPACE.repeat(widths[i2] - cell2.length)));
          yield NL;
        }
      }
      break;
    }
    case "thead": {
      const [head] = [...formatChildren(n2, no)];
      yield head || [];
      break;
    }
    case "tr": {
      yield [...formatChildren(n2, no)];
      break;
    }
    case "td":
    case "th": {
      yield [...formatChildren(n2, no), ...formatAnnotations(n2)].join("").trim();
      break;
    }
    case "tbody": {
      yield* formatChildren(n2, no);
      break;
    }
    case "comment": {
      yield "<!-- " + n2.attributes.content + " -->\n";
      break;
    }
    case "error":
    case "node":
      break;
  }
}
function* formatValue(v, o3 = {}) {
  switch (typeof v) {
    case "undefined":
      break;
    case "boolean":
    case "number":
    case "string": {
      yield v.toString();
      break;
    }
    case "object": {
      if (v === null)
        break;
      if (Array.isArray(v)) {
        for (const n2 of v)
          yield* formatValue(n2, o3);
        break;
      }
      switch (v.$$mdtype) {
        case "Function": {
          yield* formatFunction(v);
          break;
        }
        case "Node":
          yield* formatNode(v, o3);
          break;
        case "Variable": {
          yield* formatVariable(v);
          break;
        }
        default:
          throw new Error(`Unimplemented: "${v.$$mdtype}"`);
      }
      break;
    }
  }
}
function format(v, options) {
  let doc4 = "";
  for (const s2 of formatValue(v, options))
    doc4 += s2;
  return doc4.trimStart();
}
function truthy(value) {
  return value !== false && value !== void 0 && value !== null;
}
function renderConditions(node22) {
  const conditions = [
    { condition: node22.attributes.primary, children: [] }
  ];
  for (const child of node22.children) {
    if (child.type === "tag" && child.tag === "else")
      conditions.push({
        condition: "primary" in child.attributes ? child.attributes.primary : true,
        children: []
      });
    else
      conditions[conditions.length - 1].children.push(child);
  }
  return conditions;
}
var tagIf = {
  attributes: {
    primary: { type: Object, render: false }
  },
  transform(node22, config3) {
    const conditions = renderConditions(node22);
    for (const { condition, children } of conditions)
      if (truthy(condition)) {
        const nodes = children.flatMap((child) => child.transform(config3));
        if (nodes.some(isPromise)) {
          return Promise.all(nodes).then((nodes2) => nodes2.flat());
        }
        return nodes;
      }
    return [];
  }
};
var tagElse = {
  selfClosing: true,
  attributes: {
    primary: { type: Object, render: false }
  }
};
var and = {
  transform(parameters) {
    return Object.values(parameters).every((x) => truthy(x));
  }
};
var or = {
  transform(parameters) {
    return Object.values(parameters).find((x) => truthy(x)) !== void 0;
  }
};
var not = {
  parameters: {
    0: { required: true }
  },
  transform(parameters) {
    return !truthy(parameters[0]);
  }
};
var equals = {
  transform(parameters) {
    const values3 = Object.values(parameters);
    return values3.every((v) => v === values3[0]);
  }
};
var debug = {
  transform(parameters) {
    return JSON.stringify(parameters[0], null, 2);
  }
};
var defaultFn = {
  transform(parameters) {
    return parameters[0] === void 0 ? parameters[1] : parameters[0];
  }
};
var functions_default = { and, or, not, equals, default: defaultFn, debug };
function convertToRow(node22, cellType = "td") {
  node22.type = "tr";
  node22.attributes = {};
  for (const cell2 of node22.children)
    cell2.type = cellType;
  return node22;
}
function transform(document22) {
  for (const node22 of document22.walk()) {
    if (node22.type !== "tag" || node22.tag !== "table")
      continue;
    const [first, ...rest] = node22.children;
    if (!first || first.type === "table")
      continue;
    const table3 = new ast_default.Node("table", node22.attributes, [
      new ast_default.Node("thead"),
      new ast_default.Node("tbody")
    ]);
    const [thead2, tbody2] = table3.children;
    if (first.type === "list")
      thead2.push(convertToRow(first, "th"));
    for (const row of rest) {
      if (row.type === "list")
        convertToRow(row);
      else if (row.type === "tag" && row.tag === "if") {
        const children = [];
        for (const child of row.children) {
          if (child.type === "hr")
            continue;
          if (child.type === "list")
            convertToRow(child);
          children.push(child);
        }
        row.children = children;
      } else
        continue;
      tbody2.push(row);
    }
    node22.children = [table3];
  }
}
var transforms_default = [transform];
var mappings = {
  ordered_list: "list",
  bullet_list: "list",
  code_inline: "code",
  list_item: "item",
  variable: "text"
};
function annotate(node22, attributes) {
  for (const attribute of attributes) {
    node22.annotations.push(attribute);
    const { name: name2, value, type } = attribute;
    if (type === "attribute") {
      if (node22.attributes[name2] !== void 0)
        node22.errors.push({
          id: "duplicate-attribute",
          level: "warning",
          message: `Attribute '${name2}' already set`
        });
      node22.attributes[name2] = value;
    } else if (type === "class")
      if (node22.attributes.class)
        node22.attributes.class[name2] = value;
      else
        node22.attributes.class = { [name2]: value };
  }
}
function handleAttrs(token, type) {
  switch (type) {
    case "heading":
      return { level: Number(token.tag.replace("h", "")) };
    case "list": {
      const attrs = token.attrs ? Object.fromEntries(token.attrs) : void 0;
      const ordered = token.type.startsWith("ordered");
      return ordered && (attrs == null ? void 0 : attrs.start) ? { ordered: true, start: attrs.start, marker: token.markup } : { ordered, marker: token.markup };
    }
    case "link": {
      const attrs = Object.fromEntries(token.attrs);
      return attrs.title ? { href: attrs.href, title: attrs.title } : { href: attrs.href };
    }
    case "image": {
      const attrs = Object.fromEntries(token.attrs);
      return attrs.title ? { alt: token.content, src: attrs.src, title: attrs.title } : { alt: token.content, src: attrs.src };
    }
    case "em":
    case "strong":
      return { marker: token.markup };
    case "text":
    case "code":
    case "comment":
      return { content: (token.meta || {}).variable || token.content };
    case "fence": {
      const [language] = token.info.split(" ", 1);
      return language === "" || language === OPEN ? { content: token.content } : { content: token.content, language };
    }
    case "td":
    case "th": {
      if (token.attrs) {
        const attrs = Object.fromEntries(token.attrs);
        let align;
        if (attrs.style) {
          if (attrs.style.includes("left")) {
            align = "left";
          } else if (attrs.style.includes("center")) {
            align = "center";
          } else if (attrs.style.includes("right")) {
            align = "right";
          }
        }
        if (align) {
          return { align };
        }
      }
      return {};
    }
    default:
      return {};
  }
}
function handleToken(token, nodes, file, handleSlots, addLocation, inlineParent) {
  if (token.type === "frontmatter") {
    nodes[0].attributes.frontmatter = token.content;
    return;
  }
  if (token.hidden || token.type === "text" && token.content === "")
    return;
  const errors = token.errors || [];
  const parent = nodes[nodes.length - 1];
  const { tag, attributes, error: error22 } = token.meta || {};
  if (token.type === "annotation") {
    if (inlineParent)
      return annotate(inlineParent, attributes);
    return parent.errors.push({
      id: "no-inline-annotations",
      level: "error",
      message: `Can't apply inline annotations to '${parent.type}'`
    });
  }
  let typeName = token.type.replace(/_(open|close)$/, "");
  if (mappings[typeName])
    typeName = mappings[typeName];
  if (typeName === "error") {
    const { message, location } = error22;
    errors.push({ id: "parse-error", level: "critical", message, location });
  }
  if (token.nesting < 0) {
    if (parent.type === typeName && parent.tag === tag) {
      if (parent.lines && token.map)
        parent.lines.push(...token.map);
      return nodes.pop();
    }
    errors.push({
      id: "missing-opening",
      level: "critical",
      message: `Node '${typeName}' is missing opening`
    });
  }
  const attrs = handleAttrs(token, typeName);
  const node22 = new Node3(typeName, attrs, void 0, tag || void 0);
  const { position: position2 = {} } = token;
  node22.errors = errors;
  if (addLocation !== false) {
    node22.lines = token.map || parent.lines || [];
    node22.location = {
      file,
      start: {
        line: node22.lines[0],
        character: position2.start
      },
      end: {
        line: node22.lines[1],
        character: position2.end
      }
    };
  }
  if (inlineParent)
    node22.inline = true;
  if (attributes && ["tag", "fence", "image"].includes(typeName))
    annotate(node22, attributes);
  if (handleSlots && tag === "slot" && typeof node22.attributes.primary === "string")
    parent.slots[node22.attributes.primary] = node22;
  else
    parent.push(node22);
  if (token.nesting > 0)
    nodes.push(node22);
  if (!Array.isArray(token.children))
    return;
  if (node22.type === "inline")
    inlineParent = parent;
  nodes.push(node22);
  const isLeafNode = typeName === "image";
  if (!isLeafNode) {
    for (const child of token.children)
      handleToken(child, nodes, file, handleSlots, addLocation, inlineParent);
  }
  nodes.pop();
}
function parser(tokens, args) {
  const doc4 = new Node3("document");
  const nodes = [doc4];
  if (typeof args === "string")
    args = { file: args };
  for (const token of tokens)
    handleToken(token, nodes, args == null ? void 0 : args.file, args == null ? void 0 : args.slots, args == null ? void 0 : args.location);
  if (nodes.length > 1)
    for (const node22 of nodes.slice(1))
      node22.errors.push({
        id: "missing-closing",
        level: "critical",
        message: `Node '${node22.tag || node22.type}' is missing closing`
      });
  for (const transform3 of transforms_default)
    transform3(doc4);
  return doc4;
}
var schema_exports = {};
__export2(schema_exports, {
  blockquote: () => blockquote,
  code: () => code,
  comment: () => comment,
  document: () => document2,
  em: () => em,
  error: () => error,
  fence: () => fence,
  hardbreak: () => hardbreak,
  heading: () => heading,
  hr: () => hr,
  image: () => image,
  inline: () => inline,
  item: () => item,
  link: () => link,
  list: () => list,
  node: () => node,
  paragraph: () => paragraph,
  s: () => s,
  softbreak: () => softbreak,
  strong: () => strong,
  table: () => table,
  tbody: () => tbody,
  td: () => td,
  text: () => text2,
  th: () => th,
  thead: () => thead,
  tr: () => tr
});
var document2 = {
  render: "article",
  children: [
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "comment",
    "list",
    "hr"
  ],
  attributes: {
    frontmatter: { render: false }
  }
};
var heading = {
  children: ["inline"],
  attributes: {
    level: { type: Number, render: false, required: true }
  },
  transform(node22, config3) {
    return new Tag(`h${node22.attributes["level"]}`, node22.transformAttributes(config3), node22.transformChildren(config3));
  }
};
var paragraph = {
  render: "p",
  children: ["inline"]
};
var image = {
  render: "img",
  attributes: {
    src: { type: String, required: true },
    alt: { type: String },
    title: { type: String }
  }
};
var fence = {
  render: "pre",
  attributes: {
    content: { type: String, render: false, required: true },
    language: { type: String, render: "data-language" },
    process: { type: Boolean, render: false, default: true }
  },
  transform(node22, config3) {
    const attributes = node22.transformAttributes(config3);
    const children = node22.children.length ? node22.transformChildren(config3) : [node22.attributes.content];
    return new Tag("pre", attributes, children);
  }
};
var blockquote = {
  render: "blockquote",
  children: [
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ]
};
var item = {
  render: "li",
  children: [
    "inline",
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ]
};
var list = {
  children: ["item"],
  attributes: {
    ordered: { type: Boolean, render: false, required: true },
    start: { type: Number },
    marker: { type: String, render: false }
  },
  transform(node22, config3) {
    return new Tag(node22.attributes.ordered ? "ol" : "ul", node22.transformAttributes(config3), node22.transformChildren(config3));
  }
};
var hr = {
  render: "hr"
};
var table = {
  render: "table"
};
var td = {
  render: "td",
  children: [
    "inline",
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ],
  attributes: {
    align: { type: String },
    colspan: { type: Number, render: "colSpan" },
    rowspan: { type: Number, render: "rowSpan" }
  }
};
var th = {
  render: "th",
  attributes: {
    width: { type: String },
    align: { type: String },
    colspan: { type: Number, render: "colSpan" },
    rowspan: { type: Number, render: "rowSpan" }
  }
};
var tr = {
  render: "tr",
  children: ["th", "td"]
};
var tbody = {
  render: "tbody",
  children: ["tr", "tag"]
};
var thead = {
  render: "thead",
  children: ["tr"]
};
var strong = {
  render: "strong",
  children: ["em", "s", "link", "code", "text", "tag"],
  attributes: {
    marker: { type: String, render: false }
  }
};
var em = {
  render: "em",
  children: ["strong", "s", "link", "code", "text", "tag"],
  attributes: {
    marker: { type: String, render: false }
  }
};
var s = {
  render: "s",
  children: ["strong", "em", "link", "code", "text", "tag"]
};
var inline = {
  children: [
    "strong",
    "em",
    "s",
    "code",
    "text",
    "tag",
    "link",
    "image",
    "hardbreak",
    "softbreak",
    "comment"
  ]
};
var link = {
  render: "a",
  children: ["strong", "em", "s", "code", "text", "tag"],
  attributes: {
    href: { type: String, required: true },
    title: { type: String }
  }
};
var code = {
  render: "code",
  attributes: {
    content: { type: String, render: false, required: true }
  },
  transform(node22, config3) {
    const attributes = node22.transformAttributes(config3);
    return new Tag("code", attributes, [node22.attributes.content]);
  }
};
var text2 = {
  attributes: {
    content: { type: String, required: true }
  },
  transform(node22) {
    return node22.attributes.content;
  }
};
var hardbreak = {
  render: "br"
};
var softbreak = {
  transform() {
    return " ";
  }
};
var comment = {
  attributes: {
    content: { type: String, required: true }
  }
};
var error = {};
var node = {};
var import_markdown_it = __toModule(require_markdown_it());
var { escapeHtml } = (0, import_markdown_it.default)().utils;
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node22) {
  if (typeof node22 === "string" || typeof node22 === "number")
    return escapeHtml(String(node22));
  if (Array.isArray(node22))
    return node22.map(render).join("");
  if (node22 === null || typeof node22 !== "object" || !Tag.isTag(node22))
    return "";
  const { name: name2, attributes, children = [] } = node22;
  if (!name2)
    return render(children);
  let output = `<${name2}`;
  for (const [k, v] of Object.entries(attributes ?? {}))
    output += ` ${k.toLowerCase()}="${escapeHtml(String(v))}"`;
  output += ">";
  if (voidElements.has(name2))
    return output;
  if (children.length)
    output += render(children);
  output += `</${name2}>`;
  return output;
}
function tagName(name2, components) {
  return typeof name2 !== "string" ? name2 : name2[0] !== name2[0].toUpperCase() ? name2 : components instanceof Function ? components(name2) : components[name2];
}
function dynamic(node22, React10, { components = {} } = {}) {
  function deepRender2(value) {
    if (value == null || typeof value !== "object")
      return value;
    if (Array.isArray(value))
      return value.map((item2) => deepRender2(item2));
    if (value.$$mdtype === "Tag")
      return render3(value);
    if (typeof value !== "object")
      return value;
    const output = {};
    for (const [k, v] of Object.entries(value))
      output[k] = deepRender2(v);
    return output;
  }
  function render3(node3) {
    if (Array.isArray(node3))
      return React10.createElement(React10.Fragment, null, ...node3.map(render3));
    if (node3 === null || typeof node3 !== "object" || !Tag.isTag(node3))
      return node3;
    const {
      name: name2,
      attributes: { class: className, ...attrs } = {},
      children = []
    } = node3;
    if (className)
      attrs.className = className;
    return React10.createElement(tagName(name2, components), Object.keys(attrs).length == 0 ? null : deepRender2(attrs), ...children.map(render3));
  }
  return render3(node22);
}
function tagName2(name2, components) {
  return typeof name2 !== "string" ? "Fragment" : name2[0] !== name2[0].toUpperCase() ? name2 : components instanceof Function ? components(name2) : components[name2];
}
function renderArray(children) {
  return children.map(render2).join(", ");
}
function deepRender(value) {
  if (value == null || typeof value !== "object")
    return JSON.stringify(value);
  if (Array.isArray(value))
    return `[${value.map((item2) => deepRender(item2)).join(", ")}]`;
  if (value.$$mdtype === "Tag")
    return render2(value);
  if (typeof value !== "object")
    return JSON.stringify(value);
  const object2 = Object.entries(value).map(([k, v]) => [JSON.stringify(k), deepRender(v)].join(": ")).join(", ");
  return `{${object2}}`;
}
function render2(node22) {
  if (Array.isArray(node22))
    return `React.createElement(React.Fragment, null, ${renderArray(node22)})`;
  if (node22 === null || typeof node22 !== "object" || !Tag.isTag(node22))
    return JSON.stringify(node22);
  const {
    name: name2,
    attributes: { class: className, ...attrs } = {},
    children = []
  } = node22;
  if (className)
    attrs.className = className;
  return `React.createElement(
    tagName(${JSON.stringify(name2)}, components),
    ${Object.keys(attrs).length == 0 ? "null" : deepRender(attrs)},
    ${renderArray(children)})`;
}
function reactStatic(node22) {
  return `
  (({components = {}} = {}) => {
    ${tagName2}
    return ${render2(node22)};
  })
`;
}
var renderers_default = { html: render, react: dynamic, reactStatic };
var PartialFile = class {
  validate(file, config3) {
    const { partials = {} } = config3;
    const partial2 = partials[file];
    if (!partial2)
      return [
        {
          id: "attribute-value-invalid",
          level: "error",
          message: `Partial \`${file}\` not found. The 'file' attribute must be set in \`config.partials\``
        }
      ];
    return [];
  }
};
var partial = {
  inline: false,
  selfClosing: true,
  attributes: {
    file: { type: PartialFile, render: false, required: true },
    variables: { type: Object, render: false }
  },
  transform(node22, config3) {
    const { partials = {} } = config3;
    const { file, variables } = node22.attributes;
    const partial2 = partials[file];
    if (!partial2)
      return null;
    const scopedConfig = {
      ...config3,
      variables: {
        ...config3.variables,
        ...variables,
        ["$$partial:filename"]: file
      }
    };
    const transformChildren = (part) => part.resolve(scopedConfig).transformChildren(scopedConfig);
    return Array.isArray(partial2) ? partial2.flatMap(transformChildren) : transformChildren(partial2);
  }
};
var table2 = {
  children: ["table"],
  inline: false
};
var slot = {
  attributes: {
    primary: { type: String, required: true }
  }
};
var tags_default = {
  else: tagElse,
  if: tagIf,
  partial,
  slot,
  table: table2
};
var import_lib = __toModule(require_lib2());
var import_tag7 = __toModule(require_tag());
function createToken(state2, content3, contentStart) {
  try {
    const { type, meta, nesting = 0 } = (0, import_tag7.parse)(content3, { Variable, Function: Function2 });
    const token = state2.push(type, "", nesting);
    token.info = content3;
    token.meta = meta;
    if (!state2.delimiters) {
      state2.delimiters = [];
    }
    return token;
  } catch (error22) {
    if (!(error22 instanceof import_tag7.SyntaxError))
      throw error22;
    const {
      message,
      location: { start: start2, end }
    } = error22;
    const location = contentStart ? {
      start: { offset: start2.offset + contentStart },
      end: { offset: end.offset + contentStart }
    } : null;
    const token = state2.push("error", "", 0);
    token.meta = { error: { message, location } };
    return token;
  }
}
function block(state2, startLine, endLine, silent) {
  const start2 = state2.bMarks[startLine] + state2.tShift[startLine];
  const finish = state2.eMarks[startLine];
  if (!state2.src.startsWith(OPEN, start2))
    return false;
  const tagEnd = findTagEnd(state2.src, start2);
  const lastPossible = state2.src.slice(0, finish).trim().length;
  if (!tagEnd || tagEnd < lastPossible - CLOSE.length)
    return false;
  const contentStart = start2 + OPEN.length;
  const content3 = state2.src.slice(contentStart, tagEnd).trim();
  const lines = state2.src.slice(start2, tagEnd + CLOSE.length).split("\n").length;
  if (content3[0] === "$")
    return false;
  if (silent)
    return true;
  const token = createToken(state2, content3, contentStart);
  token.map = [startLine, startLine + lines];
  state2.line += lines;
  return true;
}
function inline2(state2, silent) {
  if (!state2.src.startsWith(OPEN, state2.pos))
    return false;
  const tagEnd = findTagEnd(state2.src, state2.pos);
  if (!tagEnd)
    return false;
  const content3 = state2.src.slice(state2.pos + OPEN.length, tagEnd);
  if (!silent)
    createToken(state2, content3.trim());
  state2.pos = tagEnd + CLOSE.length;
  return true;
}
function core(state2) {
  var _a, _b;
  let token;
  for (token of state2.tokens) {
    if (token.type !== "fence")
      continue;
    if (token.info.includes(OPEN)) {
      const start2 = token.info.indexOf(OPEN);
      const end = findTagEnd(token.info, start2);
      const content3 = token.info.slice(start2 + OPEN.length, end);
      try {
        const { meta } = (0, import_tag7.parse)(content3.trim(), { Variable, Function: Function2 });
        token.meta = meta;
      } catch (error22) {
        if (!(error22 instanceof import_tag7.SyntaxError))
          throw error22;
        if (!token.errors)
          token.errors = [];
        token.errors.push({
          id: "fence-tag-error",
          level: "error",
          message: `Syntax error in fence tag: ${error22.message}`
        });
      }
    }
    if ((_b = (_a = token == null ? void 0 : token.meta) == null ? void 0 : _a.attributes) == null ? void 0 : _b.find((attr) => attr.name === "process" && !attr.value))
      continue;
    token.children = parseTags(token.content, token.map[0]);
  }
}
function plugin(md) {
  md.block.ruler.before("paragraph", "annotations", block, {
    alt: ["paragraph", "blockquote"]
  });
  md.inline.ruler.push("containers", inline2);
  md.core.ruler.push("annotations", core);
}
var fence2 = "---";
function getLine(state2, n2) {
  return state2.src.slice(state2.bMarks[n2], state2.eMarks[n2]).trim();
}
function findClose(state2, endLine) {
  for (let line = 1; line < endLine; line++)
    if (getLine(state2, line) === fence2)
      return line;
}
function block2(state2, startLine, endLine, silent) {
  if (startLine != 0 || getLine(state2, 0) != fence2)
    return false;
  const close2 = findClose(state2, endLine);
  if (!close2)
    return false;
  if (silent)
    return true;
  const token = state2.push("frontmatter", "", 0);
  token.content = state2.src.slice(state2.eMarks[0], state2.bMarks[close2]).trim();
  token.map = [0, close2];
  token.hidden = true;
  state2.line = close2 + 1;
  return true;
}
function plugin2(md) {
  md.block.ruler.before("hr", "frontmatter", block2);
}
var OPEN2 = "<!--";
var CLOSE2 = "-->";
function block3(state2, startLine, endLine, silent) {
  const start2 = state2.bMarks[startLine] + state2.tShift[startLine];
  if (!state2.src.startsWith(OPEN2, start2))
    return false;
  const close2 = state2.src.indexOf(CLOSE2, start2);
  if (!close2)
    return false;
  if (silent)
    return true;
  const content3 = state2.src.slice(start2 + OPEN2.length, close2);
  const lines = content3.split("\n").length;
  const token = state2.push("comment", "", 0);
  token.content = content3.trim();
  token.map = [startLine, startLine + lines];
  state2.line += lines;
  return true;
}
function inline3(state2, silent) {
  if (!state2.src.startsWith(OPEN2, state2.pos))
    return false;
  const close2 = state2.src.indexOf(CLOSE2, state2.pos);
  if (!close2)
    return false;
  if (silent)
    return true;
  const content3 = state2.src.slice(state2.pos + OPEN2.length, close2);
  const token = state2.push("comment", "", 0);
  token.content = content3.trim();
  state2.pos = close2 + CLOSE2.length;
  return true;
}
function plugin3(md) {
  md.block.ruler.before("table", "comment", block3, { alt: ["paragraph"] });
  md.inline.ruler.push("comment", inline3);
}
var Tokenizer = class {
  constructor(config3 = {}) {
    this.parser = new import_lib.default(config3);
    this.parser.use(plugin, "annotations", {});
    this.parser.use(plugin2, "frontmatter", {});
    this.parser.disable([
      "lheading",
      "code"
    ]);
    if (config3.allowComments)
      this.parser.use(plugin3, "comments", {});
  }
  tokenize(content3) {
    return this.parser.parse(content3.toString(), {});
  }
};
var TypeMappings = {
  String,
  Number,
  Array,
  Object,
  Boolean
};
function validateType(type, value, config3, key3) {
  var _a, _b;
  if (!type)
    return true;
  if (ast_default.isFunction(value) && ((_a = config3.validation) == null ? void 0 : _a.validateFunctions)) {
    const schema = (_b = config3.functions) == null ? void 0 : _b[value.name];
    return !(schema == null ? void 0 : schema.returns) ? true : Array.isArray(schema.returns) ? schema.returns.find((t2) => t2 === type) !== void 0 : schema.returns === type;
  }
  if (ast_default.isAst(value))
    return true;
  if (Array.isArray(type))
    return type.some((t2) => validateType(t2, value, config3, key3));
  if (typeof type === "string")
    type = TypeMappings[type];
  if (typeof type === "function") {
    const instance = new type();
    if (instance.validate) {
      return instance.validate(value, config3, key3);
    }
  }
  return value != null && value.constructor === type;
}
function typeToString(type) {
  if (typeof type === "string")
    return type;
  if (Array.isArray(type))
    return type.map(typeToString).join(" | ");
  return type.name;
}
function validateFunction(fn, config3) {
  var _a, _b;
  const schema = (_a = config3.functions) == null ? void 0 : _a[fn.name];
  const errors = [];
  if (!schema)
    return [
      {
        id: "function-undefined",
        level: "critical",
        message: `Undefined function: '${fn.name}'`
      }
    ];
  if (schema.validate)
    errors.push(...schema.validate(fn, config3));
  if (schema.parameters) {
    for (const [key3, value] of Object.entries(fn.parameters)) {
      const param = (_b = schema.parameters) == null ? void 0 : _b[key3];
      if (!param) {
        errors.push({
          id: "parameter-undefined",
          level: "error",
          message: `Invalid parameter: '${key3}'`
        });
        continue;
      }
      if (ast_default.isAst(value) && !ast_default.isFunction(value))
        continue;
      if (param.type) {
        const valid = validateType(param.type, value, config3, key3);
        if (valid === false) {
          errors.push({
            id: "parameter-type-invalid",
            level: "error",
            message: `Parameter '${key3}' of '${fn.name}' must be type of '${typeToString(param.type)}'`
          });
        } else if (Array.isArray(valid)) {
          errors.push(...valid);
        }
      }
    }
  }
  for (const [key3, { required }] of Object.entries(schema.parameters ?? {}))
    if (required && fn.parameters[key3] === void 0)
      errors.push({
        id: "parameter-missing-required",
        level: "error",
        message: `Missing required parameter: '${key3}'`
      });
  return errors;
}
function displayMatches(matches3, n2) {
  if (matches3.length <= n2)
    return JSON.stringify(matches3);
  const items = matches3.slice(0, n2).map((item2) => JSON.stringify(item2));
  return `[${items.join(",")}, ... ${matches3.length - n2} more]`;
}
function validator(node22, config3) {
  var _a, _b;
  const schema = node22.findSchema(config3);
  const errors = [...node22.errors || []];
  if (!schema) {
    errors.push({
      id: node22.tag ? "tag-undefined" : "node-undefined",
      level: "critical",
      message: node22.tag ? `Undefined tag: '${node22.tag}'` : `Undefined node: '${node22.type}'`
    });
    return errors;
  }
  if (schema.inline != void 0 && node22.inline !== schema.inline)
    errors.push({
      id: "tag-placement-invalid",
      level: "critical",
      message: `'${node22.tag}' tag should be ${schema.inline ? "inline" : "block"}`
    });
  if (schema.selfClosing && node22.children.length > 0)
    errors.push({
      id: "tag-selfclosing-has-children",
      level: "critical",
      message: `'${node22.tag}' tag should be self-closing`
    });
  const attributes = {
    ...globalAttributes,
    ...schema.attributes
  };
  for (const key3 of Object.keys(node22.slots)) {
    const slot2 = (_a = schema.slots) == null ? void 0 : _a[key3];
    if (!slot2)
      errors.push({
        id: "slot-undefined",
        level: "error",
        message: `Invalid slot: '${key3}'`
      });
  }
  for (let [key3, value] of Object.entries(node22.attributes)) {
    const attrib = attributes[key3];
    if (!attrib) {
      errors.push({
        id: "attribute-undefined",
        level: "error",
        message: `Invalid attribute: '${key3}'`
      });
      continue;
    }
    let { type, matches: matches3, errorLevel } = attrib;
    if (ast_default.isAst(value)) {
      if (ast_default.isFunction(value) && ((_b = config3.validation) == null ? void 0 : _b.validateFunctions))
        errors.push(...validateFunction(value, config3));
      else if (ast_default.isVariable(value) && config3.variables) {
        let missing = false;
        let variables = config3.variables;
        for (const key22 of value.path) {
          if (!Object.prototype.hasOwnProperty.call(variables, key22)) {
            missing = true;
            break;
          }
          variables = variables[key22];
        }
        if (missing) {
          errors.push({
            id: "variable-undefined",
            level: "error",
            message: `Undefined variable: '${value.path.join(".")}'`
          });
        }
      } else
        continue;
    }
    value = value;
    if (type) {
      const valid = validateType(type, value, config3, key3);
      if (valid === false) {
        errors.push({
          id: "attribute-type-invalid",
          level: errorLevel || "error",
          message: `Attribute '${key3}' must be type of '${typeToString(type)}'`
        });
      }
      if (Array.isArray(valid)) {
        errors.push(...valid);
      }
    }
    if (typeof matches3 === "function")
      matches3 = matches3(config3);
    if (Array.isArray(matches3) && !matches3.includes(value))
      errors.push({
        id: "attribute-value-invalid",
        level: errorLevel || "error",
        message: `Attribute '${key3}' must match one of ${displayMatches(matches3, 8)}. Got '${value}' instead.`
      });
    if (matches3 instanceof RegExp && !matches3.test(value))
      errors.push({
        id: "attribute-value-invalid",
        level: errorLevel || "error",
        message: `Attribute '${key3}' must match ${matches3}. Got '${value}' instead.`
      });
    if (typeof attrib.validate === "function") {
      const attribErrors = attrib.validate(value, config3, key3);
      if (Array.isArray(attribErrors))
        errors.push(...attribErrors);
    }
  }
  for (const [key3, { required }] of Object.entries(attributes))
    if (required && node22.attributes[key3] === void 0)
      errors.push({
        id: "attribute-missing-required",
        level: "error",
        message: `Missing required attribute: '${key3}'`
      });
  if (schema.slots) {
    for (const [key3, { required }] of Object.entries(schema.slots))
      if (required && node22.slots[key3] === void 0)
        errors.push({
          id: "slot-missing-required",
          level: "error",
          message: `Missing required slot: '${key3}'`
        });
  }
  for (const { type } of node22.children) {
    if (schema.children && type !== "error" && !schema.children.includes(type))
      errors.push({
        id: "child-invalid",
        level: "warning",
        message: `Can't nest '${type}' in '${node22.tag || node22.type}'`
      });
  }
  if (schema.validate) {
    const schemaErrors = schema.validate(node22, config3);
    if (isPromise(schemaErrors)) {
      return schemaErrors.then((e3) => errors.concat(e3));
    }
    errors.push(...schemaErrors);
  }
  return errors;
}
function* walkWithParents(node22, parents = []) {
  yield [node22, parents];
  for (const child of [...Object.values(node22.slots), ...node22.children])
    yield* walkWithParents(child, [...parents, node22]);
}
function validateTree(content3, config3) {
  const output = [...walkWithParents(content3)].map(([node22, parents]) => {
    const { type, lines, location } = node22;
    const updatedConfig = {
      ...config3,
      validation: { ...config3.validation, parents }
    };
    const errors = validator(node22, updatedConfig);
    if (isPromise(errors)) {
      return errors.then((e3) => e3.map((error22) => ({ type, lines, location, error: error22 })));
    }
    return errors.map((error22) => ({ type, lines, location, error: error22 }));
  });
  if (output.some(isPromise)) {
    return Promise.all(output).then((o3) => o3.flat());
  }
  return output.flat();
}
var tokenizer = new Tokenizer();
function mergeConfig(config3 = {}) {
  return {
    ...config3,
    tags: {
      ...tags_default,
      ...config3.tags
    },
    nodes: {
      ...schema_exports,
      ...config3.nodes
    },
    functions: {
      ...functions_default,
      ...config3.functions
    }
  };
}
function parse3(content3, args) {
  if (typeof content3 === "string")
    content3 = tokenizer.tokenize(content3);
  return parser(content3, args);
}
function resolve2(content3, config3) {
  if (Array.isArray(content3))
    return content3.flatMap((child) => child.resolve(config3));
  return content3.resolve(config3);
}
function transform2(nodes, options) {
  const config3 = mergeConfig(options);
  const content3 = resolve2(nodes, config3);
  if (Array.isArray(content3))
    return content3.flatMap((child) => child.transform(config3));
  return content3.transform(config3);
}
function validate(content3, options) {
  const config3 = mergeConfig(options);
  return validateTree(content3, config3);
}
function createElement(name2, attributes = {}, ...children) {
  return { name: name2, attributes, children };
}
var Markdoc = class {
  constructor(config3) {
    this.parse = parse3;
    this.resolve = (content3) => resolve2(content3, this.config);
    this.transform = (content3) => transform2(content3, this.config);
    this.validate = (content3) => validate(content3, this.config);
    this.config = config3;
  }
};
Markdoc.nodes = schema_exports;
Markdoc.tags = tags_default;
Markdoc.functions = functions_default;
Markdoc.globalAttributes = globalAttributes;
Markdoc.renderers = renderers_default;
Markdoc.transforms = transforms_default;
Markdoc.Ast = ast_default;
Markdoc.Tag = Tag;
Markdoc.Tokenizer = Tokenizer;
Markdoc.parseTags = parseTags;
Markdoc.transformer = transformer_default;
Markdoc.validator = validator;
Markdoc.parse = parse3;
Markdoc.transform = transform2;
Markdoc.validate = validate;
Markdoc.createElement = createElement;
Markdoc.truthy = truthy;
Markdoc.format = format;

// node_modules/orderedmap/dist/index.js
function OrderedMap(content3) {
  this.content = content3;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key3) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      if (this.content[i2] === key3) return i2;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key3) {
    var found2 = this.find(key3);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key3, value, newKey2) {
    var self2 = newKey2 && newKey2 != key3 ? this.remove(newKey2) : this;
    var found2 = self2.find(key3), content3 = self2.content.slice();
    if (found2 == -1) {
      content3.push(newKey2 || key3, value);
    } else {
      content3[found2 + 1] = value;
      if (newKey2) content3[found2] = newKey2;
    }
    return new OrderedMap(content3);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key3) {
    var found2 = this.find(key3);
    if (found2 == -1) return this;
    var content3 = this.content.slice();
    content3.splice(found2, 2);
    return new OrderedMap(content3);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key3, value) {
    return new OrderedMap([key3, value].concat(this.remove(key3).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key3, value) {
    var content3 = this.remove(key3).content.slice();
    content3.push(key3, value);
    return new OrderedMap(content3);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key3, value) {
    var without = this.remove(key3), content3 = without.content.slice();
    var found2 = without.find(place);
    content3.splice(found2 == -1 ? content3.length : found2, 0, key3, value);
    return new OrderedMap(content3);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      f(this.content[i2], this.content[i2 + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map6) {
    map6 = OrderedMap.from(map6);
    if (!map6.size) return this;
    return new OrderedMap(map6.content.concat(this.subtract(map6).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map6) {
    map6 = OrderedMap.from(map6);
    if (!map6.size) return this;
    return new OrderedMap(this.subtract(map6).content.concat(map6.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map6) {
    var result = this;
    map6 = OrderedMap.from(map6);
    for (var i2 = 0; i2 < map6.content.length; i2 += 2)
      result = result.remove(map6.content[i2]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key3, value) {
      result[key3] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content3 = [];
  if (value) for (var prop in value) content3.push(prop, value[prop]);
  return new OrderedMap(content3);
};
var dist_default = OrderedMap;

// node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i2 = 0; ; i2++) {
    if (i2 == a.childCount || i2 == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i2), childB = b.child(i2);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size4 = childA.nodeSize;
    if (childA == childB) {
      posA -= size4;
      posB -= size4;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size4;
    posB -= size4;
  }
}
var Fragment2 = class _Fragment {
  /**
  @internal
  */
  constructor(content3, size4) {
    this.content = content3;
    this.size = size4 || 0;
    if (size4 == null)
      for (let i2 = 0; i2 < content3.length; i2++)
        this.size += content3[i2].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i2 = 0, pos = 0; pos < to; i2++) {
      let child = this.content[i2], end = pos + child.nodeSize;
      if (end > from2 && f(child, nodeStart + pos, parent || null, i2) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text7 = "", first = true;
    this.nodesBetween(from2, to, (node3, pos) => {
      let nodeText = node3.isText ? node3.text.slice(Math.max(from2, pos) - pos, to - pos) : !node3.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node3) : leafText : node3.type.spec.leafText ? node3.type.spec.leafText(node3) : "";
      if (node3.isBlock && (node3.isLeaf && nodeText || node3.isTextblock) && blockSeparator) {
        if (first)
          first = false;
        else
          text7 += blockSeparator;
      }
      text7 += nodeText;
    }, 0);
    return text7;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first = other.firstChild, content3 = this.content.slice(), i2 = 0;
    if (last.isText && last.sameMarkup(first)) {
      content3[content3.length - 1] = last.withText(last.text + first.text);
      i2 = 1;
    }
    for (; i2 < other.content.length; i2++)
      content3.push(other.content[i2]);
    return new _Fragment(content3, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size4 = 0;
    if (to > from2)
      for (let i2 = 0, pos = 0; pos < to; i2++) {
        let child = this.content[i2], end = pos + child.nodeSize;
        if (end > from2) {
          if (pos < from2 || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size4 += child.nodeSize;
        }
        pos = end;
      }
    return new _Fragment(result, size4);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index4, node3) {
    let current2 = this.content[index4];
    if (current2 == node3)
      return this;
    let copy2 = this.content.slice();
    let size4 = this.size + node3.nodeSize - current2.nodeSize;
    copy2[index4] = node3;
    return new _Fragment(copy2, size4);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node3) {
    return new _Fragment([node3].concat(this.content), this.size + node3.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node3) {
    return new _Fragment(this.content.concat(node3), this.size + node3.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i2 = 0; i2 < this.content.length; i2++)
      if (!this.content[i2].eq(other.content[i2]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index4) {
    let found2 = this.content[index4];
    if (!found2)
      throw new RangeError("Index " + index4 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index4) {
    return this.content[index4] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i2 = 0, p = 0; i2 < this.content.length; i2++) {
      let child = this.content[i2];
      f(child, p, i2);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(pos, round3 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i2 = 0, curPos = 0; ; i2++) {
      let cur = this.child(i2), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos || round3 > 0)
          return retIndex(i2 + 1, end);
        return retIndex(i2, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n2) => n2.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return _Fragment.empty;
    let joined, size4 = 0;
    for (let i2 = 0; i2 < array.length; i2++) {
      let node3 = array[i2];
      size4 += node3.nodeSize;
      if (i2 && node3.isText && array[i2 - 1].sameMarkup(node3)) {
        if (!joined)
          joined = array.slice(0, i2);
        joined[joined.length - 1] = node3.withText(joined[joined.length - 1].text + node3.text);
      } else if (joined) {
        joined.push(node3);
      }
    }
    return new _Fragment(joined || array, size4);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment2.empty = new Fragment2([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index4, offset5) {
  found.index = index4;
  found.offset = offset5;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++)
      if (!compareDeep(a[i2], b[i2]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set2) {
    let copy2, placed = false;
    for (let i2 = 0; i2 < set2.length; i2++) {
      let other = set2[i2];
      if (this.eq(other))
        return set2;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set2.slice(0, i2);
      } else if (other.type.excludes(this.type)) {
        return set2;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set2.slice(0, i2);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set2.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set2) {
    for (let i2 = 0; i2 < set2.length; i2++)
      if (this.eq(set2[i2]))
        return set2.slice(0, i2).concat(set2.slice(i2 + 1));
    return set2;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set2) {
    for (let i2 = 0; i2 < set2.length; i2++)
      if (this.eq(set2[i2]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    return type.create(json.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++)
      if (!a[i2].eq(b[i2]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark.none;
    if (marks instanceof _Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content3, openStart, openEnd) {
    this.content = content3;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content3 = insertInto(this.content, pos + this.openStart, fragment);
    return content3 && new _Slice(content3, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment2.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild)
      openStart++;
    for (let n2 = fragment.lastChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment2.empty, 0, 0);
function removeRange(content3, from2, to) {
  let { index: index4, offset: offset5 } = content3.findIndex(from2), child = content3.maybeChild(index4);
  let { index: indexTo, offset: offsetTo } = content3.findIndex(to);
  if (offset5 == from2 || child.isText) {
    if (offsetTo != to && !content3.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content3.cut(0, from2).append(content3.cut(to));
  }
  if (index4 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content3.replaceChild(index4, child.copy(removeRange(child.content, from2 - offset5 - 1, to - offset5 - 1)));
}
function insertInto(content3, dist, insert, parent) {
  let { index: index4, offset: offset5 } = content3.findIndex(dist), child = content3.maybeChild(index4);
  if (offset5 == dist || child.isText) {
    if (parent && !parent.canReplace(index4, index4, insert))
      return null;
    return content3.cut(0, dist).append(insert).append(content3.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset5 - 1, insert);
  return inner && content3.replaceChild(index4, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index4 = $from.index(depth), node3 = $from.node(depth);
  if (index4 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node3.copy(node3.content.replaceChild(index4, inner));
  } else if (!slice2.content.size) {
    return close(node3, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content3 = parent.content;
    return close(parent, content3.cut(0, $from.parentOffset).append(slice2.content).append(content3.cut($to.parentOffset)));
  } else {
    let { start: start2, end } = prepareSliceForReplace(slice2, $from);
    return close(node3, replaceThreeWay($from, start2, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  let node3 = $before.node(depth);
  checkJoin(node3, $after.node(depth));
  return node3;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node3 = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node3.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i2 = startIndex; i2 < endIndex; i2++)
    addNode(node3.child(i2), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node3, content3) {
  node3.type.checkContent(content3);
  return node3.copy(content3);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content3 = [];
  addRange(null, $from, depth, content3);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content3);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content3);
    addRange($start, $end, depth, content3);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content3);
  }
  addRange($to, null, depth, content3);
  return new Fragment2(content3);
}
function replaceTwoWay($from, $to, depth) {
  let content3 = [];
  addRange(null, $from, depth, content3);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content3);
  }
  addRange($to, null, depth, content3);
  return new Fragment2(content3);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node3 = parent.copy(slice2.content);
  for (let i2 = extra - 1; i2 >= 0; i2--)
    node3 = $along.node(i2).copy(Fragment2.from(node3));
  return {
    start: node3.resolveNoCache(slice2.openStart + extra),
    end: node3.resolveNoCache(node3.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path3, parentOffset) {
    this.pos = pos;
    this.path = path3;
    this.parentOffset = parentOffset;
    this.depth = path3.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index4 = this.index(this.depth);
    if (index4 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index4);
    return dOff ? parent.child(index4).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index4 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index4).cut(0, dOff);
    return index4 == 0 ? null : this.parent.child(index4 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index4, depth) {
    depth = this.resolveDepth(depth);
    let node3 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i2 = 0; i2 < index4; i2++)
      pos += node3.child(i2).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index4 = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index4).marks;
    let main = parent.maybeChild(index4 - 1), other = parent.maybeChild(index4);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i2 = 0; i2 < marks.length; i2++)
      if (marks[i2].type.spec.inclusive === false && (!other || !marks[i2].isInSet(other.marks)))
        marks = marks[i2--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i2 = 0; i2 < marks.length; i2++)
      if (marks[i2].type.spec.inclusive === false && (!next || !marks[i2].isInSet(next.marks)))
        marks = marks[i2--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i2 = 1; i2 <= this.depth; i2++)
      str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc4, pos) {
    if (!(pos >= 0 && pos <= doc4.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path3 = [];
    let start2 = 0, parentOffset = pos;
    for (let node3 = doc4; ; ) {
      let { index: index4, offset: offset5 } = node3.content.findIndex(parentOffset);
      let rem = parentOffset - offset5;
      path3.push(node3, index4, start2 + offset5);
      if (!rem)
        break;
      node3 = node3.child(index4);
      if (node3.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset5 + 1;
    }
    return new _ResolvedPos(pos, path3, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc4, pos) {
    for (let i2 = 0; i2 < resolveCache.length; i2++) {
      let cached = resolveCache[i2];
      if (cached.pos == pos && cached.doc == doc4)
        return cached;
    }
    let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc4, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result;
  }
};
var resolveCache = [];
var resolveCachePos = 0;
var resolveCacheSize = 12;
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node4 = class _Node {
  /**
  @internal
  */
  constructor(type, attrs, content3, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content3 || Fragment2.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index4) {
    return this.content.child(index4);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index4) {
    return this.content.maybeChild(index4);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content3 = null) {
    if (content3 == this.content)
      return this;
    return new _Node(this.type, this.attrs, content3, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node3 = $from.node(depth);
    let content3 = node3.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content3, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node3 = this; ; ) {
      let { index: index4, offset: offset5 } = node3.content.findIndex(pos);
      node3 = node3.maybeChild(index4);
      if (!node3)
        return null;
      if (offset5 == pos || node3.isText)
        return node3;
      pos -= offset5 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index4, offset: offset5 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index4), index: index4, offset: offset5 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index4, offset: offset5 } = this.content.findIndex(pos);
    if (offset5 < pos)
      return { node: this.content.child(index4), index: index4, offset: offset5 };
    let node3 = this.content.child(index4 - 1);
    return { node: node3, index: index4 - 1, offset: offset5 - node3.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node3) => {
        if (type.isInSet(node3.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name2 = this.type.name;
    if (this.content.size)
      name2 += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name2);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index4) {
    let match2 = this.type.contentMatch.matchFragment(this.content, 0, index4);
    if (!match2)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match2;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment2.empty, start2 = 0, end = replacement.childCount) {
    let one2 = this.contentMatchAt(from2).matchFragment(replacement, start2, end);
    let two = one2 && one2.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i2 = start2; i2 < end; i2++)
      if (!this.type.allowsMarks(replacement.child(i2).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from2).matchType(type);
    let end = start2 && start2.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let copy2 = Mark.none;
    for (let i2 = 0; i2 < this.marks.length; i2++)
      copy2 = this.marks[i2].addToSet(copy2);
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node3) => node3.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n2) => n2.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = null;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content3 = Fragment2.fromJSON(schema, json.content);
    return schema.nodeType(json.type).create(json.attrs, content3, marks);
  }
};
Node4.prototype.text = void 0;
var TextNode = class _TextNode extends Node4 {
  /**
  @internal
  */
  constructor(type, attrs, content3, marks) {
    super(type, attrs, null, marks);
    if (!content3)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content3;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text7) {
    if (text7 == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text7, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i2 = marks.length - 1; i2 >= 0; i2--)
    str = marks[i2].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string3, nodeTypes) {
    let stream = new TokenStream(string3, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match2 = dfa(nfa(expr));
    checkForDeadEnds(match2, stream);
    return match2;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i2 = 0; i2 < this.next.length; i2++)
      if (this.next[i2].type == type)
        return this.next[i2].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start2 = 0, end = frag.childCount) {
    let cur = this;
    for (let i2 = start2; cur && i2 < end; i2++)
      cur = cur.matchType(frag.child(i2).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i2 = 0; i2 < this.next.length; i2++) {
      let { type } = this.next[i2];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i2 = 0; i2 < this.next.length; i2++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i2].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search2(match2, types4) {
      let finished = match2.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment2.from(types4.map((tp) => tp.createAndFill()));
      for (let i2 = 0; i2 < match2.next.length; i2++) {
        let { type, next } = match2.next[i2];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search2(next, types4.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search2(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i2 = 0; i2 < this.wrapCache.length; i2 += 2)
      if (this.wrapCache[i2] == target)
        return this.wrapCache[i2 + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current2 = active.shift(), match2 = current2.match;
      if (match2.matchType(target)) {
        let result = [];
        for (let obj = current2; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i2 = 0; i2 < match2.next.length; i2++) {
        let { type, next } = match2.next[i2];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current2.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current2 });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n2) {
    if (n2 >= this.next.length)
      throw new RangeError(`There's no ${n2}th edge in this content match`);
    return this.next[n2];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i2 = 0; i2 < m.next.length; i2++)
        if (seen.indexOf(m.next[i2].next) == -1)
          scan(m.next[i2].next);
    }
    scan(this);
    return seen.map((m, i2) => {
      let out = i2 + (m.validEnd ? "*" : " ") + " ";
      for (let i3 = 0; i3 < m.next.length; i3++)
        out += (i3 ? ", " : "") + m.next[i3].type.name + "->" + seen.indexOf(m.next[i3].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string3, nodeTypes) {
    this.string = string3;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string3.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min3 = parseNum(stream), max4 = min3;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max4 = parseNum(stream);
    else
      max4 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min3, max: max4, expr };
}
function resolveName(stream, name2) {
  let types4 = stream.nodeTypes, type = types4[name2];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types4) {
    let type2 = types4[typeName];
    if (type2.groups.indexOf(name2) > -1)
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name2 + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile2(expr, 0), node3());
  return nfa2;
  function node3() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile2(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile2(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i2 = 0; ; i2++) {
        let next = compile2(expr2.exprs[i2], from2);
        if (i2 == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node3());
      }
    } else if (expr2.type == "star") {
      let loop = node3();
      edge(from2, loop);
      connect(compile2(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node3();
      connect(compile2(expr2.expr, from2), loop);
      connect(compile2(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile2(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i2 = 0; i2 < expr2.min; i2++) {
        let next = node3();
        connect(compile2(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile2(expr2.expr, cur), cur);
      } else {
        for (let i2 = expr2.min; i2 < expr2.max; i2++) {
          let next = node3();
          edge(cur, next);
          connect(compile2(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node3) {
  let result = [];
  scan(node3);
  return result.sort(cmp);
  function scan(node4) {
    let edges = nfa2[node4];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node4);
    for (let i2 = 0; i2 < edges.length; i2++) {
      let { term, to } = edges[i2];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node3) => {
      nfa2[node3].forEach(({ term, to }) => {
        if (!term)
          return;
        let set2;
        for (let i2 = 0; i2 < out.length; i2++)
          if (out[i2][0] == term)
            set2 = out[i2][1];
        nullFrom(nfa2, to).forEach((node4) => {
          if (!set2)
            out.push([term, set2 = []]);
          if (set2.indexOf(node4) == -1)
            set2.push(node4);
        });
      });
    });
    let state2 = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i2 = 0; i2 < out.length; i2++) {
      let states2 = out[i2][1].sort(cmp);
      state2.next.push({ type: out[i2][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state2;
  }
}
function checkForDeadEnds(match2, stream) {
  for (let i2 = 0, work = [match2]; i2 < work.length; i2++) {
    let state2 = work[i2], dead = !state2.validEnd, nodes = [];
    for (let j = 0; j < state2.next.length; j++) {
      let { type, next } = state2.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults3 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults3[attrName] = attr.default;
  }
  return defaults3;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name2 in attrs) {
    let given = value && value[name2];
    if (given === void 0) {
      let attr = attrs[name2];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name2);
    }
    built[name2] = given;
  }
  return built;
}
function initAttrs(attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name2 in attrs)
      result[name2] = new Attribute(attrs[name2]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name2, schema, spec) {
    this.name = name2;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name2 == "text");
    this.isText = name2 == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n2 in this.attrs)
      if (this.attrs[n2].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content3, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node4(this, this.computeAttrs(attrs), Fragment2.from(content3), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content3, marks) {
    content3 = Fragment2.from(content3);
    this.checkContent(content3);
    return new Node4(this, this.computeAttrs(attrs), content3, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content3, marks) {
    attrs = this.computeAttrs(attrs);
    content3 = Fragment2.from(content3);
    if (content3.size) {
      let before = this.contentMatch.fillBefore(content3);
      if (!before)
        return null;
      content3 = before.append(content3);
    }
    let matched = this.contentMatch.matchFragment(content3);
    let after = matched && matched.fillBefore(Fragment2.empty, true);
    if (!after)
      return null;
    return new Node4(this, attrs, content3.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(content3) {
    let result = this.contentMatch.matchFragment(content3);
    if (!result || !result.validEnd)
      return false;
    for (let i2 = 0; i2 < content3.childCount; i2++)
      if (!this.allowsMarks(content3.child(i2).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content3) {
    if (!this.validContent(content3))
      throw new RangeError(`Invalid content for node ${this.name}: ${content3.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i2 = 0; i2 < marks.length; i2++)
      if (!this.allowsMarkType(marks[i2].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i2 = 0; i2 < marks.length; i2++) {
      if (!this.allowsMarkType(marks[i2].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i2);
      } else if (copy2) {
        copy2.push(marks[i2]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name2, spec) => result[name2] = new _NodeType(name2, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
var Attribute = class {
  constructor(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name2, rank, schema, spec) {
    this.name = name2;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    let defaults3 = defaultAttrs(this.attrs);
    this.instance = defaults3 ? new Mark(this, defaults3) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name2, spec) => result[name2] = new _MarkType(name2, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set2) {
    for (var i2 = 0; i2 < set2.length; i2++)
      if (set2[i2].type == this) {
        set2 = set2.slice(0, i2).concat(set2.slice(i2 + 1));
        i2--;
      }
    return set2;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set2) {
    for (let i2 = 0; i2 < set2.length; i2++)
      if (set2[i2].type == this)
        return set2[i2];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content3, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content3, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text7, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text7, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node4.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name2) {
    let found2 = this.nodes[name2];
    if (!found2)
      throw new RangeError("Unknown node type: " + name2);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i2 = 0; i2 < marks.length; i2++) {
    let name2 = marks[i2], mark = schema.marks[name2], ok3 = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name2 == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name2) > -1)
          found2.push(ok3 = mark2);
      }
    }
    if (!ok3)
      throw new SyntaxError("Unknown mark type: '" + marks[i2] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
var DOMParser2 = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule))
        this.tags.push(rule);
      else if (isStyleRule(rule))
        this.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node3 = schema.nodes[r2.node];
      return node3.contentMatch.matchType(node3);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i2 = after ? this.tags.indexOf(after) + 1 : 0; i2 < this.tags.length; i2++) {
      let rule = this.tags[i2];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i2 = after ? this.styles.indexOf(after) + 1 : 0; i2 < this.styles.length; i2++) {
      let rule = this.styles[i2], style = rule.style;
      if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
      for (; i2 < result.length; i2++) {
        let next = result[i2], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i2, 0, rule);
    }
    for (let name2 in schema.marks) {
      let rules = schema.marks[name2].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name2;
        });
    }
    for (let name2 in schema.nodes) {
      let rules = schema.nodes[name2].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name2;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, pendingMarks, solid, match2, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.stashMarks = [];
    this.match = match2 || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node3) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment2.from(node3));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap2;
        if (wrap2 = start2.findWrapping(node3.type)) {
          this.match = start2;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node3.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text7 = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text7.withText(text7.text.slice(0, text7.text.length - m[0].length));
      }
    }
    let content3 = Fragment2.from(this.content);
    if (!openEnd && this.match)
      content3 = content3.append(this.match.fillBefore(Fragment2.empty, true));
    return this.type ? this.type.create(this.attrs, content3, this.marks) : content3;
  }
  popFromStashMark(mark) {
    for (let i2 = this.stashMarks.length - 1; i2 >= 0; i2--)
      if (mark.eq(this.stashMarks[i2]))
        return this.stashMarks.splice(i2, 1)[0];
  }
  applyPending(nextType) {
    for (let i2 = 0, pending = this.pendingMarks; i2 < pending.length; i2++) {
      let mark = pending[i2];
      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
        this.activeMarks = mark.addToSet(this.activeMarks);
        this.pendingMarks = mark.removeFromSet(this.pendingMarks);
      }
    }
  }
  inlineContext(node3) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node3.parentNode && !blockTags.hasOwnProperty(node3.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser2, options, isOpen) {
    this.parser = parser2;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser2.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom) {
    if (dom.nodeType == 3)
      this.addTextNode(dom);
    else if (dom.nodeType == 1)
      this.addElement(dom);
  }
  withStyleRules(dom, f) {
    let style = dom.getAttribute("style");
    if (!style)
      return f();
    let marks = this.readStyles(parseStyles(style));
    if (!marks)
      return;
    let [addMarks, removeMarks] = marks, top = this.top;
    for (let i2 = 0; i2 < removeMarks.length; i2++)
      this.removePendingMark(removeMarks[i2], top);
    for (let i2 = 0; i2 < addMarks.length; i2++)
      this.addPendingMark(addMarks[i2]);
    f();
    for (let i2 = 0; i2 < addMarks.length; i2++)
      this.removePendingMark(addMarks[i2], top);
    for (let i2 = 0; i2 < removeMarks.length; i2++)
      this.addPendingMark(removeMarks[i2]);
  }
  addTextNode(dom) {
    let value = dom.nodeValue;
    let top = this.top;
    if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, matchAfter) {
    let name2 = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name2) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name2)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, top = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name2)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      if (rule && rule.skip)
        this.addAll(dom);
      else
        this.withStyleRules(dom, () => this.addAll(dom));
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.withStyleRules(dom, () => {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
      });
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
  // Called for ignored nodes
  ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(styles3) {
    let add2 = Mark.none, remove = Mark.none;
    for (let i2 = 0; i2 < styles3.length; i2 += 2) {
      for (let after = void 0; ; ) {
        let rule = this.parser.matchStyle(styles3[i2], styles3[i2 + 1], this, after);
        if (!rule)
          break;
        if (rule.ignore)
          return null;
        if (rule.clearMark) {
          this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
            if (rule.clearMark(m))
              remove = m.addToSet(remove);
          });
        } else {
          add2 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add2);
        }
        if (rule.consuming === false)
          after = rule;
        else
          break;
      }
    }
    return [add2, remove];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, continueAfter) {
    let sync, nodeType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node3) => this.insertNode(node3));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync && this.sync(startIn))
      this.open--;
    if (mark)
      this.removePendingMark(mark, startIn);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, startIndex, endIndex) {
    let index4 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index4) {
      this.findAtPoint(parent, index4);
      this.addDOM(dom);
    }
    this.findAtPoint(parent, index4);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node3) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node3);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync);
    for (let i2 = 0; i2 < route.length; i2++)
      this.enterInner(route[i2], null, false);
    return true;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node3) {
    if (node3.isInline && this.needsBlock && !this.top.type) {
      let block4 = this.textblockFromContext();
      if (block4)
        this.enterInner(block4);
    }
    if (this.findPlace(node3)) {
      this.closeExtra();
      let top = this.top;
      top.applyPending(node3.type);
      if (top.match)
        top.match = top.match.matchType(node3.type);
      let marks = top.activeMarks;
      for (let i2 = 0; i2 < node3.marks.length; i2++)
        if (!top.type || top.type.allowsMarkType(node3.marks[i2].type))
          marks = node3.marks[i2].addToSet(marks);
      top.content.push(node3.mark(marks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, preserveWS) {
    let ok3 = this.findPlace(type.create(attrs));
    if (ok3)
      this.enterInner(type, attrs, true, preserveWS);
    return ok3;
  }
  // Open a node of the given type
  enterInner(type, attrs = null, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.applyPending(type);
    top.match = top.match && top.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
    this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i2 = this.nodes.length - 1;
    if (i2 > this.open) {
      for (; i2 > this.open; i2--)
        this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(to) {
    for (let i2 = this.open; i2 >= 0; i2--)
      if (this.nodes[i2] == to) {
        this.open = i2;
        return true;
      }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i2 = this.open; i2 >= 0; i2--) {
      let content3 = this.nodes[i2].content;
      for (let j = content3.length - 1; j >= 0; j--)
        pos += content3[j].nodeSize;
      if (i2)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset5) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].node == parent && this.find[i2].offset == offset5)
          this.find[i2].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node))
          this.find[i2].pos = this.currentPos;
      }
  }
  findAround(parent, content3, before) {
    if (parent != content3 && this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
          let pos = content3.compareDocumentPosition(this.find[i2].node);
          if (pos & (before ? 2 : 4))
            this.find[i2].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].node == textNode)
          this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match2 = (i2, depth) => {
      for (; i2 >= 0; i2--) {
        let part = parts[i2];
        if (part == "") {
          if (i2 == parts.length - 1 || i2 == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match2(i2 - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && next.groups.indexOf(part) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match2(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name2 in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name2];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
  addPendingMark(mark) {
    let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
  }
  removePendingMark(mark, upto) {
    for (let depth = this.open; depth >= 0; depth--) {
      let level = this.nodes[depth];
      let found2 = level.pendingMarks.lastIndexOf(mark);
      if (found2 > -1) {
        level.pendingMarks = mark.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark.removeFromSet(level.activeMarks);
        let stashMark = level.popFromStashMark(mark);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name2 = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name2 && listTags.hasOwnProperty(name2) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name2 == "li") {
      prevItem = child;
    } else if (name2) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style) {
  let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style))
    result.push(m[1], m[2].trim());
  return result;
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name2 in nodes) {
    let parent = nodes[name2];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match2) => {
      seen.push(match2);
      for (let i2 = 0; i2 < match2.edgeCount; i2++) {
        let { type, next } = match2.edge(i2);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark, set2) {
  for (let i2 = 0; i2 < set2.length; i2++) {
    if (mark.eq(set2[i2]))
      return set2[i2];
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc2(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node3) => {
      if (active.length || node3.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node3.marks.length) {
          let next = node3.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node3.marks.length) {
          let add2 = node3.marks[rendered++];
          let markDOM = this.serializeMark(add2, node3.isInline, options);
          if (markDOM) {
            active.push([add2, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node3, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node3, options) {
    let { dom, contentDOM } = _DOMSerializer.renderSpec(doc2(options), this.nodes[node3.type.name](node3));
    if (contentDOM) {
      if (node3.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node3.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node3, options = {}) {
    let dom = this.serializeNodeInner(node3, options);
    for (let i2 = node3.marks.length - 1; i2 >= 0; i2--) {
      let wrap2 = this.serializeMark(node3.marks[i2], node3.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline7, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && _DOMSerializer.renderSpec(doc2(options), toDOM(mark, inline7));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(doc4, structure, xmlNS = null) {
    if (typeof structure == "string")
      return { dom: doc4.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName3 = structure[0], space = tagName3.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName3.slice(0, space);
      tagName3 = tagName3.slice(space + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc4.createElementNS(xmlNS, tagName3) : doc4.createElement(tagName3);
    let attrs = structure[1], start2 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start2 = 2;
      for (let name2 in attrs)
        if (attrs[name2] != null) {
          let space2 = name2.indexOf(" ");
          if (space2 > 0)
            dom.setAttributeNS(name2.slice(0, space2), name2.slice(space2 + 1), attrs[name2]);
          else
            dom.setAttribute(name2, attrs[name2]);
        }
    }
    for (let i2 = start2; i2 < structure.length; i2++) {
      let child = structure[i2];
      if (child === 0) {
        if (i2 < structure.length - 1 || i2 > start2)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = _DOMSerializer.renderSpec(doc4, child, xmlNS);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node3) => node3.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name2 in obj) {
    let toDOM = obj[name2].spec.toDOM;
    if (toDOM)
      result[name2] = toDOM;
  }
  return result;
}
function doc2(options) {
  return options.document || window.document;
}

// node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index4, offset5) {
  return index4 + offset5 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index4 = recoverIndex(value);
    if (!this.inverted)
      for (let i2 = 0; i2 < index4; i2++)
        diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
    return this.ranges[index4 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
      let start2 = this.ranges[i2] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end = start2 + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end) ? null : makeRecover(i2 / 3, pos - start2);
        let del3 = pos == start2 ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end)
          del3 |= DEL_SIDE;
        return new MapResult(result, del3, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index4 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
      let start2 = this.ranges[i2] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i2 + oldIndex], end = start2 + oldSize;
      if (pos <= end && i2 == index4 * 3)
        return true;
      diff += this.ranges[i2 + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
      let start2 = this.ranges[i2], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n2) {
    return n2 == 0 ? _StepMap.empty : new _StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps = [], mirror, from2 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this.maps, this.mirror, from2, to);
  }
  /**
  @internal
  */
  copy() {
    return new _Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map6, mirrors) {
    this.to = this.maps.push(map6);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i2 = 0, startSize = this.maps.length; i2 < mapping.maps.length; i2++) {
      let mirr = mapping.getMirror(i2);
      this.appendMap(mapping.maps[i2], mirr != null && mirr < i2 ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n2) {
    if (this.mirror) {
      for (let i2 = 0; i2 < this.mirror.length; i2++)
        if (this.mirror[i2] == n2)
          return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n2, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n2, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i2 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i2 >= 0; i2--) {
      let mirr = mapping.getMirror(i2);
      this.appendMap(mapping.maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i2 = this.from; i2 < this.to; i2++)
      pos = this.maps[i2].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i2 = this.from; i2 < this.to; i2++) {
      let map6 = this.maps[i2], result = map6.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i2);
        if (corr != null && corr > i2 && corr < this.to) {
          i2 = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc4, failed) {
    this.doc = doc4;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc4) {
    return new _StepResult(doc4, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc4, from2, to, slice2) {
    try {
      return _StepResult.ok(doc4.replace(from2, to, slice2));
    } catch (e3) {
      if (e3 instanceof ReplaceError)
        return _StepResult.fail(e3.message);
      throw e3;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i2 = 0; i2 < fragment.childCount; i2++) {
    let child = fragment.child(i2);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i2);
    mapped.push(child);
  }
  return Fragment2.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc4) {
    let oldSlice = doc4.slice(this.from, this.to), $from = doc4.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node3, parent2) => {
      if (!node3.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node3;
      return node3.mark(this.mark.addToSet(node3.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc4, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc4) {
    let oldSlice = doc4.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node3) => {
      return node3.mark(this.mark.removeFromSet(node3.marks));
    }, doc4), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc4, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc4) {
    let node3 = doc4.nodeAt(this.pos);
    if (!node3)
      return StepResult.fail("No node at mark step's position");
    let updated = node3.type.create(node3.attrs, null, this.mark.addToSet(node3.marks));
    return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment2.from(updated), 0, node3.isLeaf ? 0 : 1));
  }
  invert(doc4) {
    let node3 = doc4.nodeAt(this.pos);
    if (node3) {
      let newSet = this.mark.addToSet(node3.marks);
      if (newSet.length == node3.marks.length) {
        for (let i2 = 0; i2 < node3.marks.length; i2++)
          if (!node3.marks[i2].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node3.marks[i2]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc4) {
    let node3 = doc4.nodeAt(this.pos);
    if (!node3)
      return StepResult.fail("No node at mark step's position");
    let updated = node3.type.create(node3.attrs, null, this.mark.removeFromSet(node3.marks));
    return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment2.from(updated), 0, node3.isLeaf ? 0 : 1));
  }
  invert(doc4) {
    let node3 = doc4.nodeAt(this.pos);
    if (!node3 || !this.mark.isInSet(node3.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc4) {
    if (this.structure && contentBetween(doc4, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc4, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc4) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc4.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc4) {
    if (this.structure && (contentBetween(doc4, this.from, this.gapFrom) || contentBetween(doc4, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc4.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc4, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc4) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc4.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc4, from2, to) {
  let $from = doc4.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node3, pos, parent) => {
    if (!node3.isInline)
      return;
    let marks = node3.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from2), end = Math.min(pos + node3.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i2 = 0; i2 < marks.length; i2++) {
        if (!marks[i2].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i2]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start2, end, marks[i2]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start2, end, mark));
    }
  });
  removed.forEach((s2) => tr2.step(s2));
  added.forEach((s2) => tr2.step(s2));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node3, pos) => {
    if (!node3.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set2 = node3.marks, found2;
      while (found2 = mark.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(found2);
        set2 = found2.removeFromSet(set2);
      }
    } else if (mark) {
      if (mark.isInSet(node3.marks))
        toRemove = [mark];
    } else {
      toRemove = node3.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node3.nodeSize, to);
      for (let i2 = 0; i2 < toRemove.length; i2++) {
        let style = toRemove[i2], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style, from: Math.max(pos, from2), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match2 = parentType.contentMatch) {
  let node3 = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i2 = 0; i2 < node3.childCount; i2++) {
    let child = node3.child(i2), end = cur + child.nodeSize;
    let allowed = match2.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match2 = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (child.isText && !parentType.spec.code) {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment2.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end;
  }
  if (!match2.validEnd) {
    let fill = match2.fillBefore(Fragment2.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i2 = replSteps.length - 1; i2 >= 0; i2--)
    tr2.step(replSteps[i2]);
}
function canCut(node3, start2, end) {
  return (start2 == 0 || node3.canReplace(start2, node3.childCount)) && (end == node3.childCount || node3.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content3 = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node3 = range.$from.node(depth);
    let index4 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node3.canReplace(index4, endIndex, content3))
      return depth;
    if (depth == 0 || node3.type.spec.isolating || !canCut(node3, index4, endIndex))
      break;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end = gapEnd;
  let before = Fragment2.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment2.from($from.node(d).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment2.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment2.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr2.step(new ReplaceAroundStep(start2, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i2 = startIndex; innerMatch && i2 < endIndex; i2++)
    innerMatch = innerMatch.matchType(parent.child(i2).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content3 = Fragment2.empty;
  for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
    if (content3.size) {
      let match2 = wrappers[i2].type.contentMatch.matchFragment(content3);
      if (!match2 || !match2.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content3 = Fragment2.from(wrappers[i2].type.create(wrappers[i2].attrs, content3));
  }
  let start2 = range.start, end = range.end;
  tr2.step(new ReplaceAroundStep(start2, end, start2, end, new Slice(content3, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node3, pos) => {
    if (node3.isTextblock && !node3.hasMarkup(type, attrs) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      tr2.clearIncompatible(tr2.mapping.slice(mapFrom).map(pos, 1), type);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node3.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment2.from(type.create(attrs, null, node3.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc4, pos, type) {
  let $pos = doc4.resolve(pos), index4 = $pos.index();
  return $pos.parent.canReplaceWith(index4, index4 + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node3 = tr2.doc.nodeAt(pos);
  if (!node3)
    throw new RangeError("No node at given position");
  if (!type)
    type = node3.type;
  let newNode = type.create(attrs, null, marks || node3.marks);
  if (node3.isLeaf)
    return tr2.replaceWith(pos, pos + node3.nodeSize, newNode);
  if (!type.validContent(node3.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node3.nodeSize, pos + 1, pos + node3.nodeSize - 1, new Slice(Fragment2.from(newNode), 0, 0), 1, true));
}
function canSplit(doc4, pos, depth = 1, typesAfter) {
  let $pos = doc4.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i2 = depth - 2; d > base2; d--, i2--) {
    let node3 = $pos.node(d), index5 = $pos.index(d);
    if (node3.type.spec.isolating)
      return false;
    let rest = node3.content.cutByIndex(index5, node3.childCount);
    let overrideChild = typesAfter && typesAfter[i2 + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i2] || node3;
    if (!node3.canReplace(index5 + 1, node3.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index4 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index4, index4, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment2.empty, after = Fragment2.empty;
  for (let d = $pos.depth, e3 = $pos.depth - depth, i2 = depth - 1; d > e3; d--, i2--) {
    before = Fragment2.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i2];
    after = Fragment2.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc4, pos) {
  let $pos = doc4.resolve(pos), index4 = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index4, index4 + 1);
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}
function joinPoint(doc4, pos, dir = -1) {
  let $pos = doc4.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index4 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index4++;
      after = $pos.node(d).maybeChild(index4);
    } else {
      before = $pos.node(d).maybeChild(index4 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index4, index4 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr2.step(step);
}
function insertPoint(doc4, pos, nodeType) {
  let $pos = doc4.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index4 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index4, index4, nodeType))
        return $pos.before(d + 1);
      if (index4 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index4 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index4, index4, nodeType))
        return $pos.after(d + 1);
      if (index4 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc4, pos, slice2) {
  let $pos = doc4.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content3 = slice2.content;
  for (let i2 = 0; i2 < slice2.openStart; i2++)
    content3 = content3.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content3);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content3.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc4, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc4.resolve(from2), $to = doc4.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment2.empty;
    for (let i2 = 0; i2 <= $from.depth; i2++) {
      let node3 = $from.node(i2);
      this.frontier.push({
        type: node3.type,
        match: node3.contentMatchAt($from.indexAfter(i2))
      });
    }
    for (let i2 = $from.depth; i2 > 0; i2--)
      this.placed = Fragment2.from($from.node(i2).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content3 = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content3.childCount == 1) {
      content3 = content3.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content3, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node3 = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node3.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node3.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match: match2 } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first ? match2.matchType(first.type) || (inject = match2.fillBefore(Fragment2.from(first), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first && (wrap2 = match2.findWrapping(first.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match2.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content: content3, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content3, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content3, openStart + 1, Math.max(openEnd, inner.size + openStart >= content3.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content: content3, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content3, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content3.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content3, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content3, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i2 = 0; i2 < wrap2.length; i2++)
        this.openFrontierNode(wrap2[i2]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add2 = [];
    let { match: match2, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i2 = 0; i2 < inject.childCount; i2++)
        add2.push(inject.child(i2));
      match2 = match2.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches3 = match2.matchType(next.type);
      if (!matches3)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match2 = matches3;
        add2.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment2.from(add2));
    this.frontier[frontierDepth].match = match2;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i2 = 0, cur = fragment; i2 < openEndCount; i2++) {
      let node3 = cur.lastChild;
      this.frontier.push({ type: node3.type, match: node3.contentMatchAt(node3.childCount) });
      cur = node3.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
      let { match: match2, type } = this.frontier[i2];
      let dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
      let fit = contentAfterFits($to, i2, type, match2, dropInner);
      if (!fit)
        continue;
      for (let d = i2 - 1; d >= 0; d--) {
        let { match: match3, type: type2 } = this.frontier[d];
        let matches3 = contentAfterFits($to, d, type2, match3, true);
        if (!matches3 || matches3.childCount)
          continue scan;
      }
      return { depth: i2, fit, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node3 = $to.node(d), add2 = node3.type.contentMatch.fillBefore(node3.content, true, $to.index(d));
      this.openFrontierNode(node3.type, node3.attrs, add2);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content3) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment2.from(type.create(attrs, content3)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add2 = open.match.fillBefore(Fragment2.empty, true);
    if (add2.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add2);
  }
};
function dropFromFragment(fragment, depth, count2) {
  if (depth == 0)
    return fragment.cutByIndex(count2, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count2)));
}
function addToFragment(fragment, depth, content3) {
  if (depth == 0)
    return fragment.append(content3);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content3)));
}
function contentAt(fragment, depth) {
  for (let i2 = 0; i2 < depth; i2++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node3, openStart, openEnd) {
  if (openStart <= 0)
    return node3;
  let frag = node3.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node3.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node3.type.contentMatch.matchFragment(frag).fillBefore(Fragment2.empty, true));
  }
  return node3.copy(frag);
}
function contentAfterFits($to, depth, type, match2, open) {
  let node3 = $to.node(depth), index4 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index4 == node3.childCount && !type.compatibleContent(node3.type))
    return null;
  let fit = match2.fillBefore(node3.content, true, index4);
  return fit && !invalidMarks(type, node3.content, index4) ? fit : null;
}
function invalidMarks(type, fragment, start2) {
  for (let i2 = start2; i2 < fragment.childCount; i2++)
    if (!type.allowsMarks(fragment.child(i2).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content3 = slice2.content, i2 = 0; ; i2++) {
    let node3 = content3.firstChild;
    leftNodes.push(node3);
    if (i2 == slice2.openStart)
      break;
    content3 = node3.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i2 = 0; i2 < targetDepths.length; i2++) {
      let targetDepth = targetDepths[(i2 + preferredTargetIndex) % targetDepths.length], expand2 = true;
      if (targetDepth < 0) {
        expand2 = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index4 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index4, index4, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand2 ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i2 = targetDepths.length - 1; i2 >= 0; i2--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i2];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    let match2 = parent.contentMatchAt(0);
    let start2 = match2.fillBefore(fragment).append(fragment);
    fragment = start2.append(match2.matchFragment(start2).fillBefore(Fragment2.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node3) {
  if (!node3.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point3 = insertPoint(tr2.doc, from2, node3.type);
    if (point3 != null)
      from2 = to = point3;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment2.from(node3), 0, 0));
}
function deleteRange(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i2 = 0; i2 < covered.length; i2++) {
    let depth = covered[i2], last = i2 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start2 = $from.start(d);
    if (start2 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start2 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start2 - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc4) {
    let node3 = doc4.nodeAt(this.pos);
    if (!node3)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name2 in node3.attrs)
      attrs[name2] = node3.attrs[name2];
    attrs[this.attr] = this.value;
    let updated = node3.type.create(attrs, null, node3.marks);
    return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment2.from(updated), 0, node3.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc4) {
    return new _AttrStep(this.pos, this.attr, doc4.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc4) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name2 in doc4.attrs)
      attrs[name2] = doc4.attrs[name2];
    attrs[this.attr] = this.value;
    let updated = doc4.type.create(attrs, doc4.content, doc4.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc4) {
    return new _DocAttrStep(this.attr, doc4.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc4) {
    this.doc = doc4;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc4) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc4;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content3) {
    return this.replace(from2, to, new Slice(Fragment2.from(content3), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content3) {
    return this.replaceWith(pos, pos, content3);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node3) {
    replaceRangeWith(this, from2, to, node3);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark)) {
      let node3 = this.doc.nodeAt(pos);
      if (!node3)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node3.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match2) {
    clearIncompatible(this, pos, parentType, match2);
    return this;
  }
};

// node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++)
      if (ranges[i2].$from.pos != ranges[i2].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content3 = Slice.empty) {
    let lastNode = content3.content.lastChild, lastParent = null;
    for (let i2 = 0; i2 < content3.openEnd; i2++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content3);
      if (i2 == 0)
        selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node3) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i2) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node3);
        selectionToInsertionEnd(tr2, mapFrom, node3.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc4) {
    return findSelectionIn(doc4, doc4, 0, 0, 1) || new AllSelection(doc4);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc4) {
    return findSelectionIn(doc4, doc4, doc4.content.size, doc4.childCount, -1) || new AllSelection(doc4);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc4, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc4, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc4, mapping) {
    let $head = doc4.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc4.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content3 = Slice.empty) {
    super.replace(tr2, content3);
    if (content3 == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc4, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc4.resolve(json.anchor), doc4.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc4, anchor, head = anchor) {
    let $anchor = doc4.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc4.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc4) {
    return TextSelection.between(doc4.resolve(this.anchor), doc4.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node3 = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node3.nodeSize);
    super($pos, $end);
    this.node = node3;
  }
  map(doc4, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc4.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment2.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc4, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc4.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc4, from2) {
    return new _NodeSelection(doc4.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node3) {
    return !node3.isText && node3.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc4) {
    let $pos = doc4.resolve(this.anchor), node3 = $pos.nodeAfter;
    if (node3 && NodeSelection.isSelectable(node3))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc4) {
    super(doc4.resolve(0), doc4.resolve(doc4.content.size));
  }
  replace(tr2, content3 = Slice.empty) {
    if (content3 == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content3);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc4) {
    return new _AllSelection(doc4);
  }
  map(doc4) {
    return new _AllSelection(doc4);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc4) {
    return new AllSelection(doc4);
  }
};
function findSelectionIn(doc4, node3, pos, index4, dir, text7 = false) {
  if (node3.inlineContent)
    return TextSelection.create(doc4, pos);
  for (let i2 = index4 - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node3.childCount : i2 >= 0; i2 += dir) {
    let child = node3.child(i2);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc4, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text7);
      if (inner)
        return inner;
    } else if (!text7 && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc4, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last = tr2.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map6 = tr2.mapping.maps[last], end;
  map6.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction = class extends Transform {
  /**
  @internal
  */
  constructor(state2) {
    super(state2.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state2.selection;
    this.storedMarks = state2.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc4) {
    super.addStep(step, doc4);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node3, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node3 = node3.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node3);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text7, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text7)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text7), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text7)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text7, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key3, value) {
    this.meta[typeof key3 == "string" ? key3 : key3.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key3) {
    return this.meta[typeof key3 == "string" ? key3 : key3.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
var FieldDesc = class {
  constructor(name2, desc, self2) {
    this.name = name2;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config3) {
      return config3.doc || config3.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config3, instance) {
      return config3.selection || Selection.atStart(instance.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config3) {
      return config3.storedMarks || null;
    },
    apply(tr2, _marks, _old, state2) {
      return state2.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin4) => {
        if (this.pluginsByKey[plugin4.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin4.key + ")");
        this.plugins.push(plugin4);
        this.pluginsByKey[plugin4.key] = plugin4;
        if (plugin4.spec.state)
          this.fields.push(new FieldDesc(plugin4.key, plugin4.spec.state, plugin4));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config3) {
    this.config = config3;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i2 = 0; i2 < this.config.plugins.length; i2++)
      if (i2 != ignore) {
        let plugin4 = this.config.plugins[i2];
        if (plugin4.spec.filterTransaction && !plugin4.spec.filterTransaction.call(plugin4, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i2 = 0; i2 < this.config.plugins.length; i2++) {
        let plugin4 = this.config.plugins[i2];
        if (plugin4.spec.appendTransaction) {
          let n2 = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
          let tr2 = n2 < trs.length && plugin4.spec.appendTransaction.call(plugin4, n2 ? trs.slice(n2) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i2)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i2] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i2 = 0; i2 < fields.length; i2++) {
      let field = fields[i2];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config3) {
    let $config = new Configuration(config3.doc ? config3.doc.type.schema : config3.schema, config3.plugins);
    let instance = new _EditorState($config);
    for (let i2 = 0; i2 < $config.fields.length; i2++)
      instance[$config.fields[i2].name] = $config.fields[i2].init(config3, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config3) {
    let $config = new Configuration(this.schema, config3.plugins);
    let fields = $config.fields, instance = new _EditorState($config);
    for (let i2 = 0; i2 < fields.length; i2++) {
      let name2 = fields[i2].name;
      instance[name2] = this.hasOwnProperty(name2) ? this[name2] : fields[i2].init(config3, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin4 = pluginFields[prop], state2 = plugin4.spec.state;
        if (state2 && state2.toJSON)
          result[prop] = state2.toJSON.call(plugin4, this[plugin4.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config3, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config3.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config3.schema, config3.plugins);
    let instance = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node4.fromJSON(config3.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config3.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin4 = pluginFields[prop], state2 = plugin4.spec.state;
            if (plugin4.key == field.name && state2 && state2.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state2.fromJSON.call(plugin4, config3, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config3, instance);
      }
    });
    return instance;
  }
};
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state2) {
    return state2[this.key];
  }
};
var keys2 = /* @__PURE__ */ Object.create(null);
function createKey(name2) {
  if (name2 in keys2)
    return name2 + "$" + ++keys2[name2];
  keys2[name2] = 0;
  return name2 + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name2 = "key") {
    this.key = createKey(name2);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state2) {
    return state2.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state2) {
    return state2[this.key];
  }
};

// node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state2, dispatch) => {
  if (state2.selection.empty)
    return false;
  if (dispatch)
    dispatch(state2.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state2, view) {
  let { $cursor } = state2.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state2) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state2, dispatch, view) => {
  let $cursor = atBlockStart(state2, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state2.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state2, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    let delStep = replaceStep(state2.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state2.tr.step(delStep);
        tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state2.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
function textblockAt(node3, side, only = false) {
  for (let scan = node3; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state2, dispatch, view) => {
  let { $head, empty: empty5 } = state2.selection, $cut = $head;
  if (!empty5)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state2) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node3 = $cut && $cut.nodeBefore;
  if (!node3 || !NodeSelection.isSelectable(node3))
    return false;
  if (dispatch)
    dispatch(state2.tr.setSelection(NodeSelection.create(state2.doc, $cut.pos - node3.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
      if ($pos.index(i2) > 0)
        return $pos.doc.resolve($pos.before(i2 + 1));
      if ($pos.node(i2).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state2, view) {
  let { $cursor } = state2.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state2) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state2, dispatch, view) => {
  let $cursor = atBlockEnd(state2, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state2, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state2.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state2.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state2.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state2, dispatch, view) => {
  let { $head, empty: empty5 } = state2.selection, $cut = $head;
  if (!empty5)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state2) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node3 = $cut && $cut.nodeAfter;
  if (!node3 || !NodeSelection.isSelectable(node3))
    return false;
  if (dispatch)
    dispatch(state2.tr.setSelection(NodeSelection.create(state2.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
      let parent = $pos.node(i2);
      if ($pos.index(i2) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i2 + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state2, dispatch) => {
  let sel = state2.selection, nodeSel = sel instanceof NodeSelection, point3;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state2.doc, sel.from))
      return false;
    point3 = sel.from;
  } else {
    point3 = joinPoint(state2.doc, sel.from, -1);
    if (point3 == null)
      return false;
  }
  if (dispatch) {
    let tr2 = state2.tr.join(point3);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point3 - state2.doc.resolve(point3).nodeBefore.nodeSize));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var joinDown = (state2, dispatch) => {
  let sel = state2.selection, point3;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state2.doc, sel.to))
      return false;
    point3 = sel.to;
  } else {
    point3 = joinPoint(state2.doc, sel.to, 1);
    if (point3 == null)
      return false;
  }
  if (dispatch)
    dispatch(state2.tr.join(point3).scrollIntoView());
  return true;
};
var newlineInCode = (state2, dispatch) => {
  let { $head, $anchor } = state2.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state2.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match2) {
  for (let i2 = 0; i2 < match2.edgeCount; i2++) {
    let { type } = match2.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state2, dispatch) => {
  let { $head, $anchor } = state2.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr2 = state2.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state2, dispatch) => {
  let sel = state2.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state2.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state2, dispatch) => {
  let { $cursor } = state2.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state2.doc, before)) {
      if (dispatch)
        dispatch(state2.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state2.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state2, dispatch) => {
    let { $from, $to } = state2.selection;
    if (state2.selection instanceof NodeSelection && state2.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state2.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state2.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.parent.isBlock)
      return false;
    if (dispatch) {
      let atEnd = $to.parentOffset == $to.parent.content.size;
      let tr2 = state2.tr;
      if (state2.selection instanceof TextSelection || state2.selection instanceof AllSelection)
        tr2.deleteSelection();
      let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let splitType = splitNode && splitNode($to.parent, atEnd);
      let types4 = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
      let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types4);
      if (!types4 && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        if (deflt)
          types4 = [{ type: deflt }];
        can = true;
      }
      if (can) {
        tr2.split(tr2.mapping.map($from.pos), 1, types4);
        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
          let first = tr2.mapping.map($from.before()), $first = tr2.doc.resolve(first);
          if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
            tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectAll = (state2, dispatch) => {
  if (dispatch)
    dispatch(state2.tr.setSelection(new AllSelection(state2.doc)));
  return true;
};
function joinMaybeClear(state2, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index4 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index4 - 1, index4)) {
    if (dispatch)
      dispatch(state2.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index4, index4 + 1) || !(after.isTextblock || canJoin(state2.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state2.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state2, $cut, dispatch) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match2;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state2, $cut, dispatch))
    return true;
  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match2 = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match2.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment2.empty;
      for (let i2 = conn.length - 1; i2 >= 0; i2--)
        wrap2 = Fragment2.from(conn[i2].create(null, wrap2));
      wrap2 = Fragment2.from(before.copy(wrap2));
      let tr2 = state2.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let joinAt = end + 2 * conn.length;
      if (canJoin(tr2.doc, joinAt))
        tr2.join(joinAt);
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state2.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at2 = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at2);
      if (at2.isTextblock)
        break;
      at2 = at2.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
      if (dispatch) {
        let end = Fragment2.empty;
        for (let i2 = wrap2.length - 1; i2 >= 0; i2--)
          end = Fragment2.from(wrap2[i2].copy(end));
        let tr2 = state2.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state2, dispatch) {
    let sel = state2.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state2.tr.setSelection(TextSelection.create(state2.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state2, dispatch) {
    let { $from, $to } = state2.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state2.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state2, dispatch) {
    let applicable = false;
    for (let i2 = 0; i2 < state2.selection.ranges.length && !applicable; i2++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state2.selection.ranges[i2];
      state2.doc.nodesBetween(from2, to, (node3, pos) => {
        if (applicable)
          return false;
        if (!node3.isTextblock || node3.hasMarkup(nodeType, attrs))
          return;
        if (node3.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state2.doc.resolve(pos), index4 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index4, index4 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr2 = state2.tr;
      for (let i2 = 0; i2 < state2.selection.ranges.length; i2++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state2.selection.ranges[i2];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
function markApplies(doc4, ranges, type) {
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let { $from, $to } = ranges[i2];
    let can = $from.depth == 0 ? doc4.inlineContent && doc4.type.allowsMarkType(type) : false;
    doc4.nodesBetween($from.pos, $to.pos, (node3) => {
      if (can)
        return false;
      can = node3.inlineContent && node3.type.allowsMarkType(type);
    });
    if (can)
      return true;
  }
  return false;
}
function toggleMark(markType, attrs = null) {
  return function(state2, dispatch) {
    let { empty: empty5, $cursor, ranges } = state2.selection;
    if (empty5 && !$cursor || !markApplies(state2.doc, ranges, markType))
      return false;
    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state2.storedMarks || $cursor.marks()))
          dispatch(state2.tr.removeStoredMark(markType));
        else
          dispatch(state2.tr.addStoredMark(markType.create(attrs)));
      } else {
        let has = false, tr2 = state2.tr;
        for (let i2 = 0; !has && i2 < ranges.length; i2++) {
          let { $from, $to } = ranges[i2];
          has = state2.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (let i2 = 0; i2 < ranges.length; i2++) {
          let { $from, $to } = ranges[i2];
          if (has) {
            tr2.removeMark($from.pos, $to.pos, markType);
          } else {
            let from2 = $from.pos, to = $to.pos, start2 = $from.nodeAfter, end = $to.nodeBefore;
            let spaceStart = start2 && start2.isText ? /^\s*/.exec(start2.text)[0].length : 0;
            let spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
            if (from2 + spaceStart < to) {
              from2 += spaceStart;
              to -= spaceEnd;
            }
            tr2.addMark(from2, to, markType.create(attrs));
          }
        }
        dispatch(tr2.scrollIntoView());
      }
    }
    return true;
  };
}
function chainCommands(...commands) {
  return function(state2, dispatch, view) {
    for (let i2 = 0; i2 < commands.length; i2++)
      if (commands[i2](state2, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del2 = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del2,
  "Mod-Delete": del2,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key3 in pcBaseKeymap)
  macBaseKeymap[key3] = pcBaseKeymap[key3];
var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// node_modules/@react-stately/list/dist/ListCollection.mjs
var $a02d57049d202695$export$d085fb9e920b5ca7 = class {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key3) {
    let node3 = this.keyMap.get(key3);
    return node3 ? node3.prevKey : null;
  }
  getKeyAfter(key3) {
    let node3 = this.keyMap.get(key3);
    return node3 ? node3.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key3) {
    return this.keyMap.get(key3);
  }
  at(idx) {
    const keys3 = [
      ...this.getKeys()
    ];
    return this.getItem(keys3[idx]);
  }
  getChildren(key3) {
    let node3 = this.keyMap.get(key3);
    return (node3 === null || node3 === void 0 ? void 0 : node3.childNodes) || [];
  }
  constructor(nodes) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.iterable = nodes;
    let visit3 = (node3) => {
      this.keyMap.set(node3.key, node3);
      if (node3.childNodes && node3.type === "section") for (let child of node3.childNodes) visit3(child);
    };
    for (let node3 of nodes) visit3(node3);
    let last;
    let index4 = 0;
    for (let [key3, node3] of this.keyMap) {
      if (last) {
        last.nextKey = key3;
        node3.prevKey = last.key;
      } else {
        this.firstKey = key3;
        node3.prevKey = void 0;
      }
      if (node3.type === "item") node3.index = index4++;
      last = node3;
      last.nextKey = void 0;
    }
    this.lastKey = last === null || last === void 0 ? void 0 : last.key;
  }
};

// node_modules/@react-stately/selection/dist/Selection.mjs
var $e40ea825a81a3709$export$52baac22726c72bf = class _$e40ea825a81a3709$export$52baac22726c72bf extends Set {
  constructor(keys3, anchorKey, currentKey) {
    super(keys3);
    if (keys3 instanceof _$e40ea825a81a3709$export$52baac22726c72bf) {
      this.anchorKey = anchorKey || keys3.anchorKey;
      this.currentKey = currentKey || keys3.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
};

// node_modules/@react-stately/selection/dist/useMultipleSelectionState.mjs
var import_react13 = __toESM(require_react(), 1);
function $7af3f5b51489e0b5$var$equalSets(setA, setB) {
  if (setA.size !== setB.size) return false;
  for (let item2 of setA) {
    if (!setB.has(item2)) return false;
  }
  return true;
}
function $7af3f5b51489e0b5$export$253fe78d46329472(props) {
  let { selectionMode = "none", disallowEmptySelection, allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = "toggle", disabledBehavior = "all" } = props;
  let isFocusedRef = (0, import_react13.useRef)(false);
  let [, setFocused] = (0, import_react13.useState)(false);
  let focusedKeyRef = (0, import_react13.useRef)(null);
  let childFocusStrategyRef = (0, import_react13.useRef)(null);
  let [, setFocusedKey] = (0, import_react13.useState)(null);
  let selectedKeysProp = (0, import_react13.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [
    props.selectedKeys
  ]);
  let defaultSelectedKeys = (0, import_react13.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [
    props.defaultSelectedKeys
  ]);
  let [selectedKeys, setSelectedKeys] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);
  let disabledKeysProp = (0, import_react13.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let [selectionBehavior, setSelectionBehavior] = (0, import_react13.useState)(selectionBehaviorProp);
  if (selectionBehaviorProp === "replace" && selectionBehavior === "toggle" && typeof selectedKeys === "object" && selectedKeys.size === 0) setSelectionBehavior("replace");
  let lastSelectionBehavior = (0, import_react13.useRef)(selectionBehaviorProp);
  (0, import_react13.useEffect)(() => {
    if (selectionBehaviorProp !== lastSelectionBehavior.current) {
      setSelectionBehavior(selectionBehaviorProp);
      lastSelectionBehavior.current = selectionBehaviorProp;
    }
  }, [
    selectionBehaviorProp
  ]);
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    get isFocused() {
      return isFocusedRef.current;
    },
    setFocused(f) {
      isFocusedRef.current = f;
      setFocused(f);
    },
    get focusedKey() {
      return focusedKeyRef.current;
    },
    get childFocusStrategy() {
      return childFocusStrategyRef.current;
    },
    setFocusedKey(k, childFocusStrategy = "first") {
      focusedKeyRef.current = k;
      childFocusStrategyRef.current = childFocusStrategy;
      setFocusedKey(k);
    },
    selectedKeys,
    setSelectedKeys(keys3) {
      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys3, selectedKeys)) setSelectedKeys(keys3);
    },
    disabledKeys: disabledKeysProp,
    disabledBehavior
  };
}
function $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {
  if (!selection) return defaultValue;
  return selection === "all" ? "all" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);
}

// node_modules/@react-stately/selection/dist/SelectionManager.mjs
var $d496c0a20b6e58ec$export$6c8a5aaad13c9852 = class {
  /**
  * The type of selection that is allowed in the collection.
  */
  get selectionMode() {
    return this.state.selectionMode;
  }
  /**
  * Whether the collection allows empty selection.
  */
  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  /**
  * The selection behavior for the collection.
  */
  get selectionBehavior() {
    return this.state.selectionBehavior;
  }
  /**
  * Sets the selection behavior for the collection.
  */
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }
  /**
  * Whether the collection is currently focused.
  */
  get isFocused() {
    return this.state.isFocused;
  }
  /**
  * Sets whether the collection is focused.
  */
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  /**
  * The current focused key in the collection.
  */
  get focusedKey() {
    return this.state.focusedKey;
  }
  /** Whether the first or last child of the focused key should receive focus. */
  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  /**
  * Sets the focused key.
  */
  setFocusedKey(key3, childFocusStrategy) {
    if (key3 == null || this.collection.getItem(key3)) this.state.setFocusedKey(key3, childFocusStrategy);
  }
  /**
  * The currently selected keys in the collection.
  */
  get selectedKeys() {
    return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  /**
  * The raw selection value for the collection.
  * Either 'all' for select all, or a set of keys.
  */
  get rawSelection() {
    return this.state.selectedKeys;
  }
  /**
  * Returns whether a key is selected.
  */
  isSelected(key3) {
    if (this.state.selectionMode === "none") return false;
    key3 = this.getKey(key3);
    return this.state.selectedKeys === "all" ? this.canSelectItem(key3) : this.state.selectedKeys.has(key3);
  }
  /**
  * Whether the selection is empty.
  */
  get isEmpty() {
    return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
  }
  /**
  * Whether all items in the collection are selected.
  */
  get isSelectAll() {
    if (this.isEmpty) return false;
    if (this.state.selectedKeys === "all") return true;
    if (this._isSelectAll != null) return this._isSelectAll;
    let allKeys = this.getSelectAllKeys();
    let selectedKeys = this.state.selectedKeys;
    this._isSelectAll = allKeys.every((k) => selectedKeys.has(k));
    return this._isSelectAll;
  }
  get firstSelectedKey() {
    let first = null;
    for (let key3 of this.state.selectedKeys) {
      let item2 = this.collection.getItem(key3);
      if (!first || item2 && (0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, item2, first) < 0) first = item2;
    }
    return first === null || first === void 0 ? void 0 : first.key;
  }
  get lastSelectedKey() {
    let last = null;
    for (let key3 of this.state.selectedKeys) {
      let item2 = this.collection.getItem(key3);
      if (!last || item2 && (0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, item2, last) > 0) last = item2;
    }
    return last === null || last === void 0 ? void 0 : last.key;
  }
  get disabledKeys() {
    return this.state.disabledKeys;
  }
  get disabledBehavior() {
    return this.state.disabledBehavior;
  }
  /**
  * Extends the selection to the given key.
  */
  extendSelection(toKey) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single") {
      this.replaceSelection(toKey);
      return;
    }
    toKey = this.getKey(toKey);
    let selection;
    if (this.state.selectedKeys === "all") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([
      toKey
    ], toKey, toKey);
    else {
      let selectedKeys = this.state.selectedKeys;
      let anchorKey = selectedKeys.anchorKey || toKey;
      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);
      for (let key3 of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) selection.delete(key3);
      for (let key3 of this.getKeyRange(toKey, anchorKey)) if (this.canSelectItem(key3)) selection.add(key3);
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from2, to) {
    let fromItem = this.collection.getItem(from2);
    let toItem = this.collection.getItem(to);
    if (fromItem && toItem) {
      if ((0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from2, to);
      return this.getKeyRangeInternal(to, from2);
    }
    return [];
  }
  getKeyRangeInternal(from2, to) {
    let keys3 = [];
    let key3 = from2;
    while (key3) {
      let item2 = this.collection.getItem(key3);
      if (item2 && item2.type === "item" || item2.type === "cell" && this.allowsCellSelection) keys3.push(key3);
      if (key3 === to) return keys3;
      key3 = this.collection.getKeyAfter(key3);
    }
    return [];
  }
  getKey(key3) {
    let item2 = this.collection.getItem(key3);
    if (!item2)
      return key3;
    if (item2.type === "cell" && this.allowsCellSelection) return key3;
    while (item2.type !== "item" && item2.parentKey != null) item2 = this.collection.getItem(item2.parentKey);
    if (!item2 || item2.type !== "item") return null;
    return item2.key;
  }
  /**
  * Toggles whether the given key is selected.
  */
  toggleSelection(key3) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single" && !this.isSelected(key3)) {
      this.replaceSelection(key3);
      return;
    }
    key3 = this.getKey(key3);
    if (key3 == null) return;
    let keys3 = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
    if (keys3.has(key3)) keys3.delete(key3);
    else if (this.canSelectItem(key3)) {
      keys3.add(key3);
      keys3.anchorKey = key3;
      keys3.currentKey = key3;
    }
    if (this.disallowEmptySelection && keys3.size === 0) return;
    this.state.setSelectedKeys(keys3);
  }
  /**
  * Replaces the selection with only the given key.
  */
  replaceSelection(key3) {
    if (this.selectionMode === "none") return;
    key3 = this.getKey(key3);
    if (key3 == null) return;
    let selection = this.canSelectItem(key3) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([
      key3
    ], key3, key3) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();
    this.state.setSelectedKeys(selection);
  }
  /**
  * Replaces the selection with the given keys.
  */
  setSelectedKeys(keys3) {
    if (this.selectionMode === "none") return;
    let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();
    for (let key3 of keys3) {
      key3 = this.getKey(key3);
      if (key3 != null) {
        selection.add(key3);
        if (this.selectionMode === "single") break;
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getSelectAllKeys() {
    let keys3 = [];
    let addKeys = (key3) => {
      while (key3) {
        if (this.canSelectItem(key3)) {
          let item2 = this.collection.getItem(key3);
          if (item2.type === "item") keys3.push(key3);
          if (item2.hasChildNodes && (this.allowsCellSelection || item2.type !== "item")) addKeys((0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection)).key);
        }
        key3 = this.collection.getKeyAfter(key3);
      }
    };
    addKeys(this.collection.getFirstKey());
    return keys3;
  }
  /**
  * Selects all items in the collection.
  */
  selectAll() {
    if (!this.isSelectAll && this.selectionMode === "multiple") this.state.setSelectedKeys("all");
  }
  /**
  * Removes all keys from the selection.
  */
  clearSelection() {
    if (!this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());
  }
  /**
  * Toggles between select all and an empty selection.
  */
  toggleSelectAll() {
    if (this.isSelectAll) this.clearSelection();
    else this.selectAll();
  }
  select(key3, e3) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single") {
      if (this.isSelected(key3) && !this.disallowEmptySelection) this.toggleSelection(key3);
      else this.replaceSelection(key3);
    } else if (this.selectionBehavior === "toggle" || e3 && (e3.pointerType === "touch" || e3.pointerType === "virtual"))
      this.toggleSelection(key3);
    else this.replaceSelection(key3);
  }
  /**
  * Returns whether the current selection is equal to the given selection.
  */
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys) return true;
    let selectedKeys = this.selectedKeys;
    if (selection.size !== selectedKeys.size) return false;
    for (let key3 of selection) {
      if (!selectedKeys.has(key3)) return false;
    }
    for (let key3 of selectedKeys) {
      if (!selection.has(key3)) return false;
    }
    return true;
  }
  canSelectItem(key3) {
    var _item_props;
    if (this.state.selectionMode === "none" || this.state.disabledKeys.has(key3)) return false;
    let item2 = this.collection.getItem(key3);
    if (!item2 || (item2 === null || item2 === void 0 ? void 0 : (_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || item2.type === "cell" && !this.allowsCellSelection) return false;
    return true;
  }
  isDisabled(key3) {
    var _this_collection_getItem_props, _this_collection_getItem;
    return this.state.disabledBehavior === "all" && (this.state.disabledKeys.has(key3) || !!((_this_collection_getItem = this.collection.getItem(key3)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.isDisabled));
  }
  isLink(key3) {
    var _this_collection_getItem_props, _this_collection_getItem;
    return !!((_this_collection_getItem = this.collection.getItem(key3)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);
  }
  getItemProps(key3) {
    var _this_collection_getItem;
    return (_this_collection_getItem = this.collection.getItem(key3)) === null || _this_collection_getItem === void 0 ? void 0 : _this_collection_getItem.props;
  }
  constructor(collection2, state2, options) {
    this.collection = collection2;
    this.state = state2;
    var _options_allowsCellSelection;
    this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;
    this._isSelectAll = null;
  }
};

// node_modules/@react-stately/list/dist/useListState.mjs
var import_react14 = __toESM(require_react(), 1);
function $e72dd72e1c76a225$export$2f645645f7bca764(props) {
  let { filter: filter2 } = props;
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react14.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let factory = (0, import_react14.useCallback)((nodes) => filter2 ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter2(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [
    filter2
  ]);
  let context = (0, import_react14.useMemo)(() => ({
    suppressTextValueWarning: props.suppressTextValueWarning
  }), [
    props.suppressTextValueWarning
  ]);
  let collection2 = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, factory, context);
  let selectionManager = (0, import_react14.useMemo)(() => new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(collection2, selectionState), [
    collection2,
    selectionState
  ]);
  const cachedCollection = (0, import_react14.useRef)(null);
  (0, import_react14.useEffect)(() => {
    if (selectionState.focusedKey != null && !collection2.getItem(selectionState.focusedKey)) {
      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);
      const cachedItemNodes = [
        ...cachedCollection.current.getKeys()
      ].map((key3) => {
        const itemNode = cachedCollection.current.getItem(key3);
        return itemNode.type === "item" ? itemNode : null;
      }).filter((node3) => node3 !== null);
      const itemNodes = [
        ...collection2.getKeys()
      ].map((key3) => {
        const itemNode = collection2.getItem(key3);
        return itemNode.type === "item" ? itemNode : null;
      }).filter((node3) => node3 !== null);
      const diff = cachedItemNodes.length - itemNodes.length;
      let index4 = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);
      let newNode;
      while (index4 >= 0) {
        if (!selectionManager.isDisabled(itemNodes[index4].key)) {
          newNode = itemNodes[index4];
          break;
        }
        if (index4 < itemNodes.length - 1) index4++;
        else {
          if (index4 > startItem.index) index4 = startItem.index;
          index4--;
        }
      }
      selectionState.setFocusedKey(newNode ? newNode.key : null);
    }
    cachedCollection.current = collection2;
  }, [
    collection2,
    selectionManager,
    selectionState,
    selectionState.focusedKey
  ]);
  return {
    collection: collection2,
    disabledKeys,
    selectionManager
  };
}

// node_modules/@react-stately/list/dist/useSingleSelectListState.mjs
var import_react15 = __toESM(require_react(), 1);
function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {
  var _props_defaultSelectedKey;
  let [selectedKey, setSelectedKey] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);
  let selectedKeys = (0, import_react15.useMemo)(() => selectedKey != null ? [
    selectedKey
  ] : [], [
    selectedKey
  ]);
  let { collection: collection2, disabledKeys, selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({
    ...props,
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: (keys3) => {
      var _keys_values_next_value;
      let key3 = (_keys_values_next_value = keys3.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;
      if (key3 === selectedKey && props.onSelectionChange) props.onSelectionChange(key3);
      setSelectedKey(key3);
    }
  });
  let selectedItem = selectedKey != null ? collection2.getItem(selectedKey) : null;
  return {
    collection: collection2,
    disabledKeys,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-listbox.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react21 = __toESM(require_react());

// node_modules/@react-aria/listbox/dist/utils.mjs
var $b1f0cad8af73213b$export$3585ede4d035bf14 = /* @__PURE__ */ new WeakMap();
function $b1f0cad8af73213b$var$normalizeKey(key3) {
  if (typeof key3 === "string") return key3.replace(/\s*/g, "");
  return "" + key3;
}
function $b1f0cad8af73213b$export$9145995848b05025(state2, itemKey) {
  let data2 = $b1f0cad8af73213b$export$3585ede4d035bf14.get(state2);
  if (!data2) throw new Error("Unknown list");
  return `${data2.id}-option-${$b1f0cad8af73213b$var$normalizeKey(itemKey)}`;
}

// node_modules/@react-aria/listbox/dist/useListBox.mjs
function $c132121280ec012d$export$50eacbbf140a3141(props, state2, ref2) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let selectionBehavior = props.selectionBehavior || "toggle";
  let linkBehavior = props.linkBehavior || (selectionBehavior === "replace" ? "action" : "override");
  if (selectionBehavior === "toggle" && linkBehavior === "action")
    linkBehavior = "override";
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    ...props,
    ref: ref2,
    selectionManager: state2.selectionManager,
    collection: state2.collection,
    disabledKeys: state2.disabledKeys,
    linkBehavior
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onFocusWithin: props.onFocus,
    onBlurWithin: props.onBlur,
    onFocusWithinChange: props.onFocusChange
  });
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $b1f0cad8af73213b$export$3585ede4d035bf14).set(state2, {
    id,
    shouldUseVirtualFocus: props.shouldUseVirtualFocus,
    shouldSelectOnPressUp: props.shouldSelectOnPressUp,
    shouldFocusOnHover: props.shouldFocusOnHover,
    isVirtualized: props.isVirtualized,
    onAction: props.onAction,
    linkBehavior
  });
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)({
    ...props,
    id,
    // listbox is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span"
  });
  return {
    labelProps,
    listBoxProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, focusWithinProps, state2.selectionManager.selectionMode === "multiple" ? {
      "aria-multiselectable": "true"
    } : {}, {
      role: "listbox",
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(fieldProps, listProps)
    })
  };
}

// node_modules/@react-aria/listbox/dist/useOption.mjs
function $293f70390ea03370$export$497855f14858aa34(props, state2, ref2) {
  var _item_props, _item_props1;
  let { key: key3 } = props;
  let data2 = (0, $b1f0cad8af73213b$export$3585ede4d035bf14).get(state2);
  var _props_isDisabled;
  let isDisabled = (_props_isDisabled = props.isDisabled) !== null && _props_isDisabled !== void 0 ? _props_isDisabled : state2.selectionManager.isDisabled(key3);
  var _props_isSelected;
  let isSelected = (_props_isSelected = props.isSelected) !== null && _props_isSelected !== void 0 ? _props_isSelected : state2.selectionManager.isSelected(key3);
  var _props_shouldSelectOnPressUp;
  let shouldSelectOnPressUp = (_props_shouldSelectOnPressUp = props.shouldSelectOnPressUp) !== null && _props_shouldSelectOnPressUp !== void 0 ? _props_shouldSelectOnPressUp : data2 === null || data2 === void 0 ? void 0 : data2.shouldSelectOnPressUp;
  var _props_shouldFocusOnHover;
  let shouldFocusOnHover = (_props_shouldFocusOnHover = props.shouldFocusOnHover) !== null && _props_shouldFocusOnHover !== void 0 ? _props_shouldFocusOnHover : data2 === null || data2 === void 0 ? void 0 : data2.shouldFocusOnHover;
  var _props_shouldUseVirtualFocus;
  let shouldUseVirtualFocus = (_props_shouldUseVirtualFocus = props.shouldUseVirtualFocus) !== null && _props_shouldUseVirtualFocus !== void 0 ? _props_shouldUseVirtualFocus : data2 === null || data2 === void 0 ? void 0 : data2.shouldUseVirtualFocus;
  var _props_isVirtualized;
  let isVirtualized = (_props_isVirtualized = props.isVirtualized) !== null && _props_isVirtualized !== void 0 ? _props_isVirtualized : data2 === null || data2 === void 0 ? void 0 : data2.isVirtualized;
  let labelId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let optionProps = {
    role: "option",
    "aria-disabled": isDisabled || void 0,
    "aria-selected": state2.selectionManager.selectionMode !== "none" ? isSelected : void 0
  };
  if (!((0, $c87311424ea30a05$export$9ac100e40613ea10)() && (0, $c87311424ea30a05$export$78551043582a6a98)())) {
    optionProps["aria-label"] = props["aria-label"];
    optionProps["aria-labelledby"] = labelId;
    optionProps["aria-describedby"] = descriptionId;
  }
  let item2 = state2.collection.getItem(key3);
  if (isVirtualized) {
    let index4 = Number(item2 === null || item2 === void 0 ? void 0 : item2.index);
    optionProps["aria-posinset"] = Number.isNaN(index4) ? void 0 : index4 + 1;
    optionProps["aria-setsize"] = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state2.collection);
  }
  let onAction = (data2 === null || data2 === void 0 ? void 0 : data2.onAction) ? () => {
    var _data_onAction;
    return data2 === null || data2 === void 0 ? void 0 : (_data_onAction = data2.onAction) === null || _data_onAction === void 0 ? void 0 : _data_onAction.call(data2, key3);
  } : void 0;
  let { itemProps, isPressed, isFocused, hasAction, allowsSelection } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state2.selectionManager,
    key: key3,
    ref: ref2,
    shouldSelectOnPressUp,
    allowsDifferentPressOrigin: shouldSelectOnPressUp && shouldFocusOnHover,
    isVirtualized,
    shouldUseVirtualFocus,
    isDisabled,
    onAction: onAction || (item2 === null || item2 === void 0 ? void 0 : (_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.onAction) ? (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(item2 === null || item2 === void 0 ? void 0 : (_item_props1 = item2.props) === null || _item_props1 === void 0 ? void 0 : _item_props1.onAction, onAction) : void 0,
    linkBehavior: data2 === null || data2 === void 0 ? void 0 : data2.linkBehavior
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled: isDisabled || !shouldFocusOnHover,
    onHoverStart() {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()) {
        state2.selectionManager.setFocused(true);
        state2.selectionManager.setFocusedKey(key3);
      }
    }
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(item2 === null || item2 === void 0 ? void 0 : item2.props);
  delete domProps.id;
  let linkProps = (0, $ea8dcbcb9ea1b556$export$7e924b3091a3bd18)(item2 === null || item2 === void 0 ? void 0 : item2.props);
  return {
    optionProps: {
      ...optionProps,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, itemProps, hoverProps, linkProps),
      id: (0, $b1f0cad8af73213b$export$9145995848b05025)(state2, key3)
    },
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    isFocused,
    isFocusVisible: isFocused && (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)(),
    isSelected,
    isDisabled,
    isPressed,
    allowsSelection,
    hasAction
  };
}

// node_modules/@react-aria/listbox/dist/useListBoxSection.mjs
function $af383d3bef1cfdc9$export$c3f9f39876e4bc7(props) {
  let { heading: heading3, "aria-label": ariaLabel } = props;
  let headingId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: heading3 ? {
      // Techincally, listbox cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a visual label for the nested group.
      id: headingId,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": ariaLabel,
      "aria-labelledby": heading3 ? headingId : void 0
    }
  };
}

// node_modules/@react-aria/virtualizer/dist/utils.mjs
var $ce415dc67314b753$var$cachedRTLResult = null;
function $ce415dc67314b753$export$faf7630257ad4304(recalculate = false) {
  if ($ce415dc67314b753$var$cachedRTLResult === null || recalculate) {
    const outerDiv = document.createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = document.createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) $ce415dc67314b753$var$cachedRTLResult = "positive-descending";
    else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) $ce415dc67314b753$var$cachedRTLResult = "negative";
      else $ce415dc67314b753$var$cachedRTLResult = "positive-ascending";
    }
    document.body.removeChild(outerDiv);
    return $ce415dc67314b753$var$cachedRTLResult;
  }
  return $ce415dc67314b753$var$cachedRTLResult;
}
function $ce415dc67314b753$export$1389d168952b34b5(node3, direction) {
  let { scrollLeft } = node3;
  if (direction === "rtl") {
    let { scrollWidth, clientWidth } = node3;
    switch ($ce415dc67314b753$export$faf7630257ad4304()) {
      case "negative":
        scrollLeft = -scrollLeft;
        break;
      case "positive-descending":
        scrollLeft = scrollWidth - clientWidth - scrollLeft;
        break;
    }
  }
  return scrollLeft;
}
function $ce415dc67314b753$export$ed5fd5ffe5ab0ac(node3, direction, scrollLeft) {
  if (direction === "rtl") switch ($ce415dc67314b753$export$faf7630257ad4304()) {
    case "negative":
      scrollLeft = -scrollLeft;
      break;
    case "positive-ascending":
      break;
    default: {
      const { clientWidth, scrollWidth } = node3;
      scrollLeft = scrollWidth - clientWidth - scrollLeft;
      break;
    }
  }
  node3.scrollLeft = scrollLeft;
}

// node_modules/@react-aria/virtualizer/dist/ScrollView.mjs
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_react17 = __toESM(require_react(), 1);

// node_modules/@react-stately/virtualizer/dist/Layout.mjs
var $c74cda7d31af1253$export$c84671f46d6a1ca = class {
  /**
  * Returns whether the layout should invalidate in response to
  * visible rectangle changes. By default, it only invalidates
  * when the collection view's size changes. Return true always
  * to make the layout invalidate while scrolling (e.g. sticky headers).
  */
  shouldInvalidate(newRect, oldRect) {
    return newRect.width !== oldRect.width || newRect.height !== oldRect.height;
  }
  /**
  * This method allows the layout to perform any pre-computation
  * it needs to in order to prepare {@link LayoutInfo}s for retrieval.
  * Called by the collection view before {@link getVisibleLayoutInfos}
  * or {@link getLayoutInfo} are called.
  */
  validate(invalidationContext) {
  }
  /**
  * Returns a {@link DragTarget} describing a view at the given point to be dragged.
  * Return `null` to cancel the drag. The default implementation returns the view at the given point.
  * @param point The point at which the drag occurred.
  */
  // getDragTarget(point: Point): DragTarget | null {
  //   let target = this.virtualizer.keyAtPoint(point);
  //   if (!target) {
  //     return null;
  //   }
  //   return {
  //     type: 'item',
  //     key: target
  //   };
  // }
  /**
  * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`
  * to reject the drop. The dropped items will be inserted before the resulting target.
  * @param point The point at which the drop occurred.
  */
  // getDropTarget(point: Point): DropTarget | null {
  //   return null;
  // }
  /**
  * Returns the starting attributes for an animated insertion.
  * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.
  * The default implementation just returns its input.
  *
  * @param layoutInfo The proposed LayoutInfo for this view.
  */
  getInitialLayoutInfo(layoutInfo) {
    return layoutInfo;
  }
  /**
  * Returns the ending attributes for an animated removal.
  * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}
  * to the one returned by this method. The default implementation returns its input.
  *
  * @param layoutInfo The original LayoutInfo for this view.
  */
  getFinalLayoutInfo(layoutInfo) {
    return layoutInfo;
  }
};

// node_modules/@react-stately/virtualizer/dist/LayoutInfo.mjs
var $d7fd61009c21d0bb$export$7e0eeb9da702a085 = class _$d7fd61009c21d0bb$export$7e0eeb9da702a085 {
  /**
  * Returns a copy of the LayoutInfo.
  */
  copy() {
    let res = new _$d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());
    res.estimatedSize = this.estimatedSize;
    res.opacity = this.opacity;
    res.transform = this.transform;
    res.parentKey = this.parentKey;
    res.isSticky = this.isSticky;
    res.zIndex = this.zIndex;
    res.allowOverflow = this.allowOverflow;
    return res;
  }
  /**
  * @param type A string representing the view type. Should be `'item'` for item views.
                           Other types are used by supplementary views.
  * @param key The unique key for this view.
  * @param rect The rectangle describing the size and position of this view.
  */
  constructor(type, key3, rect) {
    this.type = type;
    this.key = key3;
    this.parentKey = null;
    this.rect = rect;
    this.estimatedSize = false;
    this.isSticky = false;
    this.opacity = 1;
    this.transform = null;
    this.zIndex = 0;
    this.allowOverflow = false;
  }
};

// node_modules/@react-stately/virtualizer/dist/Point.mjs
var $3041db3296945e6e$export$baf26146a414f24a = class _$3041db3296945e6e$export$baf26146a414f24a {
  /**
  * Returns a copy of this point.
  */
  copy() {
    return new _$3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);
  }
  /**
  * Checks if two points are equal.
  */
  equals(point3) {
    return this.x === point3.x && this.y === point3.y;
  }
  /**
  * Returns true if this point is the origin.
  */
  isOrigin() {
    return this.x === 0 && this.y === 0;
  }
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
};

// node_modules/@react-stately/virtualizer/dist/Rect.mjs
var $60423f92c7f9ad87$export$c79fc6492f3af13d = class _$60423f92c7f9ad87$export$c79fc6492f3af13d {
  /**
  * The maximum x-coordinate in the rectangle.
  */
  get maxX() {
    return this.x + this.width;
  }
  /**
  * The maximum y-coordinate in the rectangle.
  */
  get maxY() {
    return this.y + this.height;
  }
  /**
  * The area of the rectangle.
  */
  get area() {
    return this.width * this.height;
  }
  /**
  * The top left corner of the rectangle.
  */
  get topLeft() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);
  }
  /**
  * The top right corner of the rectangle.
  */
  get topRight() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);
  }
  /**
  * The bottom left corner of the rectangle.
  */
  get bottomLeft() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);
  }
  /**
  * The bottom right corner of the rectangle.
  */
  get bottomRight() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);
  }
  /**
  * Returns whether this rectangle intersects another rectangle.
  * @param rect - The rectangle to check.
  */
  intersects(rect) {
    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;
  }
  /**
  * Returns whether this rectangle fully contains another rectangle.
  * @param rect - The rectangle to check.
  */
  containsRect(rect) {
    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;
  }
  /**
  * Returns whether the rectangle contains the given point.
  * @param point - The point to check.
  */
  containsPoint(point3) {
    return this.x <= point3.x && this.y <= point3.y && this.maxX >= point3.x && this.maxY >= point3.y;
  }
  /**
  * Returns the first corner of this rectangle (from top to bottom, left to right)
  * that is contained in the given rectangle, or null of the rectangles do not intersect.
  * @param rect - The rectangle to check.
  */
  getCornerInRect(rect) {
    for (let key3 of [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]) {
      if (rect.containsPoint(this[key3])) return key3;
    }
    return null;
  }
  equals(rect) {
    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
  }
  pointEquals(point3) {
    return this.x === point3.x && this.y === point3.y;
  }
  sizeEquals(size4) {
    return this.width === size4.width && this.height === size4.height;
  }
  /**
  * Returns the union of this Rect and another.
  */
  union(other) {
    let x = Math.min(this.x, other.x);
    let y = Math.min(this.y, other.y);
    let width = Math.max(this.maxX, other.maxX) - x;
    let height = Math.max(this.maxY, other.maxY) - y;
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);
  }
  /**
  * Returns the intersection of this Rect with another.
  * If the rectangles do not intersect, an all zero Rect is returned.
  */
  intersection(other) {
    if (!this.intersects(other)) return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);
    let x = Math.max(this.x, other.x);
    let y = Math.max(this.y, other.y);
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);
  }
  /**
  * Returns a copy of this rectangle.
  */
  copy() {
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);
  }
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
};

// node_modules/@react-stately/virtualizer/dist/Size.mjs
var $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec = class _$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {
  /**
  * Returns a copy of this size.
  */
  copy() {
    return new _$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);
  }
  /**
  * Returns whether this size is equal to another one.
  */
  equals(other) {
    return this.width === other.width && this.height === other.height;
  }
  /**
  * The total area of the Size.
  */
  get area() {
    return this.width * this.height;
  }
  constructor(width = 0, height = 0) {
    this.width = width;
    this.height = height;
  }
};

// node_modules/@react-stately/virtualizer/dist/ReusableView.mjs
var $ad1d98aa8f0c31b4$var$KEY = 0;
var $ad1d98aa8f0c31b4$export$1a5223887c560441 = class {
  /**
  * Prepares the view for reuse. Called just before the view is removed from the DOM.
  */
  prepareForReuse() {
    this.content = null;
    this.rendered = null;
    this.layoutInfo = null;
  }
  constructor(virtualizer) {
    this.virtualizer = virtualizer;
    this.key = ++$ad1d98aa8f0c31b4$var$KEY;
  }
};

// node_modules/@react-stately/virtualizer/dist/tween.mjs
var $3eb131dcf37ad5f8$var$perf = typeof window !== "undefined" ? window.performance : null;
var $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);
var $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
};
var $3eb131dcf37ad5f8$var$fixTs;
function $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {
  let canceled = false;
  let raf_id;
  let promise = new Promise((resolve3) => {
    let start2 = $3eb131dcf37ad5f8$var$getTime();
    let diffX = end.x - begin.x;
    let diffY = end.y - begin.y;
    raf_id = requestAnimationFrame(function run2(t2) {
      if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t2 > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;
      if ($3eb131dcf37ad5f8$var$fixTs) t2 = $3eb131dcf37ad5f8$var$getTime();
      let delta = t2 - start2;
      if (delta > duration) {
        fn(end);
        resolve3();
      } else {
        let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));
        if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run2);
      }
    });
  });
  promise.cancel = function() {
    canceled = true;
    cancelAnimationFrame(raf_id);
  };
  return promise;
}
function $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t2) {
  return Math.sin(t2 * Math.PI / 2);
}

// node_modules/@react-stately/virtualizer/dist/utils.mjs
function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {
  let res = /* @__PURE__ */ new Set();
  for (let key3 of a.keys()) if (!b.has(key3)) res.add(key3);
  return res;
}
function $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {
  let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);
  let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);
  let toUpdate = /* @__PURE__ */ new Set();
  for (let key3 of a.keys()) if (b.has(key3)) toUpdate.add(key3);
  return {
    toRemove,
    toAdd,
    toUpdate
  };
}
function* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {
  for (let iterator of iterators) yield* iterator;
}
function $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {
  if (a === b) return true;
  if (a.size !== b.size) return false;
  for (let key3 of a) {
    if (!b.has(key3)) return false;
  }
  return true;
}

// node_modules/@react-stately/virtualizer/dist/OverscanManager.mjs
var $364191b3decf3697$var$RollingAverage = class {
  addSample(sample) {
    this.count++;
    this.value += (sample - this.value) / this.count;
  }
  constructor() {
    this.count = 0;
    this.value = 0;
  }
};
var $364191b3decf3697$export$4455ee6afb38dcbb = class {
  setVisibleRect(rect) {
    let time = performance.now() - this.startTime;
    if (time < 500) {
      this.averageTime.addSample(time);
      if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;
      if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;
    }
    this.startTime = performance.now();
    this.visibleRect = rect;
  }
  collectMetrics() {
    let time = performance.now() - this.startTime;
    if (time < 500) this.averagePerf.addSample(time);
    if (this.visibleRect.height > 0) {
      let o3 = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));
      this.overscanY.addSample(o3);
    }
    if (this.visibleRect.width > 0) {
      let o3 = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));
      this.overscanX.addSample(o3);
    }
  }
  getOverscannedRect() {
    let overscanned = this.visibleRect.copy();
    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;
    if (this.velocity.y > 0) {
      overscanned.y -= overscanY * 0.2;
      overscanned.height += overscanY + overscanY * 0.2;
    } else {
      overscanned.y -= overscanY;
      overscanned.height += overscanY + overscanY * 0.2;
    }
    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;
    if (this.velocity.x > 0) {
      overscanned.x -= overscanX * 0.2;
      overscanned.width += overscanX + overscanX * 0.2;
    } else {
      overscanned.x -= overscanX;
      overscanned.width += overscanX + overscanX * 0.2;
    }
    return overscanned;
  }
  constructor() {
    this.startTime = 0;
    this.averagePerf = new $364191b3decf3697$var$RollingAverage();
    this.averageTime = new $364191b3decf3697$var$RollingAverage();
    this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);
    this.overscanX = new $364191b3decf3697$var$RollingAverage();
    this.overscanY = new $364191b3decf3697$var$RollingAverage();
    this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
  }
};

// node_modules/@react-stately/virtualizer/dist/Transaction.mjs
var $8e135e531d8dcb66$export$febc5573c75cefb0 = class {
  constructor() {
    this.level = 0;
    this.actions = [];
    this.animated = true;
    this.initialMap = /* @__PURE__ */ new Map();
    this.finalMap = /* @__PURE__ */ new Map();
    this.initialLayoutInfo = /* @__PURE__ */ new Map();
    this.finalLayoutInfo = /* @__PURE__ */ new Map();
    this.removed = /* @__PURE__ */ new Map();
    this.toRemove = /* @__PURE__ */ new Map();
  }
};

// node_modules/@react-stately/virtualizer/dist/Virtualizer.mjs
var $38b9490c1cca8fc4$export$89be5a243e59c4b2 = class {
  _setContentSize(size4) {
    this._contentSize = size4;
    this.delegate.setContentSize(size4);
  }
  _setContentOffset(offset5) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset5.x, offset5.y, this._visibleRect.width, this._visibleRect.height);
    this.delegate.setVisibleRect(rect);
  }
  /**
  * Get the size of the scrollable content.
  */
  get contentSize() {
    return this._contentSize;
  }
  /**
  * Get the collection view's currently visible rectangle.
  */
  get visibleRect() {
    return this._visibleRect;
  }
  /**
  * Set the collection view's currently visible rectangle.
  */
  set visibleRect(rect) {
    this._setVisibleRect(rect);
  }
  _setVisibleRect(rect, forceUpdate = false) {
    let current2 = this._visibleRect;
    if (rect.equals(current2)) return;
    if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);
    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);
    this._resetAnimatedContentOffset();
    this._visibleRect = rect;
    if (shouldInvalidate)
      this.relayoutNow({
        offsetChanged: !rect.pointEquals(current2),
        sizeChanged: !rect.sizeEquals(current2)
      });
    else this.updateSubviews(forceUpdate);
  }
  get collection() {
    return this._collection;
  }
  set collection(data2) {
    this._setData(data2);
  }
  _setData(data2) {
    if (data2 === this._collection) return;
    if (this._collection) this._runTransaction(() => {
      this._collection = data2;
    }, this.transitionDuration > 0);
    else {
      this._collection = data2;
      this.reloadData();
    }
  }
  /**
  * Reloads the data from the data source and relayouts the collection view.
  * Does not animate any changes. Equivalent to re-assigning the same data source
  * to the collection view.
  */
  reloadData() {
    this.relayout({
      contentChanged: true
    });
  }
  /**
  * Returns the item with the given key.
  */
  getItem(key3) {
    return this._collection ? this._collection.getItem(key3) : null;
  }
  /** The set of persisted keys are always present in the DOM, even if not currently in view. */
  get persistedKeys() {
    return this._persistedKeys;
  }
  /** The set of persisted keys are always present in the DOM, even if not currently in view. */
  set persistedKeys(persistedKeys) {
    if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {
      this._persistedKeys = persistedKeys;
      this.updateSubviews();
    }
  }
  /** Returns whether the given key, or an ancestor, is persisted. */
  isPersistedKey(key3) {
    if (this._persistedKeys.has(key3)) return true;
    for (let k of this._persistedKeys) while (k != null) {
      let layoutInfo = this.layout.getLayoutInfo(k);
      if (!layoutInfo) break;
      k = layoutInfo.parentKey;
      if (k === key3) return true;
    }
    return false;
  }
  /**
  * Get the collection view's layout.
  */
  get layout() {
    return this._layout;
  }
  /**
  * Set the collection view's layout.
  */
  set layout(layout) {
    this.setLayout(layout);
  }
  /**
  * Sets the collection view's layout, optionally with an animated transition
  * from the current layout to the new layout.
  * @param layout The layout to switch to.
  * @param animated Whether to animate the layout change.
  */
  setLayout(layout, animated = false) {
    if (layout === this._layout) return;
    let applyLayout = () => {
      if (this._layout)
        this._layout.virtualizer = null;
      layout.virtualizer = this;
      this._layout = layout;
    };
    if (animated)
      this._runTransaction(applyLayout);
    else {
      applyLayout();
      this.relayout();
    }
  }
  _getReuseType(layoutInfo, content3) {
    if (layoutInfo.type === "item" && content3) {
      let type = this.delegate.getType ? this.delegate.getType(content3) : "item";
      let reuseType = type === "item" ? "item" : layoutInfo.type + "_" + type;
      return {
        type,
        reuseType
      };
    }
    return {
      type: layoutInfo.type,
      reuseType: layoutInfo.type
    };
  }
  getReusableView(layoutInfo) {
    let content3 = this.getItem(layoutInfo.key);
    let { reuseType } = this._getReuseType(layoutInfo, content3);
    if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];
    let reusable = this._reusableViews[reuseType];
    let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);
    view.viewType = reuseType;
    if (!this._animatedContentOffset.isOrigin()) {
      layoutInfo = layoutInfo.copy();
      layoutInfo.rect.x += this._animatedContentOffset.x;
      layoutInfo.rect.y += this._animatedContentOffset.y;
    }
    view.layoutInfo = layoutInfo;
    this._renderView(view);
    return view;
  }
  _renderView(reusableView) {
    let { type, key: key3 } = reusableView.layoutInfo;
    reusableView.content = this.getItem(key3);
    reusableView.rendered = this._renderContent(type, reusableView.content);
  }
  _renderContent(type, content3) {
    let cached = this._renderedContent.get(content3);
    if (cached != null) return cached;
    let rendered = this.delegate.renderView(type, content3);
    if (content3) this._renderedContent.set(content3, rendered);
    return rendered;
  }
  /**
  * Returns an array of all currently visible views, including both
  * item views and supplementary views.
  */
  get visibleViews() {
    return Array.from(this._visibleViews.values());
  }
  /**
  * Gets the visible view for the given type and key. Returns null if
  * the view is not currently visible.
  *
  * @param key The key of the view to retrieve.
  */
  getView(key3) {
    return this._visibleViews.get(key3) || null;
  }
  /**
  * Returns an array of visible views matching the given type.
  * @param type The view type to find.
  */
  getViewsOfType(type) {
    return this.visibleViews.filter((v) => v.layoutInfo && v.layoutInfo.type === type);
  }
  /**
  * Returns the key for the given view. Returns null
  * if the view is not currently visible.
  */
  keyForView(view) {
    if (view && view.layoutInfo) return view.layoutInfo.key;
    return null;
  }
  /**
  * Returns the key for the item view currently at the given point.
  */
  keyAtPoint(point3) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point3.x, point3.y, 1, 1);
    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
    for (let layoutInfo of layoutInfos) {
      if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;
    }
    return null;
  }
  /**
  * Cleanup for when the Virtualizer will be unmounted.
  */
  willUnmount() {
    cancelAnimationFrame(this._relayoutRaf);
  }
  /**
  * Triggers a layout invalidation, and updates the visible subviews.
  */
  relayout(context = {}) {
    if (this._scrollAnimation || typeof requestAnimationFrame === "undefined") return;
    if (this._invalidationContext) {
      Object.assign(this._invalidationContext, context);
      return;
    }
    this._invalidationContext = context;
  }
  /**
  * Performs a relayout immediately. Prefer {@link relayout} over this method
  * where possible, since it coalesces multiple layout passes in the same tick.
  */
  relayoutNow(context = this._invalidationContext || {}) {
    if (this._relayoutRaf) {
      cancelAnimationFrame(this._relayoutRaf);
      this._relayoutRaf = null;
      context = {
        ...this._invalidationContext,
        ...context
      };
    }
    this._invalidationContext = null;
    if (!this.layout || !this._collection || this._scrollAnimation) return;
    let scrollAnchor = this._getScrollAnchor();
    if (typeof context.beforeLayout === "function") context.beforeLayout();
    this.layout.validate(context);
    this._setContentSize(this.layout.getContentSize());
    if (typeof context.afterLayout === "function") context.afterLayout();
    let visibleRect = this.getVisibleRect();
    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);
    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;
    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;
    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));
    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));
    let hasLayoutUpdates = false;
    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {
      if (context.animated || !this._animatedContentOffset.isOrigin()) {
        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;
        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;
        hasLayoutUpdates = this.updateSubviews(context.contentChanged);
      } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));
    } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);
    if (!(context.transaction && context.animated)) this._applyLayoutInfos();
    if (context.animated && hasLayoutUpdates) {
      this._enableTransitions();
      let done = () => {
        this._disableTransitions();
        if (!this._animatedContentOffset.isOrigin()) {
          let { x, y } = this.getVisibleRect();
          this._resetAnimatedContentOffset();
          this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));
        }
        if (typeof context.afterAnimation === "function") context.afterAnimation();
      };
      setTimeout(done, this.transitionDuration + 100);
      return;
    } else if (typeof context.afterAnimation === "function") context.afterAnimation();
  }
  /**
  * Corrects DOM order of visible views to match item order of collection.
  */
  _correctItemOrder() {
    if (this._isScrolling || this._transaction) return;
    for (let key3 of this._visibleLayoutInfos.keys()) {
      let view = this._visibleViews.get(key3);
      this._children.delete(view);
      this._children.add(view);
    }
  }
  _enableTransitions() {
    this.delegate.beginAnimations();
  }
  _disableTransitions() {
    this.delegate.endAnimations();
  }
  _getScrollAnchor() {
    if (!this.anchorScrollPosition) return null;
    let visibleRect = this.getVisibleRect();
    if (this.delegate.getScrollAnchor) {
      let key3 = this.delegate.getScrollAnchor(visibleRect);
      if (key3 != null) {
        let layoutInfo = this.layout.getLayoutInfo(key3);
        let corner = layoutInfo.rect.getCornerInRect(visibleRect);
        if (corner) {
          let key4 = layoutInfo.key;
          let offset5 = layoutInfo.rect[corner].y - visibleRect.y;
          return {
            key: key4,
            layoutInfo,
            corner,
            offset: offset5
          };
        }
      }
    }
    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;
    let cornerAnchor = null;
    for (let [key3, view] of this._visibleViews) {
      let layoutInfo = view.layoutInfo;
      if (layoutInfo && layoutInfo.rect.area > 0) {
        let corner = layoutInfo.rect.getCornerInRect(visibleRect);
        if (corner) {
          let offset5 = layoutInfo.rect[corner].y - visibleRect.y;
          if (!cornerAnchor || offset5 < cornerAnchor.offset) cornerAnchor = {
            key: key3,
            layoutInfo,
            corner,
            offset: offset5
          };
        }
      }
    }
    return cornerAnchor;
  }
  _restoreScrollAnchor(scrollAnchor, context) {
    let contentOffset = this.getVisibleRect();
    if (scrollAnchor) {
      var _context_transaction;
      let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);
      if (finalAnchor) {
        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;
        contentOffset.y += adjustment;
      }
    }
    return contentOffset;
  }
  getVisibleRect() {
    let v = this.visibleRect;
    let x = v.x - this._animatedContentOffset.x;
    let y = v.y - this._animatedContentOffset.y;
    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);
  }
  getVisibleLayoutInfos() {
    let isTestEnv = false;
    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes("clientWidth");
    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes("clientHeight");
    let rect;
    if (isTestEnv && !(isClientWidthMocked && isClientHeightMocked)) rect = this._getContentRect();
    else rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();
    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);
    return this._visibleLayoutInfos;
  }
  _getLayoutInfoMap(rect, copy2 = false) {
    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
    let map6 = /* @__PURE__ */ new Map();
    for (let layoutInfo of layoutInfos) {
      if (copy2) layoutInfo = layoutInfo.copy();
      map6.set(layoutInfo.key, layoutInfo);
    }
    return map6;
  }
  updateSubviews(forceUpdate = false) {
    if (!this._collection) return;
    let visibleLayoutInfos = this.getVisibleLayoutInfos();
    let currentlyVisible = this._visibleViews;
    let toAdd, toRemove, toUpdate;
    if (forceUpdate) {
      toAdd = visibleLayoutInfos;
      toRemove = currentlyVisible;
      toUpdate = /* @__PURE__ */ new Set();
    } else {
      ({ toAdd, toRemove, toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));
      for (let key3 of toUpdate) {
        let view = currentlyVisible.get(key3);
        if (!view || !view.layoutInfo) continue;
        let item2 = this.getItem(visibleLayoutInfos.get(key3).key);
        if (view.content === item2) toUpdate.delete(key3);
        else {
          let { reuseType } = this._getReuseType(view.layoutInfo, item2);
          if (view.viewType !== reuseType) {
            toUpdate.delete(key3);
            toAdd.add(key3);
            toRemove.add(key3);
          }
        }
      }
      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {
        if (this._transaction) this._applyLayoutInfos();
        return;
      }
    }
    let removed = /* @__PURE__ */ new Set();
    for (let key3 of toRemove.keys()) {
      let view = this._visibleViews.get(key3);
      if (view) {
        removed.add(view);
        this._visibleViews.delete(key3);
        if (this._transaction) this._transaction.toRemove.set(key3, view);
        else this.reuseView(view);
      }
    }
    for (let key3 of toAdd.keys()) {
      let layoutInfo = visibleLayoutInfos.get(key3);
      let view;
      if (this._transaction) {
        if (this._transaction.initialLayoutInfo.has(key3)) layoutInfo = this._transaction.initialLayoutInfo.get(key3);
        view = this._transaction.toRemove.get(key3);
        if (view) {
          this._transaction.toRemove.delete(key3);
          this._applyLayoutInfo(view, layoutInfo);
        }
      }
      if (!view) {
        view = this.getReusableView(layoutInfo);
        if (!removed.has(view)) this._children.add(view);
      }
      this._visibleViews.set(key3, view);
      removed.delete(view);
    }
    for (let key3 of toUpdate) {
      let view = currentlyVisible.get(key3);
      this._renderedContent.delete(key3);
      this._renderView(view);
    }
    if (!this._transaction) this.removeViews(removed);
    this._correctItemOrder();
    this._flushVisibleViews();
    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());
    if (hasLayoutUpdates) requestAnimationFrame(() => {
      if (this._transaction) requestAnimationFrame(() => this._applyLayoutInfos());
    });
    return hasLayoutUpdates;
  }
  afterRender() {
    if (this._transactionQueue.length > 0) this._processTransactionQueue();
    else if (this._invalidationContext) this.relayoutNow();
    if (this.shouldOverscan) this._overscanManager.collectMetrics();
  }
  _flushVisibleViews() {
    let viewsByParentKey = /* @__PURE__ */ new Map([
      [
        null,
        []
      ]
    ]);
    for (let view of this._children) {
      var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;
      if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);
      (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);
      if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);
    }
    let buildTree2 = (parent, views) => views.map((view) => {
      let children2 = viewsByParentKey.get(view.layoutInfo.key);
      return this.delegate.renderWrapper(parent, view, children2, (childViews) => buildTree2(view, childViews));
    });
    let children = buildTree2(null, viewsByParentKey.get(null));
    this.delegate.setVisibleViews(children);
  }
  _applyLayoutInfo(view, layoutInfo) {
    if (view.layoutInfo === layoutInfo) return false;
    view.layoutInfo = layoutInfo;
    return true;
  }
  _applyLayoutInfos() {
    let updated = false;
    for (let view of this._visibleViews.values()) {
      let cur = view.layoutInfo;
      if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {
        let layoutInfo = this.layout.getLayoutInfo(cur.key);
        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;
      }
    }
    if (this._transaction) {
      for (let view of this._transaction.toRemove.values()) {
        let cur = view.layoutInfo;
        if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {
          let layoutInfo = this.layout.getLayoutInfo(cur.key);
          if (this._applyLayoutInfo(view, layoutInfo)) updated = true;
        }
      }
      for (let view of this._transaction.removed.values()) {
        let cur = view.layoutInfo;
        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;
        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());
        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;
      }
    }
    if (updated) this._flushVisibleViews();
  }
  _hasLayoutUpdates() {
    if (!this._transaction) return false;
    for (let view of this._visibleViews.values()) {
      let cur = view.layoutInfo;
      if (!cur) return true;
      let layoutInfo = this.layout.getLayoutInfo(cur.key);
      if (
        // Uses equals rather than pointEquals so that width/height changes are taken into account
        !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform
      ) return true;
    }
    return false;
  }
  reuseView(view) {
    view.prepareForReuse();
    this._reusableViews[view.viewType].push(view);
  }
  removeViews(toRemove) {
    for (let view of toRemove) this._children.delete(view);
  }
  updateItemSize(key3, size4) {
    if (!this.layout.updateItemSize) return;
    if (this._scrollAnimation) {
      this._sizeUpdateQueue.set(key3, size4);
      return;
    }
    let changed = this.layout.updateItemSize(key3, size4);
    if (changed) this.relayout();
  }
  startScrolling() {
    this._isScrolling = true;
  }
  endScrolling() {
    this._isScrolling = false;
    this._correctItemOrder();
    this._flushVisibleViews();
  }
  _resetAnimatedContentOffset() {
    if (!this._animatedContentOffset.isOrigin()) {
      this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);
      this._applyLayoutInfos();
    }
  }
  /**
  * Scrolls the item with the given key into view, optionally with an animation.
  * @param key The key of the item to scroll into view.
  * @param duration The duration of the scroll animation.
  */
  scrollToItem(key3, options) {
    if (key3 == null) return;
    let layoutInfo = this.layout.getLayoutInfo(key3);
    if (!layoutInfo) return;
    let { duration = 300, shouldScrollX = true, shouldScrollY = true, offsetX = 0, offsetY = 0 } = options;
    let x = this.visibleRect.x;
    let y = this.visibleRect.y;
    let minX = layoutInfo.rect.x - offsetX;
    let minY = layoutInfo.rect.y - offsetY;
    let maxX = x + this.visibleRect.width;
    let maxY = y + this.visibleRect.height;
    if (shouldScrollX) {
      if (minX <= x || maxX === 0) x = minX;
      else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;
    }
    if (shouldScrollY) {
      if (minY <= y || maxY === 0) y = minY;
      else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;
    }
    return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);
  }
  /**
  * Performs an animated scroll to the given offset.
  * @param offset - The offset to scroll to.
  * @param duration The duration of the animation.
  * @returns A promise that resolves when the animation is complete.
  */
  scrollTo(offset5, duration = 300) {
    if (this._scrollAnimation) {
      this._scrollAnimation.cancel();
      this._scrollAnimation = null;
    }
    if (duration <= 0 || this.visibleRect.pointEquals(offset5)) {
      this._setContentOffset(offset5);
      return Promise.resolve();
    }
    this.startScrolling();
    this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset5, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset6) => {
      this._setContentOffset(offset6);
    });
    this._scrollAnimation.then(() => {
      this._scrollAnimation = null;
      for (let [key3, size4] of this._sizeUpdateQueue) this.updateItemSize(key3, size4);
      this._sizeUpdateQueue.clear();
      this.relayout();
      this._processTransactionQueue();
      this.endScrolling();
    });
    return this._scrollAnimation;
  }
  _runTransaction(action, animated) {
    this._startTransaction();
    if (this._nextTransaction) this._nextTransaction.actions.push(action);
    this._endTransaction(animated);
  }
  _startTransaction() {
    if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0)();
    this._nextTransaction.level++;
  }
  _endTransaction(animated) {
    if (!this._nextTransaction) return false;
    if (animated != null) this._nextTransaction.animated = animated;
    if (--this._nextTransaction.level > 0) return false;
    if (this._nextTransaction.actions.length === 0) {
      this._nextTransaction = null;
      return false;
    }
    if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;
    this._transactionQueue.push(this._nextTransaction);
    this._nextTransaction = null;
    return true;
  }
  _processTransactionQueue() {
    if (this._transaction || this._scrollAnimation) return;
    let next = this._transactionQueue.shift();
    if (next) this._performTransaction(next);
  }
  _getContentRect() {
    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);
  }
  _performTransaction(transaction) {
    this._transaction = transaction;
    this.relayoutNow({
      transaction,
      animated: transaction.animated,
      beforeLayout: () => {
        if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);
        for (let action of transaction.actions) action();
      },
      afterLayout: () => {
        if (transaction.animated) {
          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());
          this._setupTransactionAnimations(transaction);
        } else this._transaction = null;
      },
      afterAnimation: () => {
        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())) {
          this._children.delete(view);
          this.reuseView(view);
        }
        this._transaction = null;
        this._correctItemOrder();
        this._flushVisibleViews();
        this._processTransactionQueue();
      }
    });
  }
  _setupTransactionAnimations(transaction) {
    let { initialMap, finalMap } = transaction;
    for (let [key3, layoutInfo] of initialMap) if (finalMap.has(key3))
      transaction.initialLayoutInfo.set(key3, layoutInfo);
    else
      transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);
    for (let [key3, layoutInfo] of finalMap) if (!initialMap.has(key3)) {
      let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());
      transaction.initialLayoutInfo.set(key3, initialLayoutInfo);
    }
    for (let [key3, view] of this._visibleViews)
      if (!finalMap.has(key3) && view.layoutInfo.rect.width > 0) {
        transaction.removed.set(key3, view);
        this._visibleViews.delete(key3);
        if (view.layoutInfo) {
          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);
        }
      }
  }
  constructor(options = {}) {
    this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();
    this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this._reusableViews = {};
    this._visibleLayoutInfos = /* @__PURE__ */ new Map();
    this._visibleViews = /* @__PURE__ */ new Map();
    this._renderedContent = /* @__PURE__ */ new WeakMap();
    this._children = /* @__PURE__ */ new Set();
    this._invalidationContext = null;
    this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();
    this._persistedKeys = /* @__PURE__ */ new Set();
    this._scrollAnimation = null;
    this._isScrolling = false;
    this._sizeUpdateQueue = /* @__PURE__ */ new Map();
    this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);
    this._transaction = null;
    this._nextTransaction = null;
    this._transactionQueue = [];
    var _options_transitionDuration;
    this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;
    this.anchorScrollPosition = options.anchorScrollPosition || false;
    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;
    this.shouldOverscan = options.shouldOverscan !== false;
    for (let key3 of [
      "delegate",
      "size",
      "layout",
      "collection"
    ]) if (options[key3]) this[key3] = options[key3];
  }
};

// node_modules/@react-stately/virtualizer/dist/useVirtualizerState.mjs
var import_react16 = __toESM(require_react(), 1);
function $fc0b13b484ac1194$export$1505db82fe357e65(opts) {
  let [visibleViews, setVisibleViews] = (0, import_react16.useState)([]);
  let [contentSize, setContentSize] = (0, import_react16.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());
  let [isAnimating, setAnimating] = (0, import_react16.useState)(false);
  let [isScrolling, setScrolling] = (0, import_react16.useState)(false);
  let virtualizer = (0, import_react16.useMemo)(() => new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);
  virtualizer.delegate = {
    setVisibleViews,
    setVisibleRect(rect) {
      virtualizer.visibleRect = rect;
      opts.onVisibleRectChange(rect);
    },
    setContentSize,
    renderView: opts.renderView,
    renderWrapper: opts.renderWrapper,
    beginAnimations: () => setAnimating(true),
    endAnimations: () => setAnimating(false),
    getScrollAnchor: opts.getScrollAnchor
  };
  virtualizer.layout = opts.layout;
  virtualizer.collection = opts.collection;
  virtualizer.transitionDuration = opts.transitionDuration;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    virtualizer.afterRender();
  });
  (0, import_react16.useEffect)(() => {
    return () => virtualizer.willUnmount();
  }, []);
  let setVisibleRect = (0, import_react16.useCallback)((rect) => {
    virtualizer.visibleRect = rect;
  }, [
    virtualizer
  ]);
  let startScrolling = (0, import_react16.useCallback)(() => {
    virtualizer.startScrolling();
    setScrolling(true);
  }, [
    virtualizer
  ]);
  let endScrolling = (0, import_react16.useCallback)(() => {
    virtualizer.endScrolling();
    setScrolling(false);
  }, [
    virtualizer
  ]);
  let state2 = (0, import_react16.useMemo)(() => ({
    virtualizer,
    visibleViews,
    setVisibleRect,
    contentSize,
    isAnimating,
    isScrolling,
    startScrolling,
    endScrolling
  }), [
    virtualizer,
    visibleViews,
    setVisibleRect,
    contentSize,
    isAnimating,
    isScrolling,
    startScrolling,
    endScrolling
  ]);
  return state2;
}

// node_modules/@react-aria/virtualizer/dist/ScrollView.mjs
var $44a6ee657928b002$var$isOldReact = (0, import_react17.default).version.startsWith("16.") || (0, import_react17.default).version.startsWith("17.");
function $44a6ee657928b002$var$ScrollView(props, ref2) {
  let { contentSize, onVisibleRectChange, children, innerStyle, sizeToFit, onScrollStart, onScrollEnd, scrollDirection = "both", ...otherProps } = props;
  let defaultRef = (0, import_react17.useRef)();
  ref2 = ref2 || defaultRef;
  let state2 = (0, import_react17.useRef)({
    scrollTop: 0,
    scrollLeft: 0,
    scrollEndTime: 0,
    scrollTimeout: null,
    width: 0,
    height: 0,
    isScrolling: false
  }).current;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let [isScrolling, setScrolling] = (0, import_react17.useState)(false);
  let onScroll = (0, import_react17.useCallback)((e3) => {
    if (e3.target !== e3.currentTarget) return;
    if (props.onScroll) props.onScroll(e3);
    (0, import_react_dom2.flushSync)(() => {
      let scrollTop = e3.currentTarget.scrollTop;
      let scrollLeft = (0, $ce415dc67314b753$export$1389d168952b34b5)(e3.currentTarget, direction);
      state2.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state2.height));
      state2.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state2.width));
      onVisibleRectChange(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(state2.scrollLeft, state2.scrollTop, state2.width, state2.height));
      if (!state2.isScrolling) {
        state2.isScrolling = true;
        setScrolling(true);
        if (onScrollStart) onScrollStart();
      }
      let now = Date.now();
      if (state2.scrollEndTime <= now + 50) {
        state2.scrollEndTime = now + 300;
        clearTimeout(state2.scrollTimeout);
        state2.scrollTimeout = setTimeout(() => {
          state2.isScrolling = false;
          setScrolling(false);
          state2.scrollTimeout = null;
          if (onScrollEnd) onScrollEnd();
        }, 300);
      }
    });
  }, [
    props,
    direction,
    state2,
    contentSize,
    onVisibleRectChange,
    onScrollStart,
    onScrollEnd
  ]);
  (0, import_react17.useEffect)(() => {
    return () => {
      clearTimeout(state2.scrollTimeout);
    };
  }, []);
  let updateSize = (0, import_react17.useCallback)(() => {
    let dom = ref2.current;
    if (!dom) return;
    let isTestEnv = false;
    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes("clientWidth");
    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes("clientHeight");
    let w = isTestEnv && !isClientWidthMocked ? Infinity : dom.clientWidth;
    let h = isTestEnv && !isClientHeightMocked ? Infinity : dom.clientHeight;
    if (sizeToFit && contentSize.width > 0 && contentSize.height > 0) {
      if (sizeToFit === "width") w = Math.min(w, contentSize.width);
      else if (sizeToFit === "height") h = Math.min(h, contentSize.height);
    }
    if (state2.width !== w || state2.height !== h) {
      state2.width = w;
      state2.height = h;
      onVisibleRectChange(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(state2.scrollLeft, state2.scrollTop, w, h));
    }
  }, [
    onVisibleRectChange,
    ref2,
    state2,
    sizeToFit,
    contentSize
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    updateSize();
  }, [
    updateSize
  ]);
  let raf = (0, import_react17.useRef)();
  let onResize = () => {
    var _raf;
    var _current;
    if ($44a6ee657928b002$var$isOldReact) (_current = (_raf = raf).current) !== null && _current !== void 0 ? _current : _raf.current = requestAnimationFrame(() => {
      updateSize();
      raf.current = null;
    });
    else updateSize();
  };
  (0, $9daab02d461809db$export$683480f191c0e3ea)({
    ref: ref2,
    onResize
  });
  (0, import_react17.useEffect)(() => {
    return () => {
      if (raf.current) cancelAnimationFrame(raf.current);
    };
  }, []);
  let style = {
    // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.
    padding: 0,
    ...otherProps.style
  };
  if (scrollDirection === "horizontal") {
    style.overflowX = "auto";
    style.overflowY = "hidden";
  } else if (scrollDirection === "vertical" || contentSize.width === state2.width) {
    style.overflowY = "auto";
    style.overflowX = "hidden";
  } else style.overflow = "auto";
  innerStyle = {
    width: Number.isFinite(contentSize.width) ? contentSize.width : void 0,
    height: Number.isFinite(contentSize.height) ? contentSize.height : void 0,
    pointerEvents: isScrolling ? "none" : "auto",
    position: "relative",
    ...innerStyle
  };
  return (0, import_react17.default).createElement("div", {
    ...otherProps,
    style,
    ref: ref2,
    onScroll
  }, (0, import_react17.default).createElement("div", {
    role: "presentation",
    style: innerStyle
  }, children));
}
var $44a6ee657928b002$export$5665e3d6be6adea = (0, import_react17.default).forwardRef($44a6ee657928b002$var$ScrollView);

// node_modules/@react-aria/virtualizer/dist/useVirtualizerItem.mjs
var import_react18 = __toESM(require_react(), 1);
function $47736c1e63ba1c6d$export$1da781778207e0a2(options) {
  let { layoutInfo, virtualizer, ref: ref2 } = options;
  let updateSize = (0, import_react18.useCallback)(() => {
    let size4 = $47736c1e63ba1c6d$var$getSize(ref2.current);
    virtualizer.updateItemSize(layoutInfo.key, size4);
  }, [
    virtualizer,
    layoutInfo.key,
    ref2
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (layoutInfo.estimatedSize) updateSize();
  });
  return {
    updateSize
  };
}
function $47736c1e63ba1c6d$var$getSize(node3) {
  let height = node3.style.height;
  node3.style.height = "";
  let size4 = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(node3.scrollWidth, node3.scrollHeight);
  node3.style.height = height;
  return size4;
}

// node_modules/@react-aria/virtualizer/dist/VirtualizerItem.mjs
var import_react19 = __toESM(require_react(), 1);
function $ccf8a0a04e4175ae$export$6796df8ba7398521(props) {
  let { className, layoutInfo, virtualizer, parent, children } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let ref2 = (0, import_react19.useRef)();
  (0, $47736c1e63ba1c6d$export$1da781778207e0a2)({
    layoutInfo,
    virtualizer,
    ref: ref2
  });
  return (0, import_react19.default).createElement("div", {
    role: "presentation",
    ref: ref2,
    className,
    style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, direction, parent)
  }, children);
}
var $ccf8a0a04e4175ae$var$cache = /* @__PURE__ */ new WeakMap();
function $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, dir, parent) {
  let xProperty = dir === "rtl" ? "right" : "left";
  let cached = $ccf8a0a04e4175ae$var$cache.get(layoutInfo);
  if (cached && cached[xProperty] != null) {
    if (!parent) return cached;
    let top = layoutInfo.rect.y - parent.rect.y;
    let x = layoutInfo.rect.x - parent.rect.x;
    if (cached.top === top && cached[xProperty] === x) return cached;
  }
  let rectStyles = {
    top: layoutInfo.rect.y - (parent ? parent.rect.y : 0),
    [xProperty]: layoutInfo.rect.x - (parent ? parent.rect.x : 0),
    width: layoutInfo.rect.width,
    height: layoutInfo.rect.height
  };
  Object.entries(rectStyles).forEach(([key3, value]) => {
    if (!Number.isFinite(value)) rectStyles[key3] = void 0;
  });
  let style = {
    position: layoutInfo.isSticky ? "sticky" : "absolute",
    // Sticky elements are positioned in normal document flow. Display inline-block so that they don't push other sticky columns onto the following rows.
    display: layoutInfo.isSticky ? "inline-block" : void 0,
    overflow: layoutInfo.allowOverflow ? "visible" : "hidden",
    transition: "all",
    WebkitTransition: "all",
    WebkitTransitionDuration: "inherit",
    transitionDuration: "inherit",
    opacity: layoutInfo.opacity,
    zIndex: layoutInfo.zIndex,
    transform: layoutInfo.transform,
    contain: "size layout style",
    ...rectStyles
  };
  $ccf8a0a04e4175ae$var$cache.set(layoutInfo, style);
  return style;
}

// node_modules/@react-aria/virtualizer/dist/Virtualizer.mjs
var import_react20 = __toESM(require_react(), 1);
function $6d0a5c394373ae64$var$Virtualizer(props, ref2) {
  let { children: renderView, renderWrapper, layout, collection: collection2, sizeToFit, scrollDirection, transitionDuration, isLoading, onLoadMore, focusedKey, shouldUseVirtualFocus, scrollToItem, autoFocus, ...otherProps } = props;
  let fallbackRef = (0, import_react20.useRef)();
  ref2 = ref2 || fallbackRef;
  let state2 = (0, $fc0b13b484ac1194$export$1505db82fe357e65)({
    transitionDuration,
    layout,
    collection: collection2,
    renderView,
    renderWrapper: renderWrapper || $6d0a5c394373ae64$var$defaultRenderWrapper,
    onVisibleRectChange(rect) {
      ref2.current.scrollLeft = rect.x;
      ref2.current.scrollTop = rect.y;
    }
  });
  let { virtualizerProps, scrollViewProps } = $6d0a5c394373ae64$export$dd6d526d88b5a137(props, state2, ref2);
  return (0, import_react20.default).createElement((0, $44a6ee657928b002$export$5665e3d6be6adea), {
    ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(otherProps, virtualizerProps, scrollViewProps),
    ref: ref2,
    innerStyle: state2.isAnimating ? {
      transition: `none ${state2.virtualizer.transitionDuration}ms`
    } : void 0,
    contentSize: state2.contentSize,
    onScrollStart: state2.startScrolling,
    onScrollEnd: state2.endScrolling,
    sizeToFit,
    scrollDirection
  }, state2.visibleViews);
}
function $6d0a5c394373ae64$export$dd6d526d88b5a137(props, state2, ref2) {
  let { focusedKey, scrollToItem, shouldUseVirtualFocus, isLoading, onLoadMore } = props;
  let { virtualizer } = state2;
  let lastFocusedKey = (0, import_react20.useRef)(null);
  let isFocusWithin = (0, import_react20.useRef)(false);
  let autoFocus = (0, import_react20.useRef)(props.autoFocus);
  (0, import_react20.useEffect)(() => {
    if (virtualizer.visibleRect.height === 0) return;
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (focusedKey !== lastFocusedKey.current && (modality !== "pointer" || autoFocus.current)) {
      autoFocus.current = false;
      if (scrollToItem)
        scrollToItem(focusedKey);
      else virtualizer.scrollToItem(focusedKey, {
        duration: 0
      });
    }
    lastFocusedKey.current = focusedKey;
  }, [
    focusedKey,
    virtualizer.visibleRect.height,
    virtualizer,
    lastFocusedKey,
    scrollToItem,
    ref2
  ]);
  virtualizer.persistedKeys = (0, import_react20.useMemo)(() => focusedKey ? /* @__PURE__ */ new Set([
    focusedKey
  ]) : /* @__PURE__ */ new Set(), [
    focusedKey
  ]);
  let onFocus = (0, import_react20.useCallback)((e3) => {
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (!isFocusWithin.current && ref2.current.contains(e3.target) && modality !== "pointer") {
      if (scrollToItem) scrollToItem(focusedKey);
      else virtualizer.scrollToItem(focusedKey, {
        duration: 0
      });
    }
    isFocusWithin.current = e3.target !== ref2.current;
  }, [
    ref2,
    virtualizer,
    focusedKey,
    scrollToItem
  ]);
  let onBlur = (0, import_react20.useCallback)((e3) => {
    isFocusWithin.current = ref2.current.contains(e3.relatedTarget);
  }, [
    ref2
  ]);
  let tabIndex;
  if (!shouldUseVirtualFocus) {
    tabIndex = focusedKey != null ? -1 : 0;
    if (virtualizer.collection.size === 0 && props.tabIndex != null) tabIndex = props.tabIndex;
  }
  let isLoadingRef = (0, import_react20.useRef)(isLoading);
  let prevProps = (0, import_react20.useRef)(props);
  let onVisibleRectChange = (0, import_react20.useCallback)((rect) => {
    state2.setVisibleRect(rect);
    if (!isLoadingRef.current && onLoadMore) {
      let scrollOffset = state2.virtualizer.contentSize.height - rect.height * 2;
      if (rect.y > scrollOffset) {
        isLoadingRef.current = true;
        onLoadMore();
      }
    }
  }, [
    onLoadMore,
    state2
  ]);
  let lastContentSize = (0, import_react20.useRef)(0);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (state2.isAnimating) return;
    let wasLoading = isLoadingRef.current;
    if (props !== prevProps.current) {
      isLoadingRef.current = isLoading;
      prevProps.current = props;
    }
    let shouldLoadMore = !isLoadingRef.current && onLoadMore && state2.contentSize.height > 0 && state2.contentSize.height <= state2.virtualizer.visibleRect.height && (wasLoading || state2.contentSize.height !== lastContentSize.current);
    if (shouldLoadMore) {
      isLoadingRef.current = true;
      onLoadMore();
    }
    lastContentSize.current = state2.contentSize.height;
  }, [
    state2.contentSize,
    state2.isAnimating,
    state2.virtualizer,
    isLoading,
    onLoadMore,
    props
  ]);
  return {
    virtualizerProps: {
      tabIndex,
      onFocus,
      onBlur
    },
    scrollViewProps: {
      onVisibleRectChange
    }
  };
}
var $6d0a5c394373ae64$export$89be5a243e59c4b2 = (0, import_react20.default).forwardRef($6d0a5c394373ae64$var$Virtualizer);
function $6d0a5c394373ae64$var$defaultRenderWrapper(parent, reusableView) {
  return (0, import_react20.default).createElement((0, $ccf8a0a04e4175ae$export$6796df8ba7398521), {
    key: reusableView.key,
    layoutInfo: reusableView.layoutInfo,
    virtualizer: reusableView.virtualizer,
    parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo
  }, reusableView.rendered);
}

// node_modules/@react-stately/layout/dist/ListLayout.mjs
var $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;
var $61ef60fc9b1041f4$export$cacbb3924155d68e = class extends (0, $c74cda7d31af1253$export$c84671f46d6a1ca) {
  getLayoutInfo(key3) {
    let res = this.layoutInfos.get(key3);
    if (!res && this.validRect.area < this.contentSize.area && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, Infinity, Infinity);
      this.rootNodes = this.buildCollection();
      this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);
      res = this.layoutInfos.get(key3);
    }
    return res;
  }
  getVisibleLayoutInfos(rect) {
    if (!this.validRect.containsRect(rect) && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = this.validRect.union(rect);
      this.rootNodes = this.buildCollection();
    }
    let res = [];
    let addNodes = (nodes) => {
      for (let node3 of nodes) if (this.isVisible(node3, rect)) {
        res.push(node3.layoutInfo);
        if (node3.header) res.push(node3.header);
        if (node3.children) addNodes(node3.children);
      }
    };
    addNodes(this.rootNodes);
    return res;
  }
  isVisible(node3, rect) {
    return node3.layoutInfo.rect.intersects(rect) || node3.layoutInfo.isSticky || this.virtualizer.isPersistedKey(node3.layoutInfo.key);
  }
  shouldInvalidateEverything(invalidationContext) {
    return invalidationContext.sizeChanged;
  }
  validate(invalidationContext) {
    this.collection = this.virtualizer.collection;
    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);
    if (this.invalidateEverything) {
      this.lastValidRect = this.validRect;
      this.validRect = this.virtualizer.getVisibleRect();
    }
    this.rootNodes = this.buildCollection();
    if (this.lastCollection && this.collection !== this.lastCollection) {
      for (let key3 of this.lastCollection.getKeys()) if (!this.collection.getItem(key3)) {
        let layoutNode = this.layoutNodes.get(key3);
        if (layoutNode) {
          var _layoutNode_header;
          this.layoutInfos.delete(layoutNode.layoutInfo.key);
          this.layoutInfos.delete((_layoutNode_header = layoutNode.header) === null || _layoutNode_header === void 0 ? void 0 : _layoutNode_header.key);
          this.layoutNodes.delete(key3);
        }
      }
    }
    this.lastWidth = this.virtualizer.visibleRect.width;
    this.lastCollection = this.collection;
    this.invalidateEverything = false;
  }
  buildCollection() {
    let y = this.padding;
    let skipped = 0;
    let nodes = [];
    for (let node3 of this.collection) {
      var _this_rowHeight;
      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;
      if (node3.type === "item" && y + rowHeight < this.validRect.y && !this.isValid(node3, y)) {
        y += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(node3, 0, y);
      y = layoutNode.layoutInfo.rect.maxY;
      nodes.push(layoutNode);
      if (node3.type === "item" && y > this.validRect.maxY) {
        y += (this.collection.size - (nodes.length + skipped)) * rowHeight;
        break;
      }
    }
    if (this.isLoading) {
      var _this_loaderHeight;
      let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y, this.virtualizer.visibleRect.width, (_this_loaderHeight = this.loaderHeight) !== null && _this_loaderHeight !== void 0 ? _this_loaderHeight : this.virtualizer.visibleRect.height);
      let loader = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("loader", "loader", rect);
      this.layoutInfos.set("loader", loader);
      nodes.push({
        layoutInfo: loader
      });
      y = loader.rect.maxY;
    }
    if (nodes.length === 0) {
      var _this_placeholderHeight;
      let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y, this.virtualizer.visibleRect.width, (_this_placeholderHeight = this.placeholderHeight) !== null && _this_placeholderHeight !== void 0 ? _this_placeholderHeight : this.virtualizer.visibleRect.height);
      let placeholder = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("placeholder", "placeholder", rect);
      this.layoutInfos.set("placeholder", placeholder);
      nodes.push({
        layoutInfo: placeholder
      });
      y = placeholder.rect.maxY;
    }
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(this.virtualizer.visibleRect.width, y + this.padding);
    return nodes;
  }
  isValid(node3, y) {
    let cached = this.layoutNodes.get(node3.key);
    return !this.invalidateEverything && cached && cached.node === node3 && y === (cached.header || cached.layoutInfo).rect.y && cached.layoutInfo.rect.intersects(this.lastValidRect) && cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.validRect));
  }
  buildChild(node3, x, y) {
    if (this.isValid(node3, y)) return this.layoutNodes.get(node3.key);
    let layoutNode = this.buildNode(node3, x, y);
    layoutNode.node = node3;
    var _node_parentKey;
    layoutNode.layoutInfo.parentKey = (_node_parentKey = node3.parentKey) !== null && _node_parentKey !== void 0 ? _node_parentKey : null;
    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);
    if (layoutNode.header) this.layoutInfos.set(layoutNode.header.key, layoutNode.header);
    this.layoutNodes.set(node3.key, layoutNode);
    return layoutNode;
  }
  buildNode(node3, x, y) {
    switch (node3.type) {
      case "section":
        return this.buildSection(node3, x, y);
      case "item":
        return this.buildItem(node3, x, y);
    }
  }
  buildSection(node3, x, y) {
    let width = this.virtualizer.visibleRect.width;
    let rectHeight = this.headingHeight;
    let isEstimated = false;
    if (rectHeight == null) {
      let previousLayoutNode = this.layoutNodes.get(node3.key);
      if (previousLayoutNode && previousLayoutNode.header) {
        let curNode = this.collection.getItem(node3.key);
        let lastNode = this.lastCollection ? this.lastCollection.getItem(node3.key) : null;
        rectHeight = previousLayoutNode.header.rect.height;
        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;
      } else {
        rectHeight = node3.rendered ? this.estimatedHeadingHeight : 0;
        isEstimated = true;
      }
    }
    if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;
    let headerRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y, width, rectHeight);
    let header = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("header", node3.key + ":header", headerRect);
    header.estimatedSize = isEstimated;
    header.parentKey = node3.key;
    y += header.rect.height;
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y, width, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node3.type, node3.key, rect);
    let startY = y;
    let skipped = 0;
    let children = [];
    for (let child of (0, $c5a24bc478652b5f$export$1005530eda016c13)(node3, this.collection)) {
      var _this_rowHeight;
      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;
      if (y + rowHeight < this.validRect.y && !this.isValid(node3, y)) {
        y += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(child, x, y);
      y = layoutNode.layoutInfo.rect.maxY;
      children.push(layoutNode);
      if (y > this.validRect.maxY) {
        y += ([
          ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(node3, this.collection)
        ].length - (children.length + skipped)) * rowHeight;
        break;
      }
    }
    rect.height = y - startY;
    return {
      header,
      layoutInfo,
      children,
      validRect: layoutInfo.rect.intersection(this.validRect)
    };
  }
  buildItem(node3, x, y) {
    let width = this.virtualizer.visibleRect.width;
    let rectHeight = this.rowHeight;
    let isEstimated = false;
    if (rectHeight == null) {
      let previousLayoutNode = this.layoutNodes.get(node3.key);
      if (previousLayoutNode) {
        rectHeight = previousLayoutNode.layoutInfo.rect.height;
        isEstimated = width !== this.lastWidth || node3 !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;
      } else {
        rectHeight = this.estimatedRowHeight;
        isEstimated = true;
      }
    }
    if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;
    if (typeof this.indentationForItem === "function") x += this.indentationForItem(this.collection, node3.key) || 0;
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, width - x, rectHeight);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node3.type, node3.key, rect);
    layoutInfo.allowOverflow = true;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: layoutInfo.rect
    };
  }
  updateItemSize(key3, size4) {
    let layoutInfo = this.layoutInfos.get(key3);
    if (!layoutInfo) return false;
    layoutInfo.estimatedSize = false;
    if (layoutInfo.rect.height !== size4.height) {
      let newLayoutInfo = layoutInfo.copy();
      newLayoutInfo.rect.height = size4.height;
      this.layoutInfos.set(key3, newLayoutInfo);
      this.updateLayoutNode(key3, layoutInfo, newLayoutInfo);
      let node3 = this.collection.getItem(layoutInfo.parentKey);
      while (node3) {
        this.updateLayoutNode(node3.key, layoutInfo, newLayoutInfo);
        node3 = this.collection.getItem(node3.parentKey);
      }
      return true;
    }
    return false;
  }
  updateLayoutNode(key3, oldLayoutInfo, newLayoutInfo) {
    let n2 = this.layoutNodes.get(key3);
    if (n2) {
      n2.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
      if (n2.header === oldLayoutInfo) n2.header = newLayoutInfo;
      else if (n2.layoutInfo === oldLayoutInfo) n2.layoutInfo = newLayoutInfo;
    }
  }
  getContentSize() {
    return this.contentSize;
  }
  getKeyAbove(key3) {
    let collection2 = this.collection;
    key3 = collection2.getKeyBefore(key3);
    while (key3 != null) {
      let item2 = collection2.getItem(key3);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key))) return key3;
      key3 = collection2.getKeyBefore(key3);
    }
  }
  getKeyBelow(key3) {
    let collection2 = this.collection;
    key3 = collection2.getKeyAfter(key3);
    while (key3 != null) {
      let item2 = collection2.getItem(key3);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key))) return key3;
      key3 = collection2.getKeyAfter(key3);
    }
  }
  getKeyPageAbove(key3) {
    let layoutInfo = this.getLayoutInfo(key3);
    if (layoutInfo) {
      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);
      while (layoutInfo && layoutInfo.rect.y > pageY) {
        let keyAbove = this.getKeyAbove(layoutInfo.key);
        layoutInfo = this.getLayoutInfo(keyAbove);
      }
      if (layoutInfo) return layoutInfo.key;
    }
    return this.getFirstKey();
  }
  getKeyPageBelow(key3) {
    let layoutInfo = this.getLayoutInfo(key3 != null ? key3 : this.getFirstKey());
    if (layoutInfo) {
      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);
      while (layoutInfo && layoutInfo.rect.y < pageY) {
        let keyBelow = this.getKeyBelow(layoutInfo.key);
        layoutInfo = this.getLayoutInfo(keyBelow);
      }
      if (layoutInfo) return layoutInfo.key;
    }
    return this.getLastKey();
  }
  getFirstKey() {
    let collection2 = this.collection;
    let key3 = collection2.getFirstKey();
    while (key3 != null) {
      let item2 = collection2.getItem(key3);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key))) return key3;
      key3 = collection2.getKeyAfter(key3);
    }
  }
  getLastKey() {
    let collection2 = this.collection;
    let key3 = collection2.getLastKey();
    while (key3 != null) {
      let item2 = collection2.getItem(key3);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key))) return key3;
      key3 = collection2.getKeyBefore(key3);
    }
  }
  getKeyForSearch(search2, fromKey) {
    if (!this.collator) return null;
    let collection2 = this.collection;
    let key3 = fromKey || this.getFirstKey();
    while (key3 != null) {
      let item2 = collection2.getItem(key3);
      let substring = item2.textValue.slice(0, search2.length);
      if (item2.textValue && this.collator.compare(substring, search2) === 0) return key3;
      key3 = this.getKeyBelow(key3);
    }
    return null;
  }
  getInitialLayoutInfo(layoutInfo) {
    layoutInfo.opacity = 0;
    layoutInfo.transform = "scale3d(0.8, 0.8, 0.8)";
    return layoutInfo;
  }
  getFinalLayoutInfo(layoutInfo) {
    layoutInfo.opacity = 0;
    layoutInfo.transform = "scale3d(0.8, 0.8, 0.8)";
    return layoutInfo;
  }
  getDropTargetFromPoint(x, y, isValidDropTarget) {
    x += this.virtualizer.visibleRect.x;
    y += this.virtualizer.visibleRect.y;
    let key3 = this.virtualizer.keyAtPoint(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));
    if (key3 == null || this.collection.size === 0) return {
      type: "root"
    };
    let layoutInfo = this.getLayoutInfo(key3);
    let rect = layoutInfo.rect;
    let target = {
      type: "item",
      key: layoutInfo.key,
      dropPosition: "on"
    };
    if (!isValidDropTarget(target)) {
      if (y <= rect.y + rect.height / 2 && isValidDropTarget({
        ...target,
        dropPosition: "before"
      })) target.dropPosition = "before";
      else if (isValidDropTarget({
        ...target,
        dropPosition: "after"
      })) target.dropPosition = "after";
    } else if (y <= rect.y + 10 && isValidDropTarget({
      ...target,
      dropPosition: "before"
    })) target.dropPosition = "before";
    else if (y >= rect.maxY - 10 && isValidDropTarget({
      ...target,
      dropPosition: "after"
    })) target.dropPosition = "after";
    return target;
  }
  /**
  * Creates a new ListLayout with options. See the list of properties below for a description
  * of the options that can be provided.
  */
  constructor(options = {}) {
    super();
    this.disabledKeys = /* @__PURE__ */ new Set();
    this.allowDisabledKeyFocus = false;
    this.rowHeight = options.rowHeight;
    this.estimatedRowHeight = options.estimatedRowHeight;
    this.headingHeight = options.headingHeight;
    this.estimatedHeadingHeight = options.estimatedHeadingHeight;
    this.padding = options.padding || 0;
    this.indentationForItem = options.indentationForItem;
    this.collator = options.collator;
    this.loaderHeight = options.loaderHeight;
    this.placeholderHeight = options.placeholderHeight;
    this.layoutInfos = /* @__PURE__ */ new Map();
    this.layoutNodes = /* @__PURE__ */ new Map();
    this.rootNodes = [];
    this.lastWidth = 0;
    this.lastCollection = null;
    this.allowDisabledKeyFocus = options.allowDisabledKeyFocus;
    this.lastValidRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();
  }
};

// node_modules/@react-stately/layout/dist/TableLayout.mjs
var $a152112e902709bf$export$62444c3c724b1b20 = class extends (0, $61ef60fc9b1041f4$export$cacbb3924155d68e) {
  shouldInvalidateEverything(invalidationContext) {
    return super.shouldInvalidateEverything(invalidationContext) || !this.lastCollection || this.collection.columns.length !== this.lastCollection.columns.length || this.collection.columns.some((c, i2) => c.key !== this.lastCollection.columns[i2].key || c.props.width !== this.lastCollection.columns[i2].props.width || c.props.minWidth !== this.lastCollection.columns[i2].props.minWidth || c.props.maxWidth !== this.lastCollection.columns[i2].props.maxWidth);
  }
  getResizerPosition() {
    var _this_getLayoutInfo;
    return (_this_getLayoutInfo = this.getLayoutInfo(this.resizingColumn)) === null || _this_getLayoutInfo === void 0 ? void 0 : _this_getLayoutInfo.rect.maxX;
  }
  getColumnWidth(key3) {
    var _this_columnLayout_getColumnWidth;
    return (_this_columnLayout_getColumnWidth = this.columnLayout.getColumnWidth(key3)) !== null && _this_columnLayout_getColumnWidth !== void 0 ? _this_columnLayout_getColumnWidth : 0;
  }
  getColumnMinWidth(key3) {
    let column = this.collection.columns.find((col) => col.key === key3);
    if (!column) return 0;
    return this.columnLayout.getColumnMinWidth(key3);
  }
  getColumnMaxWidth(key3) {
    let column = this.collection.columns.find((col) => col.key === key3);
    if (!column) return 0;
    return this.columnLayout.getColumnMaxWidth(key3);
  }
  // outside, where this is called, should call props.onColumnResizeStart...
  startResize(key3) {
    this.resizingColumn = key3;
  }
  // only way to call props.onColumnResize with the new size outside of Layout is to send the result back
  updateResizedColumns(key3, width) {
    let newControlled = new Map(Array.from(this.controlledColumns).map(([key4, entry]) => [
      key4,
      entry.props.width
    ]));
    let newSizes = this.columnLayout.resizeColumnWidth(this.virtualizer.visibleRect.width, this.collection, newControlled, this.uncontrolledWidths, key3, width);
    let map6 = new Map(Array.from(this.uncontrolledColumns).map(([key4]) => [
      key4,
      newSizes.get(key4)
    ]));
    map6.set(key3, width);
    this.uncontrolledWidths = map6;
    if (this.uncontrolledWidths.size > 0) this.virtualizer.relayoutNow({
      sizeChanged: true
    });
    return newSizes;
  }
  endResize() {
    this.resizingColumn = null;
  }
  buildCollection() {
    let loadingState = this.collection.body.props.loadingState;
    this.wasLoading = this.isLoading;
    this.isLoading = loadingState === "loading" || loadingState === "loadingMore";
    this.stickyColumnIndices = [];
    for (let column of this.collection.columns)
      if (column.props.isDragButtonCell || column.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column.key)) this.stickyColumnIndices.push(column.index);
    let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);
    this.controlledColumns = controlledColumns;
    this.uncontrolledColumns = uncontrolledColumns;
    let colWidths = this.columnLayout.recombineColumns(this.collection.columns, this.uncontrolledWidths, uncontrolledColumns, controlledColumns);
    this.columnWidths = this.columnLayout.buildColumnWidths(this.virtualizer.visibleRect.width, this.collection, colWidths);
    let header = this.buildHeader();
    let body = this.buildBody(0);
    this.lastPersistedKeys = null;
    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);
    return [
      header,
      body
    ];
  }
  buildHeader() {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("header", "header", rect);
    let y = 0;
    let width = 0;
    let children = [];
    for (let headerRow of this.collection.headerRows) {
      let layoutNode = this.buildChild(headerRow, 0, y);
      layoutNode.layoutInfo.parentKey = "header";
      y = layoutNode.layoutInfo.rect.maxY;
      width = Math.max(width, layoutNode.layoutInfo.rect.width);
      layoutNode.index = children.length;
      children.push(layoutNode);
    }
    rect.width = width;
    rect.height = y;
    this.layoutInfos.set("header", layoutInfo);
    return {
      layoutInfo,
      children,
      validRect: layoutInfo.rect
    };
  }
  buildHeaderRow(headerRow, x, y) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y, 0, 0);
    let row = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("headerrow", headerRow.key, rect);
    let height = 0;
    let columns = [];
    for (let cell2 of (0, $c5a24bc478652b5f$export$1005530eda016c13)(headerRow, this.collection)) {
      let layoutNode = this.buildChild(cell2, x, y);
      layoutNode.layoutInfo.parentKey = row.key;
      x = layoutNode.layoutInfo.rect.maxX;
      height = Math.max(height, layoutNode.layoutInfo.rect.height);
      layoutNode.index = columns.length;
      columns.push(layoutNode);
    }
    for (let [i2, layout] of columns.entries()) layout.layoutInfo.zIndex = columns.length - i2 + 1;
    this.setChildHeights(columns, height);
    rect.height = height;
    rect.width = x;
    return {
      layoutInfo: row,
      children: columns,
      validRect: rect
    };
  }
  setChildHeights(children, height) {
    for (let child of children) if (child.layoutInfo.rect.height !== height) {
      child.layoutInfo = child.layoutInfo.copy();
      this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);
      child.layoutInfo.rect.height = height;
    }
  }
  // used to get the column widths when rendering to the DOM
  getRenderedColumnWidth(node3) {
    var _node_colspan;
    let colspan = (_node_colspan = node3.colspan) !== null && _node_colspan !== void 0 ? _node_colspan : 1;
    var _node_colIndex;
    let colIndex = (_node_colIndex = node3.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node3.index;
    let width = 0;
    for (let i2 = colIndex; i2 < colIndex + colspan; i2++) {
      let column = this.collection.columns[i2];
      if ((column === null || column === void 0 ? void 0 : column.key) != null) width += this.columnWidths.get(column.key);
    }
    return width;
  }
  getEstimatedHeight(node3, width, height, estimatedHeight) {
    let isEstimated = false;
    if (height == null) {
      let previousLayoutNode = this.layoutNodes.get(node3.key);
      if (previousLayoutNode) {
        height = previousLayoutNode.layoutInfo.rect.height;
        isEstimated = node3 !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;
      } else {
        height = estimatedHeight;
        isEstimated = true;
      }
    }
    return {
      height,
      isEstimated
    };
  }
  buildColumn(node3, x, y) {
    var _node_props, _node_props1;
    let width = this.getRenderedColumnWidth(node3);
    let { height, isEstimated } = this.getEstimatedHeight(node3, width, this.headingHeight, this.estimatedHeadingHeight);
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, width, height);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node3.type, node3.key, rect);
    layoutInfo.isSticky = !this.disableSticky && (((_node_props = node3.props) === null || _node_props === void 0 ? void 0 : _node_props.isDragButtonCell) || ((_node_props1 = node3.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.isSelectionCell));
    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: layoutInfo.rect
    };
  }
  buildBody(y) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("rowgroup", "body", rect);
    let startY = y;
    let skipped = 0;
    let width = 0;
    let children = [];
    for (let [i2, node3] of [
      ...this.collection
    ].entries()) {
      var _this_rowHeight;
      let rowHeight = ((_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) + 1;
      if (y + rowHeight < this.validRect.y && !this.isValid(node3, y)) {
        y += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(node3, 0, y);
      layoutNode.layoutInfo.parentKey = "body";
      layoutNode.index = i2;
      y = layoutNode.layoutInfo.rect.maxY;
      width = Math.max(width, layoutNode.layoutInfo.rect.width);
      children.push(layoutNode);
      if (y > this.validRect.maxY) {
        y += (this.collection.size - (skipped + children.length)) * rowHeight;
        break;
      }
    }
    if (this.isLoading) {
      let rect2 = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(40, Math.max(y, 40), (width || this.virtualizer.visibleRect.width) - 80, children.length === 0 ? this.virtualizer.visibleRect.height - 80 : 60);
      let loader = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("loader", "loader", rect2);
      loader.parentKey = "body";
      loader.isSticky = !this.disableSticky && children.length === 0;
      this.layoutInfos.set("loader", loader);
      children.push({
        layoutInfo: loader,
        validRect: loader.rect
      });
      y = loader.rect.maxY;
      width = Math.max(width, rect2.width);
    } else if (children.length === 0) {
      let rect2 = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(40, Math.max(y, 40), this.virtualizer.visibleRect.width - 80, this.virtualizer.visibleRect.height - 80);
      let empty5 = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("empty", "empty", rect2);
      empty5.parentKey = "body";
      empty5.isSticky = !this.disableSticky;
      this.layoutInfos.set("empty", empty5);
      children.push({
        layoutInfo: empty5,
        validRect: empty5.rect
      });
      y = empty5.rect.maxY;
      width = Math.max(width, rect2.width);
    }
    rect.width = width;
    rect.height = y - startY;
    this.layoutInfos.set("body", layoutInfo);
    return {
      layoutInfo,
      children,
      validRect: layoutInfo.rect.intersection(this.validRect)
    };
  }
  buildNode(node3, x, y) {
    switch (node3.type) {
      case "headerrow":
        return this.buildHeaderRow(node3, x, y);
      case "item":
        return this.buildRow(node3, x, y);
      case "column":
      case "placeholder":
        return this.buildColumn(node3, x, y);
      case "cell":
        return this.buildCell(node3, x, y);
      default:
        throw new Error("Unknown node type " + node3.type);
    }
  }
  buildRow(node3, x, y) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("row", node3.key, rect);
    let children = [];
    let height = 0;
    for (let [i2, child] of [
      ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(node3, this.collection)
    ].entries()) if (child.type === "cell") {
      if (x > this.validRect.maxX) {
        let layoutNode = this.layoutNodes.get(child.key);
        if (layoutNode) {
          layoutNode.layoutInfo.rect.x = x;
          x += layoutNode.layoutInfo.rect.width;
        }
      } else {
        let layoutNode = this.buildChild(child, x, y);
        x = layoutNode.layoutInfo.rect.maxX;
        height = Math.max(height, layoutNode.layoutInfo.rect.height);
        layoutNode.index = i2;
        children.push(layoutNode);
      }
    }
    this.setChildHeights(children, height);
    rect.width = this.layoutInfos.get("header").rect.width;
    rect.height = height + 1;
    return {
      layoutInfo,
      children,
      validRect: rect.intersection(this.validRect)
    };
  }
  buildCell(node3, x, y) {
    var _node_props, _node_props1;
    let width = this.getRenderedColumnWidth(node3);
    let { height, isEstimated } = this.getEstimatedHeight(node3, width, this.rowHeight, this.estimatedRowHeight);
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, width, height);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node3.type, node3.key, rect);
    layoutInfo.isSticky = !this.disableSticky && (((_node_props = node3.props) === null || _node_props === void 0 ? void 0 : _node_props.isDragButtonCell) || ((_node_props1 = node3.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.isSelectionCell));
    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: rect
    };
  }
  getVisibleLayoutInfos(rect) {
    if (!this.validRect.containsRect(rect) && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = this.validRect.union(rect);
      this.rootNodes = this.buildCollection();
    }
    let res = [];
    this.buildPersistedIndices();
    for (let node3 of this.rootNodes) {
      res.push(node3.layoutInfo);
      this.addVisibleLayoutInfos(res, node3, rect);
    }
    return res;
  }
  addVisibleLayoutInfos(res, node3, rect) {
    if (!node3.children || node3.children.length === 0) return;
    switch (node3.layoutInfo.type) {
      case "header":
        for (let child of node3.children) {
          res.push(child.layoutInfo);
          this.addVisibleLayoutInfos(res, child, rect);
        }
        break;
      case "rowgroup": {
        let firstVisibleRow = this.binarySearch(node3.children, rect.topLeft, "y");
        let lastVisibleRow = this.binarySearch(node3.children, rect.bottomRight, "y");
        let persistedRowIndices = this.persistedIndices.get(node3.layoutInfo.key);
        let persistIndex = 0;
        while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < firstVisibleRow) {
          let idx = persistedRowIndices[persistIndex];
          if (idx < node3.children.length) {
            res.push(node3.children[idx].layoutInfo);
            this.addVisibleLayoutInfos(res, node3.children[idx], rect);
          }
          persistIndex++;
        }
        for (let i2 = firstVisibleRow; i2 <= lastVisibleRow; i2++) {
          while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i2) persistIndex++;
          res.push(node3.children[i2].layoutInfo);
          this.addVisibleLayoutInfos(res, node3.children[i2], rect);
        }
        while (persistedRowIndices && persistIndex < persistedRowIndices.length) {
          let idx = persistedRowIndices[persistIndex++];
          if (idx < node3.children.length) res.push(node3.children[idx].layoutInfo);
        }
        break;
      }
      case "headerrow":
      case "row": {
        let firstVisibleCell = this.binarySearch(node3.children, rect.topLeft, "x");
        let lastVisibleCell = this.binarySearch(node3.children, rect.topRight, "x");
        let stickyIndex = 0;
        let persistedCellIndices = this.persistedIndices.get(node3.layoutInfo.key) || this.stickyColumnIndices;
        while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell) {
          let idx = persistedCellIndices[stickyIndex];
          if (idx < node3.children.length) res.push(node3.children[idx].layoutInfo);
          stickyIndex++;
        }
        for (let i2 = firstVisibleCell; i2 <= lastVisibleCell; i2++) {
          while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i2) stickyIndex++;
          res.push(node3.children[i2].layoutInfo);
        }
        while (stickyIndex < persistedCellIndices.length) {
          let idx = persistedCellIndices[stickyIndex++];
          if (idx < node3.children.length) res.push(node3.children[idx].layoutInfo);
        }
        break;
      }
      default:
        throw new Error("Unknown node type " + node3.layoutInfo.type);
    }
  }
  binarySearch(items, point3, axis) {
    let low = 0;
    let high = items.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      let item2 = items[mid];
      if (axis === "x" && item2.layoutInfo.rect.maxX < point3.x || axis === "y" && item2.layoutInfo.rect.maxY < point3.y) low = mid + 1;
      else if (axis === "x" && item2.layoutInfo.rect.x > point3.x || axis === "y" && item2.layoutInfo.rect.y > point3.y) high = mid - 1;
      else return mid;
    }
    return Math.max(0, Math.min(items.length - 1, low));
  }
  buildPersistedIndices() {
    if (this.virtualizer.persistedKeys === this.lastPersistedKeys) return;
    this.lastPersistedKeys = this.virtualizer.persistedKeys;
    this.persistedIndices.clear();
    for (let key3 of this.virtualizer.persistedKeys) {
      let layoutInfo = this.layoutInfos.get(key3);
      while (layoutInfo && layoutInfo.parentKey) {
        let collectionNode = this.collection.getItem(layoutInfo.key);
        let indices = this.persistedIndices.get(layoutInfo.parentKey);
        if (!indices) {
          indices = collectionNode.type === "cell" || collectionNode.type === "column" ? [
            ...this.stickyColumnIndices
          ] : [];
          this.persistedIndices.set(layoutInfo.parentKey, indices);
        }
        let index4 = this.layoutNodes.get(layoutInfo.key).index;
        if (!indices.includes(index4)) indices.push(index4);
        layoutInfo = this.layoutInfos.get(layoutInfo.parentKey);
      }
    }
    for (let indices of this.persistedIndices.values()) indices.sort((a, b) => a - b);
  }
  getInitialLayoutInfo(layoutInfo) {
    let res = super.getInitialLayoutInfo(layoutInfo);
    res.transform = null;
    return res;
  }
  getFinalLayoutInfo(layoutInfo) {
    let res = super.getFinalLayoutInfo(layoutInfo);
    res.transform = null;
    return res;
  }
  // Checks if Chrome version is 105 or greater
  checkChrome105() {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    let isChrome105;
    if (window.navigator["userAgentData"]) isChrome105 = (_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((b) => b.brand === "Chromium" && Number(b.version) === 105);
    else {
      let regex = /Chrome\/(\d+)/;
      let matches3 = regex.exec(window.navigator.userAgent);
      isChrome105 = matches3 && matches3.length >= 2 && Number(matches3[1]) === 105;
    }
    return isChrome105;
  }
  getDropTargetFromPoint(x, y, isValidDropTarget) {
    var _this_virtualizer_layout_getVisibleLayoutInfos_find;
    x += this.virtualizer.visibleRect.x;
    y += this.virtualizer.visibleRect.y;
    y -= (_this_virtualizer_layout_getVisibleLayoutInfos_find = this.virtualizer.layout.getVisibleLayoutInfos(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, 1, 1)).find((info) => info.type === "headerrow")) === null || _this_virtualizer_layout_getVisibleLayoutInfos_find === void 0 ? void 0 : _this_virtualizer_layout_getVisibleLayoutInfos_find.rect.height;
    let key3;
    let point3 = new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y);
    let rectAtPoint = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point3.x, point3.y, 1, 1);
    let layoutInfos = this.virtualizer.layout.getVisibleLayoutInfos(rectAtPoint).filter((info) => info.type === "row");
    for (let layoutInfo2 of layoutInfos) if (layoutInfo2.rect.intersects(rectAtPoint)) key3 = layoutInfo2.key;
    if (key3 == null || this.collection.size === 0) return {
      type: "root"
    };
    let layoutInfo = this.getLayoutInfo(key3);
    let rect = layoutInfo.rect;
    let target = {
      type: "item",
      key: layoutInfo.key,
      dropPosition: "on"
    };
    if (!isValidDropTarget(target)) {
      if (y <= rect.y + rect.height / 2 && isValidDropTarget({
        ...target,
        dropPosition: "before"
      })) target.dropPosition = "before";
      else if (isValidDropTarget({
        ...target,
        dropPosition: "after"
      })) target.dropPosition = "after";
    } else if (y <= rect.y + 10 && isValidDropTarget({
      ...target,
      dropPosition: "before"
    })) target.dropPosition = "before";
    else if (y >= rect.maxY - 10 && isValidDropTarget({
      ...target,
      dropPosition: "after"
    })) target.dropPosition = "after";
    return target;
  }
  constructor(options) {
    super(options);
    this.columnWidths = /* @__PURE__ */ new Map();
    this.wasLoading = false;
    this.isLoading = false;
    this.lastPersistedKeys = null;
    this.persistedIndices = /* @__PURE__ */ new Map();
    this.collection = options.initialCollection;
    this.stickyColumnIndices = [];
    this.disableSticky = this.checkChrome105();
    this.columnLayout = options.columnLayout;
    let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);
    this.controlledColumns = controlledColumns;
    this.uncontrolledColumns = uncontrolledColumns;
    this.uncontrolledWidths = this.columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);
  }
};

// node_modules/@keystar/ui/dist/keystar-ui-listbox.js
var ListItem = forwardRefWithAs(function ListItem2(props, forwardedRef) {
  let {
    children,
    elementType: ElementType = "div",
    descriptionProps,
    keyboardShortcutProps,
    labelProps,
    isFocused,
    isHovered,
    isPressed,
    isSelected,
    ...otherProps
  } = props;
  let gridGutter = tokenSchema.size.space.regular;
  let contentGutter = tokenSchema.size.space.medium;
  let focusIndicatorWidth = tokenSchema.size.space.xsmall;
  let gridClassname = css({
    display: "grid",
    // listboxes (options) have selection indicators at the end, whilst menus have them at the start
    gridTemplateAreas: '". icon text . kbd checkmark ." ". icon description . kbd checkmark ."',
    gridTemplateColumns: `${gridGutter} auto 1fr ${contentGutter} auto ${tokenSchema.size.icon.regular} ${gridGutter}`,
    gridTemplateRows: "1fr auto",
    borderRadius: tokenSchema.size.radius.small,
    paddingBlock: tokenSchema.size.space.regular
  });
  let rootClassname = css({
    cursor: "default",
    color: tokenSchema.color.alias.foregroundIdle,
    display: "block",
    outline: 0,
    position: "relative",
    paddingInline: tokenSchema.size.space.small,
    // indicate when external link? e.g. `&[href^=http]`
    "a&": {
      cursor: "pointer"
    },
    "& .list-item-text": {
      marginBlock: `calc((${tokenSchema.size.icon.regular} - ${tokenSchema.typography.text.regular.capheight}) / 2)`
    },
    [`&:not([aria-disabled=true])`]: {
      "& .list-item-checkmark": {
        stroke: tokenSchema.color.alias.foregroundSelected
      },
      "& .list-item-text": {
        color: tokenSchema.color.foreground.neutralEmphasis
      },
      "& .list-item-icon": {
        color: tokenSchema.color.foreground.neutralSecondary
      }
    },
    // standard menu items: no selection indicator
    [`&[role=menuitem] .${gridClassname}`]: {
      gridTemplateAreas: '". icon text . kbd ." ". icon description . kbd ."',
      gridTemplateColumns: `${gridGutter} auto 1fr ${contentGutter} auto ${gridGutter}`
    },
    [[
      // selectable menu items: selection indicator at the start
      `&[role=menuitemcheckbox] .${gridClassname}, &[role=menuitemradio] .${gridClassname}`,
      // menus with _any_ selectable items must make space for the selection indicator
      `[data-selection=single] &[role=menuitem] .${gridClassname}, [data-selection=multiple] &[role=menuitem] .${gridClassname}`
    ].join(", ")]: {
      gridTemplateAreas: '". checkmark icon text . kbd ." ". checkmark icon description . kbd ."',
      gridTemplateColumns: `${tokenSchema.size.space.small} ${tokenSchema.size.icon.medium} auto 1fr ${contentGutter} auto ${gridGutter}`
    },
    // hover
    [`&[aria-disabled=false]:hover .${gridClassname}, &[data-hovered] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered,
      color: tokenSchema.color.alias.foregroundHovered
    },
    // focus
    [`&[aria-disabled=false]:focus .${gridClassname}, &[data-focused] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered,
      color: tokenSchema.color.alias.foregroundHovered
    },
    // emphasise `kbd` during interaction
    "&[aria-disabled=false]:hover kbd, &[data-hovered] kbd, &[aria-disabled=false]:focus kbd, &[data-focused] kbd": {
      color: tokenSchema.color.alias.foregroundIdle
    },
    // press
    [`&[aria-disabled=false]:active .${gridClassname}, &[data-pressed] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundPressed,
      color: tokenSchema.color.alias.foregroundPressed
    },
    // focus indicator
    "&[data-focused]": {
      // [`& .${gridClassname}`]: {
      //   backgroundColor: tokenSchema.color.alias.backgroundSelected,
      // },
      "&::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        borderRadius: focusIndicatorWidth,
        content: '""',
        insetBlock: tokenSchema.size.space.xsmall,
        insetInlineStart: 0,
        position: "absolute",
        width: focusIndicatorWidth
      }
    },
    // disabled
    "&[aria-disabled=true]": {
      color: tokenSchema.color.alias.foregroundDisabled,
      "& kbd": {
        color: "currentColor"
      },
      "& .list-item-checkmark": {
        stroke: "currentColor"
      }
    }
  });
  const slots = {
    text: {
      ...labelProps,
      color: "inherit",
      gridArea: "text",
      weight: "medium",
      UNSAFE_className: "list-item-text"
    },
    icon: {
      gridArea: "icon",
      marginEnd: "regular",
      UNSAFE_className: "list-item-icon"
    },
    description: {
      color: "neutralSecondary",
      gridArea: "description",
      marginY: "small",
      size: "small",
      ...descriptionProps
    },
    kbd: {
      UNSAFE_className: css({
        alignItems: "center",
        color: tokenSchema.color.foreground.neutralTertiary,
        display: "flex",
        gridArea: "kbd",
        height: tokenSchema.size.icon.regular
      }),
      ...keyboardShortcutProps
    }
  };
  return (0, import_jsx_runtime4.jsx)(
    ElementType,
    {
      ...toDataAttributes({
        focused: isFocused || void 0,
        hovered: isHovered || void 0,
        pressed: isPressed || void 0
      }),
      ...otherProps,
      ref: forwardedRef,
      className: classNames(rootClassname),
      children: (0, import_jsx_runtime4.jsx)("div", {
        className: gridClassname,
        children: (0, import_jsx_runtime4.jsx)(ClearSlots, {
          children: (0, import_jsx_runtime4.jsxs)(SlotProvider, {
            slots,
            children: [children, isSelected && (0, import_jsx_runtime4.jsx)(Icon, {
              src: checkIcon,
              slot: "checkmark",
              strokeScaling: false,
              gridArea: "checkmark",
              UNSAFE_className: "list-item-checkmark"
            })]
          })
        })
      })
    }
  );
});
var localizedMessages = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    loadingMore: "جارٍ تحميل المزيد..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    loadingMore: "Зареждане на още..."
  },
  "cs-CZ": {
    loading: "Načítání...",
    loadingMore: "Načítání dalších..."
  },
  "da-DK": {
    loading: "Indlæser ...",
    loadingMore: "Indlæser flere ..."
  },
  "de-DE": {
    loading: "Laden...",
    loadingMore: "Mehr laden ..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    loadingMore: "Φόρτωση περισσότερων..."
  },
  "en-US": {
    loading: "Loading…",
    loadingMore: "Loading more…"
  },
  "es-ES": {
    loading: "Cargando…",
    loadingMore: "Cargando más…"
  },
  "et-EE": {
    loading: "Laadimine...",
    loadingMore: "Laadi rohkem..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    loadingMore: "Ladataan lisää…"
  },
  "fr-FR": {
    loading: "Chargement...",
    loadingMore: "Chargement supplémentaire..."
  },
  "he-IL": {
    loading: "טוען...",
    loadingMore: "טוען עוד..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    loadingMore: "Továbbiak betöltése folyamatban…"
  },
  "it-IT": {
    loading: "Caricamento...",
    loadingMore: "Caricamento altri..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    loadingMore: "さらに読み込み中..."
  },
  "ko-KR": {
    loading: "로드 중",
    loadingMore: "추가 로드 중"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    loadingMore: "Įkeliama daugiau..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    loadingMore: "Tiek ielādēts vēl..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    loadingMore: "Laster inn flere ..."
  },
  "nl-NL": {
    loading: "Laden...",
    loadingMore: "Meer laden..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    loadingMore: "Wczytywanie większej liczby..."
  },
  "pt-BR": {
    loading: "Carregando...",
    loadingMore: "Carregando mais..."
  },
  "pt-PT": {
    loading: "A carregar...",
    loadingMore: "A carregar mais..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    loadingMore: "Se încarcă mai multe..."
  },
  "ru-RU": {
    loading: "Загрузка...",
    loadingMore: "Дополнительная загрузка..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    loadingMore: "Načítava sa viac..."
  },
  "sl-SI": {
    loading: "Nalaganje...",
    loadingMore: "Nalaganje več vsebine..."
  },
  "sr-SP": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "sv-SE": {
    loading: "Läser in...",
    loadingMore: "Läser in mer..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    loadingMore: "Daha fazla yükleniyor..."
  },
  "uk-UA": {
    loading: "Завантаження…",
    loadingMore: "Завантаження інших об’єктів..."
  },
  "zh-CN": {
    loading: "正在加载...",
    loadingMore: "正在加载更多..."
  },
  "zh-T": {
    loading: "正在載入",
    loadingMore: "正在載入更多…"
  }
};
var ListBoxContext = (0, import_react21.createContext)(null);
function useListBoxContext() {
  let context = (0, import_react21.useContext)(ListBoxContext);
  assert(!!context, "ListBoxContext is missing");
  return context;
}
function ListBoxOption(props) {
  let {
    item: item2,
    shouldSelectOnPressUp,
    shouldFocusOnHover,
    shouldUseVirtualFocus
  } = props;
  let {
    rendered,
    key: key3
  } = item2;
  let state2 = useListBoxContext();
  let ref2 = (0, import_react21.useRef)(null);
  let {
    optionProps,
    labelProps,
    descriptionProps,
    isSelected,
    isDisabled,
    isFocused,
    isPressed
  } = $293f70390ea03370$export$497855f14858aa34({
    "aria-label": item2["aria-label"],
    key: key3,
    shouldSelectOnPressUp,
    shouldFocusOnHover,
    isVirtualized: true,
    shouldUseVirtualFocus
  }, state2, ref2);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    ...props,
    isDisabled
  });
  let {
    isFocusVisible: isFocusVisible$1,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let contents = isReactText(rendered) ? (0, import_jsx_runtime4.jsx)(Text, {
    children: rendered
  }) : rendered;
  let isKeyboardModality = $507fabe10e71c6fb$export$b9b3dfddab17db27();
  return (0, import_jsx_runtime4.jsx)(ListItem, {
    descriptionProps,
    labelProps,
    isFocused: shouldUseVirtualFocus ? isFocused && isKeyboardModality : isFocusVisible$1,
    isHovered: isHovered && !shouldFocusOnHover || isFocused && !isKeyboardModality,
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(optionProps, focusProps, shouldFocusOnHover ? {} : hoverProps),
    isPressed,
    isSelected,
    ref: ref2,
    children: contents
  });
}
function ListBoxSection(props) {
  let {
    children,
    layoutInfo,
    headerLayoutInfo,
    virtualizer,
    item: item2
  } = props;
  let {
    headingProps,
    groupProps
  } = $af383d3bef1cfdc9$export$c3f9f39876e4bc7({
    heading: item2.rendered,
    "aria-label": item2["aria-label"]
  });
  let headerRef = (0, import_react21.useRef)(null);
  $47736c1e63ba1c6d$export$1da781778207e0a2({
    layoutInfo: headerLayoutInfo,
    virtualizer,
    ref: headerRef
  });
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let state2 = useListBoxContext();
  return (0, import_jsx_runtime4.jsxs)(import_react21.Fragment, {
    children: [(0, import_jsx_runtime4.jsxs)("div", {
      role: "presentation",
      ref: headerRef,
      style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(headerLayoutInfo, direction),
      children: [item2.key !== state2.collection.getFirstKey() && (0, import_jsx_runtime4.jsx)(Divider, {
        role: "presentation",
        elementType: "div",
        size: "medium",
        UNSAFE_className: css({
          margin: tokenSchema.size.space.medium
        })
      }), item2.rendered && (0, import_jsx_runtime4.jsx)(Text, {
        ...headingProps,
        casing: "uppercase",
        color: "neutralSecondary",
        size: "small",
        weight: "medium",
        UNSAFE_className: css({
          padding: tokenSchema.size.space.medium
        }),
        children: item2.rendered
      })]
    }), (0, import_jsx_runtime4.jsx)("div", {
      ...groupProps,
      style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, direction),
      className: classNames(css({}), "ListBoxSection"),
      children
    })]
  });
}
function useListBoxLayout(state2) {
  let {
    scale
  } = useProvider();
  let collator = $325a3faab7a68acd$export$a16aca283550c30d({
    usage: "search",
    sensitivity: "base"
  });
  let layout = (0, import_react21.useMemo)(() => new $61ef60fc9b1041f4$export$cacbb3924155d68e({
    estimatedRowHeight: scale === "large" ? 48 : 32,
    estimatedHeadingHeight: scale === "large" ? 33 : 26,
    padding: scale === "large" ? 5 : 4,
    loaderHeight: 40,
    placeholderHeight: scale === "large" ? 48 : 32,
    collator
  }), [collator, scale]);
  layout.collection = state2.collection;
  layout.disabledKeys = state2.disabledKeys;
  return layout;
}
function ListBoxBase(props, forwardedRef) {
  let {
    layout,
    state: state2,
    shouldSelectOnPressUp,
    focusOnPointerEnter,
    shouldUseVirtualFocus,
    domProps = {},
    transitionDuration = 0,
    onScroll
  } = props;
  let {
    listBoxProps
  } = $c132121280ec012d$export$50eacbbf140a3141({
    ...props,
    keyboardDelegate: layout,
    isVirtualized: true
  }, state2, forwardedRef);
  let styleProps = useStyleProps(props);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  layout.isLoading = !!props.isLoading;
  let renderWrapper = (parent, reusableView, children, renderChildren) => {
    if (reusableView.viewType === "section") {
      var _children$find;
      return (0, import_jsx_runtime4.jsx)(ListBoxSection, {
        item: reusableView.content,
        layoutInfo: reusableView.layoutInfo,
        virtualizer: reusableView.virtualizer,
        headerLayoutInfo: (_children$find = children.find((c) => c.viewType === "header")) === null || _children$find === void 0 ? void 0 : _children$find.layoutInfo,
        children: renderChildren(children.filter((c) => c.viewType === "item"))
      }, reusableView.key);
    }
    return (0, import_jsx_runtime4.jsx)($ccf8a0a04e4175ae$export$6796df8ba7398521, {
      layoutInfo: reusableView.layoutInfo,
      virtualizer: reusableView.virtualizer,
      parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
      children: reusableView.rendered
    }, reusableView.key);
  };
  return (0, import_jsx_runtime4.jsx)(ListBoxContext.Provider, {
    value: state2,
    children: (0, import_jsx_runtime4.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
      children: (0, import_jsx_runtime4.jsx)($6d0a5c394373ae64$export$89be5a243e59c4b2, {
        ...styleProps,
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(listBoxProps, domProps),
        ref: forwardedRef,
        focusedKey: state2.selectionManager.focusedKey,
        autoFocus: !!props.autoFocus,
        sizeToFit: "height",
        scrollDirection: "vertical",
        layout,
        collection: state2.collection,
        renderWrapper,
        transitionDuration,
        isLoading: props.isLoading,
        onLoadMore: props.onLoadMore,
        shouldUseVirtualFocus,
        onScroll,
        children: (type, item2) => {
          if (type === "item") {
            return (0, import_jsx_runtime4.jsx)(ListBoxOption, {
              item: item2,
              shouldSelectOnPressUp,
              shouldFocusOnHover: focusOnPointerEnter,
              shouldUseVirtualFocus
            });
          } else if (type === "loader") {
            return (0, import_jsx_runtime4.jsx)("div", {
              role: "option",
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                height: "100%"
              },
              children: (0, import_jsx_runtime4.jsx)(ProgressCircle, {
                isIndeterminate: true,
                size: "small",
                "aria-label": state2.collection.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
              })
            });
          } else if (type === "placeholder") {
            let emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
            if (emptyState == null) {
              return null;
            }
            return (0, import_jsx_runtime4.jsx)("div", {
              role: "option",
              children: emptyState
            });
          }
        }
      })
    })
  });
}
var _ListBoxBase = (0, import_react21.forwardRef)(ListBoxBase);
function ListBox(props, forwardedRef) {
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let state2 = $e72dd72e1c76a225$export$2f645645f7bca764(props);
  let layout = useListBoxLayout(state2);
  return (0, import_jsx_runtime4.jsx)(_ListBoxBase, {
    ...props,
    ref: domRef,
    state: state2,
    layout
  });
}
var _ListBox = (0, import_react21.forwardRef)(ListBox);
var listStyles = css({
  borderRadius: "inherit",
  maxHeight: "inherit",
  // maxWidth: tokenSchema.size.dialog.small,
  outline: 0,
  overflowY: "auto",
  paddingBlock: tokenSchema.size.space.small,
  userSelect: "none"
});

// node_modules/@keystar/ui/dist/keystar-ui-editor.js
var import_react24 = __toESM(require_react());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min2 = Math.min;
var max3 = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start2, value, end) {
  return max3(start2, min2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list5 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list5 = list5.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list5 = list5.concat(list5.map(getOppositeAlignmentPlacement));
    }
  }
  return list5;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config3) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config3;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data2
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element3 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element3))) != null ? _await$platform$isEle : true) ? element3 : element3.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset5 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset5, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min2(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min2(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max3(overflow.left, 0);
        const xMax = max3(overflow.right, 0);
        const yMin = max3(overflow.top, 0);
        const yMax = max3(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max3(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max3(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node3) {
  if (isNode(node3)) {
    return (node3.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node3) {
  var _node$ownerDocument;
  return (node3 == null || (_node$ownerDocument = node3.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node3) {
  var _ref;
  return (_ref = (isNode(node3) ? node3.ownerDocument : node3.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element3) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element3);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element3) {
  return ["table", "td", "th"].includes(getNodeName(element3));
}
function isContainingBlock(element3) {
  const webkit2 = isWebKit();
  const css2 = getComputedStyle2(element3);
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit2 && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit2 && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element3) {
  let currentNode = getParentNode(element3);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node3) {
  return ["html", "body", "#document"].includes(getNodeName(node3));
}
function getComputedStyle2(element3) {
  return getWindow(element3).getComputedStyle(element3);
}
function getNodeScroll(element3) {
  if (isElement(element3)) {
    return {
      scrollLeft: element3.scrollLeft,
      scrollTop: element3.scrollTop
    };
  }
  return {
    scrollLeft: element3.pageXOffset,
    scrollTop: element3.pageYOffset
  };
}
function getParentNode(node3) {
  if (getNodeName(node3) === "html") {
    return node3;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node3.assignedSlot || // DOM Element detected.
    node3.parentNode || // ShadowRoot detected.
    isShadowRoot(node3) && node3.host || // Fallback.
    getDocumentElement(node3)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node3) {
  const parentNode2 = getParentNode(node3);
  if (isLastTraversableNode(parentNode2)) {
    return node3.ownerDocument ? node3.ownerDocument.body : node3.body;
  }
  if (isHTMLElement(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node3, list5, traverseIframes) {
  var _node$ownerDocument2;
  if (list5 === void 0) {
    list5 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node3);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node3.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list5.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list5.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element3) {
  const css2 = getComputedStyle2(element3);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element3);
  const offsetWidth = hasOffset ? element3.offsetWidth : width;
  const offsetHeight = hasOffset ? element3.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element3) {
  return !isElement(element3) ? element3.contextElement : element3;
}
function getScale(element3) {
  const domElement = unwrapElement(element3);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element3) {
  const win = getWindow(element3);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element3, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element3)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element3, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element3.getBoundingClientRect();
  const domElement = unwrapElement(element3);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element3);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect2.left + visualOffsets.x) / scale.x;
  let y = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element3) {
  return topLayerSelectors.some((selector) => {
    try {
      return element3.matches(selector);
    } catch (e3) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element3) {
  return Array.from(element3.getClientRects());
}
function getWindowScrollBarX(element3) {
  return getBoundingClientRect(getDocumentElement(element3)).left + getNodeScroll(element3).scrollLeft;
}
function getDocumentRect(element3) {
  const html2 = getDocumentElement(element3);
  const scroll = getNodeScroll(element3);
  const body = element3.ownerDocument.body;
  const width = max3(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max3(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element3);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max3(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element3, strategy) {
  const win = getWindow(element3);
  const html2 = getDocumentElement(element3);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element3, strategy) {
  const clientRect2 = getBoundingClientRect(element3, true, strategy === "fixed");
  const top = clientRect2.top + element3.clientTop;
  const left = clientRect2.left + element3.clientLeft;
  const scale = isHTMLElement(element3) ? getScale(element3) : createCoords(1);
  const width = element3.clientWidth * scale.x;
  const height = element3.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element3, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element3, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element3));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element3);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element3, stopNode) {
  const parentNode2 = getParentNode(element3);
  if (parentNode2 === stopNode || !isElement(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle2(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element3, cache) {
  const cachedResult2 = cache.get(element3);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element3, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element3).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element3) : element3;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element3, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element3, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element3,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element3) ? [] : getClippingElementAncestors(element3, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element3, clippingAncestor, strategy);
    accRect.top = max3(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max3(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element3, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element3) {
  const {
    width,
    height
  } = getCssDimensions(element3);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element3, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element3, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll.scrollLeft - offsets.x;
  const y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element3) {
  return getComputedStyle2(element3).position === "static";
}
function getTrueOffsetParent(element3, polyfill) {
  if (!isHTMLElement(element3) || getComputedStyle2(element3).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element3);
  }
  return element3.offsetParent;
}
function getOffsetParent(element3, polyfill) {
  const win = getWindow(element3);
  if (isTopLayer(element3)) {
    return win;
  }
  if (!isHTMLElement(element3)) {
    let svgOffsetParent = getParentNode(element3);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element3, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element3) || win;
}
var getElementRects = async function(data2) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data2.floating);
  return {
    reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element3) {
  return getComputedStyle2(element3).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element3, onMove) {
  let io = null;
  let timeoutId2;
  const root2 = getDocumentElement(element3);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId2);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element3.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max3(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element3);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React2 = __toESM(require_react(), 1);
var import_react22 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react22.useLayoutEffect : import_react22.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys3;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a[i2], b[i2])) {
          return false;
        }
      }
      return true;
    }
    keys3 = Object.keys(a);
    length = keys3.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys3[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key3 = keys3[i2];
      if (key3 === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key3], b[key3])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element3) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element3.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element3, value) {
  const dpr = getDPR(element3);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref2 = React2.useRef(value);
  index(() => {
    ref2.current = value;
  });
  return ref2;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform3 = true,
    whileElementsMounted,
    open
  } = options;
  const [data2, setData] = React2.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React2.useState(null);
  const [_floating, _setFloating] = React2.useState(null);
  const setReference = React2.useCallback((node3) => {
    if (node3 !== referenceRef.current) {
      referenceRef.current = node3;
      _setReference(node3);
    }
  }, []);
  const setFloating = React2.useCallback((node3) => {
    if (node3 !== floatingRef.current) {
      floatingRef.current = node3;
      _setFloating(node3);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React2.useRef(null);
  const floatingRef = React2.useRef(null);
  const dataRef = React2.useRef(data2);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React2.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config3 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config3.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config3).then((data3) => {
      const fullData = {
        ...data3,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data3) => ({
        ...data3,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React2.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React2.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React2.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React2.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data2.x);
    const y = roundByDPR(elements.floating, data2.y);
    if (transform3) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform3, elements.floating, data2.x, data2.y]);
  return React2.useMemo(() => ({
    ...data2,
    update,
    refs,
    elements,
    floatingStyles
  }), [data2, update, refs, elements, floatingStyles]);
}
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});

// node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
var React3 = __toESM(require_react());
var import_react23 = __toESM(require_react());

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches2 = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element3) {
  var _element$getRootNode;
  return element3 === null || element3 === void 0 ? void 0 : (_element$getRootNode = element3.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element3);
} : function(element3) {
  return element3 === null || element3 === void 0 ? void 0 : element3.ownerDocument;
};
var isInert = function isInert2(node3, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node3 === null || node3 === void 0 ? void 0 : (_node$getAttribute = node3.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node3, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node3 && isInert2(node3.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node3) {
  var _node$getAttribute2;
  var attValue = node3 === null || node3 === void 0 ? void 0 : (_node$getAttribute2 = node3.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node3, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter2) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches2.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter2);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element3 = elementsToCheck.shift();
    if (isInert(element3, false)) {
      continue;
    }
    if (element3.tagName === "SLOT") {
      var assigned = element3.assignedElements();
      var content3 = assigned.length ? assigned : element3.children;
      var nestedCandidates = getCandidatesIteratively2(content3, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element3,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches2.call(element3, candidateSelector);
      if (validCandidate && options.filter(element3) && (includeContainer || !elements.includes(element3))) {
        candidates.push(element3);
      }
      var shadowRoot = element3.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element3);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element3));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element3.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element3,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element3.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node3) {
  return !isNaN(parseInt(node3.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node3) {
  if (!node3) {
    throw new Error("No node provided");
  }
  if (node3.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node3.tagName) || isContentEditable(node3)) && !hasTabIndex(node3)) {
      return 0;
    }
  }
  return node3.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node3, isScope) {
  var tabIndex = getTabIndex(node3);
  if (tabIndex < 0 && isScope && !hasTabIndex(node3)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node3) {
  return node3.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node3) {
  return isInput(node3) && node3.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node3) {
  var r2 = node3.tagName === "DETAILS" && Array.prototype.slice.apply(node3.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node3) {
  if (!node3.name) {
    return true;
  }
  var radioScope = node3.form || getRootNode(node3);
  var queryRadios = function queryRadios2(name2) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node3.name));
  } else {
    try {
      radioSet = queryRadios(node3.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node3.form);
  return !checked || checked === node3;
};
var isRadio = function isRadio2(node3) {
  return isInput(node3) && node3.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node3) {
  return isRadio(node3) && !isTabbableRadio(node3);
};
var isNodeAttached = function isNodeAttached2(node3) {
  var _nodeRoot;
  var nodeRoot = node3 && getRootNode(node3);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node3) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node3 !== null && node3 !== void 0 && (_node$ownerDocument = node3.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node3));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node3) {
  var _node$getBoundingClie = node3.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node3, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node3).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches2.call(node3, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node3.parentElement : node3;
  if (matches2.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node3;
      while (node3) {
        var parentElement = node3.parentElement;
        var rootNode = getRootNode(node3);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node3);
        } else if (node3.assignedSlot) {
          node3 = node3.assignedSlot;
        } else if (!parentElement && rootNode !== node3.ownerDocument) {
          node3 = rootNode.host;
        } else {
          node3 = parentElement;
        }
      }
      node3 = originalNode;
    }
    if (isNodeAttached(node3)) {
      return !node3.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node3);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node3) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node3.tagName)) {
    var parentNode2 = node3.parentElement;
    while (parentNode2) {
      if (parentNode2.tagName === "FIELDSET" && parentNode2.disabled) {
        for (var i2 = 0; i2 < parentNode2.children.length; i2++) {
          var child = parentNode2.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches2.call(parentNode2, "fieldset[disabled] *") ? true : !child.contains(node3);
          }
        }
        return true;
      }
      parentNode2 = parentNode2.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node3) {
  if (node3.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node3) || isHiddenInput(node3) || isHidden(node3, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node3) || isDisabledFromFieldset(node3)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node3) {
  if (isNonTabbableRadio(node3) || getTabIndex(node3) < 0 || !isNodeMatchingSelectorFocusable(options, node3)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item2, i2) {
    var isScope = !!item2.scopeParent;
    var element3 = isScope ? item2.scopeParent : item2;
    var candidateTabindex = getSortOrderTabIndex(element3, isScope);
    var elements = isScope ? sortByOrder2(item2.candidates) : element3;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element3);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item: item2,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
var import_react_dom5 = __toESM(require_react_dom());
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key3 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key3)) {
          target[key3] = source[key3];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var index2 = typeof document !== "undefined" ? import_react23.useLayoutEffect : import_react23.useEffect;
var serverHandoffComplete = false;
var count = 0;
var genId = () => "floating-ui-" + count++;
function useFloatingId() {
  const [id, setId] = React3.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React3.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
}
var useReactId = React3["useId".toString()];
var useId2 = useReactId || useFloatingId;
var FloatingArrow = React3.forwardRef(function FloatingArrow2(_ref, ref2) {
  let {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow6
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform: transform3,
      ...restStyle
    } = {},
    ...rest
  } = _ref;
  if (true) {
    if (!ref2) {
      console.warn("Floating UI: The `ref` prop is required for the `FloatingArrow`", "component.");
    }
  }
  const clipPathId = useId2();
  if (!floating) {
    return null;
  }
  strokeWidth *= 2;
  const halfStrokeWidth = strokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const [side, alignment] = placement.split("-");
  const isRTL2 = platform.isRTL(floating);
  const isCustomShape = !!d;
  const isVerticalSide = side === "top" || side === "bottom";
  const yOffsetProp = staticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = staticOffset && alignment === "end" ? "right" : "left";
  if (staticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow6 == null ? void 0 : arrow6.x) != null ? staticOffset || arrow6.x : "";
  const arrowY = (arrow6 == null ? void 0 : arrow6.y) != null ? staticOffset || arrow6.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return React3.createElement("svg", _extends({}, rest, {
    "aria-hidden": true,
    ref: ref2,
    width: isCustomShape ? width : width + strokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + strokeWidth / 2 + "px)",
      transform: "" + rotation + (transform3 != null ? transform3 : ""),
      ...restStyle
    }
  }), strokeWidth > 0 && React3.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: strokeWidth + (d ? 0 : 1),
    d: dValue
  }), React3.createElement("path", {
    stroke: strokeWidth && !d ? rest.fill : "none",
    d: dValue
  }), React3.createElement("clipPath", {
    id: clipPathId
  }, React3.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + strokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map6 = /* @__PURE__ */ new Map();
  return {
    emit(event, data2) {
      var _map$get;
      (_map$get = map6.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data2));
    },
    on(event, listener) {
      map6.set(event, [...map6.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map6.set(event, ((_map$get2 = map6.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
var FloatingNodeContext = React3.createContext(null);
var FloatingTreeContext = React3.createContext(null);
var useFloatingTree = () => React3.useContext(FloatingTreeContext);
function getDocument(node3) {
  return (node3 == null ? void 0 : node3.ownerDocument) || document;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getWindow2(value) {
  return getDocument(value).defaultView || window;
}
function isElement2(value) {
  return value ? value instanceof Element || value instanceof getWindow2(value).Element : false;
}
function isShadowRoot2(node3) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow2(node3).ShadowRoot;
  return node3 instanceof OwnElement || node3 instanceof ShadowRoot;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot2(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function createAttribute(name2) {
  return "data-floating-ui-" + name2;
}
var safePolygonIdentifier = createAttribute("safe-polygon");
var FloatingDelayGroupContext = React3.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: () => {
  },
  setState: () => {
  },
  isInstantPhase: false
});
function activeElement(doc4) {
  let activeElement2 = doc4.activeElement;
  while (((_activeElement = activeElement2) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {
    var _activeElement, _activeElement$shadow;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
var getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, direction) {
  const allTabbable = tabbable(container, getTabbableOptions());
  if (direction === "prev") {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element3) => {
    element3.dataset.tabindex = element3.getAttribute("tabindex") || "";
    element3.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll("[data-tabindex]");
  elements.forEach((element3) => {
    const tabindex = element3.dataset.tabindex;
    delete element3.dataset.tabindex;
    if (tabindex) {
      element3.setAttribute("tabindex", tabindex);
    } else {
      element3.removeAttribute("tabindex");
    }
  });
}
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
var FocusGuard = React3.forwardRef(function FocusGuard2(props, ref2) {
  const [role, setRole] = React3.useState();
  index2(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  const restProps = {
    ref: ref2,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return React3.createElement("span", _extends({}, props, restProps));
});
var PortalContext = React3.createContext(null);
function useFloatingPortalNode(_temp) {
  let {
    id,
    root: root2
  } = _temp === void 0 ? {} : _temp;
  const [portalNode, setPortalNode] = React3.useState(null);
  const uniqueId = useId2();
  const portalContext = usePortalContext();
  const data2 = React3.useMemo(() => ({
    id,
    root: root2,
    portalContext,
    uniqueId
  }), [id, root2, portalContext, uniqueId]);
  const dataRef = React3.useRef();
  index2(() => {
    return () => {
      portalNode == null ? void 0 : portalNode.remove();
    };
  }, [portalNode, data2]);
  index2(() => {
    if (dataRef.current === data2) return;
    dataRef.current = data2;
    const {
      id: id2,
      root: root3,
      portalContext: portalContext2,
      uniqueId: uniqueId2
    } = data2;
    const existingIdRoot = id2 ? document.getElementById(id2) : null;
    const attr = createAttribute("portal");
    if (existingIdRoot) {
      const subRoot = document.createElement("div");
      subRoot.id = uniqueId2;
      subRoot.setAttribute(attr, "");
      existingIdRoot.appendChild(subRoot);
      setPortalNode(subRoot);
    } else {
      let container = root3 || (portalContext2 == null ? void 0 : portalContext2.portalNode);
      if (container && !isElement2(container)) container = container.current;
      container = container || document.body;
      let idWrapper = null;
      if (id2) {
        idWrapper = document.createElement("div");
        idWrapper.id = id2;
        container.appendChild(idWrapper);
      }
      const subRoot = document.createElement("div");
      subRoot.id = uniqueId2;
      subRoot.setAttribute(attr, "");
      container = idWrapper || container;
      container.appendChild(subRoot);
      setPortalNode(subRoot);
    }
  }, [data2]);
  return portalNode;
}
function FloatingPortal(_ref) {
  let {
    children,
    id,
    root: root2 = null,
    preserveTabOrder = true
  } = _ref;
  const portalNode = useFloatingPortalNode({
    id,
    root: root2
  });
  const [focusManagerState, setFocusManagerState] = React3.useState(null);
  const beforeOutsideRef = React3.useRef(null);
  const afterOutsideRef = React3.useRef(null);
  const beforeInsideRef = React3.useRef(null);
  const afterInsideRef = React3.useRef(null);
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root2 || portalNode)
  );
  React3.useEffect(() => {
    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);
  return React3.createElement(PortalContext.Provider, {
    value: React3.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode])
  }, shouldRenderGuards && portalNode && React3.createElement(FocusGuard, {
    "data-type": "outside",
    ref: beforeOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _beforeInsideRef$curr;
        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();
      } else {
        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        prevTabbable == null ? void 0 : prevTabbable.focus();
      }
    }
  }), shouldRenderGuards && portalNode && React3.createElement("span", {
    "aria-owns": portalNode.id,
    style: HIDDEN_STYLES
  }), portalNode && (0, import_react_dom5.createPortal)(children, portalNode), shouldRenderGuards && portalNode && React3.createElement(FocusGuard, {
    "data-type": "outside",
    ref: afterOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _afterInsideRef$curre;
        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();
      } else {
        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        nextTabbable == null ? void 0 : nextTabbable.focus();
        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));
      }
    }
  }));
}
var usePortalContext = () => React3.useContext(PortalContext);
var VisuallyHiddenDismiss = React3.forwardRef(function VisuallyHiddenDismiss2(props, ref2) {
  return React3.createElement("button", _extends({}, props, {
    type: "button",
    ref: ref2,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
var FloatingListContext = React3.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
var identifier = createAttribute("scroll-lock");
var FloatingOverlay = React3.forwardRef(function FloatingOverlay2(_ref, ref2) {
  let {
    lockScroll = false,
    ...rest
  } = _ref;
  index2(() => {
    var _window$visualViewpor, _window$visualViewpor2;
    if (!lockScroll) {
      return;
    }
    const alreadyLocked = document.body.hasAttribute(identifier);
    if (alreadyLocked) {
      return;
    }
    document.body.setAttribute(identifier, "");
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {
      Object.assign(document.body.style, {
        overflow: "hidden",
        [paddingProp]: scrollbarWidth + "px"
      });
      return () => {
        document.body.removeAttribute(identifier);
        Object.assign(document.body.style, {
          overflow: "",
          [paddingProp]: ""
        });
      };
    }
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    Object.assign(document.body.style, {
      position: "fixed",
      overflow: "hidden",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0",
      [paddingProp]: scrollbarWidth + "px"
    });
    return () => {
      Object.assign(document.body.style, {
        position: "",
        overflow: "",
        top: "",
        left: "",
        right: "",
        [paddingProp]: ""
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return React3.createElement("div", _extends({
    ref: ref2
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
var useInsertionEffect = React3["useInsertionEffect".toString()];
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref2 = React3.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref2.current = callback;
  });
  return React3.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref2.current == null ? void 0 : ref2.current(...args);
  }, []);
}
function useFloating2(options) {
  var _options$elements;
  if (options === void 0) {
    options = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options;
  const [_domReference, setDomReference] = React3.useState(null);
  const domReference = ((_options$elements = options.elements) == null ? void 0 : _options$elements.reference) || _domReference;
  const position2 = useFloating(options);
  const tree = useFloatingTree();
  const onOpenChange = useEffectEvent((open2, event) => {
    if (open2) {
      dataRef.current.openEvent = event;
    }
    unstable_onOpenChange == null ? void 0 : unstable_onOpenChange(open2, event);
  });
  const domReferenceRef = React3.useRef(null);
  const dataRef = React3.useRef({});
  const events = React3.useState(() => createPubSub())[0];
  const floatingId = useId2();
  const setPositionReference = React3.useCallback((node3) => {
    const positionReference = isElement2(node3) ? {
      getBoundingClientRect: () => node3.getBoundingClientRect(),
      contextElement: node3
    } : node3;
    position2.refs.setReference(positionReference);
  }, [position2.refs]);
  const setReference = React3.useCallback((node3) => {
    if (isElement2(node3) || node3 === null) {
      domReferenceRef.current = node3;
      setDomReference(node3);
    }
    if (isElement2(position2.refs.reference.current) || position2.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node3 !== null && !isElement2(node3)) {
      position2.refs.setReference(node3);
    }
  }, [position2.refs]);
  const refs = React3.useMemo(() => ({
    ...position2.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position2.refs, setReference, setPositionReference]);
  const elements = React3.useMemo(() => ({
    ...position2.elements,
    domReference
  }), [position2.elements, domReference]);
  const context = React3.useMemo(() => ({
    ...position2,
    refs,
    elements,
    dataRef,
    nodeId,
    floatingId,
    events,
    open,
    onOpenChange
  }), [position2, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
  index2(() => {
    const node3 = tree == null ? void 0 : tree.nodesRef.current.find((node4) => node4.id === nodeId);
    if (node3) {
      node3.context = context;
    }
  });
  return React3.useMemo(() => ({
    ...position2,
    context,
    refs,
    elements
  }), [position2, refs, elements, context]);
}

// node_modules/@keystar/ui/dist/keystar-ui-editor.js
var EditorPopover = (0, import_react24.forwardRef)(function EditorPopover2(props, forwardedRef) {
  props = useDefaultProps(props);
  const {
    children,
    reference,
    placement,
    portal
  } = props;
  const Wrapper = portal ? FloatingPortal : import_react24.Fragment;
  const styleProps = useStyleProps(props);
  const [floating, setFloating] = (0, import_react24.useState)(null);
  const middleware = getMiddleware(props);
  const {
    floatingStyles,
    context,
    update
  } = useFloating2({
    elements: {
      reference,
      floating
    },
    middleware,
    placement,
    whileElementsMounted: autoUpdate
  });
  (0, import_react24.useImperativeHandle)(forwardedRef, () => {
    return {
      context,
      update
    };
  }, [context, update]);
  return (0, import_jsx_runtime5.jsx)(Wrapper, {
    children: (0, import_jsx_runtime5.jsx)(DialogElement, {
      ref: setFloating,
      ...styleProps,
      style: {
        ...floatingStyles,
        ...styleProps.style
      },
      children
    })
  });
});
function useDefaultProps(props) {
  return Object.assign({}, {
    adaptToBoundary: "flip",
    placement: "bottom",
    portal: true
  }, props);
}
var DEFAULT_OFFSET = 8;
function applyStyles() {
  return {
    name: "applyStyles",
    async fn(state2) {
      let {
        elements,
        middlewareData
      } = state2;
      if (middlewareData.hide) {
        Object.assign(elements.floating.style, {
          visibility: middlewareData.hide.referenceHidden ? "hidden" : "visible"
        });
      }
      return {};
    }
  };
}
function getMiddleware(props) {
  const {
    adaptToBoundary,
    boundary
  } = props;
  let portalMiddlewares = [...props.portal ? [hide3({
    boundary
  })] : [], applyStyles()];
  if (adaptToBoundary === "stick") {
    return [offset3(DEFAULT_OFFSET), shift3({
      boundary,
      crossAxis: true,
      padding: DEFAULT_OFFSET,
      limiter: limitShift3({
        offset: ({
          rects,
          middlewareData,
          placement
        }) => {
          var _middlewareData$offse, _middlewareData$offse2;
          return {
            crossAxis: rects.floating.height + ((_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) === null || _middlewareData$offse2 === void 0 ? void 0 : _middlewareData$offse2.y) !== null && _middlewareData$offse !== void 0 ? _middlewareData$offse : 0) * (placement === "top" ? -1 : 1)
          };
        }
      })
    }), ...portalMiddlewares];
  }
  if (adaptToBoundary === "stretch") {
    return [offset3(DEFAULT_OFFSET), flip3({
      boundary,
      padding: DEFAULT_OFFSET
    }), size3({
      apply({
        elements,
        availableHeight
      }) {
        Object.assign(elements.floating.style, {
          maxHeight: `${availableHeight}px`
        });
      },
      boundary,
      padding: DEFAULT_OFFSET
    }), ...portalMiddlewares];
  }
  return [offset3(DEFAULT_OFFSET), flip3({
    boundary,
    padding: DEFAULT_OFFSET
  }), shift3({
    padding: DEFAULT_OFFSET
  }), ...portalMiddlewares];
}
var DialogElement = (0, import_react24.forwardRef)(function DialogElement2(props, forwardedRef) {
  return (0, import_jsx_runtime5.jsx)("div", {
    role: "dialog",
    ref: forwardedRef,
    ...props,
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.surface,
      borderRadius: tokenSchema.size.radius.medium,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
      boxShadow: `${tokenSchema.size.shadow.medium} ${tokenSchema.color.shadow.regular}`,
      boxSizing: "content-box",
      // resolves measurement/scroll issues related to border
      minHeight: tokenSchema.size.element.regular,
      minWidth: tokenSchema.size.element.regular,
      outline: 0
    }), props.className)
  });
});
var EditorToolbarContext = (0, import_react24.createContext)(null);
function useToolbarContext() {
  let context = (0, import_react24.useContext)(EditorToolbarContext);
  if (context == null) {
    throw new Error("useToolbarContext must be used within a EditorToolbar");
  }
  return {
    state: context
  };
}
function EditorToolbar(props) {
  let {
    children
  } = props;
  let ref2 = (0, import_react24.useRef)(null);
  let {
    state: state2,
    toolbarProps
  } = useToolbar(props, ref2);
  return (0, import_jsx_runtime5.jsx)(EditorToolbarContext.Provider, {
    value: state2,
    children: (0, import_jsx_runtime5.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
      children: (0, import_jsx_runtime5.jsx)(HStack, {
        alignItems: "center",
        gap: "regular",
        ref: ref2,
        ...toolbarProps,
        children
      })
    })
  });
}
var GroupSelectionContext = (0, import_react24.createContext)(null);
function useGroupSelectionContext() {
  let context = (0, import_react24.useContext)(GroupSelectionContext);
  assert(context !== null, 'An `EditorToolbarItem` is only valid inside an `EditorToolbarGroup` with a `selectionMode` of "single" or "multiple". When no selection is needed, use `EditorToolbarButton` instead.');
  let disabledKeys = useSetFromIterable(context.disabledKeys);
  return {
    ...context,
    disabledKeys
  };
}
function useSelectionItem(props) {
  let context = useGroupSelectionContext();
  if (context.selectionMode === "single") {
    let {
      disabledKeys,
      value,
      onChange
    } = context;
    let isDisabled = disabledKeys.has(props.value);
    let isSelected = value === props.value;
    return {
      isDisabled,
      isSelected,
      buttonProps: {
        ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
          labelable: true
        }),
        role: "radio",
        "aria-checked": isSelected,
        onPress: () => {
          if (isDisabled) {
            return;
          }
          onChange(props.value);
        }
      }
    };
  }
  if (context.selectionMode === "multiple") {
    let {
      disabledKeys,
      value,
      onChange
    } = context;
    let isDisabled = disabledKeys.has(props.value);
    let isSelected = value.includes(props.value);
    return {
      isDisabled,
      isSelected,
      buttonProps: {
        ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
          labelable: true
        }),
        role: "checkbox",
        "aria-checked": isSelected,
        onPress: () => {
          if (isDisabled) {
            return;
          }
          onChange(props.value);
        }
      }
    };
  }
  assertNever(context);
}
function EditorToolbarGroup(props) {
  if (props.selectionMode === "single") {
    return (0, import_jsx_runtime5.jsx)(EditorSingleSelectionGroup, {
      ...props
    });
  }
  if (props.selectionMode === "multiple") {
    return (0, import_jsx_runtime5.jsx)(EditorMultipleSelectionGroup, {
      ...props
    });
  }
  return (0, import_jsx_runtime5.jsx)(HStack, {
    gap: "xsmall",
    role: "group",
    ...filterPropsWithLabelWarning(props),
    children: props.children
  });
}
function EditorSingleSelectionGroup(props) {
  let {
    children,
    ...context
  } = props;
  return (0, import_jsx_runtime5.jsx)(GroupSelectionContext.Provider, {
    value: context,
    children: (0, import_jsx_runtime5.jsx)(HStack, {
      gap: "xsmall",
      role: "radiogroup",
      ...filterPropsWithLabelWarning(props),
      children
    })
  });
}
function EditorMultipleSelectionGroup(props) {
  let {
    children,
    ...context
  } = props;
  return (0, import_jsx_runtime5.jsx)(GroupSelectionContext.Provider, {
    value: context,
    children: (0, import_jsx_runtime5.jsx)(HStack, {
      gap: "xsmall",
      role: "group",
      ...filterPropsWithLabelWarning(props),
      children
    })
  });
}
function EditorToolbarItem(props) {
  let {
    isDisabled,
    isSelected,
    buttonProps
  } = useSelectionItem(props);
  let {
    itemProps
  } = useToolbarItem({
    ...props,
    isDisabled
  });
  return (0, import_jsx_runtime5.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, itemProps),
    children: (0, import_jsx_runtime5.jsx)(ActionButton, {
      prominence: "low",
      isDisabled,
      isSelected,
      children: props.children
    })
  });
}
function EditorToolbarButton(props) {
  let {
    itemProps
  } = useToolbarItem(props);
  return (0, import_jsx_runtime5.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
    ...itemProps,
    children: (0, import_jsx_runtime5.jsx)(ToggleButton, {
      prominence: "low",
      ...props
    })
  });
}
function EditorToolbarSeparator() {
  return (0, import_jsx_runtime5.jsx)("div", {
    role: "separator",
    "aria-orientation": "vertical",
    className: css({
      alignSelf: "center",
      backgroundColor: tokenSchema.color.border.muted,
      flexShrink: 0,
      height: tokenSchema.size.icon.regular,
      width: tokenSchema.size.border.regular
    })
  });
}
function filterPropsWithLabelWarning(props) {
  let {
    "aria-labelledby": ariaLabelledby,
    "aria-label": ariaLabel
  } = props;
  if (!ariaLabelledby && !ariaLabel) {
    console.warn("You must specify an aria-label or aria-labelledby attribute for accessibility.");
  }
  return {
    ...onlyStyleProps(props),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    })
  };
}
function useToolbarItem(props) {
  let {
    isDisabled
  } = props;
  let {
    state: state2
  } = useToolbarContext();
  let {
    lastFocusedId,
    setLastFocusedId
  } = state2;
  let id = (0, import_react24.useId)();
  let tabIndex = lastFocusedId === id || lastFocusedId == null ? 0 : -1;
  (0, import_react24.useEffect)(() => {
    let reset2 = (lastId) => lastId === id ? null : lastId;
    if (isDisabled) {
      setLastFocusedId(reset2);
    }
    return () => {
      setLastFocusedId(reset2);
    };
  }, [id, isDisabled, setLastFocusedId]);
  return {
    itemProps: {
      tabIndex,
      onFocus: () => {
        setLastFocusedId(id);
      }
    }
  };
}
function useToolbar(props, ref2) {
  let [lastFocusedId, setLastFocusedId] = (0, import_react24.useState)(null);
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let focusManager = $9bf71ea28793e738$export$c5251b9e124bf29(ref2, {
    wrap: true
  });
  let isRtl = direction === "rtl";
  let onKeyDown = (e3) => {
    if (!e3.currentTarget.contains(e3.target)) {
      return;
    }
    let accept = (node3) => {
      var _node$parentElement, _node$parentElement2;
      let isFirstChild = ((_node$parentElement = node3.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.firstElementChild) === node3;
      let isGroupChild = /group/.test(((_node$parentElement2 = node3.parentElement) === null || _node$parentElement2 === void 0 ? void 0 : _node$parentElement2.role) || "");
      return !isGroupChild || isFirstChild;
    };
    let options = ($c87311424ea30a05$export$9ac100e40613ea10() ? e3.altKey : e3.ctrlKey) ? {
      accept
    } : {};
    switch (e3.key) {
      case "Home":
        e3.preventDefault();
        e3.stopPropagation();
        focusManager.focusFirst();
        break;
      case "End":
        e3.preventDefault();
        e3.stopPropagation();
        focusManager.focusLast();
        break;
      case "ArrowRight":
      case "ArrowDown":
        e3.preventDefault();
        e3.stopPropagation();
        if (e3.key === "ArrowRight" && isRtl) {
          focusManager.focusPrevious(options);
        } else {
          focusManager.focusNext(options);
        }
        break;
      case "ArrowLeft":
      case "ArrowUp":
        e3.preventDefault();
        e3.stopPropagation();
        if (e3.key === "ArrowLeft" && isRtl) {
          focusManager.focusNext(options);
        } else {
          focusManager.focusPrevious(options);
        }
        break;
    }
  };
  return {
    toolbarProps: {
      ...filterPropsWithLabelWarning(props),
      onKeyDown,
      role: "toolbar",
      "aria-orientation": "horizontal"
    },
    state: (0, import_react24.useMemo)(() => ({
      lastFocusedId,
      setLastFocusedId
    }), [lastFocusedId])
  };
}
function useSetFromIterable(value) {
  return (0, import_react24.useMemo)(() => value == null ? /* @__PURE__ */ new Set() : new Set(value), [value]);
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-boldIcon.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var boldIcon = (0, import_jsx_runtime6.jsx)("path", {
  d: "M14 12a4 4 0 0 0 0-8H6v8M15 20a4 4 0 0 0 0-8H6v8Z"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-codeIcon.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var codeIcon = (0, import_jsx_runtime7.jsx)("path", {
  d: "m16 18 6-6-6-6M8 6l-6 6 6 6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-italicIcon.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var italicIcon = (0, import_jsx_runtime8.jsx)("path", {
  d: "M19 4h-9M14 20H5M15 4 9 20"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-listIcon.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var listIcon = (0, import_jsx_runtime9.jsx)("path", {
  d: "M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-listOrderedIcon.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var listOrderedIcon = (0, import_jsx_runtime10.jsx)("path", {
  d: "M10 6h11M10 12h11M10 18h11M4 6h1v4M4 10h2M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-quoteIcon.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var quoteIcon = (0, import_jsx_runtime11.jsx)("path", {
  d: "M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1zM15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-removeFormattingIcon.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var removeFormattingIcon = (0, import_jsx_runtime12.jsx)("path", {
  d: "M4 7V4h16v3M5 20h6M13 4 8 20M15 15l5 5M20 15l-5 5"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-strikethroughIcon.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var strikethroughIcon = (0, import_jsx_runtime13.jsx)("path", {
  d: "M16 4H9a3 3 0 0 0-2.83 4M14 12a4 4 0 0 1 0 8H6M4 12h16"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-tableIcon.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var tableIcon = (0, import_jsx_runtime14.jsxs)(import_jsx_runtime14.Fragment, {
  children: [(0, import_jsx_runtime14.jsx)("path", {
    d: "M12 3v18"
  }), (0, import_jsx_runtime14.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime14.jsx)("path", {
    d: "M3 9h18M3 15h18"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-menu.js
var import_react31 = __toESM(require_react());

// node_modules/@react-aria/menu/dist/ar-AE.mjs
var $c0398ad35c3639b7$exports = {};
$c0398ad35c3639b7$exports = {
  "longPressMessage": `اضغط مطولاً أو اضغط على Alt + السهم لأسفل لفتح القائمة`
};

// node_modules/@react-aria/menu/dist/bg-BG.mjs
var $7af657c4165927c3$exports = {};
$7af657c4165927c3$exports = {
  "longPressMessage": `Натиснете продължително или натиснете Alt+ стрелка надолу, за да отворите менюто`
};

// node_modules/@react-aria/menu/dist/cs-CZ.mjs
var $d95d4da6d531ab81$exports = {};
$d95d4da6d531ab81$exports = {
  "longPressMessage": `Dlouhým stiskem nebo stisknutím kláves Alt + šipka dolů otevřete nabídku`
};

// node_modules/@react-aria/menu/dist/da-DK.mjs
var $24ebda9c775dca17$exports = {};
$24ebda9c775dca17$exports = {
  "longPressMessage": `Langt tryk eller tryk på Alt + pil ned for at åbne menuen`
};

// node_modules/@react-aria/menu/dist/de-DE.mjs
var $743e0dfca6cab1e9$exports = {};
$743e0dfca6cab1e9$exports = {
  "longPressMessage": `Drücken Sie lange oder drücken Sie Alt + Nach-unten, um das Menü zu öffnen`
};

// node_modules/@react-aria/menu/dist/el-GR.mjs
var $a2f41026e05f1c84$exports = {};
$a2f41026e05f1c84$exports = {
  "longPressMessage": `Πιέστε παρατεταμένα ή πατήστε Alt + κάτω βέλος για να ανοίξετε το μενού`
};

// node_modules/@react-aria/menu/dist/en-US.mjs
var $43b800e97c901737$exports = {};
$43b800e97c901737$exports = {
  "longPressMessage": `Long press or press Alt + ArrowDown to open menu`
};

// node_modules/@react-aria/menu/dist/es-ES.mjs
var $442f5f6ac211e29f$exports = {};
$442f5f6ac211e29f$exports = {
  "longPressMessage": `Mantenga pulsado o pulse Alt + flecha abajo para abrir el menú`
};

// node_modules/@react-aria/menu/dist/et-EE.mjs
var $dff280acfeb2d8ac$exports = {};
$dff280acfeb2d8ac$exports = {
  "longPressMessage": `Menüü avamiseks vajutage pikalt või vajutage klahve Alt + allanool`
};

// node_modules/@react-aria/menu/dist/fi-FI.mjs
var $51608325613944d7$exports = {};
$51608325613944d7$exports = {
  "longPressMessage": `Avaa valikko painamalla pohjassa tai näppäinyhdistelmällä Alt + Alanuoli`
};

// node_modules/@react-aria/menu/dist/fr-FR.mjs
var $c4a1b1eabeaa87be$exports = {};
$c4a1b1eabeaa87be$exports = {
  "longPressMessage": `Appuyez de manière prolongée ou appuyez sur Alt + Flèche vers le bas pour ouvrir le menu.`
};

// node_modules/@react-aria/menu/dist/he-IL.mjs
var $8c74815cdee18d1b$exports = {};
$8c74815cdee18d1b$exports = {
  "longPressMessage": `לחץ לחיצה ארוכה או הקש Alt + ArrowDown כדי לפתוח את התפריט`
};

// node_modules/@react-aria/menu/dist/hr-HR.mjs
var $fd0e9ef6a7fe0ec9$exports = {};
$fd0e9ef6a7fe0ec9$exports = {
  "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika`
};

// node_modules/@react-aria/menu/dist/hu-HU.mjs
var $a89a74a39eba465a$exports = {};
$a89a74a39eba465a$exports = {
  "longPressMessage": `Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyíl gombot a menü megnyitásához`
};

// node_modules/@react-aria/menu/dist/it-IT.mjs
var $edc7c66594a0ae8a$exports = {};
$edc7c66594a0ae8a$exports = {
  "longPressMessage": `Premere a lungo o premere Alt + Freccia giù per aprire il menu`
};

// node_modules/@react-aria/menu/dist/ja-JP.mjs
var $f1ab51510712db52$exports = {};
$f1ab51510712db52$exports = {
  "longPressMessage": `長押しまたは Alt+下矢印キーでメニューを開く`
};

// node_modules/@react-aria/menu/dist/ko-KR.mjs
var $f9b672d9b82fa3d6$exports = {};
$f9b672d9b82fa3d6$exports = {
  "longPressMessage": `길게 누르거나 Alt + 아래쪽 화살표를 눌러 메뉴 열기`
};

// node_modules/@react-aria/menu/dist/lt-LT.mjs
var $a385f3910feda499$exports = {};
$a385f3910feda499$exports = {
  "longPressMessage": `Norėdami atidaryti meniu, nuspaudę palaikykite arba paspauskite „Alt + ArrowDown“.`
};

// node_modules/@react-aria/menu/dist/lv-LV.mjs
var $4f1bde932c441789$exports = {};
$4f1bde932c441789$exports = {
  "longPressMessage": `Lai atvērtu izvēlni, turiet nospiestu vai nospiediet taustiņu kombināciju Alt + lejupvērstā bultiņa`
};

// node_modules/@react-aria/menu/dist/nb-NO.mjs
var $914a51a8a594d5be$exports = {};
$914a51a8a594d5be$exports = {
  "longPressMessage": `Langt trykk eller trykk Alt + PilNed for å åpne menyen`
};

// node_modules/@react-aria/menu/dist/nl-NL.mjs
var $89aaf803103bb500$exports = {};
$89aaf803103bb500$exports = {
  "longPressMessage": `Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen`
};

// node_modules/@react-aria/menu/dist/pl-PL.mjs
var $c685891476dbaaca$exports = {};
$c685891476dbaaca$exports = {
  "longPressMessage": `Naciśnij i przytrzymaj lub naciśnij klawisze Alt + Strzałka w dół, aby otworzyć menu`
};

// node_modules/@react-aria/menu/dist/pt-BR.mjs
var $885879b9b10c2959$exports = {};
$885879b9b10c2959$exports = {
  "longPressMessage": `Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu`
};

// node_modules/@react-aria/menu/dist/pt-PT.mjs
var $6b39616688a51692$exports = {};
$6b39616688a51692$exports = {
  "longPressMessage": `Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu`
};

// node_modules/@react-aria/menu/dist/ro-RO.mjs
var $f26362aed63f47e2$exports = {};
$f26362aed63f47e2$exports = {
  "longPressMessage": `Apăsați lung sau apăsați pe Alt + săgeată în jos pentru a deschide meniul`
};

// node_modules/@react-aria/menu/dist/ru-RU.mjs
var $06cbade644558bf0$exports = {};
$06cbade644558bf0$exports = {
  "longPressMessage": `Нажмите и удерживайте или нажмите Alt + Стрелка вниз, чтобы открыть меню`
};

// node_modules/@react-aria/menu/dist/sk-SK.mjs
var $0a391ff68f9d59b1$exports = {};
$0a391ff68f9d59b1$exports = {
  "longPressMessage": `Ponuku otvoríte dlhým stlačením alebo stlačením klávesu Alt + klávesu so šípkou nadol`
};

// node_modules/@react-aria/menu/dist/sl-SI.mjs
var $8193cf0e649c7928$exports = {};
$8193cf0e649c7928$exports = {
  "longPressMessage": `Za odprtje menija pritisnite in držite gumb ali pritisnite Alt+puščica navzdol`
};

// node_modules/@react-aria/menu/dist/sr-SP.mjs
var $f398debcce5a5c55$exports = {};
$f398debcce5a5c55$exports = {
  "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni`
};

// node_modules/@react-aria/menu/dist/sv-SE.mjs
var $9e9fef000aa4c013$exports = {};
$9e9fef000aa4c013$exports = {
  "longPressMessage": `Håll nedtryckt eller tryck på Alt + pil nedåt för att öppna menyn`
};

// node_modules/@react-aria/menu/dist/tr-TR.mjs
var $c016c8183bbe3d68$exports = {};
$c016c8183bbe3d68$exports = {
  "longPressMessage": `Menüyü açmak için uzun basın veya Alt + Aşağı Ok tuşuna basın`
};

// node_modules/@react-aria/menu/dist/uk-UA.mjs
var $ca4f6c8462244e62$exports = {};
$ca4f6c8462244e62$exports = {
  "longPressMessage": `Довго або звичайно натисніть комбінацію клавіш Alt і стрілка вниз, щоб відкрити меню`
};

// node_modules/@react-aria/menu/dist/zh-CN.mjs
var $2d9960c02ccac927$exports = {};
$2d9960c02ccac927$exports = {
  "longPressMessage": `长按或按 Alt + 向下方向键以打开菜单`
};

// node_modules/@react-aria/menu/dist/zh-TW.mjs
var $f1b682a4c8c5631c$exports = {};
$f1b682a4c8c5631c$exports = {
  "longPressMessage": `長按或按 Alt+向下鍵以開啟功能表`
};

// node_modules/@react-aria/menu/dist/intlStrings.mjs
var $2cbb7ca666678a14$exports = {};
$2cbb7ca666678a14$exports = {
  "ar-AE": $c0398ad35c3639b7$exports,
  "bg-BG": $7af657c4165927c3$exports,
  "cs-CZ": $d95d4da6d531ab81$exports,
  "da-DK": $24ebda9c775dca17$exports,
  "de-DE": $743e0dfca6cab1e9$exports,
  "el-GR": $a2f41026e05f1c84$exports,
  "en-US": $43b800e97c901737$exports,
  "es-ES": $442f5f6ac211e29f$exports,
  "et-EE": $dff280acfeb2d8ac$exports,
  "fi-FI": $51608325613944d7$exports,
  "fr-FR": $c4a1b1eabeaa87be$exports,
  "he-IL": $8c74815cdee18d1b$exports,
  "hr-HR": $fd0e9ef6a7fe0ec9$exports,
  "hu-HU": $a89a74a39eba465a$exports,
  "it-IT": $edc7c66594a0ae8a$exports,
  "ja-JP": $f1ab51510712db52$exports,
  "ko-KR": $f9b672d9b82fa3d6$exports,
  "lt-LT": $a385f3910feda499$exports,
  "lv-LV": $4f1bde932c441789$exports,
  "nb-NO": $914a51a8a594d5be$exports,
  "nl-NL": $89aaf803103bb500$exports,
  "pl-PL": $c685891476dbaaca$exports,
  "pt-BR": $885879b9b10c2959$exports,
  "pt-PT": $6b39616688a51692$exports,
  "ro-RO": $f26362aed63f47e2$exports,
  "ru-RU": $06cbade644558bf0$exports,
  "sk-SK": $0a391ff68f9d59b1$exports,
  "sl-SI": $8193cf0e649c7928$exports,
  "sr-SP": $f398debcce5a5c55$exports,
  "sv-SE": $9e9fef000aa4c013$exports,
  "tr-TR": $c016c8183bbe3d68$exports,
  "uk-UA": $ca4f6c8462244e62$exports,
  "zh-CN": $2d9960c02ccac927$exports,
  "zh-TW": $f1b682a4c8c5631c$exports
};

// node_modules/@react-aria/menu/dist/useMenuTrigger.mjs
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $168583247155ddda$export$dc9c12ed27dd1b49(props, state2, ref2) {
  let { type = "menu", isDisabled, trigger = "press" } = props;
  let menuTriggerId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let { triggerProps, overlayProps } = (0, $628037886ba31236$export$f9d5c8beee7d008d)({
    type
  }, state2, ref2);
  let onKeyDown = (e3) => {
    if (isDisabled) return;
    if (trigger === "longPress" && !e3.altKey) return;
    if (ref2 && ref2.current) switch (e3.key) {
      case "Enter":
      case " ":
        if (trigger === "longPress") return;
      case "ArrowDown":
        if (!("continuePropagation" in e3)) e3.stopPropagation();
        e3.preventDefault();
        state2.toggle("first");
        break;
      case "ArrowUp":
        if (!("continuePropagation" in e3)) e3.stopPropagation();
        e3.preventDefault();
        state2.toggle("last");
        break;
      default:
        if ("continuePropagation" in e3) e3.continuePropagation();
    }
  };
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault($2cbb7ca666678a14$exports)), "@react-aria/menu");
  let { longPressProps } = (0, $8a26561d2877236e$export$c24ed0104d07eab9)({
    isDisabled: isDisabled || trigger !== "longPress",
    accessibilityDescription: stringFormatter.format("longPressMessage"),
    onLongPressStart() {
      state2.close();
    },
    onLongPress() {
      state2.open("first");
    }
  });
  let pressProps = {
    onPressStart(e3) {
      if (e3.pointerType !== "touch" && e3.pointerType !== "keyboard" && !isDisabled)
        state2.open(e3.pointerType === "virtual" ? "first" : null);
    },
    onPress(e3) {
      if (e3.pointerType === "touch" && !isDisabled) state2.toggle();
    }
  };
  delete triggerProps.onPress;
  return {
    menuTriggerProps: {
      ...triggerProps,
      ...trigger === "press" ? pressProps : longPressProps,
      id: menuTriggerId,
      onKeyDown
    },
    menuProps: {
      ...overlayProps,
      "aria-labelledby": menuTriggerId,
      autoFocus: state2.focusStrategy || true,
      onClose: state2.close
    }
  };
}

// node_modules/@react-aria/menu/dist/useMenu.mjs
var $d5336fe17ce95402$export$6f49b4016bfc8d56 = /* @__PURE__ */ new WeakMap();
function $d5336fe17ce95402$export$38eaa17faae8f579(props, state2, ref2) {
  let { shouldFocusWrap = true, onKeyDown, onKeyUp, ...otherProps } = props;
  if (!props["aria-label"] && !props["aria-labelledby"]) console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    ...otherProps,
    ref: ref2,
    selectionManager: state2.selectionManager,
    collection: state2.collection,
    disabledKeys: state2.disabledKeys,
    shouldFocusWrap,
    linkBehavior: "override"
  });
  $d5336fe17ce95402$export$6f49b4016bfc8d56.set(state2, {
    onClose: props.onClose,
    onAction: props.onAction
  });
  return {
    menuProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      onKeyDown,
      onKeyUp
    }, {
      role: "menu",
      ...listProps,
      onKeyDown: (e3) => {
        if (e3.key !== "Escape") listProps.onKeyDown(e3);
      }
    })
  };
}

// node_modules/@react-aria/menu/dist/useMenuItem.mjs
function $a2e5df62f93c7633$export$9d32628fc2aea7da(props, state2, ref2) {
  let { key: key3, closeOnSelect, isVirtualized, "aria-haspopup": hasPopup, onPressStart: pressStartProp, onPressUp: pressUpProp, onPress, onPressChange, onPressEnd, onHoverStart: hoverStartProp, onHoverChange, onHoverEnd, onKeyDown, onKeyUp, onFocus, onFocusChange, onBlur } = props;
  let isTrigger = !!hasPopup;
  var _props_isDisabled;
  let isDisabled = (_props_isDisabled = props.isDisabled) !== null && _props_isDisabled !== void 0 ? _props_isDisabled : state2.selectionManager.isDisabled(key3);
  var _props_isSelected;
  let isSelected = (_props_isSelected = props.isSelected) !== null && _props_isSelected !== void 0 ? _props_isSelected : state2.selectionManager.isSelected(key3);
  let data2 = (0, $d5336fe17ce95402$export$6f49b4016bfc8d56).get(state2);
  let item2 = state2.collection.getItem(key3);
  let onClose = props.onClose || data2.onClose;
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let performAction = (e3) => {
    var _item_props;
    if (isTrigger) return;
    if (item2 === null || item2 === void 0 ? void 0 : (_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.onAction) item2.props.onAction();
    if (props.onAction) props.onAction(key3);
    else if (data2.onAction) data2.onAction(key3);
    if (e3.target instanceof HTMLAnchorElement) router.open(e3.target, e3, item2.props.href, item2.props.routerOptions);
  };
  let role = "menuitem";
  if (!isTrigger) {
    if (state2.selectionManager.selectionMode === "single") role = "menuitemradio";
    else if (state2.selectionManager.selectionMode === "multiple") role = "menuitemcheckbox";
  }
  let labelId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let keyboardId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let ariaProps = {
    "aria-disabled": isDisabled || void 0,
    role,
    "aria-label": props["aria-label"],
    "aria-labelledby": labelId,
    "aria-describedby": [
      descriptionId,
      keyboardId
    ].filter(Boolean).join(" ") || void 0,
    "aria-controls": props["aria-controls"],
    "aria-haspopup": hasPopup,
    "aria-expanded": props["aria-expanded"]
  };
  if (state2.selectionManager.selectionMode !== "none" && !isTrigger) ariaProps["aria-checked"] = isSelected;
  if (isVirtualized) {
    ariaProps["aria-posinset"] = item2 === null || item2 === void 0 ? void 0 : item2.index;
    ariaProps["aria-setsize"] = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state2.collection);
  }
  let onPressStart = (e3) => {
    if (e3.pointerType === "keyboard") performAction(e3);
    pressStartProp === null || pressStartProp === void 0 ? void 0 : pressStartProp(e3);
  };
  let onPressUp = (e3) => {
    if (e3.pointerType !== "keyboard") {
      performAction(e3);
      if (!isTrigger && onClose && (closeOnSelect !== null && closeOnSelect !== void 0 ? closeOnSelect : state2.selectionManager.selectionMode !== "multiple" || state2.selectionManager.isLink(key3))) onClose();
    }
    pressUpProp === null || pressUpProp === void 0 ? void 0 : pressUpProp(e3);
  };
  let { itemProps, isFocused } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state2.selectionManager,
    key: key3,
    ref: ref2,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    // Disable all handling of links in useSelectable item
    // because we handle it ourselves. The behavior of menus
    // is slightly different from other collections because
    // actions are performed on key down rather than key up.
    linkBehavior: "none"
  });
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPressStart,
    onPress,
    onPressUp,
    onPressChange,
    onPressEnd,
    isDisabled
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled,
    onHoverStart(e3) {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()) {
        state2.selectionManager.setFocused(true);
        state2.selectionManager.setFocusedKey(key3);
      }
      hoverStartProp === null || hoverStartProp === void 0 ? void 0 : hoverStartProp(e3);
    },
    onHoverChange,
    onHoverEnd
  });
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)({
    onKeyDown: (e3) => {
      if (e3.repeat) {
        e3.continuePropagation();
        return;
      }
      switch (e3.key) {
        case " ":
          if (!isDisabled && state2.selectionManager.selectionMode === "none" && !isTrigger && closeOnSelect !== false && onClose) onClose();
          break;
        case "Enter":
          if (!isDisabled && closeOnSelect !== false && !isTrigger && onClose) onClose();
          break;
        default:
          if (!isTrigger) e3.continuePropagation();
          onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e3);
          break;
      }
    },
    onKeyUp
  });
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    onBlur,
    onFocus,
    onFocusChange
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(item2.props);
  delete domProps.id;
  let linkProps = (0, $ea8dcbcb9ea1b556$export$7e924b3091a3bd18)(item2.props);
  return {
    menuItemProps: {
      ...ariaProps,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, linkProps, isTrigger ? {
        onFocus: itemProps.onFocus,
        "data-key": itemProps["data-key"]
      } : itemProps, pressProps, hoverProps, keyboardProps, focusProps),
      tabIndex: itemProps.tabIndex != null ? -1 : void 0
    },
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    keyboardShortcutProps: {
      id: keyboardId
    },
    isFocused,
    isSelected,
    isPressed,
    isDisabled
  };
}

// node_modules/@react-aria/menu/dist/useMenuSection.mjs
function $3e5eb2498db5b506$export$73f7a44322579622(props) {
  let { heading: heading3, "aria-label": ariaLabel } = props;
  let headingId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: heading3 ? {
      // Techincally, menus cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a label for the nested group.
      id: headingId,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": ariaLabel,
      "aria-labelledby": heading3 ? headingId : void 0
    }
  };
}

// node_modules/@react-aria/menu/dist/useSafelyMouseToSubmenu.mjs
var import_react26 = __toESM(require_react(), 1);
var $d275435c250248f8$var$ANGLE_PADDING = Math.PI / 12;

// node_modules/@react-aria/menu/dist/useSubmenuTrigger.mjs
var import_react27 = __toESM(require_react(), 1);

// node_modules/@react-stately/tree/dist/TreeCollection.mjs
var $05ca4cd7c4a5a999$export$863faf230ee2118a = class {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key3) {
    let node3 = this.keyMap.get(key3);
    return node3 ? node3.prevKey : null;
  }
  getKeyAfter(key3) {
    let node3 = this.keyMap.get(key3);
    return node3 ? node3.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key3) {
    return this.keyMap.get(key3);
  }
  at(idx) {
    const keys3 = [
      ...this.getKeys()
    ];
    return this.getItem(keys3[idx]);
  }
  constructor(nodes, { expandedKeys } = {}) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.iterable = nodes;
    expandedKeys = expandedKeys || /* @__PURE__ */ new Set();
    let visit3 = (node3) => {
      this.keyMap.set(node3.key, node3);
      if (node3.childNodes && (node3.type === "section" || expandedKeys.has(node3.key))) for (let child of node3.childNodes) visit3(child);
    };
    for (let node3 of nodes) visit3(node3);
    let last;
    let index4 = 0;
    for (let [key3, node3] of this.keyMap) {
      if (last) {
        last.nextKey = key3;
        node3.prevKey = last.key;
      } else {
        this.firstKey = key3;
        node3.prevKey = void 0;
      }
      if (node3.type === "item") node3.index = index4++;
      last = node3;
      last.nextKey = void 0;
    }
    this.lastKey = last === null || last === void 0 ? void 0 : last.key;
  }
};

// node_modules/@react-stately/tree/dist/useTreeState.mjs
var import_react28 = __toESM(require_react(), 1);
function $875d6693e12af071$export$728d6ba534403756(props) {
  let { onExpandedChange } = props;
  let [expandedKeys, setExpandedKeys] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.expandedKeys ? new Set(props.expandedKeys) : void 0, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : /* @__PURE__ */ new Set(), onExpandedChange);
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react28.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let tree = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, (0, import_react28.useCallback)((nodes) => new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {
    expandedKeys
  }), [
    expandedKeys
  ]), null);
  (0, import_react28.useEffect)(() => {
    if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);
  }, [
    tree,
    selectionState.focusedKey
  ]);
  let onToggle = (key3) => {
    setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key3));
  };
  return {
    collection: tree,
    expandedKeys,
    disabledKeys,
    toggleKey: onToggle,
    setExpandedKeys,
    selectionManager: new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(tree, selectionState)
  };
}
function $875d6693e12af071$var$toggleKey(set2, key3) {
  let res = new Set(set2);
  if (res.has(key3)) res.delete(key3);
  else res.add(key3);
  return res;
}

// node_modules/@keystar/ui/dist/keystar-ui-menu.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/menu/dist/useMenuTriggerState.mjs
var import_react29 = __toESM(require_react(), 1);
function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {
  let overlayTriggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let [focusStrategy, setFocusStrategy] = (0, import_react29.useState)(null);
  let [expandedKeysStack, setExpandedKeysStack] = (0, import_react29.useState)([]);
  let closeAll = () => {
    setExpandedKeysStack([]);
    overlayTriggerState.close();
  };
  let openSubmenu = (triggerKey, level) => {
    setExpandedKeysStack((oldStack) => {
      if (level > oldStack.length) return oldStack;
      return [
        ...oldStack.slice(0, level),
        triggerKey
      ];
    });
  };
  let closeSubmenu = (triggerKey, level) => {
    setExpandedKeysStack((oldStack) => {
      let key3 = oldStack[level];
      if (key3 === triggerKey) return oldStack.slice(0, level);
      else return oldStack;
    });
  };
  return {
    focusStrategy,
    ...overlayTriggerState,
    open(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.open();
    },
    toggle(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.toggle();
    },
    close() {
      closeAll();
    },
    expandedKeysStack,
    openSubmenu,
    closeSubmenu
  };
}

// node_modules/@react-stately/menu/dist/useSubmenuTriggerState.mjs
var import_react30 = __toESM(require_react(), 1);

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-moreHorizontalIcon.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var moreHorizontalIcon = (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, {
  children: [(0, import_jsx_runtime15.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime15.jsx)("circle", {
    cx: 19,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime15.jsx)("circle", {
    cx: 5,
    cy: 12,
    r: 1
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-menu.js
var localizedMessages2 = {
  "ar-AE": {
    moreActions: "المزيد من الإجراءات"
  },
  "bg-BG": {
    moreActions: "Повече действия"
  },
  "cs-CZ": {
    moreActions: "Další akce"
  },
  "da-DK": {
    moreActions: "Flere handlinger"
  },
  "de-DE": {
    moreActions: "Mehr Aktionen"
  },
  "el-GR": {
    moreActions: "Περισσότερες ενέργειες"
  },
  "en-US": {
    moreActions: "More actions"
  },
  "es-ES": {
    moreActions: "Más acciones"
  },
  "et-EE": {
    moreActions: "Veel toiminguid"
  },
  "fi-FI": {
    moreActions: "Lisää toimintoja"
  },
  "fr-FR": {
    moreActions: "Autres actions"
  },
  "he-IL": {
    moreActions: "פעולות נוספות"
  },
  "hr-HR": {
    moreActions: "Dodatne radnje"
  },
  "hu-HU": {
    moreActions: "További lehetőségek"
  },
  "it-IT": {
    moreActions: "Altre azioni"
  },
  "ja-JP": {
    moreActions: "その他のアクション"
  },
  "ko-KR": {
    moreActions: "기타 작업"
  },
  "lt-LT": {
    moreActions: "Daugiau veiksmų"
  },
  "lv-LV": {
    moreActions: "Citas darbības"
  },
  "nb-NO": {
    moreActions: "Flere handlinger"
  },
  "nl-NL": {
    moreActions: "Meer handelingen"
  },
  "pl-PL": {
    moreActions: "Więcej akcji"
  },
  "pt-BR": {
    moreActions: "Mais ações"
  },
  "pt-PT": {
    moreActions: "Mais ações"
  },
  "ro-RO": {
    moreActions: "Mai multe acțiuni"
  },
  "ru-RU": {
    moreActions: "Дополнительные действия"
  },
  "sk-SK": {
    moreActions: "Ďalšie akcie"
  },
  "sl-SI": {
    moreActions: "Več možnosti"
  },
  "sr-SP": {
    moreActions: "Dodatne radnje"
  },
  "sv-SE": {
    moreActions: "Fler åtgärder"
  },
  "tr-TR": {
    moreActions: "Daha fazla eylem"
  },
  "uk-UA": {
    moreActions: "Більше дій"
  },
  "zh-CN": {
    moreActions: "更多操作"
  },
  "zh-TW": {
    moreActions: "更多動作"
  }
};
var MenuContext = import_react31.default.createContext({});
function useMenuContext() {
  return (0, import_react31.useContext)(MenuContext);
}
function MenuItem(props) {
  let {
    item: item2,
    state: state2,
    isVirtualized,
    onAction
  } = props;
  let {
    onClose,
    closeOnSelect
  } = useMenuContext();
  let {
    rendered,
    key: key3
  } = item2;
  let isSelected = state2.selectionManager.isSelected(key3);
  let isDisabled = state2.selectionManager.isDisabled(key3);
  let ref2 = (0, import_react31.useRef)(null);
  let {
    menuItemProps,
    labelProps,
    descriptionProps,
    keyboardShortcutProps
  } = $a2e5df62f93c7633$export$9d32628fc2aea7da({
    isSelected,
    isDisabled,
    "aria-label": item2["aria-label"],
    key: key3,
    onClose,
    closeOnSelect,
    isVirtualized,
    onAction
  }, state2, ref2);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let {
    focusProps,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let contents = isReactText(rendered) ? (0, import_jsx_runtime16.jsx)(Text, {
    children: rendered
  }) : rendered;
  let role = state2.selectionManager.disabledBehavior === "selection" && state2.disabledKeys.has(key3) ? "menuitem" : void 0;
  return (0, import_jsx_runtime16.jsx)(ListItem, {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(menuItemProps, {
      role
    }, hoverProps, focusProps),
    elementType: item2.props.href ? "a" : "div",
    descriptionProps,
    keyboardShortcutProps,
    labelProps,
    isHovered,
    isFocused: isFocusVisible,
    isSelected,
    ref: ref2,
    children: contents
  });
}
function MenuSection(props) {
  let {
    item: item2,
    state: state2,
    onAction
  } = props;
  let {
    itemProps,
    headingProps,
    groupProps
  } = $3e5eb2498db5b506$export$73f7a44322579622({
    heading: item2.rendered,
    "aria-label": item2["aria-label"]
  });
  let {
    separatorProps
  } = $f4b273590fab9f93$export$52210f68a14655d0({});
  return (0, import_jsx_runtime16.jsxs)(import_react31.Fragment, {
    children: [item2.key !== state2.collection.getFirstKey() && (0, import_jsx_runtime16.jsx)(Divider, {
      ...separatorProps,
      marginY: "small"
    }), (0, import_jsx_runtime16.jsxs)("div", {
      ...itemProps,
      children: [item2.rendered && (0, import_jsx_runtime16.jsx)(Text, {
        casing: "uppercase",
        size: "small",
        color: "neutralSecondary",
        weight: "medium",
        UNSAFE_className: css({
          paddingBlock: tokenSchema.size.space.regular,
          paddingInline: tokenSchema.size.space.medium
        }),
        ...headingProps,
        children: item2.rendered
      }), (0, import_jsx_runtime16.jsx)("div", {
        ...groupProps,
        children: [...$c5a24bc478652b5f$export$1005530eda016c13(item2, state2.collection)].map((node3) => {
          let item3 = (0, import_jsx_runtime16.jsx)(MenuItem, {
            item: node3,
            state: state2,
            onAction
          }, node3.key);
          if (node3.wrapper) {
            item3 = node3.wrapper(item3);
          }
          return item3;
        })
      })]
    })]
  });
}
function Menu(props, forwardedRef) {
  let contextProps = (0, import_react31.useContext)(MenuContext);
  let completeProps = {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(contextProps, props)
  };
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let state2 = $875d6693e12af071$export$728d6ba534403756(completeProps);
  let {
    menuProps
  } = $d5336fe17ce95402$export$38eaa17faae8f579(completeProps, state2, domRef);
  let styleProps = useStyleProps(completeProps);
  $e7801be82b4b2a53$export$4debdb1a3f0fa79e(contextProps, domRef);
  return (0, import_jsx_runtime16.jsx)("div", {
    ...menuProps,
    ...styleProps,
    ref: domRef,
    className: classNames(listStyles, styleProps.className),
    "data-selection": state2.selectionManager.selectionMode,
    children: [...state2.collection].map((item2) => {
      if (item2.type === "section") {
        return (0, import_jsx_runtime16.jsx)(MenuSection, {
          item: item2,
          state: state2,
          onAction: completeProps.onAction
        }, item2.key);
      }
      let menuItem = (0, import_jsx_runtime16.jsx)(MenuItem, {
        item: item2,
        state: state2,
        onAction: completeProps.onAction
      }, item2.key);
      if (item2.wrapper) {
        menuItem = item2.wrapper(menuItem);
      }
      return menuItem;
    })
  });
}
var _Menu = import_react31.default.forwardRef(Menu);
var MenuTrigger = (0, import_react31.forwardRef)(function MenuTrigger2(props, forwardedRef) {
  let triggerRef = (0, import_react31.useRef)(null);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let menuTriggerRef = domRef || triggerRef;
  let menuRef = (0, import_react31.useRef)(null);
  let {
    children,
    align = "start",
    shouldFlip = true,
    direction = "bottom",
    closeOnSelect,
    trigger = "press"
  } = props;
  let [menuTrigger, menu] = import_react31.default.Children.toArray(children);
  let state2 = $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props);
  let {
    menuTriggerProps,
    menuProps
  } = $168583247155ddda$export$dc9c12ed27dd1b49({
    trigger
  }, state2, menuTriggerRef);
  let initialPlacement;
  switch (direction) {
    case "left":
    case "right":
    case "start":
    case "end":
      initialPlacement = `${direction} ${align === "end" ? "bottom" : "top"}`;
      break;
    case "bottom":
    case "top":
    default:
      initialPlacement = `${direction} ${align}`;
  }
  let isMobile = useIsMobileDevice();
  let menuContext = {
    ...menuProps,
    ref: menuRef,
    onClose: state2.close,
    closeOnSelect,
    autoFocus: state2.focusStrategy || true,
    UNSAFE_style: isMobile ? {
      width: "100%",
      maxHeight: "inherit"
    } : {
      maxWidth: tokenSchema.size.dialog.xsmall
    }
  };
  let overlay;
  if (isMobile) {
    overlay = (0, import_jsx_runtime16.jsx)(Tray, {
      state: state2,
      children: menu
    });
  } else {
    overlay = (0, import_jsx_runtime16.jsx)(Popover, {
      state: state2,
      triggerRef: menuTriggerRef,
      scrollRef: menuRef,
      placement: initialPlacement,
      hideArrow: true,
      shouldFlip,
      children: menu
    });
  }
  return (0, import_jsx_runtime16.jsxs)(import_react31.Fragment, {
    children: [(0, import_jsx_runtime16.jsx)(SlotProvider, {
      slots: {
        actionButton: {
          holdAffordance: trigger === "longPress"
        }
      },
      children: (0, import_jsx_runtime16.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
        ...menuTriggerProps,
        ref: menuTriggerRef,
        isPressed: state2.isOpen,
        children: menuTrigger
      })
    }), (0, import_jsx_runtime16.jsx)(MenuContext.Provider, {
      // TODO: Fix this type error
      // @ts-expect-error
      value: menuContext,
      children: overlay
    })]
  });
});
function ActionMenu(props, ref2) {
  props = useSlotProps(props, "actionMenu");
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  let buttonProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
    labelable: true
  });
  if (buttonProps["aria-label"] === void 0) {
    buttonProps["aria-label"] = stringFormatter.format("moreActions");
  }
  return (0, import_jsx_runtime16.jsxs)(MenuTrigger, {
    isOpen: props.isOpen,
    defaultOpen: props.defaultOpen,
    onOpenChange: props.onOpenChange,
    align: props.align,
    direction: props.direction,
    shouldFlip: props.shouldFlip,
    children: [(0, import_jsx_runtime16.jsx)(ActionButton, {
      ref: ref2,
      ...props,
      ...buttonProps,
      children: (0, import_jsx_runtime16.jsx)(Icon, {
        src: moreHorizontalIcon
      })
    }), (0, import_jsx_runtime16.jsx)(_Menu, {
      children: props.children,
      items: props.items,
      disabledKeys: props.disabledKeys,
      onAction: props.onAction
    })]
  });
}
var _ActionMenu = (0, import_react31.forwardRef)(ActionMenu);

// node_modules/@react-aria/select/dist/useSelect.mjs
var import_react32 = __toESM(require_react(), 1);
var $58aed456727eb0f3$export$703601b7e90536f8 = /* @__PURE__ */ new WeakMap();
function $58aed456727eb0f3$export$e64b2f635402ca43(props, state2, ref2) {
  let { keyboardDelegate, isDisabled, isRequired, name: name2, validationBehavior = "aria" } = props;
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let delegate = (0, import_react32.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(state2.collection, state2.disabledKeys, null, collator), [
    keyboardDelegate,
    state2.collection,
    state2.disabledKeys,
    collator
  ]);
  let { menuTriggerProps, menuProps } = (0, $168583247155ddda$export$dc9c12ed27dd1b49)({
    isDisabled,
    type: "listbox"
  }, state2, ref2);
  let onKeyDown = (e3) => {
    switch (e3.key) {
      case "ArrowLeft": {
        e3.preventDefault();
        let key3 = state2.selectedKey != null ? delegate.getKeyAbove(state2.selectedKey) : delegate.getFirstKey();
        if (key3) state2.setSelectedKey(key3);
        break;
      }
      case "ArrowRight": {
        e3.preventDefault();
        let key3 = state2.selectedKey != null ? delegate.getKeyBelow(state2.selectedKey) : delegate.getFirstKey();
        if (key3) state2.setSelectedKey(key3);
        break;
      }
    }
  };
  let { typeSelectProps } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({
    keyboardDelegate: delegate,
    selectionManager: state2.selectionManager,
    onTypeSelect(key3) {
      state2.setSelectedKey(key3);
    }
  });
  let { isInvalid, validationErrors, validationDetails } = state2.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    labelElementType: "span",
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;
  delete typeSelectProps.onKeyDownCapture;
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let triggerProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(typeSelectProps, menuTriggerProps, fieldProps);
  let valueId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  $58aed456727eb0f3$export$703601b7e90536f8.set(state2, {
    isDisabled,
    isRequired,
    name: name2,
    validationBehavior
  });
  return {
    labelProps: {
      ...labelProps,
      onClick: () => {
        if (!props.isDisabled) {
          ref2.current.focus();
          (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
        }
      }
    },
    triggerProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...triggerProps,
      isDisabled,
      onKeyDown: (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),
      onKeyUp: props.onKeyUp,
      "aria-labelledby": [
        valueId,
        triggerProps["aria-labelledby"],
        triggerProps["aria-label"] && !triggerProps["aria-labelledby"] ? triggerProps.id : null
      ].filter(Boolean).join(" "),
      onFocus(e3) {
        if (state2.isFocused) return;
        if (props.onFocus) props.onFocus(e3);
        if (props.onFocusChange) props.onFocusChange(true);
        state2.setFocused(true);
      },
      onBlur(e3) {
        if (state2.isOpen) return;
        if (props.onBlur) props.onBlur(e3);
        if (props.onFocusChange) props.onFocusChange(false);
        state2.setFocused(false);
      }
    }),
    valueProps: {
      id: valueId
    },
    menuProps: {
      ...menuProps,
      autoFocus: state2.focusStrategy || true,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      disallowEmptySelection: true,
      linkBehavior: "selection",
      onBlur: (e3) => {
        if (e3.currentTarget.contains(e3.relatedTarget)) return;
        if (props.onBlur) props.onBlur(e3);
        if (props.onFocusChange) props.onFocusChange(false);
        state2.setFocused(false);
      },
      "aria-labelledby": [
        fieldProps["aria-labelledby"],
        triggerProps["aria-label"] && !fieldProps["aria-labelledby"] ? triggerProps.id : null
      ].filter(Boolean).join(" ")
    },
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@react-aria/select/dist/HiddenSelect.mjs
var import_react33 = __toESM(require_react(), 1);
function $bdd25dc72710631f$export$f809e80f58e251d1(props, state2, triggerRef) {
  let data2 = (0, $58aed456727eb0f3$export$703601b7e90536f8).get(state2) || {};
  let { autoComplete, name: name2 = data2.name, isDisabled = data2.isDisabled } = props;
  let { validationBehavior, isRequired } = data2;
  let modality = (0, $507fabe10e71c6fb$export$98e20ec92f614cfe)();
  let { visuallyHiddenProps } = (0, $5c3e21d68f1c4674$export$a966af930f325cab)();
  (0, $99facab73266f662$export$5add1d006293d136)(props.selectRef, state2.selectedKey, state2.setSelectedKey);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)({
    validationBehavior,
    focus: () => triggerRef.current.focus()
  }, state2, props.selectRef);
  var _state_selectedKey;
  return {
    containerProps: {
      ...visuallyHiddenProps,
      "aria-hidden": true,
      ["data-react-aria-prevent-focus"]: true,
      ["data-a11y-ignore"]: "aria-hidden-focus"
    },
    inputProps: {
      type: "text",
      tabIndex: modality == null || state2.isFocused || state2.isOpen ? -1 : 0,
      style: {
        fontSize: 16
      },
      onFocus: () => triggerRef.current.focus(),
      disabled: isDisabled
    },
    selectProps: {
      tabIndex: -1,
      autoComplete,
      disabled: isDisabled,
      required: validationBehavior === "native" && isRequired,
      name: name2,
      value: (_state_selectedKey = state2.selectedKey) !== null && _state_selectedKey !== void 0 ? _state_selectedKey : "",
      onChange: (e3) => state2.setSelectedKey(e3.target.value)
    }
  };
}
function $bdd25dc72710631f$export$cbd84cdb2e668835(props) {
  let { state: state2, triggerRef, label, name: name2, isDisabled } = props;
  let selectRef = (0, import_react33.useRef)(null);
  let { containerProps, inputProps, selectProps } = $bdd25dc72710631f$export$f809e80f58e251d1({
    ...props,
    selectRef
  }, state2, triggerRef);
  var _state_selectedKey;
  if (state2.collection.size <= 300) return (0, import_react33.default).createElement("div", {
    ...containerProps,
    "data-testid": "hidden-select-container"
  }, (0, import_react33.default).createElement("input", inputProps), (0, import_react33.default).createElement("label", null, label, (0, import_react33.default).createElement("select", {
    ...selectProps,
    ref: selectRef
  }, (0, import_react33.default).createElement("option", null), [
    ...state2.collection.getKeys()
  ].map((key3) => {
    let item2 = state2.collection.getItem(key3);
    if (item2.type === "item") return (0, import_react33.default).createElement("option", {
      key: item2.key,
      value: item2.key
    }, item2.textValue);
  }))));
  else if (name2) return (0, import_react33.default).createElement("input", {
    type: "hidden",
    autoComplete: selectProps.autoComplete,
    name: name2,
    disabled: isDisabled,
    value: (_state_selectedKey = state2.selectedKey) !== null && _state_selectedKey !== void 0 ? _state_selectedKey : ""
  });
  return null;
}

// node_modules/@react-stately/select/dist/useSelectState.mjs
var import_react34 = __toESM(require_react(), 1);
function $2bc3a590c5373a4e$export$5159ec8b34d4ec12(props) {
  let triggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let [focusStrategy, setFocusStrategy] = (0, import_react34.useState)(null);
  let listState = (0, $a0d645289fe9b86b$export$e7f05e985daf4b5f)({
    ...props,
    onSelectionChange: (key3) => {
      if (props.onSelectionChange != null) props.onSelectionChange(key3);
      triggerState.close();
      validationState.commitValidation();
    }
  });
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: listState.selectedKey
  });
  let [isFocused, setFocused] = (0, import_react34.useState)(false);
  return {
    ...validationState,
    ...listState,
    ...triggerState,
    focusStrategy,
    open(focusStrategy2 = null) {
      if (listState.collection.size !== 0) {
        setFocusStrategy(focusStrategy2);
        triggerState.open();
      }
    },
    toggle(focusStrategy2 = null) {
      if (listState.collection.size !== 0) {
        setFocusStrategy(focusStrategy2);
        triggerState.toggle();
      }
    },
    isFocused,
    setFocused
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-picker.js
var import_react35 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronsUpDownIcon.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var chevronsUpDownIcon = (0, import_jsx_runtime17.jsx)("path", {
  d: "m7 15 5 5 5-5M7 9l5-5 5 5"
});

// node_modules/@keystar/ui/dist/keystar-ui-picker.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var localizedMessages3 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    placeholder: "حدد خيارًا..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    placeholder: "Изберете опция"
  },
  "cs-CZ": {
    loading: "Načítání...",
    placeholder: "Vyberte vhodnou možnost..."
  },
  "da-DK": {
    loading: "Indlæser ...",
    placeholder: "Vælg en mulighed ..."
  },
  "de-DE": {
    loading: "Laden...",
    placeholder: "Option auswählen..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    placeholder: "Επιλέξτε…"
  },
  "en-US": {
    placeholder: "Select an option…",
    loading: "Loading…"
  },
  "es-ES": {
    loading: "Cargando…",
    placeholder: "Selecciona una de estas opciones..."
  },
  "et-EE": {
    loading: "Laadimine...",
    placeholder: "Valige valikuline..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    placeholder: "Valitse vaihtoehto..."
  },
  "fr-FR": {
    loading: "Chargement...",
    placeholder: "Sélectionnez une option..."
  },
  "he-IL": {
    loading: "טוען...",
    placeholder: "בחר אפשרות..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    placeholder: "Odaberite opciju"
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    placeholder: "Válasszon egy opciót…"
  },
  "it-IT": {
    loading: "Caricamento...",
    placeholder: "Seleziona un’opzione..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    placeholder: "オプションを選択..."
  },
  "ko-KR": {
    loading: "로드 중",
    placeholder: "선택 사항 선택"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    placeholder: "Pasirinkite parinktį..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    placeholder: "Atlasiet opciju..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    placeholder: "Velg et alternativ..."
  },
  "nl-NL": {
    loading: "Laden...",
    placeholder: "Optie selecteren..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    placeholder: "Wybierz opcję..."
  },
  "pt-BR": {
    loading: "Carregando...",
    placeholder: "Selecione uma opção..."
  },
  "pt-PT": {
    loading: "A carregar...",
    placeholder: "Selecionar uma opção..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    placeholder: "Selectați o opțiune"
  },
  "ru-RU": {
    loading: "Загрузка...",
    placeholder: "Выбрать параметр..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    placeholder: "Vyberte možnosť..."
  },
  "sl-SI": {
    loading: "Nalaganje...",
    placeholder: "Izberite možnost"
  },
  "sr-SP": {
    loading: "Učitavam...",
    placeholder: "Izaberite opciju"
  },
  "sv-SE": {
    loading: "Läser in...",
    placeholder: "Välj ett alternativ..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    placeholder: "Bir seçim yapın…"
  },
  "uk-UA": {
    loading: "Завантаження…",
    placeholder: "Виберіть опцію..."
  },
  "zh-CN": {
    loading: "正在加载...",
    placeholder: "选择一个选项..."
  },
  "zh-T": {
    loading: "正在載入",
    placeholder: "選取一個選項"
  }
};
function Picker(props, forwardedRef) {
  props = useSlotProps(props, "picker");
  props = useProviderProps(props);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages3);
  let {
    align = "start",
    autoComplete,
    autoFocus,
    direction = "bottom",
    isDisabled,
    label,
    menuWidth,
    name: name2,
    placeholder = stringFormatter.format("placeholder"),
    prominence,
    shouldFlip = true
  } = props;
  let popoverRef = (0, import_react35.useRef)(null);
  let triggerRef = (0, import_react35.useRef)(null);
  let listboxRef = (0, import_react35.useRef)(null);
  let state2 = $2bc3a590c5373a4e$export$5159ec8b34d4ec12(props);
  let layout = useListBoxLayout(state2);
  let {
    labelProps,
    triggerProps,
    valueProps,
    menuProps,
    descriptionProps,
    errorMessageProps
  } = $58aed456727eb0f3$export$e64b2f635402ca43({
    ...props,
    keyboardDelegate: layout
  }, state2, triggerRef);
  let isMobile = useIsMobileDevice();
  let isLoadingInitial = props.isLoading && state2.collection.size === 0;
  let isLoadingMore = props.isLoading && state2.collection.size > 0;
  let listbox = (0, import_jsx_runtime18.jsx)(_ListBoxBase, {
    ...menuProps,
    ref: listboxRef,
    disallowEmptySelection: true,
    autoFocus: state2.focusStrategy || true,
    shouldSelectOnPressUp: true,
    focusOnPointerEnter: true,
    layout,
    state: state2,
    UNSAFE_className: listStyles,
    isLoading: isLoadingMore,
    onLoadMore: props.onLoadMore
  });
  let [buttonWidth, setButtonWidth] = (0, import_react35.useState)();
  let {
    scale
  } = useProvider();
  let onResize = (0, import_react35.useCallback)(() => {
    if (!isMobile && triggerRef.current) {
      let width = triggerRef.current.offsetWidth;
      setButtonWidth(width);
    }
  }, [triggerRef, setButtonWidth, isMobile]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: triggerRef,
    onResize
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(onResize, [scale, state2.selectedKey, onResize]);
  let overlay;
  if (isMobile) {
    overlay = (0, import_jsx_runtime18.jsx)(Tray, {
      state: state2,
      children: listbox
    });
  } else {
    let style = {
      minWidth: buttonWidth,
      width: menuWidth !== null && menuWidth !== void 0 ? menuWidth : buttonWidth
    };
    overlay = (0, import_jsx_runtime18.jsx)(Popover, {
      UNSAFE_style: style,
      ref: popoverRef,
      placement: `${direction} ${align}`,
      shouldFlip,
      hideArrow: true,
      state: state2,
      triggerRef,
      scrollRef: listboxRef,
      children: listbox
    });
  }
  let contents = state2.selectedItem ? state2.selectedItem.rendered : placeholder;
  if (isReactText(contents)) {
    contents = (0, import_jsx_runtime18.jsx)(Text, {
      children: contents
    });
  }
  let picker = (0, import_jsx_runtime18.jsxs)("div", {
    children: [(0, import_jsx_runtime18.jsx)($bdd25dc72710631f$export$cbd84cdb2e668835, {
      autoComplete,
      isDisabled,
      label,
      name: name2,
      state: state2,
      triggerRef
    }), (0, import_jsx_runtime18.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...triggerProps,
      children: (0, import_jsx_runtime18.jsxs)(FieldButton, {
        "aria-required": true,
        prominence,
        ref: triggerRef,
        isActive: state2.isOpen,
        isDisabled,
        autoFocus,
        UNSAFE_className: classNames(css({
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          position: "relative",
          width: "100%",
          /* Ensure that changing the selected item doesn't affect the size of the dropdown and its parents */
          contain: "size"
        })),
        children: [(0, import_jsx_runtime18.jsx)(SlotProvider, {
          slots: {
            icon: {
              marginEnd: "small"
            },
            text: {
              ...valueProps,
              // when no item is selected, we're styling the placeholder
              color: !state2.selectedItem ? "neutralSecondary" : "inherit",
              weight: state2.selectedItem ? "medium" : void 0
            },
            // we try to maintain most of the selected item's rendered content
            // within the button, but description text is too long
            description: {
              isHidden: true
            }
          },
          children: contents
        }), isLoadingInitial && (0, import_jsx_runtime18.jsx)(ProgressCircle, {
          isIndeterminate: true,
          size: "small",
          "aria-label": stringFormatter.format("loading"),
          UNSAFE_className: css({
            marginInlineStart: tokenSchema.size.space.small
          })
        }), (0, import_jsx_runtime18.jsx)(Icon, {
          src: chevronsUpDownIcon,
          UNSAFE_className: css({
            marginInlineStart: tokenSchema.size.space.small
          })
        })]
      })
    }), state2.collection.size === 0 ? null : overlay]
  });
  return (0, import_jsx_runtime18.jsx)(FieldPrimitive, {
    width: "alias.singleLineWidth",
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    supplementRequiredState: true,
    children: picker
  });
}
var _Picker = (0, import_react35.forwardRef)(Picker);

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-fileCodeIcon.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var fileCodeIcon = (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, {
  children: [(0, import_jsx_runtime19.jsx)("path", {
    d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
  }), (0, import_jsx_runtime19.jsx)("path", {
    d: "M14 2v4a2 2 0 0 0 2 2h4M10 13l-2 2 2 2M14 17l2-2-2-2"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-heading1Icon.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var heading1Icon = (0, import_jsx_runtime20.jsx)("path", {
  d: "M4 12h8M4 18V6M12 18V6M17 12l3-2v8"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-heading2Icon.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var heading2Icon = (0, import_jsx_runtime21.jsx)("path", {
  d: "M4 12h8M4 18V6M12 18V6M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-heading3Icon.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var heading3Icon = (0, import_jsx_runtime22.jsx)("path", {
  d: "M4 12h8M4 18V6M12 18V6M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-heading4Icon.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var heading4Icon = (0, import_jsx_runtime23.jsx)("path", {
  d: "M4 12h8M4 18V6M12 18V6M17 10v4h4M21 10v8"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-heading5Icon.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var heading5Icon = (0, import_jsx_runtime24.jsx)("path", {
  d: "M4 12h8M4 18V6M12 18V6M17 13v-3h4M17 17.7c.4.2.8.3 1.3.3 1.5 0 2.7-1.1 2.7-2.5S19.8 13 18.3 13H17"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-heading6Icon.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var heading6Icon = (0, import_jsx_runtime25.jsxs)(import_jsx_runtime25.Fragment, {
  children: [(0, import_jsx_runtime25.jsx)("path", {
    d: "M4 12h8M4 18V6M12 18V6"
  }), (0, import_jsx_runtime25.jsx)("circle", {
    cx: 19,
    cy: 16,
    r: 2
  }), (0, import_jsx_runtime25.jsx)("path", {
    d: "M20 10c-2 2-3 3.5-3 6"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-separatorHorizontalIcon.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var separatorHorizontalIcon = (0, import_jsx_runtime26.jsx)("path", {
  d: "M3 12h18M8 8l4-4 4 4M16 16l-4 4-4-4"
});

// node_modules/@react-aria/gridlist/dist/utils.mjs
var $ce9b18daab526bbd$export$5b9bb410392e3991 = /* @__PURE__ */ new WeakMap();
function $ce9b18daab526bbd$export$f45c25170b9a99c2(state2, key3) {
  let { id } = $ce9b18daab526bbd$export$5b9bb410392e3991.get(state2);
  if (!id) throw new Error("Unknown list");
  return `${id}-${$ce9b18daab526bbd$export$e0c709538cb8ae18(key3)}`;
}
function $ce9b18daab526bbd$export$e0c709538cb8ae18(key3) {
  if (typeof key3 === "string") return key3.replace(/\s*/g, "");
  return "" + key3;
}

// node_modules/@react-aria/grid/dist/GridKeyboardDelegate.mjs
var $d1c300d9c497e402$export$de9feff04fda126e = class {
  isCell(node3) {
    return node3.type === "cell";
  }
  isRow(node3) {
    return node3.type === "row" || node3.type === "item";
  }
  isDisabled(item2) {
    var _item_props;
    return this.disabledBehavior === "all" && (((_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || this.disabledKeys.has(item2.key));
  }
  findPreviousKey(fromKey, pred) {
    let key3 = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();
    while (key3 != null) {
      let item2 = this.collection.getItem(key3);
      if (!this.isDisabled(item2) && (!pred || pred(item2))) return key3;
      key3 = this.collection.getKeyBefore(key3);
    }
  }
  findNextKey(fromKey, pred) {
    let key3 = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();
    while (key3 != null) {
      let item2 = this.collection.getItem(key3);
      if (!this.isDisabled(item2) && (!pred || pred(item2))) return key3;
      key3 = this.collection.getKeyAfter(key3);
    }
  }
  getKeyBelow(key3) {
    let startItem = this.collection.getItem(key3);
    if (!startItem) return;
    if (this.isCell(startItem)) key3 = startItem.parentKey;
    key3 = this.findNextKey(key3);
    if (key3 != null) {
      if (this.isCell(startItem)) {
        let item2 = this.collection.getItem(key3);
        return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection), startItem.index).key;
      }
      if (this.focusMode === "row") return key3;
    }
  }
  getKeyAbove(key3) {
    let startItem = this.collection.getItem(key3);
    if (!startItem) return;
    if (this.isCell(startItem)) key3 = startItem.parentKey;
    key3 = this.findPreviousKey(key3);
    if (key3 != null) {
      if (this.isCell(startItem)) {
        let item2 = this.collection.getItem(key3);
        return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection), startItem.index).key;
      }
      if (this.focusMode === "row") return key3;
    }
  }
  getKeyRightOf(key3) {
    let item2 = this.collection.getItem(key3);
    if (!item2) return;
    if (this.isRow(item2)) {
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection);
      return this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key : (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(children).key;
    }
    if (this.isCell(item2)) {
      let parent = this.collection.getItem(item2.parentKey);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
      let next = this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index - 1) : (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index + 1);
      if (next) return next.key;
      if (this.focusMode === "row") return item2.parentKey;
      return this.direction === "rtl" ? this.getFirstKey(key3) : this.getLastKey(key3);
    }
  }
  getKeyLeftOf(key3) {
    let item2 = this.collection.getItem(key3);
    if (!item2) return;
    if (this.isRow(item2)) {
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection);
      return this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(children).key : (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
    }
    if (this.isCell(item2)) {
      let parent = this.collection.getItem(item2.parentKey);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
      let prev = this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index + 1) : (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index - 1);
      if (prev) return prev.key;
      if (this.focusMode === "row") return item2.parentKey;
      return this.direction === "rtl" ? this.getLastKey(key3) : this.getFirstKey(key3);
    }
  }
  getFirstKey(key3, global2) {
    let item2;
    if (key3 != null) {
      item2 = this.collection.getItem(key3);
      if (!item2) return;
      if (this.isCell(item2) && !global2) {
        let parent = this.collection.getItem(item2.parentKey);
        return (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection)).key;
      }
    }
    key3 = this.findNextKey();
    if (key3 != null && item2 && this.isCell(item2) && global2 || this.focusMode === "cell") {
      let item3 = this.collection.getItem(key3);
      key3 = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item3, this.collection)).key;
    }
    return key3;
  }
  getLastKey(key3, global2) {
    let item2;
    if (key3 != null) {
      item2 = this.collection.getItem(key3);
      if (!item2) return;
      if (this.isCell(item2) && !global2) {
        let parent = this.collection.getItem(item2.parentKey);
        let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
        return (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
      }
    }
    key3 = this.findPreviousKey();
    if (key3 != null && item2 && this.isCell(item2) && global2 || this.focusMode === "cell") {
      let item3 = this.collection.getItem(key3);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item3, this.collection);
      key3 = (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
    }
    return key3;
  }
  getItem(key3) {
    return this.ref.current.querySelector(`[data-key="${CSS.escape(key3.toString())}"]`);
  }
  getItemRect(key3) {
    var _this_layout_getLayoutInfo;
    if (this.layout) return (_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key3)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect;
    let item2 = this.getItem(key3);
    if (item2) return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(item2.offsetLeft, item2.offsetTop, item2.offsetWidth, item2.offsetHeight);
  }
  getPageHeight() {
    var _this_layout_virtualizer, _this_ref_current, _this_ref;
    if (this.layout) return (_this_layout_virtualizer = this.layout.virtualizer) === null || _this_layout_virtualizer === void 0 ? void 0 : _this_layout_virtualizer.visibleRect.height;
    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.offsetHeight;
  }
  getContentHeight() {
    var _this_ref_current, _this_ref;
    if (this.layout) return this.layout.getContentSize().height;
    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.scrollHeight;
  }
  getKeyPageAbove(key3) {
    let itemRect = this.getItemRect(key3);
    if (!itemRect) return null;
    let pageY = Math.max(0, itemRect.maxY - this.getPageHeight());
    while (itemRect && itemRect.y > pageY) {
      key3 = this.getKeyAbove(key3);
      itemRect = this.getItemRect(key3);
    }
    return key3;
  }
  getKeyPageBelow(key3) {
    let itemRect = this.getItemRect(key3);
    if (!itemRect) return null;
    let pageHeight = this.getPageHeight();
    let pageY = Math.min(this.getContentHeight(), itemRect.y + pageHeight);
    while (itemRect && itemRect.maxY < pageY) {
      let nextKey = this.getKeyBelow(key3);
      itemRect = this.getItemRect(nextKey);
      if (nextKey != null) key3 = nextKey;
    }
    return key3;
  }
  getKeyForSearch(search2, fromKey) {
    if (!this.collator) return null;
    let collection2 = this.collection;
    let key3 = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
    let startItem = collection2.getItem(key3);
    if (startItem.type === "cell") key3 = startItem.parentKey;
    let hasWrapped = false;
    while (key3 != null) {
      let item2 = collection2.getItem(key3);
      if (item2.textValue) {
        let substring = item2.textValue.slice(0, search2.length);
        if (this.collator.compare(substring, search2) === 0) {
          if (this.isRow(item2) && this.focusMode === "cell") return (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection)).key;
          return item2.key;
        }
      }
      key3 = this.findNextKey(key3);
      if (key3 == null && !hasWrapped) {
        key3 = this.getFirstKey();
        hasWrapped = true;
      }
    }
    return null;
  }
  constructor(options) {
    this.collection = options.collection;
    this.disabledKeys = options.disabledKeys;
    this.disabledBehavior = options.disabledBehavior || "all";
    this.ref = options.ref;
    this.direction = options.direction;
    this.collator = options.collator;
    this.layout = options.layout;
    this.focusMode = options.focusMode || "row";
  }
};

// node_modules/@react-aria/grid/dist/utils.mjs
var $1af922eb41e03c8f$export$e6235c0d09b995d0 = /* @__PURE__ */ new WeakMap();

// node_modules/@react-aria/grid/dist/ar-AE.mjs
var $682989befd4f478d$exports = {};
$682989befd4f478d$exports = {
  "deselectedItem": (args) => `${args.item} غير المحدد`,
  "longPressToSelect": `اضغط مطولًا للدخول إلى وضع التحديد.`,
  "select": `تحديد`,
  "selectedAll": `جميع العناصر المحددة.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `لم يتم تحديد عناصر`,
    one: () => `${formatter.number(args.count)} عنصر محدد`,
    other: () => `${formatter.number(args.count)} عنصر محدد`
  })}.`,
  "selectedItem": (args) => `${args.item} المحدد`
};

// node_modules/@react-aria/grid/dist/bg-BG.mjs
var $f7fca02019afd941$exports = {};
$f7fca02019afd941$exports = {
  "deselectedItem": (args) => `${args.item} не е избран.`,
  "longPressToSelect": `Натиснете и задръжте за да влезете в избирателен режим.`,
  "select": `Изберете`,
  "selectedAll": `Всички елементи са избрани.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Няма избрани елементи`,
    one: () => `${formatter.number(args.count)} избран елемент`,
    other: () => `${formatter.number(args.count)} избрани елементи`
  })}.`,
  "selectedItem": (args) => `${args.item} избран.`
};

// node_modules/@react-aria/grid/dist/cs-CZ.mjs
var $8f86f40be75387f1$exports = {};
$8f86f40be75387f1$exports = {
  "deselectedItem": (args) => `Položka ${args.item} není vybrána.`,
  "longPressToSelect": `Dlouhým stisknutím přejdete do režimu výběru.`,
  "select": `Vybrat`,
  "selectedAll": `Vybrány všechny položky.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nevybrány žádné položky`,
    one: () => `Vybrána ${formatter.number(args.count)} položka`,
    other: () => `Vybráno ${formatter.number(args.count)} položek`
  })}.`,
  "selectedItem": (args) => `Vybrána položka ${args.item}.`
};

// node_modules/@react-aria/grid/dist/da-DK.mjs
var $db24ba43c8d652ee$exports = {};
$db24ba43c8d652ee$exports = {
  "deselectedItem": (args) => `${args.item} ikke valgt.`,
  "longPressToSelect": `Lav et langt tryk for at aktivere valgtilstand.`,
  "select": `Vælg`,
  "selectedAll": `Alle elementer valgt.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Ingen elementer valgt`,
    one: () => `${formatter.number(args.count)} element valgt`,
    other: () => `${formatter.number(args.count)} elementer valgt`
  })}.`,
  "selectedItem": (args) => `${args.item} valgt.`
};

// node_modules/@react-aria/grid/dist/de-DE.mjs
var $f8f1e72c8b5447d6$exports = {};
$f8f1e72c8b5447d6$exports = {
  "deselectedItem": (args) => `${args.item} nicht ausgewählt.`,
  "longPressToSelect": `Gedrückt halten, um Auswahlmodus zu öffnen.`,
  "select": `Auswählen`,
  "selectedAll": `Alle Elemente ausgewählt.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Keine Elemente ausgewählt`,
    one: () => `${formatter.number(args.count)} Element ausgewählt`,
    other: () => `${formatter.number(args.count)} Elemente ausgewählt`
  })}.`,
  "selectedItem": (args) => `${args.item} ausgewählt.`
};

// node_modules/@react-aria/grid/dist/el-GR.mjs
var $9a73ed2983c3ab0b$exports = {};
$9a73ed2983c3ab0b$exports = {
  "deselectedItem": (args) => `Δεν επιλέχθηκε το στοιχείο ${args.item}.`,
  "longPressToSelect": `Πατήστε παρατεταμένα για να μπείτε σε λειτουργία επιλογής.`,
  "select": `Επιλογή`,
  "selectedAll": `Επιλέχθηκαν όλα τα στοιχεία.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Δεν επιλέχθηκαν στοιχεία`,
    one: () => `Επιλέχθηκε ${formatter.number(args.count)} στοιχείο`,
    other: () => `Επιλέχθηκαν ${formatter.number(args.count)} στοιχεία`
  })}.`,
  "selectedItem": (args) => `Επιλέχθηκε το στοιχείο ${args.item}.`
};

// node_modules/@react-aria/grid/dist/en-US.mjs
var $583de0b3587601b9$exports = {};
$583de0b3587601b9$exports = {
  "deselectedItem": (args) => `${args.item} not selected.`,
  "select": `Select`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `No items selected`,
    one: () => `${formatter.number(args.count)} item selected`,
    other: () => `${formatter.number(args.count)} items selected`
  })}.`,
  "selectedAll": `All items selected.`,
  "selectedItem": (args) => `${args.item} selected.`,
  "longPressToSelect": `Long press to enter selection mode.`
};

// node_modules/@react-aria/grid/dist/es-ES.mjs
var $147159c978043442$exports = {};
$147159c978043442$exports = {
  "deselectedItem": (args) => `${args.item} no seleccionado.`,
  "longPressToSelect": `Mantenga pulsado para abrir el modo de selección.`,
  "select": `Seleccionar`,
  "selectedAll": `Todos los elementos seleccionados.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Ningún elemento seleccionado`,
    one: () => `${formatter.number(args.count)} elemento seleccionado`,
    other: () => `${formatter.number(args.count)} elementos seleccionados`
  })}.`,
  "selectedItem": (args) => `${args.item} seleccionado.`
};

// node_modules/@react-aria/grid/dist/et-EE.mjs
var $5cbb62c8a19173ac$exports = {};
$5cbb62c8a19173ac$exports = {
  "deselectedItem": (args) => `${args.item} pole valitud.`,
  "longPressToSelect": `Valikurežiimi sisenemiseks vajutage pikalt.`,
  "select": `Vali`,
  "selectedAll": `Kõik üksused valitud.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Üksusi pole valitud`,
    one: () => `${formatter.number(args.count)} üksus valitud`,
    other: () => `${formatter.number(args.count)} üksust valitud`
  })}.`,
  "selectedItem": (args) => `${args.item} valitud.`
};

// node_modules/@react-aria/grid/dist/fi-FI.mjs
var $a33d71dc804cc59e$exports = {};
$a33d71dc804cc59e$exports = {
  "deselectedItem": (args) => `Kohdetta ${args.item} ei valittu.`,
  "longPressToSelect": `Siirry valintatilaan painamalla pitkään.`,
  "select": `Valitse`,
  "selectedAll": `Kaikki kohteet valittu.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Ei yhtään kohdetta valittu`,
    one: () => `${formatter.number(args.count)} kohde valittu`,
    other: () => `${formatter.number(args.count)} kohdetta valittu`
  })}.`,
  "selectedItem": (args) => `${args.item} valittu.`
};

// node_modules/@react-aria/grid/dist/fr-FR.mjs
var $92d800447793d084$exports = {};
$92d800447793d084$exports = {
  "deselectedItem": (args) => `${args.item} non sélectionné.`,
  "longPressToSelect": `Appuyez de manière prolongée pour passer en mode de sélection.`,
  "select": `Sélectionner`,
  "selectedAll": `Tous les éléments sélectionnés.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Aucun élément sélectionné`,
    one: () => `${formatter.number(args.count)} élément sélectionné`,
    other: () => `${formatter.number(args.count)} éléments sélectionnés`
  })}.`,
  "selectedItem": (args) => `${args.item} sélectionné.`
};

// node_modules/@react-aria/grid/dist/he-IL.mjs
var $fe732cdb32124ea8$exports = {};
$fe732cdb32124ea8$exports = {
  "deselectedItem": (args) => `${args.item} לא נבחר.`,
  "longPressToSelect": `הקשה ארוכה לכניסה למצב בחירה.`,
  "select": `בחר`,
  "selectedAll": `כל הפריטים נבחרו.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `לא נבחרו פריטים`,
    one: () => `פריט ${formatter.number(args.count)} נבחר`,
    other: () => `${formatter.number(args.count)} פריטים נבחרו`
  })}.`,
  "selectedItem": (args) => `${args.item} נבחר.`
};

// node_modules/@react-aria/grid/dist/hr-HR.mjs
var $e41234e934efb4f5$exports = {};
$e41234e934efb4f5$exports = {
  "deselectedItem": (args) => `Stavka ${args.item} nije odabrana.`,
  "longPressToSelect": `Dugo pritisnite za ulazak u način odabira.`,
  "select": `Odaberite`,
  "selectedAll": `Odabrane su sve stavke.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nije odabrana nijedna stavka`,
    one: () => `Odabrana je ${formatter.number(args.count)} stavka`,
    other: () => `Odabrano je ${formatter.number(args.count)} stavki`
  })}.`,
  "selectedItem": (args) => `Stavka ${args.item} je odabrana.`
};

// node_modules/@react-aria/grid/dist/hu-HU.mjs
var $1b0393182473bf9e$exports = {};
$1b0393182473bf9e$exports = {
  "deselectedItem": (args) => `${args.item} nincs kijelölve.`,
  "longPressToSelect": `Nyomja hosszan a kijelöléshez.`,
  "select": `Kijelölés`,
  "selectedAll": `Az összes elem kijelölve.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Egy elem sincs kijelölve`,
    one: () => `${formatter.number(args.count)} elem kijelölve`,
    other: () => `${formatter.number(args.count)} elem kijelölve`
  })}.`,
  "selectedItem": (args) => `${args.item} kijelölve.`
};

// node_modules/@react-aria/grid/dist/it-IT.mjs
var $2eed782c1c110ce7$exports = {};
$2eed782c1c110ce7$exports = {
  "deselectedItem": (args) => `${args.item} non selezionato.`,
  "longPressToSelect": `Premi a lungo per passare alla modalità di selezione.`,
  "select": `Seleziona`,
  "selectedAll": `Tutti gli elementi selezionati.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nessun elemento selezionato`,
    one: () => `${formatter.number(args.count)} elemento selezionato`,
    other: () => `${formatter.number(args.count)} elementi selezionati`
  })}.`,
  "selectedItem": (args) => `${args.item} selezionato.`
};

// node_modules/@react-aria/grid/dist/ja-JP.mjs
var $8b5d459f86e9b23c$exports = {};
$8b5d459f86e9b23c$exports = {
  "deselectedItem": (args) => `${args.item} が選択されていません。`,
  "longPressToSelect": `長押しして選択モードを開きます。`,
  "select": `選択`,
  "selectedAll": `すべての項目を選択しました。`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `項目が選択されていません`,
    one: () => `${formatter.number(args.count)} 項目を選択しました`,
    other: () => `${formatter.number(args.count)} 項目を選択しました`
  })}。`,
  "selectedItem": (args) => `${args.item} を選択しました。`
};

// node_modules/@react-aria/grid/dist/ko-KR.mjs
var $1949c3ad17295fd4$exports = {};
$1949c3ad17295fd4$exports = {
  "deselectedItem": (args) => `${args.item}이(가) 선택되지 않았습니다.`,
  "longPressToSelect": `선택 모드로 들어가려면 길게 누르십시오.`,
  "select": `선택`,
  "selectedAll": `모든 항목이 선택되었습니다.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `선택된 항목이 없습니다`,
    one: () => `${formatter.number(args.count)}개 항목이 선택되었습니다`,
    other: () => `${formatter.number(args.count)}개 항목이 선택되었습니다`
  })}.`,
  "selectedItem": (args) => `${args.item}이(가) 선택되었습니다.`
};

// node_modules/@react-aria/grid/dist/lt-LT.mjs
var $f5e3df4dc8aa7b54$exports = {};
$f5e3df4dc8aa7b54$exports = {
  "deselectedItem": (args) => `${args.item} nepasirinkta.`,
  "longPressToSelect": `Norėdami įjungti pasirinkimo režimą, paspauskite ir palaikykite.`,
  "select": `Pasirinkti`,
  "selectedAll": `Pasirinkti visi elementai.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nepasirinktas nė vienas elementas`,
    one: () => `Pasirinktas ${formatter.number(args.count)} elementas`,
    other: () => `Pasirinkta elementų: ${formatter.number(args.count)}`
  })}.`,
  "selectedItem": (args) => `Pasirinkta: ${args.item}.`
};

// node_modules/@react-aria/grid/dist/lv-LV.mjs
var $9dd86690a5c2b2c5$exports = {};
$9dd86690a5c2b2c5$exports = {
  "deselectedItem": (args) => `Vienums ${args.item} nav atlasīts.`,
  "longPressToSelect": `Ilgi turiet nospiestu. lai ieslēgtu atlases režīmu.`,
  "select": `Atlasīt`,
  "selectedAll": `Atlasīti visi vienumi.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nav atlasīts neviens vienums`,
    one: () => `Atlasīto vienumu skaits: ${formatter.number(args.count)}`,
    other: () => `Atlasīto vienumu skaits: ${formatter.number(args.count)}`
  })}.`,
  "selectedItem": (args) => `Atlasīts vienums ${args.item}.`
};

// node_modules/@react-aria/grid/dist/nb-NO.mjs
var $843964c3bf9a7d24$exports = {};
$843964c3bf9a7d24$exports = {
  "deselectedItem": (args) => `${args.item} er ikke valgt.`,
  "longPressToSelect": `Bruk et langt trykk for å gå inn i valgmodus.`,
  "select": `Velg`,
  "selectedAll": `Alle elementer er valgt.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Ingen elementer er valgt`,
    one: () => `${formatter.number(args.count)} element er valgt`,
    other: () => `${formatter.number(args.count)} elementer er valgt`
  })}.`,
  "selectedItem": (args) => `${args.item} er valgt.`
};

// node_modules/@react-aria/grid/dist/nl-NL.mjs
var $73f50e845f9ef3b4$exports = {};
$73f50e845f9ef3b4$exports = {
  "deselectedItem": (args) => `${args.item} niet geselecteerd.`,
  "longPressToSelect": `Druk lang om de selectiemodus te openen.`,
  "select": `Selecteren`,
  "selectedAll": `Alle items geselecteerd.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Geen items geselecteerd`,
    one: () => `${formatter.number(args.count)} item geselecteerd`,
    other: () => `${formatter.number(args.count)} items geselecteerd`
  })}.`,
  "selectedItem": (args) => `${args.item} geselecteerd.`
};

// node_modules/@react-aria/grid/dist/pl-PL.mjs
var $87f92a7e077514b2$exports = {};
$87f92a7e077514b2$exports = {
  "deselectedItem": (args) => `Nie zaznaczono ${args.item}.`,
  "longPressToSelect": `Naciśnij i przytrzymaj, aby wejść do trybu wyboru.`,
  "select": `Zaznacz`,
  "selectedAll": `Wszystkie zaznaczone elementy.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nie zaznaczono żadnych elementów`,
    one: () => `${formatter.number(args.count)} zaznaczony element`,
    other: () => `${formatter.number(args.count)} zaznaczonych elementów`
  })}.`,
  "selectedItem": (args) => `Zaznaczono ${args.item}.`
};

// node_modules/@react-aria/grid/dist/pt-BR.mjs
var $c28c98d58ee9ff6f$exports = {};
$c28c98d58ee9ff6f$exports = {
  "deselectedItem": (args) => `${args.item} não selecionado.`,
  "longPressToSelect": `Mantenha pressionado para entrar no modo de seleção.`,
  "select": `Selecionar`,
  "selectedAll": `Todos os itens selecionados.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nenhum item selecionado`,
    one: () => `${formatter.number(args.count)} item selecionado`,
    other: () => `${formatter.number(args.count)} itens selecionados`
  })}.`,
  "selectedItem": (args) => `${args.item} selecionado.`
};

// node_modules/@react-aria/grid/dist/pt-PT.mjs
var $b6b1503b17b2254d$exports = {};
$b6b1503b17b2254d$exports = {
  "deselectedItem": (args) => `${args.item} não selecionado.`,
  "longPressToSelect": `Prima continuamente para entrar no modo de seleção.`,
  "select": `Selecionar`,
  "selectedAll": `Todos os itens selecionados.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nenhum item selecionado`,
    one: () => `${formatter.number(args.count)} item selecionado`,
    other: () => `${formatter.number(args.count)} itens selecionados`
  })}.`,
  "selectedItem": (args) => `${args.item} selecionado.`
};

// node_modules/@react-aria/grid/dist/ro-RO.mjs
var $8bdaeb71e50c3e1a$exports = {};
$8bdaeb71e50c3e1a$exports = {
  "deselectedItem": (args) => `${args.item} neselectat.`,
  "longPressToSelect": `Apăsați lung pentru a intra în modul de selectare.`,
  "select": `Selectare`,
  "selectedAll": `Toate elementele selectate.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Niciun element selectat`,
    one: () => `${formatter.number(args.count)} element selectat`,
    other: () => `${formatter.number(args.count)} elemente selectate`
  })}.`,
  "selectedItem": (args) => `${args.item} selectat.`
};

// node_modules/@react-aria/grid/dist/ru-RU.mjs
var $ec2b852dd7c3d1f2$exports = {};
$ec2b852dd7c3d1f2$exports = {
  "deselectedItem": (args) => `${args.item} не выбрано.`,
  "longPressToSelect": `Нажмите и удерживайте для входа в режим выбора.`,
  "select": `Выбрать`,
  "selectedAll": `Выбраны все элементы.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Нет выбранных элементов`,
    one: () => `${formatter.number(args.count)} элемент выбран`,
    other: () => `${formatter.number(args.count)} элементов выбрано`
  })}.`,
  "selectedItem": (args) => `${args.item} выбрано.`
};

// node_modules/@react-aria/grid/dist/sk-SK.mjs
var $79e6d900d6a4f82d$exports = {};
$79e6d900d6a4f82d$exports = {
  "deselectedItem": (args) => `Nevybraté položky: ${args.item}.`,
  "longPressToSelect": `Dlhším stlačením prejdite do režimu výberu.`,
  "select": `Vybrať`,
  "selectedAll": `Všetky vybraté položky.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Žiadne vybraté položky`,
    one: () => `${formatter.number(args.count)} vybratá položka`,
    other: () => `Počet vybratých položiek:${formatter.number(args.count)}`
  })}.`,
  "selectedItem": (args) => `Vybraté položky: ${args.item}.`
};

// node_modules/@react-aria/grid/dist/sl-SI.mjs
var $f4c1f0d5d4d03d80$exports = {};
$f4c1f0d5d4d03d80$exports = {
  "deselectedItem": (args) => `Element ${args.item} ni izbran.`,
  "longPressToSelect": `Za izbirni način pritisnite in dlje časa držite.`,
  "select": `Izberite`,
  "selectedAll": `Vsi elementi so izbrani.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Noben element ni izbran`,
    one: () => `${formatter.number(args.count)} element je izbran`,
    other: () => `${formatter.number(args.count)} elementov je izbranih`
  })}.`,
  "selectedItem": (args) => `Element ${args.item} je izbran.`
};

// node_modules/@react-aria/grid/dist/sr-SP.mjs
var $46252cd87269b10b$exports = {};
$46252cd87269b10b$exports = {
  "deselectedItem": (args) => `${args.item} nije izabrano.`,
  "longPressToSelect": `Dugo pritisnite za ulazak u režim biranja.`,
  "select": `Izaberite`,
  "selectedAll": `Izabrane su sve stavke.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nije izabrana nijedna stavka`,
    one: () => `Izabrana je ${formatter.number(args.count)} stavka`,
    other: () => `Izabrano je ${formatter.number(args.count)} stavki`
  })}.`,
  "selectedItem": (args) => `${args.item} je izabrano.`
};

// node_modules/@react-aria/grid/dist/sv-SE.mjs
var $d4d5d8dab362555c$exports = {};
$d4d5d8dab362555c$exports = {
  "deselectedItem": (args) => `${args.item} ej markerat.`,
  "longPressToSelect": `Tryck länge när du vill öppna väljarläge.`,
  "select": `Markera`,
  "selectedAll": `Alla markerade objekt.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Inga markerade objekt`,
    one: () => `${formatter.number(args.count)} markerat objekt`,
    other: () => `${formatter.number(args.count)} markerade objekt`
  })}.`,
  "selectedItem": (args) => `${args.item} markerat.`
};

// node_modules/@react-aria/grid/dist/tr-TR.mjs
var $3d55d1f97c377e83$exports = {};
$3d55d1f97c377e83$exports = {
  "deselectedItem": (args) => `${args.item} seçilmedi.`,
  "longPressToSelect": `Seçim moduna girmek için uzun basın.`,
  "select": `Seç`,
  "selectedAll": `Tüm ögeler seçildi.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Hiçbir öge seçilmedi`,
    one: () => `${formatter.number(args.count)} öge seçildi`,
    other: () => `${formatter.number(args.count)} öge seçildi`
  })}.`,
  "selectedItem": (args) => `${args.item} seçildi.`
};

// node_modules/@react-aria/grid/dist/uk-UA.mjs
var $5368512f1c703a3f$exports = {};
$5368512f1c703a3f$exports = {
  "deselectedItem": (args) => `${args.item} не вибрано.`,
  "longPressToSelect": `Виконайте довге натиснення, щоб перейти в режим вибору.`,
  "select": `Вибрати`,
  "selectedAll": `Усі елементи вибрано.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Жодних елементів не вибрано`,
    one: () => `${formatter.number(args.count)} елемент вибрано`,
    other: () => `Вибрано елементів: ${formatter.number(args.count)}`
  })}.`,
  "selectedItem": (args) => `${args.item} вибрано.`
};

// node_modules/@react-aria/grid/dist/zh-CN.mjs
var $f1316b1074463583$exports = {};
$f1316b1074463583$exports = {
  "deselectedItem": (args) => `未选择 ${args.item}。`,
  "longPressToSelect": `长按以进入选择模式。`,
  "select": `选择`,
  "selectedAll": `已选择所有项目。`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `未选择项目`,
    one: () => `已选择 ${formatter.number(args.count)} 个项目`,
    other: () => `已选择 ${formatter.number(args.count)} 个项目`
  })}。`,
  "selectedItem": (args) => `已选择 ${args.item}。`
};

// node_modules/@react-aria/grid/dist/zh-TW.mjs
var $7e60654723031b6f$exports = {};
$7e60654723031b6f$exports = {
  "deselectedItem": (args) => `未選取「${args.item}」。`,
  "longPressToSelect": `長按以進入選擇模式。`,
  "select": `選取`,
  "selectedAll": `已選取所有項目。`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `未選取任何項目`,
    one: () => `已選取 ${formatter.number(args.count)} 個項目`,
    other: () => `已選取 ${formatter.number(args.count)} 個項目`
  })}。`,
  "selectedItem": (args) => `已選取「${args.item}」。`
};

// node_modules/@react-aria/grid/dist/intlStrings.mjs
var $835c96616a7cb4f9$exports = {};
$835c96616a7cb4f9$exports = {
  "ar-AE": $682989befd4f478d$exports,
  "bg-BG": $f7fca02019afd941$exports,
  "cs-CZ": $8f86f40be75387f1$exports,
  "da-DK": $db24ba43c8d652ee$exports,
  "de-DE": $f8f1e72c8b5447d6$exports,
  "el-GR": $9a73ed2983c3ab0b$exports,
  "en-US": $583de0b3587601b9$exports,
  "es-ES": $147159c978043442$exports,
  "et-EE": $5cbb62c8a19173ac$exports,
  "fi-FI": $a33d71dc804cc59e$exports,
  "fr-FR": $92d800447793d084$exports,
  "he-IL": $fe732cdb32124ea8$exports,
  "hr-HR": $e41234e934efb4f5$exports,
  "hu-HU": $1b0393182473bf9e$exports,
  "it-IT": $2eed782c1c110ce7$exports,
  "ja-JP": $8b5d459f86e9b23c$exports,
  "ko-KR": $1949c3ad17295fd4$exports,
  "lt-LT": $f5e3df4dc8aa7b54$exports,
  "lv-LV": $9dd86690a5c2b2c5$exports,
  "nb-NO": $843964c3bf9a7d24$exports,
  "nl-NL": $73f50e845f9ef3b4$exports,
  "pl-PL": $87f92a7e077514b2$exports,
  "pt-BR": $c28c98d58ee9ff6f$exports,
  "pt-PT": $b6b1503b17b2254d$exports,
  "ro-RO": $8bdaeb71e50c3e1a$exports,
  "ru-RU": $ec2b852dd7c3d1f2$exports,
  "sk-SK": $79e6d900d6a4f82d$exports,
  "sl-SI": $f4c1f0d5d4d03d80$exports,
  "sr-SP": $46252cd87269b10b$exports,
  "sv-SE": $d4d5d8dab362555c$exports,
  "tr-TR": $3d55d1f97c377e83$exports,
  "uk-UA": $5368512f1c703a3f$exports,
  "zh-CN": $f1316b1074463583$exports,
  "zh-TW": $7e60654723031b6f$exports
};

// node_modules/@react-aria/grid/dist/useGridSelectionAnnouncement.mjs
var import_react36 = __toESM(require_react(), 1);
function $parcel$interopDefault2(a) {
  return a && a.__esModule ? a.default : a;
}
function $92599c3fd427b763$export$137e594ef3218a10(props, state2) {
  let { getRowText = (key3) => {
    var _state_collection_getTextValue, _state_collection, _state_collection_getItem;
    var _state_collection_getTextValue1;
    return (_state_collection_getTextValue1 = (_state_collection_getTextValue = (_state_collection = state2.collection).getTextValue) === null || _state_collection_getTextValue === void 0 ? void 0 : _state_collection_getTextValue.call(_state_collection, key3)) !== null && _state_collection_getTextValue1 !== void 0 ? _state_collection_getTextValue1 : (_state_collection_getItem = state2.collection.getItem(key3)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.textValue;
  } } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($835c96616a7cb4f9$exports)), "@react-aria/grid");
  let selection = state2.selectionManager.rawSelection;
  let lastSelection = (0, import_react36.useRef)(selection);
  (0, $4f58c5f72bcf79f7$export$496315a1608d9602)(() => {
    var _lastSelection_current;
    if (!state2.selectionManager.isFocused) {
      lastSelection.current = selection;
      return;
    }
    let addedKeys = $92599c3fd427b763$var$diffSelection(selection, lastSelection.current);
    let removedKeys = $92599c3fd427b763$var$diffSelection(lastSelection.current, selection);
    let isReplace = state2.selectionManager.selectionBehavior === "replace";
    let messages2 = [];
    if (state2.selectionManager.selectedKeys.size === 1 && isReplace) {
      if (state2.collection.getItem(state2.selectionManager.selectedKeys.keys().next().value)) {
        let currentSelectionText = getRowText(state2.selectionManager.selectedKeys.keys().next().value);
        if (currentSelectionText) messages2.push(stringFormatter.format("selectedItem", {
          item: currentSelectionText
        }));
      }
    } else if (addedKeys.size === 1 && removedKeys.size === 0) {
      let addedText = getRowText(addedKeys.keys().next().value);
      if (addedText) messages2.push(stringFormatter.format("selectedItem", {
        item: addedText
      }));
    } else if (removedKeys.size === 1 && addedKeys.size === 0) {
      if (state2.collection.getItem(removedKeys.keys().next().value)) {
        let removedText = getRowText(removedKeys.keys().next().value);
        if (removedText) messages2.push(stringFormatter.format("deselectedItem", {
          item: removedText
        }));
      }
    }
    if (state2.selectionManager.selectionMode === "multiple") {
      if (messages2.length === 0 || selection === "all" || selection.size > 1 || lastSelection.current === "all" || ((_lastSelection_current = lastSelection.current) === null || _lastSelection_current === void 0 ? void 0 : _lastSelection_current.size) > 1) messages2.push(selection === "all" ? stringFormatter.format("selectedAll") : stringFormatter.format("selectedCount", {
        count: selection.size
      }));
    }
    if (messages2.length > 0) (0, $319e236875307eab$export$a9b970dcc4ae71a9)(messages2.join(" "));
    lastSelection.current = selection;
  }, [
    selection
  ]);
}
function $92599c3fd427b763$var$diffSelection(a, b) {
  let res = /* @__PURE__ */ new Set();
  if (a === "all" || b === "all") return res;
  for (let key3 of a.keys()) if (!b.has(key3)) res.add(key3);
  return res;
}

// node_modules/@react-aria/grid/dist/useHighlightSelectionDescription.mjs
var import_react37 = __toESM(require_react(), 1);
function $parcel$interopDefault3(a) {
  return a && a.__esModule ? a.default : a;
}
function $5b9b5b5723db6ae1$export$be42ebdab07ae4c2(props) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($835c96616a7cb4f9$exports)), "@react-aria/grid");
  let modality = (0, $507fabe10e71c6fb$export$98e20ec92f614cfe)();
  let shouldLongPress = (modality === "pointer" || modality === "virtual" || modality == null) && typeof window !== "undefined" && "ontouchstart" in window;
  let interactionDescription = (0, import_react37.useMemo)(() => {
    let selectionMode = props.selectionManager.selectionMode;
    let selectionBehavior = props.selectionManager.selectionBehavior;
    let message = void 0;
    if (shouldLongPress) message = stringFormatter.format("longPressToSelect");
    return selectionBehavior === "replace" && selectionMode !== "none" && props.hasItemActions ? message : void 0;
  }, [
    props.selectionManager.selectionMode,
    props.selectionManager.selectionBehavior,
    props.hasItemActions,
    stringFormatter,
    shouldLongPress
  ]);
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(interactionDescription);
  return descriptionProps;
}

// node_modules/@react-aria/grid/dist/useGrid.mjs
var import_react38 = __toESM(require_react(), 1);
function $83c6e2eafa584c67$export$f6b86a04e5d66d90(props, state2, ref2) {
  let { isVirtualized, keyboardDelegate, focusMode, scrollRef, getRowText, onRowAction, onCellAction } = props;
  let { selectionManager: manager } = state2;
  if (!props["aria-label"] && !props["aria-labelledby"]) console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let disabledBehavior = state2.selectionManager.disabledBehavior;
  let delegate = (0, import_react38.useMemo)(() => keyboardDelegate || new (0, $d1c300d9c497e402$export$de9feff04fda126e)({
    collection: state2.collection,
    disabledKeys: state2.disabledKeys,
    disabledBehavior,
    ref: ref2,
    direction,
    collator,
    focusMode
  }), [
    keyboardDelegate,
    state2.collection,
    state2.disabledKeys,
    disabledBehavior,
    ref2,
    direction,
    collator,
    focusMode
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    ref: ref2,
    selectionManager: manager,
    keyboardDelegate: delegate,
    isVirtualized,
    scrollRef
  });
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).set(state2, {
    keyboardDelegate: delegate,
    actions: {
      onRowAction,
      onCellAction
    }
  });
  let descriptionProps = (0, $5b9b5b5723db6ae1$export$be42ebdab07ae4c2)({
    selectionManager: manager,
    hasItemActions: !!(onRowAction || onCellAction)
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let onFocus = (0, import_react38.useCallback)((e3) => {
    if (manager.isFocused) {
      if (!e3.currentTarget.contains(e3.target)) manager.setFocused(false);
      return;
    }
    if (!e3.currentTarget.contains(e3.target)) return;
    manager.setFocused(true);
  }, [
    manager
  ]);
  let navDisabledHandlers = (0, import_react38.useMemo)(() => ({
    onBlur: collectionProps.onBlur,
    onFocus
  }), [
    onFocus,
    collectionProps.onBlur
  ]);
  let hasTabbableChild = (0, $83013635b024ae3d$export$eac1895992b9f3d6)(ref2, {
    isDisabled: state2.collection.size !== 0
  });
  let gridProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
    domProps,
    {
      role: "grid",
      id,
      "aria-multiselectable": manager.selectionMode === "multiple" ? "true" : void 0
    },
    state2.isKeyboardNavigationDisabled ? navDisabledHandlers : collectionProps,
    // If collection is empty, make sure the grid is tabbable unless there is a child tabbable element.
    state2.collection.size === 0 && {
      tabIndex: hasTabbableChild ? -1 : 0
    },
    descriptionProps
  );
  if (isVirtualized) {
    gridProps["aria-rowcount"] = state2.collection.size;
    gridProps["aria-colcount"] = state2.collection.columnCount;
  }
  (0, $92599c3fd427b763$export$137e594ef3218a10)({
    getRowText
  }, state2);
  return {
    gridProps
  };
}

// node_modules/@react-aria/grid/dist/useGridRowGroup.mjs
function $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf() {
  return {
    rowGroupProps: {
      role: "rowgroup"
    }
  };
}

// node_modules/@react-aria/grid/dist/useGridRow.mjs
function $4159a7a9cbb0cc18$export$96357d5a73f686fa(props, state2, ref2) {
  var _node_props, _node_props1;
  let { node: node3, isVirtualized, shouldSelectOnPressUp, onAction } = props;
  let { actions } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state2);
  let onRowAction = actions.onRowAction ? () => actions.onRowAction(node3.key) : onAction;
  let { itemProps, ...states } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state2.selectionManager,
    key: node3.key,
    ref: ref2,
    isVirtualized,
    shouldSelectOnPressUp,
    onAction: onRowAction || (node3 === null || node3 === void 0 ? void 0 : (_node_props = node3.props) === null || _node_props === void 0 ? void 0 : _node_props.onAction) ? (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(node3 === null || node3 === void 0 ? void 0 : (_node_props1 = node3.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.onAction, onRowAction) : void 0,
    isDisabled: state2.collection.size === 0
  });
  let isSelected = state2.selectionManager.isSelected(node3.key);
  let rowProps = {
    role: "row",
    "aria-selected": state2.selectionManager.selectionMode !== "none" ? isSelected : void 0,
    "aria-disabled": states.isDisabled || void 0,
    ...itemProps
  };
  if (isVirtualized) rowProps["aria-rowindex"] = node3.index + 1;
  return {
    rowProps,
    ...states
  };
}

// node_modules/@react-aria/grid/dist/useGridCell.mjs
var import_react39 = __toESM(require_react(), 1);
function $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state2, ref2) {
  let { node: node3, isVirtualized, focusMode = "child", shouldSelectOnPressUp, onAction } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { keyboardDelegate, actions: { onCellAction } } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state2);
  let keyWhenFocused = (0, import_react39.useRef)(null);
  let focus = () => {
    let treeWalker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref2.current);
    if (focusMode === "child") {
      if (ref2.current.contains(document.activeElement) && ref2.current !== document.activeElement) return;
      let focusable = state2.selectionManager.childFocusStrategy === "last" ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();
      if (focusable) {
        (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
        return;
      }
    }
    if (keyWhenFocused.current != null && node3.key !== keyWhenFocused.current || !ref2.current.contains(document.activeElement)) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
  };
  let { itemProps, isPressed } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state2.selectionManager,
    key: node3.key,
    ref: ref2,
    isVirtualized,
    focus,
    shouldSelectOnPressUp,
    onAction: onCellAction ? () => onCellAction(node3.key) : onAction,
    isDisabled: state2.collection.size === 0
  });
  let onKeyDownCapture = (e3) => {
    if (!e3.currentTarget.contains(e3.target) || state2.isKeyboardNavigationDisabled) return;
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref2.current);
    walker.currentNode = document.activeElement;
    switch (e3.key) {
      case "ArrowLeft": {
        let focusable = direction === "rtl" ? walker.nextNode() : walker.previousNode();
        if (focusMode === "child" && focusable === ref2.current) focusable = null;
        e3.preventDefault();
        e3.stopPropagation();
        if (focusable) {
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
          });
        } else {
          let prev = keyboardDelegate.getKeyLeftOf(node3.key);
          if (prev !== node3.key) {
            ref2.current.parentElement.dispatchEvent(new KeyboardEvent(e3.nativeEvent.type, e3.nativeEvent));
            break;
          }
          if (focusMode === "cell" && direction === "rtl") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref2.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
            });
          } else {
            walker.currentNode = ref2.current;
            focusable = direction === "rtl" ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);
            if (focusable) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowRight": {
        let focusable = direction === "rtl" ? walker.previousNode() : walker.nextNode();
        if (focusMode === "child" && focusable === ref2.current) focusable = null;
        e3.preventDefault();
        e3.stopPropagation();
        if (focusable) {
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
          });
        } else {
          let next = keyboardDelegate.getKeyRightOf(node3.key);
          if (next !== node3.key) {
            ref2.current.parentElement.dispatchEvent(new KeyboardEvent(e3.nativeEvent.type, e3.nativeEvent));
            break;
          }
          if (focusMode === "cell" && direction === "ltr") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref2.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
            });
          } else {
            walker.currentNode = ref2.current;
            focusable = direction === "rtl" ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();
            if (focusable) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
        if (!e3.altKey && ref2.current.contains(e3.target)) {
          e3.stopPropagation();
          e3.preventDefault();
          ref2.current.parentElement.dispatchEvent(new KeyboardEvent(e3.nativeEvent.type, e3.nativeEvent));
        }
        break;
    }
  };
  let onFocus = (e3) => {
    keyWhenFocused.current = node3.key;
    if (e3.target !== ref2.current) {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()) state2.selectionManager.setFocusedKey(node3.key);
      return;
    }
    requestAnimationFrame(() => {
      if (focusMode === "child" && document.activeElement === ref2.current) focus();
    });
  };
  let gridCellProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, {
    role: "gridcell",
    onKeyDownCapture,
    onFocus
  });
  var _node_colIndex;
  if (isVirtualized) gridCellProps["aria-colindex"] = ((_node_colIndex = node3.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node3.index) + 1;
  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) gridCellProps.onPointerDown = (e3) => {
    let el = e3.currentTarget;
    let tabindex = el.getAttribute("tabindex");
    el.removeAttribute("tabindex");
    requestAnimationFrame(() => {
      el.setAttribute("tabindex", tabindex);
    });
  };
  return {
    gridCellProps,
    isPressed
  };
}
function $ab90dcbc1b5466d0$var$last(walker) {
  let next;
  let last;
  do {
    last = walker.lastChild();
    if (last) next = last;
  } while (last);
  return next;
}

// node_modules/@react-aria/grid/dist/useGridSelectionCheckbox.mjs
function $parcel$interopDefault4(a) {
  return a && a.__esModule ? a.default : a;
}
function $7cb39d07f245a780$export$70e2eed1a92976ad(props, state2) {
  let { key: key3 } = props;
  let manager = state2.selectionManager;
  let checkboxId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let isDisabled = !state2.selectionManager.canSelectItem(key3);
  let isSelected = state2.selectionManager.isSelected(key3);
  let onChange = () => manager.select(key3);
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault4($835c96616a7cb4f9$exports)), "@react-aria/grid");
  return {
    checkboxProps: {
      id: checkboxId,
      "aria-label": stringFormatter.format("select"),
      isSelected,
      isDisabled,
      onChange
    }
  };
}

// node_modules/@react-aria/gridlist/dist/useGridList.mjs
function $f47efb0c3a859cf2$export$664f9155035607eb(props, state2, ref2) {
  let { isVirtualized, keyboardDelegate, onAction, linkBehavior = "action" } = props;
  if (!props["aria-label"] && !props["aria-labelledby"]) console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    selectionManager: state2.selectionManager,
    collection: state2.collection,
    disabledKeys: state2.disabledKeys,
    ref: ref2,
    keyboardDelegate,
    isVirtualized,
    selectOnFocus: state2.selectionManager.selectionBehavior === "replace",
    shouldFocusWrap: props.shouldFocusWrap,
    linkBehavior
  });
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $ce9b18daab526bbd$export$5b9bb410392e3991).set(state2, {
    id,
    onAction,
    linkBehavior
  });
  let descriptionProps = (0, $5b9b5b5723db6ae1$export$be42ebdab07ae4c2)({
    selectionManager: state2.selectionManager,
    hasItemActions: !!onAction
  });
  let hasTabbableChild = (0, $83013635b024ae3d$export$eac1895992b9f3d6)(ref2, {
    isDisabled: state2.collection.size !== 0
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let gridProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
    domProps,
    {
      role: "grid",
      id,
      "aria-multiselectable": state2.selectionManager.selectionMode === "multiple" ? "true" : void 0
    },
    // If collection is empty, make sure the grid is tabbable unless there is a child tabbable element.
    state2.collection.size === 0 ? {
      tabIndex: hasTabbableChild ? -1 : 0
    } : listProps,
    descriptionProps
  );
  if (isVirtualized) {
    gridProps["aria-rowcount"] = state2.collection.size;
    gridProps["aria-colcount"] = 1;
  }
  (0, $92599c3fd427b763$export$137e594ef3218a10)({}, state2);
  return {
    gridProps
  };
}

// node_modules/@react-aria/gridlist/dist/useGridListItem.mjs
var import_react40 = __toESM(require_react(), 1);
var $4e8b0456ef72939f$var$EXPANSION_KEYS = {
  "expand": {
    ltr: "ArrowRight",
    rtl: "ArrowLeft"
  },
  "collapse": {
    ltr: "ArrowLeft",
    rtl: "ArrowRight"
  }
};
function $4e8b0456ef72939f$export$9610e69494fadfd2(props, state2, ref2) {
  var _node_props, _node_props1;
  let { node: node3, isVirtualized, shouldSelectOnPressUp } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { onAction, linkBehavior } = (0, $ce9b18daab526bbd$export$5b9bb410392e3991).get(state2);
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let keyWhenFocused = (0, import_react40.useRef)(null);
  let focus = () => {
    var _ref_current;
    if (keyWhenFocused.current != null && node3.key !== keyWhenFocused.current || !((_ref_current = ref2.current) === null || _ref_current === void 0 ? void 0 : _ref_current.contains(document.activeElement))) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
  };
  let treeGridRowProps = {};
  let hasChildRows;
  let hasLink = state2.selectionManager.isLink(node3.key);
  if (node3 != null && "expandedKeys" in state2) {
    hasChildRows = [
      ...state2.collection.getChildren(node3.key)
    ].length > 1;
    if (onAction == null && !hasLink && state2.selectionManager.selectionMode === "none" && hasChildRows) onAction = () => state2.toggleKey(node3.key);
    let isExpanded = hasChildRows ? state2.expandedKeys.has(node3.key) : void 0;
    treeGridRowProps = {
      "aria-expanded": isExpanded,
      "aria-level": node3.level + 1,
      "aria-posinset": (node3 === null || node3 === void 0 ? void 0 : node3.index) + 1,
      "aria-setsize": node3.level > 0 ? (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(state2.collection.getChildren(node3 === null || node3 === void 0 ? void 0 : node3.parentKey)).index + 1 : [
        ...state2.collection
      ].filter((row) => row.level === 0).at(-1).index + 1
    };
  }
  let { itemProps, ...itemStates } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state2.selectionManager,
    key: node3.key,
    ref: ref2,
    isVirtualized,
    shouldSelectOnPressUp,
    onAction: onAction || ((_node_props = node3.props) === null || _node_props === void 0 ? void 0 : _node_props.onAction) ? (0, $ff5963eb1fccf552$export$e08e3b67e392101e)((_node_props1 = node3.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.onAction, onAction ? () => onAction(node3.key) : void 0) : void 0,
    focus,
    linkBehavior
  });
  let onKeyDown = (e3) => {
    if (!e3.currentTarget.contains(e3.target)) return;
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref2.current);
    walker.currentNode = document.activeElement;
    if ("expandedKeys" in state2 && document.activeElement === ref2.current) {
      if (e3.key === $4e8b0456ef72939f$var$EXPANSION_KEYS["expand"][direction] && state2.selectionManager.focusedKey === node3.key && hasChildRows && !state2.expandedKeys.has(node3.key)) {
        state2.toggleKey(node3.key);
        e3.stopPropagation();
        return;
      } else if (e3.key === $4e8b0456ef72939f$var$EXPANSION_KEYS["collapse"][direction] && state2.selectionManager.focusedKey === node3.key && hasChildRows && state2.expandedKeys.has(node3.key)) {
        state2.toggleKey(node3.key);
        e3.stopPropagation();
        return;
      }
    }
    switch (e3.key) {
      case "ArrowLeft": {
        let focusable = direction === "rtl" ? walker.nextNode() : walker.previousNode();
        if (focusable) {
          e3.preventDefault();
          e3.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
          });
        } else {
          e3.preventDefault();
          e3.stopPropagation();
          if (direction === "rtl") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref2.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
            });
          } else {
            walker.currentNode = ref2.current;
            let lastElement = $4e8b0456ef72939f$var$last(walker);
            if (lastElement) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(lastElement);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(lastElement, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowRight": {
        let focusable = direction === "rtl" ? walker.previousNode() : walker.nextNode();
        if (focusable) {
          e3.preventDefault();
          e3.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
          });
        } else {
          e3.preventDefault();
          e3.stopPropagation();
          if (direction === "ltr") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref2.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref2.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
            });
          } else {
            walker.currentNode = ref2.current;
            let lastElement = $4e8b0456ef72939f$var$last(walker);
            if (lastElement) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(lastElement);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(lastElement, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref2.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
        if (!e3.altKey && ref2.current.contains(e3.target)) {
          e3.stopPropagation();
          e3.preventDefault();
          ref2.current.parentElement.dispatchEvent(new KeyboardEvent(e3.nativeEvent.type, e3.nativeEvent));
        }
        break;
    }
  };
  let onFocus = (e3) => {
    keyWhenFocused.current = node3.key;
    if (e3.target !== ref2.current) {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()) state2.selectionManager.setFocusedKey(node3.key);
      return;
    }
  };
  let linkProps = itemStates.hasAction ? (0, $ea8dcbcb9ea1b556$export$51437d503373d223)(node3.props) : {};
  let rowProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, linkProps, {
    role: "row",
    onKeyDownCapture: onKeyDown,
    onFocus,
    // 'aria-label': [(node.textValue || undefined), rowAnnouncement].filter(Boolean).join(', '),
    "aria-label": node3.textValue || void 0,
    "aria-selected": state2.selectionManager.canSelectItem(node3.key) ? state2.selectionManager.isSelected(node3.key) : void 0,
    "aria-disabled": state2.selectionManager.isDisabled(node3.key) || void 0,
    "aria-labelledby": descriptionId && node3.textValue ? `${(0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state2, node3.key)} ${descriptionId}` : void 0,
    id: (0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state2, node3.key)
  });
  if (isVirtualized) rowProps["aria-rowindex"] = node3.index + 1;
  let gridCellProps = {
    role: "gridcell",
    "aria-colindex": 1
  };
  return {
    rowProps: {
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(rowProps, treeGridRowProps)
    },
    gridCellProps,
    descriptionProps: {
      id: descriptionId
    },
    ...itemStates
  };
}
function $4e8b0456ef72939f$var$last(walker) {
  let next;
  let last;
  do {
    last = walker.lastChild();
    if (last) next = last;
  } while (last);
  return next;
}

// node_modules/@react-aria/gridlist/dist/useGridListSelectionCheckbox.mjs
function $e52ffc04a4adbd52$export$e29f2573fabbf7b9(props, state2) {
  let { key: key3 } = props;
  const { checkboxProps } = (0, $7cb39d07f245a780$export$70e2eed1a92976ad)(props, state2);
  return {
    checkboxProps: {
      ...checkboxProps,
      "aria-labelledby": `${checkboxProps.id} ${(0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state2, key3)}`
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-list-view.js
var import_react41 = __toESM(require_react());
var import_jsx_runtime30 = __toESM(require_jsx_runtime());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronLeftIcon.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var chevronLeftIcon = (0, import_jsx_runtime27.jsx)("path", {
  d: "m15 18-6-6 6-6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronRightIcon.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var chevronRightIcon = (0, import_jsx_runtime28.jsx)("path", {
  d: "m9 18 6-6-6-6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gripVerticalIcon.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var gripVerticalIcon = (0, import_jsx_runtime29.jsxs)(import_jsx_runtime29.Fragment, {
  children: [(0, import_jsx_runtime29.jsx)("circle", {
    cx: 9,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime29.jsx)("circle", {
    cx: 9,
    cy: 5,
    r: 1
  }), (0, import_jsx_runtime29.jsx)("circle", {
    cx: 9,
    cy: 19,
    r: 1
  }), (0, import_jsx_runtime29.jsx)("circle", {
    cx: 15,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime29.jsx)("circle", {
    cx: 15,
    cy: 5,
    r: 1
  }), (0, import_jsx_runtime29.jsx)("circle", {
    cx: 15,
    cy: 19,
    r: 1
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-list-view.js
var listViewClassList = new ClassList("ListView", ["centered-wrapper"]);
var listViewItemClassList = new ClassList("ListViewItem", ["actionmenu", "actions", "badge", "checkbox", "content", "description", "draghandle", "grid", "parent-indicator", "row", "thumbnail"]);
var ListViewContext = (
  // @ts-expect-error
  (0, import_react41.createContext)(null)
);
var ListViewProvider = ListViewContext.Provider;
function useListViewContext() {
  let context = (0, import_react41.useContext)(ListViewContext);
  if (!context) {
    throw new Error("Attempt to access `ListViewContext` outside of its provided.");
  }
  return context;
}
var localizedMessages4 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    loadingMore: "جارٍ تحميل المزيد..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    loadingMore: "Зареждане на още..."
  },
  "cs-CZ": {
    loading: "Načítání...",
    loadingMore: "Načítání dalších..."
  },
  "da-DK": {
    loading: "Indlæser...",
    loadingMore: "Indlæser flere..."
  },
  "de-DE": {
    loading: "Laden...",
    loadingMore: "Mehr laden ..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    loadingMore: "Φόρτωση περισσότερων..."
  },
  "en-US": {
    loading: "Loading…",
    loadingMore: "Loading more…"
  },
  "es-ES": {
    loading: "Cargando…",
    loadingMore: "Cargando más…"
  },
  "et-EE": {
    loading: "Laadimine...",
    loadingMore: "Laadi rohkem..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    loadingMore: "Ladataan lisää…"
  },
  "fr-FR": {
    loading: "Chargement...",
    loadingMore: "Chargement supplémentaire..."
  },
  "he-IL": {
    loading: "טוען...",
    loadingMore: "טוען עוד..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    loadingMore: "Továbbiak betöltése folyamatban…"
  },
  "it-IT": {
    loading: "Caricamento...",
    loadingMore: "Caricamento altri..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    loadingMore: "さらに読み込み中..."
  },
  "ko-KR": {
    loading: "로드 중…",
    loadingMore: "추가 로드 중…"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    loadingMore: "Įkeliama daugiau..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    loadingMore: "Tiek ielādēts vēl..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    loadingMore: "Laster inn flere ..."
  },
  "nl-NL": {
    loading: "Laden...",
    loadingMore: "Meer laden..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    loadingMore: "Wczytywanie większej liczby..."
  },
  "pt-BR": {
    loading: "Carregando...",
    loadingMore: "Carregando mais..."
  },
  "pt-PT": {
    loading: "A carregar...",
    loadingMore: "A carregar mais..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    loadingMore: "Se încarcă mai multe..."
  },
  "ru-RU": {
    loading: "Загрузка...",
    loadingMore: "Дополнительная загрузка..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    loadingMore: "Načítava sa viac..."
  },
  "sl-SI": {
    loading: "Nalaganje ...",
    loadingMore: "Nalaganje več vsebine ..."
  },
  "sr-SP": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "sv-SE": {
    loading: "Läser in...",
    loadingMore: "Läser in mer..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    loadingMore: "Daha fazla yükleniyor..."
  },
  "uk-UA": {
    loading: "Завантаження…",
    loadingMore: "Завантаження інших об’єктів..."
  },
  "zh-CN": {
    loading: "正在加载...",
    loadingMore: "正在加载更多..."
  },
  "zh-T": {
    loading: "載入中…",
    loadingMore: "正在載入更多…"
  }
};
function DragPreview(props) {
  let {
    item: item2,
    itemCount,
    itemHeight,
    density
  } = props;
  let isDraggingMultiple = itemCount > 1;
  return (0, import_jsx_runtime30.jsx)("div", {
    ...toDataAttributes({
      density,
      multi: isDraggingMultiple
    }),
    style: {
      height: itemHeight
    },
    className: classNames(css({
      display: "grid",
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderSelected}`,
      borderRadius: tokenSchema.size.radius.small,
      paddingInline: tokenSchema.size.space.medium,
      position: "relative",
      outline: 0,
      width: tokenSchema.size.alias.singleLineWidth,
      // Density
      minHeight: tokenSchema.size.element.medium,
      paddingBlock: tokenSchema.size.space.medium,
      '&[data-density="compact"]': {
        minHeight: tokenSchema.size.element.regular,
        paddingBlock: tokenSchema.size.space.regular
      },
      '&[data-density="spacious"]': {
        minHeight: tokenSchema.size.element.large,
        paddingBlock: tokenSchema.size.space.large
      },
      // indicate that multiple items are being dragged by implying a stack
      "&[data-multi=true]::after": {
        backgroundColor: "inherit",
        border: "inherit",
        borderRadius: "inherit",
        content: '" "',
        display: "block",
        height: "100%",
        insetInlineStart: 4,
        position: "absolute",
        top: 4,
        width: "100%",
        zIndex: -1
      }
    })),
    children: (0, import_jsx_runtime30.jsx)(Grid, {
      UNSAFE_className: listViewItemClassList.element("grid"),
      columns: "auto auto 1fr auto",
      rows: "1fr auto",
      areas: ["thumbnail content     . badge", "thumbnail description . badge"],
      alignItems: "center",
      children: (0, import_jsx_runtime30.jsxs)(SlotProvider, {
        slots: {
          text: {
            gridArea: "content",
            flexGrow: 1,
            truncate: true,
            weight: "medium",
            UNSAFE_className: listViewItemClassList.element("content")
          },
          description: {
            color: "neutralSecondary",
            size: "small",
            gridArea: "description",
            flexGrow: 1,
            marginTop: "small",
            truncate: true,
            UNSAFE_className: listViewItemClassList.element("description")
          },
          image: {
            borderRadius: "xsmall",
            gridArea: "thumbnail",
            marginEnd: "regular",
            overflow: "hidden",
            height: density === "compact" ? "element.small" : "element.regular",
            UNSAFE_className: listViewItemClassList.element("thumbnail")
          },
          button: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actions")
          },
          actionGroup: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actions")
          },
          actionMenu: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actionmenu")
          }
        },
        children: [isReactText(item2.rendered) ? (0, import_jsx_runtime30.jsx)(Text, {
          children: item2.rendered
        }) : item2.rendered, isDraggingMultiple && (0, import_jsx_runtime30.jsx)(Flex, {
          alignItems: "center",
          backgroundColor: "accentEmphasis",
          borderRadius: "small",
          gridArea: "badge",
          minWidth: "element.small",
          padding: "small",
          UNSAFE_className: listViewItemClassList.element("badge"),
          children: (0, import_jsx_runtime30.jsx)(Text, {
            align: "center",
            color: "inverse",
            size: "small",
            weight: "medium",
            children: itemCount
          })
        })]
      })
    })
  });
}
function InsertionIndicator(props) {
  let {
    dropState,
    dragAndDropHooks
  } = useListViewContext();
  const {
    target,
    isPresentationOnly
  } = props;
  assert(!!dragAndDropHooks.useDropIndicator, "dragAndDropHooks.useDropIndicator is not defined.");
  let ref2 = (0, import_react41.useRef)(null);
  let {
    dropIndicatorProps
  } = dragAndDropHooks.useDropIndicator(props, dropState, ref2);
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  let isDropTarget = dropState.isDropTarget(target);
  if (!isDropTarget && dropIndicatorProps["aria-hidden"]) {
    return null;
  }
  let maskColor2 = tokenSchema.color.background.canvas;
  let borderColor2 = tokenSchema.color.background.accentEmphasis;
  let borderSize2 = tokenSchema.size.border.medium;
  let circleSize2 = tokenSchema.size.space.regular;
  return (0, import_jsx_runtime30.jsx)("div", {
    role: "row",
    "aria-hidden": dropIndicatorProps["aria-hidden"],
    children: (0, import_jsx_runtime30.jsx)("div", {
      role: "gridcell",
      "aria-selected": "false",
      ...toDataAttributes({
        dropTarget: isDropTarget
      }),
      className: classNames(css({
        insetInlineStart: circleSize2,
        outline: "none",
        position: "absolute",
        width: `calc(100% - (2 * ${circleSize2}))`,
        "&[data-drop-target=true]": {
          borderBottom: `${borderSize2} solid ${borderColor2}`,
          "&::before": {
            left: `calc(${circleSize2} * -1)`
          },
          "&::after": {
            right: `calc(${circleSize2} * -1)`
          },
          "&::before, &::after": {
            backgroundColor: maskColor2,
            border: `${borderSize2} solid ${borderColor2}`,
            borderRadius: "50%",
            content: '" "',
            height: circleSize2,
            position: "absolute",
            top: `calc(${circleSize2} / -2 - ${borderSize2} / 2)`,
            width: circleSize2,
            zIndex: 5
          }
        }
      })),
      children: !isPresentationOnly && (0, import_jsx_runtime30.jsx)("div", {
        ...visuallyHiddenProps,
        role: "button",
        ...dropIndicatorProps,
        ref: ref2
      })
    })
  });
}
function ListViewItem(props) {
  var _draggableItem, _draggableItem2, _dropIndicator, _dropIndicator2;
  let {
    item: item2
  } = props;
  let {
    density,
    dragAndDropHooks,
    dragState,
    dropState,
    isListDraggable,
    isListDroppable,
    layout,
    loadingState,
    overflowMode,
    state: state2
  } = useListViewContext();
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let rowRef = (0, import_react41.useRef)(null);
  let {
    isFocusVisible: isFocusVisibleWithin,
    focusProps: focusWithinProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    within: true
  });
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let {
    rowProps,
    gridCellProps,
    isPressed,
    descriptionProps,
    isDisabled,
    allowsSelection,
    hasAction
  } = $4e8b0456ef72939f$export$9610e69494fadfd2({
    node: item2,
    isVirtualized: true,
    shouldSelectOnPressUp: isListDraggable
  }, state2, rowRef);
  let isDroppable = isListDroppable && !isDisabled;
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled: !allowsSelection && !hasAction
  });
  let {
    checkboxProps
  } = $e52ffc04a4adbd52$export$e29f2573fabbf7b9({
    key: item2.key
  }, state2);
  let draggableItem;
  if (isListDraggable) {
    assert(!!(dragAndDropHooks && dragAndDropHooks.useDraggableItem), "useDraggableItem is missing from dragAndDropHooks");
    draggableItem = dragAndDropHooks.useDraggableItem({
      key: item2.key,
      hasDragButton: true
    }, dragState);
    if (isDisabled) {
      draggableItem = null;
    }
  }
  let isDropTarget;
  let dropIndicator;
  let dropIndicatorRef = (0, import_react41.useRef)(null);
  if (isListDroppable) {
    let target = {
      type: "item",
      key: item2.key,
      dropPosition: "on"
    };
    isDropTarget = dropState.isDropTarget(target);
    assert(!!(dragAndDropHooks && dragAndDropHooks.useDropIndicator), "useDropIndicator is missing from dragAndDropHooks");
    dropIndicator = dragAndDropHooks.useDropIndicator({
      target
    }, dropState, dropIndicatorRef);
  }
  let dragButtonRef = (0, import_react41.useRef)(null);
  let {
    buttonProps
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    // @ts-expect-error
    ...(_draggableItem = draggableItem) === null || _draggableItem === void 0 ? void 0 : _draggableItem.dragButtonProps,
    elementType: "div"
  }, dragButtonRef);
  let chevron = (0, import_jsx_runtime30.jsx)(Icon, {
    ...toDataAttributes({
      disabled: !hasAction,
      visible: item2.props.hasChildItems
    }),
    color: "neutral",
    src: direction === "ltr" ? chevronRightIcon : chevronLeftIcon,
    "aria-hidden": "true",
    UNSAFE_className: classNames(listViewItemClassList.element("parent-indicator"), css({
      display: "none",
      gridArea: "chevron",
      marginInlineStart: tokenSchema.size.space.regular,
      [`${listViewItemClassList.selector("root")}[data-child-nodes=true] &`]: {
        display: "inline-block",
        visibility: "hidden"
      },
      "&[data-visible=true]": {
        visibility: "visible"
      },
      "&[data-disabled=true]": {
        stroke: tokenSchema.color.alias.foregroundDisabled
      }
    }))
  });
  let showCheckbox = state2.selectionManager.selectionMode !== "none" && state2.selectionManager.selectionBehavior === "toggle";
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  let dropProps = isDroppable ? (
    // @ts-expect-error
    void 0
  ) : (
    // @ts-expect-error
    {
      "aria-hidden": void 0
    }
  );
  const mergedProps = $3ef42575df84b30b$export$9d1611c77c2fe928(
    rowProps,
    // @ts-expect-error
    (_draggableItem2 = draggableItem) === null || _draggableItem2 === void 0 ? void 0 : _draggableItem2.dragProps,
    dropProps,
    hoverProps,
    focusWithinProps,
    focusProps,
    // Remove tab index from list row if performing a screenreader drag. This prevents TalkBack from focusing the row,
    // allowing for single swipe navigation between row drop indicator
    // @ts-expect-error
    (dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.isVirtualDragging()) && {
      tabIndex: null
    }
  );
  let isFirstRow = item2.prevKey == null;
  let isLastRow = item2.nextKey == null;
  let isFlushWithContainerBottom = false;
  if (isLastRow && loadingState !== "loadingMore") {
    var _layout$getContentSiz, _layout$virtualizer;
    if (((_layout$getContentSiz = layout.getContentSize()) === null || _layout$getContentSiz === void 0 ? void 0 : _layout$getContentSiz.height) >= ((_layout$virtualizer = layout.virtualizer) === null || _layout$virtualizer === void 0 ? void 0 : _layout$virtualizer.getVisibleRect().height)) {
      isFlushWithContainerBottom = true;
    }
  }
  let content3 = isReactText(item2.rendered) ? (0, import_jsx_runtime30.jsx)(Text, {
    children: item2.rendered
  }) : item2.rendered;
  if (isDisabled) {
    content3 = (0, import_jsx_runtime30.jsx)(KeystarProvider, {
      isDisabled: true,
      children: content3
    });
  }
  return (0, import_jsx_runtime30.jsx)("div", {
    ...mergedProps,
    ...toDataAttributes({
      "flush-last": isFlushWithContainerBottom
    }),
    className: classNames(listViewItemClassList.element("row"), css({
      cursor: "default",
      outline: 0,
      position: "relative",
      /* box shadow for bottom border */
      "&:not([data-flush-last=true])::after": {
        boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.border.neutral}`,
        content: '" "',
        display: "block",
        insetBlockEnd: 0,
        insetBlockStart: 0,
        insetInlineEnd: 0,
        insetInlineStart: 0,
        pointerEvents: "none",
        position: "absolute",
        zIndex: 3
      }
    })),
    ref: rowRef,
    children: (0, import_jsx_runtime30.jsx)("div", {
      ...toDataAttributes({
        first: isFirstRow || void 0,
        last: isLastRow || void 0,
        // @ts-expect-error
        droppable: isDropTarget || void 0,
        draggable: isListDraggable || void 0,
        focus: isFocusVisible ? "visible" : isFocusVisibleWithin ? "within" : void 0,
        interaction: isPressed ? "press" : isHovered ? "hover" : void 0
      }),
      className: classNames(listViewItemClassList.element("root"), css({
        display: "grid",
        paddingInline: tokenSchema.size.space.medium,
        position: "relative",
        outline: 0,
        // density
        minHeight: tokenSchema.size.element.medium,
        paddingBlock: tokenSchema.size.space.medium,
        [`${listViewClassList.selector("root")}[data-density="compact"] &`]: {
          minHeight: tokenSchema.size.element.regular,
          paddingBlock: tokenSchema.size.space.regular
        },
        [`${listViewClassList.selector("root")}[data-density="spacious"] &`]: {
          minHeight: tokenSchema.size.element.large,
          paddingBlock: tokenSchema.size.space.large
        },
        // variants
        "&[data-draggable=true]": {
          paddingInlineStart: tokenSchema.size.space.small
        },
        // interactions
        '&[data-interaction="hover"]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered
        },
        '&[data-interaction="press"]': {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // focus indicator
        '&[data-focus="visible"]': {
          "&::before": {
            backgroundColor: tokenSchema.color.background.accentEmphasis,
            borderRadius: tokenSchema.size.space.small,
            content: '""',
            insetBlock: 0,
            insetInlineStart: tokenSchema.size.space.xsmall,
            marginBlock: tokenSchema.size.space.xsmall,
            marginInlineEnd: `calc(${tokenSchema.size.space.small} * -1)`,
            position: "absolute",
            width: tokenSchema.size.space.small
          }
        },
        // selected
        [`${listViewItemClassList.selector("row")}[aria-selected="true"] &`]: {
          backgroundColor: tokenSchema.color.alias.backgroundSelected,
          // boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.alias.focusRing}`,
          '&[data-interaction="hover"], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
          }
        }
      })),
      ...gridCellProps,
      children: (0, import_jsx_runtime30.jsxs)(Grid, {
        UNSAFE_className: listViewItemClassList.element("grid"),
        columns: "auto auto auto 1fr minmax(0px, auto) auto auto",
        rows: "1fr auto",
        areas: ["draghandle checkbox thumbnail content actions actionmenu chevron", "draghandle checkbox thumbnail description actions actionmenu chevron"],
        alignItems: "center",
        children: [isListDraggable && (0, import_jsx_runtime30.jsx)("div", {
          className: classNames(css({
            gridArea: "draghandle",
            display: "flex",
            justifyContent: "center",
            width: tokenSchema.size.element.small
          })),
          children: !isDisabled && (0, import_jsx_runtime30.jsx)(FocusRing, {
            children: (0, import_jsx_runtime30.jsx)("div", {
              ...buttonProps,
              className: classNames(listViewItemClassList.element("draghandle"), css({
                outline: 0,
                position: "relative",
                // focus ring
                "::after": {
                  borderRadius: tokenSchema.size.radius.small,
                  content: '""',
                  inset: 0,
                  margin: 0,
                  position: "absolute",
                  transition: transition(["box-shadow", "margin"], {
                    easing: "easeOut"
                  })
                },
                "&[data-focus=visible]::after": {
                  boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
                  margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
                }
              })),
              ref: dragButtonRef,
              draggable: "true",
              children: (0, import_jsx_runtime30.jsx)(Icon, {
                src: gripVerticalIcon,
                color: "neutral"
              })
            })
          })
        }), isListDroppable && !((_dropIndicator = dropIndicator) !== null && _dropIndicator !== void 0 && _dropIndicator.isHidden) && (0, import_jsx_runtime30.jsx)("div", {
          role: "button",
          ...visuallyHiddenProps,
          ...(_dropIndicator2 = dropIndicator) === null || _dropIndicator2 === void 0 ? void 0 : _dropIndicator2.dropIndicatorProps,
          ref: dropIndicatorRef
        }), showCheckbox && (0, import_jsx_runtime30.jsx)(Flex, {
          gridArea: "checkbox",
          alignItems: "center",
          justifyContent: "center",
          children: (0, import_jsx_runtime30.jsx)(Checkbox, {
            ...checkboxProps,
            UNSAFE_className: classNames(listViewItemClassList.element("checkbox"), css({
              paddingInlineEnd: tokenSchema.size.space.regular
            }))
          })
        }), (0, import_jsx_runtime30.jsxs)(SlotProvider, {
          slots: {
            text: {
              color: isDisabled ? "color.alias.foregroundDisabled" : void 0,
              gridArea: "content",
              flexGrow: 1,
              truncate: overflowMode === "truncate",
              weight: "medium",
              UNSAFE_className: listViewItemClassList.element("content")
            },
            description: {
              color: isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary",
              size: "small",
              gridArea: "description",
              flexGrow: 1,
              marginTop: "regular",
              truncate: overflowMode === "truncate",
              UNSAFE_className: listViewItemClassList.element("description"),
              ...descriptionProps
            },
            image: {
              borderRadius: "xsmall",
              gridArea: "thumbnail",
              marginEnd: "regular",
              overflow: "hidden",
              height: density === "compact" ? "element.small" : "element.regular",
              UNSAFE_className: listViewItemClassList.element("thumbnail")
            },
            button: {
              UNSAFE_className: listViewItemClassList.element("actions"),
              prominence: "low",
              gridArea: "actions"
            },
            actionGroup: {
              UNSAFE_className: listViewItemClassList.element("actions"),
              prominence: "low",
              gridArea: "actions",
              density: "compact"
            },
            actionMenu: {
              UNSAFE_className: listViewItemClassList.element("actionmenu"),
              prominence: "low",
              gridArea: "actionmenu"
            }
          },
          children: [content3, (0, import_jsx_runtime30.jsx)(ClearSlots, {
            children: chevron
          })]
        })]
      })
    })
  });
}
function RootDropIndicator() {
  let {
    dropState,
    dragAndDropHooks
  } = useListViewContext();
  let ref2 = (0, import_react41.useRef)(null);
  assert(!!dragAndDropHooks.useDropIndicator, "dragAndDropHooks.useDropIndicator is not defined.");
  let {
    dropIndicatorProps
  } = dragAndDropHooks.useDropIndicator({
    target: {
      type: "root"
    }
  }, dropState, ref2);
  let isDropTarget = dropState.isDropTarget({
    type: "root"
  });
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  if (!isDropTarget && dropIndicatorProps["aria-hidden"]) {
    return null;
  }
  return (0, import_jsx_runtime30.jsx)("div", {
    role: "row",
    "aria-hidden": dropIndicatorProps["aria-hidden"],
    children: (0, import_jsx_runtime30.jsx)("div", {
      role: "gridcell",
      "aria-selected": "false",
      children: (0, import_jsx_runtime30.jsx)("div", {
        role: "button",
        ...visuallyHiddenProps,
        ...dropIndicatorProps,
        ref: ref2
      })
    })
  });
}
var ROW_HEIGHTS = {
  compact: {
    medium: 32,
    large: 40
  },
  regular: {
    medium: 40,
    large: 50
  },
  spacious: {
    medium: 48,
    large: 60
  }
};
function useListLayout(state2, density, overflowMode) {
  let {
    scale
  } = useProvider();
  let collator = $325a3faab7a68acd$export$a16aca283550c30d({
    usage: "search",
    sensitivity: "base"
  });
  let isEmpty = state2.collection.size === 0;
  let layout = (0, import_react41.useMemo)(
    () => new $61ef60fc9b1041f4$export$cacbb3924155d68e({
      estimatedRowHeight: ROW_HEIGHTS[density][scale],
      padding: 0,
      collator,
      loaderHeight: isEmpty ? void 0 : ROW_HEIGHTS[density][scale]
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [collator, scale, density, isEmpty, overflowMode]
  );
  layout.collection = state2.collection;
  layout.disabledKeys = state2.disabledKeys;
  return layout;
}
function ListView(props, ref2) {
  var _dropState, _droppableCollection;
  let {
    density = "regular",
    loadingState,
    onLoadMore,
    isQuiet,
    overflowMode = "truncate",
    onAction,
    dragAndDropHooks,
    ...otherProps
  } = props;
  let isListDraggable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollectionState);
  let isListDroppable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollectionState);
  let dragHooksProvided = (0, import_react41.useRef)(isListDraggable);
  let dropHooksProvided = (0, import_react41.useRef)(isListDroppable);
  (0, import_react41.useEffect)(() => {
    if (dragHooksProvided.current !== isListDraggable) {
      console.warn("Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
    }
    if (dropHooksProvided.current !== isListDroppable) {
      console.warn("Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
    }
  }, [isListDraggable, isListDroppable]);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(ref2);
  let state2 = $e72dd72e1c76a225$export$2f645645f7bca764({
    ...props,
    selectionBehavior: props.selectionStyle === "highlight" ? "replace" : "toggle"
  });
  let {
    collection: collection2,
    selectionManager
  } = state2;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages4);
  let isLoading = loadingState === "loading" || loadingState === "loadingMore";
  let styleProps = useStyleProps(props);
  let preview = (0, import_react41.useRef)(null);
  let dragState = (() => {
    if (dragAndDropHooks != null && dragAndDropHooks.useDraggableCollectionState && dragAndDropHooks.useDraggableCollection) {
      let state3 = dragAndDropHooks.useDraggableCollectionState({
        collection: collection2,
        selectionManager,
        preview
      });
      dragAndDropHooks.useDraggableCollection({}, state3, domRef);
      return state3;
    }
  })();
  let layout = useListLayout(state2, props.density || "regular", overflowMode);
  layout.allowDisabledKeyFocus = state2.selectionManager.disabledBehavior === "selection" || !!(dragState !== null && dragState !== void 0 && dragState.draggingKeys.size);
  let DragPreview$1 = dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.DragPreview;
  let dropState;
  let droppableCollection;
  let isRootDropTarget;
  if (dragAndDropHooks && dragAndDropHooks.useDroppableCollectionState && dragAndDropHooks.useDroppableCollection) {
    dropState = dragAndDropHooks.useDroppableCollectionState({
      collection: collection2,
      selectionManager
    });
    droppableCollection = dragAndDropHooks.useDroppableCollection({
      keyboardDelegate: layout,
      dropTargetDelegate: layout
    }, dropState, domRef);
    isRootDropTarget = dropState.isDropTarget({
      type: "root"
    });
  }
  let {
    gridProps
  } = $f47efb0c3a859cf2$export$664f9155035607eb({
    ...props,
    isVirtualized: true,
    keyboardDelegate: layout,
    onAction
  }, state2, domRef);
  layout.isLoading = isLoading;
  let focusedKey = selectionManager.focusedKey;
  if (((_dropState = dropState) === null || _dropState === void 0 || (_dropState = _dropState.target) === null || _dropState === void 0 ? void 0 : _dropState.type) === "item") {
    focusedKey = dropState.target.key;
  }
  let hasAnyChildren = (0, import_react41.useMemo)(() => [...collection2].some((item2) => item2.hasChildNodes), [collection2]);
  return (0, import_jsx_runtime30.jsxs)(ListViewProvider, {
    value: {
      density,
      // @ts-expect-error
      dragAndDropHooks,
      // @ts-expect-error
      dragState,
      // @ts-expect-error
      dropState,
      isListDraggable,
      isListDroppable,
      // @ts-expect-error
      layout,
      // @ts-expect-error
      loadingState,
      // @ts-expect-error
      onAction,
      overflowMode,
      state: state2
    },
    children: [(0, import_jsx_runtime30.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
      children: (0, import_jsx_runtime30.jsx)(FocusRing, {
        children: (0, import_jsx_runtime30.jsx)($6d0a5c394373ae64$export$89be5a243e59c4b2, {
          ...$3ef42575df84b30b$export$9d1611c77c2fe928(
            // @ts-expect-error
            isListDroppable ? (_droppableCollection = droppableCollection) === null || _droppableCollection === void 0 ? void 0 : _droppableCollection.collectionProps : {},
            gridProps
          ),
          ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
          ...gridProps,
          ...styleProps,
          ...toDataAttributes({
            childNodes: hasAnyChildren,
            density,
            draggable: isListDraggable,
            // @ts-expect-error
            dropTarget: isRootDropTarget,
            overflowMode
          }),
          isLoading,
          onLoadMore,
          ref: domRef,
          focusedKey,
          scrollDirection: "vertical",
          className: classNames(listViewClassList.element("root"), css({
            backgroundColor: tokenSchema.color.background.canvas,
            border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
            borderRadius: tokenSchema.size.radius.medium,
            boxSizing: "content-box",
            // resolves measurement/scroll issues related to border
            outline: 0,
            overflow: "auto",
            position: "relative",
            transform: "translate3d(0, 0, 0)",
            userSelect: "none",
            "&[data-drop-target=true]": {
              borderColor: tokenSchema.color.alias.focusRing,
              backgroundColor: tokenSchema.color.alias.backgroundSelected,
              boxShadow: `inset 0 0 0 1px ${tokenSchema.color.alias.focusRing}`
            },
            "&[data-focus=visible]": {
              borderColor: tokenSchema.color.alias.focusRing,
              boxShadow: `inset 0 0 0 1px ${tokenSchema.color.alias.focusRing}`
            }
          }), styleProps.className),
          layout,
          collection: collection2,
          transitionDuration: isLoading ? 160 : 220,
          children: (type, item2) => {
            if (type === "item") {
              return (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
                children: [isListDroppable && collection2.getKeyBefore(item2.key) == null && (0, import_jsx_runtime30.jsx)(RootDropIndicator, {}, "root"), isListDroppable && (0, import_jsx_runtime30.jsx)(InsertionIndicator, {
                  target: {
                    key: item2.key,
                    type: "item",
                    dropPosition: "before"
                  }
                }, `${item2.key}-before`), (0, import_jsx_runtime30.jsx)(ListViewItem, {
                  item: item2,
                  isEmphasized: true,
                  hasActions: !!onAction
                }), isListDroppable && (0, import_jsx_runtime30.jsx)(InsertionIndicator, {
                  target: {
                    key: item2.key,
                    type: "item",
                    dropPosition: "after"
                  },
                  isPresentationOnly: collection2.getKeyAfter(item2.key) != null
                }, `${item2.key}-after`)]
              });
            } else if (type === "loader") {
              return (0, import_jsx_runtime30.jsx)(CenteredWrapper, {
                children: (0, import_jsx_runtime30.jsx)(ProgressCircle, {
                  isIndeterminate: true,
                  size: density === "compact" ? "small" : void 0,
                  "aria-label": collection2.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
                })
              });
            } else if (type === "placeholder") {
              let emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
              if (emptyState == null) {
                return null;
              }
              return (0, import_jsx_runtime30.jsx)(CenteredWrapper, {
                children: emptyState
              });
            }
          }
        })
      })
    }), DragPreview$1 && isListDraggable && (0, import_jsx_runtime30.jsx)(DragPreview$1, {
      ref: preview,
      children: () => {
        let item2 = state2.collection.getItem(dragState.draggedKey);
        assert(item2 != null, "Dragged item must exist in collection.");
        let itemCount = dragState.draggingKeys.size;
        let itemHeight = layout.getLayoutInfo(dragState.draggedKey).rect.height;
        return (0, import_jsx_runtime30.jsx)(DragPreview, {
          item: item2,
          itemCount,
          itemHeight,
          density
        });
      }
    })]
  });
}
function CenteredWrapper({
  children
}) {
  let {
    state: state2
  } = useListViewContext();
  return (0, import_jsx_runtime30.jsx)("div", {
    role: "row",
    "aria-rowindex": state2.collection.size + 1,
    "data-has-items": state2.collection.size > 0,
    className: classNames(listViewClassList.element("centered-wrapper"), css({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "100%",
      width: "100%",
      // if there's items it must be loading—add a gutter between the items
      // and the loading indicator
      "&[data-has-items=true]": {
        paddingTop: tokenSchema.size.space.regular
      }
    })),
    children: (0, import_jsx_runtime30.jsx)("div", {
      role: "gridcell",
      children
    })
  });
}
var _ListView = import_react41.default.forwardRef(ListView);

// node_modules/@keystar/ui/dist/keystar-ui-split-view.js
var import_react42 = __toESM(require_react());
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var SplitViewContext = (0, import_react42.createContext)({
  activity: void 0,
  id: "",
  isCollapsed: void 0
});
var SplitViewProvider = SplitViewContext.Provider;
function useSplitView() {
  return (0, import_react42.useContext)(SplitViewContext);
}
var currentState = null;
var element = null;
function getCursorStyle(state2, isReversed) {
  switch (state2) {
    case "horizontal":
      return "ew-resize";
    case "horizontal-max":
      return isReversed ? "e-resize" : "w-resize";
    case "horizontal-min":
      return isReversed ? "w-resize" : "e-resize";
  }
}
function resetGlobalCursorStyle() {
  if (element !== null) {
    document.head.removeChild(element);
    currentState = null;
    element = null;
  }
}
function setGlobalCursorStyle(state2, isReversed) {
  if (currentState === state2) {
    return;
  }
  currentState = state2;
  const style = getCursorStyle(state2, isReversed);
  if (element === null) {
    element = document.createElement("style");
    document.head.appendChild(element);
  }
  element.innerHTML = `*{cursor: ${style}!important;}`;
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name2) => {
        return localStorage.getItem(name2);
      };
      storageObject.setItem = (name2, value) => {
        localStorage.setItem(name2, value);
      };
    } else {
      throw new Error("localStorage not supported in this environment");
    }
  } catch (error3) {
    console.error(error3);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
var defaultStorage = {
  getItem: (name2) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name2);
  },
  setItem: (name2, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name2, value);
  }
};
function getPosition(e3) {
  if (isMouseEvent(e3)) {
    return e3.clientX;
  } else if (isTouchEvent(e3)) {
    return e3.touches[0].clientX;
  }
  return 0;
}
function getPercentage(value, min3, max4) {
  return Math.round((value - min3) / (max4 - min3) * 100);
}
function getPrimaryPaneId(id) {
  return `primary-pane-${id}`;
}
function getSecondaryPaneId(id) {
  return `secondary-pane-${id}`;
}
function getResizeHandleId(id) {
  return `resize-handle-${id}`;
}
function getPrimaryPane(id) {
  return document.getElementById(getPrimaryPaneId(id));
}
function getSecondaryPane(id) {
  return document.getElementById(getSecondaryPaneId(id));
}
function getResizeHandle(id) {
  return document.getElementById(getResizeHandleId(id));
}
function px(value) {
  return `${value}px`;
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
var MAX_WIDTH_PROP = "--primary-pane-max-width";
var MAX_WIDTH_VAR = `var(${MAX_WIDTH_PROP})`;
var MIN_WIDTH_PROP = "--primary-pane-min-width";
var MIN_WIDTH_VAR = `var(${MIN_WIDTH_PROP})`;
var WIDTH_PROP = "--primary-pane-width";
var WIDTH_VAR = `var(${WIDTH_PROP})`;
var SNAP_REGION_PX = 32;
var KEYBOARD_ARROW_STEPS = 10;
function SplitView(props) {
  let {
    autoSaveId,
    children,
    defaultSize,
    isCollapsed,
    minSize,
    maxSize,
    onCollapseChange,
    onResize,
    storage = defaultStorage
  } = props;
  const [startPane, endPane] = children;
  const getIsMounted = useIsMounted();
  const id = useId(props.id);
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const styleProps = useStyleProps(props);
  const [isReversed, setReversed] = (0, import_react42.useState)(false);
  const [isDragging, setDragging] = (0, import_react42.useState)(false);
  const [handleIsFocused, setHandleFocus] = (0, import_react42.useState)(false);
  const [size4, setSize] = (0, import_react42.useState)(() => {
    let size5 = defaultSize;
    if (autoSaveId) {
      let savedSize = storage.getItem(autoSaveId);
      if (savedSize) {
        size5 = Number.parseInt(savedSize);
      }
    }
    return size5;
  });
  const wrapperRef = (0, import_react42.useRef)(null);
  const offsetRef = (0, import_react42.useRef)(0);
  const moveRef = (0, import_react42.useRef)(0);
  (0, import_react42.useEffect)(() => {
    const resizeHandle = getResizeHandle(id);
    const primaryPane = getPrimaryPane(id);
    const secondaryPane = getSecondaryPane(id);
    setReversed(direction === "rtl" ? (resizeHandle === null || resizeHandle === void 0 ? void 0 : resizeHandle.previousElementSibling) === primaryPane : (resizeHandle === null || resizeHandle === void 0 ? void 0 : resizeHandle.previousElementSibling) === secondaryPane);
  }, [direction, id]);
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => onResize === null || onResize === void 0 ? void 0 : onResize(size4), [size4]);
  (0, import_react42.useEffect)(() => {
    var _wrapperRef$current;
    (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 || _wrapperRef$current.style.setProperty(WIDTH_PROP, px(size4));
    moveRef.current = size4;
    if (autoSaveId) {
      storage.setItem(autoSaveId, px(size4));
    }
  }, [autoSaveId, onResize, size4, storage]);
  (0, import_react42.useEffect)(() => {
    const wrapper = wrapperRef.current;
    const resizeHandle = getResizeHandle(id);
    const primaryPane = getPrimaryPane(id);
    if (!wrapper || !resizeHandle || !primaryPane) {
      return;
    }
    let collapseRequested = false;
    let collapseAllowed = typeof isCollapsed === "boolean";
    const onMove = (e3) => {
      e3.preventDefault();
      let delta = getPosition(e3) - offsetRef.current;
      if (isReversed) delta = delta * -1;
      let nextWidth = size4 + delta;
      if (Math.abs(nextWidth - defaultSize) < SNAP_REGION_PX / 2) {
        nextWidth = defaultSize;
      }
      if (collapseAllowed) {
        collapseRequested = nextWidth <= minSize / 2;
      }
      if (collapseRequested) {
        primaryPane.style.setProperty("width", "0px");
        moveRef.current = size4;
      } else {
        moveRef.current = nextWidth;
        primaryPane.style.removeProperty("width");
      }
      wrapper.style.setProperty(WIDTH_PROP, px(moveRef.current));
      let cursorStyle = "horizontal";
      if (moveRef.current < minSize) {
        cursorStyle = "horizontal-min";
      }
      if (moveRef.current > maxSize) {
        cursorStyle = "horizontal-max";
      }
      setGlobalCursorStyle(cursorStyle, isReversed);
    };
    const stopDragging = () => {
      resizeHandle.blur();
      setDragging(false);
      resetGlobalCursorStyle();
      if (collapseRequested) {
        onCollapseChange === null || onCollapseChange === void 0 || onCollapseChange(!isCollapsed);
        primaryPane.style.removeProperty("width");
      } else {
        setSize($9446cca9a3875146$export$7d15b64cf5a3a4c4(moveRef.current, minSize, maxSize));
      }
      collapseRequested = false;
      document.body.removeEventListener("mousemove", onMove);
      document.body.removeEventListener("touchmove", onMove);
      window.removeEventListener("mouseup", stopDragging);
      window.removeEventListener("touchend", stopDragging);
    };
    const startDragging = (e3) => {
      if ("button" in e3 && e3.button !== 0) {
        return;
      }
      if ("touches" in e3 && e3.touches.length !== 1) {
        return;
      }
      setDragging(true);
      offsetRef.current = getPosition(e3);
      document.body.addEventListener("mousemove", onMove);
      document.body.addEventListener("touchmove", onMove);
      window.addEventListener("mouseup", stopDragging);
      window.addEventListener("touchend", stopDragging);
    };
    const onKeyDown = (e3) => {
      if (e3.defaultPrevented) {
        return;
      }
      let step = Math.round((maxSize - minSize) / KEYBOARD_ARROW_STEPS);
      let increment2 = () => setSize((size5) => Math.min(size5 + step, maxSize));
      let decrement = () => setSize((size5) => Math.max(size5 - step, minSize));
      switch (e3.key) {
        case "Enter":
          if (collapseAllowed) {
            e3.preventDefault();
            onCollapseChange === null || onCollapseChange === void 0 || onCollapseChange(!isCollapsed);
          }
          break;
        case "Home":
          e3.preventDefault();
          setSize(minSize);
          break;
        case "End":
          e3.preventDefault();
          setSize(maxSize);
          break;
        case "ArrowLeft":
          e3.preventDefault();
          if (isReversed) {
            increment2();
          } else {
            decrement();
          }
          break;
        case "ArrowRight":
          e3.preventDefault();
          if (isReversed) {
            decrement();
          } else {
            increment2();
          }
      }
    };
    let options = {
      passive: true
    };
    let onDoubleClick = (e3) => {
      if (e3.clientX === offsetRef.current) {
        setSize(defaultSize);
      }
    };
    resizeHandle.addEventListener("contextmenu", stopDragging);
    resizeHandle.addEventListener("dblclick", onDoubleClick);
    resizeHandle.addEventListener("keydown", onKeyDown);
    resizeHandle.addEventListener("mousedown", startDragging, options);
    resizeHandle.addEventListener("touchstart", startDragging, options);
    return () => {
      resizeHandle.removeEventListener("contextmenu", stopDragging);
      resizeHandle.removeEventListener("dblclick", onDoubleClick);
      resizeHandle.removeEventListener("keydown", onKeyDown);
      resizeHandle.removeEventListener("mousedown", startDragging);
      resizeHandle.removeEventListener("touchstart", startDragging);
    };
  }, [maxSize, minSize, defaultSize, id, isReversed, size4, onCollapseChange, isCollapsed]);
  return (0, import_jsx_runtime31.jsx)(SplitViewProvider, {
    value: {
      id,
      isCollapsed,
      activity: !getIsMounted() ? "initializing" : isDragging ? "pointer" : handleIsFocused ? "keyboard" : void 0
    },
    children: (0, import_jsx_runtime31.jsxs)("div", {
      ...styleProps,
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
      ref: wrapperRef,
      className: classNames(css({
        display: "flex",
        height: "100%",
        width: "100%",
        overflow: "hidden",
        [MIN_WIDTH_PROP]: px(minSize),
        [MAX_WIDTH_PROP]: px(maxSize),
        [WIDTH_PROP]: px(defaultSize)
      }), styleProps.className),
      children: [startPane, (0, import_jsx_runtime31.jsx)(SplitViewResizeHandle, {
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": getPercentage(size4, minSize, maxSize),
        onBlur: () => setHandleFocus(false),
        onFocus: () => setHandleFocus(true)
      }), endPane]
    })
  });
}
var SplitPanePrimary = (0, import_react42.forwardRef)(function SplitPanePrimary2(props, forwardedRef) {
  let {
    activity,
    id,
    isCollapsed
  } = useSplitView();
  let styleProps = useStyleProps(props);
  return (0, import_jsx_runtime31.jsx)("div", {
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ref: forwardedRef,
    id: getPrimaryPaneId(id),
    "data-split-pane": "primary",
    "data-split-view-activity": activity,
    "data-split-view-collapsed": isCollapsed || void 0,
    className: classNames(css({
      containerType: "inline-size",
      overflow: "hidden",
      width: `clamp(${MIN_WIDTH_VAR},${WIDTH_VAR},${MAX_WIDTH_VAR})`,
      // prevent the secondary pane from collapsing completely, regardless of
      // consumer preference. losing the drag handle is a bad experience.
      maxWidth: `calc(100% - 100px)`,
      // hide when collapsed
      "&[data-split-view-collapsed]": {
        visibility: "hidden",
        width: 0
      },
      // support transition when not dragging
      "&:not([data-split-view-activity])": {
        transition: transition("width")
      },
      // disable interactive elements during drag
      "&[data-split-view-activity=pointer]": {
        pointerEvents: "none"
      }
    }), styleProps.className),
    children: props.children
  });
});
var SplitPaneSecondary = (0, import_react42.forwardRef)(function SplitPaneSecondary2(props, forwardedRef) {
  let {
    id,
    activity
  } = useSplitView();
  let styleProps = useStyleProps(props);
  return (0, import_jsx_runtime31.jsx)("div", {
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ref: forwardedRef,
    id: getSecondaryPaneId(id),
    "data-split-pane": "secondary",
    "data-split-view-activity": activity,
    className: classNames(css({
      containerType: "inline-size",
      flex: `1 1 0`,
      // prevent the secondary pane from collapsing completely, regardless of
      // consumer preference. losing the drag handle is a bad experience.
      minWidth: `100px`,
      overflow: "hidden",
      // disable interactive elements during drag
      "&[data-split-view-activity=pointer]": {
        pointerEvents: "none"
      }
    }), styleProps.className),
    children: props.children
  });
});
var SplitViewResizeHandle = (0, import_react42.forwardRef)(function SplitViewResizeHandle2(props, forwardedRef) {
  let {
    activity,
    id,
    isCollapsed
  } = useSplitView();
  return (0, import_jsx_runtime31.jsx)("div", {
    ...props,
    ref: forwardedRef,
    "aria-controls": getPrimaryPaneId(id),
    "aria-label": "Resize",
    "aria-orientation": "vertical",
    id: getResizeHandleId(id),
    role: "separator",
    tabIndex: 0,
    "data-split-view-resize-handle": true,
    "data-split-view-activity": activity,
    "data-split-view-collapsed": isCollapsed || void 0,
    className: css({
      backgroundColor: tokenSchema.color.border.muted,
      boxSizing: "border-box",
      cursor: "ew-resize",
      flexShrink: 0,
      outline: 0,
      position: "relative",
      touchAction: "none",
      transition: transition("background-color"),
      userSelect: "none",
      width: tokenSchema.size.border.regular,
      zIndex: 1,
      // hide visually when collapsed. still allow keyboard focus
      "&[data-split-view-collapsed]:not([data-split-view-activity])": visuallyHiddenStyles,
      // increase hit area
      "&::before": {
        content: '""',
        position: "absolute",
        inset: `calc(${tokenSchema.size.space.small} * -1)`
      },
      // drag indicator
      "&::after": {
        backgroundColor: tokenSchema.color.alias.backgroundHovered,
        content: '""',
        insetBlock: 0,
        insetInline: `calc(${tokenSchema.size.border.medium} * -1)`,
        opacity: 0,
        position: "absolute",
        transition: transition("opacity")
      },
      // delay transition to avoid unexpected flicker, the user may just be
      // mousing between panes; this way we ensure intent
      "&:hover": {
        backgroundColor: tokenSchema.color.border.neutral,
        transitionDelay: tokenSchema.animation.duration.regular,
        "&::after": {
          opacity: 1,
          transitionDelay: tokenSchema.animation.duration.regular
        }
      },
      "&[data-split-view-activity=pointer]::after, &[data-split-view-activity=keyboard]::after": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        insetInline: `calc(${tokenSchema.size.border.regular} * -1)`,
        opacity: 1
      }
    })
  });
});
var visuallyHiddenStyles = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-panelLeftOpenIcon.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var panelLeftOpenIcon = (0, import_jsx_runtime32.jsxs)(import_jsx_runtime32.Fragment, {
  children: [(0, import_jsx_runtime32.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime32.jsx)("path", {
    d: "M9 3v18M14 9l3 3-3 3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-panelLeftCloseIcon.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var panelLeftCloseIcon = (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, {
  children: [(0, import_jsx_runtime33.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime33.jsx)("path", {
    d: "M9 3v18M16 15l-3-3 3-3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-panelRightOpenIcon.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var panelRightOpenIcon = (0, import_jsx_runtime34.jsxs)(import_jsx_runtime34.Fragment, {
  children: [(0, import_jsx_runtime34.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime34.jsx)("path", {
    d: "M15 3v18M10 15l-3-3 3-3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-panelRightCloseIcon.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var panelRightCloseIcon = (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, {
  children: [(0, import_jsx_runtime35.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime35.jsx)("path", {
    d: "M15 3v18M8 9l3 3-3 3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-badge.js
var import_react43 = __toESM(require_react());
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var Badge = (0, import_react43.forwardRef)(function Badge2(props, forwardedRef) {
  const {
    children,
    tone = "neutral",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  const bg = tone === "neutral" ? "surfaceSecondary" : tone;
  const fg = tone === "neutral" ? void 0 : tone;
  const slots = (0, import_react43.useMemo)(() => ({
    icon: {
      color: fg
    },
    text: {
      trim: false,
      color: fg,
      weight: "medium"
    }
  }), [fg]);
  return (0, import_jsx_runtime36.jsx)(Flex, {
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    ref: forwardedRef,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    // appearance
    backgroundColor: bg,
    borderRadius: "full",
    height: "element.small",
    minWidth: 0,
    paddingX: "regular",
    alignItems: "center",
    flexShrink: 0,
    gap: "small",
    inline: true,
    children: (0, import_jsx_runtime36.jsx)(SlotProvider, {
      slots,
      children: isReactText(children) ? (0, import_jsx_runtime36.jsx)(Text, {
        children
      }) : children
    })
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-nav-list.js
var import_react44 = __toESM(require_react());
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var listBlockGutter = tokenSchema.size.space.large;
var itemIndicatorGutter = tokenSchema.size.space.regular;
var itemIndicatorWidth = tokenSchema.size.space.small;
var itemContentGutter = tokenSchema.size.space.medium;
var textInsetStart = `calc(${itemIndicatorWidth} + ${itemIndicatorGutter} + ${itemContentGutter})`;
var NavList = (0, import_react44.forwardRef)(function NavList2(props, forwardedRef) {
  const {
    children,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const styleProps = useStyleProps(otherProps);
  const dividerStyles = useDividerStyles();
  const currentItem = useCurrentItem(domRef);
  (0, import_react44.useEffect)(() => {
    if (currentItem) {
      currentItem.scrollIntoView({
        block: "center"
      });
    }
  }, [currentItem]);
  const slots = (0, import_react44.useMemo)(() => ({
    divider: {
      "aria-hidden": true,
      elementType: "li",
      size: "medium",
      UNSAFE_className: dividerStyles
    }
  }), [dividerStyles]);
  return (0, import_jsx_runtime37.jsx)(Flex, {
    elementType: "nav",
    ref: domRef,
    direction: "column",
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    children: (0, import_jsx_runtime37.jsx)(Flex, {
      direction: "column",
      elementType: "ul",
      flex: "1 0 0",
      children: (0, import_jsx_runtime37.jsx)(SlotProvider, {
        slots,
        children
      })
    })
  });
});
function useDividerStyles() {
  return css({
    marginBlock: listBlockGutter,
    marginInlineStart: textInsetStart,
    width: `calc(40% - ${textInsetStart} - ${itemContentGutter})`,
    // FIXME: magic numbers
    minWidth: 80,
    maxWidth: 240
  });
}
function useCurrentItem(ref2) {
  let [currentItem, setCurrentItem] = (0, import_react44.useState)(null);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    let el = ref2.current && ref2.current.querySelector("[aria-current]");
    if (el) {
      setCurrentItem(el);
    }
  }, [ref2]);
  return currentItem;
}
var NavItem = (0, import_react44.forwardRef)(function NavItem2(props, forwardedRef) {
  const {
    "aria-current": ariaCurrent,
    children,
    href,
    ...otherProps
  } = props;
  const styles3 = useStyles();
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, domRef);
  const slots = (0, import_react44.useMemo)(() => ({
    text: {
      color: "inherit",
      UNSAFE_className: styles3.text
    }
  }), [styles3.text]);
  return (0, import_jsx_runtime37.jsx)("li", {
    children: (0, import_jsx_runtime37.jsx)(FocusRing, {
      children: (0, import_jsx_runtime37.jsx)("a", {
        ref: domRef,
        "aria-current": ariaCurrent,
        href,
        className: classNames(styles3.anchor),
        ...linkProps,
        ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
        children: (0, import_jsx_runtime37.jsx)("div", {
          className: classNames(styles3.content),
          children: (0, import_jsx_runtime37.jsx)(SlotProvider, {
            slots,
            children: isReactText(children) ? (0, import_jsx_runtime37.jsx)(Text, {
              children
            }) : children
          })
        })
      })
    })
  });
});
function useStyles() {
  const ringColor = tokenSchema.color.alias.focusRing;
  const ringWidth = tokenSchema.size.alias.focusRing;
  const anchor = css({
    color: tokenSchema.color.foreground.neutral,
    display: "flex",
    gap: itemIndicatorGutter,
    paddingBlock: tokenSchema.size.space.xsmall,
    outline: 0,
    // selected indicator
    "&::before": {
      borderRadius: itemIndicatorWidth,
      content: '""',
      insetInlineStart: tokenSchema.size.space.xsmall,
      marginBlock: tokenSchema.size.space.xsmall,
      position: "relative",
      width: itemIndicatorWidth
    },
    // interaction
    "&:hover": {
      color: tokenSchema.color.foreground.neutralEmphasis
    },
    // selection
    "&[aria-current]": {
      color: tokenSchema.color.foreground.neutralEmphasis,
      "&::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis
      }
    }
  });
  const content3 = css({
    alignItems: "center",
    borderRadius: tokenSchema.size.radius.regular,
    display: "flex",
    flex: 1,
    flexShrink: 0,
    gap: tokenSchema.size.space.regular,
    minHeight: tokenSchema.size.element.regular,
    minWidth: 0,
    paddingInline: tokenSchema.size.space.medium,
    paddingBlock: tokenSchema.size.space.small,
    position: "relative",
    // focus ring
    [`&::after`]: {
      borderRadius: tokenSchema.size.radius.regular,
      content: '""',
      insetBlock: 1,
      insetInline: -1,
      margin: 1,
      position: "absolute",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      })
    },
    [`.${anchor}[data-focus=visible] &::after`]: {
      boxShadow: `0 0 0 ${ringWidth} ${ringColor}`,
      margin: 0
    },
    [`.${anchor}[aria-current] &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered
    },
    [`.${anchor}:hover &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered
    },
    [`.${anchor}:active &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundPressed
    }
  });
  const text7 = css({
    fontWeight: tokenSchema.typography.fontWeight.medium,
    [`.${anchor}[aria-current] &`]: {
      fontWeight: tokenSchema.typography.fontWeight.semibold
    }
  });
  return {
    anchor,
    content: content3,
    text: text7
  };
}
function NavGroup(props) {
  const {
    children,
    id,
    title,
    ...otherProps
  } = props;
  const headingId = $bdb11010cef70236$export$f680877a34711e37(id);
  const groupStyles = useGroupStyles();
  const headingStyles = useHeadingStyles();
  return (0, import_jsx_runtime37.jsxs)("li", {
    className: classNames(groupStyles),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    children: [(0, import_jsx_runtime37.jsx)(Text, {
      elementType: "h3",
      id: headingId,
      UNSAFE_className: headingStyles,
      children: title
    }), (0, import_jsx_runtime37.jsx)(Box, {
      elementType: "ul",
      flexShrink: 0,
      "aria-labelledby": headingId,
      children
    })]
  });
}
function useGroupStyles() {
  return css({
    "&:not(:first-child)": {
      marginBlockStart: listBlockGutter
    },
    "&:not(:last-child)": {
      marginBlockEnd: listBlockGutter
    }
  });
}
function useHeadingStyles() {
  return css({
    color: tokenSchema.color.foreground.neutralSecondary,
    fontSize: tokenSchema.typography.text.small.size,
    fontWeight: tokenSchema.typography.fontWeight.medium,
    paddingBlock: tokenSchema.size.space.regular,
    paddingInlineEnd: itemContentGutter,
    paddingInlineStart: textInsetStart,
    textTransform: "uppercase"
  });
}

// node_modules/@keystar/ui/dist/keystar-ui-status-light.js
var import_react45 = __toESM(require_react());
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var StatusLight = (0, import_react45.forwardRef)(function StatusLight2(props, forwardedRef) {
  let {
    children,
    role,
    tone = "neutral"
  } = props;
  const styleProps = useStyleProps(props);
  if (!children && !props["aria-label"]) {
    console.warn("If no children are provided, an aria-label must be specified");
  }
  if (!role && (props["aria-label"] || props["aria-labelledby"])) {
    console.warn("A labelled StatusLight must have a role.");
  }
  return (0, import_jsx_runtime38.jsx)("div", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    }),
    ...styleProps,
    ref: forwardedRef,
    "data-tone": tone,
    className: classNames(css({
      alignItems: "center",
      color: tokenSchema.color.foreground.neutral,
      display: "flex",
      gap: tokenSchema.size.space.regular,
      height: tokenSchema.size.element.small,
      // indicator
      "&::before": {
        content: '""',
        backgroundColor: tokenSchema.color.foreground.neutralTertiary,
        borderRadius: tokenSchema.size.radius.full,
        height: tokenSchema.size.scale[100],
        width: tokenSchema.size.scale[100]
      },
      // special case for neutral
      "&[data-tone=neutral]": {
        color: tokenSchema.color.foreground.neutralSecondary
      },
      "&[data-tone=accent]::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis
      },
      "&[data-tone=caution]::before": {
        backgroundColor: tokenSchema.color.background.cautionEmphasis
      },
      "&[data-tone=critical]::before": {
        backgroundColor: tokenSchema.color.background.criticalEmphasis
      },
      "&[data-tone=pending]::before": {
        backgroundColor: tokenSchema.color.background.pendingEmphasis
      },
      "&[data-tone=positive]::before": {
        backgroundColor: tokenSchema.color.background.positiveEmphasis
      }
    }), styleProps.className),
    children: isReactText(children) ? (0, import_jsx_runtime38.jsx)(Text, {
      color: "inherit",
      children
    }) : children
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-logOutIcon.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var logOutIcon = (0, import_jsx_runtime39.jsx)("path", {
  d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gitPullRequestIcon.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var gitPullRequestIcon = (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, {
  children: [(0, import_jsx_runtime40.jsx)("circle", {
    cx: 18,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime40.jsx)("circle", {
    cx: 6,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime40.jsx)("path", {
    d: "M13 6h3a2 2 0 0 1 2 2v7M6 9v12"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gitBranchPlusIcon.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var gitBranchPlusIcon = (0, import_jsx_runtime41.jsxs)(import_jsx_runtime41.Fragment, {
  children: [(0, import_jsx_runtime41.jsx)("path", {
    d: "M6 3v12M18 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM6 21a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"
  }), (0, import_jsx_runtime41.jsx)("path", {
    d: "M15 6a9 9 0 0 0-9 9M18 15v6M21 18h-6"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gitForkIcon.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var gitForkIcon = (0, import_jsx_runtime42.jsxs)(import_jsx_runtime42.Fragment, {
  children: [(0, import_jsx_runtime42.jsx)("circle", {
    cx: 12,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime42.jsx)("circle", {
    cx: 6,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime42.jsx)("circle", {
    cx: 18,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime42.jsx)("path", {
    d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9M12 12v3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-monitorIcon.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var monitorIcon = (0, import_jsx_runtime43.jsxs)(import_jsx_runtime43.Fragment, {
  children: [(0, import_jsx_runtime43.jsx)("rect", {
    width: 20,
    height: 14,
    x: 2,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime43.jsx)("path", {
    d: "M8 21h8M12 17v4"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-moonIcon.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var moonIcon = (0, import_jsx_runtime44.jsx)("path", {
  d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-sunIcon.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var sunIcon = (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, {
  children: [(0, import_jsx_runtime45.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 4
  }), (0, import_jsx_runtime45.jsx)("path", {
    d: "M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-userIcon.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var userIcon = (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, {
  children: [(0, import_jsx_runtime46.jsx)("path", {
    d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"
  }), (0, import_jsx_runtime46.jsx)("circle", {
    cx: 12,
    cy: 7,
    r: 4
  })]
});

// node_modules/@react-aria/combobox/dist/ar-AE.mjs
var $02cb4c75c506befe$exports = {};
$02cb4c75c506befe$exports = {
  "buttonLabel": `عرض المقترحات`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} خيار`,
    other: () => `${formatter.number(args.optionCount)} خيارات`
  })} متاحة.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `المجموعة المدخلة ${args.groupTitle}, مع ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} خيار`,
      other: () => `${formatter.number(args.groupCount)} خيارات`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, محدد`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `مقترحات`,
  "selectedAnnouncement": (args) => `${args.optionText}، محدد`
};

// node_modules/@react-aria/combobox/dist/bg-BG.mjs
var $568b8163f1e56faf$exports = {};
$568b8163f1e56faf$exports = {
  "buttonLabel": `Покажи предложения`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} опция`,
    other: () => `${formatter.number(args.optionCount)} опции`
  })} на разположение.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Въведена група ${args.groupTitle}, с ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} опция`,
      other: () => `${formatter.number(args.groupCount)} опции`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, избрани`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Предложения`,
  "selectedAnnouncement": (args) => `${args.optionText}, избрани`
};

// node_modules/@react-aria/combobox/dist/cs-CZ.mjs
var $87581c0202d106b8$exports = {};
$87581c0202d106b8$exports = {
  "buttonLabel": `Zobrazit doporučení`,
  "countAnnouncement": (args, formatter) => `K dispozici ${formatter.plural(args.optionCount, {
    one: () => `je ${formatter.number(args.optionCount)} možnost`,
    other: () => `jsou/je ${formatter.number(args.optionCount)} možnosti/-í`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Zadaná skupina „${args.groupTitle}“ ${formatter.plural(args.groupCount, {
      one: () => `s ${formatter.number(args.groupCount)} možností`,
      other: () => `se ${formatter.number(args.groupCount)} možnostmi`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: ` (vybráno)`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Návrhy`,
  "selectedAnnouncement": (args) => `${args.optionText}, vybráno`
};

// node_modules/@react-aria/combobox/dist/da-DK.mjs
var $a10a0369f5433ed1$exports = {};
$a10a0369f5433ed1$exports = {
  "buttonLabel": `Vis forslag`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} mulighed tilgængelig`,
    other: () => `${formatter.number(args.optionCount)} muligheder tilgængelige`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Angivet gruppe ${args.groupTitle}, med ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} mulighed`,
      other: () => `${formatter.number(args.groupCount)} muligheder`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valgt`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Forslag`,
  "selectedAnnouncement": (args) => `${args.optionText}, valgt`
};

// node_modules/@react-aria/combobox/dist/de-DE.mjs
var $bfd288727d5cb166$exports = {};
$bfd288727d5cb166$exports = {
  "buttonLabel": `Empfehlungen anzeigen`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} Option`,
    other: () => `${formatter.number(args.optionCount)} Optionen`
  })} verfügbar.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Eingetretene Gruppe ${args.groupTitle}, mit ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} Option`,
      other: () => `${formatter.number(args.groupCount)} Optionen`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, ausgewählt`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Empfehlungen`,
  "selectedAnnouncement": (args) => `${args.optionText}, ausgewählt`
};

// node_modules/@react-aria/combobox/dist/el-GR.mjs
var $ca177778f9a74e3c$exports = {};
$ca177778f9a74e3c$exports = {
  "buttonLabel": `Προβολή προτάσεων`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} επιλογή`,
    other: () => `${formatter.number(args.optionCount)} επιλογές `
  })} διαθέσιμες.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Εισαγμένη ομάδα ${args.groupTitle}, με ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} επιλογή`,
      other: () => `${formatter.number(args.groupCount)} επιλογές`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, επιλεγμένο`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Προτάσεις`,
  "selectedAnnouncement": (args) => `${args.optionText}, επιλέχθηκε`
};

// node_modules/@react-aria/combobox/dist/en-US.mjs
var $9b5aa79ef84beb6c$exports = {};
$9b5aa79ef84beb6c$exports = {
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Entered group ${args.groupTitle}, with ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} option`,
      other: () => `${formatter.number(args.groupCount)} options`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selected`,
    other: ``
  }, args.isSelected)}`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} option`,
    other: () => `${formatter.number(args.optionCount)} options`
  })} available.`,
  "selectedAnnouncement": (args) => `${args.optionText}, selected`,
  "buttonLabel": `Show suggestions`,
  "listboxLabel": `Suggestions`
};

// node_modules/@react-aria/combobox/dist/es-ES.mjs
var $57968e8209de2557$exports = {};
$57968e8209de2557$exports = {
  "buttonLabel": `Mostrar sugerencias`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opción`,
    other: () => `${formatter.number(args.optionCount)} opciones`
  })} disponible(s).`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Se ha unido al grupo ${args.groupTitle}, con ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opción`,
      other: () => `${formatter.number(args.groupCount)} opciones`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, seleccionado`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugerencias`,
  "selectedAnnouncement": (args) => `${args.optionText}, seleccionado`
};

// node_modules/@react-aria/combobox/dist/et-EE.mjs
var $60690790bf4c1c6a$exports = {};
$60690790bf4c1c6a$exports = {
  "buttonLabel": `Kuva soovitused`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} valik`,
    other: () => `${formatter.number(args.optionCount)} valikud`
  })} saadaval.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Sisestatud rühm ${args.groupTitle}, valikuga ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} valik`,
      other: () => `${formatter.number(args.groupCount)} valikud`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valitud`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Soovitused`,
  "selectedAnnouncement": (args) => `${args.optionText}, valitud`
};

// node_modules/@react-aria/combobox/dist/fi-FI.mjs
var $1101246e8c7d9357$exports = {};
$1101246e8c7d9357$exports = {
  "buttonLabel": `Näytä ehdotukset`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} vaihtoehto`,
    other: () => `${formatter.number(args.optionCount)} vaihtoehdot`
  })} saatavilla.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Mentiin ryhmään ${args.groupTitle}, ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} vaihtoehdon`,
      other: () => `${formatter.number(args.groupCount)} vaihtoehdon`
    })} kanssa.`,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valittu`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Ehdotukset`,
  "selectedAnnouncement": (args) => `${args.optionText}, valittu`
};

// node_modules/@react-aria/combobox/dist/fr-FR.mjs
var $6404b5cb5b241730$exports = {};
$6404b5cb5b241730$exports = {
  "buttonLabel": `Afficher les suggestions`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} option`,
    other: () => `${formatter.number(args.optionCount)} options`
  })} disponible(s).`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Groupe ${args.groupTitle} rejoint, avec ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} option`,
      other: () => `${formatter.number(args.groupCount)} options`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, sélectionné(s)`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Suggestions`,
  "selectedAnnouncement": (args) => `${args.optionText}, sélectionné`
};

// node_modules/@react-aria/combobox/dist/he-IL.mjs
var $dfeafa702e92e31f$exports = {};
$dfeafa702e92e31f$exports = {
  "buttonLabel": `הצג הצעות`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `אפשרות ${formatter.number(args.optionCount)}`,
    other: () => `${formatter.number(args.optionCount)} אפשרויות`
  })} במצב זמין.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `נכנס לקבוצה ${args.groupTitle}, עם ${formatter.plural(args.groupCount, {
      one: () => `אפשרות ${formatter.number(args.groupCount)}`,
      other: () => `${formatter.number(args.groupCount)} אפשרויות`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, נבחר`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `הצעות`,
  "selectedAnnouncement": (args) => `${args.optionText}, נבחר`
};

// node_modules/@react-aria/combobox/dist/hr-HR.mjs
var $2d125e0b34676352$exports = {};
$2d125e0b34676352$exports = {
  "buttonLabel": `Prikaži prijedloge`,
  "countAnnouncement": (args, formatter) => `Dostupno još: ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcija`,
    other: () => `${formatter.number(args.optionCount)} opcije/a`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Unesena skupina ${args.groupTitle}, s ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opcijom`,
      other: () => `${formatter.number(args.groupCount)} opcije/a`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, odabranih`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Prijedlozi`,
  "selectedAnnouncement": (args) => `${args.optionText}, odabrano`
};

// node_modules/@react-aria/combobox/dist/hu-HU.mjs
var $ea029611d7634059$exports = {};
$ea029611d7634059$exports = {
  "buttonLabel": `Javaslatok megjelenítése`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} lehetőség`,
    other: () => `${formatter.number(args.optionCount)} lehetőség`
  })} áll rendelkezésre.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Belépett a(z) ${args.groupTitle} csoportba, amely ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} lehetőséget`,
      other: () => `${formatter.number(args.groupCount)} lehetőséget`
    })} tartalmaz. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, kijelölve`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Javaslatok`,
  "selectedAnnouncement": (args) => `${args.optionText}, kijelölve`
};

// node_modules/@react-aria/combobox/dist/it-IT.mjs
var $77f075bb86ad7091$exports = {};
$77f075bb86ad7091$exports = {
  "buttonLabel": `Mostra suggerimenti`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opzione disponibile`,
    other: () => `${formatter.number(args.optionCount)} opzioni disponibili`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Ingresso nel gruppo ${args.groupTitle}, con ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opzione`,
      other: () => `${formatter.number(args.groupCount)} opzioni`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selezionato`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Suggerimenti`,
  "selectedAnnouncement": (args) => `${args.optionText}, selezionato`
};

// node_modules/@react-aria/combobox/dist/ja-JP.mjs
var $6e87462e84907983$exports = {};
$6e87462e84907983$exports = {
  "buttonLabel": `候補を表示`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} 個のオプション`,
    other: () => `${formatter.number(args.optionCount)} 個のオプション`
  })}を利用できます。`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `入力されたグループ ${args.groupTitle}、${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} 個のオプション`,
      other: () => `${formatter.number(args.groupCount)} 個のオプション`
    })}を含む。`,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `、選択済み`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `候補`,
  "selectedAnnouncement": (args) => `${args.optionText}、選択済み`
};

// node_modules/@react-aria/combobox/dist/ko-KR.mjs
var $9246f2c6edc6b232$exports = {};
$9246f2c6edc6b232$exports = {
  "buttonLabel": `제안 사항 표시`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)}개 옵션`,
    other: () => `${formatter.number(args.optionCount)}개 옵션`
  })}을 사용할 수 있습니다.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `입력한 그룹 ${args.groupTitle}, ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)}개 옵션`,
      other: () => `${formatter.number(args.groupCount)}개 옵션`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, 선택됨`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `제안`,
  "selectedAnnouncement": (args) => `${args.optionText}, 선택됨`
};

// node_modules/@react-aria/combobox/dist/lt-LT.mjs
var $e587accc6c0a434c$exports = {};
$e587accc6c0a434c$exports = {
  "buttonLabel": `Rodyti pasiūlymus`,
  "countAnnouncement": (args, formatter) => `Yra ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} parinktis`,
    other: () => `${formatter.number(args.optionCount)} parinktys (-ių)`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Įvesta grupė ${args.groupTitle}, su ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} parinktimi`,
      other: () => `${formatter.number(args.groupCount)} parinktimis (-ių)`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, pasirinkta`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Pasiūlymai`,
  "selectedAnnouncement": (args) => `${args.optionText}, pasirinkta`
};

// node_modules/@react-aria/combobox/dist/lv-LV.mjs
var $03a1900e7400b5ab$exports = {};
$03a1900e7400b5ab$exports = {
  "buttonLabel": `Rādīt ieteikumus`,
  "countAnnouncement": (args, formatter) => `Pieejamo opciju skaits: ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcija`,
    other: () => `${formatter.number(args.optionCount)} opcijas`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Ievadīta grupa ${args.groupTitle}, ar ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opciju`,
      other: () => `${formatter.number(args.groupCount)} opcijām`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, atlasīta`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Ieteikumi`,
  "selectedAnnouncement": (args) => `${args.optionText}, atlasīta`
};

// node_modules/@react-aria/combobox/dist/nb-NO.mjs
var $1387676441be6cf6$exports = {};
$1387676441be6cf6$exports = {
  "buttonLabel": `Vis forslag`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} alternativ`,
    other: () => `${formatter.number(args.optionCount)} alternativer`
  })} finnes.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Angitt gruppe ${args.groupTitle}, med ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} alternativ`,
      other: () => `${formatter.number(args.groupCount)} alternativer`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valgt`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Forslag`,
  "selectedAnnouncement": (args) => `${args.optionText}, valgt`
};

// node_modules/@react-aria/combobox/dist/nl-NL.mjs
var $17e82ebf0f8ab91f$exports = {};
$17e82ebf0f8ab91f$exports = {
  "buttonLabel": `Suggesties weergeven`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} optie`,
    other: () => `${formatter.number(args.optionCount)} opties`
  })} beschikbaar.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Groep ${args.groupTitle} ingevoerd met ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} optie`,
      other: () => `${formatter.number(args.groupCount)} opties`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, geselecteerd`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Suggesties`,
  "selectedAnnouncement": (args) => `${args.optionText}, geselecteerd`
};

// node_modules/@react-aria/combobox/dist/pl-PL.mjs
var $2f5377d3471630e5$exports = {};
$2f5377d3471630e5$exports = {
  "buttonLabel": `Wyświetlaj sugestie`,
  "countAnnouncement": (args, formatter) => `dostępna/dostępne(-nych) ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcja`,
    other: () => `${formatter.number(args.optionCount)} opcje(-i)`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Dołączono do grupy ${args.groupTitle}, z ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opcją`,
      other: () => `${formatter.number(args.groupCount)} opcjami`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, wybrano`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugestie`,
  "selectedAnnouncement": (args) => `${args.optionText}, wybrano`
};

// node_modules/@react-aria/combobox/dist/pt-BR.mjs
var $dee9868b6fa95ffe$exports = {};
$dee9868b6fa95ffe$exports = {
  "buttonLabel": `Mostrar sugestões`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opção`,
    other: () => `${formatter.number(args.optionCount)} opções`
  })} disponível.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Grupo inserido ${args.groupTitle}, com ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opção`,
      other: () => `${formatter.number(args.groupCount)} opções`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selecionado`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugestões`,
  "selectedAnnouncement": (args) => `${args.optionText}, selecionado`
};

// node_modules/@react-aria/combobox/dist/pt-PT.mjs
var $f8b2e63637cbb5a6$exports = {};
$f8b2e63637cbb5a6$exports = {
  "buttonLabel": `Apresentar sugestões`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opção`,
    other: () => `${formatter.number(args.optionCount)} opções`
  })} disponível.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Grupo introduzido ${args.groupTitle}, com ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opção`,
      other: () => `${formatter.number(args.groupCount)} opções`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selecionado`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugestões`,
  "selectedAnnouncement": (args) => `${args.optionText}, selecionado`
};

// node_modules/@react-aria/combobox/dist/ro-RO.mjs
var $46a885db3b44ea95$exports = {};
$46a885db3b44ea95$exports = {
  "buttonLabel": `Afișare sugestii`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opțiune`,
    other: () => `${formatter.number(args.optionCount)} opțiuni`
  })} disponibile.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Grup ${args.groupTitle} introdus, cu ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opțiune`,
      other: () => `${formatter.number(args.groupCount)} opțiuni`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selectat`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugestii`,
  "selectedAnnouncement": (args) => `${args.optionText}, selectat`
};

// node_modules/@react-aria/combobox/dist/ru-RU.mjs
var $50d8a8f0afa9dee5$exports = {};
$50d8a8f0afa9dee5$exports = {
  "buttonLabel": `Показать предложения`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} параметр`,
    other: () => `${formatter.number(args.optionCount)} параметров`
  })} доступно.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Введенная группа ${args.groupTitle}, с ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} параметром`,
      other: () => `${formatter.number(args.groupCount)} параметрами`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, выбранными`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Предложения`,
  "selectedAnnouncement": (args) => `${args.optionText}, выбрано`
};

// node_modules/@react-aria/combobox/dist/sk-SK.mjs
var $2867ee6173245507$exports = {};
$2867ee6173245507$exports = {
  "buttonLabel": `Zobraziť návrhy`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} možnosť`,
    other: () => `${formatter.number(args.optionCount)} možnosti/-í`
  })} k dispozícii.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Zadaná skupina ${args.groupTitle}, s ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} možnosťou`,
      other: () => `${formatter.number(args.groupCount)} možnosťami`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, vybraté`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Návrhy`,
  "selectedAnnouncement": (args) => `${args.optionText}, vybraté`
};

// node_modules/@react-aria/combobox/dist/sl-SI.mjs
var $0631b65beeb09b50$exports = {};
$0631b65beeb09b50$exports = {
  "buttonLabel": `Prikaži predloge`,
  "countAnnouncement": (args, formatter) => `Na voljo je ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcija`,
    other: () => `${formatter.number(args.optionCount)} opcije`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Vnesena skupina ${args.groupTitle}, z ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opcija`,
      other: () => `${formatter.number(args.groupCount)} opcije`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, izbrano`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Predlogi`,
  "selectedAnnouncement": (args) => `${args.optionText}, izbrano`
};

// node_modules/@react-aria/combobox/dist/sr-SP.mjs
var $65fc749265dcd686$exports = {};
$65fc749265dcd686$exports = {
  "buttonLabel": `Prikaži predloge`,
  "countAnnouncement": (args, formatter) => `Dostupno još: ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcija`,
    other: () => `${formatter.number(args.optionCount)} opcije/a`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Unesena grupa ${args.groupTitle}, s ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opcijom`,
      other: () => `${formatter.number(args.groupCount)} optione/a`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, izabranih`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Predlozi`,
  "selectedAnnouncement": (args) => `${args.optionText}, izabrano`
};

// node_modules/@react-aria/combobox/dist/sv-SE.mjs
var $69ba655c7853c08e$exports = {};
$69ba655c7853c08e$exports = {
  "buttonLabel": `Visa förslag`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} alternativ`,
    other: () => `${formatter.number(args.optionCount)} alternativ`
  })} tillgängliga.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Ingick i gruppen ${args.groupTitle} med ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} alternativ`,
      other: () => `${formatter.number(args.groupCount)} alternativ`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valda`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Förslag`,
  "selectedAnnouncement": (args) => `${args.optionText}, valda`
};

// node_modules/@react-aria/combobox/dist/tr-TR.mjs
var $a79794784d61577c$exports = {};
$a79794784d61577c$exports = {
  "buttonLabel": `Önerileri göster`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} seçenek`,
    other: () => `${formatter.number(args.optionCount)} seçenekler`
  })} kullanılabilir.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Girilen grup ${args.groupTitle}, ile ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} seçenek`,
      other: () => `${formatter.number(args.groupCount)} seçenekler`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, seçildi`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Öneriler`,
  "selectedAnnouncement": (args) => `${args.optionText}, seçildi`
};

// node_modules/@react-aria/combobox/dist/uk-UA.mjs
var $c2845791417ebaf4$exports = {};
$c2845791417ebaf4$exports = {
  "buttonLabel": `Показати пропозиції`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} параметр`,
    other: () => `${formatter.number(args.optionCount)} параметри(-ів)`
  })} доступно.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Введена група ${args.groupTitle}, з ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} параметр`,
      other: () => `${formatter.number(args.groupCount)} параметри(-ів)`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, вибрано`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Пропозиції`,
  "selectedAnnouncement": (args) => `${args.optionText}, вибрано`
};

// node_modules/@react-aria/combobox/dist/zh-CN.mjs
var $29b642d0025cc7a4$exports = {};
$29b642d0025cc7a4$exports = {
  "buttonLabel": `显示建议`,
  "countAnnouncement": (args, formatter) => `有 ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} 个选项`,
    other: () => `${formatter.number(args.optionCount)} 个选项`
  })}可用。`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `进入了 ${args.groupTitle} 组，其中有 ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} 个选项`,
      other: () => `${formatter.number(args.groupCount)} 个选项`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, 已选择`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `建议`,
  "selectedAnnouncement": (args) => `${args.optionText}, 已选择`
};

// node_modules/@react-aria/combobox/dist/zh-TW.mjs
var $cd36dd33f9d46936$exports = {};
$cd36dd33f9d46936$exports = {
  "buttonLabel": `顯示建議`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} 選項`,
    other: () => `${formatter.number(args.optionCount)} 選項`
  })} 可用。`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `輸入的群組 ${args.groupTitle}, 有 ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} 選項`,
      other: () => `${formatter.number(args.groupCount)} 選項`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, 已選取`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `建議`,
  "selectedAnnouncement": (args) => `${args.optionText}, 已選取`
};

// node_modules/@react-aria/combobox/dist/intlStrings.mjs
var $de5926a92e8ebc5b$exports = {};
$de5926a92e8ebc5b$exports = {
  "ar-AE": $02cb4c75c506befe$exports,
  "bg-BG": $568b8163f1e56faf$exports,
  "cs-CZ": $87581c0202d106b8$exports,
  "da-DK": $a10a0369f5433ed1$exports,
  "de-DE": $bfd288727d5cb166$exports,
  "el-GR": $ca177778f9a74e3c$exports,
  "en-US": $9b5aa79ef84beb6c$exports,
  "es-ES": $57968e8209de2557$exports,
  "et-EE": $60690790bf4c1c6a$exports,
  "fi-FI": $1101246e8c7d9357$exports,
  "fr-FR": $6404b5cb5b241730$exports,
  "he-IL": $dfeafa702e92e31f$exports,
  "hr-HR": $2d125e0b34676352$exports,
  "hu-HU": $ea029611d7634059$exports,
  "it-IT": $77f075bb86ad7091$exports,
  "ja-JP": $6e87462e84907983$exports,
  "ko-KR": $9246f2c6edc6b232$exports,
  "lt-LT": $e587accc6c0a434c$exports,
  "lv-LV": $03a1900e7400b5ab$exports,
  "nb-NO": $1387676441be6cf6$exports,
  "nl-NL": $17e82ebf0f8ab91f$exports,
  "pl-PL": $2f5377d3471630e5$exports,
  "pt-BR": $dee9868b6fa95ffe$exports,
  "pt-PT": $f8b2e63637cbb5a6$exports,
  "ro-RO": $46a885db3b44ea95$exports,
  "ru-RU": $50d8a8f0afa9dee5$exports,
  "sk-SK": $2867ee6173245507$exports,
  "sl-SI": $0631b65beeb09b50$exports,
  "sr-SP": $65fc749265dcd686$exports,
  "sv-SE": $69ba655c7853c08e$exports,
  "tr-TR": $a79794784d61577c$exports,
  "uk-UA": $c2845791417ebaf4$exports,
  "zh-CN": $29b642d0025cc7a4$exports,
  "zh-TW": $cd36dd33f9d46936$exports
};

// node_modules/@react-aria/combobox/dist/useComboBox.mjs
var import_react46 = __toESM(require_react(), 1);
function $parcel$interopDefault5(a) {
  return a && a.__esModule ? a.default : a;
}
function $c350ade66beef0af$export$8c18d1b4f7232bbf(props, state2) {
  let { buttonRef, popoverRef, inputRef, listBoxRef, keyboardDelegate, shouldFocusWrap, isReadOnly, isDisabled } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault5($de5926a92e8ebc5b$exports)), "@react-aria/combobox");
  let { menuTriggerProps, menuProps } = (0, $168583247155ddda$export$dc9c12ed27dd1b49)({
    type: "listbox",
    isDisabled: isDisabled || isReadOnly
  }, state2, buttonRef);
  (0, $b1f0cad8af73213b$export$3585ede4d035bf14).set(state2, {
    id: menuProps.id
  });
  let delegate = (0, import_react46.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(state2.collection, state2.disabledKeys, listBoxRef), [
    keyboardDelegate,
    state2.collection,
    state2.disabledKeys,
    listBoxRef
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    selectionManager: state2.selectionManager,
    keyboardDelegate: delegate,
    disallowTypeAhead: true,
    disallowEmptySelection: true,
    shouldFocusWrap,
    ref: inputRef,
    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component
    isVirtualized: true
  });
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onKeyDown = (e3) => {
    switch (e3.key) {
      case "Enter":
      case "Tab":
        if (state2.isOpen && e3.key === "Enter") e3.preventDefault();
        if (state2.isOpen && state2.selectionManager.focusedKey != null && state2.selectionManager.isLink(state2.selectionManager.focusedKey)) {
          if (e3.key === "Enter") {
            let item2 = listBoxRef.current.querySelector(`[data-key="${CSS.escape(state2.selectionManager.focusedKey.toString())}"]`);
            if (item2 instanceof HTMLAnchorElement) {
              let collectionItem = state2.collection.getItem(state2.selectionManager.focusedKey);
              router.open(item2, e3, collectionItem.props.href, collectionItem.props.routerOptions);
            }
          }
          state2.close();
        } else state2.commit();
        break;
      case "Escape":
        if (state2.selectedKey !== null || state2.inputValue === "" || props.allowsCustomValue) e3.continuePropagation();
        state2.revert();
        break;
      case "ArrowDown":
        state2.open("first", "manual");
        break;
      case "ArrowUp":
        state2.open("last", "manual");
        break;
      case "ArrowLeft":
      case "ArrowRight":
        state2.selectionManager.setFocusedKey(null);
        break;
    }
  };
  let onBlur = (e3) => {
    var _popoverRef_current;
    let blurFromButton = (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) && buttonRef.current === e3.relatedTarget;
    let blurIntoPopover = (_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(e3.relatedTarget);
    if (blurFromButton || blurIntoPopover) return;
    if (props.onBlur) props.onBlur(e3);
    state2.setFocused(false);
  };
  let onFocus = (e3) => {
    if (state2.isFocused) return;
    if (props.onFocus) props.onFocus(e3);
    state2.setFocused(true);
  };
  let { isInvalid, validationErrors, validationDetails } = state2.displayValidation;
  let { labelProps, inputProps, descriptionProps, errorMessageProps } = (0, $2d73ec29415bd339$export$712718f7aec83d5)({
    ...props,
    onChange: state2.setInputValue,
    onKeyDown: !isReadOnly ? (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(state2.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown) : props.onKeyDown,
    onBlur,
    value: state2.inputValue,
    onFocus,
    autoComplete: "off",
    validate: void 0,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: state2
  }, inputRef);
  let onPress = (e3) => {
    if (e3.pointerType === "touch") {
      inputRef.current.focus();
      state2.toggle(null, "manual");
    }
  };
  let onPressStart = (e3) => {
    if (e3.pointerType !== "touch") {
      inputRef.current.focus();
      state2.toggle(e3.pointerType === "keyboard" || e3.pointerType === "virtual" ? "first" : null, "manual");
    }
  };
  let triggerLabelProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id: menuTriggerProps.id,
    "aria-label": stringFormatter.format("buttonLabel"),
    "aria-labelledby": props["aria-labelledby"] || labelProps.id
  });
  let listBoxProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id: menuProps.id,
    "aria-label": stringFormatter.format("listboxLabel"),
    "aria-labelledby": props["aria-labelledby"] || labelProps.id
  });
  let lastEventTime = (0, import_react46.useRef)(0);
  let onTouchEnd = (e3) => {
    if (isDisabled || isReadOnly) return;
    if (e3.timeStamp - lastEventTime.current < 500) {
      e3.preventDefault();
      inputRef.current.focus();
      return;
    }
    let rect = e3.target.getBoundingClientRect();
    let touch = e3.changedTouches[0];
    let centerX = Math.ceil(rect.left + 0.5 * rect.width);
    let centerY = Math.ceil(rect.top + 0.5 * rect.height);
    if (touch.clientX === centerX && touch.clientY === centerY) {
      e3.preventDefault();
      inputRef.current.focus();
      state2.toggle(null, "manual");
      lastEventTime.current = e3.timeStamp;
    }
  };
  let focusedItem = state2.selectionManager.focusedKey != null && state2.isOpen ? state2.collection.getItem(state2.selectionManager.focusedKey) : void 0;
  var _focusedItem_parentKey;
  let sectionKey = (_focusedItem_parentKey = focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.parentKey) !== null && _focusedItem_parentKey !== void 0 ? _focusedItem_parentKey : null;
  var _state_selectionManager_focusedKey;
  let itemKey = (_state_selectionManager_focusedKey = state2.selectionManager.focusedKey) !== null && _state_selectionManager_focusedKey !== void 0 ? _state_selectionManager_focusedKey : null;
  let lastSection = (0, import_react46.useRef)(sectionKey);
  let lastItem = (0, import_react46.useRef)(itemKey);
  (0, import_react46.useEffect)(() => {
    if ((0, $c87311424ea30a05$export$e1865c3bedcd822b)() && focusedItem != null && itemKey !== lastItem.current) {
      let isSelected = state2.selectionManager.isSelected(itemKey);
      let section = sectionKey != null ? state2.collection.getItem(sectionKey) : null;
      let sectionTitle = (section === null || section === void 0 ? void 0 : section["aria-label"]) || (typeof (section === null || section === void 0 ? void 0 : section.rendered) === "string" ? section.rendered : "") || "";
      let announcement = stringFormatter.format("focusAnnouncement", {
        isGroupChange: section && sectionKey !== lastSection.current,
        groupTitle: sectionTitle,
        groupCount: section ? [
          ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(section, state2.collection)
        ].length : 0,
        optionText: focusedItem["aria-label"] || focusedItem.textValue || "",
        isSelected
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSection.current = sectionKey;
    lastItem.current = itemKey;
  });
  let optionCount = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state2.collection);
  let lastSize = (0, import_react46.useRef)(optionCount);
  let lastOpen = (0, import_react46.useRef)(state2.isOpen);
  (0, import_react46.useEffect)(() => {
    let didOpenWithoutFocusedItem = state2.isOpen !== lastOpen.current && (state2.selectionManager.focusedKey == null || (0, $c87311424ea30a05$export$e1865c3bedcd822b)());
    if (state2.isOpen && (didOpenWithoutFocusedItem || optionCount !== lastSize.current)) {
      let announcement = stringFormatter.format("countAnnouncement", {
        optionCount
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSize.current = optionCount;
    lastOpen.current = state2.isOpen;
  });
  let lastSelectedKey = (0, import_react46.useRef)(state2.selectedKey);
  (0, import_react46.useEffect)(() => {
    if ((0, $c87311424ea30a05$export$e1865c3bedcd822b)() && state2.isFocused && state2.selectedItem && state2.selectedKey !== lastSelectedKey.current) {
      let optionText = state2.selectedItem["aria-label"] || state2.selectedItem.textValue || "";
      let announcement = stringFormatter.format("selectedAnnouncement", {
        optionText
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSelectedKey.current = state2.selectedKey;
  });
  (0, import_react46.useEffect)(() => {
    if (state2.isOpen) return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
      inputRef.current,
      popoverRef.current
    ]);
  }, [
    state2.isOpen,
    inputRef,
    popoverRef
  ]);
  return {
    labelProps,
    buttonProps: {
      ...menuTriggerProps,
      ...triggerLabelProps,
      excludeFromTabOrder: true,
      onPress,
      onPressStart,
      isDisabled: isDisabled || isReadOnly
    },
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(inputProps, {
      role: "combobox",
      "aria-expanded": menuTriggerProps["aria-expanded"],
      "aria-controls": state2.isOpen ? menuProps.id : void 0,
      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)
      "aria-autocomplete": "list",
      "aria-activedescendant": focusedItem ? (0, $b1f0cad8af73213b$export$9145995848b05025)(state2, focusedItem.key) : void 0,
      onTouchEnd,
      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.
      autoCorrect: "off",
      // This disable's the macOS Safari spell check auto corrections.
      spellCheck: "false"
    }),
    listBoxProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(menuProps, listBoxProps, {
      autoFocus: state2.focusStrategy,
      shouldUseVirtualFocus: true,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      linkBehavior: "selection"
    }),
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@react-stately/combobox/dist/useComboBoxState.mjs
var import_react47 = __toESM(require_react(), 1);
function $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {
  var _collection_getItem, _collection_getItem1;
  let { defaultFilter, menuTrigger = "input", allowsEmptyCollection = false, allowsCustomValue, shouldCloseOnBlur = true } = props;
  let [showAllItems, setShowAllItems] = (0, import_react47.useState)(false);
  let [isFocused, setFocusedState] = (0, import_react47.useState)(false);
  let [focusStrategy, setFocusStrategy] = (0, import_react47.useState)(null);
  let onSelectionChange = (key3) => {
    if (props.onSelectionChange) props.onSelectionChange(key3);
    if (key3 === selectedKey) {
      resetInputValue();
      closeMenu();
    }
  };
  var _props_items;
  let { collection: collection2, selectionManager, selectedKey, setSelectedKey, selectedItem, disabledKeys } = (0, $a0d645289fe9b86b$export$e7f05e985daf4b5f)({
    ...props,
    onSelectionChange,
    items: (_props_items = props.items) !== null && _props_items !== void 0 ? _props_items : props.defaultItems
  });
  var _props_defaultInputValue, _ref;
  let [inputValue, setInputValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.inputValue, (_ref = (_props_defaultInputValue = props.defaultInputValue) !== null && _props_defaultInputValue !== void 0 ? _props_defaultInputValue : (_collection_getItem = collection2.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _ref !== void 0 ? _ref : "", props.onInputChange);
  let originalCollection = collection2;
  let filteredCollection = (0, import_react47.useMemo)(() => (
    // No default filter if items are controlled.
    props.items != null || !defaultFilter ? collection2 : $a9e7382a7d111cb5$var$filterCollection(collection2, inputValue, defaultFilter)
  ), [
    collection2,
    inputValue,
    defaultFilter,
    props.items
  ]);
  let [lastCollection, setLastCollection] = (0, import_react47.useState)(filteredCollection);
  let menuOpenTrigger = (0, import_react47.useRef)("focus");
  let onOpenChange = (open2) => {
    if (props.onOpenChange) props.onOpenChange(open2, open2 ? menuOpenTrigger.current : void 0);
    selectionManager.setFocused(open2);
    if (!open2) selectionManager.setFocusedKey(null);
  };
  let triggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)({
    ...props,
    onOpenChange,
    isOpen: void 0,
    defaultOpen: void 0
  });
  let open = (focusStrategy2 = null, trigger) => {
    let displayAllItems = trigger === "manual" || trigger === "focus" && menuTrigger === "focus";
    if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {
      if (displayAllItems && !triggerState.isOpen && props.items === void 0)
        setShowAllItems(true);
      menuOpenTrigger.current = trigger;
      setFocusStrategy(focusStrategy2);
      triggerState.open();
    }
  };
  let toggle = (focusStrategy2 = null, trigger) => {
    let displayAllItems = trigger === "manual" || trigger === "focus" && menuTrigger === "focus";
    if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen) return;
    if (displayAllItems && !triggerState.isOpen && props.items === void 0)
      setShowAllItems(true);
    if (!triggerState.isOpen) menuOpenTrigger.current = trigger;
    toggleMenu(focusStrategy2);
  };
  let updateLastCollection = (0, import_react47.useCallback)(() => {
    setLastCollection(showAllItems ? originalCollection : filteredCollection);
  }, [
    showAllItems,
    originalCollection,
    filteredCollection
  ]);
  let toggleMenu = (0, import_react47.useCallback)((focusStrategy2 = null) => {
    if (triggerState.isOpen) updateLastCollection();
    setFocusStrategy(focusStrategy2);
    triggerState.toggle();
  }, [
    triggerState,
    updateLastCollection
  ]);
  let closeMenu = (0, import_react47.useCallback)(() => {
    if (triggerState.isOpen) {
      updateLastCollection();
      triggerState.close();
    }
  }, [
    triggerState,
    updateLastCollection
  ]);
  let [lastValue, setLastValue] = (0, import_react47.useState)(inputValue);
  let resetInputValue = () => {
    var _collection_getItem2;
    var _collection_getItem_textValue2;
    let itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
    setLastValue(itemText);
    setInputValue(itemText);
  };
  var _props_selectedKey, _ref1;
  let lastSelectedKey = (0, import_react47.useRef)((_ref1 = (_props_selectedKey = props.selectedKey) !== null && _props_selectedKey !== void 0 ? _props_selectedKey : props.defaultSelectedKey) !== null && _ref1 !== void 0 ? _ref1 : null);
  var _collection_getItem_textValue;
  let lastSelectedKeyText = (0, import_react47.useRef)((_collection_getItem_textValue = (_collection_getItem1 = collection2.getItem(selectedKey)) === null || _collection_getItem1 === void 0 ? void 0 : _collection_getItem1.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : "");
  (0, import_react47.useEffect)(() => {
    var _collection_getItem2;
    if (isFocused && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue && menuTrigger !== "manual") open(null, "input");
    if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0) closeMenu();
    if (selectedKey != null && selectedKey !== lastSelectedKey.current) closeMenu();
    if (inputValue !== lastValue) {
      selectionManager.setFocusedKey(null);
      setShowAllItems(false);
      if (inputValue === "" && (props.inputValue === void 0 || props.selectedKey === void 0)) setSelectedKey(null);
    }
    if (selectedKey !== lastSelectedKey.current && (props.inputValue === void 0 || props.selectedKey === void 0)) resetInputValue();
    else if (lastValue !== inputValue) setLastValue(inputValue);
    var _collection_getItem_textValue2;
    let selectedItemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
    if (!isFocused && selectedKey != null && props.inputValue === void 0 && selectedKey === lastSelectedKey.current) {
      if (lastSelectedKeyText.current !== selectedItemText) {
        setLastValue(selectedItemText);
        setInputValue(selectedItemText);
      }
    }
    lastSelectedKey.current = selectedKey;
    lastSelectedKeyText.current = selectedItemText;
  });
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: (0, import_react47.useMemo)(() => ({
      inputValue,
      selectedKey
    }), [
      inputValue,
      selectedKey
    ])
  });
  let revert = () => {
    if (allowsCustomValue && selectedKey == null) commitCustomValue();
    else commitSelection();
  };
  let commitCustomValue = () => {
    lastSelectedKey.current = null;
    setSelectedKey(null);
    closeMenu();
  };
  let commitSelection = () => {
    if (props.selectedKey !== void 0 && props.inputValue !== void 0) {
      var _collection_getItem2;
      props.onSelectionChange(selectedKey);
      var _collection_getItem_textValue2;
      let itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
      setLastValue(itemText);
      closeMenu();
    } else {
      resetInputValue();
      closeMenu();
    }
  };
  const commitValue = () => {
    if (allowsCustomValue) {
      var _collection_getItem2;
      var _collection_getItem_textValue2;
      const itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
      inputValue === itemText ? commitSelection() : commitCustomValue();
    } else
      commitSelection();
  };
  let commit = () => {
    if (triggerState.isOpen && selectionManager.focusedKey != null) {
      if (selectedKey === selectionManager.focusedKey) commitSelection();
      else setSelectedKey(selectionManager.focusedKey);
    } else commitValue();
  };
  let valueOnFocus = (0, import_react47.useRef)(inputValue);
  let setFocused = (isFocused2) => {
    if (isFocused2) {
      valueOnFocus.current = inputValue;
      if (menuTrigger === "focus") open(null, "focus");
    } else {
      if (shouldCloseOnBlur) commitValue();
      if (inputValue !== valueOnFocus.current) validation.commitValidation();
    }
    setFocusedState(isFocused2);
  };
  let displayedCollection = (0, import_react47.useMemo)(() => {
    if (triggerState.isOpen) {
      if (showAllItems) return originalCollection;
      else return filteredCollection;
    } else return lastCollection;
  }, [
    triggerState.isOpen,
    originalCollection,
    filteredCollection,
    showAllItems,
    lastCollection
  ]);
  return {
    ...validation,
    ...triggerState,
    focusStrategy,
    toggle,
    open,
    close: commitValue,
    selectionManager,
    selectedKey,
    setSelectedKey,
    disabledKeys,
    isFocused,
    setFocused,
    selectedItem,
    collection: displayedCollection,
    inputValue,
    setInputValue,
    commit,
    revert
  };
}
function $a9e7382a7d111cb5$var$filterCollection(collection2, inputValue, filter2) {
  return new (0, $a02d57049d202695$export$d085fb9e920b5ca7)($a9e7382a7d111cb5$var$filterNodes(collection2, collection2, inputValue, filter2));
}
function $a9e7382a7d111cb5$var$filterNodes(collection2, nodes, inputValue, filter2) {
  let filteredNode = [];
  for (let node3 of nodes) {
    if (node3.type === "section" && node3.hasChildNodes) {
      let filtered = $a9e7382a7d111cb5$var$filterNodes(collection2, (0, $c5a24bc478652b5f$export$1005530eda016c13)(node3, collection2), inputValue, filter2);
      if ([
        ...filtered
      ].some((node4) => node4.type === "item")) filteredNode.push({
        ...node3,
        childNodes: filtered
      });
    } else if (node3.type === "item" && filter2(node3.textValue, inputValue)) filteredNode.push({
      ...node3
    });
    else if (node3.type !== "item") filteredNode.push({
      ...node3
    });
  }
  return filteredNode;
}

// node_modules/@keystar/ui/dist/keystar-ui-combobox.js
var import_react48 = __toESM(require_react());
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var comboboxClassList = new ClassList("Combobox", ["input", "mobile-trigger"]);
var localizedMessages5 = {
  "ar-AE": {
    clear: "مسح",
    invalid: "(غير صالح)",
    loading: "جارٍ التحميل...",
    noResults: "لا توجد نتائج"
  },
  "bg-BG": {
    clear: "Изчисти",
    invalid: "(невалиден)",
    loading: "Зареждане...",
    noResults: "Няма резултати"
  },
  "cs-CZ": {
    clear: "Vymazat",
    invalid: "(neplatné)",
    loading: "Načítání...",
    noResults: "Žádné výsledky"
  },
  "da-DK": {
    clear: "Ryd",
    invalid: "(ugyldig)",
    loading: "Indlæser ...",
    noResults: "Ingen resultater"
  },
  "de-DE": {
    clear: "Löschen",
    invalid: "(ungültig)",
    loading: "Wird geladen...",
    noResults: "Keine Ergebnisse"
  },
  "el-GR": {
    clear: "Καθαρισμός",
    invalid: "(δεν ισχύει)",
    loading: "Φόρτωση...",
    noResults: "Χωρίς αποτέλεσμα"
  },
  "en-US": {
    loading: "Loading...",
    noResults: "No results",
    clear: "Clear",
    invalid: "(invalid)"
  },
  "es-ES": {
    clear: "Borrar",
    invalid: "(no válido)",
    loading: "Cargando...",
    noResults: "Sin resultados"
  },
  "et-EE": {
    clear: "Puhasta",
    invalid: "(kehtetu)",
    loading: "Laadimine...",
    noResults: "Tulemusi pole"
  },
  "fi-FI": {
    clear: "Kirkas",
    invalid: "(epäkelpo)",
    loading: "Ladataan...",
    noResults: "Ei tuloksia"
  },
  "fr-FR": {
    clear: "Effacer",
    invalid: "(non valide)",
    loading: "Chargement en cours...",
    noResults: "Aucun résultat"
  },
  "he-IL": {
    clear: "נקי",
    invalid: "(לא חוקי)",
    loading: "טוען...",
    noResults: "אין תוצאות"
  },
  "hr-HR": {
    clear: "Izbriši",
    invalid: "(nevažeće)",
    loading: "Učitavam...",
    noResults: "Nema rezultata"
  },
  "hu-HU": {
    clear: "Törlés",
    invalid: "(érvénytelen)",
    loading: "Betöltés folyamatban…",
    noResults: "Nincsenek találatok"
  },
  "it-IT": {
    clear: "Cancella",
    invalid: "(non valido)",
    loading: "Caricamento in corso...",
    noResults: "Nessun risultato"
  },
  "ja-JP": {
    clear: "クリア",
    invalid: "(無効)",
    loading: "読み込み中...",
    noResults: "結果なし"
  },
  "ko-KR": {
    clear: "지우기",
    invalid: "(유효하지 않음)",
    loading: "로드 중...",
    noResults: "결과 없음"
  },
  "lt-LT": {
    clear: "Skaidrus",
    invalid: "(netinkama)",
    loading: "Įkeliama...",
    noResults: "Be rezultatų"
  },
  "lv-LV": {
    clear: "Notīrīt",
    invalid: "(nederīgs)",
    loading: "Notiek ielāde...",
    noResults: "Nav rezultātu"
  },
  "nb-NO": {
    clear: "Tøm",
    invalid: "(ugyldig)",
    loading: "Laster inn ...",
    noResults: "Ingen resultater"
  },
  "nl-NL": {
    clear: "Helder",
    invalid: "(ongeldig)",
    loading: "Laden...",
    noResults: "Geen resultaten"
  },
  "pl-PL": {
    clear: "Wyczyść",
    invalid: "(nieprawidłowy)",
    loading: "Trwa ładowanie...",
    noResults: "Brak wyników"
  },
  "pt-BR": {
    clear: "Limpar",
    invalid: "(inválido)",
    loading: "Carregando...",
    noResults: "Nenhum resultado"
  },
  "pt-PT": {
    clear: "Limpar",
    invalid: "(inválido)",
    loading: "A carregar...",
    noResults: "Sem resultados"
  },
  "ro-RO": {
    clear: "Golire",
    invalid: "(nevalid)",
    loading: "Se încarcă...",
    noResults: "Niciun rezultat"
  },
  "ru-RU": {
    clear: "Очистить",
    invalid: "(недействительно)",
    loading: "Загрузка...",
    noResults: "Результаты отсутствуют"
  },
  "sk-SK": {
    clear: "Vymazať",
    invalid: "(neplatné)",
    loading: "Načítava sa...",
    noResults: "Žiadne výsledky"
  },
  "sl-SI": {
    clear: "Jasen",
    invalid: "(neveljavno)",
    loading: "Nalaganje...",
    noResults: "Ni rezultatov"
  },
  "sr-SP": {
    clear: "Izbriši",
    invalid: "(nevažeće)",
    loading: "Učitavam...",
    noResults: "Nema rezultata"
  },
  "sv-SE": {
    clear: "Rensa",
    invalid: "(ogiltigt)",
    loading: "Läser in...",
    noResults: "Inga resultat"
  },
  "tr-TR": {
    clear: "Temizle",
    invalid: "(geçersiz)",
    loading: "Yükleniyor...",
    noResults: "Sonuç yok"
  },
  "uk-UA": {
    clear: "Очистити",
    invalid: "(недійсне)",
    loading: "Завантаження...",
    noResults: "Результатів немає"
  },
  "zh-CN": {
    clear: "透明",
    invalid: "（无效）",
    loading: "正在加载...",
    noResults: "无结果"
  },
  "zh-TW": {
    clear: "清除",
    invalid: "(無效)",
    loading: "正在載入...",
    noResults: "無任何結果"
  }
};
function MobileCombobox(props, forwardedRef) {
  props = useProviderProps(props);
  let {
    isDisabled,
    validationState,
    isReadOnly
  } = props;
  let {
    contains: contains2
  } = $bb77f239b46e8c72$export$3274cf84b703fff({
    sensitivity: "base"
  });
  let state2 = $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e({
    ...props,
    defaultFilter: contains2,
    allowsEmptyCollection: true,
    // Needs to be false here otherwise we double up on
    // commitSelection/commitCustomValue calls when user taps on underlay (i.e.
    // initial tap will call setFocused(false) ->
    // commitSelection/commitCustomValue via onBlur, then the closing of the
    // tray will call setFocused(false) again due to cleanup effect)
    shouldCloseOnBlur: false
  });
  let buttonRef = (0, import_react48.useRef)(null);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    triggerProps,
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d({
    type: "listbox"
  }, state2, buttonRef);
  let {
    labelProps,
    fieldProps
  } = $2baaea4c71418dea$export$294aa081a6c6f55d({
    ...props,
    labelElementType: "span"
  });
  labelProps.onClick = () => {
    let button = buttonRef.current;
    if (button && !props.isDisabled) {
      button.focus();
      $507fabe10e71c6fb$export$8397ddfc504fdb9a("keyboard");
    }
  };
  return (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, {
    children: [(0, import_jsx_runtime47.jsx)(FieldPrimitive, {
      ...props,
      labelProps,
      ref: domRef,
      supplementRequiredState: true,
      children: (0, import_jsx_runtime47.jsx)(ComboboxButton, {
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(triggerProps, fieldProps, {
          autoFocus: props.autoFocus
        }),
        ref: buttonRef,
        isDisabled,
        isReadOnly,
        isPlaceholder: !state2.inputValue,
        validationState,
        onPress: () => !isReadOnly && state2.open(null, "manual"),
        children: state2.inputValue || props.placeholder || ""
      })
    }), (0, import_jsx_runtime47.jsx)(Tray, {
      state: state2,
      isFixedHeight: true,
      ...overlayProps,
      children: (0, import_jsx_runtime47.jsx)(ComboboxTray, {
        ...props,
        onClose: state2.close,
        overlayProps,
        state: state2
      })
    })]
  });
}
var ComboboxButton = import_react48.default.forwardRef(function ComboboxButton2(props, forwardedRef) {
  let {
    isDisabled,
    isPlaceholder,
    validationState,
    children,
    style
  } = props;
  let valueId = $bdb11010cef70236$export$f680877a34711e37();
  let invalidId = $bdb11010cef70236$export$f680877a34711e37();
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({});
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    ...props,
    "aria-labelledby": [props["aria-labelledby"], props["aria-label"] && !props["aria-labelledby"] ? props.id : null, valueId, validationState === "invalid" ? invalidId : null].filter(Boolean).join(" "),
    elementType: "div"
  }, domRef);
  return (0, import_jsx_runtime47.jsx)(FocusRing, {
    children: (0, import_jsx_runtime47.jsxs)(Flex, {
      position: "relative",
      width: "alias.singleLineWidth",
      zIndex: 0,
      ...toDataAttributes({
        readonly: props.isReadOnly
      }),
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, buttonProps),
      "aria-haspopup": "dialog",
      ref: domRef,
      UNSAFE_className: comboboxClassList.element("mobile-trigger"),
      UNSAFE_style: {
        ...style,
        outline: "none"
      },
      children: [(0, import_jsx_runtime47.jsx)(Flex, {
        alignItems: "center",
        paddingX: "medium",
        flex: true,
        children: (0, import_jsx_runtime47.jsx)(Text, {
          id: valueId,
          color: isPlaceholder ? "neutralSecondary" : void 0,
          trim: false,
          truncate: true,
          children
        })
      }), (0, import_jsx_runtime47.jsx)(InputStateIndicator, {
        isHovered,
        isPressed,
        isDisabled,
        validationState
      }), (0, import_jsx_runtime47.jsx)(CosmeticFieldButton, {
        isHovered,
        isPressed,
        isDisabled,
        validationState,
        UNSAFE_className: css({
          borderEndStartRadius: 0,
          borderStartStartRadius: 0,
          [`${comboboxClassList.selector("mobile-trigger")}[data-focus] &`]: {
            borderColor: tokenSchema.color.alias.borderFocused
          }
        }),
        children: (0, import_jsx_runtime47.jsx)(Icon, {
          src: chevronDownIcon
        })
      })]
    })
  });
});
var CosmeticFieldButton = (props) => {
  let {
    isHovered,
    isPressed,
    ...otherProps
  } = props;
  let {
    children,
    styleProps
  } = useFieldButton(otherProps, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime47.jsx)("div", {
    "data-disabled": props.isDisabled,
    ...styleProps,
    children
  });
};
var InputStateIndicator = (props) => {
  let {
    isDisabled,
    isHovered,
    isPressed
  } = props;
  return (0, import_jsx_runtime47.jsx)("div", {
    role: "presentation",
    ...toDataAttributes({
      disabled: isDisabled,
      interaction: isPressed ? "press" : isHovered ? "hover" : void 0,
      validation: props.validationState
    }),
    className: css({
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
      borderRadius: tokenSchema.size.radius.regular,
      inset: 0,
      position: "absolute",
      transition: transition(["border-color", "box-shadow"]),
      zIndex: -1,
      "&[data-interaction=hover]": {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      "&[data-validation=invalid]": {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [`${comboboxClassList.selector("mobile-trigger")}[data-focus] &`]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [`${comboboxClassList.selector("mobile-trigger")}[data-focus]:not([data-readonly]) &`]: {
        boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
      },
      "&[data-disabled=true]": {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        borderColor: "transparent"
      }
    })
  });
};
function ComboboxTray(props) {
  let {
    state: state2,
    isDisabled,
    validationState,
    label,
    overlayProps,
    loadingState,
    onLoadMore,
    onClose
  } = props;
  let timeoutRef = (0, import_react48.useRef)();
  let [showLoading, setShowLoading] = (0, import_react48.useState)(false);
  let inputRef = (0, import_react48.useRef)(null);
  let buttonRef = (0, import_react48.useRef)(null);
  let popoverRef = (0, import_react48.useRef)(null);
  let listBoxRef = (0, import_react48.useRef)(null);
  let layout = useListBoxLayout(state2);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages5);
  let {
    inputProps,
    listBoxProps,
    labelProps
  } = $c350ade66beef0af$export$8c18d1b4f7232bbf({
    ...props,
    keyboardDelegate: layout,
    buttonRef,
    popoverRef,
    listBoxRef,
    inputRef
  }, state2);
  import_react48.default.useEffect(() => {
    let input = inputRef.current;
    if (input) {
      $6a99195332edec8b$export$80f3e147d781571c(input);
    }
    return () => {
      state2.setFocused(false);
    };
  }, []);
  let {
    dialogProps
  } = $40df3f8667284809$export$d55e7ee900f34e93({
    "aria-labelledby": $bdb11010cef70236$export$f680877a34711e37(labelProps.id)
  }, popoverRef);
  inputProps.role = "searchbox";
  inputProps["aria-haspopup"] = "listbox";
  delete inputProps.onTouchEnd;
  let clearButton = (0, import_jsx_runtime47.jsx)(ClearButton, {
    preventFocus: true,
    "aria-label": stringFormatter.format("clear"),
    excludeFromTabOrder: true,
    onPress: () => {
      state2.setInputValue("");
      let input = inputRef.current;
      if (input) {
        input.focus();
      }
    },
    isDisabled
  });
  let loadingCircle = (0, import_jsx_runtime47.jsx)(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: (0, import_jsx_runtime47.jsx)(ProgressCircle, {
      "aria-label": stringFormatter.format("loading"),
      size: "small",
      isIndeterminate: true
    })
  });
  let isTouchDown = (0, import_react48.useRef)(false);
  let onTouchStart = () => {
    isTouchDown.current = true;
  };
  let onTouchEnd = () => {
    isTouchDown.current = false;
  };
  let onScroll = (0, import_react48.useCallback)(() => {
    let input = inputRef.current;
    let popover = popoverRef.current;
    if (!input || document.activeElement !== input || !isTouchDown.current) {
      return;
    }
    if (popover) {
      popover.focus();
    }
  }, [inputRef, popoverRef, isTouchDown]);
  let inputValue = inputProps.value;
  let lastInputValue = (0, import_react48.useRef)(inputValue);
  (0, import_react48.useEffect)(() => {
    if (loadingState === "filtering" && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (loadingState !== "filtering") {
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = void 0;
    }
    lastInputValue.current = inputValue;
  }, [loadingState, inputValue, showLoading]);
  let onKeyDown = (e3) => {
    let popover = popoverRef.current;
    if (popover && e3.key === "Enter" && state2.selectionManager.focusedKey == null) {
      popover.focus();
    } else {
      var _inputProps$onKeyDown;
      (_inputProps$onKeyDown = inputProps.onKeyDown) === null || _inputProps$onKeyDown === void 0 || _inputProps$onKeyDown.call(inputProps, e3);
    }
  };
  return (0, import_jsx_runtime47.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    restoreFocus: true,
    contain: true,
    children: (0, import_jsx_runtime47.jsxs)(Flex, {
      direction: "column",
      height: "100%",
      ref: popoverRef,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, dialogProps),
      children: [(0, import_jsx_runtime47.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: onClose
      }), (0, import_jsx_runtime47.jsx)(TextFieldPrimitive, {
        label,
        labelProps,
        inputProps: {
          ...inputProps,
          onKeyDown
        },
        ref: inputRef,
        isDisabled,
        marginX: "small",
        marginTop: "regular",
        endElement: (0, import_jsx_runtime47.jsxs)(Flex, {
          children: [showLoading && loadingState === "filtering" && loadingCircle, (state2.inputValue !== "" || loadingState === "filtering" || validationState != null) && !props.isReadOnly && clearButton]
        })
      }), (0, import_jsx_runtime47.jsx)(_ListBoxBase, {
        ...listBoxProps,
        domProps: {
          onTouchStart,
          onTouchEnd
        },
        disallowEmptySelection: true,
        shouldSelectOnPressUp: true,
        focusOnPointerEnter: true,
        layout,
        state: state2,
        shouldUseVirtualFocus: true,
        renderEmptyState: () => loadingState !== "loading" && (0, import_jsx_runtime47.jsx)(Flex, {
          height: "element.regular",
          alignItems: "center",
          paddingX: "medium",
          children: (0, import_jsx_runtime47.jsx)(Text, {
            color: "neutralSecondary",
            children: stringFormatter.format("noResults")
          })
        }),
        ref: listBoxRef,
        onScroll,
        onLoadMore,
        isLoading: loadingState === "loading" || loadingState === "loadingMore"
      }), (0, import_jsx_runtime47.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: onClose
      })]
    })
  });
}
var _MobileCombobox = import_react48.default.forwardRef(MobileCombobox);
function Combobox(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateTextFieldProps(props);
  let isMobile = useIsMobileDevice();
  if (isMobile) {
    return (0, import_jsx_runtime47.jsx)(_MobileCombobox, {
      ...props,
      menuTrigger: "input",
      ref: forwardedRef
    });
  } else {
    return (0, import_jsx_runtime47.jsx)(ComboboxBase, {
      ...props,
      ref: forwardedRef
    });
  }
}
var ComboboxBase = import_react48.default.forwardRef(function ComboboxBase2(props, forwardedRef) {
  let {
    align = "start",
    menuTrigger = "input",
    shouldFlip = true,
    direction = "bottom",
    loadingState,
    menuWidth: menuWidthProp,
    onLoadMore
  } = props;
  let isAsync = loadingState != null;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages5);
  let buttonRef = (0, import_react48.useRef)(null);
  let inputRef = (0, import_react48.useRef)(null);
  let listBoxRef = (0, import_react48.useRef)(null);
  let [popoverRefLikeValue, popoverRef] = useStatefulRef();
  let fieldRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    contains: contains2
  } = $bb77f239b46e8c72$export$3274cf84b703fff({
    sensitivity: "base"
  });
  let state2 = $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e({
    ...props,
    defaultFilter: contains2,
    allowsEmptyCollection: isAsync
  });
  let layout = useListBoxLayout(state2);
  let {
    buttonProps,
    inputProps,
    listBoxProps,
    labelProps,
    descriptionProps,
    errorMessageProps
  } = $c350ade66beef0af$export$8c18d1b4f7232bbf({
    ...props,
    keyboardDelegate: layout,
    buttonRef,
    popoverRef: popoverRefLikeValue,
    listBoxRef,
    inputRef,
    menuTrigger
  }, state2);
  let [menuWidth, setMenuWidth] = (0, import_react48.useState)();
  let {
    scale
  } = useProvider();
  let onResize = (0, import_react48.useCallback)(() => {
    if (buttonRef.current && inputRef.current) {
      let buttonWidth = buttonRef.current.offsetWidth;
      let inputWidth = inputRef.current.offsetWidth;
      setMenuWidth(inputWidth + buttonWidth);
    }
  }, [buttonRef, inputRef, setMenuWidth]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: fieldRef,
    onResize
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(onResize, [scale, onResize]);
  let style = {
    width: menuWidth,
    minWidth: menuWidthProp !== null && menuWidthProp !== void 0 ? menuWidthProp : menuWidth
  };
  return (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, {
    children: [(0, import_jsx_runtime47.jsx)(FieldPrimitive, {
      width: "alias.singleLineWidth",
      ...props,
      descriptionProps,
      errorMessageProps,
      labelProps,
      ref: fieldRef,
      children: (0, import_jsx_runtime47.jsx)(ComboboxInput, {
        ...props,
        isOpen: state2.isOpen,
        loadingState,
        inputProps,
        inputRef,
        triggerProps: buttonProps,
        triggerRef: buttonRef
      })
    }), (0, import_jsx_runtime47.jsx)(Popover, {
      state: state2,
      UNSAFE_style: style,
      ref: popoverRef,
      triggerRef: align === "end" ? buttonRef : inputRef,
      scrollRef: listBoxRef,
      placement: `${direction} ${align}`,
      hideArrow: true,
      isNonModal: true,
      shouldFlip,
      children: (0, import_jsx_runtime47.jsx)(_ListBoxBase, {
        ...listBoxProps,
        ref: listBoxRef,
        disallowEmptySelection: true,
        autoFocus: state2.focusStrategy,
        shouldSelectOnPressUp: true,
        focusOnPointerEnter: true,
        layout,
        state: state2,
        shouldUseVirtualFocus: true,
        isLoading: loadingState === "loadingMore",
        onLoadMore,
        UNSAFE_className: listStyles,
        renderEmptyState: () => isAsync && (0, import_jsx_runtime47.jsx)(Flex, {
          height: "element.regular",
          alignItems: "center",
          paddingX: "medium",
          children: (0, import_jsx_runtime47.jsx)(Text, {
            color: "neutralSecondary",
            children: loadingState === "loading" ? stringFormatter.format("loading") : stringFormatter.format("noResults")
          })
        })
      })
    })]
  });
});
function useStatefulRef() {
  let [current2, statefulRef] = (0, import_react48.useState)(null);
  return (0, import_react48.useMemo)(() => {
    return [{
      current: current2
    }, statefulRef];
  }, [current2, statefulRef]);
}
var ComboboxInput = import_react48.default.forwardRef(function ComboboxInput2(props, forwardedRef) {
  let {
    isDisabled,
    inputProps,
    inputRef,
    triggerProps,
    triggerRef,
    autoFocus,
    style,
    loadingState,
    isOpen,
    menuTrigger
  } = props;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages5);
  let timeoutRef = (0, import_react48.useRef)();
  let [showLoading, setShowLoading] = (0, import_react48.useState)(false);
  let loadingCircle = (0, import_jsx_runtime47.jsx)(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: (0, import_jsx_runtime47.jsx)(ProgressCircle, {
      "aria-label": stringFormatter.format("loading"),
      size: "small",
      isIndeterminate: true
    })
  });
  let isLoading = loadingState === "loading" || loadingState === "filtering";
  let inputValue = inputProps.value;
  let lastInputValue = (0, import_react48.useRef)(inputValue);
  (0, import_react48.useEffect)(() => {
    if (isLoading && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (!isLoading) {
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = void 0;
    }
    lastInputValue.current = inputValue;
  }, [isLoading, showLoading, inputValue]);
  return (0, import_jsx_runtime47.jsx)(FocusRing, {
    autoFocus,
    isTextInput: true,
    within: true,
    children: (0, import_jsx_runtime47.jsx)("div", {
      ref: forwardedRef,
      style,
      children: (0, import_jsx_runtime47.jsx)(TextFieldPrimitive, {
        inputProps: {
          ...inputProps,
          className: comboboxClassList.element("input")
        },
        ref: inputRef,
        isDisabled,
        endElement: (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, {
          children: [showLoading && (isOpen || menuTrigger === "manual" || loadingState === "loading") ? loadingCircle : null, (0, import_jsx_runtime47.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
            preventFocusOnPress: true,
            isPressed: isOpen,
            children: (0, import_jsx_runtime47.jsx)(FieldButton, {
              ...triggerProps,
              ref: triggerRef,
              UNSAFE_className: css({
                borderEndStartRadius: 0,
                borderStartStartRadius: 0,
                [`${comboboxClassList.selector("input")}[aria-invalid] ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderInvalid
                },
                [`${comboboxClassList.selector("input")}[readonly] ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderIdle
                },
                [`${comboboxClassList.selector("input")}:focus ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderFocused
                }
              }),
              children: (0, import_jsx_runtime47.jsx)(Icon, {
                src: chevronDownIcon
              })
            })
          })]
        })
      })
    })
  });
});
var _Combobox = import_react48.default.forwardRef(Combobox);

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-gitBranchIcon.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var gitBranchIcon = (0, import_jsx_runtime48.jsxs)(import_jsx_runtime48.Fragment, {
  children: [(0, import_jsx_runtime48.jsx)("path", {
    d: "M6 3v12"
  }), (0, import_jsx_runtime48.jsx)("circle", {
    cx: 18,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime48.jsx)("circle", {
    cx: 6,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime48.jsx)("path", {
    d: "M18 9a9 9 0 0 1-9 9"
  })]
});

// node_modules/@react-aria/radio/dist/utils.mjs
var $884aeceb3d67f00f$export$37b65e5b5444d35c = /* @__PURE__ */ new WeakMap();

// node_modules/@react-aria/radio/dist/useRadio.mjs
function $0d5c49892c1215da$export$37b0961d2f4751e2(props, state2, ref2) {
  let { value, children, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby } = props;
  const isDisabled = props.isDisabled || state2.isDisabled;
  let hasChildren = children != null;
  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;
  if (!hasChildren && !hasAriaLabel) console.warn("If you do not provide children, you must specify an aria-label for accessibility");
  let checked = state2.selectedValue === value;
  let onChange = (e3) => {
    e3.stopPropagation();
    state2.setSelectedValue(value);
  };
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled
  });
  let { pressProps: labelProps, isPressed: isLabelPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled,
    onPress() {
      state2.setSelectedValue(value);
    }
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)((0, $3ef42575df84b30b$export$9d1611c77c2fe928)(props, {
    onFocus: () => state2.setLastFocusedValue(value)
  }), ref2);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, focusableProps);
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let tabIndex = -1;
  if (state2.selectedValue != null) {
    if (state2.selectedValue === value) tabIndex = 0;
  } else if (state2.lastFocusedValue === value || state2.lastFocusedValue == null) tabIndex = 0;
  if (isDisabled) tabIndex = void 0;
  let { name: name2, descriptionId, errorMessageId, validationBehavior } = (0, $884aeceb3d67f00f$export$37b65e5b5444d35c).get(state2);
  (0, $99facab73266f662$export$5add1d006293d136)(ref2, state2.selectedValue, state2.setSelectedValue);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)({
    validationBehavior
  }, state2, ref2);
  return {
    labelProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(labelProps, {
      onClick: (e3) => e3.preventDefault()
    }),
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...interactions,
      type: "radio",
      name: name2,
      tabIndex,
      disabled: isDisabled,
      required: state2.isRequired && validationBehavior === "native",
      checked,
      value,
      onChange,
      "aria-describedby": [
        props["aria-describedby"],
        state2.isInvalid ? errorMessageId : null,
        descriptionId
      ].filter(Boolean).join(" ") || void 0
    }),
    isDisabled,
    isSelected: checked,
    isPressed: isPressed || isLabelPressed
  };
}

// node_modules/@react-aria/radio/dist/useRadioGroup.mjs
function $430f30ed08ec25fa$export$62b9571f283ff5c2(props, state2) {
  let { name: name2, isReadOnly, isRequired, isDisabled, orientation = "vertical", validationBehavior = "aria" } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { isInvalid, validationErrors, validationDetails } = state2.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    // Radio group is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span",
    isInvalid: state2.isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onBlurWithin(e3) {
      var _props_onBlur;
      (_props_onBlur = props.onBlur) === null || _props_onBlur === void 0 ? void 0 : _props_onBlur.call(props, e3);
      if (!state2.selectedValue) state2.setLastFocusedValue(null);
    },
    onFocusWithin: props.onFocus,
    onFocusWithinChange: props.onFocusChange
  });
  let onKeyDown = (e3) => {
    let nextDir;
    switch (e3.key) {
      case "ArrowRight":
        if (direction === "rtl" && orientation !== "vertical") nextDir = "prev";
        else nextDir = "next";
        break;
      case "ArrowLeft":
        if (direction === "rtl" && orientation !== "vertical") nextDir = "next";
        else nextDir = "prev";
        break;
      case "ArrowDown":
        nextDir = "next";
        break;
      case "ArrowUp":
        nextDir = "prev";
        break;
      default:
        return;
    }
    e3.preventDefault();
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(e3.currentTarget, {
      from: e3.target
    });
    let nextElem;
    if (nextDir === "next") {
      nextElem = walker.nextNode();
      if (!nextElem) {
        walker.currentNode = e3.currentTarget;
        nextElem = walker.firstChild();
      }
    } else {
      nextElem = walker.previousNode();
      if (!nextElem) {
        walker.currentNode = e3.currentTarget;
        nextElem = walker.lastChild();
      }
    }
    if (nextElem) {
      nextElem.focus();
      state2.setSelectedValue(nextElem.value);
    }
  };
  let groupName = (0, $bdb11010cef70236$export$f680877a34711e37)(name2);
  (0, $884aeceb3d67f00f$export$37b65e5b5444d35c).set(state2, {
    name: groupName,
    descriptionId: descriptionProps.id,
    errorMessageId: errorMessageProps.id,
    validationBehavior
  });
  return {
    radioGroupProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      // https://www.w3.org/TR/wai-aria-1.2/#radiogroup
      role: "radiogroup",
      onKeyDown,
      "aria-invalid": state2.isInvalid || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-readonly": isReadOnly || void 0,
      "aria-required": isRequired || void 0,
      "aria-disabled": isDisabled || void 0,
      "aria-orientation": orientation,
      ...fieldProps,
      ...focusWithinProps
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-radio.js
var import_react50 = __toESM(require_react());
var import_jsx_runtime49 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/radio/dist/useRadioGroupState.mjs
var import_react49 = __toESM(require_react(), 1);
var $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 1e10);
var $a54cdc5c1942b639$var$i = 0;
function $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {
  let name2 = (0, import_react49.useMemo)(() => props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [
    props.name
  ]);
  var _props_defaultValue;
  let [selectedValue, setSelected] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);
  let [lastFocusedValue, setLastFocusedValue] = (0, import_react49.useState)(null);
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: selectedValue
  });
  let setSelectedValue = (value) => {
    if (!props.isReadOnly && !props.isDisabled) {
      setSelected(value);
      validation.commitValidation();
    }
  };
  let isInvalid = validation.displayValidation.isInvalid;
  return {
    ...validation,
    name: name2,
    selectedValue,
    setSelectedValue,
    lastFocusedValue,
    setLastFocusedValue,
    isDisabled: props.isDisabled || false,
    isReadOnly: props.isReadOnly || false,
    isRequired: props.isRequired || false,
    validationState: props.validationState || (isInvalid ? "invalid" : null),
    isInvalid
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-radio.js
var RadioContext = import_react50.default.createContext(null);
function useRadioProvider() {
  const context = import_react50.default.useContext(RadioContext);
  if (!context) {
    throw new Error("useRadioProvider must be used within a RadioGroupProvider");
  }
  return context;
}
var radioClassList = new ClassList("Radio", ["indicator"]);
function Radio(props) {
  let {
    children,
    autoFocus,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let inputRef = (0, import_react50.useRef)(null);
  let radioGroupProps = useRadioProvider();
  let {
    state: state2
  } = radioGroupProps;
  let {
    inputProps
  } = $0d5c49892c1215da$export$37b0961d2f4751e2({
    ...props,
    ...radioGroupProps
  }, state2, inputRef);
  const inputClassName = css({
    position: "absolute",
    zIndex: 1,
    inset: 0,
    opacity: 1e-4
  });
  const labelClassName = css({
    alignItems: "flex-start",
    display: "inline-flex",
    gap: tokenSchema.size.space.regular,
    position: "relative",
    userSelect: "none"
  });
  const slots = (0, import_react50.useMemo)(() => ({
    text: {
      color: "inherit"
    },
    description: {
      color: "neutralTertiary"
    }
  }), []);
  return (0, import_jsx_runtime49.jsxs)("label", {
    className: classNames(styleProps.className, labelClassName),
    style: styleProps.style,
    children: [(0, import_jsx_runtime49.jsx)(FocusRing, {
      autoFocus,
      children: (0, import_jsx_runtime49.jsx)("input", {
        ...inputProps,
        ref: inputRef,
        className: classNames(inputClassName)
      })
    }), (0, import_jsx_runtime49.jsx)(Indicator2, {
      inputClassName
    }), (0, import_jsx_runtime49.jsx)(SlotProvider, {
      slots,
      children: children && (0, import_jsx_runtime49.jsx)(Content3, {
        children: isReactText(children) ? (0, import_jsx_runtime49.jsx)(Text, {
          children
        }) : children
      })
    })]
  });
}
var sizeToken2 = tokenSchema.size.element.xsmall;
var Indicator2 = (props) => {
  let {
    inputClassName
  } = props;
  return (0, import_jsx_runtime49.jsx)("span", {
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      borderRadius: tokenSchema.size.radius.full,
      color: tokenSchema.color.foreground.onEmphasis,
      display: "flex",
      flexShrink: 0,
      justifyContent: "center",
      alignItems: "center",
      position: "relative",
      height: sizeToken2,
      width: sizeToken2,
      // indicator icons
      [radioClassList.selector("indicator")]: {
        opacity: 0,
        transform: `scale(0) translate3d(0, 0, 0)`,
        transition: transition(["opacity", "transform"]),
        willChange: "opacity, transform"
      },
      // focus ring
      "::after": {
        borderRadius: tokenSchema.size.radius.full,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      [`.${inputClassName}[data-focus=visible] + &::after`]: {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // border / background
      "&::before": {
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.alias.borderIdle}`,
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["border-color", "border-width"], {
          duration: "regular"
        })
      },
      [`.${inputClassName}:disabled + &`]: {
        color: tokenSchema.color.alias.foregroundDisabled,
        "&::before": {
          borderColor: tokenSchema.color.alias.borderDisabled
        }
      },
      [`.${inputClassName}:enabled:hover + &::before`]: {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      [`.${inputClassName}:enabled:active + &::before`]: {
        borderColor: tokenSchema.color.alias.borderPressed
      },
      // checked states
      [`.${inputClassName}:checked + &`]: {
        "&::before": {
          borderWidth: `calc(${sizeToken2} / 2)`
        },
        [radioClassList.selector("indicator")]: {
          opacity: 1,
          transform: `scale(1)`
        }
      },
      [`.${inputClassName}:enabled:checked + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo9
      },
      [`.${inputClassName}:enabled:checked:hover + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo10
      },
      [`.${inputClassName}:enabled:checked:active + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo11
      }
    })),
    children: (0, import_jsx_runtime49.jsx)("span", {
      className: radioClassList.element("indicator"),
      children: (0, import_jsx_runtime49.jsx)("svg", {
        className: resetClassName,
        fill: "currentColor",
        height: 12,
        viewBox: "0 0 24 24",
        width: 12,
        children: (0, import_jsx_runtime49.jsx)("circle", {
          cx: "12",
          cy: "12",
          r: "6"
        })
      })
    })
  });
};
var Content3 = (props) => {
  return (0, import_jsx_runtime49.jsx)("div", {
    className: classNames(css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: "grid",
      paddingTop: `calc((${sizeToken2} - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      gap: tokenSchema.size.space.large,
      'input[type="radio"]:hover ~ &': {
        color: tokenSchema.color.alias.foregroundHovered
      },
      'input[type="radio"]:disabled ~ &': {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    })),
    ...props
  });
};
var RadioGroup = (0, import_react50.forwardRef)(function RadioGroup2(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateFieldProps(props);
  let {
    validationState,
    children,
    orientation = "vertical"
  } = props;
  let state2 = $a54cdc5c1942b639$export$bca9d026f8e704eb(props);
  let {
    radioGroupProps,
    labelProps,
    descriptionProps,
    errorMessageProps
  } = $430f30ed08ec25fa$export$62b9571f283ff5c2(props, state2);
  return (0, import_jsx_runtime49.jsx)(FieldPrimitive, {
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    children: (0, import_jsx_runtime49.jsx)("div", {
      ...radioGroupProps,
      ...toDataAttributes({
        orientation
      }),
      className: classNames(css({
        display: "flex",
        gap: tokenSchema.size.space.large,
        '&[data-orientation="vertical"]': {
          flexDirection: "column"
        }
      })),
      children: (0, import_jsx_runtime49.jsx)(RadioContext.Provider, {
        value: {
          validationState,
          state: state2
        },
        children
      })
    })
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-editIcon.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var editIcon = (0, import_jsx_runtime50.jsxs)(import_jsx_runtime50.Fragment, {
  children: [(0, import_jsx_runtime50.jsx)("path", {
    d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
  }), (0, import_jsx_runtime50.jsx)("path", {
    d: "M18.375 2.625a2.121 2.121 0 1 1 3 3L12 15l-4 1 1-4Z"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-externalLinkIcon.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var externalLinkIcon = (0, import_jsx_runtime51.jsx)("path", {
  d: "M15 3h6v6M10 14 21 3M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-linkIcon.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var linkIcon = (0, import_jsx_runtime52.jsxs)(import_jsx_runtime52.Fragment, {
  children: [(0, import_jsx_runtime52.jsx)("path", {
    d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"
  }), (0, import_jsx_runtime52.jsx)("path", {
    d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-unlinkIcon.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());
var unlinkIcon = (0, import_jsx_runtime53.jsx)("path", {
  d: "m18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71M8 2v3M2 8h3M16 19v3M19 16h3"
});

// node_modules/@react-aria/actiongroup/dist/useActionGroup.mjs
var import_react51 = __toESM(require_react(), 1);
var $304ac34015d4535d$var$BUTTON_GROUP_ROLES = {
  "none": "toolbar",
  "single": "radiogroup",
  "multiple": "toolbar"
};
function $304ac34015d4535d$export$f4bf8d43c16de704(props, state2, ref2) {
  let { isDisabled, orientation = "horizontal" } = props;
  let [isInToolbar, setInToolbar] = (0, import_react51.useState)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    var _ref_current_parentElement;
    setInToolbar(!!(ref2.current && ((_ref_current_parentElement = ref2.current.parentElement) === null || _ref_current_parentElement === void 0 ? void 0 : _ref_current_parentElement.closest('[role="toolbar"]'))));
  }, [
    ref2
  ]);
  let allKeys = [
    ...state2.collection.getKeys()
  ];
  if (!allKeys.some((key3) => !state2.disabledKeys.has(key3))) isDisabled = true;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let focusManager = (0, $9bf71ea28793e738$export$c5251b9e124bf29)(ref2);
  let flipDirection = direction === "rtl" && orientation === "horizontal";
  let onKeyDown = (e3) => {
    if (!e3.currentTarget.contains(e3.target)) return;
    switch (e3.key) {
      case "ArrowRight":
      case "ArrowDown":
        e3.preventDefault();
        e3.stopPropagation();
        if (e3.key === "ArrowRight" && flipDirection) focusManager.focusPrevious({
          wrap: true
        });
        else focusManager.focusNext({
          wrap: true
        });
        break;
      case "ArrowLeft":
      case "ArrowUp":
        e3.preventDefault();
        e3.stopPropagation();
        if (e3.key === "ArrowLeft" && flipDirection) focusManager.focusNext({
          wrap: true
        });
        else focusManager.focusPrevious({
          wrap: true
        });
        break;
    }
  };
  let role = $304ac34015d4535d$var$BUTTON_GROUP_ROLES[state2.selectionManager.selectionMode];
  if (isInToolbar && role === "toolbar") role = "group";
  return {
    actionGroupProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
        labelable: true
      }),
      role,
      "aria-orientation": role === "toolbar" ? orientation : void 0,
      "aria-disabled": isDisabled,
      onKeyDown
    }
  };
}

// node_modules/@react-aria/actiongroup/dist/useActionGroupItem.mjs
var import_react52 = __toESM(require_react(), 1);
var $f0ac0fb73c3ec062$var$BUTTON_ROLES = {
  "none": void 0,
  "single": "radio",
  "multiple": "checkbox"
};
function $f0ac0fb73c3ec062$export$9597202bd3099a29(props, state2, ref2) {
  let selectionMode = state2.selectionManager.selectionMode;
  let buttonProps = {
    role: $f0ac0fb73c3ec062$var$BUTTON_ROLES[selectionMode]
  };
  if (selectionMode !== "none") {
    let isSelected = state2.selectionManager.isSelected(props.key);
    buttonProps["aria-checked"] = isSelected;
  }
  let isFocused = props.key === state2.selectionManager.focusedKey;
  let onRemovedWithFocus = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    if (isFocused) state2.selectionManager.setFocusedKey(null);
  });
  (0, import_react52.useEffect)(() => {
    return () => {
      onRemovedWithFocus();
    };
  }, [
    onRemovedWithFocus
  ]);
  return {
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(buttonProps, {
      tabIndex: isFocused || state2.selectionManager.focusedKey == null ? 0 : -1,
      onFocus() {
        state2.selectionManager.setFocusedKey(props.key);
      },
      onPress() {
        state2.selectionManager.select(props.key);
      }
    })
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-action-group.js
var import_react53 = __toESM(require_react());
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
function ActionGroup(props, forwardedRef) {
  props = useProviderProps(props);
  props = useSlotProps(props, "actionGroup");
  let {
    density,
    prominence,
    isJustified,
    isDisabled,
    orientation = "horizontal",
    overflowMode = "wrap",
    onAction,
    buttonLabelBehavior,
    summaryIcon,
    ...otherProps
  } = props;
  prominence = prominence === "low" ? "low" : "default";
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let wrapperRef = (0, import_react53.useRef)(null);
  let state2 = $e72dd72e1c76a225$export$2f645645f7bca764({
    ...props,
    suppressTextValueWarning: true
  });
  let {
    actionGroupProps
  } = $304ac34015d4535d$export$f4bf8d43c16de704(props, state2, domRef);
  let providerProps = {
    isDisabled
  };
  let styleProps = useStyleProps(props);
  let isIconCollapsible = (0, import_react53.useMemo)(() => [...state2.collection].every((item2) => typeof item2.rendered !== "string"), [state2.collection]);
  let [{
    visibleItems,
    hideButtonText,
    isMeasuring
  }, setVisibleItems] = $1dbecbe27a04f9af$export$14d238f342723f25({
    visibleItems: state2.collection.size,
    hideButtonText: buttonLabelBehavior === "hide" && isIconCollapsible,
    isMeasuring: false
  });
  let selectionMode = state2.selectionManager.selectionMode;
  let updateOverflow = (0, import_react53.useCallback)(() => {
    if (overflowMode === "wrap") {
      return;
    }
    if (orientation === "vertical" && selectionMode !== "none") {
      return;
    }
    let computeVisibleItems = (visibleItems2) => {
      if (domRef.current && wrapperRef.current) {
        let listItems = Array.from(domRef.current.children);
        let containerSize = orientation === "horizontal" ? wrapperRef.current.getBoundingClientRect().width : wrapperRef.current.getBoundingClientRect().height;
        let isShowingMenu = visibleItems2 < state2.collection.size;
        let calculatedSize = 0;
        let newVisibleItems = 0;
        if (isShowingMenu) {
          let item2 = listItems.pop();
          if (item2) {
            calculatedSize += orientation === "horizontal" ? outerWidth(item2, false, true) : outerHeight(item2, false, true);
          }
        }
        for (let [i2, item2] of listItems.entries()) {
          calculatedSize += orientation === "horizontal" ? outerWidth(item2, i2 === 0, i2 === listItems.length - 1) : outerHeight(item2, i2 === 0, i2 === listItems.length - 1);
          if (Math.round(calculatedSize) <= Math.round(containerSize)) {
            newVisibleItems++;
          } else {
            break;
          }
        }
        if (selectionMode !== "none" && newVisibleItems < state2.collection.size) {
          return 0;
        }
        return newVisibleItems;
      }
      return visibleItems2;
    };
    setVisibleItems(function* () {
      let hideButtonText2 = buttonLabelBehavior === "hide" && isIconCollapsible;
      yield {
        visibleItems: state2.collection.size,
        hideButtonText: hideButtonText2,
        isMeasuring: true
      };
      let newVisibleItems = computeVisibleItems(state2.collection.size);
      let isMeasuring2 = newVisibleItems < state2.collection.size && newVisibleItems > 0;
      if (newVisibleItems < state2.collection.size && buttonLabelBehavior === "collapse" && isIconCollapsible) {
        yield {
          visibleItems: state2.collection.size,
          hideButtonText: true,
          isMeasuring: true
        };
        newVisibleItems = computeVisibleItems(state2.collection.size);
        isMeasuring2 = newVisibleItems < state2.collection.size && newVisibleItems > 0;
        hideButtonText2 = true;
      }
      yield {
        visibleItems: newVisibleItems,
        hideButtonText: hideButtonText2,
        isMeasuring: isMeasuring2
      };
      if (isMeasuring2) {
        yield {
          visibleItems: computeVisibleItems(newVisibleItems),
          hideButtonText: hideButtonText2,
          isMeasuring: false
        };
      }
    });
  }, [domRef, state2.collection, setVisibleItems, overflowMode, selectionMode, buttonLabelBehavior, isIconCollapsible, orientation]);
  let parentRef = (0, import_react53.useMemo)(() => ({
    get current() {
      var _wrapperRef$current;
      return (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.parentElement;
    }
  }), [wrapperRef]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: overflowMode !== "wrap" ? parentRef : void 0,
    onResize: updateOverflow
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(updateOverflow, [updateOverflow, state2.collection]);
  let children = [...state2.collection];
  let menuItem = null;
  let menuProps = {};
  if (overflowMode === "collapse" && visibleItems === 0) {
    menuProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    });
    actionGroupProps = {};
  }
  if (overflowMode === "collapse" && visibleItems < state2.collection.size) {
    let menuChildren = children.slice(visibleItems);
    children = children.slice(0, visibleItems);
    menuItem = (0, import_jsx_runtime54.jsx)(ActionGroupMenu, {
      ...menuProps,
      items: menuChildren,
      prominence,
      onAction,
      isDisabled,
      state: state2,
      summaryIcon,
      hideButtonText,
      isOnlyItem: visibleItems === 0,
      orientation
    });
  }
  let style = {
    ...styleProps.style,
    // While measuring, take up as much space as possible.
    flexBasis: isMeasuring ? "100%" : void 0
  };
  return (0, import_jsx_runtime54.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    children: (0, import_jsx_runtime54.jsx)("div", {
      ...styleProps,
      style,
      className: classNames(css({
        display: "flex",
        minWidth: 0
      }), styleProps.className),
      ref: wrapperRef,
      children: (0, import_jsx_runtime54.jsx)("div", {
        ...actionGroupProps,
        ...toDataAttributes({
          overflow: overflowMode,
          prominence,
          justified: isJustified && !isMeasuring || void 0,
          compact: density === "compact" || void 0,
          vertical: orientation === "vertical" || void 0
        }),
        ref: domRef,
        className: classNames(css({
          display: "flex",
          // NOTE: prefer `gap` but it breaks the measurement/collapse logic, so we use margin instead.
          margin: `calc(var(--action-item-gap) / -2)`,
          minWidth: 0,
          width: "calc(100% + var(--action-item-gap) + 1px)",
          "--action-item-gap": tokenSchema.size.space.regular,
          [actionButtonClassList.selector("root", "child")]: {
            margin: `calc(var(--action-item-gap) / 2)`
          },
          // wrap
          "&[data-overflow=wrap]": {
            flexWrap: "wrap"
          },
          // justified
          "&[data-justified]": {
            [actionButtonClassList.selector("root", "child")]: {
              flexGrow: 1
            }
          },
          // compact
          "&[data-compact]:not([data-prominence=low])": {
            "--action-item-gap": 0,
            // gap: 0,
            [actionButtonClassList.selector("root", "child")]: {
              borderRadius: 0,
              "&:first-of-type": {
                borderTopLeftRadius: tokenSchema.size.radius.regular,
                borderBottomLeftRadius: tokenSchema.size.radius.regular
              },
              "&:last-of-type": {
                borderTopRightRadius: tokenSchema.size.radius.regular,
                borderBottomRightRadius: tokenSchema.size.radius.regular
              },
              "&:not(:last-of-type)": {
                marginRight: `calc(${tokenSchema.size.border.regular} * -1)`
              },
              "&.is-hovered, &.is-focused, &.is-pressed": {
                zIndex: 1
              },
              "&.is-selected": {
                zIndex: 2
              }
            }
          },
          "&[data-compact][data-prominence=low]": {
            "--action-item-gap": tokenSchema.size.space.small
          }
        }), otherProps.UNSAFE_className),
        children: (0, import_jsx_runtime54.jsxs)(KeystarProvider, {
          ...providerProps,
          children: [children.map((item2) => (0, import_jsx_runtime54.jsx)(ActionGroupItem, {
            onAction,
            prominence,
            isDisabled,
            item: item2,
            state: state2,
            hideButtonText,
            orientation
          }, item2.key)), menuItem]
        })
      })
    })
  });
}
var _ActionGroup = (0, import_react53.forwardRef)(ActionGroup);
function ActionGroupItem({
  item: item2,
  state: state2,
  isDisabled,
  onAction,
  hideButtonText,
  orientation,
  prominence
}) {
  let ref2 = (0, import_react53.useRef)(null);
  let {
    buttonProps
  } = $f0ac0fb73c3ec062$export$9597202bd3099a29({
    key: item2.key
  }, state2);
  isDisabled = isDisabled || state2.disabledKeys.has(item2.key);
  let isSelected = state2.selectionManager.isSelected(item2.key);
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(item2.props);
  if (onAction && !isDisabled) {
    buttonProps = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, {
      onPress: () => onAction(item2.key)
    });
  }
  let textId = $bdb11010cef70236$export$f680877a34711e37();
  let kbdId = $bdb11010cef70236$export$f680877a34711e37();
  let [textContent, setTextContent] = (0, import_react53.useState)("");
  let [kbdContent, setKbdContent] = (0, import_react53.useState)("");
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (hideButtonText) {
      var _document$getElementB, _document$getElementB2;
      setTextContent((_document$getElementB = document.getElementById(textId)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.textContent);
      setKbdContent((_document$getElementB2 = document.getElementById(kbdId)) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.textContent);
    }
  }, [hideButtonText, item2.rendered, textId, kbdId]);
  let button = (
    // Use a PressResponder to send DOM props through.
    // Button doesn't allow overriding the role by default.
    (0, import_jsx_runtime54.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, domProps),
      children: (0, import_jsx_runtime54.jsx)(ClearSlots, {
        children: (0, import_jsx_runtime54.jsx)(SlotProvider, {
          slots: {
            kbd: {
              id: hideButtonText ? kbdId : void 0,
              isHidden: true
              // always hide kbd in buttons
            },
            text: {
              id: hideButtonText ? textId : void 0,
              isHidden: hideButtonText
            }
          },
          children: (0, import_jsx_runtime54.jsx)(ActionButton, {
            ...item2.props,
            prominence,
            ref: ref2,
            UNSAFE_className: classNames(css({
              flexShrink: 0
            })),
            isSelected,
            isDisabled,
            "aria-label": item2["aria-label"],
            "aria-labelledby": item2["aria-label"] == null && hideButtonText ? textId : void 0,
            children: item2.rendered
          })
        })
      })
    })
  );
  if (hideButtonText && textContent) {
    button = (0, import_jsx_runtime54.jsxs)(_TooltipTrigger, {
      placement: orientation === "vertical" ? "end" : "top",
      children: [button, (0, import_jsx_runtime54.jsx)(Tooltip, {
        children: kbdContent ? (0, import_jsx_runtime54.jsxs)(import_jsx_runtime54.Fragment, {
          children: [(0, import_jsx_runtime54.jsx)(Text, {
            children: textContent
          }), (0, import_jsx_runtime54.jsx)(Kbd, {
            children: kbdContent
          })]
        }) : textContent
      })]
    });
  }
  if (item2.wrapper) {
    button = item2.wrapper(button);
  }
  return button;
}
function ActionGroupMenu({
  hideButtonText,
  isDisabled,
  isOnlyItem,
  items,
  onAction,
  orientation,
  prominence,
  state: state2,
  summaryIcon,
  ...otherProps
}) {
  let key3 = items[0].key;
  let {
    buttonProps
  } = $f0ac0fb73c3ec062$export$9597202bd3099a29({
    key: key3
  }, state2);
  delete buttonProps.onPress;
  delete buttonProps.role;
  delete buttonProps["aria-checked"];
  let ariaLabel = otherProps["aria-label"] || (otherProps["aria-labelledby"] ? void 0 : "…");
  let ariaLabelledby = otherProps["aria-labelledby"];
  let textId = $bdb11010cef70236$export$f680877a34711e37();
  let id = $bdb11010cef70236$export$f680877a34711e37();
  if (state2.selectionManager.selectionMode === "none") {
    summaryIcon = null;
  }
  let isSelected = state2.selectionManager.selectionMode !== "none" && items.some((i2) => state2.selectionManager.isSelected(i2.key));
  if (!summaryIcon && state2.selectionManager.selectionMode === "single" && state2.selectionManager.disallowEmptySelection && state2.selectionManager.firstSelectedKey != null) {
    let selectedItem = state2.collection.getItem(state2.selectionManager.firstSelectedKey);
    if (selectedItem) {
      var _ariaLabelledby;
      summaryIcon = selectedItem.rendered;
      if (isReactText(summaryIcon)) {
        summaryIcon = (0, import_jsx_runtime54.jsx)(Text, {
          children: summaryIcon
        });
      }
      ariaLabelledby = `${(_ariaLabelledby = ariaLabelledby) !== null && _ariaLabelledby !== void 0 ? _ariaLabelledby : id} ${textId}`;
    }
  }
  if (summaryIcon) {
    summaryIcon = (0, import_jsx_runtime54.jsxs)(import_jsx_runtime54.Fragment, {
      children: [summaryIcon, (0, import_jsx_runtime54.jsx)(Icon, {
        src: chevronDownIcon
      })]
    });
  }
  return (
    // Use a PressResponder to send DOM props through.
    (0, import_jsx_runtime54.jsxs)(MenuTrigger, {
      align: isOnlyItem ? "start" : "end",
      direction: orientation === "vertical" ? "end" : "bottom",
      children: [(0, import_jsx_runtime54.jsx)(SlotProvider, {
        slots: {
          text: {
            id: hideButtonText ? textId : void 0,
            isHidden: hideButtonText
          }
        },
        children: (0, import_jsx_runtime54.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
          ...buttonProps,
          children: (0, import_jsx_runtime54.jsx)(ActionButton, {
            ...otherProps,
            id,
            prominence,
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledby,
            isDisabled,
            isSelected,
            children: summaryIcon || (0, import_jsx_runtime54.jsx)(Icon, {
              src: moreHorizontalIcon
            })
          })
        })
      }), (0, import_jsx_runtime54.jsx)(_Menu, {
        items,
        disabledKeys: state2.disabledKeys,
        selectionMode: state2.selectionManager.selectionMode,
        selectedKeys: state2.selectionManager.selectedKeys,
        disallowEmptySelection: state2.selectionManager.disallowEmptySelection,
        onSelectionChange: (keys3) => state2.selectionManager.setSelectedKeys(keys3),
        onAction,
        children: (node3) => (0, import_jsx_runtime54.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          ...node3.props,
          textValue: node3.textValue,
          children: node3.rendered
        })
      })]
    })
  );
}
function outerWidth(element3, ignoreLeftMargin, ignoreRightMargin) {
  let style = window.getComputedStyle(element3);
  return element3.offsetWidth + (ignoreLeftMargin ? 0 : toNumber(style.marginLeft)) + (ignoreRightMargin ? 0 : toNumber(style.marginRight));
}
function outerHeight(element3, ignoreTopMargin, ignoreBottomMargin) {
  let style = window.getComputedStyle(element3);
  return element3.offsetHeight + (ignoreTopMargin ? 0 : toNumber(style.marginTop)) + (ignoreBottomMargin ? 0 : toNumber(style.marginBottom));
}
function toNumber(value) {
  let parsed = parseInt(value, 10);
  return isNaN(parsed) ? 0 : parsed;
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-maximizeIcon.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());
var maximizeIcon = (0, import_jsx_runtime55.jsx)("path", {
  d: "M8 3H5a2 2 0 0 0-2 2v3M21 8V5a2 2 0 0 0-2-2h-3M3 16v3a2 2 0 0 0 2 2h3M16 21h3a2 2 0 0 0 2-2v-3"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-minimizeIcon.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
var minimizeIcon = (0, import_jsx_runtime56.jsx)("path", {
  d: "M8 3v3a2 2 0 0 1-2 2H3M21 8h-3a2 2 0 0 1-2-2V3M3 16h3a2 2 0 0 1 2 2v3M16 21v-3a2 2 0 0 1 2-2h3"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-subscriptIcon.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());
var subscriptIcon = (0, import_jsx_runtime57.jsx)("path", {
  d: "m4 5 8 8M12 5l-8 8M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-superscriptIcon.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
var superscriptIcon = (0, import_jsx_runtime58.jsx)("path", {
  d: "m4 19 8-8M12 19l-8-8M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-typeIcon.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());
var typeIcon = (0, import_jsx_runtime59.jsx)("path", {
  d: "M4 7V4h16v3M9 20h6M12 4v16"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-underlineIcon.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());
var underlineIcon = (0, import_jsx_runtime60.jsx)("path", {
  d: "M6 4v6a6 6 0 0 0 12 0V4M4 20h16"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alignLeftIcon.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());
var alignLeftIcon = (0, import_jsx_runtime61.jsx)("path", {
  d: "M21 6H3M15 12H3M17 18H3"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alignRightIcon.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
var alignRightIcon = (0, import_jsx_runtime62.jsx)("path", {
  d: "M21 6H3M21 12H9M21 18H7"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alignCenterIcon.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());
var alignCenterIcon = (0, import_jsx_runtime63.jsx)("path", {
  d: "M21 6H3M17 12H7M19 18H5"
});

// node_modules/match-sorter/dist/match-sorter.esm.js
var import_remove_accents = __toESM(require_remove_accents());
var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
var defaultBaseSortFn = (a, b) => String(a.rankedValue).localeCompare(String(b.rankedValue));
function matchSorter(items, value, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    keys: keys3,
    threshold = rankings.MATCHES,
    baseSort = defaultBaseSortFn,
    sorter = (matchedItems2) => matchedItems2.sort((a, b) => sortRankedValues(a, b, baseSort))
  } = options;
  const matchedItems = items.reduce(reduceItemsToRanked, []);
  return sorter(matchedItems).map((_ref) => {
    let {
      item: item2
    } = _ref;
    return item2;
  });
  function reduceItemsToRanked(matches3, item2, index4) {
    const rankingInfo = getHighestRanking(item2, keys3, value, options);
    const {
      rank,
      keyThreshold = threshold
    } = rankingInfo;
    if (rank >= keyThreshold) {
      matches3.push({
        ...rankingInfo,
        item: item2,
        index: index4
      });
    }
    return matches3;
  }
}
matchSorter.rankings = rankings;
function getHighestRanking(item2, keys3, value, options) {
  if (!keys3) {
    const stringItem = item2;
    return {
      // ends up being duplicate of 'item' in matches but consistent
      rankedValue: stringItem,
      rank: getMatchRanking(stringItem, value, options),
      keyIndex: -1,
      keyThreshold: options.threshold
    };
  }
  const valuesToRank = getAllValuesToRank(item2, keys3);
  return valuesToRank.reduce((_ref2, _ref3, i2) => {
    let {
      rank,
      rankedValue,
      keyIndex,
      keyThreshold
    } = _ref2;
    let {
      itemValue,
      attributes
    } = _ref3;
    let newRank = getMatchRanking(itemValue, value, options);
    let newRankedValue = rankedValue;
    const {
      minRanking,
      maxRanking,
      threshold
    } = attributes;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    if (newRank > rank) {
      rank = newRank;
      keyIndex = i2;
      keyThreshold = threshold;
      newRankedValue = itemValue;
    }
    return {
      rankedValue: newRankedValue,
      rank,
      keyIndex,
      keyThreshold
    };
  }, {
    rankedValue: item2,
    rank: rankings.NO_MATCH,
    keyIndex: -1,
    keyThreshold: options.threshold
  });
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(` ${stringToRank}`)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string3) {
  let acronym = "";
  const wordsInString = string3.split(" ");
  wordsInString.forEach((wordInString) => {
    const splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach((splitByHyphenWord) => {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  let matchingInOrderCharCount = 0;
  let charNumber = 0;
  function findMatchingCharacter(matchChar, string3, index4) {
    for (let j = index4, J = string3.length; j < J; j++) {
      const stringChar = string3[j];
      if (stringChar === matchChar) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    const spreadPercentage = 1 / spread2;
    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (let i2 = 1, I = stringToRank.length; i2 < I; i2++) {
    const matchChar = stringToRank[i2];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    const found2 = charNumber > -1;
    if (!found2) {
      return rankings.NO_MATCH;
    }
  }
  const spread = charNumber - firstIndex;
  return getRanking(spread);
}
function sortRankedValues(a, b, baseSort) {
  const aFirst = -1;
  const bFirst = 1;
  const {
    rank: aRank,
    keyIndex: aKeyIndex
  } = a;
  const {
    rank: bRank,
    keyIndex: bKeyIndex
  } = b;
  const same = aRank === bRank;
  if (same) {
    if (aKeyIndex === bKeyIndex) {
      return baseSort(a, b);
    } else {
      return aKeyIndex < bKeyIndex ? aFirst : bFirst;
    }
  } else {
    return aRank > bRank ? aFirst : bFirst;
  }
}
function prepareValueForComparison(value, _ref4) {
  let {
    keepDiacritics
  } = _ref4;
  value = `${value}`;
  if (!keepDiacritics) {
    value = (0, import_remove_accents.default)(value);
  }
  return value;
}
function getItemValues(item2, key3) {
  if (typeof key3 === "object") {
    key3 = key3.key;
  }
  let value;
  if (typeof key3 === "function") {
    value = key3(item2);
  } else if (item2 == null) {
    value = null;
  } else if (Object.hasOwnProperty.call(item2, key3)) {
    value = item2[key3];
  } else if (key3.includes(".")) {
    return getNestedValues(key3, item2);
  } else {
    value = null;
  }
  if (value == null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value;
  }
  return [String(value)];
}
function getNestedValues(path3, item2) {
  const keys3 = path3.split(".");
  let values3 = [item2];
  for (let i2 = 0, I = keys3.length; i2 < I; i2++) {
    const nestedKey = keys3[i2];
    let nestedValues = [];
    for (let j = 0, J = values3.length; j < J; j++) {
      const nestedItem = values3[j];
      if (nestedItem == null) continue;
      if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {
        const nestedValue = nestedItem[nestedKey];
        if (nestedValue != null) {
          nestedValues.push(nestedValue);
        }
      } else if (nestedKey === "*") {
        nestedValues = nestedValues.concat(nestedItem);
      }
    }
    values3 = nestedValues;
  }
  if (Array.isArray(values3[0])) {
    const result = [];
    return result.concat(...values3);
  }
  return values3;
}
function getAllValuesToRank(item2, keys3) {
  const allValues = [];
  for (let j = 0, J = keys3.length; j < J; j++) {
    const key3 = keys3[j];
    const attributes = getKeyAttributes(key3);
    const itemValues = getItemValues(item2, key3);
    for (let i2 = 0, I = itemValues.length; i2 < I; i2++) {
      allValues.push({
        itemValue: itemValues[i2],
        attributes
      });
    }
  }
  return allValues;
}
var defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getKeyAttributes(key3) {
  if (typeof key3 === "string") {
    return defaultKeyAttributes;
  }
  return {
    ...defaultKeyAttributes,
    ...key3
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-trashIcon.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime());
var trashIcon = (0, import_jsx_runtime64.jsx)("path", {
  d: "M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-columnsIcon.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime());
var columnsIcon = (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, {
  children: [(0, import_jsx_runtime65.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime65.jsx)("path", {
    d: "M12 3v18"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-fileUpIcon.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime());
var fileUpIcon = (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, {
  children: [(0, import_jsx_runtime66.jsx)("path", {
    d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
  }), (0, import_jsx_runtime66.jsx)("path", {
    d: "M14 2v4a2 2 0 0 0 2 2h4M12 12v6M15 15l-3-3-3 3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-action-bar.js
var import_react54 = __toESM(require_react());
var import_jsx_runtime67 = __toESM(require_jsx_runtime());
var localizedMessages6 = {
  "ar-AE": {
    actions: "الإجراءات",
    actionsAvailable: "الإجراءات المتاحة.",
    clearSelection: "إزالة التحديد",
    selected: "{count, plural, =0 {غير محدد} other {# محدد}}",
    selectedAll: "تم تحديد الكل"
  },
  "bg-BG": {
    actions: "Действия",
    actionsAvailable: "Налични действия.",
    clearSelection: "Изчистване на избора",
    selected: "{count, plural, =0 {Няма избрани} one {# избран} other {# избрани}}",
    selectedAll: "Всички избрани"
  },
  "cs-CZ": {
    actions: "Akce",
    actionsAvailable: "Dostupné akce.",
    clearSelection: "Vymazat výběr",
    selected: "Vybráno: { count }",
    selectedAll: "Vybráno vše"
  },
  "da-DK": {
    actions: "Handlinger",
    actionsAvailable: "Tilgængelige handlinger.",
    clearSelection: "Ryd markering",
    selected: "{count, plural, =0 {Ingen valgt} other {# valgt}}",
    selectedAll: "Alle valgt"
  },
  "de-DE": {
    actions: "Aktionen",
    actionsAvailable: "Aktionen verfügbar.",
    clearSelection: "Auswahl löschen",
    selected: "{count, plural, =0 {Nichts ausgewählt} one {# ausgewählt} other {# ausgewählt}}",
    selectedAll: "Alles ausgewählt"
  },
  "el-GR": {
    actions: "Ενέργειες",
    actionsAvailable: "Υπάρχουν διαθέσιμες ενέργειες.",
    clearSelection: "Εκκαθάριση επιλογής",
    selected: "{count, plural, =0 {Δεν επιλέχθηκε κανένα} one {# επιλεγμένο} other {# επιλεγμένα}}",
    selectedAll: "Επιλέχθηκαν όλα"
  },
  "en-US": {
    clearSelection: "Clear selection",
    selected: "{count, plural, =0 {None selected} other {# selected}}",
    selectedAll: "All selected",
    actions: "Actions",
    actionsAvailable: "Actions available."
  },
  "es-ES": {
    actions: "Acciones",
    actionsAvailable: "Acciones disponibles.",
    clearSelection: "Borrar selección",
    selected: "{count, plural, =0 {Nada seleccionado} one {# seleccionado} other {# seleccionados}}",
    selectedAll: "Todo seleccionado"
  },
  "et-EE": {
    actions: "Toimingud",
    actionsAvailable: "Toimingud saadaval.",
    clearSelection: "Puhasta valik",
    selected: "{count, plural, =0 {Pole valitud} other {# valitud}}",
    selectedAll: "Kõik valitud"
  },
  "fi-FI": {
    actions: "Toiminnot",
    actionsAvailable: "Toiminnot käytettävissä.",
    clearSelection: "Poista valinta",
    selected: "{count, plural, =0 {Ei mitään valittu} other {# valittu}}",
    selectedAll: "Kaikki valittu"
  },
  "fr-FR": {
    actions: "Actions",
    actionsAvailable: "Actions disponibles.",
    clearSelection: "Supprimer la sélection",
    selected: "{count, plural, =0 {Aucun élément sélectionné} one {# sélectionné} other {# sélectionnés}}",
    selectedAll: "Toute la sélection"
  },
  "he-IL": {
    actions: "פעולות",
    actionsAvailable: "פעולות זמינות.",
    clearSelection: "נקה בחירה",
    selected: '{count, plural, =0 {לא בוצעה בחירה} one { # בחר} other {# נבחרו}}",',
    selectedAll: "כל הפריטים שנבחרו"
  },
  "hr-HR": {
    actions: "Radnje",
    actionsAvailable: "Dostupne radnje.",
    clearSelection: "Poništi odabir",
    selected: "Odabrano: { count }",
    selectedAll: "Sve je odabrano"
  },
  "hu-HU": {
    actions: "Műveletek",
    actionsAvailable: "Műveletek állnak rendelkezésre.",
    clearSelection: "Kijelölés törlése",
    selected: "{count, plural, =0 {Egy sincs kijelölve} other {# kijelölve}}",
    selectedAll: "Mind kijelölve"
  },
  "it-IT": {
    actions: "Azioni",
    actionsAvailable: "Azioni disponibili.",
    clearSelection: "Annulla selezione",
    selected: "{count, plural, =0 {Nessuno selezionato} one {# selezionato} other {# selezionati}}",
    selectedAll: "Tutti selezionati"
  },
  "ja-JP": {
    actions: "アクション",
    actionsAvailable: "アクションを利用できます。",
    clearSelection: "選択をクリア",
    selected: "{count, plural, =0 {選択されていません} other {# 個を選択しました}}",
    selectedAll: "すべてを選択"
  },
  "ko-KR": {
    actions: "액션",
    actionsAvailable: "사용 가능한 액션",
    clearSelection: "선택 항목 지우기",
    selected: "{count, plural, =0 {선택된 항목 없음} other {#개 선택됨}}",
    selectedAll: "모두 선택됨"
  },
  "lt-LT": {
    actions: "Veiksmai",
    actionsAvailable: "Galimi veiksmai.",
    clearSelection: "Išvalyti pasirinkimą",
    selected: "Pasirinkta: {count}",
    selectedAll: "Pasirinkta viskas"
  },
  "lv-LV": {
    actions: "Darbības",
    actionsAvailable: "Pieejamas darbības.",
    clearSelection: "Notīrīt atlasi",
    selected: "{count, plural, =0 {Nav atlasīts nekas} other {Atlasīts(-i): #}}",
    selectedAll: "Atlasīts viss"
  },
  "nb-NO": {
    actions: "Handlinger",
    actionsAvailable: "Tilgjengelige handlinger.",
    clearSelection: "Tøm utvalg",
    selected: "Valde element: {count}",
    selectedAll: "Alle er valgt"
  },
  "nl-NL": {
    actions: "Acties",
    actionsAvailable: "Acties beschikbaar.",
    clearSelection: "Selectie wissen",
    selected: "{count, plural, =0 {Niets geselecteerd} other {# geselecteerd}}",
    selectedAll: "Alles geselecteerd"
  },
  "pl-PL": {
    actions: "Działania",
    actionsAvailable: "Dostępne działania.",
    clearSelection: "Wyczyść zaznaczenie",
    selected: "Zaznaczono: {count}",
    selectedAll: "Wszystkie zaznaczone"
  },
  "pt-BR": {
    actions: "Ações",
    actionsAvailable: "Ações disponíveis.",
    clearSelection: "Limpar seleção",
    selected: "{count, plural, =0 {Nenhum selecionado} one {# selecionado} other {# selecionados}}",
    selectedAll: "Todos selecionados"
  },
  "pt-PT": {
    actions: "Ações",
    actionsAvailable: "Ações disponíveis.",
    clearSelection: "Limpar seleção",
    selected: "{count, plural, =0 {Nenhum selecionado} one {# selecionado} other {# selecionados}}",
    selectedAll: "Tudo selecionado"
  },
  "ro-RO": {
    actions: "Acțiuni",
    actionsAvailable: "Acțiuni disponibile.",
    clearSelection: "Goliți selecția",
    selected: "{count, plural, =0 {Niciunul selectat} one { # selectat} other {# selectate}}",
    selectedAll: "Toate selectate"
  },
  "ru-RU": {
    actions: "Действия",
    actionsAvailable: "Возможно выполнение действий.",
    clearSelection: "Очистить выбор",
    selected: "Выбрано: {count}",
    selectedAll: "Выбрано все"
  },
  "sk-SK": {
    actions: "Akcie",
    actionsAvailable: "Dostupné akcie.",
    clearSelection: "Vymazať výber",
    selected: "Vybrané položky: {count}",
    selectedAll: "Všetky vybraté položky"
  },
  "sl-SI": {
    actions: "Dejanja",
    actionsAvailable: "Na voljo so dejanja.",
    clearSelection: "Počisti izbor",
    selected: "Izbrano: {count}",
    selectedAll: "Vsi izbrani"
  },
  "sr-SP": {
    actions: "Radnje",
    actionsAvailable: "Dostupne su radnje.",
    clearSelection: "Poništi izbor",
    selected: "Izabrano: {count}",
    selectedAll: "Sve je izabrano"
  },
  "sv-SE": {
    actions: "Åtgärder",
    actionsAvailable: "Åtgärder finns.",
    clearSelection: "Rensa markering",
    selected: "{count, plural, =0 {Inga valda} one {# vald} other {# valda}}",
    selectedAll: "Alla markerade"
  },
  "tr-TR": {
    actions: "Eylemler",
    actionsAvailable: "Eylemler mevcut.",
    clearSelection: "Seçimi temizle",
    selected: "{count, plural, =0 {Hiçbiri seçilmedi} other {# seçildi}}",
    selectedAll: "Tümü seçildi"
  },
  "uk-UA": {
    actions: "Дії",
    actionsAvailable: "Доступні дії.",
    clearSelection: "Очистити вибір",
    selected: "Вибрано: {count}",
    selectedAll: "Усе вибрано"
  },
  "zh-CN": {
    actions: "操作",
    actionsAvailable: "有可用操作。",
    clearSelection: "清除选择",
    selected: "{count, plural, =0 {无选择} other {已选择 # 个}}",
    selectedAll: "全选"
  },
  "zh-TW": {
    actions: "動作",
    actionsAvailable: "可執行的動作。",
    clearSelection: "清除選取項目",
    selected: "{count, plural, =0 {未選取任何項目} other {已選取 # 個}}",
    selectedAll: "已選取所有項目"
  }
};
var actionbarClassList = new ClassList("ActionBar", ["bar", "container"]);
var styles = {};
function ActionBar(props, forwardedRef) {
  let isOpen = props.selectedItemCount !== 0;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime67.jsx)(Transition, {
      nodeRef: domRef,
      isOpen,
      children: (0, import_jsx_runtime67.jsx)(ActionBarInnerWithRef, {
        ...props,
        ref: domRef
      })
    })
  );
}
function ActionBarInner(props, ref2) {
  props = useProviderProps(props);
  let {
    children,
    onAction,
    onClearSelection,
    selectedItemCount,
    isOpen,
    items
  } = props;
  let styleProps = useStyleProps(props);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages6);
  let [lastCount, setLastCount] = (0, import_react54.useState)(selectedItemCount);
  if ((selectedItemCount === "all" || selectedItemCount > 0) && selectedItemCount !== lastCount) {
    setLastCount(selectedItemCount);
  }
  let {
    keyboardProps
  } = $46d819fcbaf35654$export$8f71654801c2f7cd({
    onKeyDown(e3) {
      if (e3.key === "Escape") {
        e3.preventDefault();
        onClearSelection();
      }
    }
  });
  let isInitial = (0, import_react54.useRef)(true);
  (0, import_react54.useEffect)(() => {
    if (isInitial.current) {
      isInitial.current = false;
      $319e236875307eab$export$a9b970dcc4ae71a9(stringFormatter.format("actionsAvailable"));
    }
  }, [stringFormatter]);
  return (0, import_jsx_runtime67.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    restoreFocus: true,
    children: (0, import_jsx_runtime67.jsx)("div", {
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
      ...styleProps,
      ...keyboardProps,
      "data-open": isOpen,
      ref: ref2,
      className: classNames(css({
        flex: "none",
        height: 0,
        opacity: 0,
        overflow: "hidden",
        transition: transition(["height", "opacity"], {
          duration: "short"
        }),
        '&[data-open="true"]': {
          height: `calc(${tokenSchema.size.element.large} + (2 * ${tokenSchema.size.space.regular}))`,
          opacity: 1
        }
      }), actionbarClassList.element("root"), styleProps.className),
      children: (0, import_jsx_runtime67.jsxs)("div", {
        "data-open": isOpen,
        className: classNames(css({
          alignItems: "center",
          backgroundColor: tokenSchema.color.background.surface,
          border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
          borderRadius: tokenSchema.size.radius.medium,
          display: "grid",
          gap: tokenSchema.size.space.small,
          gridTemplateAreas: '"clear selected . actiongroup"',
          gridTemplateColumns: `auto max-content minmax(${tokenSchema.size.element.small}, 1fr) auto`,
          bottom: tokenSchema.size.space.regular,
          insetInline: tokenSchema.size.space.regular,
          isolation: "isolate",
          justifyContent: "space-between",
          margin: "0 auto",
          padding: tokenSchema.size.space.regular,
          position: "absolute",
          transform: `translateY(${tokenSchema.size.space.large})`,
          // initialise with offset
          transition: transition("transform", {
            duration: "short"
          }),
          '&[data-open="true"]': {
            transform: "translateY(0)"
          }
        }), actionbarClassList.element("bar"), styleProps.className),
        children: [(0, import_jsx_runtime67.jsx)(_ActionGroup, {
          items,
          "aria-label": stringFormatter.format("actions"),
          prominence: "low",
          overflowMode: "collapse",
          buttonLabelBehavior: "collapse",
          onAction,
          gridArea: "actiongroup",
          UNSAFE_className: classNames(styles, "react-spectrum-ActionBar-actionGroup"),
          children
        }), (0, import_jsx_runtime67.jsx)(ActionButton, {
          gridArea: "clear",
          "aria-label": stringFormatter.format("clearSelection"),
          onPress: () => onClearSelection(),
          prominence: "low",
          children: (0, import_jsx_runtime67.jsx)(Icon, {
            src: xIcon
          })
        }), (0, import_jsx_runtime67.jsx)(Text, {
          gridArea: "selected",
          children: lastCount === "all" ? stringFormatter.format("selectedAll") : `${lastCount} selected`
        })]
      })
    })
  });
}
var ActionBarInnerWithRef = import_react54.default.forwardRef(ActionBarInner);
var _ActionBar = import_react54.default.forwardRef(ActionBar);
function ActionBarContainer(props, forwardedRef) {
  let styleProps = useStyleProps(props);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  return (0, import_jsx_runtime67.jsx)("div", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ...styleProps,
    ref: domRef,
    className: classNames(css({
      display: "flex",
      flexDirection: "column",
      position: "relative",
      [`& > :not(${actionbarClassList.selector("root")})`]: {
        flex: 1,
        minHeight: 0
      }
    }), actionbarClassList.element("container"), styleProps.className),
    children: props.children
  });
}
var _ActionBarContainer = import_react54.default.forwardRef(ActionBarContainer);

// node_modules/decimal.js-light/decimal.mjs
var MAX_DIGITS = 1e9;
var defaults = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
};
var Decimal;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var exponentOutOfRange = decimalError + "Exponent out of range: ";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var ONE;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE);
var P = {};
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s) x.s = 1;
  return x;
};
P.comparedTo = P.cmp = function(y) {
  var i2, j, xdL, ydL, x = this;
  y = new x.constructor(y);
  if (x.s !== y.s) return x.s || -y.s;
  if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;
  xdL = x.d.length;
  ydL = y.d.length;
  for (i2 = 0, j = xdL < ydL ? xdL : ydL; i2 < j; ++i2) {
    if (x.d[i2] !== y.d[i2]) return x.d[i2] > y.d[i2] ^ x.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
};
P.decimalPlaces = P.dp = function() {
  var x = this, w = x.d.length - 1, dp = (w - x.e) * LOG_BASE;
  w = x.d[w];
  if (w) for (; w % 10 == 0; w /= 10) dp--;
  return dp < 0 ? 0 : dp;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.idiv = function(y) {
  var x = this, Ctor = x.constructor;
  return round2(divide(x, new Ctor(y), 0, 1), Ctor.precision);
};
P.equals = P.eq = function(y) {
  return !this.cmp(y);
};
P.exponent = function() {
  return getBase10Exponent(this);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  return this.cmp(y) >= 0;
};
P.isInteger = P.isint = function() {
  return this.e > this.d.length - 2;
};
P.isNegative = P.isneg = function() {
  return this.s < 0;
};
P.isPositive = P.ispos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return this.s === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base2) {
  var r2, x = this, Ctor = x.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base2 === void 0) {
    base2 = new Ctor(10);
  } else {
    base2 = new Ctor(base2);
    if (base2.s < 1 || base2.eq(ONE)) throw Error(decimalError + "NaN");
  }
  if (x.s < 1) throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
  if (x.eq(ONE)) return new Ctor(0);
  external = false;
  r2 = divide(ln(x, wpr), ln(base2, wpr), wpr);
  external = true;
  return round2(r2, pr);
};
P.minus = P.sub = function(y) {
  var x = this;
  y = new x.constructor(y);
  return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor, pr = Ctor.precision;
  y = new Ctor(y);
  if (!y.s) throw Error(decimalError + "NaN");
  if (!x.s) return round2(new Ctor(x), pr);
  external = false;
  q = divide(x, y, 0, 1).times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return exp(this);
};
P.naturalLogarithm = P.ln = function() {
  return ln(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s || 0;
  return x;
};
P.plus = P.add = function(y) {
  var x = this;
  y = new x.constructor(y);
  return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
};
P.precision = P.sd = function(z) {
  var e3, sd, w, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
  e3 = getBase10Exponent(x) + 1;
  w = x.d.length - 1;
  sd = w * LOG_BASE + 1;
  w = x.d[w];
  if (w) {
    for (; w % 10 == 0; w /= 10) sd--;
    for (w = x.d[0]; w >= 10; w /= 10) sd++;
  }
  return z && e3 > sd ? e3 : sd;
};
P.squareRoot = P.sqrt = function() {
  var e3, n2, pr, r2, s2, t2, wpr, x = this, Ctor = x.constructor;
  if (x.s < 1) {
    if (!x.s) return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e3 = getBase10Exponent(x);
  external = false;
  s2 = Math.sqrt(+x);
  if (s2 == 0 || s2 == 1 / 0) {
    n2 = digitsToString(x.d);
    if ((n2.length + e3) % 2 == 0) n2 += "0";
    s2 = Math.sqrt(n2);
    e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
    if (s2 == 1 / 0) {
      n2 = "5e" + e3;
    } else {
      n2 = s2.toExponential();
      n2 = n2.slice(0, n2.indexOf("e") + 1) + e3;
    }
    r2 = new Ctor(n2);
  } else {
    r2 = new Ctor(s2.toString());
  }
  pr = Ctor.precision;
  s2 = wpr = pr + 3;
  for (; ; ) {
    t2 = r2;
    r2 = t2.plus(divide(x, t2, wpr + 2)).times(0.5);
    if (digitsToString(t2.d).slice(0, wpr) === (n2 = digitsToString(r2.d)).slice(0, wpr)) {
      n2 = n2.slice(wpr - 3, wpr + 1);
      if (s2 == wpr && n2 == "4999") {
        round2(t2, pr + 1, 0);
        if (t2.times(t2).eq(x)) {
          r2 = t2;
          break;
        }
      } else if (n2 != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round2(r2, pr);
};
P.times = P.mul = function(y) {
  var carry, e3, i2, k, r2, rL, t2, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  if (!x.s || !y.s) return new Ctor(0);
  y.s *= x.s;
  e3 = x.e + y.e;
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r2 = xd;
    xd = yd;
    yd = r2;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r2 = [];
  rL = xdL + ydL;
  for (i2 = rL; i2--; ) r2.push(0);
  for (i2 = ydL; --i2 >= 0; ) {
    carry = 0;
    for (k = xdL + i2; k > i2; ) {
      t2 = r2[k] + yd[i2] * xd[k - i2 - 1] + carry;
      r2[k--] = t2 % BASE | 0;
      carry = t2 / BASE | 0;
    }
    r2[k] = (r2[k] + carry) % BASE | 0;
  }
  for (; !r2[--rL]; ) r2.pop();
  if (carry) ++e3;
  else r2.shift();
  y.d = r2;
  y.e = e3;
  return external ? round2(y, Ctor.precision) : y;
};
P.toDecimalPlaces = P.todp = function(dp, rm2) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0) return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm2 === void 0) rm2 = Ctor.rounding;
  else checkInt32(rm2, 0, 8);
  return round2(x, dp + getBase10Exponent(x) + 1, rm2);
};
P.toExponential = function(dp, rm2) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = toString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm2 === void 0) rm2 = Ctor.rounding;
    else checkInt32(rm2, 0, 8);
    x = round2(new Ctor(x), dp + 1, rm2);
    str = toString(x, true, dp + 1);
  }
  return str;
};
P.toFixed = function(dp, rm2) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) return toString(x);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm2 === void 0) rm2 = Ctor.rounding;
  else checkInt32(rm2, 0, 8);
  y = round2(new Ctor(x), dp + getBase10Exponent(x) + 1, rm2);
  str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);
  return x.isneg() && !x.isZero() ? "-" + str : str;
};
P.toInteger = P.toint = function() {
  var x = this, Ctor = x.constructor;
  return round2(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
};
P.toNumber = function() {
  return +this;
};
P.toPower = P.pow = function(y) {
  var e3, k, pr, r2, sign, yIsInt, x = this, Ctor = x.constructor, guard = 12, yn = +(y = new Ctor(y));
  if (!y.s) return new Ctor(ONE);
  x = new Ctor(x);
  if (!x.s) {
    if (y.s < 1) throw Error(decimalError + "Infinity");
    return x;
  }
  if (x.eq(ONE)) return x;
  pr = Ctor.precision;
  if (y.eq(ONE)) return round2(x, pr);
  e3 = y.e;
  k = y.d.length - 1;
  yIsInt = e3 >= k;
  sign = x.s;
  if (!yIsInt) {
    if (sign < 0) throw Error(decimalError + "NaN");
  } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r2 = new Ctor(ONE);
    e3 = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k % 2) {
        r2 = r2.times(x);
        truncate(r2.d, e3);
      }
      k = mathfloor(k / 2);
      if (k === 0) break;
      x = x.times(x);
      truncate(x.d, e3);
    }
    external = true;
    return y.s < 0 ? new Ctor(ONE).div(r2) : round2(r2, pr);
  }
  sign = sign < 0 && y.d[Math.max(e3, k)] & 1 ? -1 : 1;
  x.s = 1;
  external = false;
  r2 = y.times(ln(x, pr + guard));
  external = true;
  r2 = exp(r2);
  r2.s = sign;
  return r2;
};
P.toPrecision = function(sd, rm2) {
  var e3, str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    e3 = getBase10Exponent(x);
    str = toString(x, e3 <= Ctor.toExpNeg || e3 >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm2 === void 0) rm2 = Ctor.rounding;
    else checkInt32(rm2, 0, 8);
    x = round2(new Ctor(x), sd, rm2);
    e3 = getBase10Exponent(x);
    str = toString(x, sd <= e3 || e3 <= Ctor.toExpNeg, sd);
  }
  return str;
};
P.toSignificantDigits = P.tosd = function(sd, rm2) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm2 = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm2 === void 0) rm2 = Ctor.rounding;
    else checkInt32(rm2, 0, 8);
  }
  return round2(new Ctor(x), sd, rm2);
};
P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var x = this, e3 = getBase10Exponent(x), Ctor = x.constructor;
  return toString(x, e3 <= Ctor.toExpNeg || e3 >= Ctor.toExpPos);
};
function add(x, y) {
  var carry, d, e3, i2, k, len, xd, yd, Ctor = x.constructor, pr = Ctor.precision;
  if (!x.s || !y.s) {
    if (!y.s) y = new Ctor(x);
    return external ? round2(y, pr) : y;
  }
  xd = x.d;
  yd = y.d;
  k = x.e;
  e3 = y.e;
  xd = xd.slice();
  i2 = k - e3;
  if (i2) {
    if (i2 < 0) {
      d = xd;
      i2 = -i2;
      len = yd.length;
    } else {
      d = yd;
      e3 = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i2 > len) {
      i2 = len;
      d.length = 1;
    }
    d.reverse();
    for (; i2--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i2 = yd.length;
  if (len - i2 < 0) {
    i2 = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i2; ) {
    carry = (xd[--i2] = xd[i2] + yd[i2] + carry) / BASE | 0;
    xd[i2] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e3;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y.d = xd;
  y.e = e3;
  return external ? round2(y, pr) : y;
}
function checkInt32(i2, min3, max4) {
  if (i2 !== ~~i2 || i2 < min3 || i2 > max4) {
    throw Error(invalidArgument + i2);
  }
}
function digitsToString(d) {
  var i2, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i2 = 1; i2 < indexOfLastWord; i2++) {
      ws = d[i2] + "";
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
      str += ws;
    }
    w = d[i2];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k) str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; ) w /= 10;
  return str + w;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x, k) {
    var temp, carry = 0, i2 = x.length;
    for (x = x.slice(); i2--; ) {
      temp = x[i2] * k + carry;
      x[i2] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry) x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i2, r2;
    if (aL != bL) {
      r2 = aL > bL ? 1 : -1;
    } else {
      for (i2 = r2 = 0; i2 < aL; i2++) {
        if (a[i2] != b[i2]) {
          r2 = a[i2] > b[i2] ? 1 : -1;
          break;
        }
      }
    }
    return r2;
  }
  function subtract2(a, b, aL) {
    var i2 = 0;
    for (; aL--; ) {
      a[aL] -= i2;
      i2 = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i2 * BASE + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; ) a.shift();
  }
  return function(x, y, pr, dp) {
    var cmp2, e3, i2, k, prod, prodL, q, qd, rem, remL, rem0, sd, t2, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!x.s) return new Ctor(x);
    if (!y.s) throw Error(decimalError + "Division by zero");
    e3 = x.e - y.e;
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign);
    qd = q.d = [];
    for (i2 = 0; yd[i2] == (xd[i2] || 0); ) ++i2;
    if (yd[i2] > (xd[i2] || 0)) --e3;
    if (pr == null) {
      sd = pr = Ctor.precision;
    } else if (dp) {
      sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) return new Ctor(0);
    sd = sd / LOG_BASE + 2 | 0;
    i2 = 0;
    if (yL == 1) {
      k = 0;
      yd = yd[0];
      sd++;
      for (; (i2 < xL || k) && sd--; i2++) {
        t2 = k * BASE + (xd[i2] || 0);
        qd[i2] = t2 / yd | 0;
        k = t2 % yd | 0;
      }
    } else {
      k = BASE / (yd[0] + 1) | 0;
      if (k > 1) {
        yd = multiplyInteger(yd, k);
        xd = multiplyInteger(xd, k);
        yL = yd.length;
        xL = xd.length;
      }
      xi = yL;
      rem = xd.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; ) rem[remL++] = 0;
      yz = yd.slice();
      yz.unshift(0);
      yd0 = yd[0];
      if (yd[1] >= BASE / 2) ++yd0;
      do {
        k = 0;
        cmp2 = compare(yd, rem, yL, remL);
        if (cmp2 < 0) {
          rem0 = rem[0];
          if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
          k = rem0 / yd0 | 0;
          if (k > 1) {
            if (k >= BASE) k = BASE - 1;
            prod = multiplyInteger(yd, k);
            prodL = prod.length;
            remL = rem.length;
            cmp2 = compare(prod, rem, prodL, remL);
            if (cmp2 == 1) {
              k--;
              subtract2(prod, yL < prodL ? yz : yd, prodL);
            }
          } else {
            if (k == 0) cmp2 = k = 1;
            prod = yd.slice();
          }
          prodL = prod.length;
          if (prodL < remL) prod.unshift(0);
          subtract2(rem, prod, remL);
          if (cmp2 == -1) {
            remL = rem.length;
            cmp2 = compare(yd, rem, yL, remL);
            if (cmp2 < 1) {
              k++;
              subtract2(rem, yL < remL ? yz : yd, remL);
            }
          }
          remL = rem.length;
        } else if (cmp2 === 0) {
          k++;
          rem = [0];
        }
        qd[i2++] = k;
        if (cmp2 && rem[0]) {
          rem[remL++] = xd[xi] || 0;
        } else {
          rem = [xd[xi]];
          remL = 1;
        }
      } while ((xi++ < xL || rem[0] !== void 0) && sd--);
    }
    if (!qd[0]) qd.shift();
    q.e = e3;
    return round2(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
  };
}();
function exp(x, sd) {
  var denominator, guard, pow, sum, t2, wpr, i2 = 0, k = 0, Ctor = x.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));
  if (!x.s) return new Ctor(ONE);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t2 = new Ctor(0.03125);
  while (x.abs().gte(0.1)) {
    x = x.times(t2);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow = round2(pow.times(x), wpr);
    denominator = denominator.times(++i2);
    t2 = sum.plus(divide(pow, denominator, wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      while (k--) sum = round2(sum.times(sum), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round2(sum, pr)) : sum;
    }
    sum = t2;
  }
}
function getBase10Exponent(x) {
  var e3 = x.e * LOG_BASE, w = x.d[0];
  for (; w >= 10; w /= 10) e3++;
  return e3;
}
function getLn10(Ctor, sd, pr) {
  if (sd > Ctor.LN10.sd()) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round2(new Ctor(Ctor.LN10), sd);
}
function getZeroString(k) {
  var zs = "";
  for (; k--; ) zs += "0";
  return zs;
}
function ln(y, sd) {
  var c, c0, denominator, e3, numerator, sum, t2, wpr, x2, n2 = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, pr = Ctor.precision;
  if (x.s < 1) throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
  if (x.eq(ONE)) return new Ctor(0);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  if (x.eq(10)) {
    if (sd == null) external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  e3 = getBase10Exponent(x);
  if (Math.abs(e3) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n2++;
    }
    e3 = getBase10Exponent(x);
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e3++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t2 = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
    x = ln(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t2);
    Ctor.precision = pr;
    return sd == null ? (external = true, round2(x, pr)) : x;
  }
  sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
  x2 = round2(x.times(x), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round2(numerator.times(x2), wpr);
    t2 = sum.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e3 !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
      sum = divide(sum, new Ctor(n2), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round2(sum, pr)) : sum;
    }
    sum = t2;
    denominator += 2;
  }
}
function parseDecimal(x, str) {
  var e3, i2, len;
  if ((e3 = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i2 = str.search(/e/i)) > 0) {
    if (e3 < 0) e3 = i2;
    e3 += +str.slice(i2 + 1);
    str = str.substring(0, i2);
  } else if (e3 < 0) {
    e3 = str.length;
  }
  for (i2 = 0; str.charCodeAt(i2) === 48; ) ++i2;
  for (len = str.length; str.charCodeAt(len - 1) === 48; ) --len;
  str = str.slice(i2, len);
  if (str) {
    len -= i2;
    e3 = e3 - i2 - 1;
    x.e = mathfloor(e3 / LOG_BASE);
    x.d = [];
    i2 = (e3 + 1) % LOG_BASE;
    if (e3 < 0) i2 += LOG_BASE;
    if (i2 < len) {
      if (i2) x.d.push(+str.slice(0, i2));
      for (len -= LOG_BASE; i2 < len; ) x.d.push(+str.slice(i2, i2 += LOG_BASE));
      str = str.slice(i2);
      i2 = LOG_BASE - str.length;
    } else {
      i2 -= len;
    }
    for (; i2--; ) str += "0";
    x.d.push(+str);
    if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e3);
  } else {
    x.s = 0;
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function round2(x, sd, rm2) {
  var i2, j, k, n2, rd, doRound, w, xdi, xd = x.d;
  for (n2 = 1, k = xd[0]; k >= 10; k /= 10) n2++;
  i2 = sd - n2;
  if (i2 < 0) {
    i2 += LOG_BASE;
    j = sd;
    w = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i2 + 1) / LOG_BASE);
    k = xd.length;
    if (xdi >= k) return x;
    w = k = xd[xdi];
    for (n2 = 1; k >= 10; k /= 10) n2++;
    i2 %= LOG_BASE;
    j = i2 - LOG_BASE + n2;
  }
  if (rm2 !== void 0) {
    k = mathpow(10, n2 - j - 1);
    rd = w / k % 10 | 0;
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;
    doRound = rm2 < 4 ? (rd || doRound) && (rm2 == 0 || rm2 == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm2 == 4 || doRound || rm2 == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i2 > 0 ? j > 0 ? w / mathpow(10, n2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm2 == (x.s < 0 ? 8 : 7));
  }
  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k = getBase10Exponent(x);
      xd.length = 1;
      sd = sd - k - 1;
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;
      xd[0] = x.e = x.s = 0;
    }
    return x;
  }
  if (i2 == 0) {
    xd.length = xdi;
    k = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k = mathpow(10, LOG_BASE - i2);
    xd[xdi] = j > 0 ? (w / mathpow(10, n2 - j) % mathpow(10, j) | 0) * k : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd[0] += k) == BASE) {
          xd[0] = 1;
          ++x.e;
        }
        break;
      } else {
        xd[xdi] += k;
        if (xd[xdi] != BASE) break;
        xd[xdi--] = 0;
        k = 1;
      }
    }
  }
  for (i2 = xd.length; xd[--i2] === 0; ) xd.pop();
  if (external && (x.e > MAX_E || x.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x));
  }
  return x;
}
function subtract(x, y) {
  var d, e3, i2, j, k, len, xd, xe, xLTy, yd, Ctor = x.constructor, pr = Ctor.precision;
  if (!x.s || !y.s) {
    if (y.s) y.s = -y.s;
    else y = new Ctor(x);
    return external ? round2(y, pr) : y;
  }
  xd = x.d;
  yd = y.d;
  e3 = y.e;
  xe = x.e;
  xd = xd.slice();
  k = xe - e3;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e3 = xe;
      len = xd.length;
    }
    i2 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i2) {
      k = i2;
      d.length = 1;
    }
    d.reverse();
    for (i2 = k; i2--; ) d.push(0);
    d.reverse();
  } else {
    i2 = xd.length;
    len = yd.length;
    xLTy = i2 < len;
    if (xLTy) len = i2;
    for (i2 = 0; i2 < len; i2++) {
      if (xd[i2] != yd[i2]) {
        xLTy = xd[i2] < yd[i2];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i2 = yd.length - len; i2 > 0; --i2) xd[len++] = 0;
  for (i2 = yd.length; i2 > k; ) {
    if (xd[--i2] < yd[i2]) {
      for (j = i2; j && xd[--j] === 0; ) xd[j] = BASE - 1;
      --xd[j];
      xd[i2] += BASE;
    }
    xd[i2] -= yd[i2];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e3;
  if (!xd[0]) return new Ctor(0);
  y.d = xd;
  y.e = e3;
  return external ? round2(y, pr) : y;
}
function toString(x, isExp, sd) {
  var k, e3 = getBase10Exponent(x), str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e3 < 0 ? "e" : "e+") + e3;
  } else if (e3 < 0) {
    str = "0." + getZeroString(-e3 - 1) + str;
    if (sd && (k = sd - len) > 0) str += getZeroString(k);
  } else if (e3 >= len) {
    str += getZeroString(e3 + 1 - len);
    if (sd && (k = sd - e3 - 1) > 0) str = str + "." + getZeroString(k);
  } else {
    if ((k = e3 + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e3 + 1 === len) str += ".";
      str += getZeroString(k);
    }
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone(obj) {
  var i2, p, ps;
  function Decimal2(value) {
    var x = this;
    if (!(x instanceof Decimal2)) return new Decimal2(value);
    x.constructor = Decimal2;
    if (value instanceof Decimal2) {
      x.s = value.s;
      x.e = value.e;
      x.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x.s = 1;
      } else if (value < 0) {
        value = -value;
        x.s = -1;
      } else {
        x.s = 0;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x.e = 0;
        x.d = [value];
        return;
      }
      return parseDecimal(x, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x.s = -1;
    } else {
      x.s = 1;
    }
    if (isDecimal.test(value)) parseDecimal(x, value);
    else throw Error(invalidArgument + value);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.clone = clone;
  Decimal2.config = Decimal2.set = config;
  if (obj === void 0) obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i2 = 0; i2 < ps.length; ) if (!obj.hasOwnProperty(p = ps[i2++])) obj[p] = this[p];
  }
  Decimal2.config(obj);
  return Decimal2;
}
function config(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i2, p, v, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i2 = 0; i2 < ps.length; i2 += 3) {
    if ((v = obj[p = ps[i2]]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i2 + 1] && v <= ps[i2 + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ": " + v);
    }
  }
  if ((v = obj[p = "LN10"]) !== void 0) {
    if (v == Math.LN10) this[p] = new this(v);
    else throw Error(invalidArgument + p + ": " + v);
  }
  return this;
}
var Decimal = clone(defaults);
ONE = new Decimal(1);
var decimal_default = Decimal;

// node_modules/@keystatic/core/node_modules/minimatch/dist/esm/index.js
var import_brace_expansion = __toESM(require_brace_expansion());

// node_modules/@keystatic/core/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/@keystatic/core/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s2) => s2.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position2) => {
  const pos = position2;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i2 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i2 < glob.length) {
    const c = glob.charAt(i2);
    if ((c === "!" || c === "^") && i2 === pos + 1) {
      negate = true;
      i2++;
      continue;
    }
    if (c === "]" && sawStart && !escaping) {
      endPos = i2 + 1;
      break;
    }
    sawStart = true;
    if (c === "\\") {
      if (!escaping) {
        escaping = true;
        i2++;
        continue;
      }
    }
    if (c === "[" && !escaping) {
      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
        if (glob.startsWith(cls, i2)) {
          if (rangeStart) {
            return ["$.", false, glob.length - pos, true];
          }
          i2 += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
      } else if (c === rangeStart) {
        ranges.push(braceEscape(c));
      }
      rangeStart = "";
      i2++;
      continue;
    }
    if (glob.startsWith("-]", i2 + 1)) {
      ranges.push(braceEscape(c + "-"));
      i2 += 2;
      continue;
    }
    if (glob.startsWith("-", i2 + 1)) {
      rangeStart = c;
      i2 += 2;
      continue;
    }
    ranges.push(braceEscape(c));
    i2++;
  }
  if (endPos < i2) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r2 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r2), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/@keystatic/core/node_modules/minimatch/dist/esm/unescape.js
var unescape = (s2, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s2.replace(/\[([^\/\\])\]/g, "$1") : s2.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/@keystatic/core/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _AST_instances, fillNegs_fn, _AST_static, parseAST_fn, partsToRegExp_fn, parseGlob_fn;
var _AST = class _AST {
  constructor(type, parent, options = {}) {
    __privateAdd(this, _AST_instances);
    __publicField(this, "type");
    __privateAdd(this, _root);
    __privateAdd(this, _hasMagic);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent);
    __privateAdd(this, _parentIndex);
    __privateAdd(this, _negs);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options);
    __privateAdd(this, _toString);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    __privateAdd(this, _emptyExt, false);
    this.type = type;
    if (type)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p of __privateGet(this, _parts)) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  // reconstructs the pattern
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
        throw new Error("invalid part: " + p);
      }
      __privateGet(this, _parts).push(p);
    }
  }
  toJSON() {
    var _a;
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    var _a;
    if (__privateGet(this, _root) === this)
      return true;
    if (!((_a = __privateGet(this, _parent)) == null ? void 0 : _a.isStart()))
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p = __privateGet(this, _parent);
    for (let i2 = 0; i2 < __privateGet(this, _parentIndex); i2++) {
      const pp2 = __privateGet(p, _parts)[i2];
      if (!(pp2 instanceof _AST && pp2.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    var _a, _b, _c;
    if (__privateGet(this, _root) === this)
      return true;
    if (((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!")
      return true;
    if (!((_b = __privateGet(this, _parent)) == null ? void 0 : _b.isEnd()))
      return false;
    if (!this.type)
      return (_c = __privateGet(this, _parent)) == null ? void 0 : _c.isEnd();
    const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of __privateGet(this, _parts)) {
      c.copyIn(p);
    }
    return c;
  }
  static fromGlob(pattern, options = {}) {
    var _a;
    const ast = new _AST(null, void 0, options);
    __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== __privateGet(this, _root))
      return __privateGet(this, _root).toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return __privateGet(this, _options);
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    var _a;
    const dot = allowDot ?? !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root) === this)
      __privateMethod(this, _AST_instances, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = __privateGet(this, _parts).map((p) => {
        var _a2;
        const [re, _, hasMagic, uflag] = typeof p === "string" ? __privateMethod(_a2 = _AST, _AST_static, parseGlob_fn).call(_a2, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).join("");
      let start3 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start3 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start3 + src + end;
      return [
        final2,
        unescape(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start2 = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s2 = this.toString();
      __privateSet(this, _parts, [s2]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s2, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close2 = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start2 + body + close2;
    }
    return [
      final,
      unescape(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_AST_instances = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n2;
  while (n2 = __privateGet(this, _negs).pop()) {
    if (n2.type !== "!")
      continue;
    let p = n2;
    let pp2 = __privateGet(p, _parent);
    while (pp2) {
      for (let i2 = __privateGet(p, _parentIndex) + 1; !pp2.type && i2 < __privateGet(pp2, _parts).length; i2++) {
        for (const part of __privateGet(n2, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp2, _parts)[i2]);
        }
      }
      p = pp2;
      pp2 = __privateGet(p, _parent);
    }
  }
  return this;
};
_AST_static = new WeakSet();
parseAST_fn = function(str, ast, pos, opt) {
  var _a, _b;
  let escaping = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i3 = pos;
    let acc2 = "";
    while (i3 < str.length) {
      const c = str.charAt(i3++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc2 += c;
        continue;
      }
      if (inBrace) {
        if (i3 === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i3 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i3;
        braceNeg = false;
        acc2 += c;
        continue;
      }
      if (!opt.noext && isExtglobType(c) && str.charAt(i3) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c, ast);
        i3 = __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, str, ext2, i3, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c;
    }
    ast.push(acc2);
    return i3;
  }
  let i2 = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i2 < str.length) {
    const c = str.charAt(i2++);
    if (escaping || c === "\\") {
      escaping = !escaping;
      acc += c;
      continue;
    }
    if (inBrace) {
      if (i2 === braceStart + 1) {
        if (c === "^" || c === "!") {
          braceNeg = true;
        }
      } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c;
      continue;
    } else if (c === "[") {
      inBrace = true;
      braceStart = i2;
      braceNeg = false;
      acc += c;
      continue;
    }
    if (isExtglobType(c) && str.charAt(i2) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c, part);
      part.push(ext2);
      i2 = __privateMethod(_b = _AST, _AST_static, parseAST_fn).call(_b, str, ext2, i2, opt);
      continue;
    }
    if (c === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i2;
    }
    acc += c;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str.substring(pos - 1)]);
  return i2;
};
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p) => {
    if (typeof p === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re;
  }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
};
parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
  let escaping = false;
  let re = "";
  let uflag = false;
  for (let i2 = 0; i2 < glob.length; i2++) {
    const c = glob.charAt(i2);
    if (escaping) {
      escaping = false;
      re += (reSpecials.has(c) ? "\\" : "") + c;
      continue;
    }
    if (c === "\\") {
      if (i2 === glob.length - 1) {
        re += "\\\\";
      } else {
        escaping = true;
      }
      continue;
    }
    if (c === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob, i2);
      if (consumed) {
        re += src;
        uflag = uflag || needUflag;
        i2 += consumed - 1;
        hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c === "*") {
      if (noEmpty && glob === "*")
        re += starNoEmpty;
      else
        re += star;
      hasMagic = true;
      continue;
    }
    if (c === "?") {
      re += qmark;
      hasMagic = true;
      continue;
    }
    re += regExpEscape(c);
  }
  return [re, unescape(glob), !!hasMagic, uflag];
};
__privateAdd(_AST, _AST_static);
var AST = _AST;

// node_modules/@keystatic/core/node_modules/minimatch/dist/esm/escape.js
var escape = (s2, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s2.replace(/[?*()[\]]/g, "[$&]") : s2.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/@keystatic/core/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults2 = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s2, options = {}) => orig.unescape(s2, ext(def, options)),
    escape: (s2, options = {}) => orig.escape(s2, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list5, pattern, options = {}) => orig.match(list5, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults2;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list5, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list5 = list5.filter((f) => mm.match(f));
  if (mm.options.nonull && !list5.length) {
    list5.push(pattern);
  }
  return list5;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s2) => this.slashSplit(s2));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set2 = this.globParts.map((s2, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s2[0] === "" && s2[1] === "" && (s2[2] === "?" || !globMagic.test(s2[2])) && !globMagic.test(s2[3]);
        const isDrive = /^[a-z]:/i.test(s2[0]);
        if (isUNC) {
          return [...s2.slice(0, 4), ...s2.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s2[0], ...s2.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s2.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set2);
    this.set = set2.filter((s2) => s2.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i2 = 0; i2 < this.set.length; i2++) {
        const p = this.set[i2];
        if (p[0] === "" && p[1] === "" && this.globParts[i2][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i2 = 0; i2 < globParts.length; i2++) {
        for (let j = 0; j < globParts[i2].length; j++) {
          if (globParts[i2][j] === "**") {
            globParts[i2][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i2 = gs;
        while (parts[i2 + 1] === "**") {
          i2++;
        }
        if (i2 !== gs) {
          parts.splice(gs, i2 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set2, part) => {
        const prev = set2[set2.length - 1];
        if (part === "**" && prev === "**") {
          return set2;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set2.pop();
            return set2;
          }
        }
        set2.push(part);
        return set2;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i2 = 1; i2 < parts.length - 1; i2++) {
          const p = parts[i2];
          if (i2 === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i2, 1);
            i2--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i2 = 1; i2 < parts.length - 1; i2++) {
            const p = parts[i2];
            if (i2 === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i2, 1);
              i2--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i2 = 0; i2 < globParts.length - 1; i2++) {
      for (let j = i2 + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i2], globParts[j], !this.preserveMultipleSlashes);
        if (!matched)
          continue;
        globParts[i2] = matched;
        globParts[j] = [];
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial2 = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial2)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial2) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial2;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set2.map((pattern) => {
      const pp2 = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp2.forEach((p, i2) => {
        const next = pp2[i2 + 1];
        const prev = pp2[i2 - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp2[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp2[i2] = twoStar;
          }
        } else if (next === void 0) {
          pp2[i2 - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp2[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp2[i2 + 1] = GLOBSTAR;
        }
      });
      return pp2.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close2] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close2 + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial2 = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial2) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i2 = ff.length - 2; !filename && i2 >= 0; i2--) {
        filename = ff[i2];
      }
    }
    for (let i2 = 0; i2 < set2.length; i2++) {
      const pattern = set2[i2];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial2);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-refreshCwIcon.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime());
var refreshCwIcon = (0, import_jsx_runtime68.jsxs)(import_jsx_runtime68.Fragment, {
  children: [(0, import_jsx_runtime68.jsx)("path", {
    d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"
  }), (0, import_jsx_runtime68.jsx)("path", {
    d: "M21 3v5h-5M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"
  }), (0, import_jsx_runtime68.jsx)("path", {
    d: "M8 16H3v5"
  })]
});

// node_modules/prosemirror-view/dist/index.js
var domIndex = function(node3) {
  for (var index4 = 0; ; index4++) {
    node3 = node3.previousSibling;
    if (!node3)
      return index4;
  }
};
var parentNode = function(node3) {
  let parent = node3.assignedSlot || node3.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node3, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node3, to == null ? node3.nodeValue.length : to);
  range.setStart(node3, from2 || 0);
  return range;
};
var clearReusedRange = function() {
  reusedRange = null;
};
var isEquivalentPosition = function(node3, off, targetNode, targetOff) {
  return targetNode && (scanFor(node3, off, targetNode, targetOff, -1) || scanFor(node3, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node3, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node3 == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node3))) {
      let parent = node3.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node3) || atomElements.test(node3.nodeName) || node3.contentEditable == "false")
        return false;
      off = domIndex(node3) + (dir < 0 ? 0 : 1);
      node3 = parent;
    } else if (node3.nodeType == 1) {
      node3 = node3.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node3.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node3) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node3) {
  return node3.nodeType == 3 ? node3.nodeValue.length : node3.childNodes.length;
}
function textNodeBefore$1(node3, offset5) {
  for (; ; ) {
    if (node3.nodeType == 3 && offset5)
      return node3;
    if (node3.nodeType == 1 && offset5 > 0) {
      if (node3.contentEditable == "false")
        return null;
      node3 = node3.childNodes[offset5 - 1];
      offset5 = nodeSize(node3);
    } else if (node3.parentNode && !hasBlockDesc(node3)) {
      offset5 = domIndex(node3);
      node3 = node3.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node3, offset5) {
  for (; ; ) {
    if (node3.nodeType == 3 && offset5 < node3.nodeValue.length)
      return node3;
    if (node3.nodeType == 1 && offset5 < node3.childNodes.length) {
      if (node3.contentEditable == "false")
        return null;
      node3 = node3.childNodes[offset5];
      offset5 = 0;
    } else if (node3.parentNode && !hasBlockDesc(node3)) {
      offset5 = domIndex(node3) + 1;
      node3 = node3.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node3, offset5, parent) {
  for (let atStart = offset5 == 0, atEnd = offset5 == nodeSize(node3); atStart || atEnd; ) {
    if (node3 == parent)
      return true;
    let index4 = domIndex(node3);
    node3 = node3.parentNode;
    if (!node3)
      return false;
    atStart = atStart && index4 == 0;
    atEnd = atEnd && index4 == nodeSize(node3);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key3) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key3;
  return event;
}
function deepActiveElement(doc4) {
  let elt = doc4.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc4, x, y) {
  if (doc4.caretPositionFromPoint) {
    try {
      let pos = doc4.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: pos.offset };
    } catch (_) {
    }
  }
  if (doc4.caretRangeFromPoint) {
    let range = doc4.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: range.startOffset };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc3 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac2 = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc3 && "webkitFontSmoothing" in doc3.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc4) {
  let vp = doc4.defaultView && doc4.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc4.documentElement.clientWidth,
    top: 0,
    bottom: doc4.documentElement.clientHeight
  };
}
function getSide2(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node3) {
  let rect = node3.getBoundingClientRect();
  let scaleX = rect.width / node3.offsetWidth || 1;
  let scaleY = rect.height / node3.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node3.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node3.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc4 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc4.body;
    let bounding = atTop ? windowRect(doc4) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide2(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide2(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide2(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide2(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide2(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide2(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide2(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide2(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide2(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc4.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
      break;
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc4 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc4)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i2 = 0; i2 < stack.length; i2++) {
    let { dom, top, left } = stack[i2];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node3, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset5 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node3.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset5 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset5 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node: node3, offset: offset5 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node3, coords) {
  let len = node3.nodeValue.length;
  let range = document.createRange();
  for (let i2 = 0; i2 < len; i2++) {
    range.setEnd(node3, i2 + 1);
    range.setStart(node3, i2);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node: node3, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node: node3, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node: node3, offset: offset5 } = findOffsetInNode(elt, coords), bias = -1;
  if (node3.nodeType == 1 && !node3.firstChild) {
    let rect = node3.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node3, offset5, bias);
}
function posFromCaret(view, node3, offset5, coords) {
  let outsideBlock = -1;
  for (let cur = node3, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
      let rect = desc.dom.getBoundingClientRect();
      if (desc.node.isBlock && desc.parent && !sawBlock) {
        sawBlock = true;
        if (rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node3, offset5, -1);
}
function elementFromPoint(element3, coords, box) {
  let len = element3.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
      let child = element3.childNodes[i2];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i2 = (i2 + 1) % len) == startI)
        break;
    }
  }
  return element3;
}
function posAtCoords(view, coords) {
  let doc4 = view.dom.ownerDocument, node3, offset5 = 0;
  let caret = caretFromPoint(doc4, coords.left, coords.top);
  if (caret)
    ({ node: node3, offset: offset5 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc4).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node3 && p; p = parentNode(p))
      if (p.draggable)
        node3 = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node3) {
    if (gecko && node3.nodeType == 1) {
      offset5 = Math.min(offset5, node3.childNodes.length);
      if (offset5 < node3.childNodes.length) {
        let next = node3.childNodes[offset5], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset5++;
      }
    }
    let prev;
    if (webkit && offset5 && node3.nodeType == 1 && (prev = node3.childNodes[offset5 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset5--;
    if (node3 == view.dom && offset5 == node3.childNodes.length - 1 && node3.lastChild.nodeType == 1 && coords.top > node3.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset5 == 0 || node3.nodeType != 1 || node3.childNodes[offset5 - 1].nodeName != "BR")
      pos = posFromCaret(view, node3, offset5, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first))
      return first;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node: node3, offset: offset5, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node3.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node3.nodeValue) || (side < 0 ? !offset5 : offset5 == node3.nodeValue.length))) {
      let rect = singleRect(textRange(node3, offset5, offset5), side);
      if (gecko && offset5 && /\s/.test(node3.nodeValue[offset5 - 1]) && offset5 < node3.nodeValue.length) {
        let rectBefore = singleRect(textRange(node3, offset5 - 1, offset5 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node3, offset5, offset5 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset5, to = offset5, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset5) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset5 == node3.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node3, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset5 && (side < 0 || offset5 == nodeSize(node3))) {
      let before = node3.childNodes[offset5 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset5 < nodeSize(node3)) {
      let after = node3.childNodes[offset5];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node3.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset5 && (side < 0 || offset5 == nodeSize(node3))) {
    let before = node3.childNodes[offset5 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset5 < nodeSize(node3)) {
    let after = node3.childNodes[offset5];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node3.nodeType == 3 ? textRange(node3) : node3, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state2, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state2)
    view.updateState(state2);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state2)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state2, dir) {
  let sel = state2.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state2, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i2 = 0; i2 < boxes.length; i2++) {
        let box = boxes[i2];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state2, dir) {
  let { $head } = state2.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset5 = $head.parentOffset, atStart = !offset5, atEnd = offset5 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state2, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state2, dir) {
  if (cachedState == state2 && cachedDir == dir)
    return cachedResult;
  cachedState = state2;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state2, dir) : endOfTextblockHorizontal(view, state2, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node3, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size4 = 0;
    for (let i2 = 0; i2 < this.children.length; i2++)
      size4 += this.children[i2].size;
    return size4;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i2 = 0; i2 < this.children.length; i2++)
      this.children[i2].destroy();
  }
  posBeforeChild(child) {
    for (let i2 = 0, pos = this.posAtStart; ; i2++) {
      let cur = this.children[i2];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset5, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset5 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset5];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset5 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset5 == 0)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = false;
            break;
          }
          if (search2.previousSibling)
            break;
        }
      if (atEnd == null && offset5 == dom.childNodes.length)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = true;
            break;
          }
          if (search2.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset5, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset5, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i2 = 0, offset5 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = offset5 + child.size;
      if (offset5 == pos && end != offset5) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset5 - child.border);
      offset5 = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i2 = 0, offset5 = 0;
    for (let curPos = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset5 = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset5)
      return this.children[i2].domFromPos(offset5 - this.children[i2].border, side);
    for (let prev; i2 && !(prev = this.children[i2 - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i2--) {
    }
    if (side <= 0) {
      let prev, enter = true;
      for (; ; i2--, enter = false) {
        prev = i2 ? this.children[i2 - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter = true;
      for (; ; i2++, enter = false) {
        next = i2 < this.children.length ? this.children[i2] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset5 = base2, i2 = 0; ; i2++) {
      let child = this.children[i2], end = offset5 + child.size;
      if (fromOffset == -1 && from2 <= end) {
        let childBase = offset5 + child.border;
        if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset5;
        for (let j = i2; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to || i2 == this.children.length - 1)) {
        to = end;
        for (let j = i2 + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset5 = end;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node: node3, offset: offset5 } = this.domFromPos(pos, 0);
    if (node3.nodeType != 1 || offset5 == node3.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node3.childNodes[offset5];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, root2, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i2 = 0, offset5 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = offset5 + child.size;
      if (from2 > offset5 && to < end)
        return child.setSelection(anchor - offset5 - child.border, head - offset5 - child.border, root2, force);
      offset5 = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = root2.getSelection();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node: node3, offset: offset5 } = anchorDOM;
      if (node3.nodeType == 3) {
        brKludge = !!(offset5 && node3.nodeValue[offset5 - 1] == "\n");
        if (brKludge && offset5 == node3.nodeValue.length) {
          for (let scan = node3, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node3.childNodes[offset5 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      let after = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset5 = 0, i2 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = offset5 + child.size;
      if (offset5 == end ? from2 <= end && to >= offset5 : from2 < end && to > offset5) {
        let startInside = offset5 + child.border, endInside = end - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset5 || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset5 = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node3 = this.parent; node3; node3 = node3.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node3.dirty < dirty)
        node3.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  isText(text7) {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text7) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text7;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset5) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset5 ? this.size : 0);
    return this.posAtStart + offset5;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
  }
  static create(parent, mark, inline7, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline7);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline7));
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size4 = this.size;
    if (to < size4)
      nodes = replaceNodes(nodes, to, size4, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i2 = 0; i2 < nodes.length; i2++)
      nodes[i2].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node3, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node3;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node3, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node3.type.name], descObj;
    let spec = custom && custom(node3, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node3.isText) {
      if (!dom)
        dom = document.createTextNode(node3.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node3.type.spec.toDOM(node3)));
    }
    if (!contentDOM && !node3.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node3.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node3);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node3, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node3.isText)
      return new TextViewDesc(parent, node3, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node3, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i2 = this.children.length - 1; i2 >= 0; i2--) {
        let child = this.children[i2];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment2.empty;
    }
    return rule;
  }
  matchesNode(node3, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node3.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline7 = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i2, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline7, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i2 == this.node.childCount ? Mark.none : this.node.child(i2).marks, inline7, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i2) => {
      updater.syncToMarks(child.marks, inline7, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i2)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i2, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline7, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text7 = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text7, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text7 };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node: node3, pos, text: text7 }) {
    if (this.getDesc(node3))
      return;
    let topNode = node3;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node3, text7);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text7.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node3, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node3.sameMarkup(this.node))
      return false;
    this.updateInner(node3, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node3, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node3;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc4, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc4);
  let docView = new NodeViewDesc(void 0, doc4, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node3, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node3, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node3, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node3.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node3.text != this.node.text) && node3.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node3.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node3;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n2 = this.nodeDOM; n2; n2 = n2.parentNode)
      if (n2 == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset5, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset5, this.node.text.length);
    return super.localPosFromDOM(dom, offset5, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node3 = this.node.cut(from2, to), dom = document.createTextNode(node3.text);
    return new _TextViewDesc(this.parent, node3, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text7) {
    return this.node.text == text7;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node3, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node3, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node3, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update) {
      let result = this.spec.update(node3, outerDeco, innerDeco);
      if (result)
        this.updateInner(node3, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node3.isLeaf) {
      return false;
    } else {
      return super.update(node3, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, root2, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root2) : super.setSelection(anchor, head, root2, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i2 = 0; i2 < descs.length; i2++) {
    let desc = descs[i2], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node3, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
  for (let i2 = 0; i2 < outerDeco.length; i2++) {
    let attrs = outerDeco[i2].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name2 in attrs) {
      let val = attrs[name2];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node3.isInline ? "span" : "div"));
      if (name2 == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name2 == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name2 != "nodeName")
        top[name2] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i2 = 0; i2 < curComputed.length; i2++) {
    let deco = curComputed[i2], prev = prevComputed[i2];
    if (i2) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name2 in prev)
    if (name2 != "class" && name2 != "style" && name2 != "nodeName" && !(name2 in cur))
      dom.removeAttribute(name2);
  for (let name2 in cur)
    if (name2 != "class" && name2 != "style" && name2 != "nodeName" && cur[name2] != prev[name2])
      dom.setAttribute(name2, cur[name2]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i2 = 0; i2 < prevList.length; i2++)
      if (curList.indexOf(prevList[i2]) == -1)
        dom.classList.remove(prevList[i2]);
    for (let i2 = 0; i2 < curList.length; i2++)
      if (prevList.indexOf(curList[i2]) == -1)
        dom.classList.add(curList[i2]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node3) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node3, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i2 = 0; i2 < a.length; i2++)
    if (!a[i2].type.eq(b[i2].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end) {
    if (start2 == end)
      return;
    for (let i2 = start2; i2 < end; i2++)
      this.top.children[i2].destroy();
    this.top.children.splice(start2, end - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline7, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
        let next = this.top.children[i2];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i2;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline7, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node3, outerDeco, innerDeco, index4) {
    let found2 = -1, targetDesc;
    if (index4 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index4 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node3, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i2 = this.index, e3 = Math.min(this.top.children.length, i2 + 5); i2 < e3; i2++) {
        let child = this.top.children[i2];
        if (child.matchesNode(node3, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i2;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node3, outerDeco, innerDeco, index4, view) {
    let child = this.top.children[index4];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node3, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index4);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i2 = this.index; i2 < this.top.children.length; i2++) {
            if (this.top.children[i2] == desc)
              return i2;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node3, outerDeco, innerDeco, view, index4, pos) {
    for (let i2 = this.index; i2 < this.top.children.length; i2++) {
      let next = this.top.children[i2];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index4)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node3.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node3.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node3, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i2);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node3, outerDeco, innerDeco, view, pos))) {
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node3, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node3.isAtom || !next.children.length || !next.node.content.eq(node3.content))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node3, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node3, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node3, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node3) {
    return this.lock && (node3 == this.lock || node3.nodeType == 1 && node3.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches3 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node3 = desc.node;
    if (!node3)
      continue;
    if (node3 != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches3.push(desc);
  }
  return { index: fI, matched, matches: matches3.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset5 = 0;
  if (locals.length == 0) {
    for (let i2 = 0; i2 < parent.childCount; i2++) {
      let child = parent.child(i2);
      onNode(child, locals, deco.forChild(offset5, child), i2);
      offset5 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset5) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i2 = 0; i2 < widgets.length; i2++)
          onWidget(widgets[i2], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index4;
    if (restNode) {
      index4 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index4 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i2 = 0; i2 < active.length; i2++)
      if (active[i2].to <= offset5)
        active.splice(i2--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset5 && locals[decoIndex].to > offset5)
      active.push(locals[decoIndex++]);
    let end = offset5 + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i2 = 0; i2 < active.length; i2++)
        if (active[i2].to < cutAt)
          cutAt = active[i2].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset5);
        child = child.cut(0, cutAt - offset5);
        end = cutAt;
        index4 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset5, child), index4);
    offset5 = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text7, from2, to) {
  for (let i2 = 0, pos = 0; i2 < frag.childCount && pos <= to; ) {
    let child = frag.child(i2++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i2 < frag.childCount) {
      let next = frag.child(i2++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text7.length - childStart, to - childStart) == text7)
        return to - text7.length;
      let found2 = childStart < to ? str.lastIndexOf(text7, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text7.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text7.length - childStart && str.slice(to - childStart, to - childStart + text7.length) == text7)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i2 = 0, off = 0; i2 < nodes.length; i2++) {
    let child = nodes[i2], start2 = off, end = off += child.size;
    if (start2 >= to || end <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc4 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc4.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc4.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc4.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node: node3, offset: offset5 } = view.docView.domFromPos(pos, 0);
  let after = offset5 < node3.childNodes.length ? node3.childNodes[offset5] : null;
  let before = offset5 ? node3.childNodes[offset5 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element3) {
  element3.contentEditable = "true";
  if (safari && element3.draggable) {
    element3.draggable = false;
    element3.wasDraggable = true;
  }
  return element3;
}
function resetEditable(element3) {
  element3.contentEditable = "false";
  if (element3.wasDraggable) {
    element3.draggable = true;
    element3.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc4 = view.dom.ownerDocument;
  doc4.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node3 = domSel.anchorNode, offset5 = domSel.anchorOffset;
  doc4.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node3 || domSel.anchorOffset != offset5) {
      doc4.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  let node3 = view.cursorWrapper.dom, img = node3.nodeName == "IMG";
  if (img)
    range.setEnd(node3.parentNode, domIndex(node3) + 1);
  else
    range.setEnd(node3, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node3.disabled = true;
    node3.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state2, dir) {
  let { $anchor, $head } = state2.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state2.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node3 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node3 || node3.isText || !node3.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node3.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node3 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node3 || node3.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node3.nodeSize : $head.pos;
      if (!(node3.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node3)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node3.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node3.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node3) {
  return node3.nodeType == 3 ? node3.nodeValue.length : node3.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node3 = sel.focusNode, offset5 = sel.focusOffset;
  if (!node3)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node3.nodeType == 1 && offset5 < nodeLen(node3) && isIgnorable(node3.childNodes[offset5], -1))
    force = true;
  for (; ; ) {
    if (offset5 > 0) {
      if (node3.nodeType != 1) {
        break;
      } else {
        let before = node3.childNodes[offset5 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node3;
          moveOffset = --offset5;
        } else if (before.nodeType == 3) {
          node3 = before;
          offset5 = node3.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node3)) {
      break;
    } else {
      let prev = node3.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node3.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node3 = node3.parentNode;
        if (node3 == view.dom)
          break;
        offset5 = 0;
      } else {
        node3 = prev;
        offset5 = nodeLen(node3);
      }
    }
  }
  if (force)
    setSelFocus(view, node3, offset5);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node3 = sel.focusNode, offset5 = sel.focusOffset;
  if (!node3)
    return;
  let len = nodeLen(node3);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset5 < len) {
      if (node3.nodeType != 1)
        break;
      let after = node3.childNodes[offset5];
      if (isIgnorable(after, 1)) {
        moveNode = node3;
        moveOffset = ++offset5;
      } else
        break;
    } else if (isBlockNode(node3)) {
      break;
    } else {
      let next = node3.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node3 = node3.parentNode;
        if (node3 == view.dom)
          break;
        offset5 = len = 0;
      } else {
        node3 = next;
        offset5 = 0;
        len = nodeLen(node3);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node3, offset5) {
  while (node3 && offset5 == node3.childNodes.length && !hasBlockDesc(node3)) {
    offset5 = domIndex(node3) + 1;
    node3 = node3.parentNode;
  }
  while (node3 && offset5 < node3.childNodes.length) {
    let next = node3.childNodes[offset5];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node3 = next;
    offset5 = 0;
  }
}
function textNodeBefore(node3, offset5) {
  while (node3 && !offset5 && !hasBlockDesc(node3)) {
    offset5 = domIndex(node3);
    node3 = node3.parentNode;
  }
  while (node3 && offset5) {
    let next = node3.childNodes[offset5 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node3 = next;
    offset5 = node3.childNodes.length;
  }
}
function setSelFocus(view, node3, offset5) {
  if (node3.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node3, offset5)) {
      node3 = after;
      offset5 = 0;
    } else if (before = textNodeBefore(node3, offset5)) {
      node3 = before;
      offset5 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node3, offset5);
    range.setStart(node3, offset5);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node3, offset5);
  }
  view.domObserver.setCurSelection();
  let { state: state2 } = view;
  setTimeout(() => {
    if (view.state == state2)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty5 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty5)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node3, state2) {
  view.domObserver.stop();
  node3.contentEditable = state2;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code4 = event.keyCode, mods = getMods(event);
  if (code4 == 8 || mac2 && code4 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code4 == 46 && !event.shiftKey || mac2 && code4 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code4 == 13 || code4 == 27) {
    return true;
  } else if (code4 == 37 || mac2 && code4 == 66 && mods == "c") {
    let dir = code4 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code4 == 39 || mac2 && code4 == 70 && mods == "c") {
    let dir = code4 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code4 == 38 || mac2 && code4 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code4 == 40 || mac2 && code4 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac2 ? "m" : "c") && (code4 == 66 || code4 == 73 || code4 == 89 || code4 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content: content3, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content3.childCount == 1 && content3.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node3 = content3.firstChild;
    context.push(node3.type.name, node3.attrs != node3.type.defaultAttrs ? node3.attrs : null);
    content3 = node3.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc4 = detachedDoc(), wrap2 = doc4.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content3, { document: doc4 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i2 = needsWrap.length - 1; i2 >= 0; i2--) {
      let wrapper = doc4.createElement(needsWrap[i2]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text7 = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text: text7 };
}
function parseFromClipboard(view, text7, html2, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html2 && !text7)
    return null;
  let asText = text7 && (plainText || inCode || !html2);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text7 = f(text7, inCode || plainText, view);
    });
    if (inCode)
      return text7 ? new Slice(Fragment2.from(view.state.schema.text(text7.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text7, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text7.split(/(?:\r\n?|\n)+/).forEach((block4) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block4)
          p.appendChild(serializer.serializeNode(schema.text(block4, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html2 = f(html2, view);
    });
    dom = readHTML(html2);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i2 = +sliceData[3]; i2 > 0; i2--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser2 = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    slice2 = parser2.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node3 = slice2.content.firstChild; openStart < slice2.openStart && !node3.type.spec.isolating; openStart++, node3 = node3.firstChild) {
      }
      for (let node3 = slice2.content.lastChild; openEnd < slice2.openEnd && !node3.type.spec.isolating; openEnd++, node3 = node3.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match2 = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node3) => {
      if (!result)
        return;
      let wrap2 = match2.findWrapping(node3.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node3, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node3, wrap2);
        result.push(wrapped);
        match2 = match2.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment2.from(result);
  }
  return fragment;
}
function withWrappers(node3, wrap2, from2 = 0) {
  for (let i2 = wrap2.length - 1; i2 >= from2; i2--)
    node3 = wrap2[i2].create(null, Fragment2.from(node3));
  return node3;
}
function addToSibling(wrap2, lastWrap, node3, sibling2, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node3, sibling2.lastChild, depth + 1);
    if (inner)
      return sibling2.copy(sibling2.content.replaceChild(sibling2.childCount - 1, inner));
    let match2 = sibling2.contentMatchAt(sibling2.childCount);
    if (match2.matchType(depth == wrap2.length - 1 ? node3.type : wrap2[depth + 1]))
      return sibling2.copy(sibling2.content.append(Fragment2.from(withWrappers(node3, wrap2, depth + 1))));
  }
}
function closeRight(node3, depth) {
  if (depth == 0)
    return node3;
  let fragment = node3.content.replaceChild(node3.childCount - 1, closeRight(node3.lastChild, depth - 1));
  let fill = node3.contentMatchAt(node3.childCount).fillBefore(Fragment2.empty, true);
  return node3.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node3 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node3.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node3.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node3.contentMatchAt(node3.childCount).fillBefore(Fragment2.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node3.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html2) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html2);
  if (metas)
    html2 = html2.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html2 = wrap2.map((n2) => "<" + n2 + ">").join("") + html2 + wrap2.map((n2) => "</" + n2 + ">").reverse().join("");
  elt.innerHTML = html2;
  if (wrap2)
    for (let i2 = 0; i2 < wrap2.length; i2++)
      elt = elt.querySelector(wrap2[i2]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i2 = 0; i2 < nodes.length; i2++) {
    let node3 = nodes[i2];
    if (node3.childNodes.length == 1 && node3.textContent == " " && node3.parentNode)
      node3.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node3);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e3) {
    return slice2;
  }
  let { content: content3, openStart, openEnd } = slice2;
  for (let i2 = array.length - 2; i2 >= 0; i2 -= 2) {
    let type = schema.nodes[array[i2]];
    if (!type || type.hasRequiredAttrs())
      break;
    content3 = Fragment2.from(type.create(array[i2 + 1], content3));
    openStart++;
    openEnd++;
  }
  return new Slice(content3, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node3 = event.target; node3 != view.dom; node3 = node3.parentNode)
    if (!node3 || node3.nodeType == 11 || node3.pmViewDesc && node3.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text7 = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text7) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text7)))
      view.dispatch(view.state.tr.insertText(text7).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    if (view.someProp(propName, (f) => i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node3 = $pos.nodeAfter;
  if (node3 && node3.isAtom && NodeSelection.isSelectable(node3)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    let node3 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    if (NodeSelection.isSelectable(node3)) {
      if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i2);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc4 = view.state.doc;
  if (inside == -1) {
    if (doc4.inlineContent) {
      updateSelection(view, TextSelection.create(doc4, 0, doc4.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc4.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    let node3 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    let nodePos = $pos.before(i2);
    if (node3.inlineContent)
      updateSelection(view, TextSelection.create(doc4, nodePos + 1, nodePos + 1 + node3.content.size), "pointer");
    else if (NodeSelection.isSelectable(node3))
      updateSelection(view, NodeSelection.create(doc4, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state: state2 } = view, $pos = state2.selection.$from;
    if (state2.selection.empty && (state2.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko && state2.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node3 = sel.focusNode, offset5 = sel.focusOffset; node3 && node3.nodeType == 1 && offset5 != 0; ) {
          let before = offset5 < 0 ? node3.lastChild : node3.childNodes[offset5 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node3 = before;
            offset5 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut = event.type == "cut";
  if (sel.empty)
    return;
  let data2 = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text: text7 } = serializeForClipboard(view, slice2);
  if (data2) {
    event.preventDefault();
    data2.clearData();
    data2.setData("text/html", dom.innerHTML);
    data2.setData("text/plain", text7);
  } else {
    captureCopy(view, dom);
  }
  if (cut)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text7, html2, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text7, html2, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text7 = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text7)
    return text7;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data2 = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data2 && doPaste(view, getText(data2), data2.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move2, node3) {
    this.slice = slice2;
    this.move = move2;
    this.node = node3;
  }
};
var dragCopyModifier = mac2 ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node3;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node3 = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node3 = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let slice2 = (node3 || view.state.selection).content(), { dom, text: text7 } = serializeForClipboard(view, slice2);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text7);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node3);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e3) => e3.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move2 = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move2))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move2) {
    let { node: node3 } = dragging;
    if (node3)
      node3.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode2)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset5, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset5, pos - offset5, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node3) {
    if (this.spec.destroy)
      this.spec.destroy(node3);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset5, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset5;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset5;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset5, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset5, to.pos - offset5, this);
  }
  valid(node3, span) {
    let { index: index4, offset: offset5 } = node3.content.findIndex(span.from), child;
    return offset5 == span.from && !(child = node3.child(index4)).isText && offset5 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset5 = 0) {
    return this.type.eq(other.type) && this.from + offset5 == other.from && this.to + offset5 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset5, oldOffset) {
    return this.type.map(mapping, this, offset5, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc4, decorations) {
    return decorations.length ? buildTree(decorations, doc4, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end == null ? 1e9 : end, result, 0, predicate);
    return result;
  }
  findInner(start2, end, result, offset5, predicate) {
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let span = this.local[i2];
      if (span.from <= end && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset5, span.to + offset5));
    }
    for (let i2 = 0; i2 < this.children.length; i2 += 3) {
      if (this.children[i2] < end && this.children[i2 + 1] > start2) {
        let childOff = this.children[i2] + 1;
        this.children[i2 + 2].findInner(start2 - childOff, end - childOff, result, offset5 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc4, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc4, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node3, offset5, oldOffset, options) {
    let newLocal;
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let mapped = this.local[i2].map(mapping, offset5, oldOffset);
      if (mapped && mapped.type.valid(node3, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i2].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node3, offset5, oldOffset, options);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc4, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return _DecorationSet.create(doc4, decorations);
    return this.addInner(doc4, decorations, 0);
  }
  addInner(doc4, decorations, offset5) {
    let children, childIndex = 0;
    doc4.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset5, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset5);
    for (let i2 = 0; i2 < local.length; i2++)
      if (!local[i2].type.valid(doc4, local[i2]))
        local.splice(i2--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset5) {
    let children = this.children, local = this.local;
    for (let i2 = 0; i2 < children.length; i2 += 3) {
      let found2;
      let from2 = children[i2] + offset5, to = children[i2 + 1] + offset5;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i2 + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i2 + 2] = removed;
      } else {
        children.splice(i2, 3);
        i2 -= 3;
      }
    }
    if (local.length) {
      for (let i2 = 0, span; i2 < decorations.length; i2++)
        if (span = decorations[i2]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset5)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new _DecorationSet(local, children) : empty;
  }
  forChild(offset5, node3) {
    if (this == empty)
      return this;
    if (node3.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i2 = 0; i2 < this.children.length; i2 += 3)
      if (this.children[i2] >= offset5) {
        if (this.children[i2] == offset5)
          child = this.children[i2 + 2];
        break;
      }
    let start2 = offset5 + 1, end = start2 + node3.content.size;
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let dec = this.local[i2];
      if (dec.from < end && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i2 = 0; i2 < this.local.length; i2++)
      if (!this.local[i2].eq(other.local[i2]))
        return false;
    for (let i2 = 0; i2 < this.children.length; i2 += 3)
      if (this.children[i2] != other.children[i2] || this.children[i2 + 1] != other.children[i2 + 1] || !this.children[i2 + 2].eq(other.children[i2 + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node3) {
    return removeOverlap(this.localsInner(node3));
  }
  /**
  @internal
  */
  localsInner(node3) {
    if (this == empty)
      return none;
    if (node3.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i2 = 0; i2 < this.local.length; i2++) {
      if (!(this.local[i2].type instanceof InlineType))
        result.push(this.local[i2]);
    }
    return result;
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc4) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc4, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset5, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i2 = 0; i2 < this.members.length; i2++) {
      let result = this.members[i2].forChild(offset5, child);
      if (result == empty)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i2 = 0; i2 < this.members.length; i2++)
      if (!this.members[i2].eq(other.members[i2]))
        return false;
    return true;
  }
  locals(node3) {
    let result, sorted = true;
    for (let i2 = 0; i2 < this.members.length; i2++) {
      let locals = this.members[i2].localsInner(node3);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
};
function mapChildren(oldChildren, newLocal, mapping, node3, offset5, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i2 = 0, baseOffset = oldOffset; i2 < mapping.maps.length; i2++) {
    let moved = 0;
    mapping.maps[i2].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i3 = 0; i3 < children.length; i3 += 3) {
        let end = children[i3 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start2 = children[i3] + baseOffset - moved;
        if (oldEnd >= start2) {
          children[i3 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i3] += dSize;
          children[i3 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i2].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i2 = 0; i2 < children.length; i2 += 3)
    if (children[i2 + 1] < 0) {
      if (children[i2 + 1] == -2) {
        mustRebuild = true;
        children[i2 + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i2] + oldOffset), fromLocal = from2 - offset5;
      if (fromLocal < 0 || fromLocal >= node3.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i2 + 1] + oldOffset, -1), toLocal = to - offset5;
      let { index: index4, offset: childOffset } = node3.content.findIndex(fromLocal);
      let childNode = node3.maybeChild(index4);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i2 + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i2] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i2] = fromLocal;
          children[i2 + 1] = toLocal;
          children[i2 + 2] = mapped;
        } else {
          children[i2 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset5, oldOffset, options);
    let built = buildTree(decorations, node3, 0, options);
    newLocal = built.local;
    for (let i2 = 0; i2 < children.length; i2 += 3)
      if (children[i2 + 1] < 0) {
        children.splice(i2, 3);
        i2 -= 3;
      }
    for (let i2 = 0, j = 0; i2 < built.children.length; i2 += 3) {
      let from2 = built.children[i2];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i2], built.children[i2 + 1], built.children[i2 + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset5) {
  if (!offset5 || !spans.length)
    return spans;
  let result = [];
  for (let i2 = 0; i2 < spans.length; i2++) {
    let span = spans[i2];
    result.push(new Decoration(span.from + offset5, span.to + offset5, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset5, oldOffset, options) {
  function gather(set2, oldOffset2) {
    for (let i2 = 0; i2 < set2.local.length; i2++) {
      let mapped = set2.local[i2].map(mapping, offset5, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set2.local[i2].spec);
    }
    for (let i2 = 0; i2 < set2.children.length; i2 += 3)
      gather(set2.children[i2 + 2], set2.children[i2] + oldOffset2 + 1);
  }
  for (let i2 = 0; i2 < children.length; i2 += 3)
    if (children[i2 + 1] == -1)
      gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node3, offset5) {
  if (node3.isLeaf)
    return null;
  let end = offset5 + node3.nodeSize, found2 = null;
  for (let i2 = 0, span; i2 < spans.length; i2++) {
    if ((span = spans[i2]) && span.from > offset5 && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i2] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i2 = 0; i2 < array.length; i2++)
    if (array[i2] != null)
      result.push(array[i2]);
  return result;
}
function buildTree(spans, node3, offset5, options) {
  let children = [], hasNulls = false;
  node3.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset5);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset5 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset5).sort(byPos);
  for (let i2 = 0; i2 < locals.length; i2++)
    if (!locals[i2].type.valid(node3, locals[i2])) {
      if (options.onRemove)
        options.onRemove(locals[i2].spec);
      locals.splice(i2--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i2 = 0; i2 < working.length - 1; i2++) {
    let span = working[i2];
    if (span.from != span.to)
      for (let j = i2 + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i2] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i2, deco) {
  while (i2 < array.length && byPos(deco, array[i2]) > 0)
    i2++;
  array.splice(i2, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i2 = 0; i2 < mutations.length; i2++)
        this.queue.push(mutations[i2]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e3) => {
        this.queue.push({ target: e3.target, type: "characterData", oldValue: e3.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i2 = 0; i2 < take.length; i2++)
          this.queue.push(take[i2]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i2 = 0; i2 < mutations.length; i2++) {
        let result = this.registerMutation(mutations[i2], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length > 1) {
      let brs = added.filter((n2) => n2.nodeName == "BR");
      if (brs.length == 2) {
        let a = brs[0], b = brs[1];
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i2 = 0; i2 < mut.addedNodes.length; i2++)
        added.push(mut.addedNodes[i2]);
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i2];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node3 = parent.childNodes[off - 1], desc = node3.pmViewDesc;
      if (node3.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser2 = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc4 = parser2.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    let anchor2 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc4, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr3 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr3.setMeta("pointer", true);
      else if (origin == "key")
        tr3.scrollIntoView();
      if (compositionID)
        tr3.setMeta("composition", compositionID);
      view.dispatch(tr3);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse5 = parseBetween(view, from2, to);
  let doc4 = view.state.doc, compare = doc4.slice(parse5.from, parse5.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse5.doc.content, parse5.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n2) => n2.nodeType == 1 && !isInline.test(n2.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse5.sel && parse5.sel.anchor != parse5.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse5.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse5.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr3 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr3.setMeta("composition", compositionID);
          view.dispatch(tr3);
        }
      }
      return;
    }
  }
  view.input.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse5.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse5.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse5.from && parse5.doc.textBetween(change.start - parse5.from - 1, change.start - parse5.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse5.doc.resolveNoCache(change.start - parse5.from);
  let $to = parse5.doc.resolveNoCache(change.endB - parse5.from);
  let $fromA = doc4.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n2) => n2.nodeName == "DIV" || n2.nodeName == "P")) || !inlineChange && $from.pos < parse5.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse5.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc4, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && android && change.endB == change.start)
    view.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse5.sel && parse5.sel.anchor == parse5.sel.head && parse5.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse5.doc.resolveNoCache(change.endB - parse5.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr2, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr2 = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc4.resolve(change.start).marksAcross(doc4.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr2 = view.state.tr;
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text7 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text7)))
        return;
      tr2 = view.state.tr.insertText(text7, chFrom, chTo);
    }
  }
  if (!tr2)
    tr2 = view.state.tr.replace(chFrom, chTo, parse5.doc.slice(change.start - parse5.from, change.endB - parse5.from));
  if (parse5.sel) {
    let sel2 = resolveSelection(view, tr2.doc, parse5.sel);
    if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
      tr2.setSelection(sel2);
  }
  if (storedMarks)
    tr2.ensureMarks(storedMarks);
  if (compositionID)
    tr2.setMeta("composition", compositionID);
  view.dispatch(tr2.scrollIntoView());
}
function resolveSelection(view, doc4, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc4.content.size)
    return null;
  return selectionBetween(view, doc4.resolve(parsedSel.anchor), doc4.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i2 = 0; i2 < prevMarks.length; i2++)
    added = prevMarks[i2].removeFromSet(added);
  for (let i2 = 0; i2 < curMarks.length; i2++)
    removed = curMarks[i2].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node3) => node3.mark(mark.addToSet(node3.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node3) => node3.mark(mark.removeFromSet(node3.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i2 = 0; i2 < prev.childCount; i2++)
    updated.push(update(prev.child(i2)));
  if (Fragment2.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start2, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start2);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start2 + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    let move2 = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move2;
    if (start2 && start2 < b.size && isSurrogatePair(b.textBetween(start2 - 1, start2 + 1)))
      start2 += move2 ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move2 = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move2;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += move2 ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name2 in prev)
        this._props[name2] = prev[name2];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name2 in this._props)
      updated[name2] = this._props[name2];
    updated.state = this.state;
    for (let name2 in props)
      updated[name2] = props[name2];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state2) {
    this.updateStateInner(state2, this._props);
  }
  updateStateInner(state2, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state2.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state2;
    let pluginsChanged = prev.plugins != state2.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state2.plugins && !prev.doc.eq(state2.doc) ? "reset" : state2.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state2.doc, outerDeco, innerDeco);
    if (updateDoc || !state2.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state2.selection.empty && selectionContextChanged(prev.selection, state2.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state2.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state2.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state2.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state2.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
        let plugin4 = this.directPlugins[i2];
        if (plugin4.spec.view)
          this.pluginViews.push(plugin4.spec.view(this));
      }
      for (let i2 = 0; i2 < this.state.plugins.length; i2++) {
        let plugin4 = this.state.plugins[i2];
        if (plugin4.spec.view)
          this.pluginViews.push(plugin4.spec.view(this));
      }
    } else {
      for (let i2 = 0; i2 < this.pluginViews.length; i2++) {
        let pluginView = this.pluginViews[i2];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
      let prop2 = this.directPlugins[i2].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i2 = 0; i2 < plugins.length; i2++) {
        let prop2 = plugins[i2].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node3 = this.root.activeElement;
      if (node3 == this.dom)
        return true;
      if (!node3 || !this.dom.contains(node3))
        return false;
      while (node3 && this.dom != node3 && this.dom.contains(node3)) {
        if (node3.contentEditable == "false")
          return false;
        node3 = node3.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search2 = this.dom.parentNode; search2; search2 = search2.parentNode) {
        if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
          if (!search2.getSelection)
            Object.getPrototypeOf(search2).getSelection = () => search2.ownerDocument.getSelection();
          return this._root = search2;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node3, offset5, bias = -1) {
    let pos = this.docView.posFromDOM(node3, offset5, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state2) {
    return endOfTextblock(this, state2 || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html2, event) {
    return doPaste(this, "", html2, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text7, event) {
    return doPaste(this, text7, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr2) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr2);
    else
      this.updateState(this.state.apply(tr2));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add2(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add2);
  view.someProp("markViews", add2);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin4) {
  if (plugin4.spec.state || plugin4.spec.filterTransaction || plugin4.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// node_modules/lib0/diff.js
var highSurrogateRegex = /[\uD800-\uDBFF]/;
var lowSurrogateRegex = /[\uDC00-\uDFFF]/;
var simpleDiffString = (a, b) => {
  let left = 0;
  let right = 0;
  while (left < a.length && left < b.length && a[left] === b[left]) {
    left++;
  }
  if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--;
  while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {
    right++;
  }
  if (right > 0 && lowSurrogateRegex.test(a[a.length - right])) right--;
  return {
    index: left,
    remove: a.length - left - right,
    insert: b.slice(left, b.length - right)
  };
};
var simpleDiff = simpleDiffString;

// node_modules/y-prosemirror/src/plugins/keys.js
var ySyncPluginKey = new PluginKey("y-sync");
var yUndoPluginKey = new PluginKey("y-undo");
var yCursorPluginKey = new PluginKey("yjs-cursor");

// node_modules/y-prosemirror/src/plugins/sync-plugin.js
var isVisible = (item2, snapshot2) => snapshot2 === void 0 ? !item2.deleted : snapshot2.sv.has(item2.id.client) && /** @type {number} */
snapshot2.sv.get(item2.id.client) > item2.id.clock && !isDeleted(snapshot2.ds, item2.id);
var defaultColors = [{ light: "#ecd44433", dark: "#ecd444" }];
var getUserColor = (colorMapping, colors, user) => {
  if (!colorMapping.has(user)) {
    if (colorMapping.size < colors.length) {
      const usedColors = create();
      colorMapping.forEach((color3) => usedColors.add(color3));
      colors = colors.filter((color3) => !usedColors.has(color3));
    }
    colorMapping.set(user, oneOf(colors));
  }
  return (
    /** @type {ColorDef} */
    colorMapping.get(user)
  );
};
var ySyncPlugin = (yXmlFragment, {
  colors = defaultColors,
  colorMapping = /* @__PURE__ */ new Map(),
  permanentUserData = null,
  onFirstRender = () => {
  }
} = {}) => {
  let changedInitialContent = false;
  let rerenderTimeout;
  const plugin4 = new Plugin({
    props: {
      editable: (state2) => {
        const syncState = ySyncPluginKey.getState(state2);
        return syncState.snapshot == null && syncState.prevSnapshot == null;
      }
    },
    key: ySyncPluginKey,
    state: {
      /**
       * @returns {any}
       */
      init: (_initargs, _state2) => {
        return {
          type: yXmlFragment,
          doc: yXmlFragment.doc,
          binding: null,
          snapshot: null,
          prevSnapshot: null,
          isChangeOrigin: false,
          isUndoRedoOperation: false,
          addToHistory: true,
          colors,
          colorMapping,
          permanentUserData
        };
      },
      apply: (tr2, pluginState) => {
        const change = tr2.getMeta(ySyncPluginKey);
        if (change !== void 0) {
          pluginState = Object.assign({}, pluginState);
          for (const key3 in change) {
            pluginState[key3] = change[key3];
          }
        }
        pluginState.addToHistory = tr2.getMeta("addToHistory") !== false;
        pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;
        pluginState.isUndoRedoOperation = change !== void 0 && !!change.isChangeOrigin && !!change.isUndoRedoOperation;
        if (pluginState.binding !== null) {
          if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {
            timeout(0, () => {
              if (pluginState.binding == null || pluginState.binding.isDestroyed) {
                return;
              }
              if (change.restore == null) {
                pluginState.binding._renderSnapshot(
                  change.snapshot,
                  change.prevSnapshot,
                  pluginState
                );
              } else {
                pluginState.binding._renderSnapshot(
                  change.snapshot,
                  change.snapshot,
                  pluginState
                );
                delete pluginState.restore;
                delete pluginState.snapshot;
                delete pluginState.prevSnapshot;
                pluginState.binding.mux(() => {
                  pluginState.binding._prosemirrorChanged(
                    pluginState.binding.prosemirrorView.state.doc
                  );
                });
              }
            });
          }
        }
        return pluginState;
      }
    },
    view: (view) => {
      const binding = new ProsemirrorBinding(yXmlFragment, view);
      if (rerenderTimeout != null) {
        rerenderTimeout.destroy();
      }
      rerenderTimeout = timeout(0, () => {
        binding._forceRerender();
        view.dispatch(view.state.tr.setMeta(ySyncPluginKey, { binding }));
        onFirstRender();
      });
      return {
        update: () => {
          const pluginState = plugin4.getState(view.state);
          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {
            if (changedInitialContent || view.state.doc.content.findDiffStart(
              view.state.doc.type.createAndFill().content
            ) !== null) {
              changedInitialContent = true;
              if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {
                const yUndoPluginState = yUndoPluginKey.getState(view.state);
                const um = yUndoPluginState && yUndoPluginState.undoManager;
                if (um) {
                  um.stopCapturing();
                }
              }
              binding.mux(() => {
                pluginState.doc.transact((tr2) => {
                  tr2.meta.set("addToHistory", pluginState.addToHistory);
                  binding._prosemirrorChanged(view.state.doc);
                }, ySyncPluginKey);
              });
            }
          }
        },
        destroy: () => {
          rerenderTimeout.destroy();
          binding.destroy();
        }
      };
    }
  });
  return plugin4;
};
var restoreRelativeSelection = (tr2, relSel, binding) => {
  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {
    const anchor = relativePositionToAbsolutePosition(
      binding.doc,
      binding.type,
      relSel.anchor,
      binding.mapping
    );
    const head = relativePositionToAbsolutePosition(
      binding.doc,
      binding.type,
      relSel.head,
      binding.mapping
    );
    if (anchor !== null && head !== null) {
      tr2 = tr2.setSelection(TextSelection.create(tr2.doc, anchor, head));
    }
  }
};
var getRelativeSelection = (pmbinding, state2) => ({
  anchor: absolutePositionToRelativePosition(
    state2.selection.anchor,
    pmbinding.type,
    pmbinding.mapping
  ),
  head: absolutePositionToRelativePosition(
    state2.selection.head,
    pmbinding.type,
    pmbinding.mapping
  )
});
var ProsemirrorBinding = class {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {any} prosemirrorView The target binding
   */
  constructor(yXmlFragment, prosemirrorView) {
    this.type = yXmlFragment;
    this.prosemirrorView = prosemirrorView;
    this.mux = createMutex();
    this.isDestroyed = false;
    this.mapping = /* @__PURE__ */ new Map();
    this._observeFunction = this._typeChanged.bind(this);
    this.doc = yXmlFragment.doc;
    this.beforeTransactionSelection = null;
    this.beforeAllTransactions = () => {
      if (this.beforeTransactionSelection === null) {
        this.beforeTransactionSelection = getRelativeSelection(
          this,
          prosemirrorView.state
        );
      }
    };
    this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    };
    this.doc.on("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.on("afterAllTransactions", this.afterAllTransactions);
    yXmlFragment.observeDeep(this._observeFunction);
    this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
  }
  _isLocalCursorInView() {
    if (!this.prosemirrorView.hasFocus()) return false;
    if (isBrowser && this._domSelectionInView === null) {
      timeout(0, () => {
        this._domSelectionInView = null;
      });
      this._domSelectionInView = this._isDomSelectionInView();
    }
    return this._domSelectionInView;
  }
  _isDomSelectionInView() {
    const selection = this.prosemirrorView._root.getSelection();
    const range = this.prosemirrorView._root.createRange();
    range.setStart(selection.anchorNode, selection.anchorOffset);
    range.setEnd(selection.focusNode, selection.focusOffset);
    const rects = range.getClientRects();
    if (rects.length === 0) {
      if (range.startContainer && range.collapsed) {
        range.selectNodeContents(range.startContainer);
      }
    }
    const bounding = range.getBoundingClientRect();
    const documentElement = doc.documentElement;
    return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   */
  renderSnapshot(snapshot2, prevSnapshot) {
    if (!prevSnapshot) {
      prevSnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
    }
    this.prosemirrorView.dispatch(
      this._tr.setMeta(ySyncPluginKey, { snapshot: snapshot2, prevSnapshot })
    );
  }
  unrenderSnapshot() {
    this.mapping = /* @__PURE__ */ new Map();
    this.mux(() => {
      const fragmentContent = this.type.toArray().map(
        (t2) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t2,
          this.prosemirrorView.state.schema,
          this.mapping
        )
      ).filter((n2) => n2 !== null);
      const tr2 = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment2.from(fragmentContent), 0, 0)
      );
      tr2.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });
      this.prosemirrorView.dispatch(tr2);
    });
  }
  _forceRerender() {
    this.mapping = /* @__PURE__ */ new Map();
    this.mux(() => {
      const fragmentContent = this.type.toArray().map(
        (t2) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t2,
          this.prosemirrorView.state.schema,
          this.mapping
        )
      ).filter((n2) => n2 !== null);
      const tr2 = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment2.from(fragmentContent), 0, 0)
      );
      this.prosemirrorView.dispatch(
        tr2.setMeta(ySyncPluginKey, { isChangeOrigin: true })
      );
    });
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(snapshot2, prevSnapshot, pluginState) {
    if (!snapshot2) {
      snapshot2 = snapshot(this.doc);
    }
    this.mapping = /* @__PURE__ */ new Map();
    this.mux(() => {
      this.doc.transact((transaction) => {
        const pud = pluginState.permanentUserData;
        if (pud) {
          pud.dss.forEach((ds) => {
            iterateDeletedStructs(transaction, ds, (_item) => {
            });
          });
        }
        const computeYChange = (type, id) => {
          const user = type === "added" ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);
          return {
            user,
            type,
            color: getUserColor(
              pluginState.colorMapping,
              pluginState.colors,
              user
            )
          };
        };
        const fragmentContent = typeListToArraySnapshot(
          this.type,
          new Snapshot(prevSnapshot.ds, snapshot2.sv)
        ).map((t2) => {
          if (!t2._item.deleted || isVisible(t2._item, snapshot2) || isVisible(t2._item, prevSnapshot)) {
            return createNodeFromYElement(
              t2,
              this.prosemirrorView.state.schema,
              /* @__PURE__ */ new Map(),
              snapshot2,
              prevSnapshot,
              computeYChange
            );
          } else {
            return null;
          }
        }).filter((n2) => n2 !== null);
        const tr2 = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment2.from(fragmentContent), 0, 0)
        );
        this.prosemirrorView.dispatch(
          tr2.setMeta(ySyncPluginKey, { isChangeOrigin: true })
        );
      }, ySyncPluginKey);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(events, transaction) {
    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);
    if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {
      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);
      return;
    }
    this.mux(() => {
      const delType = (_, type) => this.mapping.delete(type);
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        (struct) => {
          if (struct.constructor === Item) {
            const type = (
              /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              struct.content.type
            );
            type && this.mapping.delete(type);
          }
        }
      );
      transaction.changed.forEach(delType);
      transaction.changedParentTypes.forEach(delType);
      const fragmentContent = this.type.toArray().map(
        (t2) => createNodeIfNotExists(
          /** @type {Y.XmlElement | Y.XmlHook} */
          t2,
          this.prosemirrorView.state.schema,
          this.mapping
        )
      ).filter((n2) => n2 !== null);
      let tr2 = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment2.from(fragmentContent), 0, 0)
      );
      restoreRelativeSelection(tr2, this.beforeTransactionSelection, this);
      tr2 = tr2.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof UndoManager });
      if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {
        tr2.scrollIntoView();
      }
      this.prosemirrorView.dispatch(tr2);
    });
  }
  _prosemirrorChanged(doc4) {
    this.doc.transact(() => {
      updateYFragment(this.doc, this.type, doc4, this.mapping);
      this.beforeTransactionSelection = getRelativeSelection(
        this,
        this.prosemirrorView.state
      );
    }, ySyncPluginKey);
  }
  destroy() {
    this.isDestroyed = true;
    this.type.unobserveDeep(this._observeFunction);
    this.doc.off("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.off("afterAllTransactions", this.afterAllTransactions);
  }
};
var createNodeIfNotExists = (el, schema, mapping, snapshot2, prevSnapshot, computeYChange) => {
  const node3 = (
    /** @type {PModel.Node} */
    mapping.get(el)
  );
  if (node3 === void 0) {
    if (el instanceof YXmlElement) {
      return createNodeFromYElement(
        el,
        schema,
        mapping,
        snapshot2,
        prevSnapshot,
        computeYChange
      );
    } else {
      throw methodUnimplemented();
    }
  }
  return node3;
};
var createNodeFromYElement = (el, schema, mapping, snapshot2, prevSnapshot, computeYChange) => {
  const children = [];
  const createChildren = (type) => {
    if (type.constructor === YXmlElement) {
      const n2 = createNodeIfNotExists(
        type,
        schema,
        mapping,
        snapshot2,
        prevSnapshot,
        computeYChange
      );
      if (n2 !== null) {
        children.push(n2);
      }
    } else {
      const ns = createTextNodesFromYText(
        type,
        schema,
        mapping,
        snapshot2,
        prevSnapshot,
        computeYChange
      );
      if (ns !== null) {
        ns.forEach((textchild) => {
          if (textchild !== null) {
            children.push(textchild);
          }
        });
      }
    }
  };
  if (snapshot2 === void 0 || prevSnapshot === void 0) {
    el.toArray().forEach(createChildren);
  } else {
    typeListToArraySnapshot(el, new Snapshot(prevSnapshot.ds, snapshot2.sv)).forEach(createChildren);
  }
  try {
    const attrs = el.getAttributes(snapshot2);
    if (snapshot2 !== void 0) {
      if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        snapshot2
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "removed",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "removed" };
      } else if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        prevSnapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "added",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "added" };
      }
    }
    const node3 = schema.node(el.nodeName, attrs, children);
    mapping.set(el, node3);
    return node3;
  } catch (e3) {
    el.doc.transact((transaction) => {
      el._item.delete(transaction);
    }, ySyncPluginKey);
    mapping.delete(el);
    return null;
  }
};
var createTextNodesFromYText = (text7, schema, _mapping, snapshot2, prevSnapshot, computeYChange) => {
  const nodes = [];
  const deltas = text7.toDelta(snapshot2, prevSnapshot, computeYChange);
  try {
    for (let i2 = 0; i2 < deltas.length; i2++) {
      const delta = deltas[i2];
      const marks = [];
      for (const markName in delta.attributes) {
        marks.push(schema.mark(markName, delta.attributes[markName]));
      }
      nodes.push(schema.text(delta.insert, marks));
    }
  } catch (e3) {
    text7.doc.transact((transaction) => {
      text7._item.delete(transaction);
    }, ySyncPluginKey);
    return null;
  }
  return nodes;
};
var createTypeFromTextNodes = (nodes, mapping) => {
  const type = new YXmlText();
  const delta = nodes.map((node3) => ({
    // @ts-ignore
    insert: node3.text,
    attributes: marksToAttributes(node3.marks)
  }));
  type.applyDelta(delta);
  mapping.set(type, nodes);
  return type;
};
var createTypeFromElementNode = (node3, mapping) => {
  const type = new YXmlElement(node3.type.name);
  for (const key3 in node3.attrs) {
    const val = node3.attrs[key3];
    if (val !== null && key3 !== "ychange") {
      type.setAttribute(key3, val);
    }
  }
  type.insert(
    0,
    normalizePNodeContent(node3).map(
      (n2) => createTypeFromTextOrElementNode(n2, mapping)
    )
  );
  mapping.set(type, node3);
  return type;
};
var createTypeFromTextOrElementNode = (node3, mapping) => node3 instanceof Array ? createTypeFromTextNodes(node3, mapping) : createTypeFromElementNode(node3, mapping);
var isObject = (val) => typeof val === "object" && val !== null;
var equalAttrs = (pattrs, yattrs) => {
  const keys3 = Object.keys(pattrs).filter((key3) => pattrs[key3] !== null);
  let eq = keys3.length === Object.keys(yattrs).filter((key3) => yattrs[key3] !== null).length;
  for (let i2 = 0; i2 < keys3.length && eq; i2++) {
    const key3 = keys3[i2];
    const l2 = pattrs[key3];
    const r2 = yattrs[key3];
    eq = key3 === "ychange" || l2 === r2 || isObject(l2) && isObject(r2) && equalAttrs(l2, r2);
  }
  return eq;
};
var normalizePNodeContent = (pnode) => {
  const c = pnode.content.content;
  const res = [];
  for (let i2 = 0; i2 < c.length; i2++) {
    const n2 = c[i2];
    if (n2.isText) {
      const textNodes = [];
      for (let tnode = c[i2]; i2 < c.length && tnode.isText; tnode = c[++i2]) {
        textNodes.push(tnode);
      }
      i2--;
      res.push(textNodes);
    } else {
      res.push(n2);
    }
  }
  return res;
};
var equalYTextPText = (ytext, ptexts) => {
  const delta = ytext.toDelta();
  return delta.length === ptexts.length && delta.every(
    (d, i2) => d.insert === /** @type {any} */
    ptexts[i2].text && keys(d.attributes || {}).length === ptexts[i2].marks.length && ptexts[i2].marks.every(
      (mark) => equalAttrs(d.attributes[mark.type.name] || {}, mark.attrs)
    )
  );
};
var equalYTypePNode = (ytype, pnode) => {
  if (ytype instanceof YXmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {
    const normalizedContent = normalizePNodeContent(pnode);
    return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every(
      (ychild, i2) => equalYTypePNode(ychild, normalizedContent[i2])
    );
  }
  return ytype instanceof YXmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);
};
var mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every(
  (a, i2) => pcontent[i2] === a
);
var computeChildEqualityFactor = (ytype, pnode, mapping) => {
  const yChildren = ytype.toArray();
  const pChildren = normalizePNodeContent(pnode);
  const pChildCnt = pChildren.length;
  const yChildCnt = yChildren.length;
  const minCnt = min(yChildCnt, pChildCnt);
  let left = 0;
  let right = 0;
  let foundMappedChild = false;
  for (; left < minCnt; left++) {
    const leftY = yChildren[left];
    const leftP = pChildren[left];
    if (mappedIdentity(mapping.get(leftY), leftP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(leftY, leftP)) {
      break;
    }
  }
  for (; left + right < minCnt; right++) {
    const rightY = yChildren[yChildCnt - right - 1];
    const rightP = pChildren[pChildCnt - right - 1];
    if (mappedIdentity(mapping.get(rightY), rightP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(rightY, rightP)) {
      break;
    }
  }
  return {
    equalityFactor: left + right,
    foundMappedChild
  };
};
var ytextTrans = (ytext) => {
  let str = "";
  let n2 = ytext._start;
  const nAttrs = {};
  while (n2 !== null) {
    if (!n2.deleted) {
      if (n2.countable && n2.content instanceof ContentString) {
        str += n2.content.str;
      } else if (n2.content instanceof ContentFormat) {
        nAttrs[n2.content.key] = null;
      }
    }
    n2 = n2.right;
  }
  return {
    str,
    nAttrs
  };
};
var updateYText = (ytext, ptexts, mapping) => {
  mapping.set(ytext, ptexts);
  const { nAttrs, str } = ytextTrans(ytext);
  const content3 = ptexts.map((p) => ({
    insert: (
      /** @type {any} */
      p.text
    ),
    attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks))
  }));
  const { insert, remove, index: index4 } = simpleDiff(
    str,
    content3.map((c) => c.insert).join("")
  );
  ytext.delete(index4, remove);
  ytext.insert(index4, insert);
  ytext.applyDelta(
    content3.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))
  );
};
var marksToAttributes = (marks) => {
  const pattrs = {};
  marks.forEach((mark) => {
    if (mark.type.name !== "ychange") {
      pattrs[mark.type.name] = mark.attrs;
    }
  });
  return pattrs;
};
var updateYFragment = (y, yDomFragment, pNode, mapping) => {
  if (yDomFragment instanceof YXmlElement && yDomFragment.nodeName !== pNode.type.name) {
    throw new Error("node name mismatch!");
  }
  mapping.set(yDomFragment, pNode);
  if (yDomFragment instanceof YXmlElement) {
    const yDomAttrs = yDomFragment.getAttributes();
    const pAttrs = pNode.attrs;
    for (const key3 in pAttrs) {
      if (pAttrs[key3] !== null) {
        if (yDomAttrs[key3] !== pAttrs[key3] && key3 !== "ychange") {
          yDomFragment.setAttribute(key3, pAttrs[key3]);
        }
      } else {
        yDomFragment.removeAttribute(key3);
      }
    }
    for (const key3 in yDomAttrs) {
      if (pAttrs[key3] === void 0) {
        yDomFragment.removeAttribute(key3);
      }
    }
  }
  const pChildren = normalizePNodeContent(pNode);
  const pChildCnt = pChildren.length;
  const yChildren = yDomFragment.toArray();
  const yChildCnt = yChildren.length;
  const minCnt = min(pChildCnt, yChildCnt);
  let left = 0;
  let right = 0;
  for (; left < minCnt; left++) {
    const leftY = yChildren[left];
    const leftP = pChildren[left];
    if (!mappedIdentity(mapping.get(leftY), leftP)) {
      if (equalYTypePNode(leftY, leftP)) {
        mapping.set(leftY, leftP);
      } else {
        break;
      }
    }
  }
  for (; right + left + 1 < minCnt; right++) {
    const rightY = yChildren[yChildCnt - right - 1];
    const rightP = pChildren[pChildCnt - right - 1];
    if (!mappedIdentity(mapping.get(rightY), rightP)) {
      if (equalYTypePNode(rightY, rightP)) {
        mapping.set(rightY, rightP);
      } else {
        break;
      }
    }
  }
  y.transact(() => {
    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {
      const leftY = yChildren[left];
      const leftP = pChildren[left];
      const rightY = yChildren[yChildCnt - right - 1];
      const rightP = pChildren[pChildCnt - right - 1];
      if (leftY instanceof YXmlText && leftP instanceof Array) {
        if (!equalYTextPText(leftY, leftP)) {
          updateYText(leftY, leftP, mapping);
        }
        left += 1;
      } else {
        let updateLeft = leftY instanceof YXmlElement && matchNodeName(leftY, leftP);
        let updateRight = rightY instanceof YXmlElement && matchNodeName(rightY, rightP);
        if (updateLeft && updateRight) {
          const equalityLeft = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            mapping
          );
          const equalityRight = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            mapping
          );
          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {
            updateRight = false;
          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {
            updateLeft = false;
          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {
            updateLeft = false;
          } else {
            updateRight = false;
          }
        }
        if (updateLeft) {
          updateYFragment(
            y,
            /** @type {Y.XmlFragment} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            mapping
          );
          left += 1;
        } else if (updateRight) {
          updateYFragment(
            y,
            /** @type {Y.XmlFragment} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            mapping
          );
          right += 1;
        } else {
          mapping.delete(yDomFragment.get(left));
          yDomFragment.delete(left, 1);
          yDomFragment.insert(left, [
            createTypeFromTextOrElementNode(leftP, mapping)
          ]);
          left += 1;
        }
      }
    }
    const yDelLen = yChildCnt - left - right;
    if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof YXmlText) {
      mapping.delete(yChildren[0]);
      yChildren[0].delete(0, yChildren[0].length);
    } else if (yDelLen > 0) {
      yDomFragment.slice(left, left + yDelLen).forEach((type) => mapping.delete(type));
      yDomFragment.delete(left, yDelLen);
    }
    if (left + right < pChildCnt) {
      const ins = [];
      for (let i2 = left; i2 < pChildCnt - right; i2++) {
        ins.push(createTypeFromTextOrElementNode(pChildren[i2], mapping));
      }
      yDomFragment.insert(left, ins);
    }
  }, ySyncPluginKey);
};
var matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;

// node_modules/y-prosemirror/src/lib.js
var viewsToUpdate = null;
var updateMetas = () => {
  const ups = (
    /** @type {Map<EditorView, Map<any, any>>} */
    viewsToUpdate
  );
  viewsToUpdate = null;
  ups.forEach((metas, view) => {
    const tr2 = view.state.tr;
    const syncState = ySyncPluginKey.getState(view.state);
    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {
      metas.forEach((val, key3) => {
        tr2.setMeta(key3, val);
      });
      view.dispatch(tr2);
    }
  });
};
var setMeta = (view, key3, value) => {
  if (!viewsToUpdate) {
    viewsToUpdate = /* @__PURE__ */ new Map();
    timeout(0, updateMetas);
  }
  setIfUndefined(viewsToUpdate, view, create2).set(key3, value);
};
var absolutePositionToRelativePosition = (pos, type, mapping) => {
  if (pos === 0) {
    return createRelativePositionFromTypeIndex(type, 0);
  }
  let n2 = type._first === null ? null : (
    /** @type {Y.ContentType} */
    type._first.content.type
  );
  while (n2 !== null && type !== n2) {
    if (n2 instanceof YXmlText) {
      if (n2._length >= pos) {
        return createRelativePositionFromTypeIndex(n2, pos);
      } else {
        pos -= n2._length;
      }
      if (n2._item !== null && n2._item.next !== null) {
        n2 = /** @type {Y.ContentType} */
        n2._item.next.content.type;
      } else {
        do {
          n2 = n2._item === null ? null : n2._item.parent;
          pos--;
        } while (n2 !== type && n2 !== null && n2._item !== null && n2._item.next === null);
        if (n2 !== null && n2 !== type) {
          n2 = n2._item === null ? null : (
            /** @type {Y.ContentType} */
            /** @type Y.Item */
            n2._item.next.content.type
          );
        }
      }
    } else {
      const pNodeSize = (
        /** @type {any} */
        (mapping.get(n2) || { nodeSize: 0 }).nodeSize
      );
      if (n2._first !== null && pos < pNodeSize) {
        n2 = /** @type {Y.ContentType} */
        n2._first.content.type;
        pos--;
      } else {
        if (pos === 1 && n2._length === 0 && pNodeSize > 1) {
          return new RelativePosition(n2._item === null ? null : n2._item.id, n2._item === null ? findRootTypeKey(n2) : null, null);
        }
        pos -= pNodeSize;
        if (n2._item !== null && n2._item.next !== null) {
          n2 = /** @type {Y.ContentType} */
          n2._item.next.content.type;
        } else {
          if (pos === 0) {
            n2 = n2._item === null ? n2 : n2._item.parent;
            return new RelativePosition(n2._item === null ? null : n2._item.id, n2._item === null ? findRootTypeKey(n2) : null, null);
          }
          do {
            n2 = /** @type {Y.Item} */
            n2._item.parent;
            pos--;
          } while (n2 !== type && /** @type {Y.Item} */
          n2._item.next === null);
          if (n2 !== type) {
            n2 = /** @type {Y.ContentType} */
            /** @type {Y.Item} */
            /** @type {Y.Item} */
            n2._item.next.content.type;
          }
        }
      }
    }
    if (n2 === null) {
      throw unexpectedCase();
    }
    if (pos === 0 && n2.constructor !== YXmlText && n2 !== type) {
      return createRelativePosition(n2._item.parent, n2._item);
    }
  }
  return createRelativePositionFromTypeIndex(type, type._length);
};
var createRelativePosition = (type, item2) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item2.id);
};
var relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {
  const decodedPos = createAbsolutePositionFromRelativePosition(relPos, y);
  if (decodedPos === null || decodedPos.type !== documentType && !isParentOf(documentType, decodedPos.type._item)) {
    return null;
  }
  let type = decodedPos.type;
  let pos = 0;
  if (type.constructor === YXmlText) {
    pos = decodedPos.index;
  } else if (type._item === null || !type._item.deleted) {
    let n2 = type._first;
    let i2 = 0;
    while (i2 < type._length && i2 < decodedPos.index && n2 !== null) {
      if (!n2.deleted) {
        const t2 = (
          /** @type {Y.ContentType} */
          n2.content.type
        );
        i2++;
        if (t2 instanceof YXmlText) {
          pos += t2._length;
        } else {
          pos += /** @type {any} */
          mapping.get(t2).nodeSize;
        }
      }
      n2 = /** @type {Y.Item} */
      n2.right;
    }
    pos += 1;
  }
  while (type !== documentType && type._item !== null) {
    const parent = type._item.parent;
    if (parent._item === null || !parent._item.deleted) {
      pos += 1;
      let n2 = (
        /** @type {Y.AbstractType} */
        parent._first
      );
      while (n2 !== null) {
        const contentType = (
          /** @type {Y.ContentType} */
          n2.content.type
        );
        if (contentType === type) {
          break;
        }
        if (!n2.deleted) {
          if (contentType instanceof YXmlText) {
            pos += contentType._length;
          } else {
            pos += /** @type {any} */
            mapping.get(contentType).nodeSize;
          }
        }
        n2 = n2.right;
      }
    }
    type = /** @type {Y.AbstractType} */
    parent;
  }
  return pos - 1;
};
function prosemirrorToYXmlFragment(doc4, xmlFragment) {
  const type = xmlFragment || new YXmlFragment();
  const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(void 0) };
  updateYFragment(ydoc, type, doc4, /* @__PURE__ */ new Map());
  return type;
}
function yXmlFragmentToProsemirror(schema, xmlFragment) {
  const state2 = yXmlFragmentToProsemirrorJSON(xmlFragment);
  return Node4.fromJSON(schema, state2);
}
function yXmlFragmentToProsemirrorJSON(xmlFragment) {
  const items = xmlFragment.toArray();
  function serialize2(item2) {
    let response;
    if (!item2.nodeName) {
      const delta = item2.toDelta();
      response = delta.map((d) => {
        const text7 = {
          type: "text",
          text: d.insert
        };
        if (d.attributes) {
          text7.marks = Object.keys(d.attributes).map((type) => {
            const attrs = d.attributes[type];
            const mark = {
              type
            };
            if (Object.keys(attrs)) {
              mark.attrs = attrs;
            }
            return mark;
          });
        }
        return text7;
      });
    } else {
      response = {
        type: item2.nodeName
      };
      const attrs = item2.getAttributes();
      if (Object.keys(attrs).length) {
        response.attrs = attrs;
      }
      const children = item2.toArray();
      if (children.length) {
        response.content = children.map(serialize2).flat();
      }
    }
    return response;
  }
  return {
    type: "doc",
    content: items.map(serialize2)
  };
}

// node_modules/y-prosemirror/src/plugins/cursor-plugin.js
var defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId;
var defaultCursorBuilder = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name), null);
  const nonbreakingSpace1 = document.createTextNode("⁠");
  const nonbreakingSpace2 = document.createTextNode("⁠");
  cursor.insertBefore(nonbreakingSpace1, null);
  cursor.insertBefore(userDiv, null);
  cursor.insertBefore(nonbreakingSpace2, null);
  return cursor;
};
var defaultSelectionBuilder = (user) => {
  return {
    style: `background-color: ${user.color}70`,
    class: "ProseMirror-yjs-selection"
  };
};
var rxValidColor = /^#[0-9a-fA-F]{6}$/;
var createDecorations = (state2, awareness, awarenessFilter, createCursor, createSelection) => {
  const ystate = ySyncPluginKey.getState(state2);
  const y = ystate.doc;
  const decorations = [];
  if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding === null) {
    return DecorationSet.create(state2.doc, []);
  }
  awareness.getStates().forEach((aw, clientId) => {
    if (!awarenessFilter(y.clientID, clientId, aw)) {
      return;
    }
    if (aw.cursor != null) {
      const user = aw.user || {};
      if (user.color == null) {
        user.color = "#ffa500";
      } else if (!rxValidColor.test(user.color)) {
        console.warn("A user uses an unsupported color format", user);
      }
      if (user.name == null) {
        user.name = `User: ${clientId}`;
      }
      let anchor = relativePositionToAbsolutePosition(
        y,
        ystate.type,
        createRelativePositionFromJSON(aw.cursor.anchor),
        ystate.binding.mapping
      );
      let head = relativePositionToAbsolutePosition(
        y,
        ystate.type,
        createRelativePositionFromJSON(aw.cursor.head),
        ystate.binding.mapping
      );
      if (anchor !== null && head !== null) {
        const maxsize = max(state2.doc.content.size - 1, 0);
        anchor = min(anchor, maxsize);
        head = min(head, maxsize);
        decorations.push(
          Decoration.widget(head, () => createCursor(user), {
            key: clientId + "",
            side: 10
          })
        );
        const from2 = min(anchor, head);
        const to = max(anchor, head);
        decorations.push(
          Decoration.inline(from2, to, createSelection(user), {
            inclusiveEnd: true,
            inclusiveStart: false
          })
        );
      }
    }
  });
  return DecorationSet.create(state2.doc, decorations);
};
var yCursorPlugin = (awareness, {
  awarenessStateFilter = defaultAwarenessStateFilter,
  cursorBuilder: cursorBuilder2 = defaultCursorBuilder,
  selectionBuilder = defaultSelectionBuilder,
  getSelection: getSelection2 = (state2) => state2.selection
} = {}, cursorStateField = "cursor") => new Plugin({
  key: yCursorPluginKey,
  state: {
    init(_, state2) {
      return createDecorations(
        state2,
        awareness,
        awarenessStateFilter,
        cursorBuilder2,
        selectionBuilder
      );
    },
    apply(tr2, prevState, _oldState, newState) {
      const ystate = ySyncPluginKey.getState(newState);
      const yCursorState = tr2.getMeta(yCursorPluginKey);
      if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {
        return createDecorations(
          newState,
          awareness,
          awarenessStateFilter,
          cursorBuilder2,
          selectionBuilder
        );
      }
      return prevState.map(tr2.mapping, tr2.doc);
    }
  },
  props: {
    decorations: (state2) => {
      return yCursorPluginKey.getState(state2);
    }
  },
  view: (view) => {
    const awarenessListener = () => {
      if (view.docView) {
        setMeta(view, yCursorPluginKey, { awarenessUpdated: true });
      }
    };
    const updateCursorInfo = () => {
      const ystate = ySyncPluginKey.getState(view.state);
      const current2 = awareness.getLocalState() || {};
      if (ystate.binding == null) {
        return;
      }
      if (view.hasFocus()) {
        const selection = getSelection2(view.state);
        const anchor = absolutePositionToRelativePosition(
          selection.anchor,
          ystate.type,
          ystate.binding.mapping
        );
        const head = absolutePositionToRelativePosition(
          selection.head,
          ystate.type,
          ystate.binding.mapping
        );
        if (current2.cursor == null || !compareRelativePositions(
          createRelativePositionFromJSON(current2.cursor.anchor),
          anchor
        ) || !compareRelativePositions(
          createRelativePositionFromJSON(current2.cursor.head),
          head
        )) {
          awareness.setLocalStateField(cursorStateField, {
            anchor,
            head
          });
        }
      } else if (current2.cursor != null && relativePositionToAbsolutePosition(
        ystate.doc,
        ystate.type,
        createRelativePositionFromJSON(current2.cursor.anchor),
        ystate.binding.mapping
      ) !== null) {
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
    awareness.on("change", awarenessListener);
    view.dom.addEventListener("focusin", updateCursorInfo);
    view.dom.addEventListener("focusout", updateCursorInfo);
    return {
      update: updateCursorInfo,
      destroy: () => {
        view.dom.removeEventListener("focusin", updateCursorInfo);
        view.dom.removeEventListener("focusout", updateCursorInfo);
        awareness.off("change", awarenessListener);
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
  }
});

// node_modules/y-prosemirror/src/plugins/undo-plugin.js
var undo = (state2) => {
  const undoManager = yUndoPluginKey.getState(state2).undoManager;
  if (undoManager != null) {
    undoManager.undo();
    return true;
  }
};
var redo = (state2) => {
  const undoManager = yUndoPluginKey.getState(state2).undoManager;
  if (undoManager != null) {
    undoManager.redo();
    return true;
  }
};
var defaultProtectedNodes = /* @__PURE__ */ new Set(["paragraph"]);
var defaultDeleteFilter = (item2, protectedNodes) => !(item2 instanceof Item) || !(item2.content instanceof ContentType) || !(item2.content.type instanceof YText || item2.content.type instanceof YXmlElement && protectedNodes.has(item2.content.type.nodeName)) || item2.content.type._length === 0;
var yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({
  key: yUndoPluginKey,
  state: {
    init: (initargs, state2) => {
      const ystate = ySyncPluginKey.getState(state2);
      const _undoManager = undoManager || new UndoManager(ystate.type, {
        trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),
        deleteFilter: (item2) => defaultDeleteFilter(item2, protectedNodes),
        captureTransaction: (tr2) => tr2.meta.get("addToHistory") !== false
      });
      return {
        undoManager: _undoManager,
        prevSel: null,
        hasUndoOps: _undoManager.undoStack.length > 0,
        hasRedoOps: _undoManager.redoStack.length > 0
      };
    },
    /**
     * @returns {any}
     */
    apply: (tr2, val, oldState, state2) => {
      const binding = ySyncPluginKey.getState(state2).binding;
      const undoManager2 = val.undoManager;
      const hasUndoOps = undoManager2.undoStack.length > 0;
      const hasRedoOps = undoManager2.redoStack.length > 0;
      if (binding) {
        return {
          undoManager: undoManager2,
          prevSel: getRelativeSelection(binding, oldState),
          hasUndoOps,
          hasRedoOps
        };
      } else {
        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {
          return Object.assign({}, val, {
            hasUndoOps: undoManager2.undoStack.length > 0,
            hasRedoOps: undoManager2.redoStack.length > 0
          });
        } else {
          return val;
        }
      }
    }
  },
  view: (view) => {
    const ystate = ySyncPluginKey.getState(view.state);
    const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;
    undoManager2.on("stack-item-added", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);
      }
    });
    undoManager2.on("stack-item-popped", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;
      }
    });
    return {
      destroy: () => {
        undoManager2.destroy();
      }
    };
  }
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-sheetIcon.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime());
var sheetIcon = (0, import_jsx_runtime69.jsxs)(import_jsx_runtime69.Fragment, {
  children: [(0, import_jsx_runtime69.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime69.jsx)("path", {
    d: "M3 9h18M3 15h18M9 9v12M15 9v12"
  })]
});

// node_modules/compute-scroll-into-view/dist/index.js
var t = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
var e = (t2, e3) => (!e3 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2);
var n = (t2, n2) => {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    const o3 = getComputedStyle(t2, null);
    return e(o3.overflowY, n2) || e(o3.overflowX, n2) || ((t3) => {
      const e3 = ((t4) => {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      })(t3);
      return !!e3 && (e3.clientHeight < t3.scrollHeight || e3.clientWidth < t3.scrollWidth);
    })(t2);
  }
  return false;
};
var o = (t2, e3, n2, o3, l2, r2, i2, s2) => r2 < t2 && i2 > e3 || r2 > t2 && i2 < e3 ? 0 : r2 <= t2 && s2 <= n2 || i2 >= e3 && s2 >= n2 ? r2 - t2 - o3 : i2 > e3 && s2 < n2 || r2 < t2 && s2 > n2 ? i2 - e3 + l2 : 0;
var l = (t2) => {
  const e3 = t2.parentElement;
  return null == e3 ? t2.getRootNode().host || null : e3;
};
var r = (e3, r2) => {
  var i2, s2, d, h;
  if ("undefined" == typeof document) return [];
  const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = "function" == typeof a ? a : (t2) => t2 !== a;
  if (!t(e3)) throw new TypeError("Invalid target");
  const m = document.scrollingElement || document.documentElement, w = [];
  let W = e3;
  for (; t(W) && p(W); ) {
    if (W = l(W), W === m) {
      w.push(W);
      break;
    }
    null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
  }
  const b = null != (s2 = null == (i2 = window.visualViewport) ? void 0 : i2.width) ? s2 : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e3.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {
    const e4 = window.getComputedStyle(t2);
    return { top: parseFloat(e4.scrollMarginTop) || 0, right: parseFloat(e4.scrollMarginRight) || 0, bottom: parseFloat(e4.scrollMarginBottom) || 0, left: parseFloat(e4.scrollMarginLeft) || 0 };
  })(e3);
  let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
  const L = [];
  for (let t2 = 0; t2 < w.length; t2++) {
    const e4 = w[t2], { height: n2, width: l2, top: r3, right: i3, bottom: s3, left: d2 } = e4.getBoundingClientRect();
    if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && x >= r3 && I <= s3 && R >= d2 && C <= i3) return L;
    const h2 = getComputedStyle(e4), a2 = parseInt(h2.borderLeftWidth, 10), g2 = parseInt(h2.borderTopWidth, 10), p2 = parseInt(h2.borderRightWidth, 10), W2 = parseInt(h2.borderBottomWidth, 10);
    let T2 = 0, B2 = 0;
    const F2 = "offsetWidth" in e4 ? e4.offsetWidth - e4.clientWidth - a2 - p2 : 0, V2 = "offsetHeight" in e4 ? e4.offsetHeight - e4.clientHeight - g2 - W2 : 0, S = "offsetWidth" in e4 ? 0 === e4.offsetWidth ? 0 : l2 / e4.offsetWidth : 0, X = "offsetHeight" in e4 ? 0 === e4.offsetHeight ? 0 : n2 / e4.offsetHeight : 0;
    if (m === e4) T2 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, g2, W2, M + k, M + k + v, v) : k - H / 2, B2 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, a2, p2, y + D, y + D + E, E), T2 = Math.max(0, T2 + M), B2 = Math.max(0, B2 + y);
    else {
      T2 = "start" === f ? k - r3 - g2 : "end" === f ? k - s3 + W2 + V2 : "nearest" === f ? o(r3, s3, n2, g2, W2 + V2, k, k + v, v) : k - (r3 + n2 / 2) + V2 / 2, B2 = "start" === u ? D - d2 - a2 : "center" === u ? D - (d2 + l2 / 2) + F2 / 2 : "end" === u ? D - i3 + p2 + F2 : o(d2, i3, l2, a2, p2 + F2, D, D + E, E);
      const { scrollLeft: t3, scrollTop: h3 } = e4;
      T2 = 0 === X ? 0 : Math.max(0, Math.min(h3 + T2 / X, e4.scrollHeight - n2 / X + V2)), B2 = 0 === S ? 0 : Math.max(0, Math.min(t3 + B2 / S, e4.scrollWidth - l2 / S + F2)), k += h3 - T2, D += t3 - B2;
    }
    L.push({ el: e4, top: T2, left: B2 });
  }
  return L;
};

// node_modules/scroll-into-view-if-needed/dist/index.js
var o2 = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
function e2(e3, r2) {
  if (!e3.isConnected || !((t2) => {
    let o3 = t2;
    for (; o3 && o3.parentNode; ) {
      if (o3.parentNode === document) return true;
      o3 = o3.parentNode instanceof ShadowRoot ? o3.parentNode.host : o3.parentNode;
    }
    return false;
  })(e3)) return;
  const n2 = ((t2) => {
    const o3 = window.getComputedStyle(t2);
    return { top: parseFloat(o3.scrollMarginTop) || 0, right: parseFloat(o3.scrollMarginRight) || 0, bottom: parseFloat(o3.scrollMarginBottom) || 0, left: parseFloat(o3.scrollMarginLeft) || 0 };
  })(e3);
  if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r2)) return r2.behavior(r(e3, r2));
  const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
  for (const { el: a, top: i2, left: s2 } of r(e3, o2(r2))) {
    const t2 = i2 - n2.top + n2.bottom, o3 = s2 - n2.left + n2.right;
    a.scroll({ top: t2, left: o3, behavior: l2 });
  }
}

// node_modules/slate-history/dist/index.es.js
var History = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(value) {
    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0].operations));
  }
};
var SAVING = /* @__PURE__ */ new WeakMap();
var MERGING = /* @__PURE__ */ new WeakMap();
var HistoryEditor = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(value) {
    return History.isHistory(value.history) && Editor.isEditor(value);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(editor) {
    return MERGING.get(editor);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(editor) {
    return SAVING.get(editor);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(editor) {
    editor.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(editor) {
    editor.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(editor, fn) {
    var prev = HistoryEditor.isMerging(editor);
    MERGING.set(editor, false);
    fn();
    MERGING.set(editor, prev);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(editor, fn) {
    var prev = HistoryEditor.isSaving(editor);
    SAVING.set(editor, false);
    fn();
    SAVING.set(editor, prev);
  }
};
var withHistory = (editor) => {
  var e3 = editor;
  var {
    apply: apply2
  } = e3;
  e3.history = {
    undos: [],
    redos: []
  };
  e3.redo = () => {
    var {
      history: history2
    } = e3;
    var {
      redos
    } = history2;
    if (redos.length > 0) {
      var batch = redos[redos.length - 1];
      if (batch.selectionBefore) {
        Transforms.setSelection(e3, batch.selectionBefore);
      }
      HistoryEditor.withoutSaving(e3, () => {
        Editor.withoutNormalizing(e3, () => {
          for (var op of batch.operations) {
            e3.apply(op);
          }
        });
      });
      history2.redos.pop();
      history2.undos.push(batch);
    }
  };
  e3.undo = () => {
    var {
      history: history2
    } = e3;
    var {
      undos
    } = history2;
    if (undos.length > 0) {
      var batch = undos[undos.length - 1];
      HistoryEditor.withoutSaving(e3, () => {
        Editor.withoutNormalizing(e3, () => {
          var inverseOps = batch.operations.map(Operation.inverse).reverse();
          for (var op of inverseOps) {
            e3.apply(op);
          }
          if (batch.selectionBefore) {
            Transforms.setSelection(e3, batch.selectionBefore);
          }
        });
      });
      history2.redos.push(batch);
      history2.undos.pop();
    }
  };
  e3.apply = (op) => {
    var {
      operations,
      history: history2
    } = e3;
    var {
      undos
    } = history2;
    var lastBatch = undos[undos.length - 1];
    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];
    var save = HistoryEditor.isSaving(e3);
    var merge = HistoryEditor.isMerging(e3);
    if (save == null) {
      save = shouldSave(op);
    }
    if (save) {
      if (merge == null) {
        if (lastBatch == null) {
          merge = false;
        } else if (operations.length !== 0) {
          merge = true;
        } else {
          merge = shouldMerge(op, lastOp);
        }
      }
      if (lastBatch && merge) {
        lastBatch.operations.push(op);
      } else {
        var batch = {
          operations: [op],
          selectionBefore: e3.selection
        };
        undos.push(batch);
      }
      while (undos.length > 100) {
        undos.shift();
      }
      history2.redos = [];
    }
    apply2(op);
  };
  return e3;
};
var shouldMerge = (op, prev) => {
  if (prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {
    return true;
  }
  if (prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {
    return true;
  }
  return false;
};
var shouldSave = (op, prev) => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(
      this,
      "name",
      /** @type {const} */
      "Assertion"
    );
    __publicField(
      this,
      "code",
      /** @type {const} */
      "ERR_ASSERTION"
    );
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value, message) {
  assert2(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function assert2(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString2(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node2(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values3, includeImageAlt, includeHtml) {
  const result = [];
  let index4 = -1;
  while (++index4 < values3.length) {
    result[index4] = one(values3[index4], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node2(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/decode-named-character-reference/index.dom.js
var element2 = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element2.innerHTML = characterReference2;
  const char = element2.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// node_modules/micromark-util-symbol/lib/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // `�`
  }
);

// node_modules/micromark-util-symbol/lib/constants.js
var constants = (
  /** @type {const} */
  {
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isn’t.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeContent: "content",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlRaw: 1,
    // Symbol for `<script>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlBasic: 6,
    // Symbol for `<div`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// node_modules/micromark-util-symbol/lib/types.js
var types2 = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// node_modules/micromark-util-symbol/lib/values.js
var values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: "�"
  }
);

// node_modules/micromark-util-chunked/dev/index.js
function splice(list5, start2, remove, items) {
  const end = list5.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end ? 0 : end + start2;
  } else {
    start2 = start2 > end ? end : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start2, remove);
    list5.splice(...parameters);
  } else {
    if (remove) list5.splice(start2, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start2, 0);
      list5.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start2 += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list5, items) {
  if (list5.length > 0) {
    splice(list5, list5.length, 0, items);
    return list5;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index4 = -1;
  while (++index4 < extensions.length) {
    syntaxExtension(all2, extensions[index4]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code4;
    if (right) {
      for (code4 in right) {
        if (!hasOwnProperty.call(left, code4)) left[code4] = [];
        const value = right[code4];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code4],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list5) {
  let index4 = -1;
  const before = [];
  while (++index4 < list5.length) {
    ;
    (list5[index4].add === "after" ? existing : before).push(list5[index4]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base2) {
  const code4 = Number.parseInt(value, base2);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code4 < codes.ht || code4 === codes.vt || code4 > codes.cr && code4 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code4 > codes.tilde && code4 < 160 || // Lone high surrogates and low surrogates.
    code4 > 55295 && code4 < 57344 || // Noncharacters.
    code4 > 64975 && code4 < 65008 || /* eslint-disable no-bitwise */
    (code4 & 65535) === 65535 || (code4 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code4 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code4);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-util-character/dev/index.js
var unicodePunctuationInternal = regexCheck(new RegExp("\\p{P}", "u"));
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code4) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code4 !== null && (code4 < codes.space || code4 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code4) {
  return code4 !== null && code4 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code4) {
  return code4 !== null && (code4 < codes.nul || code4 === codes.space);
}
function markdownSpace(code4) {
  return code4 === codes.horizontalTab || code4 === codes.virtualSpace || code4 === codes.space;
}
function unicodePunctuation(code4) {
  return asciiPunctuation(code4) || unicodePunctuationInternal(code4);
}
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code4) {
    return code4 !== null && code4 > -1 && regex.test(String.fromCharCode(code4));
  }
}

// node_modules/micromark/dev/lib/compile.js
var hasOwnProperty2 = {}.hasOwnProperty;

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type, max4) {
  const limit = max4 ? max4 - 1 : Number.POSITIVE_INFINITY;
  let size4 = 0;
  return start2;
  function start2(code4) {
    if (markdownSpace(code4)) {
      effects.enter(type);
      return prefix(code4);
    }
    return ok3(code4);
  }
  function prefix(code4) {
    if (markdownSpace(code4) && size4++ < limit) {
      effects.consume(code4);
      return prefix;
    }
    effects.exit(type);
    return ok3(code4);
  }
}

// node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code4) {
    ok(
      code4 === codes.eof || markdownLineEnding(code4),
      "expected eol or eof"
    );
    if (code4 === codes.eof) {
      effects.consume(code4);
      return;
    }
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, contentStart, types2.linePrefix);
  }
  function paragraphInitial(code4) {
    ok(
      code4 !== codes.eof && !markdownLineEnding(code4),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types2.paragraph);
    return lineStart(code4);
  }
  function lineStart(code4) {
    const token = effects.enter(types2.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous3
    });
    if (previous3) {
      previous3.next = token;
    }
    previous3 = token;
    return data2(code4);
  }
  function data2(code4) {
    if (code4 === codes.eof) {
      effects.exit(types2.chunkText);
      effects.exit(types2.paragraph);
      effects.consume(code4);
      return;
    }
    if (markdownLineEnding(code4)) {
      effects.consume(code4);
      effects.exit(types2.chunkText);
      return lineStart;
    }
    effects.consume(code4);
    return data2;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document3 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code4) {
    if (continued < stack.length) {
      const item2 = stack[continued];
      self2.containerState = item2[1];
      ok(
        item2[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item2[0].continuation,
        documentContinue,
        checkNewContainers
      )(code4);
    }
    return checkNewContainers(code4);
  }
  function documentContinue(code4) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point3;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types2.chunkFlow) {
          point3 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point3, "could not find previous flow chunk");
      exitContainers(continued);
      let index4 = indexBeforeExits;
      while (index4 < self2.events.length) {
        self2.events[index4][1].end = Object.assign({}, point3);
        index4++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index4;
      return checkNewContainers(code4);
    }
    return start2(code4);
  }
  function checkNewContainers(code4) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code4);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code4);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code4);
  }
  function thereIsANewContainer(code4) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code4);
  }
  function thereIsNoNewContainer(code4) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code4);
  }
  function documentContinued(code4) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code4);
  }
  function containerContinue(code4) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code4);
  }
  function flowStart(code4) {
    if (code4 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code4);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types2.chunkFlow, {
      contentType: constants.contentTypeFlow,
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code4);
  }
  function flowContinue(code4) {
    if (code4 === codes.eof) {
      writeToChild(effects.exit(types2.chunkFlow), true);
      exitContainers(0);
      effects.consume(code4);
      return;
    }
    if (markdownLineEnding(code4)) {
      effects.consume(code4);
      writeToChild(effects.exit(types2.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start2;
    }
    effects.consume(code4);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (eof) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index4 = childFlow.events.length;
      while (index4--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index4][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index4][1].end || // …or ends after it.
          childFlow.events[index4][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point3;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types2.chunkFlow) {
          if (seen) {
            point3 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point3, "could not find previous flow chunk");
      exitContainers(continued);
      index4 = indexBeforeExits;
      while (index4 < self2.events.length) {
        self2.events[index4][1].end = Object.assign({}, point3);
        index4++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index4;
    }
  }
  function exitContainers(size4) {
    let index4 = stack.length;
    while (index4-- > size4) {
      const entry = stack[index4];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size4;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types2.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code4) {
  if (code4 === codes.eof || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code4)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index4 = -1;
  while (++index4 < constructs2.length) {
    const resolve3 = constructs2[index4].resolveAll;
    if (resolve3 && !called.includes(resolve3)) {
      events = resolve3(events, context);
      called.push(resolve3);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index4 = -1;
  let open;
  let group;
  let text7;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset5;
  while (++index4 < events.length) {
    if (events[index4][0] === "enter" && events[index4][1].type === "attentionSequence" && events[index4][1]._close) {
      open = index4;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index4][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index4][1]._open) && (events[index4][1].end.offset - events[index4][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index4][1].end.offset - events[index4][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index4][1].end.offset - events[index4][1].start.offset > 1 ? 2 : 1;
          const start2 = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index4][1].start);
          movePoint(start2, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types2.strongSequence : types2.emphasisSequence,
            start: start2,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? types2.strongSequence : types2.emphasisSequence,
            start: Object.assign({}, events[index4][1].start),
            end
          };
          text7 = {
            type: use > 1 ? types2.strongText : types2.emphasisText,
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index4][1].start)
          };
          group = {
            type: use > 1 ? types2.strong : types2.emphasis,
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index4][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text7, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index4),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text7, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index4][1].end.offset - events[index4][1].start.offset) {
            offset5 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index4][1], context],
              ["exit", events[index4][1], context]
            ]);
          } else {
            offset5 = 0;
          }
          splice(events, open - 1, index4 - open + 3, nextEvents);
          index4 = open + nextEvents.length - offset5 - 2;
          break;
        }
      }
    }
  }
  index4 = -1;
  while (++index4 < events.length) {
    if (events[index4][1].type === "attentionSequence") {
      events[index4][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before = classifyCharacter(previous3);
  let marker;
  return start2;
  function start2(code4) {
    ok(
      code4 === codes.asterisk || code4 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code4;
    effects.enter("attentionSequence");
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code4);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code4);
    const close2 = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous3);
    token._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close2)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close2 : close2 && (after || !open)
    );
    return ok3(code4);
  }
}
function movePoint(point3, offset5) {
  point3.column += offset5;
  point3.offset += offset5;
  point3._bufferIndex += offset5;
}

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size4 = 0;
  return start2;
  function start2(code4) {
    ok(code4 === codes.lessThan, "expected `<`");
    effects.enter(types2.autolink);
    effects.enter(types2.autolinkMarker);
    effects.consume(code4);
    effects.exit(types2.autolinkMarker);
    effects.enter(types2.autolinkProtocol);
    return open;
  }
  function open(code4) {
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return schemeOrEmailAtext;
    }
    return emailAtext(code4);
  }
  function schemeOrEmailAtext(code4) {
    if (code4 === codes.plusSign || code4 === codes.dash || code4 === codes.dot || asciiAlphanumeric(code4)) {
      size4 = 1;
      return schemeInsideOrEmailAtext(code4);
    }
    return emailAtext(code4);
  }
  function schemeInsideOrEmailAtext(code4) {
    if (code4 === codes.colon) {
      effects.consume(code4);
      size4 = 0;
      return urlInside;
    }
    if ((code4 === codes.plusSign || code4 === codes.dash || code4 === codes.dot || asciiAlphanumeric(code4)) && size4++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code4);
      return schemeInsideOrEmailAtext;
    }
    size4 = 0;
    return emailAtext(code4);
  }
  function urlInside(code4) {
    if (code4 === codes.greaterThan) {
      effects.exit(types2.autolinkProtocol);
      effects.enter(types2.autolinkMarker);
      effects.consume(code4);
      effects.exit(types2.autolinkMarker);
      effects.exit(types2.autolink);
      return ok3;
    }
    if (code4 === codes.eof || code4 === codes.space || code4 === codes.lessThan || asciiControl(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return urlInside;
  }
  function emailAtext(code4) {
    if (code4 === codes.atSign) {
      effects.consume(code4);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code4)) {
      effects.consume(code4);
      return emailAtext;
    }
    return nok(code4);
  }
  function emailAtSignOrDot(code4) {
    return asciiAlphanumeric(code4) ? emailLabel(code4) : nok(code4);
  }
  function emailLabel(code4) {
    if (code4 === codes.dot) {
      effects.consume(code4);
      size4 = 0;
      return emailAtSignOrDot;
    }
    if (code4 === codes.greaterThan) {
      effects.exit(types2.autolinkProtocol).type = types2.autolinkEmail;
      effects.enter(types2.autolinkMarker);
      effects.consume(code4);
      effects.exit(types2.autolinkMarker);
      effects.exit(types2.autolink);
      return ok3;
    }
    return emailValue(code4);
  }
  function emailValue(code4) {
    if ((code4 === codes.dash || asciiAlphanumeric(code4)) && size4++ < constants.autolinkDomainSizeMax) {
      const next = code4 === codes.dash ? emailValue : emailLabel;
      effects.consume(code4);
      return next;
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { tokenize: tokenizeBlankLine, partial: true };
function tokenizeBlankLine(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    return markdownSpace(code4) ? factorySpace(effects, after, types2.linePrefix)(code4) : after(code4);
  }
  function after(code4) {
    return code4 === codes.eof || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    if (code4 === codes.greaterThan) {
      const state2 = self2.containerState;
      ok(state2, "expected `containerState` to be defined in container");
      if (!state2.open) {
        effects.enter(types2.blockQuote, { _container: true });
        state2.open = true;
      }
      effects.enter(types2.blockQuotePrefix);
      effects.enter(types2.blockQuoteMarker);
      effects.consume(code4);
      effects.exit(types2.blockQuoteMarker);
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    if (markdownSpace(code4)) {
      effects.enter(types2.blockQuotePrefixWhitespace);
      effects.consume(code4);
      effects.exit(types2.blockQuotePrefixWhitespace);
      effects.exit(types2.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types2.blockQuotePrefix);
    return ok3(code4);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code4) {
    if (markdownSpace(code4)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types2.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code4);
    }
    return contBefore(code4);
  }
  function contBefore(code4) {
    return effects.attempt(blockQuote, ok3, nok)(code4);
  }
}
function exit(effects) {
  effects.exit(types2.blockQuote);
}

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    ok(code4 === codes.backslash, "expected `\\`");
    effects.enter(types2.characterEscape);
    effects.enter(types2.escapeMarker);
    effects.consume(code4);
    effects.exit(types2.escapeMarker);
    return inside;
  }
  function inside(code4) {
    if (asciiPunctuation(code4)) {
      effects.enter(types2.characterEscapeValue);
      effects.consume(code4);
      effects.exit(types2.characterEscapeValue);
      effects.exit(types2.characterEscape);
      return ok3;
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size4 = 0;
  let max4;
  let test;
  return start2;
  function start2(code4) {
    ok(code4 === codes.ampersand, "expected `&`");
    effects.enter(types2.characterReference);
    effects.enter(types2.characterReferenceMarker);
    effects.consume(code4);
    effects.exit(types2.characterReferenceMarker);
    return open;
  }
  function open(code4) {
    if (code4 === codes.numberSign) {
      effects.enter(types2.characterReferenceMarkerNumeric);
      effects.consume(code4);
      effects.exit(types2.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types2.characterReferenceValue);
    max4 = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value(code4);
  }
  function numeric(code4) {
    if (code4 === codes.uppercaseX || code4 === codes.lowercaseX) {
      effects.enter(types2.characterReferenceMarkerHexadecimal);
      effects.consume(code4);
      effects.exit(types2.characterReferenceMarkerHexadecimal);
      effects.enter(types2.characterReferenceValue);
      max4 = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types2.characterReferenceValue);
    max4 = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code4);
  }
  function value(code4) {
    if (code4 === codes.semicolon && size4) {
      const token = effects.exit(types2.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code4);
      }
      effects.enter(types2.characterReferenceMarker);
      effects.consume(code4);
      effects.exit(types2.characterReferenceMarker);
      effects.exit(types2.characterReference);
      return ok3;
    }
    if (test(code4) && size4++ < max4) {
      effects.consume(code4);
      return value;
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { tokenize: tokenizeCloseStart, partial: true };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code4) {
    return beforeSequenceOpen(code4);
  }
  function beforeSequenceOpen(code4) {
    ok(
      code4 === codes.graveAccent || code4 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types2.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code4;
    effects.enter(types2.codeFenced);
    effects.enter(types2.codeFencedFence);
    effects.enter(types2.codeFencedFenceSequence);
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === marker) {
      sizeOpen++;
      effects.consume(code4);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code4);
    }
    effects.exit(types2.codeFencedFenceSequence);
    return markdownSpace(code4) ? factorySpace(effects, infoBefore, types2.whitespace)(code4) : infoBefore(code4);
  }
  function infoBefore(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.codeFencedFence);
      return self2.interrupt ? ok3(code4) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
    }
    effects.enter(types2.codeFencedFenceInfo);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return info(code4);
  }
  function info(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceInfo);
      return infoBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types2.whitespace)(code4);
    }
    if (code4 === codes.graveAccent && code4 === marker) {
      return nok(code4);
    }
    effects.consume(code4);
    return info;
  }
  function metaBefore(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return infoBefore(code4);
    }
    effects.enter(types2.codeFencedFenceMeta);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return meta(code4);
  }
  function meta(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceMeta);
      return infoBefore(code4);
    }
    if (code4 === codes.graveAccent && code4 === marker) {
      return nok(code4);
    }
    effects.consume(code4);
    return meta;
  }
  function atNonLazyBreak(code4) {
    ok(markdownLineEnding(code4), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code4);
  }
  function contentBefore(code4) {
    ok(markdownLineEnding(code4), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    return contentStart;
  }
  function contentStart(code4) {
    return initialPrefix > 0 && markdownSpace(code4) ? factorySpace(
      effects,
      beforeContentChunk,
      types2.linePrefix,
      initialPrefix + 1
    )(code4) : beforeContentChunk(code4);
  }
  function beforeContentChunk(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
    }
    effects.enter(types2.codeFlowValue);
    return contentChunk(code4);
  }
  function contentChunk(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.codeFlowValue);
      return beforeContentChunk(code4);
    }
    effects.consume(code4);
    return contentChunk;
  }
  function after(code4) {
    effects.exit(types2.codeFenced);
    return ok3(code4);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size4 = 0;
    return startBefore;
    function startBefore(code4) {
      ok(markdownLineEnding(code4), "expected eol");
      effects2.enter(types2.lineEnding);
      effects2.consume(code4);
      effects2.exit(types2.lineEnding);
      return start3;
    }
    function start3(code4) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types2.codeFencedFence);
      return markdownSpace(code4) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types2.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code4) : beforeSequenceClose(code4);
    }
    function beforeSequenceClose(code4) {
      if (code4 === marker) {
        effects2.enter(types2.codeFencedFenceSequence);
        return sequenceClose(code4);
      }
      return nok2(code4);
    }
    function sequenceClose(code4) {
      if (code4 === marker) {
        size4++;
        effects2.consume(code4);
        return sequenceClose;
      }
      if (size4 >= sizeOpen) {
        effects2.exit(types2.codeFencedFenceSequence);
        return markdownSpace(code4) ? factorySpace(effects2, sequenceCloseAfter, types2.whitespace)(code4) : sequenceCloseAfter(code4);
      }
      return nok2(code4);
    }
    function sequenceCloseAfter(code4) {
      if (code4 === codes.eof || markdownLineEnding(code4)) {
        effects2.exit(types2.codeFencedFence);
        return ok4(code4);
      }
      return nok2(code4);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    ok(markdownLineEnding(code4), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    return lineStart;
  }
  function lineStart(code4) {
    return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { tokenize: tokenizeFurtherStart, partial: true };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    ok(markdownSpace(code4));
    effects.enter(types2.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types2.linePrefix,
      constants.tabSize + 1
    )(code4);
  }
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code4) : nok(code4);
  }
  function atBreak(code4) {
    if (code4 === codes.eof) {
      return after(code4);
    }
    if (markdownLineEnding(code4)) {
      return effects.attempt(furtherStart, atBreak, after)(code4);
    }
    effects.enter(types2.codeFlowValue);
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.codeFlowValue);
      return atBreak(code4);
    }
    effects.consume(code4);
    return inside;
  }
  function after(code4) {
    effects.exit(types2.codeIndented);
    return ok3(code4);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code4) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types2.linePrefix,
      constants.tabSize + 1
    )(code4);
  }
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code4) : markdownLineEnding(code4) ? furtherStart2(code4) : nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index4;
  let enter;
  if ((events[headEnterIndex][1].type === types2.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types2.lineEnding || events[tailExitIndex][1].type === "space")) {
    index4 = headEnterIndex;
    while (++index4 < tailExitIndex) {
      if (events[index4][1].type === types2.codeTextData) {
        events[headEnterIndex][1].type = types2.codeTextPadding;
        events[tailExitIndex][1].type = types2.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index4 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index4 <= tailExitIndex) {
    if (enter === void 0) {
      if (index4 !== tailExitIndex && events[index4][1].type !== types2.lineEnding) {
        enter = index4;
      }
    } else if (index4 === tailExitIndex || events[index4][1].type === types2.lineEnding) {
      events[enter][1].type = types2.codeTextData;
      if (index4 !== enter + 2) {
        events[enter][1].end = events[index4 - 1][1].end;
        events.splice(enter + 2, index4 - enter - 2);
        tailExitIndex -= index4 - enter - 2;
        index4 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code4) {
  return code4 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types2.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size4;
  let token;
  return start2;
  function start2(code4) {
    ok(code4 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types2.codeText);
    effects.enter(types2.codeTextSequence);
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === codes.graveAccent) {
      effects.consume(code4);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types2.codeTextSequence);
    return between2(code4);
  }
  function between2(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (code4 === codes.space) {
      effects.enter("space");
      effects.consume(code4);
      effects.exit("space");
      return between2;
    }
    if (code4 === codes.graveAccent) {
      token = effects.enter(types2.codeTextSequence);
      size4 = 0;
      return sequenceClose(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      return between2;
    }
    effects.enter(types2.codeTextData);
    return data2(code4);
  }
  function data2(code4) {
    if (code4 === codes.eof || code4 === codes.space || code4 === codes.graveAccent || markdownLineEnding(code4)) {
      effects.exit(types2.codeTextData);
      return between2(code4);
    }
    effects.consume(code4);
    return data2;
  }
  function sequenceClose(code4) {
    if (code4 === codes.graveAccent) {
      effects.consume(code4);
      size4++;
      return sequenceClose;
    }
    if (size4 === sizeOpen) {
      effects.exit(types2.codeTextSequence);
      effects.exit(types2.codeText);
      return ok3(code4);
    }
    token.type = types2.codeTextData;
    return data2(code4);
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(events) {
  const jumps = {};
  let index4 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index4 < events.length) {
    while (index4 in jumps) {
      index4 = jumps[index4];
    }
    event = events[index4];
    if (index4 && event[1].type === types2.chunkFlow && events[index4 - 1][1].type === types2.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types2.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types2.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types2.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types2.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index4));
        index4 = jumps[index4];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index4;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === types2.lineEnding || otherEvent[1].type === types2.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = types2.lineEndingBlank;
            }
            otherEvent[1].type = types2.lineEnding;
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index4);
        parameters.unshift(event);
        splice(events, lineIndex, index4 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  const tokenizer3 = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer3.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index4 = -1;
  let current2 = token;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current2) {
    while (events[++startPosition][1] !== current2) {
    }
    ok(
      !previous3 || current2.previous === previous3,
      "expected previous to match"
    );
    ok(!previous3 || previous3.next === current2, "expected next to match");
    startPositions.push(startPosition);
    if (!current2._tokenizer) {
      stream = context.sliceStream(current2);
      if (!current2.next) {
        stream.push(codes.eof);
      }
      if (previous3) {
        tokenizer3.defineSkip(current2.start);
      }
      if (current2._isInFirstContentOfListItem) {
        tokenizer3._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer3.write(stream);
      if (current2._isInFirstContentOfListItem) {
        tokenizer3._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current2;
    current2 = current2.next;
  }
  current2 = token;
  while (++index4 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index4][0] === "exit" && childEvents[index4 - 1][0] === "enter" && childEvents[index4][1].type === childEvents[index4 - 1][1].type && childEvents[index4][1].start.line !== childEvents[index4][1].end.line
    ) {
      ok(current2, "expected a current token");
      start2 = index4 + 1;
      breaks.push(start2);
      current2._tokenizer = void 0;
      current2.previous = void 0;
      current2 = current2.next;
    }
  }
  tokenizer3.events = [];
  if (current2) {
    current2._tokenizer = void 0;
    current2.previous = void 0;
    ok(!current2.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index4 = breaks.length;
  while (index4--) {
    const slice2 = childEvents.slice(breaks[index4], breaks[index4 + 1]);
    const start3 = startPositions.pop();
    ok(start3 !== void 0, "expected a start position when splicing");
    jumps.unshift([start3, start3 + slice2.length - 1]);
    splice(events, start3, 2, slice2);
  }
  index4 = -1;
  while (++index4 < jumps.length) {
    gaps[adjust + jumps[index4][0]] = adjust + jumps[index4][1];
    adjust += jumps[index4][1] - jumps[index4][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { tokenize: tokenizeContent, resolve: resolveContent };
var continuationConstruct = { tokenize: tokenizeContinuation, partial: true };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code4) {
    ok(
      code4 !== codes.eof && !markdownLineEnding(code4),
      "expected no eof or eol"
    );
    effects.enter(types2.content);
    previous3 = effects.enter(types2.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code4);
  }
  function chunkInside(code4) {
    if (code4 === codes.eof) {
      return contentEnd(code4);
    }
    if (markdownLineEnding(code4)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code4);
    }
    effects.consume(code4);
    return chunkInside;
  }
  function contentEnd(code4) {
    effects.exit(types2.chunkContent);
    effects.exit(types2.content);
    return ok3(code4);
  }
  function contentContinue(code4) {
    ok(markdownLineEnding(code4), "expected eol");
    effects.consume(code4);
    effects.exit(types2.chunkContent);
    ok(previous3, "expected previous token");
    previous3.next = effects.enter(types2.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code4) {
    ok(markdownLineEnding(code4), "expected a line ending");
    effects.exit(types2.chunkContent);
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, prefixed, types2.linePrefix);
  }
  function prefixed(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return nok(code4);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code4);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code4);
  }
}

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max4) {
  const limit = max4 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code4) {
    if (code4 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code4);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code4 === codes.eof || code4 === codes.space || code4 === codes.rightParenthesis || asciiControl(code4)) {
      return nok(code4);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return raw(code4);
  }
  function enclosedBefore(code4) {
    if (code4 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code4);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code4);
  }
  function enclosed(code4) {
    if (code4 === codes.greaterThan) {
      effects.exit(types2.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code4);
    }
    if (code4 === codes.eof || code4 === codes.lessThan || markdownLineEnding(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code4) {
    if (code4 === codes.lessThan || code4 === codes.greaterThan || code4 === codes.backslash) {
      effects.consume(code4);
      return enclosed;
    }
    return enclosed(code4);
  }
  function raw(code4) {
    if (!balance && (code4 === codes.eof || code4 === codes.rightParenthesis || markdownLineEndingOrSpace(code4))) {
      effects.exit(types2.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code4);
    }
    if (balance < limit && code4 === codes.leftParenthesis) {
      effects.consume(code4);
      balance++;
      return raw;
    }
    if (code4 === codes.rightParenthesis) {
      effects.consume(code4);
      balance--;
      return raw;
    }
    if (code4 === codes.eof || code4 === codes.space || code4 === codes.leftParenthesis || asciiControl(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code4) {
    if (code4 === codes.leftParenthesis || code4 === codes.rightParenthesis || code4 === codes.backslash) {
      effects.consume(code4);
      return raw;
    }
    return raw(code4);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size4 = 0;
  let seen;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code4);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code4) {
    if (size4 > constants.linkReferenceSizeMax || code4 === codes.eof || code4 === codes.leftSquareBracket || code4 === codes.rightSquareBracket && !seen || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code4 === codes.caret && !size4 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      return atBreak;
    }
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code4);
  }
  function labelInside(code4) {
    if (code4 === codes.eof || code4 === codes.leftSquareBracket || code4 === codes.rightSquareBracket || markdownLineEnding(code4) || size4++ > constants.linkReferenceSizeMax) {
      effects.exit(types2.chunkString);
      return atBreak(code4);
    }
    effects.consume(code4);
    if (!seen) seen = !markdownSpace(code4);
    return code4 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code4) {
    if (code4 === codes.leftSquareBracket || code4 === codes.backslash || code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      size4++;
      return labelInside;
    }
    return labelInside(code4);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start2;
  function start2(code4) {
    if (code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      marker = code4 === codes.leftParenthesis ? codes.rightParenthesis : code4;
      return begin;
    }
    return nok(code4);
  }
  function begin(code4) {
    if (code4 === marker) {
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code4);
  }
  function atBreak(code4) {
    if (code4 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      return factorySpace(effects, atBreak, types2.linePrefix);
    }
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker || code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.chunkString);
      return atBreak(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? escape3 : inside;
  }
  function escape3(code4) {
    if (code4 === marker || code4 === codes.backslash) {
      effects.consume(code4);
      return inside;
    }
    return inside(code4);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start2;
  function start2(code4) {
    if (markdownLineEnding(code4)) {
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      seen = true;
      return start2;
    }
    if (markdownSpace(code4)) {
      return factorySpace(
        effects,
        start2,
        seen ? types2.linePrefix : types2.lineSuffix
      )(code4);
    }
    return ok3(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { tokenize: tokenizeTitleBefore, partial: true };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier2;
  return start2;
  function start2(code4) {
    effects.enter(types2.definition);
    return before(code4);
  }
  function before(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      types2.definitionLabel,
      types2.definitionLabelMarker,
      types2.definitionLabelString
    )(code4);
  }
  function labelAfter(code4) {
    identifier2 = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code4 === codes.colon) {
      effects.enter(types2.definitionMarker);
      effects.consume(code4);
      effects.exit(types2.definitionMarker);
      return markerAfter;
    }
    return nok(code4);
  }
  function markerAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, destinationBefore)(code4) : destinationBefore(code4);
  }
  function destinationBefore(code4) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      types2.definitionDestination,
      types2.definitionDestinationLiteral,
      types2.definitionDestinationLiteralMarker,
      types2.definitionDestinationRaw,
      types2.definitionDestinationString
    )(code4);
  }
  function destinationAfter(code4) {
    return effects.attempt(titleBefore, after, after)(code4);
  }
  function after(code4) {
    return markdownSpace(code4) ? factorySpace(effects, afterWhitespace, types2.whitespace)(code4) : afterWhitespace(code4);
  }
  function afterWhitespace(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.definition);
      self2.parser.defined.push(identifier2);
      return ok3(code4);
    }
    return nok(code4);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, beforeMarker)(code4) : nok(code4);
  }
  function beforeMarker(code4) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types2.definitionTitle,
      types2.definitionTitleMarker,
      types2.definitionTitleString
    )(code4);
  }
  function titleAfter(code4) {
    return markdownSpace(code4) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types2.whitespace
    )(code4) : titleAfterOptionalWhitespace(code4);
  }
  function titleAfterOptionalWhitespace(code4) {
    return code4 === codes.eof || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    ok(code4 === codes.backslash, "expected `\\`");
    effects.enter(types2.hardBreakEscape);
    effects.consume(code4);
    return after;
  }
  function after(code4) {
    if (markdownLineEnding(code4)) {
      effects.exit(types2.hardBreakEscape);
      return ok3(code4);
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text7;
  if (events[contentStart][1].type === types2.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types2.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types2.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types2.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types2.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text7 = {
      type: types2.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text7, context],
      ["exit", text7, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size4 = 0;
  return start2;
  function start2(code4) {
    effects.enter(types2.atxHeading);
    return before(code4);
  }
  function before(code4) {
    ok(code4 === codes.numberSign, "expected `#`");
    effects.enter(types2.atxHeadingSequence);
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === codes.numberSign && size4++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code4);
      return sequenceOpen;
    }
    if (code4 === codes.eof || markdownLineEndingOrSpace(code4)) {
      effects.exit(types2.atxHeadingSequence);
      return atBreak(code4);
    }
    return nok(code4);
  }
  function atBreak(code4) {
    if (code4 === codes.numberSign) {
      effects.enter(types2.atxHeadingSequence);
      return sequenceFurther(code4);
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.atxHeading);
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, atBreak, types2.whitespace)(code4);
    }
    effects.enter(types2.atxHeadingText);
    return data2(code4);
  }
  function sequenceFurther(code4) {
    if (code4 === codes.numberSign) {
      effects.consume(code4);
      return sequenceFurther;
    }
    effects.exit(types2.atxHeadingSequence);
    return atBreak(code4);
  }
  function data2(code4) {
    if (code4 === codes.eof || code4 === codes.numberSign || markdownLineEndingOrSpace(code4)) {
      effects.exit(types2.atxHeadingText);
      return atBreak(code4);
    }
    effects.consume(code4);
    return data2;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = { tokenize: tokenizeBlankLineBefore, partial: true };
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index4 = events.length;
  while (index4--) {
    if (events[index4][0] === "enter" && events[index4][1].type === types2.htmlFlow) {
      break;
    }
  }
  if (index4 > 1 && events[index4 - 2][1].type === types2.linePrefix) {
    events[index4][1].start = events[index4 - 2][1].start;
    events[index4 + 1][1].start = events[index4 - 2][1].start;
    events.splice(index4 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index4;
  let markerB;
  return start2;
  function start2(code4) {
    return before(code4);
  }
  function before(code4) {
    ok(code4 === codes.lessThan, "expected `<`");
    effects.enter(types2.htmlFlow);
    effects.enter(types2.htmlFlowData);
    effects.consume(code4);
    return open;
  }
  function open(code4) {
    if (code4 === codes.exclamationMark) {
      effects.consume(code4);
      return declarationOpen;
    }
    if (code4 === codes.slash) {
      effects.consume(code4);
      closingTag = true;
      return tagCloseStart;
    }
    if (code4 === codes.questionMark) {
      effects.consume(code4);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      buffer = String.fromCharCode(code4);
      return tagName3;
    }
    return nok(code4);
  }
  function declarationOpen(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code4 === codes.leftSquareBracket) {
      effects.consume(code4);
      marker = constants.htmlCdata;
      index4 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code4);
  }
  function commentOpenInside(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code4);
  }
  function cdataOpenInside(code4) {
    const value = constants.cdataOpeningString;
    if (code4 === value.charCodeAt(index4++)) {
      effects.consume(code4);
      if (index4 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code4);
  }
  function tagCloseStart(code4) {
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      buffer = String.fromCharCode(code4);
      return tagName3;
    }
    return nok(code4);
  }
  function tagName3(code4) {
    if (code4 === codes.eof || code4 === codes.slash || code4 === codes.greaterThan || markdownLineEndingOrSpace(code4)) {
      const slash = code4 === codes.slash;
      const name2 = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok3(code4) : continuation(code4);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code4);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code4) : continuation(code4);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code4) : closingTag ? completeClosingTagAfter(code4) : completeAttributeNameBefore(code4);
    }
    if (code4 === codes.dash || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      buffer += String.fromCharCode(code4);
      return tagName3;
    }
    return nok(code4);
  }
  function basicSelfClosing(code4) {
    if (code4 === codes.greaterThan) {
      effects.consume(code4);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code4);
  }
  function completeClosingTagAfter(code4) {
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeClosingTagAfter;
    }
    return completeEnd(code4);
  }
  function completeAttributeNameBefore(code4) {
    if (code4 === codes.slash) {
      effects.consume(code4);
      return completeEnd;
    }
    if (code4 === codes.colon || code4 === codes.underscore || asciiAlpha(code4)) {
      effects.consume(code4);
      return completeAttributeName;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeNameBefore;
    }
    return completeEnd(code4);
  }
  function completeAttributeName(code4) {
    if (code4 === codes.dash || code4 === codes.dot || code4 === codes.colon || code4 === codes.underscore || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code4);
  }
  function completeAttributeNameAfter(code4) {
    if (code4 === codes.equalsTo) {
      effects.consume(code4);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code4);
  }
  function completeAttributeValueBefore(code4) {
    if (code4 === codes.eof || code4 === codes.lessThan || code4 === codes.equalsTo || code4 === codes.greaterThan || code4 === codes.graveAccent) {
      return nok(code4);
    }
    if (code4 === codes.quotationMark || code4 === codes.apostrophe) {
      effects.consume(code4);
      markerB = code4;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code4);
  }
  function completeAttributeValueQuoted(code4) {
    if (code4 === markerB) {
      effects.consume(code4);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code4) {
    if (code4 === codes.eof || code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.slash || code4 === codes.lessThan || code4 === codes.equalsTo || code4 === codes.greaterThan || code4 === codes.graveAccent || markdownLineEndingOrSpace(code4)) {
      return completeAttributeNameAfter(code4);
    }
    effects.consume(code4);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code4) {
    if (code4 === codes.slash || code4 === codes.greaterThan || markdownSpace(code4)) {
      return completeAttributeNameBefore(code4);
    }
    return nok(code4);
  }
  function completeEnd(code4) {
    if (code4 === codes.greaterThan) {
      effects.consume(code4);
      return completeAfter;
    }
    return nok(code4);
  }
  function completeAfter(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return continuation(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAfter;
    }
    return nok(code4);
  }
  function continuation(code4) {
    if (code4 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code4);
      return continuationCommentInside;
    }
    if (code4 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code4);
      return continuationRawTagOpen;
    }
    if (code4 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code4);
      return continuationClose;
    }
    if (code4 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    if (code4 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code4);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code4) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types2.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code4);
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.htmlFlowData);
      return continuationStart(code4);
    }
    effects.consume(code4);
    return continuation;
  }
  function continuationStart(code4) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code4);
  }
  function continuationStartNonLazy(code4) {
    ok(markdownLineEnding(code4));
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return continuationStart(code4);
    }
    effects.enter(types2.htmlFlowData);
    return continuation(code4);
  }
  function continuationCommentInside(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationRawTagOpen(code4) {
    if (code4 === codes.slash) {
      effects.consume(code4);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code4);
  }
  function continuationRawEndTag(code4) {
    if (code4 === codes.greaterThan) {
      const name2 = buffer.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code4);
        return continuationClose;
      }
      return continuation(code4);
    }
    if (asciiAlpha(code4) && buffer.length < constants.htmlRawSizeMax) {
      effects.consume(code4);
      buffer += String.fromCharCode(code4);
      return continuationRawEndTag;
    }
    return continuation(code4);
  }
  function continuationCdataInside(code4) {
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationDeclarationInside(code4) {
    if (code4 === codes.greaterThan) {
      effects.consume(code4);
      return continuationClose;
    }
    if (code4 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationClose(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.htmlFlowData);
      return continuationAfter(code4);
    }
    effects.consume(code4);
    return continuationClose;
  }
  function continuationAfter(code4) {
    effects.exit(types2.htmlFlow);
    return ok3(code4);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    if (markdownLineEnding(code4)) {
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    ok(markdownLineEnding(code4), "expected a line ending");
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index4;
  let returnState;
  return start2;
  function start2(code4) {
    ok(code4 === codes.lessThan, "expected `<`");
    effects.enter(types2.htmlText);
    effects.enter(types2.htmlTextData);
    effects.consume(code4);
    return open;
  }
  function open(code4) {
    if (code4 === codes.exclamationMark) {
      effects.consume(code4);
      return declarationOpen;
    }
    if (code4 === codes.slash) {
      effects.consume(code4);
      return tagCloseStart;
    }
    if (code4 === codes.questionMark) {
      effects.consume(code4);
      return instruction;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return tagOpen;
    }
    return nok(code4);
  }
  function declarationOpen(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return commentOpenInside;
    }
    if (code4 === codes.leftSquareBracket) {
      effects.consume(code4);
      index4 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return declaration;
    }
    return nok(code4);
  }
  function commentOpenInside(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return commentEnd;
    }
    return nok(code4);
  }
  function comment2(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (code4 === codes.dash) {
      effects.consume(code4);
      return commentClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = comment2;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return comment2;
  }
  function commentClose(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return commentEnd;
    }
    return comment2(code4);
  }
  function commentEnd(code4) {
    return code4 === codes.greaterThan ? end(code4) : code4 === codes.dash ? commentClose(code4) : comment2(code4);
  }
  function cdataOpenInside(code4) {
    const value = constants.cdataOpeningString;
    if (code4 === value.charCodeAt(index4++)) {
      effects.consume(code4);
      return index4 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code4);
  }
  function cdata(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return cdataClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = cdata;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return cdata;
  }
  function cdataClose(code4) {
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return cdataEnd;
    }
    return cdata(code4);
  }
  function cdataEnd(code4) {
    if (code4 === codes.greaterThan) {
      return end(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return cdataEnd;
    }
    return cdata(code4);
  }
  function declaration(code4) {
    if (code4 === codes.eof || code4 === codes.greaterThan) {
      return end(code4);
    }
    if (markdownLineEnding(code4)) {
      returnState = declaration;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return declaration;
  }
  function instruction(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (code4 === codes.questionMark) {
      effects.consume(code4);
      return instructionClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = instruction;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return instruction;
  }
  function instructionClose(code4) {
    return code4 === codes.greaterThan ? end(code4) : instruction(code4);
  }
  function tagCloseStart(code4) {
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return tagClose;
    }
    return nok(code4);
  }
  function tagClose(code4) {
    if (code4 === codes.dash || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagClose;
    }
    return tagCloseBetween(code4);
  }
  function tagCloseBetween(code4) {
    if (markdownLineEnding(code4)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagCloseBetween;
    }
    return end(code4);
  }
  function tagOpen(code4) {
    if (code4 === codes.dash || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagOpen;
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    return nok(code4);
  }
  function tagOpenBetween(code4) {
    if (code4 === codes.slash) {
      effects.consume(code4);
      return end;
    }
    if (code4 === codes.colon || code4 === codes.underscore || asciiAlpha(code4)) {
      effects.consume(code4);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenBetween;
    }
    return end(code4);
  }
  function tagOpenAttributeName(code4) {
    if (code4 === codes.dash || code4 === codes.dot || code4 === codes.colon || code4 === codes.underscore || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code4);
  }
  function tagOpenAttributeNameAfter(code4) {
    if (code4 === codes.equalsTo) {
      effects.consume(code4);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code4);
  }
  function tagOpenAttributeValueBefore(code4) {
    if (code4 === codes.eof || code4 === codes.lessThan || code4 === codes.equalsTo || code4 === codes.greaterThan || code4 === codes.graveAccent) {
      return nok(code4);
    }
    if (code4 === codes.quotationMark || code4 === codes.apostrophe) {
      effects.consume(code4);
      marker = code4;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code4);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code4) {
    if (code4 === codes.eof || code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.lessThan || code4 === codes.equalsTo || code4 === codes.graveAccent) {
      return nok(code4);
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    effects.consume(code4);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code4) {
    if (code4 === codes.slash || code4 === codes.greaterThan || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    return nok(code4);
  }
  function end(code4) {
    if (code4 === codes.greaterThan) {
      effects.consume(code4);
      effects.exit(types2.htmlTextData);
      effects.exit(types2.htmlText);
      return ok3;
    }
    return nok(code4);
  }
  function lineEndingBefore(code4) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code4), "expected eol");
    effects.exit(types2.htmlTextData);
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code4) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code4) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types2.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code4) : lineEndingAfterPrefix(code4);
  }
  function lineEndingAfterPrefix(code4) {
    effects.enter(types2.htmlTextData);
    return returnState(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index4 = -1;
  while (++index4 < events.length) {
    const token = events[index4][1];
    if (token.type === types2.labelImage || token.type === types2.labelLink || token.type === types2.labelEnd) {
      events.splice(index4 + 1, token.type === types2.labelImage ? 4 : 2);
      token.type = types2.data;
      index4++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index4 = events.length;
  let offset5 = 0;
  let token;
  let open;
  let close2;
  let media;
  while (index4--) {
    token = events[index4][1];
    if (open) {
      if (token.type === types2.link || token.type === types2.labelLink && token._inactive) {
        break;
      }
      if (events[index4][0] === "enter" && token.type === types2.labelLink) {
        token._inactive = true;
      }
    } else if (close2) {
      if (events[index4][0] === "enter" && (token.type === types2.labelImage || token.type === types2.labelLink) && !token._balanced) {
        open = index4;
        if (token.type !== types2.labelLink) {
          offset5 = 2;
          break;
        }
      }
    } else if (token.type === types2.labelEnd) {
      close2 = index4;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close2 !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types2.labelLink ? types2.link : types2.image,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: types2.label,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close2][1].end)
  };
  const text7 = {
    type: types2.labelText,
    start: Object.assign({}, events[open + offset5 + 2][1].end),
    end: Object.assign({}, events[close2 - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset5 + 3));
  media = push(media, [["enter", text7, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset5 + 4, close2 - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text7, context],
    events[close2 - 2],
    events[close2 - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close2 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index4 = self2.events.length;
  let labelStart;
  let defined;
  while (index4--) {
    if ((self2.events[index4][1].type === types2.labelImage || self2.events[index4][1].type === types2.labelLink) && !self2.events[index4][1]._balanced) {
      labelStart = self2.events[index4][1];
      break;
    }
  }
  return start2;
  function start2(code4) {
    ok(code4 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code4);
    }
    if (labelStart._inactive) {
      return labelEndNok(code4);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types2.labelEnd);
    effects.enter(types2.labelMarker);
    effects.consume(code4);
    effects.exit(types2.labelMarker);
    effects.exit(types2.labelEnd);
    return after;
  }
  function after(code4) {
    if (code4 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code4);
    }
    if (code4 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code4);
    }
    return defined ? labelEndOk(code4) : labelEndNok(code4);
  }
  function referenceNotFull(code4) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code4);
  }
  function labelEndOk(code4) {
    return ok3(code4);
  }
  function labelEndNok(code4) {
    labelStart._balanced = true;
    return nok(code4);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code4) {
    ok(code4 === codes.leftParenthesis, "expected left paren");
    effects.enter(types2.resource);
    effects.enter(types2.resourceMarker);
    effects.consume(code4);
    effects.exit(types2.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceOpen)(code4) : resourceOpen(code4);
  }
  function resourceOpen(code4) {
    if (code4 === codes.rightParenthesis) {
      return resourceEnd(code4);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types2.resourceDestination,
      types2.resourceDestinationLiteral,
      types2.resourceDestinationLiteralMarker,
      types2.resourceDestinationRaw,
      types2.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code4);
  }
  function resourceDestinationAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceBetween)(code4) : resourceEnd(code4);
  }
  function resourceDestinationMissing(code4) {
    return nok(code4);
  }
  function resourceBetween(code4) {
    if (code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types2.resourceTitle,
        types2.resourceTitleMarker,
        types2.resourceTitleString
      )(code4);
    }
    return resourceEnd(code4);
  }
  function resourceTitleAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceEnd)(code4) : resourceEnd(code4);
  }
  function resourceEnd(code4) {
    if (code4 === codes.rightParenthesis) {
      effects.enter(types2.resourceMarker);
      effects.consume(code4);
      effects.exit(types2.resourceMarker);
      effects.exit(types2.resource);
      return ok3;
    }
    return nok(code4);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code4) {
    ok(code4 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types2.reference,
      types2.referenceMarker,
      types2.referenceString
    )(code4);
  }
  function referenceFullAfter(code4) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code4) : nok(code4);
  }
  function referenceFullMissing(code4) {
    return nok(code4);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code4) {
    ok(code4 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types2.reference);
    effects.enter(types2.referenceMarker);
    effects.consume(code4);
    effects.exit(types2.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code4) {
    if (code4 === codes.rightSquareBracket) {
      effects.enter(types2.referenceMarker);
      effects.consume(code4);
      effects.exit(types2.referenceMarker);
      effects.exit(types2.reference);
      return ok3;
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    ok(code4 === codes.exclamationMark, "expected `!`");
    effects.enter(types2.labelImage);
    effects.enter(types2.labelImageMarker);
    effects.consume(code4);
    effects.exit(types2.labelImageMarker);
    return open;
  }
  function open(code4) {
    if (code4 === codes.leftSquareBracket) {
      effects.enter(types2.labelMarker);
      effects.consume(code4);
      effects.exit(types2.labelMarker);
      effects.exit(types2.labelImage);
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    return code4 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types2.labelLink);
    effects.enter(types2.labelMarker);
    effects.consume(code4);
    effects.exit(types2.labelMarker);
    effects.exit(types2.labelLink);
    return after;
  }
  function after(code4) {
    return code4 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start2;
  function start2(code4) {
    ok(markdownLineEnding(code4), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, ok3, types2.linePrefix);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size4 = 0;
  let marker;
  return start2;
  function start2(code4) {
    effects.enter(types2.thematicBreak);
    return before(code4);
  }
  function before(code4) {
    ok(
      code4 === codes.asterisk || code4 === codes.dash || code4 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code4;
    return atBreak(code4);
  }
  function atBreak(code4) {
    if (code4 === marker) {
      effects.enter(types2.thematicBreakSequence);
      return sequence(code4);
    }
    if (size4 >= constants.thematicBreakMarkerCountMin && (code4 === codes.eof || markdownLineEnding(code4))) {
      effects.exit(types2.thematicBreak);
      return ok3(code4);
    }
    return nok(code4);
  }
  function sequence(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      size4++;
      return sequence;
    }
    effects.exit(types2.thematicBreakSequence);
    return markdownSpace(code4) ? factorySpace(effects, atBreak, types2.whitespace)(code4) : atBreak(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list2 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = { tokenize: tokenizeIndent, partial: true };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types2.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size4 = 0;
  return start2;
  function start2(code4) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code4 === codes.asterisk || code4 === codes.plusSign || code4 === codes.dash ? types2.listUnordered : types2.listOrdered);
    if (kind === types2.listUnordered ? !self2.containerState.marker || code4 === self2.containerState.marker : asciiDigit(code4)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types2.listUnordered) {
        effects.enter(types2.listItemPrefix);
        return code4 === codes.asterisk || code4 === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code4) : atMarker(code4);
      }
      if (!self2.interrupt || code4 === codes.digit1) {
        effects.enter(types2.listItemPrefix);
        effects.enter(types2.listItemValue);
        return inside(code4);
      }
    }
    return nok(code4);
  }
  function inside(code4) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code4) && ++size4 < constants.listItemValueSizeMax) {
      effects.consume(code4);
      return inside;
    }
    if ((!self2.interrupt || size4 < 2) && (self2.containerState.marker ? code4 === self2.containerState.marker : code4 === codes.rightParenthesis || code4 === codes.dot)) {
      effects.exit(types2.listItemValue);
      return atMarker(code4);
    }
    return nok(code4);
  }
  function atMarker(code4) {
    ok(self2.containerState, "expected state");
    ok(code4 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types2.listItemMarker);
    effects.consume(code4);
    effects.exit(types2.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code4;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code4) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code4);
  }
  function otherPrefix(code4) {
    if (markdownSpace(code4)) {
      effects.enter(types2.listItemPrefixWhitespace);
      effects.consume(code4);
      effects.exit(types2.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code4);
  }
  function endOfPrefix(code4) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types2.listItemPrefix), true).length;
    return ok3(code4);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code4) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types2.listItemIndent,
      self2.containerState.size + 1
    )(code4);
  }
  function notBlank(code4) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code4)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code4);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code4);
  }
  function notInCurrentItem(code4) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list2, ok3, nok),
      types2.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code4);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types2.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code4) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types2.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code4) : nok(code4);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types2.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code4) && tail && tail[1].type === types2.listItemPrefixWhitespace ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index4 = events.length;
  let content3;
  let text7;
  let definition3;
  while (index4--) {
    if (events[index4][0] === "enter") {
      if (events[index4][1].type === types2.content) {
        content3 = index4;
        break;
      }
      if (events[index4][1].type === types2.paragraph) {
        text7 = index4;
      }
    } else {
      if (events[index4][1].type === types2.content) {
        events.splice(index4, 1);
      }
      if (!definition3 && events[index4][1].type === types2.definition) {
        definition3 = index4;
      }
    }
  }
  ok(text7 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  const heading3 = {
    type: types2.setextHeading,
    start: Object.assign({}, events[text7][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text7][1].type = types2.setextHeadingText;
  if (definition3) {
    events.splice(text7, 0, ["enter", heading3, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition3][1].end);
  } else {
    events[content3][1] = heading3;
  }
  events.push(["exit", heading3, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start2;
  function start2(code4) {
    let index4 = self2.events.length;
    let paragraph3;
    ok(
      code4 === codes.dash || code4 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index4--) {
      if (self2.events[index4][1].type !== types2.lineEnding && self2.events[index4][1].type !== types2.linePrefix && self2.events[index4][1].type !== types2.content) {
        paragraph3 = self2.events[index4][1].type === types2.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
      effects.enter(types2.setextHeadingLine);
      marker = code4;
      return before(code4);
    }
    return nok(code4);
  }
  function before(code4) {
    effects.enter(types2.setextHeadingLineSequence);
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      return inside;
    }
    effects.exit(types2.setextHeadingLineSequence);
    return markdownSpace(code4) ? factorySpace(effects, after, types2.lineSuffix)(code4) : after(code4);
  }
  function after(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types2.setextHeadingLine);
      return ok3(code4);
    }
    return nok(code4);
  }
}

// node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types2.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code4) {
    ok(
      code4 === codes.eof || markdownLineEnding(code4),
      "expected eol or eof"
    );
    if (code4 === codes.eof) {
      effects.consume(code4);
      return;
    }
    effects.enter(types2.lineEndingBlank);
    effects.consume(code4);
    effects.exit(types2.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code4) {
    ok(
      code4 === codes.eof || markdownLineEnding(code4),
      "expected eol or eof"
    );
    if (code4 === codes.eof) {
      effects.consume(code4);
      return;
    }
    effects.enter(types2.lineEnding);
    effects.consume(code4);
    effects.exit(types2.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text3 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text7 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code4) {
      return atBreak(code4) ? text7(code4) : notText(code4);
    }
    function notText(code4) {
      if (code4 === codes.eof) {
        effects.consume(code4);
        return;
      }
      effects.enter(types2.data);
      effects.consume(code4);
      return data2;
    }
    function data2(code4) {
      if (atBreak(code4)) {
        effects.exit(types2.data);
        return text7(code4);
      }
      effects.consume(code4);
      return data2;
    }
    function atBreak(code4) {
      if (code4 === codes.eof) {
        return true;
      }
      const list5 = constructs2[code4];
      let index4 = -1;
      if (list5) {
        ok(Array.isArray(list5), "expected `disable.null` to be populated");
        while (++index4 < list5.length) {
          const item2 = list5[index4];
          if (!item2.previous || item2.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index4 = -1;
    let enter;
    while (++index4 <= events.length) {
      if (enter === void 0) {
        if (events[index4] && events[index4][1].type === types2.data) {
          enter = index4;
          index4++;
        }
      } else if (!events[index4] || events[index4][1].type !== types2.data) {
        if (index4 !== enter + 2) {
          events[enter][1].end = events[index4 - 1][1].end;
          events.splice(enter + 2, index4 - enter - 2);
          index4 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types2.lineEnding) && events[eventIndex - 1][1].type === types2.data) {
      const data2 = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data2);
      let index4 = chunks.length;
      let bufferIndex = -1;
      let size4 = 0;
      let tabs;
      while (index4--) {
        const chunk = chunks[index4];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size4++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size4++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index4++;
          break;
        }
      }
      if (size4) {
        const token = {
          type: eventIndex === events.length || tabs || size4 < constants.hardBreakPrefixSizeMin ? types2.lineSuffix : types2.hardBreakTrailing,
          start: {
            line: data2.end.line,
            column: data2.end.column - size4,
            offset: data2.end.offset - size4,
            _index: data2.start._index + index4,
            _bufferIndex: index4 ? bufferIndex : data2.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data2.end)
        };
        data2.end = Object.assign({}, token.start);
        if (data2.start.offset === data2.end.offset) {
          Object.assign(data2, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser(), 1);
var debug2 = (0, import_debug.default)("micromark");
function createTokenizer(parser2, initialize, from2) {
  let point3 = Object.assign(
    from2 ? Object.assign({}, from2) : { line: 1, column: 1, offset: 0 },
    { _index: 0, _bufferIndex: -1 }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit3,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    previous: codes.eof,
    code: codes.eof,
    containerState: {},
    events: [],
    parser: parser2,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state2 = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice2) {
    chunks = push(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line, column, offset: offset5, _index, _bufferIndex } = point3;
    return { line, column, offset: offset5, _index, _bufferIndex };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug2("position: define skip: `%j`", point3);
  }
  function main() {
    let chunkIndex;
    while (point3._index < chunks.length) {
      const chunk = chunks[point3._index];
      if (typeof chunk === "string") {
        chunkIndex = point3._index;
        if (point3._bufferIndex < 0) {
          point3._bufferIndex = 0;
        }
        while (point3._index === chunkIndex && point3._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point3._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code4) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug2("main: passing `%s` to %s", code4, state2 && state2.name);
    expectedCode = code4;
    ok(typeof state2 === "function", "expected state");
    state2 = state2(code4);
  }
  function consume(code4) {
    ok(code4 === expectedCode, "expected given code to equal expected code");
    debug2("consume: `%s`", code4);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code4 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code4)) {
      point3.line++;
      point3.column = 1;
      point3.offset += code4 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug2("position: after eol: `%j`", point3);
    } else if (code4 !== codes.virtualSpace) {
      point3.column++;
      point3.offset++;
    }
    if (point3._bufferIndex < 0) {
      point3._index++;
    } else {
      point3._bufferIndex++;
      if (point3._bufferIndex === chunks[point3._index].length) {
        point3._bufferIndex = -1;
        point3._index++;
      }
    }
    context.previous = code4;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug2("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now();
    ok(type === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug2("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map6) {
        return start2;
        function start2(code4) {
          const def = code4 !== null && map6[code4];
          const all2 = code4 !== null && map6.null;
          const list5 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list5)(code4);
        }
      }
      function handleListOfConstructs(list5) {
        listOfConstructs = list5;
        constructIndex = 0;
        if (list5.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list5[constructIndex]);
      }
      function handleConstruct(construct) {
        return start2;
        function start2(code4) {
          info = store2();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code4);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code4);
        }
      }
      function ok3(code4) {
        ok(code4 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code4) {
        ok(code4 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from3) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from3,
        context.events.length - from3,
        construct.resolve(context.events.slice(from3), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store2() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { restore, from: startEventsIndex };
    function restore() {
      point3 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug2("position: restore: `%j`", point3);
    }
  }
  function accountForPotentialSkip() {
    if (point3.line in columnStart && point3.column < 2) {
      point3.column = columnStart[point3.line];
      point3.offset += columnStart[point3.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index4 = -1;
  const result = [];
  let atTab;
  while (++index4 < chunks.length) {
    const chunk = chunks[index4];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document4,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text4
});
var document4 = {
  [codes.asterisk]: list2,
  [codes.plusSign]: list2,
  [codes.dash]: list2,
  [codes.digit0]: list2,
  [codes.digit1]: list2,
  [codes.digit2]: list2,
  [codes.digit3]: list2,
  [codes.digit4]: list2,
  [codes.digit5]: list2,
  [codes.digit6]: list2,
  [codes.digit7]: list2,
  [codes.digit8]: list2,
  [codes.digit9]: list2,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak,
  [codes.dash]: [setextUnderline, thematicBreak],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text4 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser2 = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create3(content),
    document: create3(document3),
    flow: create3(flow),
    string: create3(string),
    text: create3(text3)
  };
  return parser2;
  function create3(initial) {
    return creator;
    function creator(from2) {
      return createTokenizer(parser2, initial, from2);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match2;
    let next;
    let startPosition;
    let endPosition;
    let code4;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start2) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match2 = search.exec(value);
      endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
      code4 = value.charCodeAt(endPosition);
      if (!match2) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code4 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code4) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer) chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $2.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point3) {
  return index3(point3 && point3.line) + ":" + index3(point3 && point3.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index3(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config3 = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link3),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading3),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image3),
      label: buffer,
      link: opener(link3),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list5, onenterlistordered),
      listUnordered: opener(list5),
      paragraph: opener(paragraph3),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading3),
      strong: opener(strong3),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config3, (options || {}).mdastExtensions || []);
  const data2 = {};
  return compile2;
  function compile2(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config: config3,
      enter,
      exit: exit3,
      buffer,
      resume,
      data: data2
    };
    const listStack = [];
    let index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][1].type === types2.listOrdered || events[index4][1].type === types2.listUnordered) {
        if (events[index4][0] === "enter") {
          listStack.push(index4);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index4 = prepareList(events, tail, index4);
        }
      }
    }
    index4 = -1;
    while (++index4 < events.length) {
      const handler = config3[events[index4][0]];
      if (own.call(handler, events[index4][1].type)) {
        handler[events[index4][1].type].call(
          Object.assign(
            { sliceSerialize: events[index4][2].sliceSerialize },
            context
          ),
          events[index4][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point2(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index4 = -1;
    while (++index4 < config3.transforms.length) {
      tree = config3.transforms[index4](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start2, length) {
    let index4 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index4 <= length) {
      const event = events[index4];
      switch (event[1].type) {
        case types2.listUnordered:
        case types2.listOrdered:
        case types2.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types2.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index4;
            }
            atMarker = void 0;
          }
          break;
        }
        case types2.linePrefix:
        case types2.listItemValue:
        case types2.listItemMarker:
        case types2.listItemPrefix:
        case types2.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types2.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types2.listUnordered || event[1].type === types2.listOrdered)) {
        if (listItem3) {
          let tailIndex = index4;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types2.lineEnding || tailEvent[1].type === types2.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types2.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types2.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types2.linePrefix || tailEvent[1].type === types2.blockQuotePrefix || tailEvent[1].type === types2.blockQuotePrefixWhitespace || tailEvent[1].type === types2.blockQuoteMarker || tailEvent[1].type === types2.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index4, 0, ["exit", listItem3, event[2]]);
          index4++;
          length++;
        }
        if (event[1].type === types2.listItemPrefix) {
          const item2 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          listItem3 = item2;
          events.splice(index4, 0, ["enter", item2, event[2]]);
          index4++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start2][1]._spread = listSpread;
    return length;
  }
  function opener(create3, and2) {
    return open;
    function open(token) {
      enter.call(this, create3(token), token);
      if (and2) and2.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node3, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings = parent.children;
    siblings.push(node3);
    this.stack.push(node3);
    this.tokenStack.push([token, errorHandler]);
    node3.position = {
      start: point2(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and2) {
    return close2;
    function close2(token) {
      if (and2) and2.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node3 = this.stack.pop();
    ok(node3, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): it’s not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok(node3.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node3.position, "expected `position` to be defined");
    node3.position.end = point2(token.end);
  }
  function resume() {
    return toString2(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "code", "expected code on stack");
    node3.lang = data3;
  }
  function onexitcodefencedfencemeta() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "code", "expected code on stack");
    node3.meta = data3;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "code", "expected code on stack");
    node3.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "code", "expected code on stack");
    node3.value = data3.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "definition", "expected definition on stack");
    node3.label = label;
    node3.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "definition", "expected definition on stack");
    node3.title = data3;
  }
  function onexitdefinitiondestinationstring() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "definition", "expected definition on stack");
    node3.url = data3;
  }
  function onexitatxheadingsequence(token) {
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "heading", "expected heading on stack");
    if (!node3.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node3.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "heading", "expected heading on stack");
    node3.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok("children" in node3, "expected parent on stack");
    const siblings = node3.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text7();
      tail.position = {
        start: point2(token.start),
        // @ts-expect-error: we’ll add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point2(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config3.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "html", "expected html on stack");
    node3.value = data3;
  }
  function onexithtmltext() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "html", "expected html on stack");
    node3.value = data3;
  }
  function onexitcodetext() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "inlineCode", "expected inline code on stack");
    node3.value = data3;
  }
  function onexitlink() {
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node3.type += "Reference";
      node3.referenceType = referenceType;
      delete node3.url;
      delete node3.title;
    } else {
      delete node3.identifier;
      delete node3.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node3.type += "Reference";
      node3.referenceType = referenceType;
      delete node3.url;
      delete node3.title;
    } else {
      delete node3.identifier;
      delete node3.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(
      node3.type === "image" || node3.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node3.type === "link") {
      const children = fragment.children;
      node3.children = children;
    } else {
      node3.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(
      node3.type === "image" || node3.type === "link",
      "expected image or link on stack"
    );
    node3.url = data3;
  }
  function onexitresourcetitlestring() {
    const data3 = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(
      node3.type === "image" || node3.type === "link",
      "expected image or link on stack"
    );
    node3.title = data3;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(
      node3.type === "image" || node3.type === "link",
      "expected image reference or link reference on stack"
    );
    node3.label = label;
    node3.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data3 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data3,
        type === types2.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data3);
      ok(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "link", "expected link on stack");
    node3.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node3 = this.stack[this.stack.length - 1];
    ok(node3, "expected node on stack");
    ok(node3.type === "link", "expected link on stack");
    node3.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return { type: "emphasis", children: [] };
  }
  function heading3() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return { type: "break" };
  }
  function html2() {
    return { type: "html", value: "" };
  }
  function image3() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link3() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list5(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph3() {
    return { type: "paragraph", children: [] };
  }
  function strong3() {
    return { type: "strong", children: [] };
  }
  function text7() {
    return { type: "text", value: "" };
  }
  function thematicBreak3() {
    return { type: "thematicBreak" };
  }
}
function point2(d) {
  return { line: d.line, column: d.column, offset: d.offset };
}
function configure(combined, extensions) {
  let index4 = -1;
  while (++index4 < extensions.length) {
    const value = extensions[index4];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key3;
  for (key3 in extension2) {
    if (own.call(extension2, key3)) {
      switch (key3) {
        case "canContainEols": {
          const right = extension2[key3];
          if (right) {
            combined[key3].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key3];
          if (right) {
            combined[key3].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key3];
          if (right) {
            Object.assign(combined[key3], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// node_modules/ccount/index.js
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count2 = 0;
  let index4 = source.indexOf(character);
  while (index4 !== -1) {
    count2++;
    index4 = source.indexOf(character, index4 + character.length);
  }
  return count2;
}

// node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index4 = -1;
  while (++index4 < tests.length) {
    checks[index4] = convert(tests[index4]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index5 = -1;
    while (++index5 < checks.length) {
      if (checks[index5].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node3) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node3
    );
    let key3;
    for (key3 in check) {
      if (nodeAsRecord[key3] !== checkAsRecord[key3]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node3) {
    return node3 && node3.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index4, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index4 === "number" ? index4 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node3, index4, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node3 && typeof node3 === "object" ? node3 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit3, "name", {
        value: "node (" + color(node3.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit3;
    function visit3() {
      let result = empty2;
      let subresult;
      let offset5;
      let grandparents;
      if (!test || is2(node3, index4, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node3, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node3 && node3.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node3
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset5 = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset5 > -1 && offset5 < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset5];
            subresult = factory(child, offset5, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset5 = typeof subresult[1] === "number" ? subresult[1] : offset5 + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty2 : [value];
}

// node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree, list5, options) {
  const settings = options || {};
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list5);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node3, parents) {
    let index4 = -1;
    let grandparent;
    while (++index4 < parents.length) {
      const parent = parents[index4];
      const siblings = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings ? siblings.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node3, parents);
    }
  }
  function handler(node3, parents) {
    const parent = parents[parents.length - 1];
    const find = pairs[pairIndex][0];
    const replace3 = pairs[pairIndex][1];
    let start2 = 0;
    const siblings = parent.children;
    const index4 = siblings.indexOf(node3);
    let change = false;
    let nodes = [];
    find.lastIndex = 0;
    let match2 = find.exec(node3.value);
    while (match2) {
      const position2 = match2.index;
      const matchObject = {
        index: match2.index,
        input: match2.input,
        stack: [...parents, node3]
      };
      let value = replace3(...match2, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find.lastIndex = position2 + 1;
      } else {
        if (start2 !== position2) {
          nodes.push({
            type: "text",
            value: node3.value.slice(start2, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start2 = position2 + match2[0].length;
        change = true;
      }
      if (!find.global) {
        break;
      }
      match2 = find.exec(node3.value);
    }
    if (change) {
      if (start2 < node3.value.length) {
        nodes.push({ type: "text", value: node3.value.slice(start2) });
      }
      parent.children.splice(index4, 1, ...nodes);
    } else {
      nodes = [node3];
    }
    return index4 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list5 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index4 = -1;
  while (++index4 < list5.length) {
    const tuple = list5[index4];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find) {
  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
}
function toFunction(replace3) {
  return typeof replace3 === "function" ? replace3 : function() {
    return replace3;
  };
}

// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "link");
  node3.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_, protocol, domain2, path3, match2) {
  let prefix = "";
  if (!previous2(match2)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path3);
  if (!parts[0]) return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match2) {
  if (
    // Not an expected previous character.
    !previous2(match2, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous2(match2, email) {
  const code4 = match2.input.charCodeAt(match2.index - 1);
  return (match2.index === 0 || unicodeWhitespace(code4) || unicodePunctuation(code4)) && (!email || code4 !== 47);
}

// node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js
var wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: true };
var domain = { tokenize: tokenizeDomain, partial: true };
var path2 = { tokenize: tokenizePath, partial: true };
var trail = { tokenize: tokenizeTrail, partial: true };
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = { tokenize: tokenizeWwwAutolink, previous: previousWww };
var protocolAutolink = {
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = { tokenize: tokenizeEmailAutolink, previous: previousEmail };
var text5 = {};
function gfmAutolinkLiteral() {
  return { text: text5 };
}
var code2 = codes.digit0;
while (code2 < codes.leftCurlyBrace) {
  text5[code2] = emailAutolink;
  code2++;
  if (code2 === codes.colon) code2 = codes.uppercaseA;
  else if (code2 === codes.leftSquareBracket) code2 = codes.lowercaseA;
}
text5[codes.plusSign] = emailAutolink;
text5[codes.dash] = emailAutolink;
text5[codes.dot] = emailAutolink;
text5[codes.underscore] = emailAutolink;
text5[codes.uppercaseH] = [emailAutolink, protocolAutolink];
text5[codes.lowercaseH] = [emailAutolink, protocolAutolink];
text5[codes.uppercaseW] = [emailAutolink, wwwAutolink];
text5[codes.lowercaseW] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  const self2 = this;
  let dot;
  let data2;
  return start2;
  function start2(code4) {
    if (!gfmAtext(code4) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code4);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code4);
  }
  function atext(code4) {
    if (gfmAtext(code4)) {
      effects.consume(code4);
      return atext;
    }
    if (code4 === codes.atSign) {
      effects.consume(code4);
      return emailDomain;
    }
    return nok(code4);
  }
  function emailDomain(code4) {
    if (code4 === codes.dot) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code4);
    }
    if (code4 === codes.dash || code4 === codes.underscore || asciiAlphanumeric(code4)) {
      data2 = true;
      effects.consume(code4);
      return emailDomain;
    }
    return emailDomainAfter(code4);
  }
  function emailDomainDot(code4) {
    effects.consume(code4);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code4) {
    if (data2 && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code4);
    }
    return nok(code4);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code4) {
    if (code4 !== codes.uppercaseW && code4 !== codes.lowercaseW || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code4);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path2, wwwAfter), nok),
      nok
    )(code4);
  }
  function wwwAfter(code4) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code4);
  }
}
function tokenizeProtocolAutolink(effects, ok3, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code4) {
    if ((code4 === codes.uppercaseH || code4 === codes.lowercaseH) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code4);
      effects.consume(code4);
      return protocolPrefixInside;
    }
    return nok(code4);
  }
  function protocolPrefixInside(code4) {
    if (asciiAlpha(code4) && buffer.length < 5) {
      buffer += String.fromCodePoint(code4);
      effects.consume(code4);
      return protocolPrefixInside;
    }
    if (code4 === codes.colon) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code4);
        return protocolSlashesInside;
      }
    }
    return nok(code4);
  }
  function protocolSlashesInside(code4) {
    if (code4 === codes.slash) {
      effects.consume(code4);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code4);
  }
  function afterProtocol(code4) {
    return code4 === codes.eof || asciiControl(code4) || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || unicodePunctuation(code4) ? nok(code4) : effects.attempt(domain, effects.attempt(path2, protocolAfter), nok)(code4);
  }
  function protocolAfter(code4) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code4);
  }
}
function tokenizeWwwPrefix(effects, ok3, nok) {
  let size4 = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code4) {
    if ((code4 === codes.uppercaseW || code4 === codes.lowercaseW) && size4 < 3) {
      size4++;
      effects.consume(code4);
      return wwwPrefixInside;
    }
    if (code4 === codes.dot && size4 === 3) {
      effects.consume(code4);
      return wwwPrefixAfter;
    }
    return nok(code4);
  }
  function wwwPrefixAfter(code4) {
    return code4 === codes.eof ? nok(code4) : ok3(code4);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code4) {
    if (code4 === codes.dot || code4 === codes.underscore) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code4);
    }
    if (code4 === codes.eof || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || code4 !== codes.dash && unicodePunctuation(code4)) {
      return domainAfter(code4);
    }
    seen = true;
    effects.consume(code4);
    return domainInside;
  }
  function domainAtPunctuation(code4) {
    if (code4 === codes.underscore) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code4);
    return domainInside;
  }
  function domainAfter(code4) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code4);
    }
    return ok3(code4);
  }
}
function tokenizePath(effects, ok3) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code4) {
    if (code4 === codes.leftParenthesis) {
      sizeOpen++;
      effects.consume(code4);
      return pathInside;
    }
    if (code4 === codes.rightParenthesis && sizeClose < sizeOpen) {
      return pathAtPunctuation(code4);
    }
    if (code4 === codes.exclamationMark || code4 === codes.quotationMark || code4 === codes.ampersand || code4 === codes.apostrophe || code4 === codes.rightParenthesis || code4 === codes.asterisk || code4 === codes.comma || code4 === codes.dot || code4 === codes.colon || code4 === codes.semicolon || code4 === codes.lessThan || code4 === codes.questionMark || code4 === codes.rightSquareBracket || code4 === codes.underscore || code4 === codes.tilde) {
      return effects.check(trail, ok3, pathAtPunctuation)(code4);
    }
    if (code4 === codes.eof || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      return ok3(code4);
    }
    effects.consume(code4);
    return pathInside;
  }
  function pathAtPunctuation(code4) {
    if (code4 === codes.rightParenthesis) {
      sizeClose++;
    }
    effects.consume(code4);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok3, nok) {
  return trail2;
  function trail2(code4) {
    if (code4 === codes.exclamationMark || code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.rightParenthesis || code4 === codes.asterisk || code4 === codes.comma || code4 === codes.dot || code4 === codes.colon || code4 === codes.semicolon || code4 === codes.questionMark || code4 === codes.underscore || code4 === codes.tilde) {
      effects.consume(code4);
      return trail2;
    }
    if (code4 === codes.ampersand) {
      effects.consume(code4);
      return trailCharRefStart;
    }
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code4 === codes.lessThan || // So is whitespace.
      code4 === codes.eof || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)
    ) {
      return ok3(code4);
    }
    return nok(code4);
  }
  function trailBracketAfter(code4) {
    if (code4 === codes.eof || code4 === codes.leftParenthesis || code4 === codes.leftSquareBracket || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      return ok3(code4);
    }
    return trail2(code4);
  }
  function trailCharRefStart(code4) {
    return asciiAlpha(code4) ? trailCharRefInside(code4) : nok(code4);
  }
  function trailCharRefInside(code4) {
    if (code4 === codes.semicolon) {
      effects.consume(code4);
      return trail2;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return trailCharRefInside;
    }
    return nok(code4);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    effects.consume(code4);
    return after;
  }
  function after(code4) {
    return asciiAlphanumeric(code4) ? nok(code4) : ok3(code4);
  }
}
function previousWww(code4) {
  return code4 === codes.eof || code4 === codes.leftParenthesis || code4 === codes.asterisk || code4 === codes.underscore || code4 === codes.leftSquareBracket || code4 === codes.rightSquareBracket || code4 === codes.tilde || markdownLineEndingOrSpace(code4);
}
function previousProtocol(code4) {
  return !asciiAlpha(code4);
}
function previousEmail(code4) {
  return !(code4 === codes.slash || gfmAtext(code4));
}
function gfmAtext(code4) {
  return code4 === codes.plusSign || code4 === codes.dash || code4 === codes.dot || code4 === codes.underscore || asciiAlphanumeric(code4);
}
function previousUnbalanced(events) {
  let index4 = events.length;
  let result = false;
  while (index4--) {
    const token = events[index4][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node3, _, state2, info) {
  const tracker = state2.createTracker(info);
  const exit3 = state2.enter("strikethrough");
  let value = tracker.move("~~");
  value += state2.containerPhrasing(node3, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit3();
  return value;
}
function peekDelete() {
  return "~";
}

// node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer3 = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: { [codes.tilde]: tokenizer3 },
    insideSpan: { null: [tokenizer3] },
    attentionMarkers: { null: [codes.tilde] }
  };
  function resolveAllStrikethrough(events, context) {
    let index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][0] === "enter" && events[index4][1].type === "strikethroughSequenceTemporary" && events[index4][1]._close) {
        let open = index4;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index4][1].end.offset - events[index4][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index4][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index4][1].end)
            };
            const text7 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index4][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text7, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events.slice(open + 1, index4), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text7, context],
              ["enter", events[index4][1], context],
              ["exit", events[index4][1], context],
              ["exit", strikethrough, context]
            ]);
            splice(events, open - 1, index4 - open + 3, nextEvents);
            index4 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][1].type === "strikethroughSequenceTemporary") {
        events[index4][1].type = types2.data;
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous3 = this.previous;
    const events = this.events;
    let size4 = 0;
    return start2;
    function start2(code4) {
      ok(code4 === codes.tilde, "expected `~`");
      if (previous3 === codes.tilde && events[events.length - 1][1].type !== types2.characterEscape) {
        return nok(code4);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code4);
    }
    function more(code4) {
      const before = classifyCharacter(previous3);
      if (code4 === codes.tilde) {
        if (size4 > 1) return nok(code4);
        effects.consume(code4);
        size4++;
        return more;
      }
      if (size4 < 2 && !single) return nok(code4);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code4);
      token._open = !after || after === constants.attentionSideAfter && Boolean(before);
      token._close = !before || before === constants.attentionSideAfter && Boolean(after);
      return ok3(code4);
    }
  }
}

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift4 = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac3 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i2 = 0; i2 < 10; i2++) base[48 + i2] = base[96 + i2] = String(i2);
var i2;
for (i2 = 1; i2 <= 24; i2++) base[i2 + 111] = "F" + i2;
var i2;
for (i2 = 65; i2 <= 90; i2++) {
  base[i2] = String.fromCharCode(i2 + 32);
  shift4[i2] = String.fromCharCode(i2);
}
var i2;
for (code4 in base) if (!shift4.hasOwnProperty(code4)) shift4[code4] = base[code4];
var code4;
function keyName(event) {
  var ignoreKey = mac3 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift4 : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc") name2 = "Escape";
  if (name2 == "Del") name2 = "Delete";
  if (name2 == "Left") name2 = "ArrowLeft";
  if (name2 == "Up") name2 = "ArrowUp";
  if (name2 == "Right") name2 = "ArrowRight";
  if (name2 == "Down") name2 = "ArrowDown";
  return name2;
}

// node_modules/prosemirror-keymap/dist/index.js
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name2) {
  let parts = name2.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift5, meta;
  for (let i2 = 0; i2 < parts.length - 1; i2++) {
    let mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift5 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac4)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift5)
    result = "Shift-" + result;
  return result;
}
function normalize(map6) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map6)
    copy2[normalizeKeyName(prop)] = map6[prop];
  return copy2;
}
function modifiers(name2, event, shift5 = true) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift5 && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map6 = normalize(bindings);
  return function(view, event) {
    let name2 = keyName(event), baseName, direct = map6[modifiers(name2, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name2.length == 1 && name2 != " ") {
      if (event.shiftKey) {
        let noShift = map6[modifiers(name2, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name2.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name2) {
        let fromCode = map6[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// node_modules/prosemirror-tables/dist/index.js
var readFromCache;
var addToCache;
if (typeof WeakMap != "undefined") {
  let cache = /* @__PURE__ */ new WeakMap();
  readFromCache = (key3) => cache.get(key3);
  addToCache = (key3, value) => {
    cache.set(key3, value);
    return value;
  };
} else {
  const cache = [];
  const cacheSize = 10;
  let cachePos = 0;
  readFromCache = (key3) => {
    for (let i2 = 0; i2 < cache.length; i2 += 2)
      if (cache[i2] == key3)
        return cache[i2 + 1];
  };
  addToCache = (key3, value) => {
    if (cachePos == cacheSize)
      cachePos = 0;
    cache[cachePos++] = key3;
    return cache[cachePos++] = value;
  };
}
var TableMap = class {
  constructor(width, height, map6, problems) {
    this.width = width;
    this.height = height;
    this.map = map6;
    this.problems = problems;
  }
  // Find the dimensions of the cell at the given position.
  findCell(pos) {
    for (let i2 = 0; i2 < this.map.length; i2++) {
      const curPos = this.map[i2];
      if (curPos != pos)
        continue;
      const left = i2 % this.width;
      const top = i2 / this.width | 0;
      let right = left + 1;
      let bottom = top + 1;
      for (let j = 1; right < this.width && this.map[i2 + j] == curPos; j++) {
        right++;
      }
      for (let j = 1; bottom < this.height && this.map[i2 + this.width * j] == curPos; j++) {
        bottom++;
      }
      return { left, top, right, bottom };
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(pos) {
    for (let i2 = 0; i2 < this.map.length; i2++) {
      if (this.map[i2] == pos) {
        return i2 % this.width;
      }
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(pos, axis, dir) {
    const { left, right, top, bottom } = this.findCell(pos);
    if (axis == "horiz") {
      if (dir < 0 ? left == 0 : right == this.width)
        return null;
      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
    } else {
      if (dir < 0 ? top == 0 : bottom == this.height)
        return null;
      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
    }
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(a, b) {
    const {
      left: leftA,
      right: rightA,
      top: topA,
      bottom: bottomA
    } = this.findCell(a);
    const {
      left: leftB,
      right: rightB,
      top: topB,
      bottom: bottomB
    } = this.findCell(b);
    return {
      left: Math.min(leftA, leftB),
      top: Math.min(topA, topB),
      right: Math.max(rightA, rightB),
      bottom: Math.max(bottomA, bottomB)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(rect) {
    const result = [];
    const seen = {};
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const index4 = row * this.width + col;
        const pos = this.map[index4];
        if (seen[pos])
          continue;
        seen[pos] = true;
        if (col == rect.left && col && this.map[index4 - 1] == pos || row == rect.top && row && this.map[index4 - this.width] == pos) {
          continue;
        }
        result.push(pos);
      }
    }
    return result;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(row, col, table3) {
    for (let i2 = 0, rowStart = 0; ; i2++) {
      const rowEnd = rowStart + table3.child(i2).nodeSize;
      if (i2 == row) {
        let index4 = col + row * this.width;
        const rowEndIndex = (row + 1) * this.width;
        while (index4 < rowEndIndex && this.map[index4] < rowStart)
          index4++;
        return index4 == rowEndIndex ? rowEnd - 1 : this.map[index4];
      }
      rowStart = rowEnd;
    }
  }
  // Find the table map for the given table node.
  static get(table3) {
    return readFromCache(table3) || addToCache(table3, computeMap(table3));
  }
};
function computeMap(table3) {
  if (table3.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + table3.type.name);
  const width = findWidth(table3), height = table3.childCount;
  const map6 = [];
  let mapPos = 0;
  let problems = null;
  const colWidths = [];
  for (let i2 = 0, e3 = width * height; i2 < e3; i2++)
    map6[i2] = 0;
  for (let row = 0, pos = 0; row < height; row++) {
    const rowNode = table3.child(row);
    pos++;
    for (let i2 = 0; ; i2++) {
      while (mapPos < map6.length && map6[mapPos] != 0)
        mapPos++;
      if (i2 == rowNode.childCount)
        break;
      const cellNode = rowNode.child(i2);
      const { colspan, rowspan, colwidth } = cellNode.attrs;
      for (let h = 0; h < rowspan; h++) {
        if (h + row >= height) {
          (problems || (problems = [])).push({
            type: "overlong_rowspan",
            pos,
            n: rowspan - h
          });
          break;
        }
        const start2 = mapPos + h * width;
        for (let w = 0; w < colspan; w++) {
          if (map6[start2 + w] == 0)
            map6[start2 + w] = pos;
          else
            (problems || (problems = [])).push({
              type: "collision",
              row,
              pos,
              n: colspan - w
            });
          const colW = colwidth && colwidth[w];
          if (colW) {
            const widthIndex = (start2 + w) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    const expectedPos = (row + 1) * width;
    let missing = 0;
    while (mapPos < expectedPos)
      if (map6[mapPos++] == 0)
        missing++;
    if (missing)
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    pos++;
  }
  const tableMap = new TableMap(width, height, map6, problems);
  let badWidths = false;
  for (let i2 = 0; !badWidths && i2 < colWidths.length; i2 += 2)
    if (colWidths[i2] != null && colWidths[i2 + 1] < height)
      badWidths = true;
  if (badWidths)
    findBadColWidths(tableMap, colWidths, table3);
  return tableMap;
}
function findWidth(table3) {
  let width = -1;
  let hasRowSpan = false;
  for (let row = 0; row < table3.childCount; row++) {
    const rowNode = table3.child(row);
    let rowWidth = 0;
    if (hasRowSpan)
      for (let j = 0; j < row; j++) {
        const prevRow = table3.child(j);
        for (let i2 = 0; i2 < prevRow.childCount; i2++) {
          const cell2 = prevRow.child(i2);
          if (j + cell2.attrs.rowspan > row)
            rowWidth += cell2.attrs.colspan;
        }
      }
    for (let i2 = 0; i2 < rowNode.childCount; i2++) {
      const cell2 = rowNode.child(i2);
      rowWidth += cell2.attrs.colspan;
      if (cell2.attrs.rowspan > 1)
        hasRowSpan = true;
    }
    if (width == -1)
      width = rowWidth;
    else if (width != rowWidth)
      width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map6, colWidths, table3) {
  if (!map6.problems)
    map6.problems = [];
  const seen = {};
  for (let i2 = 0; i2 < map6.map.length; i2++) {
    const pos = map6.map[i2];
    if (seen[pos])
      continue;
    seen[pos] = true;
    const node3 = table3.nodeAt(pos);
    if (!node3) {
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    let updated = null;
    const attrs = node3.attrs;
    for (let j = 0; j < attrs.colspan; j++) {
      const col = (i2 + j) % map6.width;
      const colWidth = colWidths[col * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))
        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
    }
    if (updated)
      map6.problems.unshift({
        type: "colwidth mismatch",
        pos,
        colwidth: updated
      });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth)
    return attrs.colwidth.slice();
  const result = [];
  for (let i2 = 0; i2 < attrs.colspan; i2++)
    result.push(0);
  return result;
}
function tableNodeTypes(schema) {
  let result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (const name2 in schema.nodes) {
      const type = schema.nodes[name2], role = type.spec.tableRole;
      if (role)
        result[role] = type;
    }
  }
  return result;
}
var tableEditingKey = new PluginKey("selectingCells");
function cellAround($pos) {
  for (let d = $pos.depth - 1; d > 0; d--)
    if ($pos.node(d).type.spec.tableRole == "row")
      return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function isInTable(state2) {
  const $head = state2.selection.$head;
  for (let d = $head.depth; d > 0; d--)
    if ($head.node(d).type.spec.tableRole == "row")
      return true;
  return false;
}
function selectionCell(state2) {
  const sel = state2.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  const $cell = cellAround(sel.$head) || cellNear(sel.$head);
  if ($cell) {
    return $cell;
  }
  throw new RangeError(`No cell found around position ${sel.head}`);
}
function cellNear($pos) {
  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    const role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos);
  }
  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
    const role = before.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos - before.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  const table3 = $pos.node(-1);
  const map6 = TableMap.get(table3);
  const tableStart = $pos.start(-1);
  const moved = map6.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n2 = 1) {
  const result = { ...attrs, colspan: attrs.colspan - n2 };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n2);
    if (!result.colwidth.some((w) => w > 0))
      result.colwidth = null;
  }
  return result;
}
function addColSpan(attrs, pos, n2 = 1) {
  const result = { ...attrs, colspan: attrs.colspan + n2 };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (let i2 = 0; i2 < n2; i2++)
      result.colwidth.splice(pos, 0, 0);
  }
  return result;
}
function columnIsHeader(map6, table3, col) {
  const headerCell = tableNodeTypes(table3.type.schema).header_cell;
  for (let row = 0; row < map6.height; row++)
    if (table3.nodeAt(map6.map[col + row * map6.width]).type != headerCell)
      return false;
  return true;
}
var CellSelection = class _CellSelection extends Selection {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor($anchorCell, $headCell = $anchorCell) {
    const table3 = $anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = $anchorCell.start(-1);
    const rect = map6.rectBetween(
      $anchorCell.pos - tableStart,
      $headCell.pos - tableStart
    );
    const doc4 = $anchorCell.node(0);
    const cells = map6.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);
    cells.unshift($headCell.pos - tableStart);
    const ranges = cells.map((pos) => {
      const cell2 = table3.nodeAt(pos);
      if (!cell2) {
        throw RangeError(`No cell with offset ${pos} found`);
      }
      const from2 = tableStart + pos + 1;
      return new SelectionRange(
        doc4.resolve(from2),
        doc4.resolve(from2 + cell2.content.size)
      );
    });
    super(ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  map(doc4, mapping) {
    const $anchorCell = doc4.resolve(mapping.map(this.$anchorCell.pos));
    const $headCell = doc4.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        return _CellSelection.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection())
        return _CellSelection.colSelection($anchorCell, $headCell);
      else
        return new _CellSelection($anchorCell, $headCell);
    }
    return TextSelection.between($anchorCell, $headCell);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const table3 = this.$anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = this.$anchorCell.start(-1);
    const rect = map6.rectBetween(
      this.$anchorCell.pos - tableStart,
      this.$headCell.pos - tableStart
    );
    const seen = {};
    const rows = [];
    for (let row = rect.top; row < rect.bottom; row++) {
      const rowContent = [];
      for (let index4 = row * map6.width + rect.left, col = rect.left; col < rect.right; col++, index4++) {
        const pos = map6.map[index4];
        if (seen[pos])
          continue;
        seen[pos] = true;
        const cellRect = map6.findCell(pos);
        let cell2 = table3.nodeAt(pos);
        if (!cell2) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const extraLeft = rect.left - cellRect.left;
        const extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          let attrs = cell2.attrs;
          if (extraLeft > 0) {
            attrs = removeColSpan(attrs, 0, extraLeft);
          }
          if (extraRight > 0) {
            attrs = removeColSpan(
              attrs,
              attrs.colspan - extraRight,
              extraRight
            );
          }
          if (cellRect.left < rect.left) {
            cell2 = cell2.type.createAndFill(attrs);
            if (!cell2) {
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(attrs)}`
              );
            }
          } else {
            cell2 = cell2.type.create(attrs, cell2.content);
          }
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          const attrs = {
            ...cell2.attrs,
            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
          };
          if (cellRect.top < rect.top) {
            cell2 = cell2.type.createAndFill(attrs);
          } else {
            cell2 = cell2.type.create(attrs, cell2.content);
          }
        }
        rowContent.push(cell2);
      }
      rows.push(table3.child(row).copy(Fragment2.from(rowContent)));
    }
    const fragment = this.isColSelection() && this.isRowSelection() ? table3 : rows;
    return new Slice(Fragment2.from(fragment), 1, 1);
  }
  replace(tr2, content3 = Slice.empty) {
    const mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      const { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
      tr2.replace(
        mapping.map($from.pos),
        mapping.map($to.pos),
        i2 ? Slice.empty : content3
      );
    }
    const sel = Selection.findFrom(
      tr2.doc.resolve(tr2.mapping.slice(mapFrom).map(this.to)),
      -1
    );
    if (sel)
      tr2.setSelection(sel);
  }
  replaceWith(tr2, node3) {
    this.replace(tr2, new Slice(Fragment2.from(node3), 0, 0));
  }
  forEachCell(f) {
    const table3 = this.$anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = this.$anchorCell.start(-1);
    const cells = map6.cellsInRect(
      map6.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      )
    );
    for (let i2 = 0; i2 < cells.length; i2++) {
      f(table3.nodeAt(cells[i2]), tableStart + cells[i2]);
    }
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const anchorTop = this.$anchorCell.index(-1);
    const headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0)
      return false;
    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection($anchorCell, $headCell = $anchorCell) {
    const table3 = $anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map6.findCell($anchorCell.pos - tableStart);
    const headRect = map6.findCell($headCell.pos - tableStart);
    const doc4 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        $anchorCell = doc4.resolve(tableStart + map6.map[anchorRect.left]);
      if (headRect.bottom < map6.height)
        $headCell = doc4.resolve(
          tableStart + map6.map[map6.width * (map6.height - 1) + headRect.right - 1]
        );
    } else {
      if (headRect.top > 0)
        $headCell = doc4.resolve(tableStart + map6.map[headRect.left]);
      if (anchorRect.bottom < map6.height)
        $anchorCell = doc4.resolve(
          tableStart + map6.map[map6.width * (map6.height - 1) + anchorRect.right - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const table3 = this.$anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = this.$anchorCell.start(-1);
    const anchorLeft = map6.colCount(this.$anchorCell.pos - tableStart);
    const headLeft = map6.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0)
      return false;
    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map6.width;
  }
  eq(other) {
    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection($anchorCell, $headCell = $anchorCell) {
    const table3 = $anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map6.findCell($anchorCell.pos - tableStart);
    const headRect = map6.findCell($headCell.pos - tableStart);
    const doc4 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        $anchorCell = doc4.resolve(
          tableStart + map6.map[anchorRect.top * map6.width]
        );
      if (headRect.right < map6.width)
        $headCell = doc4.resolve(
          tableStart + map6.map[map6.width * (headRect.top + 1) - 1]
        );
    } else {
      if (headRect.left > 0)
        $headCell = doc4.resolve(tableStart + map6.map[headRect.top * map6.width]);
      if (anchorRect.right < map6.width)
        $anchorCell = doc4.resolve(
          tableStart + map6.map[map6.width * (anchorRect.top + 1) - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(doc4, json) {
    return new _CellSelection(doc4.resolve(json.anchor), doc4.resolve(json.head));
  }
  static create(doc4, anchorCell, headCell = anchorCell) {
    return new _CellSelection(doc4.resolve(anchorCell), doc4.resolve(headCell));
  }
  getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  }
};
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = class _CellBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc4) {
    const $anchorCell = doc4.resolve(this.anchor), $headCell = doc4.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
      return new CellSelection($anchorCell, $headCell);
    else
      return Selection.near($headCell, 1);
  }
};
function drawCellSelection(state2) {
  if (!(state2.selection instanceof CellSelection))
    return null;
  const cells = [];
  state2.selection.forEachCell((node3, pos) => {
    cells.push(
      Decoration.node(pos, pos + node3.nodeSize, { class: "selectedCell" })
    );
  });
  return DecorationSet.create(state2.doc, cells);
}
function isCellBoundarySelection({ $from, $to }) {
  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)
    return false;
  let afterFrom = $from.pos;
  let beforeTo = $to.pos;
  let depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    if ($from.after(depth + 1) < $from.end(depth))
      break;
  for (let d = $to.depth; d >= 0; d--, beforeTo--)
    if ($to.before(d + 1) > $to.start(d))
      break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells({ $from, $to }) {
  let fromCellBoundaryNode;
  let toCellBoundaryNode;
  for (let i2 = $from.depth; i2 > 0; i2--) {
    const node3 = $from.node(i2);
    if (node3.type.spec.tableRole === "cell" || node3.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node3;
      break;
    }
  }
  for (let i2 = $to.depth; i2 > 0; i2--) {
    const node3 = $to.node(i2);
    if (node3.type.spec.tableRole === "cell" || node3.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node3;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state2, tr2, allowTableNodeSelection) {
  const sel = (tr2 || state2).selection;
  const doc4 = (tr2 || state2).doc;
  let normalize2;
  let role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize2 = CellSelection.create(doc4, sel.from);
    } else if (role == "row") {
      const $cell = doc4.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      const map6 = TableMap.get(sel.node);
      const start2 = sel.from + 1;
      const lastCell = start2 + map6.map[map6.width * map6.height - 1];
      normalize2 = CellSelection.create(doc4, start2 + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize2 = TextSelection.create(doc4, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize2 = TextSelection.create(doc4, sel.$from.start(), sel.$from.end());
  }
  if (normalize2)
    (tr2 || (tr2 = state2.tr)).setSelection(normalize2);
  return tr2;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset5, f) {
  const oldSize = old.childCount, curSize = cur.childCount;
  outer:
    for (let i2 = 0, j = 0; i2 < curSize; i2++) {
      const child = cur.child(i2);
      for (let scan = j, e3 = Math.min(oldSize, i2 + 3); scan < e3; scan++) {
        if (old.child(scan) == child) {
          j = scan + 1;
          offset5 += child.nodeSize;
          continue outer;
        }
      }
      f(child, offset5);
      if (j < oldSize && old.child(j).sameMarkup(child))
        changedDescendants(old.child(j), child, offset5 + 1, f);
      else
        child.nodesBetween(0, child.content.size, f, offset5 + 1);
      offset5 += child.nodeSize;
    }
}
function fixTables(state2, oldState) {
  let tr2;
  const check = (node3, pos) => {
    if (node3.type.spec.tableRole == "table")
      tr2 = fixTable(state2, node3, pos, tr2);
  };
  if (!oldState)
    state2.doc.descendants(check);
  else if (oldState.doc != state2.doc)
    changedDescendants(oldState.doc, state2.doc, 0, check);
  return tr2;
}
function fixTable(state2, table3, tablePos, tr2) {
  const map6 = TableMap.get(table3);
  if (!map6.problems)
    return tr2;
  if (!tr2)
    tr2 = state2.tr;
  const mustAdd = [];
  for (let i2 = 0; i2 < map6.height; i2++)
    mustAdd.push(0);
  for (let i2 = 0; i2 < map6.problems.length; i2++) {
    const prob = map6.problems[i2];
    if (prob.type == "collision") {
      const cell2 = table3.nodeAt(prob.pos);
      if (!cell2)
        continue;
      const attrs = cell2.attrs;
      for (let j = 0; j < attrs.rowspan; j++)
        mustAdd[prob.row + j] += prob.n;
      tr2.setNodeMarkup(
        tr2.mapping.map(tablePos + 1 + prob.pos),
        null,
        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
      );
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      const cell2 = table3.nodeAt(prob.pos);
      if (!cell2)
        continue;
      tr2.setNodeMarkup(tr2.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell2.attrs,
        rowspan: cell2.attrs.rowspan - prob.n
      });
    } else if (prob.type == "colwidth mismatch") {
      const cell2 = table3.nodeAt(prob.pos);
      if (!cell2)
        continue;
      tr2.setNodeMarkup(tr2.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell2.attrs,
        colwidth: prob.colwidth
      });
    }
  }
  let first, last;
  for (let i2 = 0; i2 < mustAdd.length; i2++)
    if (mustAdd[i2]) {
      if (first == null)
        first = i2;
      last = i2;
    }
  for (let i2 = 0, pos = tablePos + 1; i2 < map6.height; i2++) {
    const row = table3.child(i2);
    const end = pos + row.nodeSize;
    const add2 = mustAdd[i2];
    if (add2 > 0) {
      let role = "cell";
      if (row.firstChild) {
        role = row.firstChild.type.spec.tableRole;
      }
      const nodes = [];
      for (let j = 0; j < add2; j++) {
        const node3 = tableNodeTypes(state2.schema)[role].createAndFill();
        if (node3)
          nodes.push(node3);
      }
      const side = (i2 == 0 || first == i2 - 1) && last == i2 ? pos + 1 : end - 1;
      tr2.insert(tr2.mapping.map(side), nodes);
    }
    pos = end;
  }
  return tr2.setMeta(fixTablesKey, { fixTables: true });
}
function pastedCells(slice2) {
  if (!slice2.size)
    return null;
  let { content: content3, openStart, openEnd } = slice2;
  while (content3.childCount == 1 && (openStart > 0 && openEnd > 0 || content3.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content3 = content3.child(0).content;
  }
  const first = content3.child(0);
  const role = first.type.spec.tableRole;
  const schema = first.type.schema, rows = [];
  if (role == "row") {
    for (let i2 = 0; i2 < content3.childCount; i2++) {
      let cells = content3.child(i2).content;
      const left = i2 ? 0 : Math.max(0, openStart - 1);
      const right = i2 < content3.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right)
        cells = fitSlice(
          tableNodeTypes(schema).row,
          new Slice(cells, left, right)
        ).content;
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(
      openStart || openEnd ? fitSlice(
        tableNodeTypes(schema).row,
        new Slice(content3, openStart, openEnd)
      ).content : content3
    );
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  const widths = [];
  for (let i2 = 0; i2 < rows.length; i2++) {
    const row = rows[i2];
    for (let j = row.childCount - 1; j >= 0; j--) {
      const { rowspan, colspan } = row.child(j).attrs;
      for (let r2 = i2; r2 < i2 + rowspan; r2++)
        widths[r2] = (widths[r2] || 0) + colspan;
    }
  }
  let width = 0;
  for (let r2 = 0; r2 < widths.length; r2++)
    width = Math.max(width, widths[r2]);
  for (let r2 = 0; r2 < widths.length; r2++) {
    if (r2 >= rows.length)
      rows.push(Fragment2.empty);
    if (widths[r2] < width) {
      const empty5 = tableNodeTypes(schema).cell.createAndFill();
      const cells = [];
      for (let i2 = widths[r2]; i2 < width; i2++) {
        cells.push(empty5);
      }
      rows[r2] = rows[r2].append(Fragment2.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice2) {
  const node3 = nodeType.createAndFill();
  const tr2 = new Transform(node3).replace(0, node3.content.size, slice2);
  return tr2.doc;
}
function clipCells({ width, height, rows }, newWidth, newHeight) {
  if (width != newWidth) {
    const added = [];
    const newRows = [];
    for (let row = 0; row < rows.length; row++) {
      const frag = rows[row], cells = [];
      for (let col = added[row] || 0, i2 = 0; col < newWidth; i2++) {
        let cell2 = frag.child(i2 % frag.childCount);
        if (col + cell2.attrs.colspan > newWidth)
          cell2 = cell2.type.createChecked(
            removeColSpan(
              cell2.attrs,
              cell2.attrs.colspan,
              col + cell2.attrs.colspan - newWidth
            ),
            cell2.content
          );
        cells.push(cell2);
        col += cell2.attrs.colspan;
        for (let j = 1; j < cell2.attrs.rowspan; j++)
          added[row + j] = (added[row + j] || 0) + cell2.attrs.colspan;
      }
      newRows.push(Fragment2.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    const newRows = [];
    for (let row = 0, i2 = 0; row < newHeight; row++, i2++) {
      const cells = [], source = rows[i2 % height];
      for (let j = 0; j < source.childCount; j++) {
        let cell2 = source.child(j);
        if (row + cell2.attrs.rowspan > newHeight)
          cell2 = cell2.type.create(
            {
              ...cell2.attrs,
              rowspan: Math.max(1, newHeight - cell2.attrs.rowspan)
            },
            cell2.content
          );
        cells.push(cell2);
      }
      newRows.push(Fragment2.from(cells));
    }
    rows = newRows;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr2, map6, table3, start2, width, height, mapFrom) {
  const schema = tr2.doc.type.schema;
  const types4 = tableNodeTypes(schema);
  let empty5;
  let emptyHead;
  if (width > map6.width) {
    for (let row = 0, rowEnd = 0; row < map6.height; row++) {
      const rowNode = table3.child(row);
      rowEnd += rowNode.nodeSize;
      const cells = [];
      let add2;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types4.cell)
        add2 = empty5 || (empty5 = types4.cell.createAndFill());
      else
        add2 = emptyHead || (emptyHead = types4.header_cell.createAndFill());
      for (let i2 = map6.width; i2 < width; i2++)
        cells.push(add2);
      tr2.insert(tr2.mapping.slice(mapFrom).map(rowEnd - 1 + start2), cells);
    }
  }
  if (height > map6.height) {
    const cells = [];
    for (let i2 = 0, start22 = (map6.height - 1) * map6.width; i2 < Math.max(map6.width, width); i2++) {
      const header = i2 >= map6.width ? false : table3.nodeAt(map6.map[start22 + i2]).type == types4.header_cell;
      cells.push(
        header ? emptyHead || (emptyHead = types4.header_cell.createAndFill()) : empty5 || (empty5 = types4.cell.createAndFill())
      );
    }
    const emptyRow = types4.row.create(null, Fragment2.from(cells)), rows = [];
    for (let i2 = map6.height; i2 < height; i2++)
      rows.push(emptyRow);
    tr2.insert(tr2.mapping.slice(mapFrom).map(start2 + table3.nodeSize - 2), rows);
  }
  return !!(empty5 || emptyHead);
}
function isolateHorizontal(tr2, map6, table3, start2, left, right, top, mapFrom) {
  if (top == 0 || top == map6.height)
    return false;
  let found2 = false;
  for (let col = left; col < right; col++) {
    const index4 = top * map6.width + col, pos = map6.map[index4];
    if (map6.map[index4 - map6.width] == pos) {
      found2 = true;
      const cell2 = table3.nodeAt(pos);
      const { top: cellTop, left: cellLeft } = map6.findCell(pos);
      tr2.setNodeMarkup(tr2.mapping.slice(mapFrom).map(pos + start2), null, {
        ...cell2.attrs,
        rowspan: top - cellTop
      });
      tr2.insert(
        tr2.mapping.slice(mapFrom).map(map6.positionAt(top, cellLeft, table3)),
        cell2.type.createAndFill({
          ...cell2.attrs,
          rowspan: cellTop + cell2.attrs.rowspan - top
        })
      );
      col += cell2.attrs.colspan - 1;
    }
  }
  return found2;
}
function isolateVertical(tr2, map6, table3, start2, top, bottom, left, mapFrom) {
  if (left == 0 || left == map6.width)
    return false;
  let found2 = false;
  for (let row = top; row < bottom; row++) {
    const index4 = row * map6.width + left, pos = map6.map[index4];
    if (map6.map[index4 - 1] == pos) {
      found2 = true;
      const cell2 = table3.nodeAt(pos);
      const cellLeft = map6.colCount(pos);
      const updatePos = tr2.mapping.slice(mapFrom).map(pos + start2);
      tr2.setNodeMarkup(
        updatePos,
        null,
        removeColSpan(
          cell2.attrs,
          left - cellLeft,
          cell2.attrs.colspan - (left - cellLeft)
        )
      );
      tr2.insert(
        updatePos + cell2.nodeSize,
        cell2.type.createAndFill(
          removeColSpan(cell2.attrs, 0, left - cellLeft)
        )
      );
      row += cell2.attrs.rowspan - 1;
    }
  }
  return found2;
}
function insertCells(state2, dispatch, tableStart, rect, cells) {
  let table3 = tableStart ? state2.doc.nodeAt(tableStart - 1) : state2.doc;
  if (!table3) {
    throw new Error("No table found");
  }
  let map6 = TableMap.get(table3);
  const { top, left } = rect;
  const right = left + cells.width, bottom = top + cells.height;
  const tr2 = state2.tr;
  let mapFrom = 0;
  function recomp() {
    table3 = tableStart ? tr2.doc.nodeAt(tableStart - 1) : tr2.doc;
    if (!table3) {
      throw new Error("No table found");
    }
    map6 = TableMap.get(table3);
    mapFrom = tr2.mapping.maps.length;
  }
  if (growTable(tr2, map6, table3, tableStart, right, bottom, mapFrom))
    recomp();
  if (isolateHorizontal(tr2, map6, table3, tableStart, left, right, top, mapFrom))
    recomp();
  if (isolateHorizontal(tr2, map6, table3, tableStart, left, right, bottom, mapFrom))
    recomp();
  if (isolateVertical(tr2, map6, table3, tableStart, top, bottom, left, mapFrom))
    recomp();
  if (isolateVertical(tr2, map6, table3, tableStart, top, bottom, right, mapFrom))
    recomp();
  for (let row = top; row < bottom; row++) {
    const from2 = map6.positionAt(row, left, table3), to = map6.positionAt(row, right, table3);
    tr2.replace(
      tr2.mapping.slice(mapFrom).map(from2 + tableStart),
      tr2.mapping.slice(mapFrom).map(to + tableStart),
      new Slice(cells.rows[row - top], 0, 0)
    );
  }
  recomp();
  tr2.setSelection(
    new CellSelection(
      tr2.doc.resolve(tableStart + map6.positionAt(top, left, table3)),
      tr2.doc.resolve(tableStart + map6.positionAt(bottom - 1, right - 1, table3))
    )
  );
  dispatch(tr2);
}
var handleKeyDown = keydownHandler({
  ArrowLeft: arrow4("horiz", -1),
  ArrowRight: arrow4("horiz", 1),
  ArrowUp: arrow4("vert", -1),
  ArrowDown: arrow4("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  Backspace: deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  Delete: deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state2, dispatch, selection) {
  if (selection.eq(state2.selection))
    return false;
  if (dispatch)
    dispatch(state2.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow4(axis, dir) {
  return (state2, dispatch, view) => {
    if (!view)
      return false;
    const sel = state2.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(
        state2,
        dispatch,
        Selection.near(sel.$headCell, dir)
      );
    }
    if (axis != "horiz" && !sel.empty)
      return false;
    const end = atEndOfCell(view, axis, dir);
    if (end == null)
      return false;
    if (axis == "horiz") {
      return maybeSetSelection(
        state2,
        dispatch,
        Selection.near(state2.doc.resolve(sel.head + dir), dir)
      );
    } else {
      const $cell = state2.doc.resolve(end);
      const $next = nextCell($cell, axis, dir);
      let newSel;
      if ($next)
        newSel = Selection.near($next, 1);
      else if (dir < 0)
        newSel = Selection.near(state2.doc.resolve($cell.before(-1)), -1);
      else
        newSel = Selection.near(state2.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state2, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return (state2, dispatch, view) => {
    if (!view)
      return false;
    const sel = state2.selection;
    let cellSel;
    if (sel instanceof CellSelection) {
      cellSel = sel;
    } else {
      const end = atEndOfCell(view, axis, dir);
      if (end == null)
        return false;
      cellSel = new CellSelection(state2.doc.resolve(end));
    }
    const $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head)
      return false;
    return maybeSetSelection(
      state2,
      dispatch,
      new CellSelection(cellSel.$anchorCell, $head)
    );
  };
}
function deleteCellSelection(state2, dispatch) {
  const sel = state2.selection;
  if (!(sel instanceof CellSelection))
    return false;
  if (dispatch) {
    const tr2 = state2.tr;
    const baseContent = tableNodeTypes(state2.schema).cell.createAndFill().content;
    sel.forEachCell((cell2, pos) => {
      if (!cell2.content.eq(baseContent))
        tr2.replace(
          tr2.mapping.map(pos + 1),
          tr2.mapping.map(pos + cell2.nodeSize - 1),
          new Slice(baseContent, 0, 0)
        );
    });
    if (tr2.docChanged)
      dispatch(tr2);
  }
  return true;
}
function handleTripleClick2(view, pos) {
  const doc4 = view.state.doc, $cell = cellAround(doc4.resolve(pos));
  if (!$cell)
    return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _, slice2) {
  if (!isInTable(view.state))
    return false;
  let cells = pastedCells(slice2);
  const sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells)
      cells = {
        width: 1,
        height: 1,
        rows: [
          Fragment2.from(
            fitSlice(tableNodeTypes(view.state.schema).cell, slice2)
          )
        ]
      };
    const table3 = sel.$anchorCell.node(-1);
    const start2 = sel.$anchorCell.start(-1);
    const rect = TableMap.get(table3).rectBetween(
      sel.$anchorCell.pos - start2,
      sel.$headCell.pos - start2
    );
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start2, rect, cells);
    return true;
  } else if (cells) {
    const $cell = selectionCell(view.state);
    const start2 = $cell.start(-1);
    insertCells(
      view.state,
      view.dispatch,
      start2,
      TableMap.get($cell.node(-1)).findCell($cell.pos - start2),
      cells
    );
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  var _a;
  if (startEvent.ctrlKey || startEvent.metaKey)
    return;
  const startDOMCell = domInCell(view, startEvent.target);
  let $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    let $head = cellUnderMouse(view, event);
    const starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting)
        $head = $anchor2;
      else
        return;
    }
    const selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      const tr2 = view.state.tr.setSelection(selection);
      if (starting)
        tr2.setMeta(tableEditingKey, $anchor2.pos);
      view.dispatch(tr2);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move2);
    if (tableEditingKey.getState(view.state) != null)
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move2(_event) {
    const event = _event;
    const anchor = tableEditingKey.getState(view.state);
    let $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2)
        return stop();
    }
    if ($anchor2)
      setCellSelection($anchor2, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move2);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return null;
  const { $head } = view.state.selection;
  for (let d = $head.depth - 1; d >= 0; d--) {
    const parent = $head.node(d), index4 = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index4 != (dir < 0 ? 0 : parent.childCount))
      return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      const cellPos = $head.before(d);
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  const mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos)
    return null;
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
var columnResizingPluginKey = new PluginKey(
  "tableColumnResizing"
);
function selectedRect(state2) {
  const sel = state2.selection;
  const $pos = selectionCell(state2);
  const table3 = $pos.node(-1);
  const tableStart = $pos.start(-1);
  const map6 = TableMap.get(table3);
  const rect = sel instanceof CellSelection ? map6.rectBetween(
    sel.$anchorCell.pos - tableStart,
    sel.$headCell.pos - tableStart
  ) : map6.findCell($pos.pos - tableStart);
  return { ...rect, tableStart, map: map6, table: table3 };
}
function addColumn(tr2, { map: map6, tableStart, table: table3 }, col) {
  let refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map6, table3, col + refColumn)) {
    refColumn = col == 0 || col == map6.width ? null : 0;
  }
  for (let row = 0; row < map6.height; row++) {
    const index4 = row * map6.width + col;
    if (col > 0 && col < map6.width && map6.map[index4 - 1] == map6.map[index4]) {
      const pos = map6.map[index4];
      const cell2 = table3.nodeAt(pos);
      tr2.setNodeMarkup(
        tr2.mapping.map(tableStart + pos),
        null,
        addColSpan(cell2.attrs, col - map6.colCount(pos))
      );
      row += cell2.attrs.rowspan - 1;
    } else {
      const type = refColumn == null ? tableNodeTypes(table3.type.schema).cell : table3.nodeAt(map6.map[index4 + refColumn]).type;
      const pos = map6.positionAt(row, col, table3);
      tr2.insert(tr2.mapping.map(tableStart + pos), type.createAndFill());
    }
  }
  return tr2;
}
function addColumnAfter(state2, dispatch) {
  if (!isInTable(state2))
    return false;
  if (dispatch) {
    const rect = selectedRect(state2);
    dispatch(addColumn(state2.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr2, { map: map6, table: table3, tableStart }, col) {
  const mapStart = tr2.mapping.maps.length;
  for (let row = 0; row < map6.height; ) {
    const index4 = row * map6.width + col;
    const pos = map6.map[index4];
    const cell2 = table3.nodeAt(pos);
    const attrs = cell2.attrs;
    if (col > 0 && map6.map[index4 - 1] == pos || col < map6.width - 1 && map6.map[index4 + 1] == pos) {
      tr2.setNodeMarkup(
        tr2.mapping.slice(mapStart).map(tableStart + pos),
        null,
        removeColSpan(attrs, col - map6.colCount(pos))
      );
    } else {
      const start2 = tr2.mapping.slice(mapStart).map(tableStart + pos);
      tr2.delete(start2, start2 + cell2.nodeSize);
    }
    row += attrs.rowspan;
  }
}
function deleteColumn(state2, dispatch) {
  if (!isInTable(state2))
    return false;
  if (dispatch) {
    const rect = selectedRect(state2);
    const tr2 = state2.tr;
    if (rect.left == 0 && rect.right == rect.map.width)
      return false;
    for (let i2 = rect.right - 1; ; i2--) {
      removeColumn(tr2, rect, i2);
      if (i2 == rect.left)
        break;
      const table3 = rect.tableStart ? tr2.doc.nodeAt(rect.tableStart - 1) : tr2.doc;
      if (!table3) {
        throw RangeError("No table found");
      }
      rect.table = table3;
      rect.map = TableMap.get(table3);
    }
    dispatch(tr2);
  }
  return true;
}
function rowIsHeader(map6, table3, row) {
  var _a;
  const headerCell = tableNodeTypes(table3.type.schema).header_cell;
  for (let col = 0; col < map6.width; col++)
    if (((_a = table3.nodeAt(map6.map[col + row * map6.width])) == null ? void 0 : _a.type) != headerCell)
      return false;
  return true;
}
function addRow(tr2, { map: map6, tableStart, table: table3 }, row) {
  var _a;
  let rowPos = tableStart;
  for (let i2 = 0; i2 < row; i2++)
    rowPos += table3.child(i2).nodeSize;
  const cells = [];
  let refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map6, table3, row + refRow))
    refRow = row == 0 || row == map6.height ? null : 0;
  for (let col = 0, index4 = map6.width * row; col < map6.width; col++, index4++) {
    if (row > 0 && row < map6.height && map6.map[index4] == map6.map[index4 - map6.width]) {
      const pos = map6.map[index4];
      const attrs = table3.nodeAt(pos).attrs;
      tr2.setNodeMarkup(tableStart + pos, null, {
        ...attrs,
        rowspan: attrs.rowspan + 1
      });
      col += attrs.colspan - 1;
    } else {
      const type = refRow == null ? tableNodeTypes(table3.type.schema).cell : (_a = table3.nodeAt(map6.map[index4 + refRow * map6.width])) == null ? void 0 : _a.type;
      const node3 = type == null ? void 0 : type.createAndFill();
      if (node3)
        cells.push(node3);
    }
  }
  tr2.insert(rowPos, tableNodeTypes(table3.type.schema).row.create(null, cells));
  return tr2;
}
function addRowAfter(state2, dispatch) {
  if (!isInTable(state2))
    return false;
  if (dispatch) {
    const rect = selectedRect(state2);
    dispatch(addRow(state2.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr2, { map: map6, table: table3, tableStart }, row) {
  let rowPos = 0;
  for (let i2 = 0; i2 < row; i2++)
    rowPos += table3.child(i2).nodeSize;
  const nextRow = rowPos + table3.child(row).nodeSize;
  const mapFrom = tr2.mapping.maps.length;
  tr2.delete(rowPos + tableStart, nextRow + tableStart);
  const seen = /* @__PURE__ */ new Set();
  for (let col = 0, index4 = row * map6.width; col < map6.width; col++, index4++) {
    const pos = map6.map[index4];
    if (seen.has(pos))
      continue;
    seen.add(pos);
    if (row > 0 && pos == map6.map[index4 - map6.width]) {
      const attrs = table3.nodeAt(pos).attrs;
      tr2.setNodeMarkup(tr2.mapping.slice(mapFrom).map(pos + tableStart), null, {
        ...attrs,
        rowspan: attrs.rowspan - 1
      });
      col += attrs.colspan - 1;
    } else if (row < map6.height && pos == map6.map[index4 + map6.width]) {
      const cell2 = table3.nodeAt(pos);
      const attrs = cell2.attrs;
      const copy2 = cell2.type.create(
        { ...attrs, rowspan: cell2.attrs.rowspan - 1 },
        cell2.content
      );
      const newPos = map6.positionAt(row + 1, col, table3);
      tr2.insert(tr2.mapping.slice(mapFrom).map(tableStart + newPos), copy2);
      col += attrs.colspan - 1;
    }
  }
}
function deleteRow(state2, dispatch) {
  if (!isInTable(state2))
    return false;
  if (dispatch) {
    const rect = selectedRect(state2), tr2 = state2.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height)
      return false;
    for (let i2 = rect.bottom - 1; ; i2--) {
      removeRow(tr2, rect, i2);
      if (i2 == rect.top)
        break;
      const table3 = rect.tableStart ? tr2.doc.nodeAt(rect.tableStart - 1) : tr2.doc;
      if (!table3) {
        throw RangeError("No table found");
      }
      rect.table = table3;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr2);
  }
  return true;
}
function deprecated_toggleHeader(type) {
  return function(state2, dispatch) {
    if (!isInTable(state2))
      return false;
    if (dispatch) {
      const types4 = tableNodeTypes(state2.schema);
      const rect = selectedRect(state2), tr2 = state2.tr;
      const cells = rect.map.cellsInRect(
        type == "column" ? {
          left: rect.left,
          top: 0,
          right: rect.right,
          bottom: rect.map.height
        } : type == "row" ? {
          left: 0,
          top: rect.top,
          right: rect.map.width,
          bottom: rect.bottom
        } : rect
      );
      const nodes = cells.map((pos) => rect.table.nodeAt(pos));
      for (let i2 = 0; i2 < cells.length; i2++)
        if (nodes[i2].type == types4.header_cell)
          tr2.setNodeMarkup(
            rect.tableStart + cells[i2],
            types4.cell,
            nodes[i2].attrs
          );
      if (tr2.steps.length == 0)
        for (let i2 = 0; i2 < cells.length; i2++)
          tr2.setNodeMarkup(
            rect.tableStart + cells[i2],
            types4.header_cell,
            nodes[i2].attrs
          );
      dispatch(tr2);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types4) {
  const cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (let i2 = 0; i2 < cellPositions.length; i2++) {
    const cell2 = rect.table.nodeAt(cellPositions[i2]);
    if (cell2 && cell2.type !== types4.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic)
    return deprecated_toggleHeader(type);
  return function(state2, dispatch) {
    if (!isInTable(state2))
      return false;
    if (dispatch) {
      const types4 = tableNodeTypes(state2.schema);
      const rect = selectedRect(state2), tr2 = state2.tr;
      const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types4);
      const isHeaderColumnEnabled = isHeaderEnabledByType(
        "column",
        rect,
        types4
      );
      const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      const selectionStartsAt = isHeaderEnabled ? 1 : 0;
      const cellsRect = type == "column" ? {
        left: 0,
        top: selectionStartsAt,
        right: 1,
        bottom: rect.map.height
      } : type == "row" ? {
        left: selectionStartsAt,
        top: 0,
        right: rect.map.width,
        bottom: 1
      } : rect;
      const newType = type == "column" ? isHeaderColumnEnabled ? types4.cell : types4.header_cell : type == "row" ? isHeaderRowEnabled ? types4.cell : types4.header_cell : types4.cell;
      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
        const cellPos = relativeCellPos + rect.tableStart;
        const cell2 = tr2.doc.nodeAt(cellPos);
        if (cell2) {
          tr2.setNodeMarkup(cellPos, newType, cell2.attrs);
        }
      });
      dispatch(tr2);
    }
    return true;
  };
}
var toggleHeaderRow = toggleHeader("row", {
  useDeprecatedLogic: true
});
var toggleHeaderColumn = toggleHeader("column", {
  useDeprecatedLogic: true
});
var toggleHeaderCell = toggleHeader("cell", {
  useDeprecatedLogic: true
});
function tableEditing({
  allowTableNodeSelection = false
} = {}) {
  return new Plugin({
    key: tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(tr2, cur) {
        const set2 = tr2.getMeta(tableEditingKey);
        if (set2 != null)
          return set2 == -1 ? null : set2;
        if (cur == null || !tr2.docChanged)
          return cur;
        const { deleted, pos } = tr2.mapping.mapResult(cur);
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween(view) {
        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
      },
      handleTripleClick: handleTripleClick2,
      handleKeyDown,
      handlePaste
    },
    appendTransaction(_, oldState, state2) {
      return normalizeSelection(
        state2,
        fixTables(state2, oldState),
        allowTableNodeSelection
      );
    }
  });
}

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get2(i2) {
  if (i2 < 0 || i2 >= this.length) {
    return void 0;
  }
  return this.getInner(i2);
};
RopeSequence.prototype.forEach = function forEach(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i2) {
    return result.push(f(elt, i2));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values3) {
  if (values3 instanceof RopeSequence) {
    return values3;
  }
  return values3 && values3.length ? new Leaf(values3) : RopeSequence.empty;
};
var Leaf = function(RopeSequence3) {
  function Leaf3(values3) {
    RopeSequence3.call(this);
    this.values = values3;
  }
  if (RopeSequence3) Leaf3.__proto__ = RopeSequence3;
  Leaf3.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf3.prototype.constructor = Leaf3;
  var prototypeAccessors2 = { length: { configurable: true }, depth: { configurable: true } };
  Leaf3.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf3.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf3(this.values.slice(from2, to));
  };
  Leaf3.prototype.getInner = function getInner(i2) {
    return this.values[i2];
  };
  Leaf3.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i2 = from2; i2 < to; i2++) {
      if (f(this.values[i2], start2 + i2) === false) {
        return false;
      }
    }
  };
  Leaf3.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i2 = from2 - 1; i2 >= to; i2--) {
      if (f(this.values[i2], start2 + i2) === false) {
        return false;
      }
    }
  };
  Leaf3.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf3(this.values.concat(other.flatten()));
    }
  };
  Leaf3.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf3(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors2.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors2.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf3.prototype, prototypeAccessors2);
  return Leaf3;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i2) {
    return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state2, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (; ; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform3 = state2.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item2, i2) => {
      if (!item2.step) {
        if (!remap) {
          remap = this.remapping(end, i2 + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item2);
        return;
      }
      if (remap) {
        addBefore.push(new Item2(item2.map));
        let step = item2.step.map(remap.slice(mapFrom)), map6;
        if (step && transform3.maybeStep(step).doc) {
          map6 = transform3.mapping.maps[transform3.mapping.maps.length - 1];
          addAfter.push(new Item2(map6, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map6)
          remap.appendMap(map6, mapFrom);
      } else {
        transform3.maybeStep(item2.step);
      }
      if (item2.selection) {
        selection = remap ? item2.selection.map(remap.slice(mapFrom)) : item2.selection;
        remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform: transform3, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform3, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i2 = 0; i2 < transform3.steps.length; i2++) {
      let step = transform3.steps[i2].invert(transform3.docs[i2]);
      let item2 = new Item2(transform3.mapping.maps[i2], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item2)) {
        item2 = merged;
        if (i2)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item2);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item2;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item2, i2) => {
      let mirrorPos = item2.mirrorOffset != null && i2 - item2.mirrorOffset >= from2 ? maps.maps.length - item2.mirrorOffset : void 0;
      maps.appendMap(item2.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array.map((map6) => new Item2(map6))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item2) => {
      if (item2.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item2) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map6 = mapping.maps[pos];
      if (item2.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item2.selection && item2.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item2(map6, step, selection));
      } else {
        rebasedItems.push(new Item2(map6));
      }
    }, start2);
    let newMaps = [];
    for (let i2 = rebasedCount; i2 < newUntil; i2++)
      newMaps.push(new Item2(mapping.maps[i2]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count2 = 0;
    this.items.forEach((item2) => {
      if (!item2.step)
        count2++;
    });
    return count2;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item2, i2) => {
      if (i2 >= upto) {
        items.push(item2);
        if (item2.selection)
          events++;
      } else if (item2.step) {
        let step = item2.step.map(remap.slice(mapFrom)), map6 = step && step.getMap();
        mapFrom--;
        if (map6)
          remap.appendMap(map6, mapFrom);
        if (step) {
          let selection = item2.selection && item2.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item2(map6.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item2.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items.reverse()), events);
  }
};
Branch.empty = new Branch(dist_default2.empty, 0);
function cutOffEvents(items, n2) {
  let cutPoint;
  items.forEach((item2, i2) => {
    if (item2.selection && n2-- == 0) {
      cutPoint = i2;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item2 = class _Item {
  constructor(map6, step, selection, mirrorOffset) {
    this.map = map6;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state2, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state2)), history2.undone, rangesFor(tr2.mapping.maps[tr2.steps.length - 1]), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state2)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps[tr2.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state2.selection.getBookmark() : void 0, options, mustPreserveItems(state2)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform3, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform3.docChanged)
    return true;
  let adjacent = false;
  transform3.mapping.maps[0].forEach((start2, end) => {
    for (let i2 = 0; i2 < prevRanges.length; i2 += 2)
      if (start2 <= prevRanges[i2 + 1] && end >= prevRanges[i2])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map6) {
  let result = [];
  map6.forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i2 = 0; i2 < ranges.length; i2 += 2) {
    let from2 = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state2, redo3) {
  let preserveItems = mustPreserveItems(state2);
  let histOptions = historyKey.get(state2).spec.config;
  let pop = (redo3 ? history2.undone : history2.done).popEvent(state2, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo3 ? history2.done : history2.undone).addTransform(pop.transform, state2.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo3 ? added : pop.remaining, redo3 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo3, historyState: newHist });
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state2) {
  let plugins = state2.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i2 = 0; i2 < plugins.length; i2++)
      if (plugins[i2].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
function closeHistory(tr2) {
  return tr2.setMeta(closeHistoryKey, true);
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config3 = {}) {
  config3 = {
    depth: config3.depth || 100,
    newGroupDelay: config3.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state2) {
        return applyTransaction(hist, state2, tr2, config3);
      }
    },
    config: config3,
    props: {
      handleDOMEvents: {
        beforeinput(view, e3) {
          let inputType = e3.inputType;
          let command = inputType == "historyUndo" ? undo2 : inputType == "historyRedo" ? redo2 : null;
          if (!command)
            return false;
          e3.preventDefault();
          return command(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo3, scroll) {
  return (state2, dispatch) => {
    let hist = historyKey.getState(state2);
    if (!hist || (redo3 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr2 = histTransaction(hist, state2, redo3);
      if (tr2)
        dispatch(scroll ? tr2.scrollIntoView() : tr2);
    }
    return true;
  };
}
var undo2 = buildCommand(false, true);
var redo2 = buildCommand(true, true);
var undoNoScroll = buildCommand(false, false);
var redoNoScroll = buildCommand(true, false);

// node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node3, parents) {
    const parent = parents[parents.length - 1];
    const index4 = parent ? parent.children.indexOf(node3) : void 0;
    return visitor(node3, index4, parent);
  }
}

// node_modules/zwitch/index.js
var own2 = {}.hasOwnProperty;
function zwitch(key3, options) {
  const settings = options || {};
  function one2(value, ...parameters) {
    let fn = one2.invalid;
    const handlers2 = one2.handlers;
    if (value && own2.call(value, key3)) {
      const id = String(value[key3]);
      fn = own2.call(handlers2, id) ? handlers2[id] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}

// node_modules/mdast-util-to-markdown/lib/configure.js
var own3 = {}.hasOwnProperty;
function configure2(base2, extension2) {
  let index4 = -1;
  let key3;
  if (extension2.extensions) {
    while (++index4 < extension2.extensions.length) {
      configure2(base2, extension2.extensions[index4]);
    }
  }
  for (key3 in extension2) {
    if (own3.call(extension2, key3)) {
      switch (key3) {
        case "extensions": {
          break;
        }
        case "unsafe": {
          list3(base2[key3], extension2[key3]);
          break;
        }
        case "join": {
          list3(base2[key3], extension2[key3]);
          break;
        }
        case "handlers": {
          map2(base2[key3], extension2[key3]);
          break;
        }
        default: {
          base2.options[key3] = extension2[key3];
        }
      }
    }
  }
  return base2;
}
function list3(left, right) {
  if (right) {
    left.push(...right);
  }
}
function map2(left, right) {
  if (right) {
    Object.assign(left, right);
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote2(node3, _, state2, info) {
  const exit3 = state2.enter("blockquote");
  const tracker = state2.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state2.indentLines(
    state2.containerFlow(node3, tracker.current()),
    map3
  );
  exit3();
  return value;
}
function map3(line, _, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list5, none2) {
  if (typeof list5 === "string") {
    list5 = [list5];
  }
  if (!list5 || list5.length === 0) {
    return none2;
  }
  let index4 = -1;
  while (++index4 < list5.length) {
    if (stack.includes(list5[index4])) {
      return true;
    }
  }
  return false;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, state2, info) {
  let index4 = -1;
  while (++index4 < state2.unsafe.length) {
    if (state2.unsafe[index4].character === "\n" && patternInScope(state2.stack, state2.unsafe[index4])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/longest-streak/index.js
function longestStreak(value, substring) {
  const source = String(value);
  let index4 = source.indexOf(substring);
  let expected = index4;
  let count2 = 0;
  let max4 = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index4 !== -1) {
    if (index4 === expected) {
      if (++count2 > max4) {
        max4 = count2;
      }
    } else {
      count2 = 1;
    }
    expected = index4 + substring.length;
    index4 = source.indexOf(substring, expected);
  }
  return max4;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node3, state2) {
  return Boolean(
    state2.options.fences === false && node3.value && // If there’s no info…
    !node3.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node3.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node3.value)
  );
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state2) {
  const marker = state2.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code3(node3, _, state2, info) {
  const marker = checkFence(state2);
  const raw = node3.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node3, state2)) {
    const exit4 = state2.enter("codeIndented");
    const value2 = state2.indentLines(raw, map4);
    exit4();
    return value2;
  }
  const tracker = state2.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit3 = state2.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node3.lang) {
    const subexit = state2.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state2.safe(node3.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node3.lang && node3.meta) {
    const subexit = state2.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state2.safe(node3.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw) {
    value += tracker.move(raw + "\n");
  }
  value += tracker.move(sequence);
  exit3();
  return value;
}
function map4(line, _, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state2) {
  const marker = state2.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition2(node3, _, state2, info) {
  const quote = checkQuote(state2);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state2.enter("definition");
  let subexit = state2.enter("label");
  const tracker = state2.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state2.safe(state2.associationId(node3), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If there’s no url, or…
    !node3.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node3.url)
  ) {
    subexit = state2.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state2.safe(node3.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state2.enter("destinationRaw");
    value += tracker.move(
      state2.safe(node3.url, {
        before: value,
        after: node3.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node3.title) {
    subexit = state2.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state2.safe(node3.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state2) {
  const marker = state2.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node3, _, state2, info) {
  const marker = checkEmphasis(state2);
  const exit3 = state2.enter("emphasis");
  const tracker = state2.createTracker(info);
  let value = tracker.move(marker);
  value += tracker.move(
    state2.containerPhrasing(node3, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker);
  exit3();
  return value;
}
function emphasisPeek(_, _1, state2) {
  return state2.options.emphasis || "*";
}

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node3, state2) {
  let literalWithBreak = false;
  visit(node3, function(node4) {
    if ("value" in node4 && /\r?\n|\r/.test(node4.value) || node4.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node3.depth || node3.depth < 3) && toString2(node3) && (state2.options.setext || literalWithBreak)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading2(node3, _, state2, info) {
  const rank = Math.max(Math.min(6, node3.depth || 1), 1);
  const tracker = state2.createTracker(info);
  if (formatHeadingAsSetext(node3, state2)) {
    const exit4 = state2.enter("headingSetext");
    const subexit2 = state2.enter("phrasing");
    const value2 = state2.containerPhrasing(node3, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit4();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size…
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit3 = state2.enter("headingAtx");
  const subexit = state2.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state2.containerPhrasing(node3, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state2.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html.peek = htmlPeek;
function html(node3) {
  return node3.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image2.peek = imagePeek;
function image2(node3, _, state2, info) {
  const quote = checkQuote(state2);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state2.enter("image");
  let subexit = state2.enter("label");
  const tracker = state2.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state2.safe(node3.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node3.url && node3.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node3.url)
  ) {
    subexit = state2.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state2.safe(node3.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state2.enter("destinationRaw");
    value += tracker.move(
      state2.safe(node3.url, {
        before: value,
        after: node3.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node3.title) {
    subexit = state2.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state2.safe(node3.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node3, _, state2, info) {
  const type = node3.referenceType;
  const exit3 = state2.enter("imageReference");
  let subexit = state2.enter("label");
  const tracker = state2.createTracker(info);
  let value = tracker.move("![");
  const alt = state2.safe(node3.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state2.stack;
  state2.stack = [];
  subexit = state2.enter("reference");
  const reference = state2.safe(state2.associationId(node3), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state2.stack = stack;
  exit3();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node3, _, state2) {
  let value = node3.value || "";
  let sequence = "`";
  let index4 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index4 < state2.unsafe.length) {
    const pattern = state2.unsafe[index4];
    const expression = state2.compilePattern(pattern);
    let match2;
    if (!pattern.atBreak) continue;
    while (match2 = expression.exec(value)) {
      let position2 = match2.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match2.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node3, state2) {
  const raw = toString2(node3);
  return Boolean(
    !state2.options.resourceLink && // If there’s a url…
    node3.url && // And there’s a no title…
    !node3.title && // And the content of `node` is a single text node…
    node3.children && node3.children.length === 1 && node3.children[0].type === "text" && // And if the url is the same as the content…
    (raw === node3.url || "mailto:" + raw === node3.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node3.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node3.url)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link2.peek = linkPeek;
function link2(node3, _, state2, info) {
  const quote = checkQuote(state2);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state2.createTracker(info);
  let exit3;
  let subexit;
  if (formatLinkAsAutolink(node3, state2)) {
    const stack = state2.stack;
    state2.stack = [];
    exit3 = state2.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state2.containerPhrasing(node3, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit3();
    state2.stack = stack;
    return value2;
  }
  exit3 = state2.enter("link");
  subexit = state2.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state2.containerPhrasing(node3, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node3.url && node3.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node3.url)
  ) {
    subexit = state2.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state2.safe(node3.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state2.enter("destinationRaw");
    value += tracker.move(
      state2.safe(node3.url, {
        before: value,
        after: node3.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node3.title) {
    subexit = state2.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state2.safe(node3.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function linkPeek(node3, _, state2) {
  return formatLinkAsAutolink(node3, state2) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node3, _, state2, info) {
  const type = node3.referenceType;
  const exit3 = state2.enter("linkReference");
  let subexit = state2.enter("label");
  const tracker = state2.createTracker(info);
  let value = tracker.move("[");
  const text7 = state2.containerPhrasing(node3, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text7 + "][");
  subexit();
  const stack = state2.stack;
  state2.stack = [];
  subexit = state2.enter("reference");
  const reference = state2.safe(state2.associationId(node3), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state2.stack = stack;
  exit3();
  if (type === "full" || !text7 || text7 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state2) {
  const marker = state2.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state2) {
  const bullet = checkBullet(state2);
  const bulletOther = state2.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state2) {
  const marker = state2.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state2) {
  const marker = state2.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list4(node3, parent, state2, info) {
  const exit3 = state2.enter("list");
  const bulletCurrent = state2.bulletCurrent;
  let bullet = node3.ordered ? checkBulletOrdered(state2) : checkBullet(state2);
  const bulletOther = node3.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state2);
  let useDifferentMarker = parent && state2.bulletLastUsed ? bullet === state2.bulletLastUsed : false;
  if (!node3.ordered) {
    const firstListItem = node3.children ? node3.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state2.stack[state2.stack.length - 1] === "list" && state2.stack[state2.stack.length - 2] === "listItem" && state2.stack[state2.stack.length - 3] === "list" && state2.stack[state2.stack.length - 4] === "listItem" && // That are each the first child.
      state2.indexStack[state2.indexStack.length - 1] === 0 && state2.indexStack[state2.indexStack.length - 2] === 0 && state2.indexStack[state2.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state2) === bullet && firstListItem) {
      let index4 = -1;
      while (++index4 < node3.children.length) {
        const item2 = node3.children[index4];
        if (item2 && item2.type === "listItem" && item2.children && item2.children[0] && item2.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state2.bulletCurrent = bullet;
  const value = state2.containerFlow(node3, info);
  state2.bulletLastUsed = bullet;
  state2.bulletCurrent = bulletCurrent;
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state2) {
  const style = state2.options.listItemIndent || "one";
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node3, parent, state2, info) {
  const listItemIndent = checkListItemIndent(state2);
  let bullet = state2.bulletCurrent || checkBullet(state2);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state2.options.incrementListMarker === false ? 0 : parent.children.indexOf(node3)) + bullet;
  }
  let size4 = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node3.spread)) {
    size4 = Math.ceil(size4 / 4) * 4;
  }
  const tracker = state2.createTracker(info);
  tracker.move(bullet + " ".repeat(size4 - bullet.length));
  tracker.shift(size4);
  const exit3 = state2.enter("listItem");
  const value = state2.indentLines(
    state2.containerFlow(node3, tracker.current()),
    map6
  );
  exit3();
  return value;
  function map6(line, index4, blank) {
    if (index4) {
      return (blank ? "" : " ".repeat(size4)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size4 - bullet.length)) + line;
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph2(node3, _, state2, info) {
  const exit3 = state2.enter("paragraph");
  const subexit = state2.enter("phrasing");
  const value = state2.containerPhrasing(node3, info);
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-phrasing/lib/index.js
var phrasing = (
  /** @type {(node?: unknown) => node is PhrasingContent} */
  convert([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node3, _, state2, info) {
  const hasPhrasing = node3.children.some(function(d) {
    return phrasing(d);
  });
  const fn = hasPhrasing ? state2.containerPhrasing : state2.containerFlow;
  return fn.call(state2, node3, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state2) {
  const marker = state2.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong2.peek = strongPeek;
function strong2(node3, _, state2, info) {
  const marker = checkStrong(state2);
  const exit3 = state2.enter("strong");
  const tracker = state2.createTracker(info);
  let value = tracker.move(marker + marker);
  value += tracker.move(
    state2.containerPhrasing(node3, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker + marker);
  exit3();
  return value;
}
function strongPeek(_, _1, state2) {
  return state2.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text6(node3, _, state2, info) {
  return state2.safe(node3.value, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state2) {
  const repetition = state2.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak2(_, _1, state2) {
  const value = (checkRule(state2) + (state2.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state2));
  return state2.options.ruleSpaces ? value.slice(0, -1) : value;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote: blockquote2,
  break: hardBreak,
  code: code3,
  definition: definition2,
  emphasis,
  hardBreak,
  heading: heading2,
  html,
  image: image2,
  imageReference,
  inlineCode,
  link: link2,
  linkReference,
  list: list4,
  listItem,
  paragraph: paragraph2,
  root,
  strong: strong2,
  text: text6,
  thematicBreak: thematicBreak2
};

// node_modules/mdast-util-to-markdown/lib/join.js
var join2 = [joinDefaults];
function joinDefaults(left, right, parent, state2) {
  if (right.type === "code" && formatCodeAsIndented(right, state2) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state2))) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state2))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// node_modules/mdast-util-to-markdown/lib/unsafe.js
var fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
var unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];

// node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node3) {
  if (node3.label || !node3.identifier) {
    return node3.label || "";
  }
  return decodeString(node3.identifier);
}

// node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js
function compilePattern(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, state2, info) {
  const indexStack = state2.indexStack;
  const children = parent.children || [];
  const results = [];
  let index4 = -1;
  let before = info.before;
  indexStack.push(-1);
  let tracker = state2.createTracker(info);
  while (++index4 < children.length) {
    const child = children[index4];
    let after;
    indexStack[indexStack.length - 1] = index4;
    if (index4 + 1 < children.length) {
      let handle2 = state2.handle.handlers[children[index4 + 1].type];
      if (handle2 && handle2.peek) handle2 = handle2.peek;
      after = handle2 ? handle2(children[index4 + 1], parent, state2, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = info.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = state2.createTracker(info);
      tracker.move(results.join(""));
    }
    results.push(
      tracker.move(
        state2.handle(child, parent, state2, {
          ...tracker.current(),
          before,
          after
        })
      )
    );
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, state2, info) {
  const indexStack = state2.indexStack;
  const children = parent.children || [];
  const tracker = state2.createTracker(info);
  const results = [];
  let index4 = -1;
  indexStack.push(-1);
  while (++index4 < children.length) {
    const child = children[index4];
    indexStack[indexStack.length - 1] = index4;
    results.push(
      tracker.move(
        state2.handle(child, parent, state2, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      state2.bulletLastUsed = void 0;
    }
    if (index4 < children.length - 1) {
      results.push(
        tracker.move(between(child, children[index4 + 1], parent, state2))
      );
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state2) {
  let index4 = state2.join.length;
  while (index4--) {
    const result = state2.join[index4](left, right, parent, state2);
    if (result === true || result === 1) {
      break;
    }
    if (typeof result === "number") {
      return "\n".repeat(1 + result);
    }
    if (result === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}

// node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value, map6) {
  const result = [];
  let start2 = 0;
  let line = 0;
  let match2;
  while (match2 = eol.exec(value)) {
    one2(value.slice(start2, match2.index));
    result.push(match2[0]);
    start2 = match2.index + match2[0].length;
    line++;
  }
  one2(value.slice(start2));
  return result.join("");
  function one2(value2) {
    result.push(map6(value2, line, !value2));
  }
}

// node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(state2, input, config3) {
  const value = (config3.before || "") + (input || "") + (config3.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index4 = -1;
  while (++index4 < state2.unsafe.length) {
    const pattern = state2.unsafe[index4];
    if (!patternInScope(state2.stack, pattern)) {
      continue;
    }
    const expression = state2.compilePattern(pattern);
    let match2;
    while (match2 = expression.exec(value)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position2 = match2.index + (before ? match2[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start2 = config3.before ? config3.before.length : 0;
  const end = value.length - (config3.after ? config3.after.length : 0);
  index4 = -1;
  while (++index4 < positions.length) {
    const position2 = positions[index4];
    if (position2 < start2 || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index4 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index4 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start2 !== position2) {
      result.push(escapeBackslashes(value.slice(start2, position2), "\\"));
    }
    start2 = position2;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config3.encode || !config3.encode.includes(value.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push(
        "&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";"
      );
      start2++;
    }
  }
  result.push(escapeBackslashes(value.slice(start2, end), config3.after));
  return result.join("");
}
function numerical(a, b) {
  return a - b;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index4 = -1;
  let start2 = 0;
  let match2;
  while (match2 = expression.exec(whole)) {
    positions.push(match2.index);
  }
  while (++index4 < positions.length) {
    if (start2 !== positions[index4]) {
      results.push(value.slice(start2, positions[index4]));
    }
    results.push("\\");
    start2 = positions[index4];
  }
  results.push(value.slice(start2));
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/track.js
function track(config3) {
  const options = config3 || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move: move2, current: current2, shift: shift5 };
  function current2() {
    return { now: { line, column }, lineShift };
  }
  function shift5(value) {
    lineShift += value;
  }
  function move2(input) {
    const value = input || "";
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value;
  }
}

// node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options = {}) {
  const state2 = {
    enter,
    indentLines,
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    compilePattern,
    safe: safeBound,
    stack: [],
    unsafe: [...unsafe],
    join: [...join2],
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...handle },
    options: {},
    indexStack: [],
    // @ts-expect-error: add `handle` in a second.
    handle: void 0
  };
  configure2(state2, options);
  if (state2.options.tightDefinitions) {
    state2.join.push(joinDefinition);
  }
  state2.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: state2.handlers
  });
  let result = state2.handle(tree, void 0, state2, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter(name2) {
    state2.stack.push(name2);
    return exit3;
    function exit3() {
      state2.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(value) {
  const node3 = (
    /** @type {Nodes} */
    value
  );
  throw new Error("Cannot handle unknown node `" + node3.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info) {
  return containerPhrasing(parent, this, info);
}
function containerFlowBound(parent, info) {
  return containerFlow(parent, this, info);
}
function safeBound(value, config3) {
  return safe(this, value, config3);
}

// node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference }
  };
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "footnoteDefinition");
  node3.label = label;
  node3.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "footnoteReference");
  node3.label = label;
  node3.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function footnoteReference(node3, _, state2, info) {
  const tracker = state2.createTracker(info);
  let value = tracker.move("[^");
  const exit3 = state2.enter("footnoteReference");
  const subexit = state2.enter("reference");
  value += tracker.move(
    state2.safe(state2.associationId(node3), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  exit3();
  value += tracker.move("]");
  return value;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(node3, _, state2, info) {
  const tracker = state2.createTracker(info);
  let value = tracker.move("[^");
  const exit3 = state2.enter("footnoteDefinition");
  const subexit = state2.enter("label");
  value += tracker.move(
    state2.safe(state2.associationId(node3), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  value += tracker.move(
    "]:" + (node3.children && node3.children.length > 0 ? " " : "")
  );
  tracker.shift(4);
  value += tracker.move(
    state2.indentLines(state2.containerFlow(node3, tracker.current()), map5)
  );
  exit3();
  return value;
}
function map5(line, index4, blank) {
  if (index4 === 0) {
    return line;
  }
  return (blank ? "" : "    ") + line;
}

// node_modules/markdown-table/index.js
function markdownTable(table3, options = {}) {
  const align = (options.align || []).concat();
  const stringLength = options.stringLength || defaultStringLength;
  const alignments2 = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table3.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table3[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table3[rowIndex].length;
    }
    while (++columnIndex2 < table3[rowIndex].length) {
      const cell2 = serialize(table3[rowIndex][columnIndex2]);
      if (options.alignDelimiters !== false) {
        const size4 = stringLength(cell2);
        sizes2[columnIndex2] = size4;
        if (longestCellByColumn[columnIndex2] === void 0 || size4 > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size4;
        }
      }
      row2.push(cell2);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments2[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code4 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments2[columnIndex] = code4;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code4 = alignments2[columnIndex];
    let before = "";
    let after = "";
    if (code4 === 99) {
      before = ":";
      after = ":";
    } else if (code4 === 108) {
      before = ":";
    } else if (code4 === 114) {
      after = ":";
    }
    let size4 = options.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell2 = before + "-".repeat(size4) + after;
    if (options.alignDelimiters !== false) {
      size4 = before.length + size4 + after.length;
      if (size4 > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size4;
      }
      sizes[columnIndex] = size4;
    }
    row[columnIndex] = cell2;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell2 = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (options.alignDelimiters !== false) {
        const size4 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code4 = alignments2[columnIndex];
        if (code4 === 114) {
          before = " ".repeat(size4);
        } else if (code4 === 99) {
          if (size4 % 2) {
            before = " ".repeat(size4 / 2 + 0.5);
            after = " ".repeat(size4 / 2 - 0.5);
          } else {
            before = " ".repeat(size4 / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size4);
        }
      }
      if (options.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (options.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(options.alignDelimiters === false && cell2 === "") && (options.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (options.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell2);
      if (options.alignDelimiters !== false) {
        line.push(after);
      }
      if (options.padding !== false) {
        line.push(" ");
      }
      if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function defaultStringLength(value) {
  return value.length;
}
function toAlignment(value) {
  const code4 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code4 === 67 || code4 === 99 ? 99 : code4 === 76 || code4 === 108 ? 108 : code4 === 82 || code4 === 114 ? 114 : 0;
}

// node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit2,
      tableHeader: exit2,
      tableRow: exit2
    }
  };
}
function enterTable(token) {
  const align = token._align;
  ok(align, "expected `_align` on table");
  this.enter(
    {
      type: "table",
      align: align.map(function(d) {
        return d === "none" ? null : d;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace2);
  }
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "inlineCode");
  node3.value = value;
  this.exit(token);
}
function replace2($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node3, _, state2, info) {
    return serializeData(handleTableAsData(node3, state2, info), node3.align);
  }
  function handleTableRow(node3, _, state2, info) {
    const row = handleTableRowAsData(node3, state2, info);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node3, _, state2, info) {
    const exit3 = state2.enter("tableCell");
    const subexit = state2.enter("phrasing");
    const value = state2.containerPhrasing(node3, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit3();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node3, state2, info) {
    const children = node3.children;
    let index4 = -1;
    const result = [];
    const subexit = state2.enter("table");
    while (++index4 < children.length) {
      result[index4] = handleTableRowAsData(children[index4], state2, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node3, state2, info) {
    const children = node3.children;
    let index4 = -1;
    const result = [];
    const subexit = state2.enter("tableRow");
    while (++index4 < children.length) {
      result[index4] = handleTableCell(children[index4], node3, state2, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node3, parent, state2) {
    let value = handle.inlineCode(node3, parent, state2);
    if (state2.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}

// node_modules/mdast-util-gfm-task-list-item/lib/index.js
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node3 = this.stack[this.stack.length - 2];
  ok(node3.type === "listItem");
  node3.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node3 = this.stack[this.stack.length - 1];
    ok(node3.type === "paragraph");
    const head = node3.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index4 = -1;
      let firstParaghraph;
      while (++index4 < siblings.length) {
        const sibling2 = siblings[index4];
        if (sibling2.type === "paragraph") {
          firstParaghraph = sibling2;
          break;
        }
      }
      if (firstParaghraph === node3) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node3.children.shift();
        } else if (node3.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node3.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node3, parent, state2, info) {
  const head = node3.children[0];
  const checkable = typeof node3.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node3.checked ? "x" : " ") + "] ";
  const tracker = state2.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node3, parent, state2, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}

// node_modules/mdast-util-mdx-expression/lib/index.js
function mdxExpressionFromMarkdown() {
  return {
    enter: {
      mdxFlowExpression: enterMdxFlowExpression,
      mdxTextExpression: enterMdxTextExpression
    },
    exit: {
      mdxFlowExpression: exitMdxExpression,
      mdxFlowExpressionChunk: exitMdxExpressionData,
      mdxTextExpression: exitMdxExpression,
      mdxTextExpressionChunk: exitMdxExpressionData
    }
  };
}
function mdxExpressionToMarkdown() {
  return {
    handlers: {
      mdxFlowExpression: handleMdxExpression,
      mdxTextExpression: handleMdxExpression
    },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: true, character: "{" }
    ]
  };
}
function enterMdxFlowExpression(token) {
  this.enter({ type: "mdxFlowExpression", value: "" }, token);
  this.buffer();
}
function enterMdxTextExpression(token) {
  this.enter({ type: "mdxTextExpression", value: "" }, token);
  this.buffer();
}
function exitMdxExpression(token) {
  const value = this.resume();
  const estree = token.estree;
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "mdxFlowExpression" || node3.type === "mdxTextExpression");
  this.exit(token);
  node3.value = value;
  if (estree) {
    node3.data = { estree };
  }
}
function exitMdxExpressionData(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function handleMdxExpression(node3) {
  const value = node3.value || "";
  return "{" + value + "}";
}

// node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// node_modules/character-reference-invalid/index.js
var characterReferenceInvalid = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};

// node_modules/is-decimal/index.js
function isDecimal2(character) {
  const code4 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code4 >= 48 && code4 <= 57;
}

// node_modules/is-hexadecimal/index.js
function isHexadecimal(character) {
  const code4 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code4 >= 97 && code4 <= 102 || code4 >= 65 && code4 <= 70 || code4 >= 48 && code4 <= 57;
}

// node_modules/is-alphabetical/index.js
function isAlphabetical(character) {
  const code4 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code4 >= 97 && code4 <= 122 || code4 >= 65 && code4 <= 90;
}

// node_modules/is-alphanumerical/index.js
function isAlphanumerical(character) {
  return isAlphabetical(character) || isDecimal2(character);
}

// node_modules/parse-entities/lib/index.js
var fromCharCode = String.fromCharCode;
var messages = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(value, options = {}) {
  const additional = typeof options.additional === "string" ? options.additional.charCodeAt(0) : options.additional;
  const result = [];
  let index4 = 0;
  let lines = -1;
  let queue = "";
  let point3;
  let indent3;
  if (options.position) {
    if ("start" in options.position || "indent" in options.position) {
      indent3 = options.position.indent;
      point3 = options.position.start;
    } else {
      point3 = options.position;
    }
  }
  let line = (point3 ? point3.line : 0) || 1;
  let column = (point3 ? point3.column : 0) || 1;
  let previous3 = now();
  let character;
  index4--;
  while (++index4 <= value.length) {
    if (character === 10) {
      column = (indent3 ? indent3[lines] : 0) || 1;
    }
    character = value.charCodeAt(index4);
    if (character === 38) {
      const following = value.charCodeAt(index4 + 1);
      if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
        queue += fromCharCode(character);
        column++;
        continue;
      }
      const start2 = index4 + 1;
      let begin = start2;
      let end = start2;
      let type;
      if (following === 35) {
        end = ++begin;
        const following2 = value.charCodeAt(end);
        if (following2 === 88 || following2 === 120) {
          type = "hexadecimal";
          end = ++begin;
        } else {
          type = "decimal";
        }
      } else {
        type = "named";
      }
      let characterReferenceCharacters = "";
      let characterReference2 = "";
      let characters2 = "";
      const test = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal2 : isHexadecimal;
      end--;
      while (++end <= value.length) {
        const following2 = value.charCodeAt(end);
        if (!test(following2)) {
          break;
        }
        characters2 += fromCharCode(following2);
        if (type === "named" && characterEntitiesLegacy.includes(characters2)) {
          characterReferenceCharacters = characters2;
          characterReference2 = decodeNamedCharacterReference(characters2);
        }
      }
      let terminated = value.charCodeAt(end) === 59;
      if (terminated) {
        end++;
        const namedReference = type === "named" ? decodeNamedCharacterReference(characters2) : false;
        if (namedReference) {
          characterReferenceCharacters = characters2;
          characterReference2 = namedReference;
        }
      }
      let diff = 1 + end - start2;
      let reference = "";
      if (!terminated && options.nonTerminated === false) {
      } else if (!characters2) {
        if (type !== "named") {
          warning(4, diff);
        }
      } else if (type === "named") {
        if (terminated && !characterReference2) {
          warning(5, 1);
        } else {
          if (characterReferenceCharacters !== characters2) {
            end = begin + characterReferenceCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            const reason = characterReferenceCharacters ? 1 : 3;
            if (options.attribute) {
              const following2 = value.charCodeAt(end);
              if (following2 === 61) {
                warning(reason, diff);
                characterReference2 = "";
              } else if (isAlphanumerical(following2)) {
                characterReference2 = "";
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }
        reference = characterReference2;
      } else {
        if (!terminated) {
          warning(2, diff);
        }
        let referenceCode = Number.parseInt(
          characters2,
          type === "hexadecimal" ? 16 : 10
        );
        if (prohibited(referenceCode)) {
          warning(7, diff);
          reference = fromCharCode(
            65533
            /* `�` */
          );
        } else if (referenceCode in characterReferenceInvalid) {
          warning(6, diff);
          reference = characterReferenceInvalid[referenceCode];
        } else {
          let output = "";
          if (disallowed(referenceCode)) {
            warning(6, diff);
          }
          if (referenceCode > 65535) {
            referenceCode -= 65536;
            output += fromCharCode(referenceCode >>> (10 & 1023) | 55296);
            referenceCode = 56320 | referenceCode & 1023;
          }
          reference = output + fromCharCode(referenceCode);
        }
      }
      if (reference) {
        flush();
        previous3 = now();
        index4 = end - 1;
        column += end - start2 + 1;
        result.push(reference);
        const next = now();
        next.offset++;
        if (options.reference) {
          options.reference.call(
            options.referenceContext,
            reference,
            { start: previous3, end: next },
            value.slice(start2 - 1, end)
          );
        }
        previous3 = next;
      } else {
        characters2 = value.slice(start2 - 1, end);
        queue += characters2;
        column += characters2.length;
        index4 = end - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (Number.isNaN(character)) {
        flush();
      } else {
        queue += fromCharCode(character);
        column++;
      }
    }
  }
  return result.join("");
  function now() {
    return {
      line,
      column,
      offset: index4 + ((point3 ? point3.offset : 0) || 0)
    };
  }
  function warning(code4, offset5) {
    let position2;
    if (options.warning) {
      position2 = now();
      position2.column += offset5;
      position2.offset += offset5;
      options.warning.call(
        options.warningContext,
        messages[code4],
        position2,
        code4
      );
    }
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (options.text) {
        options.text.call(options.textContext, queue, {
          start: previous3,
          end: now()
        });
      }
      queue = "";
    }
  }
}
function prohibited(code4) {
  return code4 >= 55296 && code4 <= 57343 || code4 > 1114111;
}
function disallowed(code4) {
  return code4 >= 1 && code4 <= 8 || code4 === 11 || code4 >= 13 && code4 <= 31 || code4 >= 127 && code4 <= 159 || code4 >= 64976 && code4 <= 65007 || (code4 & 65535) === 65535 || (code4 & 65535) === 65534;
}

// node_modules/stringify-entities/lib/core.js
function core2(value, options) {
  value = value.replace(
    options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic
  );
  function surrogate(pair, index4, all2) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index4 + 2),
      options
    );
  }
  function basic(character, index4, all2) {
    return options.format(
      character.charCodeAt(0),
      all2.charCodeAt(index4 + 1),
      options
    );
  }
}
function charactersToExpression(subset) {
  const groups = [];
  let index4 = -1;
  while (++index4 < subset.length) {
    groups.push(subset[index4].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// node_modules/character-entities-html4/index.js
var characterEntitiesHtml4 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};

// node_modules/stringify-entities/lib/util/to-named.js
var own4 = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own4.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}

// node_modules/stringify-entities/lib/util/format-basic.js
function formatBasic(code4) {
  return "&#x" + code4.toString(16).toUpperCase() + ";";
}

// node_modules/stringify-entities/lib/index.js
function stringifyEntitiesLight(value, options) {
  return core2(value, Object.assign({ format: formatBasic }, options));
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index4 = origin.indexOf(":");
      if (index4 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index4);
        options.ruleId = origin.slice(index4 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start2 = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start2 ? start2.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start2 ? start2.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// node_modules/mdast-util-mdx-jsx/lib/index.js
var indent = "  ";
function mdxJsxFromMarkdown() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: enterMdxJsxTag,
      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagAttributeValueLiteral: buffer,
      mdxJsxFlowTagAttributeValueExpression: buffer,
      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: enterMdxJsxTag,
      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxTextTagAttributeValueLiteral: buffer,
      mdxJsxTextTagAttributeValueExpression: buffer,
      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker
    },
    exit: {
      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagExpressionAttributeValue: data2,
      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxFlowTagAttributeValueLiteralValue: data2,
      mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxFlowTagAttributeValueExpressionValue: data2,
      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxFlowTag: exitMdxJsxTag,
      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxTextTagExpressionAttributeValue: data2,
      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxTextTagAttributeValueLiteralValue: data2,
      mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxTextTagAttributeValueExpressionValue: data2,
      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: exitMdxJsxTag
    }
  };
  function buffer() {
    this.buffer();
  }
  function data2(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
  function enterMdxJsxTag(token) {
    const tag = {
      name: void 0,
      attributes: [],
      close: false,
      selfClosing: false,
      start: token.start,
      end: token.end
    };
    if (!this.data.mdxJsxTagStack) this.data.mdxJsxTagStack = [];
    this.data.mdxJsxTag = tag;
    this.buffer();
  }
  function enterMdxJsxTagClosingMarker(token) {
    const stack = this.data.mdxJsxTagStack;
    ok(stack, "expected `mdxJsxTagStack`");
    if (stack.length === 0) {
      throw new VFileMessage(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
    }
  }
  function enterMdxJsxTagAnyAttribute(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    if (tag.close) {
      throw new VFileMessage(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
    }
  }
  function enterMdxJsxTagSelfClosingMarker(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    if (tag.close) {
      throw new VFileMessage(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
    }
  }
  function exitMdxJsxTagClosingMarker() {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.close = true;
  }
  function exitMdxJsxTagNamePrimary(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.name = this.sliceSerialize(token);
  }
  function exitMdxJsxTagNameMember(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.name += "." + this.sliceSerialize(token);
  }
  function exitMdxJsxTagNameLocal(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.name += ":" + this.sliceSerialize(token);
  }
  function enterMdxJsxTagAttribute(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    enterMdxJsxTagAnyAttribute.call(this, token);
    tag.attributes.push({ type: "mdxJsxAttribute", name: "", value: null });
  }
  function enterMdxJsxTagExpressionAttribute(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    enterMdxJsxTagAnyAttribute.call(this, token);
    tag.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" });
    this.buffer();
  }
  function exitMdxJsxTagExpressionAttribute(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const tail = tag.attributes[tag.attributes.length - 1];
    ok(tail.type === "mdxJsxExpressionAttribute");
    const estree = token.estree;
    tail.value = this.resume();
    if (estree) {
      tail.data = { estree };
    }
  }
  function exitMdxJsxTagAttributeNamePrimary(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const node3 = tag.attributes[tag.attributes.length - 1];
    ok(node3.type === "mdxJsxAttribute");
    node3.name = this.sliceSerialize(token);
  }
  function exitMdxJsxTagAttributeNameLocal(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const node3 = tag.attributes[tag.attributes.length - 1];
    ok(node3.type === "mdxJsxAttribute");
    node3.name += ":" + this.sliceSerialize(token);
  }
  function exitMdxJsxTagAttributeValueLiteral() {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.attributes[tag.attributes.length - 1].value = parseEntities(
      this.resume(),
      { nonTerminated: false }
    );
  }
  function exitMdxJsxTagAttributeValueExpression(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const tail = tag.attributes[tag.attributes.length - 1];
    ok(tail.type === "mdxJsxAttribute");
    const node3 = { type: "mdxJsxAttributeValueExpression", value: this.resume() };
    const estree = token.estree;
    if (estree) {
      node3.data = { estree };
    }
    tail.value = node3;
  }
  function exitMdxJsxTagSelfClosingMarker() {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    tag.selfClosing = true;
  }
  function exitMdxJsxTag(token) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const stack = this.data.mdxJsxTagStack;
    ok(stack, "expected `mdxJsxTagStack`");
    const tail = stack[stack.length - 1];
    if (tag.close && tail.name !== tag.name) {
      throw new VFileMessage(
        "Unexpected closing tag `" + serializeAbbreviatedTag(tag) + "`, expected corresponding closing tag for `" + serializeAbbreviatedTag(tail) + "` (" + stringifyPosition(tail) + ")",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    }
    this.resume();
    if (tag.close) {
      stack.pop();
    } else {
      this.enter(
        {
          type: token.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
          name: tag.name || null,
          attributes: tag.attributes,
          children: []
        },
        token,
        onErrorRightIsTag
      );
    }
    if (tag.selfClosing || tag.close) {
      this.exit(token, onErrorLeftIsTag);
    } else {
      stack.push(tag);
    }
  }
  function onErrorRightIsTag(closing, open) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    const place = closing ? " before the end of `" + closing.type + "`" : "";
    const position2 = closing ? { start: closing.start, end: closing.end } : void 0;
    throw new VFileMessage(
      "Expected a closing tag for `" + serializeAbbreviatedTag(tag) + "` (" + stringifyPosition({ start: open.start, end: open.end }) + ")" + place,
      position2,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function onErrorLeftIsTag(a, b) {
    const tag = this.data.mdxJsxTag;
    ok(tag, "expected `mdxJsxTag`");
    throw new VFileMessage(
      "Expected the closing tag `" + serializeAbbreviatedTag(tag) + "` either after the end of `" + b.type + "` (" + stringifyPosition(b.end) + ") or another opening tag after the start of `" + b.type + "` (" + stringifyPosition(b.start) + ")",
      { start: a.start, end: a.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function serializeAbbreviatedTag(tag) {
    return "<" + (tag.close ? "/" : "") + (tag.name || "") + ">";
  }
}
function mdxJsxToMarkdown(options) {
  const options_ = options || {};
  const quote = options_.quote || '"';
  const quoteSmart = options_.quoteSmart || false;
  const tightSelfClosing = options_.tightSelfClosing || false;
  const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error(
      "Cannot serialize attribute values with `" + quote + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  mdxElement.peek = peekElement;
  return {
    handlers: {
      mdxJsxFlowElement: mdxElement,
      mdxJsxTextElement: mdxElement
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: true, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: true,
    // Always generate links with resources (never autolinks).
    resourceLink: true
  };
  function mdxElement(node3, _, state2, info) {
    const flow3 = node3.type === "mdxJsxFlowElement";
    const selfClosing = node3.name ? !node3.children || node3.children.length === 0 : false;
    const depth = inferDepth(state2);
    const currentIndent = createIndent(depth);
    const trackerOneLine = state2.createTracker(info);
    const trackerMultiLine = state2.createTracker(info);
    const serializedAttributes = [];
    const prefix = (flow3 ? currentIndent : "") + "<" + (node3.name || "");
    const exit3 = state2.enter(node3.type);
    trackerOneLine.move(prefix);
    trackerMultiLine.move(prefix);
    if (node3.attributes && node3.attributes.length > 0) {
      if (!node3.name) {
        throw new Error("Cannot serialize fragment w/ attributes");
      }
      let index4 = -1;
      while (++index4 < node3.attributes.length) {
        const attribute = node3.attributes[index4];
        let result;
        if (attribute.type === "mdxJsxExpressionAttribute") {
          result = "{" + (attribute.value || "") + "}";
        } else {
          if (!attribute.name) {
            throw new Error("Cannot serialize attribute w/o name");
          }
          const value2 = attribute.value;
          const left = attribute.name;
          let right = "";
          if (value2 === null || value2 === void 0) {
          } else if (typeof value2 === "object") {
            right = "{" + (value2.value || "") + "}";
          } else {
            const appliedQuote = quoteSmart && ccount(value2, quote) > ccount(value2, alternative) ? alternative : quote;
            right = appliedQuote + stringifyEntitiesLight(value2, { subset: [appliedQuote] }) + appliedQuote;
          }
          result = left + (right ? "=" : "") + right;
        }
        serializedAttributes.push(result);
      }
    }
    let attributesOnTheirOwnLine = false;
    const attributesOnOneLine = serializedAttributes.join(" ");
    if (
      // Block:
      flow3 && // Including a line ending (expressions).
      (/\r?\n|\r/.test(attributesOnOneLine) || // Current position (including `<tag`).
      trackerOneLine.current().now.column + // -1 because columns, +1 for ` ` before attributes.
      // Attributes joined by spaces.
      attributesOnOneLine.length + // ` />`.
      (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)
    ) {
      attributesOnTheirOwnLine = true;
    }
    let tracker = trackerOneLine;
    let value = prefix;
    if (attributesOnTheirOwnLine) {
      tracker = trackerMultiLine;
      let index4 = -1;
      while (++index4 < serializedAttributes.length) {
        serializedAttributes[index4] = currentIndent + indent + serializedAttributes[index4];
      }
      value += tracker.move(
        "\n" + serializedAttributes.join("\n") + "\n" + currentIndent
      );
    } else if (attributesOnOneLine) {
      value += tracker.move(" " + attributesOnOneLine);
    }
    if (selfClosing) {
      value += tracker.move(
        (tightSelfClosing || attributesOnTheirOwnLine ? "" : " ") + "/"
      );
    }
    value += tracker.move(">");
    if (node3.children && node3.children.length > 0) {
      if (node3.type === "mdxJsxTextElement") {
        value += tracker.move(
          // @ts-expect-error: `containerPhrasing` is typed correctly, but TS
          // generates *hardcoded* types, which means that our dynamically added
          // directives are not present.
          // At some point, TS should fix that, and `from-markdown` should be fine.
          state2.containerPhrasing(node3, {
            ...tracker.current(),
            before: ">",
            after: "<"
          })
        );
      } else {
        tracker.shift(2);
        value += tracker.move("\n");
        value += tracker.move(containerFlow2(node3, state2, tracker.current()));
        value += tracker.move("\n");
      }
    }
    if (!selfClosing) {
      value += tracker.move(
        (flow3 ? currentIndent : "") + "</" + (node3.name || "") + ">"
      );
    }
    exit3();
    return value;
  }
}
function containerFlow2(parent, state2, info) {
  const indexStack = state2.indexStack;
  const children = parent.children;
  const tracker = state2.createTracker(info);
  const currentIndent = createIndent(inferDepth(state2));
  const results = [];
  let index4 = -1;
  indexStack.push(-1);
  while (++index4 < children.length) {
    const child = children[index4];
    indexStack[indexStack.length - 1] = index4;
    const childInfo = { before: "\n", after: "\n", ...tracker.current() };
    const result = state2.handle(child, parent, state2, childInfo);
    const serializedChild = child.type === "mdxJsxFlowElement" ? result : state2.indentLines(result, function(line, _, blank) {
      return (blank ? "" : currentIndent) + line;
    });
    results.push(tracker.move(serializedChild));
    if (child.type !== "list") {
      state2.bulletLastUsed = void 0;
    }
    if (index4 < children.length - 1) {
      results.push(tracker.move("\n\n"));
    }
  }
  indexStack.pop();
  return results.join("");
}
function inferDepth(state2) {
  let depth = 0;
  for (const x of state2.stack) {
    if (x === "mdxJsxFlowElement") {
      depth++;
    }
  }
  return depth;
}
function createIndent(depth) {
  return indent.repeat(depth);
}
function peekElement() {
  return "<";
}

// node_modules/mdast-util-mdxjs-esm/lib/index.js
function mdxjsEsmFromMarkdown() {
  return {
    enter: { mdxjsEsm: enterMdxjsEsm },
    exit: { mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData }
  };
}
function mdxjsEsmToMarkdown() {
  return { handlers: { mdxjsEsm: handleMdxjsEsm } };
}
function enterMdxjsEsm(token) {
  this.enter({ type: "mdxjsEsm", value: "" }, token);
  this.buffer();
}
function exitMdxjsEsm(token) {
  const value = this.resume();
  const node3 = this.stack[this.stack.length - 1];
  ok(node3.type === "mdxjsEsm");
  this.exit(token);
  const estree = token.estree;
  node3.value = value;
  if (estree) {
    node3.data = { estree };
  }
}
function exitMdxjsEsmData(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function handleMdxjsEsm(node3) {
  return node3.value || "";
}

// node_modules/mdast-util-mdx/lib/index.js
function mdxFromMarkdown() {
  return [
    mdxExpressionFromMarkdown(),
    mdxJsxFromMarkdown(),
    mdxjsEsmFromMarkdown()
  ];
}
function mdxToMarkdown(options) {
  return {
    extensions: [
      mdxExpressionToMarkdown(),
      mdxJsxToMarkdown(options),
      mdxjsEsmToMarkdown()
    ]
  };
}

// node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js
var indent2 = { tokenize: tokenizeIndent2, partial: true };
function gfmFootnote() {
  return {
    document: {
      [codes.leftSquareBracket]: {
        tokenize: tokenizeDefinitionStart,
        continuation: { tokenize: tokenizeDefinitionContinuation },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [codes.leftSquareBracket]: { tokenize: tokenizeGfmFootnoteCall },
      [codes.rightSquareBracket]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  let index4 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index4--) {
    const token = self2.events[index4][1];
    if (token.type === types2.labelImage) {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === types2.labelLink || token.type === types2.label || token.type === types2.image || token.type === types2.link) {
      break;
    }
  }
  return start2;
  function start2(code4) {
    ok(code4 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart || !labelStart._balanced) {
      return nok(code4);
    }
    const id = normalizeIdentifier(
      self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
    );
    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {
      return nok(code4);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok3(code4);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index4 = events.length;
  let labelStart;
  while (index4--) {
    if (events[index4][1].type === types2.labelImage && events[index4][0] === "enter") {
      labelStart = events[index4][1];
      break;
    }
  }
  ok(labelStart, "expected `labelStart` to resolve");
  events[index4 + 1][1].type = types2.data;
  events[index4 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index4 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index4 + 3][1].end),
    end: Object.assign({}, events[index4 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: types2.chunkString,
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index4 + 1],
    events[index4 + 2],
    ["enter", call, context],
    // The `[`
    events[index4 + 3],
    events[index4 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index4, events.length - index4 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size4 = 0;
  let data2;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code4) {
    if (code4 !== codes.caret) return nok(code4);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code4) {
    if (
      // Too long.
      size4 > constants.linkReferenceSizeMax || // Closing brace with nothing.
      code4 === codes.rightSquareBracket && !data2 || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code4 === codes.eof || code4 === codes.leftSquareBracket || markdownLineEndingOrSpace(code4)
    ) {
      return nok(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
        return nok(code4);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok3;
    }
    if (!markdownLineEndingOrSpace(code4)) {
      data2 = true;
    }
    size4++;
    effects.consume(code4);
    return code4 === codes.backslash ? callEscape : callData;
  }
  function callEscape(code4) {
    if (code4 === codes.leftSquareBracket || code4 === codes.backslash || code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      size4++;
      return callData;
    }
    return callData(code4);
  }
}
function tokenizeDefinitionStart(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier2;
  let size4 = 0;
  let data2;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code4) {
    if (code4 === codes.caret) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code4);
  }
  function labelInside(code4) {
    if (
      // Too long.
      size4 > constants.linkReferenceSizeMax || // Closing brace with nothing.
      code4 === codes.rightSquareBracket && !data2 || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code4 === codes.eof || code4 === codes.leftSquareBracket || markdownLineEndingOrSpace(code4)
    ) {
      return nok(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier2 = normalizeIdentifier(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code4)) {
      data2 = true;
    }
    size4++;
    effects.consume(code4);
    return code4 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code4) {
    if (code4 === codes.leftSquareBracket || code4 === codes.backslash || code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      size4++;
      return labelInside;
    }
    return labelInside(code4);
  }
  function labelAfter(code4) {
    if (code4 === codes.colon) {
      effects.enter("definitionMarker");
      effects.consume(code4);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier2)) {
        defined.push(identifier2);
      }
      return factorySpace(
        effects,
        whitespaceAfter,
        "gfmFootnoteDefinitionWhitespace"
      );
    }
    return nok(code4);
  }
  function whitespaceAfter(code4) {
    return ok3(code4);
  }
}
function tokenizeDefinitionContinuation(effects, ok3, nok) {
  return effects.check(blankLine, ok3, effects.attempt(indent2, ok3, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    constants.tabSize + 1
  );
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === constants.tabSize ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-extension-gfm-footnote/dev/lib/html.js
var own5 = {}.hasOwnProperty;

// node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js
var EditMap = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index4, remove, add2) {
    addImpl(this, index4, remove, add2);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a, b) {
      return a[0] - b[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index4 = this.map.length;
    const vecs = [];
    while (index4 > 0) {
      index4 -= 1;
      vecs.push(
        events.slice(this.map[index4][0] + this.map[index4][1]),
        this.map[index4][2]
      );
      events.length = this.map[index4][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice2 = vecs.pop();
    while (slice2) {
      events.push(...slice2);
      slice2 = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImpl(editMap, at2, remove, add2) {
  let index4 = 0;
  if (remove === 0 && add2.length === 0) {
    return;
  }
  while (index4 < editMap.map.length) {
    if (editMap.map[index4][0] === at2) {
      editMap.map[index4][1] += remove;
      editMap.map[index4][2].push(...add2);
      return;
    }
    index4 += 1;
  }
  editMap.map.push([at2, remove, add2]);
}

// node_modules/micromark-extension-gfm-table/dev/lib/infer.js
function gfmTableAlign(events, index4) {
  ok(events[index4][1].type === "table", "expected table");
  let inDelimiterRow = false;
  const align = [];
  while (index4 < events.length) {
    const event = events[index4];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index4 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index4 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index4 += 1;
  }
  return align;
}

// node_modules/micromark-extension-gfm-table/dev/lib/syntax.js
function gfmTable() {
  return {
    flow: { null: { tokenize: tokenizeTable, resolveAll: resolveTable } }
  };
}
function tokenizeTable(effects, ok3, nok) {
  const self2 = this;
  let size4 = 0;
  let sizeB = 0;
  let seen;
  return start2;
  function start2(code4) {
    let index4 = self2.events.length - 1;
    while (index4 > -1) {
      const type = self2.events[index4][1].type;
      if (type === types2.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === types2.linePrefix)
        index4--;
      else break;
    }
    const tail = index4 > -1 ? self2.events[index4][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    return next(code4);
  }
  function headRowBefore(code4) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code4);
  }
  function headRowStart(code4) {
    if (code4 === codes.verticalBar) {
      return headRowBreak(code4);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code4);
  }
  function headRowBreak(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter(types2.lineEnding);
        effects.consume(code4);
        effects.exit(types2.lineEnding);
        return headDelimiterStart;
      }
      return nok(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, headRowBreak, types2.whitespace)(code4);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size4 += 1;
    }
    if (code4 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter(types2.data);
    return headRowData(code4);
  }
  function headRowData(code4) {
    if (code4 === codes.eof || code4 === codes.verticalBar || markdownLineEndingOrSpace(code4)) {
      effects.exit(types2.data);
      return headRowBreak(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? headRowEscape : headRowData;
  }
  function headRowEscape(code4) {
    if (code4 === codes.backslash || code4 === codes.verticalBar) {
      effects.consume(code4);
      return headRowData;
    }
    return headRowData(code4);
  }
  function headDelimiterStart(code4) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code4)) {
      ok(self2.parser.constructs.disable.null, "expected `disabled.null`");
      return factorySpace(
        effects,
        headDelimiterBefore,
        types2.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code4);
    }
    return headDelimiterBefore(code4);
  }
  function headDelimiterBefore(code4) {
    if (code4 === codes.dash || code4 === codes.colon) {
      return headDelimiterValueBefore(code4);
    }
    if (code4 === codes.verticalBar) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterCellBefore(code4) {
    if (markdownSpace(code4)) {
      return factorySpace(
        effects,
        headDelimiterValueBefore,
        types2.whitespace
      )(code4);
    }
    return headDelimiterValueBefore(code4);
  }
  function headDelimiterValueBefore(code4) {
    if (code4 === codes.colon) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code4);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code4 === codes.dash) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code4);
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return headDelimiterCellAfter(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterLeftAlignmentAfter(code4) {
    if (code4 === codes.dash) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterFiller(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return headDelimiterFiller;
    }
    if (code4 === codes.colon) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code4);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code4);
  }
  function headDelimiterRightAlignmentAfter(code4) {
    if (markdownSpace(code4)) {
      return factorySpace(
        effects,
        headDelimiterCellAfter,
        types2.whitespace
      )(code4);
    }
    return headDelimiterCellAfter(code4);
  }
  function headDelimiterCellAfter(code4) {
    if (code4 === codes.verticalBar) {
      return headDelimiterBefore(code4);
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      if (!seen || size4 !== sizeB) {
        return headDelimiterNok(code4);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok3(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterNok(code4) {
    return nok(code4);
  }
  function bodyRowStart(code4) {
    effects.enter("tableRow");
    return bodyRowBreak(code4);
  }
  function bodyRowBreak(code4) {
    if (code4 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit("tableRow");
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, bodyRowBreak, types2.whitespace)(code4);
    }
    effects.enter(types2.data);
    return bodyRowData(code4);
  }
  function bodyRowData(code4) {
    if (code4 === codes.eof || code4 === codes.verticalBar || markdownLineEndingOrSpace(code4)) {
      effects.exit(types2.data);
      return bodyRowBreak(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code4) {
    if (code4 === codes.backslash || code4 === codes.verticalBar) {
      effects.consume(code4);
      return bodyRowData;
    }
    return bodyRowData(code4);
  }
}
function resolveTable(events, context) {
  let index4 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell2 = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map6 = new EditMap();
  while (++index4 < events.length) {
    const event = events[index4];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          ok(currentTable, "there should be a table opening");
          flushTableEnd(map6, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map6.add(index4, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell2 = [0, index4 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map6.add(index4, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === types2.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell2[2] === 0) {
          if (lastCell[1] !== 0) {
            cell2[0] = cell2[1];
            currentCell = flushCell(
              map6,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell2[2] = index4;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell2[0] = cell2[1];
            currentCell = flushCell(
              map6,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell2;
          cell2 = [lastCell[1], index4, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index4;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index4;
      if (lastCell[1] !== 0) {
        cell2[0] = cell2[1];
        currentCell = flushCell(
          map6,
          context,
          lastCell,
          rowKind,
          index4,
          currentCell
        );
      } else if (cell2[1] !== 0) {
        currentCell = flushCell(map6, context, cell2, rowKind, index4, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === types2.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell2[3] = index4;
    }
  }
  if (lastTableEnd !== 0) {
    ok(currentTable, "expected table opening");
    flushTableEnd(map6, context, lastTableEnd, currentTable, currentBody);
  }
  map6.consume(context.events);
  index4 = -1;
  while (++index4 < context.events.length) {
    const event = context.events[index4];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index4);
    }
  }
  return events;
}
function flushCell(map6, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    ok(previousCell, "expected previous cell enter");
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map6.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map6.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map6.add(range[2], 0, [["enter", valueToken, context]]);
    ok(range[3] !== 0);
    if (rowKind !== 2) {
      const start2 = context.events[range[2]];
      const end = context.events[range[3]];
      start2[1].end = Object.assign({}, end[1].end);
      start2[1].type = types2.chunkText;
      start2[1].contentType = constants.contentTypeText;
      if (range[3] > range[2] + 1) {
        const a = range[2] + 1;
        const b = range[3] - range[2] - 1;
        map6.add(a, b, []);
      }
    }
    map6.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map6.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map6, context, index4, table3, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index4);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table3.end = Object.assign({}, related);
  exits.push(["exit", table3, context]);
  map6.add(index4 + 1, 0, exits);
}
function getPoint(events, index4) {
  const event = events[index4];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// node_modules/micromark-extension-gfm-tagfilter/lib/index.js
var reFlow = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\t\n\f\r />])/gi;
var reText = new RegExp("^" + reFlow.source, "i");

// node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js
var tasklistCheck = { tokenize: tokenizeTasklistCheck };
function gfmTaskListItem() {
  return {
    text: { [codes.leftSquareBracket]: tasklistCheck }
  };
}
function tokenizeTasklistCheck(effects, ok3, nok) {
  const self2 = this;
  return open;
  function open(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    if (
      // Exit if there’s stuff before.
      self2.previous !== codes.eof || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code4);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code4);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code4) {
    if (markdownLineEndingOrSpace(code4)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code4);
      effects.exit("taskListCheckValueUnchecked");
      return close2;
    }
    if (code4 === codes.uppercaseX || code4 === codes.lowercaseX) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code4);
      effects.exit("taskListCheckValueChecked");
      return close2;
    }
    return nok(code4);
  }
  function close2(code4) {
    if (code4 === codes.rightSquareBracket) {
      effects.enter("taskListCheckMarker");
      effects.consume(code4);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    if (markdownLineEnding(code4)) {
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return effects.check({ tokenize: spaceThenNonSpace }, ok3, nok)(code4);
    }
    return nok(code4);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  return factorySpace(effects, after, types2.whitespace);
  function after(code4) {
    return code4 === codes.eof ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code4, set2) {
  var pos = 65536;
  for (var i2 = 0; i2 < set2.length; i2 += 2) {
    pos += set2[i2];
    if (pos > code4) {
      return false;
    }
    pos += set2[i2 + 1];
    if (pos >= code4) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code4, astral) {
  if (code4 < 65) {
    return code4 === 36;
  }
  if (code4 < 91) {
    return true;
  }
  if (code4 < 97) {
    return code4 === 95;
  }
  if (code4 < 123) {
    return true;
  }
  if (code4 <= 65535) {
    return code4 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code4));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code4, astralIdentifierStartCodes);
}
function isIdentifierChar(code4, astral) {
  if (code4 < 48) {
    return code4 === 36;
  }
  if (code4 < 58) {
    return true;
  }
  if (code4 < 65) {
    return false;
  }
  if (code4 < 91) {
    return true;
  }
  if (code4 < 97) {
    return code4 === 95;
  }
  if (code4 < 123) {
    return true;
  }
  if (code4 <= 65535) {
    return code4 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code4));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code4, astralIdentifierStartCodes) || isInAstralSet(code4, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name2, prec) {
  return new TokenType(name2, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name2, options) {
  if (options === void 0) options = {};
  options.keyword = name2;
  return keywords[name2] = new TokenType(name2, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code4) {
  return code4 === 10 || code4 === 13 || code4 === 8232 || code4 === 8233;
}
function nextLineBreak(code4, from2, end) {
  if (end === void 0) end = code4.length;
  for (var i2 = from2; i2 < end; i2++) {
    var next = code4.charCodeAt(i2);
    if (isNewLine(next)) {
      return i2 < end - 1 && next === 13 && code4.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty3 = ref.hasOwnProperty;
var toString3 = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty3.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString3.call(obj) === "[object Array]";
};
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code4) {
  if (code4 <= 65535) {
    return String.fromCharCode(code4);
  }
  code4 -= 65536;
  return String.fromCharCode((code4 >> 10) + 55296, (code4 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset4(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p, start2, end) {
  this.start = start2;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset5) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset5);
    if (nextBreak < 0) {
      return new Position(line, offset5 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block4, text7, start2, end, startLoc, endLoc) {
    var comment2 = {
      type: block4 ? "Block" : "Line",
      value: text7,
      start: start2,
      end
    };
    if (options.locations) {
      comment2.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment2.range = [start2, end];
    }
    array.push(comment2);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse2() {
  var node3 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node3);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i2 = 0; i2 < plugins.length; i2++) {
    cls = plugins[i2](cls);
  }
  return cls;
};
Parser.parse = function parse4(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser2 = new this(options, input, pos);
  parser2.nextToken();
  return parser2.parseExpression();
};
Parser.tokenizer = function tokenizer2(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/s;
pp$9.strictDirective = function(start2) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    var match2 = literal.exec(this.input.slice(start2));
    if (!match2) {
      return false;
    }
    if ((match2[1] || match2[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start2 + match2[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start2 += match2[0].length;
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start2] === ";") {
      start2++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name2) {
  return this.type === types$1.name && this.value === name2 && !this.containsEsc;
};
pp$9.eatContextual = function(name2) {
  if (!this.isContextual(name2)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name2) {
  if (!this.eatContextual(name2)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node3) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node3.body) {
    node3.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node3.body.push(stmt);
  }
  if (this.inModule) {
    for (var i2 = 0, list5 = Object.keys(this.undefinedExports); i2 < list5.length; i2 += 1) {
      var name2 = list5[i2];
      this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node3.body);
  this.next();
  node3.sourceType = this.options.sourceType;
  return this.finishNode(node3, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node3 = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node3, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node3);
    case types$1._do:
      return this.parseDoStatement(node3);
    case types$1._for:
      return this.parseForStatement(node3);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node3, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node3, true);
    case types$1._if:
      return this.parseIfStatement(node3);
    case types$1._return:
      return this.parseReturnStatement(node3);
    case types$1._switch:
      return this.parseSwitchStatement(node3);
    case types$1._throw:
      return this.parseThrowStatement(node3);
    case types$1._try:
      return this.parseTryStatement(node3);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node3, kind);
    case types$1._while:
      return this.parseWhileStatement(node3);
    case types$1._with:
      return this.parseWithStatement(node3);
    case types$1.braceL:
      return this.parseBlock(true, node3);
    case types$1.semi:
      return this.parseEmptyStatement(node3);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node3, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node3) : this.parseExport(node3, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node3, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node3, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node3, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node3, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node3.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node3.label = this.parseIdent();
    this.semicolon();
  }
  var i2 = 0;
  for (; i2 < this.labels.length; ++i2) {
    var lab = this.labels[i2];
    if (node3.label == null || lab.name === node3.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node3.label && isBreak) {
        break;
      }
    }
  }
  if (i2 === this.labels.length) {
    this.raise(node3.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node3, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node3) {
  this.next();
  this.semicolon();
  return this.finishNode(node3, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node3) {
  this.next();
  this.labels.push(loopLabel);
  node3.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node3.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node3, "DoWhileStatement");
};
pp$8.parseForStatement = function(node3) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node3, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node3.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node3, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node3, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node3.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node3.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node3, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node3, init);
};
pp$8.parseFunctionStatement = function(node3, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node3, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node3) {
  this.next();
  node3.test = this.parseParenExpression();
  node3.consequent = this.parseStatement("if");
  node3.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node3, "IfStatement");
};
pp$8.parseReturnStatement = function(node3) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node3.argument = null;
  } else {
    node3.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node3, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node3) {
  this.next();
  node3.discriminant = this.parseParenExpression();
  node3.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node3.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node3, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node3) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node3.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node3, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node3) {
  this.next();
  node3.block = this.parseBlock();
  node3.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node3.handler = this.finishNode(clause, "CatchClause");
  }
  node3.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node3.handler && !node3.finalizer) {
    this.raise(node3.start, "Missing catch or finally clause");
  }
  return this.finishNode(node3, "TryStatement");
};
pp$8.parseVarStatement = function(node3, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node3, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node3, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node3) {
  this.next();
  node3.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node3.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node3, "WhileStatement");
};
pp$8.parseWithStatement = function(node3) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node3.object = this.parseParenExpression();
  node3.body = this.parseStatement("with");
  return this.finishNode(node3, "WithStatement");
};
pp$8.parseEmptyStatement = function(node3) {
  this.next();
  return this.finishNode(node3, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node3, maybeName, expr, context) {
  for (var i$12 = 0, list5 = this.labels; i$12 < list5.length; i$12 += 1) {
    var label = list5[i$12];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
    var label$1 = this.labels[i2];
    if (label$1.statementStart === node3.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node3.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node3.label = expr;
  return this.finishNode(node3, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node3, expr) {
  node3.expression = expr;
  this.semicolon();
  return this.finishNode(node3, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node3, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node3 === void 0) node3 = this.startNode();
  node3.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node3.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node3, "BlockStatement");
};
pp$8.parseFor = function(node3, init) {
  node3.init = init;
  this.expect(types$1.semi);
  node3.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node3.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node3.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node3, "ForStatement");
};
pp$8.parseForIn = function(node3, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node3.left = init;
  node3.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node3.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node3, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node3, isFor, kind, allowMissingInitializer) {
  node3.declarations = [];
  node3.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node3.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node3;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node3, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node3);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node3.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node3.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node3.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node3.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node3.id, this.strict || node3.generator || node3.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node3.async, node3.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node3.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node3);
  this.parseFunctionBody(node3, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node3, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node3) {
  this.expect(types$1.parenL);
  node3.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node3, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node3, isStatement);
  this.parseClassSuper(node3);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element3 = this.parseClassElement(node3.superClass !== null);
    if (element3) {
      classBody.body.push(element3);
      if (element3.type === "MethodDefinition" && element3.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element3.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element3.key && element3.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element3)) {
        this.raiseRecoverable(element3.key.start, "Identifier '#" + element3.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node3.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node3, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node3 = this.startNode();
  var keyName2 = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node3);
      return node3;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName2 = "static";
    }
  }
  node3.static = isStatic;
  if (!keyName2 && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName2 = "async";
    }
  }
  if (!keyName2 && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName2 && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName2 = lastValue;
      }
    }
  }
  if (keyName2) {
    node3.computed = false;
    node3.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node3.key.name = keyName2;
    this.finishNode(node3.key, "Identifier");
  } else {
    this.parseClassElementName(node3);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node3.static && checkKeyName(node3, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node3.key.start, "Constructor can't have get/set modifier");
    }
    node3.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node3, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node3);
  }
  return node3;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element3) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element3.computed = false;
    element3.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element3);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key3 = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key3.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key3.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key3.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node3) {
  node3.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node3.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node3, "StaticBlock");
};
pp$8.parseClassId = function(node3, isStatement) {
  if (this.type === types$1.name) {
    node3.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node3.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node3.id = null;
  }
};
pp$8.parseClassSuper = function(node3) {
  node3.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element3 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element3);
  return element3.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i2 = 0; i2 < used.length; ++i2) {
    var id = used[i2];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element3) {
  var name2 = element3.key.name;
  var curr = privateNameMap[name2];
  var next = "true";
  if (element3.type === "MethodDefinition" && (element3.kind === "get" || element3.kind === "set")) {
    next = (element3.static ? "s" : "i") + element3.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node3, name2) {
  var computed = node3.computed;
  var key3 = node3.key;
  return !computed && (key3.type === "Identifier" && key3.name === name2 || key3.type === "Literal" && key3.value === name2);
}
pp$8.parseExportAllDeclaration = function(node3, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node3.exported = this.parseModuleExportName();
      this.checkExport(exports, node3.exported, this.lastTokStart);
    } else {
      node3.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node3.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node3, "ExportAllDeclaration");
};
pp$8.parseExport = function(node3, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node3, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node3.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node3, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node3.declaration = this.parseExportDeclaration(node3);
    if (node3.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node3.declaration.declarations);
    } else {
      this.checkExport(exports, node3.declaration.id, node3.declaration.id.start);
    }
    node3.specifiers = [];
    node3.source = null;
  } else {
    node3.declaration = null;
    node3.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node3.source = this.parseExprAtom();
    } else {
      for (var i2 = 0, list5 = node3.specifiers; i2 < list5.length; i2 += 1) {
        var spec = list5[i2];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node3.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node3, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node3) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports, name2, pos) {
  if (!exports) {
    return;
  }
  if (typeof name2 !== "string") {
    name2 = name2.type === "Identifier" ? name2.name : name2.value;
  }
  if (hasOwn(exports, name2)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
  }
  exports[name2] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i2 = 0, list5 = pat.properties; i2 < list5.length; i2 += 1) {
      var prop = list5[i2];
      this.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$12 = 0, list$1 = pat.elements; i$12 < list$1.length; i$12 += 1) {
      var elt = list$1[i$12];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i2 = 0, list5 = decls; i2 < list5.length; i2 += 1) {
    var decl = list5[i2];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node3 = this.startNode();
  node3.local = this.parseModuleExportName();
  node3.exported = this.eatContextual("as") ? this.parseModuleExportName() : node3.local;
  this.checkExport(
    exports,
    node3.exported,
    node3.exported.start
  );
  return this.finishNode(node3, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node3) {
  this.next();
  if (this.type === types$1.string) {
    node3.specifiers = empty$1;
    node3.source = this.parseExprAtom();
  } else {
    node3.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node3.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node3, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node3 = this.startNode();
  node3.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node3.local = this.parseIdent();
  } else {
    this.checkUnreserved(node3.imported);
    node3.local = node3.imported;
  }
  this.checkLValSimple(node3.local, BIND_LEXICAL);
  return this.finishNode(node3, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node3 = this.startNode();
  node3.local = this.parseIdent();
  this.checkLValSimple(node3.local, BIND_LEXICAL);
  return this.finishNode(node3, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node3 = this.startNode();
  this.next();
  this.expectContextual("as");
  node3.local = this.parseIdent();
  this.checkLValSimple(node3.local, BIND_LEXICAL);
  return this.finishNode(node3, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
    statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node3, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node3) {
    switch (node3.type) {
      case "Identifier":
        if (this.inAsync && node3.name === "await") {
          this.raise(node3.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node3.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i2 = 0, list5 = node3.properties; i2 < list5.length; i2 += 1) {
          var prop = list5[i2];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node3.kind !== "init") {
          this.raise(node3.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node3.value, isBinding);
        break;
      case "ArrayExpression":
        node3.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node3.elements, isBinding);
        break;
      case "SpreadElement":
        node3.type = "RestElement";
        this.toAssignable(node3.argument, isBinding);
        if (node3.argument.type === "AssignmentPattern") {
          this.raise(node3.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node3.operator !== "=") {
          this.raise(node3.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node3.type = "AssignmentPattern";
        delete node3.operator;
        this.toAssignable(node3.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node3.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node3.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node3.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node3;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i2 = 0; i2 < end; i2++) {
    var elt = exprList[i2];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node3 = this.startNode();
  this.next();
  node3.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node3, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node3 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node3.argument = this.parseBindingAtom();
  return this.finishNode(node3, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node3 = this.startNode();
        this.next();
        node3.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node3, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node3 = this.startNodeAt(startPos, startLoc);
  node3.left = left;
  node3.right = this.parseMaybeAssign();
  return this.finishNode(node3, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i2 = 0, list5 = expr.properties; i2 < list5.length; i2 += 1) {
        var prop = list5[i2];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$12 = 0, list$1 = expr.elements; i$12 < list$1.length; i$12 += 1) {
        var elem = list$1[i$12];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types3 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types3.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types3.f_expr || parent === types3.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types3.b_stat || parent === types3.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types3.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
    var context = this.context[i2];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types3.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types3.b_stat : types3.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types3.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types3.p_stat : types3.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types3.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types3.b_stat)) {
    this.context.push(types3.f_expr);
  } else {
    this.context.push(types3.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types3.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types3.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index4 = this.context.length - 1;
    if (this.context[index4] === types3.f_expr) {
      this.context[index4] = types3.f_expr_gen;
    } else {
      this.context[index4] = types3.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key3 = prop.key;
  var name2;
  switch (key3.type) {
    case "Identifier":
      name2 = key3.name;
      break;
    case "Literal":
      name2 = String(key3.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name2 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key3.start;
          }
        } else {
          this.raiseRecoverable(key3.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name2 = "$" + name2;
  var other = propHash[name2];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key3.start, "Redefinition of property");
    }
  } else {
    other = propHash[name2] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node3.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node3, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node3.left = left;
    this.next();
    node3.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node3, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.test = expr;
    node3.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node3.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node3, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node3 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node3, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node3 = this.startNodeAt(startPos, startLoc);
  node3.left = left;
  node3.operator = op;
  node3.right = right;
  return this.finishNode(node3, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node3 = this.startNode(), update = this.type === types$1.incDec;
    node3.operator = this.value;
    node3.prefix = true;
    this.next();
    node3.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node3.argument);
    } else if (this.strict && node3.operator === "delete" && isLocalVariableAccess(node3.argument)) {
      this.raiseRecoverable(node3.start, "Deleting local variable in strict mode");
    } else if (node3.operator === "delete" && isPrivateFieldAccess(node3.argument)) {
      this.raiseRecoverable(node3.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node3, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node3) {
  return node3.type === "Identifier" || node3.type === "ParenthesizedExpression" && isLocalVariableAccess(node3.expression);
}
function isPrivateFieldAccess(node3) {
  return node3.type === "MemberExpression" && node3.property.type === "PrivateIdentifier" || node3.type === "ChainExpression" && isPrivateFieldAccess(node3.expression) || node3.type === "ParenthesizedExpression" && isPrivateFieldAccess(node3.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
  var optionalChained = false;
  while (true) {
    var element3 = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element3.optional) {
      optionalChained = true;
    }
    if (element3 === base2 || element3.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element3;
        element3 = this.finishNode(chainNode, "ChainExpression");
      }
      return element3;
    }
    base2 = element3;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.object = base2;
    if (computed) {
      node3.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base2.type !== "Super") {
      node3.property = this.parsePrivateIdent();
    } else {
      node3.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node3.computed = !!computed;
    if (optionalSupported) {
      node3.optional = optional;
    }
    base2 = this.finishNode(node3, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base2;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base2 = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base2;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base2 = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base2;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node3, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node3 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node3.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node3, "Super");
    case types$1._this:
      node3 = this.startNode();
      this.next();
      return this.finishNode(node3, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types3.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value = this.value;
      node3 = this.parseLiteral(value.value);
      node3.regex = { pattern: value.pattern, flags: value.flags };
      return node3;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node3 = this.startNode();
      node3.value = this.type === types$1._null ? null : this.type === types$1._true;
      node3.raw = this.type.keyword;
      this.next();
      return this.finishNode(node3, "Literal");
    case types$1.parenL:
      var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start2;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start2;
        }
      }
      return expr;
    case types$1.bracketL:
      node3 = this.startNode();
      this.next();
      node3.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node3, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types3.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node3 = this.startNode();
      this.next();
      return this.parseFunction(node3, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node3 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node3);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node3.start, node3.loc && node3.loc.start);
    meta.name = "import";
    node3.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node3);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node3) {
  this.next();
  node3.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node3, "ImportExpression");
};
pp$5.parseImportMeta = function(node3) {
  this.next();
  var containsEsc = this.containsEsc;
  node3.property = this.parseIdent(true);
  if (node3.property.name !== "meta") {
    this.raiseRecoverable(node3.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node3.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node3.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node3, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node3 = this.startNode();
  node3.value = value;
  node3.raw = this.input.slice(this.start, this.end);
  if (node3.raw.charCodeAt(node3.raw.length - 1) === 110) {
    node3.bigint = node3.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node3, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item2) {
  return item2;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty3 = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node3 = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node3.start, node3.loc && node3.loc.start);
    meta.name = "new";
    node3.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node3.property = this.parseIdent(true);
    if (node3.property.name !== "target") {
      this.raiseRecoverable(node3.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node3.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node3.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node3, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node3.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node3.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node3.arguments = empty3;
  }
  return this.finishNode(node3, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node3 = this.startNode();
  this.next();
  node3.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node3.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node3.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node3.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node3, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node3 = this.startNode(), first = true, propHash = {};
  node3.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node3.properties.push(prop);
  }
  return this.finishNode(node3, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  prop.kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start2 = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start2, "getter should have no params");
    } else {
      this.raiseRecoverable(start2, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node3) {
  node3.id = null;
  if (this.options.ecmaVersion >= 6) {
    node3.generator = node3.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node3.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node3 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node3);
  if (this.options.ecmaVersion >= 6) {
    node3.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node3.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node3.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node3.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node3, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node3, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node3, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node3);
  if (this.options.ecmaVersion >= 8) {
    node3.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node3.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node3, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node3, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node3, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node3.body = this.parseMaybeAssign(forInit);
    node3.expression = true;
    this.checkParams(node3, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node3.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node3.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node3, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node3.params));
    if (this.strict && node3.id) {
      this.checkLValSimple(node3.id, BIND_OUTSIDE);
    }
    node3.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node3.expression = false;
    this.adaptDirectivePrologue(node3.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i2 = 0, list5 = params; i2 < list5.length; i2 += 1) {
    var param = list5[i2];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node3, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i2 = 0, list5 = node3.params; i2 < list5.length; i2 += 1) {
    var param = list5[i2];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start2 = ref2.start;
  var end = ref2.end;
  var name2 = ref2.name;
  if (this.inGenerator && name2 === "yield") {
    this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name2 === "await") {
    this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
    this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
    this.raise(start2, "Cannot use " + name2 + " in class static initialization block");
  }
  if (this.keywords.test(name2)) {
    this.raise(start2, "Unexpected keyword '" + name2 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start2, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name2)) {
    if (!this.inAsync && name2 === "await") {
      this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start2, "The keyword '" + name2 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node3 = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node3, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node3);
    if (node3.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node3.start;
    }
  }
  return node3;
};
pp$5.parseIdentNode = function() {
  var node3 = this.startNode();
  if (this.type === types$1.name) {
    node3.name = this.value;
  } else if (this.type.keyword) {
    node3.name = this.type.keyword;
    if ((node3.name === "class" || node3.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node3;
};
pp$5.parsePrivateIdent = function() {
  var node3 = this.startNode();
  if (this.type === types$1.privateId) {
    node3.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node3, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node3.start, "Private field '#" + node3.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node3);
    }
  }
  return node3;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node3 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node3.delegate = false;
    node3.argument = null;
  } else {
    node3.delegate = this.eat(types$1.star);
    node3.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node3, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node3 = this.startNode();
  this.next();
  node3.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node3, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name2, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
    scope.lexical.push(name2);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name2];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name2);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name2) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
    }
    scope$2.functions.push(name2);
  } else {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
      var scope$3 = this.scopeStack[i2];
      if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name2);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node5 = function Node6(parser2, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser2.options.locations) {
    this.loc = new SourceLocation(parser2, loc);
  }
  if (parser2.options.directSourceFile) {
    this.sourceFile = parser2.options.directSourceFile;
  }
  if (parser2.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node5(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node5(this, pos, loc);
};
function finishNodeAt(node3, type, pos, loc) {
  node3.type = type;
  node3.end = pos;
  if (this.options.locations) {
    node3.loc.end = loc;
  }
  if (this.options.ranges) {
    node3.range[1] = pos;
  }
  return node3;
}
pp$2.finishNode = function(node3, type) {
  return finishNodeAt.call(this, node3, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node3, type, pos, loc) {
  return finishNodeAt.call(this, node3, type, pos, loc);
};
pp$2.copyNode = function(node3) {
  var newNode = new Node5(this, node3.start, this.startLoc);
  for (var prop in node3) {
    newNode[prop] = node3[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i2 = 0, list5 = [9, 10, 11, 12, 13, 14]; i2 < list5.length; i2 += 1) {
  ecmaVersion = list5[i2];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i2;
var list5;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base2) {
  this.parent = parent;
  this.base = base2 || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser2) {
  this.parser = parser2;
  this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "") + (parser2.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser2.options.ecmaVersion >= 14 ? 14 : parser2.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start2, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start2 | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i2, forceU) {
  if (forceU === void 0) forceU = false;
  var s2 = this.source;
  var l2 = s2.length;
  if (i2 >= l2) {
    return -1;
  }
  var c = s2.charCodeAt(i2);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l2) {
    return c;
  }
  var next = s2.charCodeAt(i2 + 1);
  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
  if (forceU === void 0) forceU = false;
  var s2 = this.source;
  var l2 = s2.length;
  if (i2 >= l2) {
    return l2;
  }
  var c = s2.charCodeAt(i2), next;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l2 || (next = s2.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
    return i2 + 1;
  }
  return i2 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i2 = 0, list5 = chs; i2 < list5.length; i2 += 1) {
    var ch = list5[i2];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state2) {
  var validFlags = state2.validFlags;
  var flags = state2.flags;
  var u = false;
  var v = false;
  for (var i2 = 0; i2 < flags.length; i2++) {
    var flag = flags.charAt(i2);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state2.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i2 + 1) > -1) {
      this.raise(state2.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state2.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _ in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state2) {
  this.regexp_pattern(state2);
  if (!state2.switchN && this.options.ecmaVersion >= 9 && hasProp(state2.groupNames)) {
    state2.switchN = true;
    this.regexp_pattern(state2);
  }
};
pp$1.regexp_pattern = function(state2) {
  state2.pos = 0;
  state2.lastIntValue = 0;
  state2.lastStringValue = "";
  state2.lastAssertionIsQuantifiable = false;
  state2.numCapturingParens = 0;
  state2.maxBackReference = 0;
  state2.groupNames = /* @__PURE__ */ Object.create(null);
  state2.backReferenceNames.length = 0;
  state2.branchID = null;
  this.regexp_disjunction(state2);
  if (state2.pos !== state2.source.length) {
    if (state2.eat(
      41
      /* ) */
    )) {
      state2.raise("Unmatched ')'");
    }
    if (state2.eat(
      93
      /* ] */
    ) || state2.eat(
      125
      /* } */
    )) {
      state2.raise("Lone quantifier brackets");
    }
  }
  if (state2.maxBackReference > state2.numCapturingParens) {
    state2.raise("Invalid escape");
  }
  for (var i2 = 0, list5 = state2.backReferenceNames; i2 < list5.length; i2 += 1) {
    var name2 = list5[i2];
    if (!state2.groupNames[name2]) {
      state2.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state2) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state2.branchID = new BranchID(state2.branchID, null);
  }
  this.regexp_alternative(state2);
  while (state2.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state2.branchID = state2.branchID.sibling();
    }
    this.regexp_alternative(state2);
  }
  if (trackDisjunction) {
    state2.branchID = state2.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state2, true)) {
    state2.raise("Nothing to repeat");
  }
  if (state2.eat(
    123
    /* { */
  )) {
    state2.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state2) {
  while (state2.pos < state2.source.length && this.regexp_eatTerm(state2)) {
  }
};
pp$1.regexp_eatTerm = function(state2) {
  if (this.regexp_eatAssertion(state2)) {
    if (state2.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state2)) {
      if (state2.switchU) {
        state2.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state2.switchU ? this.regexp_eatAtom(state2) : this.regexp_eatExtendedAtom(state2)) {
    this.regexp_eatQuantifier(state2);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state2) {
  var start2 = state2.pos;
  state2.lastAssertionIsQuantifiable = false;
  if (state2.eat(
    94
    /* ^ */
  ) || state2.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state2.eat(
    92
    /* \ */
  )) {
    if (state2.eat(
      66
      /* B */
    ) || state2.eat(
      98
      /* b */
    )) {
      return true;
    }
    state2.pos = start2;
  }
  if (state2.eat(
    40
    /* ( */
  ) && state2.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state2.eat(
        60
        /* < */
      );
    }
    if (state2.eat(
      61
      /* = */
    ) || state2.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state2);
      if (!state2.eat(
        41
        /* ) */
      )) {
        state2.raise("Unterminated group");
      }
      state2.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state2.pos = start2;
  return false;
};
pp$1.regexp_eatQuantifier = function(state2, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state2, noError)) {
    state2.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state2, noError) {
  return state2.eat(
    42
    /* * */
  ) || state2.eat(
    43
    /* + */
  ) || state2.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state2, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state2, noError) {
  var start2 = state2.pos;
  if (state2.eat(
    123
    /* { */
  )) {
    var min3 = 0, max4 = -1;
    if (this.regexp_eatDecimalDigits(state2)) {
      min3 = state2.lastIntValue;
      if (state2.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state2)) {
        max4 = state2.lastIntValue;
      }
      if (state2.eat(
        125
        /* } */
      )) {
        if (max4 !== -1 && max4 < min3 && !noError) {
          state2.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state2.switchU && !noError) {
      state2.raise("Incomplete quantifier");
    }
    state2.pos = start2;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state2) {
  return this.regexp_eatPatternCharacters(state2) || state2.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state2) || this.regexp_eatCharacterClass(state2) || this.regexp_eatUncapturingGroup(state2) || this.regexp_eatCapturingGroup(state2);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state2) {
  var start2 = state2.pos;
  if (state2.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state2)) {
      return true;
    }
    state2.pos = start2;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state2) {
  var start2 = state2.pos;
  if (state2.eat(
    40
    /* ( */
  )) {
    if (state2.eat(
      63
      /* ? */
    ) && state2.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state2);
      if (state2.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state2.raise("Unterminated group");
    }
    state2.pos = start2;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state2) {
  if (state2.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state2);
    } else if (state2.current() === 63) {
      state2.raise("Invalid group");
    }
    this.regexp_disjunction(state2);
    if (state2.eat(
      41
      /* ) */
    )) {
      state2.numCapturingParens += 1;
      return true;
    }
    state2.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state2) {
  return state2.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state2) || this.regexp_eatCharacterClass(state2) || this.regexp_eatUncapturingGroup(state2) || this.regexp_eatCapturingGroup(state2) || this.regexp_eatInvalidBracedQuantifier(state2) || this.regexp_eatExtendedPatternCharacter(state2);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state2) {
  if (this.regexp_eatBracedQuantifier(state2, true)) {
    state2.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state2) {
  var ch = state2.current();
  if (isSyntaxCharacter(ch)) {
    state2.lastIntValue = ch;
    state2.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state2) {
  var start2 = state2.pos;
  var ch = 0;
  while ((ch = state2.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state2.advance();
  }
  return state2.pos !== start2;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state2) {
  var ch = state2.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state2) {
  if (state2.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state2)) {
      state2.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state2.groupNames[state2.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i2 = 0, list5 = known; i2 < list5.length; i2 += 1) {
          var altID = list5[i2];
          if (!altID.separatedFrom(state2.branchID)) {
            state2.raise("Duplicate capture group name");
          }
        }
      } else {
        state2.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state2.groupNames[state2.lastStringValue] = [])).push(state2.branchID);
    } else {
      state2.groupNames[state2.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state2) {
  state2.lastStringValue = "";
  if (state2.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state2) && state2.eat(
      62
      /* > */
    )) {
      return true;
    }
    state2.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state2) {
  state2.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state2)) {
    state2.lastStringValue += codePointToString(state2.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state2)) {
      state2.lastStringValue += codePointToString(state2.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state2) {
  var start2 = state2.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state2.current(forceU);
  state2.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state2, forceU)) {
    ch = state2.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state2.lastIntValue = ch;
    return true;
  }
  state2.pos = start2;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state2) {
  var start2 = state2.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state2.current(forceU);
  state2.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state2, forceU)) {
    ch = state2.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state2.lastIntValue = ch;
    return true;
  }
  state2.pos = start2;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state2) {
  if (this.regexp_eatBackReference(state2) || this.regexp_eatCharacterClassEscape(state2) || this.regexp_eatCharacterEscape(state2) || state2.switchN && this.regexp_eatKGroupName(state2)) {
    return true;
  }
  if (state2.switchU) {
    if (state2.current() === 99) {
      state2.raise("Invalid unicode escape");
    }
    state2.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state2) {
  var start2 = state2.pos;
  if (this.regexp_eatDecimalEscape(state2)) {
    var n2 = state2.lastIntValue;
    if (state2.switchU) {
      if (n2 > state2.maxBackReference) {
        state2.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state2.numCapturingParens) {
      return true;
    }
    state2.pos = start2;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state2) {
  if (state2.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state2)) {
      state2.backReferenceNames.push(state2.lastStringValue);
      return true;
    }
    state2.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state2) {
  return this.regexp_eatControlEscape(state2) || this.regexp_eatCControlLetter(state2) || this.regexp_eatZero(state2) || this.regexp_eatHexEscapeSequence(state2) || this.regexp_eatRegExpUnicodeEscapeSequence(state2, false) || !state2.switchU && this.regexp_eatLegacyOctalEscapeSequence(state2) || this.regexp_eatIdentityEscape(state2);
};
pp$1.regexp_eatCControlLetter = function(state2) {
  var start2 = state2.pos;
  if (state2.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state2)) {
      return true;
    }
    state2.pos = start2;
  }
  return false;
};
pp$1.regexp_eatZero = function(state2) {
  if (state2.current() === 48 && !isDecimalDigit(state2.lookahead())) {
    state2.lastIntValue = 0;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state2) {
  var ch = state2.current();
  if (ch === 116) {
    state2.lastIntValue = 9;
    state2.advance();
    return true;
  }
  if (ch === 110) {
    state2.lastIntValue = 10;
    state2.advance();
    return true;
  }
  if (ch === 118) {
    state2.lastIntValue = 11;
    state2.advance();
    return true;
  }
  if (ch === 102) {
    state2.lastIntValue = 12;
    state2.advance();
    return true;
  }
  if (ch === 114) {
    state2.lastIntValue = 13;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state2) {
  var ch = state2.current();
  if (isControlLetter(ch)) {
    state2.lastIntValue = ch % 32;
    state2.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state2, forceU) {
  if (forceU === void 0) forceU = false;
  var start2 = state2.pos;
  var switchU = forceU || state2.switchU;
  if (state2.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state2, 4)) {
      var lead = state2.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state2.pos;
        if (state2.eat(
          92
          /* \ */
        ) && state2.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state2, 4)) {
          var trail2 = state2.lastIntValue;
          if (trail2 >= 56320 && trail2 <= 57343) {
            state2.lastIntValue = (lead - 55296) * 1024 + (trail2 - 56320) + 65536;
            return true;
          }
        }
        state2.pos = leadSurrogateEnd;
        state2.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state2.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state2) && state2.eat(
      125
      /* } */
    ) && isValidUnicode(state2.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state2.raise("Invalid unicode escape");
    }
    state2.pos = start2;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state2) {
  if (state2.switchU) {
    if (this.regexp_eatSyntaxCharacter(state2)) {
      return true;
    }
    if (state2.eat(
      47
      /* / */
    )) {
      state2.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state2.current();
  if (ch !== 99 && (!state2.switchN || ch !== 107)) {
    state2.lastIntValue = ch;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state2) {
  state2.lastIntValue = 0;
  var ch = state2.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state2.lastIntValue = 10 * state2.lastIntValue + (ch - 48);
      state2.advance();
    } while ((ch = state2.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state2) {
  var ch = state2.current();
  if (isCharacterClassEscape(ch)) {
    state2.lastIntValue = -1;
    state2.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state2.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state2.lastIntValue = -1;
    state2.advance();
    var result;
    if (state2.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state2)) && state2.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state2.raise("Invalid property name");
      }
      return result;
    }
    state2.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state2) {
  var start2 = state2.pos;
  if (this.regexp_eatUnicodePropertyName(state2) && state2.eat(
    61
    /* = */
  )) {
    var name2 = state2.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state2)) {
      var value = state2.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state2, name2, value);
      return CharSetOk;
    }
  }
  state2.pos = start2;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state2)) {
    var nameOrValue = state2.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state2, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state2, name2, value) {
  if (!hasOwn(state2.unicodeProperties.nonBinary, name2)) {
    state2.raise("Invalid property name");
  }
  if (!state2.unicodeProperties.nonBinary[name2].test(value)) {
    state2.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state2, nameOrValue) {
  if (state2.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state2.switchV && state2.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state2.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state2) {
  var ch = 0;
  state2.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state2.current())) {
    state2.lastStringValue += codePointToString(ch);
    state2.advance();
  }
  return state2.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state2) {
  var ch = 0;
  state2.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state2.current())) {
    state2.lastStringValue += codePointToString(ch);
    state2.advance();
  }
  return state2.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state2) {
  return this.regexp_eatUnicodePropertyValue(state2);
};
pp$1.regexp_eatCharacterClass = function(state2) {
  if (state2.eat(
    91
    /* [ */
  )) {
    var negate = state2.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state2);
    if (!state2.eat(
      93
      /* ] */
    )) {
      state2.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state2.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state2) {
  if (state2.current() === 93) {
    return CharSetOk;
  }
  if (state2.switchV) {
    return this.regexp_classSetExpression(state2);
  }
  this.regexp_nonEmptyClassRanges(state2);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state2) {
  while (this.regexp_eatClassAtom(state2)) {
    var left = state2.lastIntValue;
    if (state2.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state2)) {
      var right = state2.lastIntValue;
      if (state2.switchU && (left === -1 || right === -1)) {
        state2.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state2.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state2) {
  var start2 = state2.pos;
  if (state2.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state2)) {
      return true;
    }
    if (state2.switchU) {
      var ch$1 = state2.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state2.raise("Invalid class escape");
      }
      state2.raise("Invalid escape");
    }
    state2.pos = start2;
  }
  var ch = state2.current();
  if (ch !== 93) {
    state2.lastIntValue = ch;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state2) {
  var start2 = state2.pos;
  if (state2.eat(
    98
    /* b */
  )) {
    state2.lastIntValue = 8;
    return true;
  }
  if (state2.switchU && state2.eat(
    45
    /* - */
  )) {
    state2.lastIntValue = 45;
    return true;
  }
  if (!state2.switchU && state2.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state2)) {
      return true;
    }
    state2.pos = start2;
  }
  return this.regexp_eatCharacterClassEscape(state2) || this.regexp_eatCharacterEscape(state2);
};
pp$1.regexp_classSetExpression = function(state2) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state2)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state2)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start2 = state2.pos;
    while (state2.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state2.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state2))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state2.raise("Invalid character in character class");
    }
    if (start2 !== state2.pos) {
      return result;
    }
    while (state2.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state2)) {
        continue;
      }
      state2.raise("Invalid character in character class");
    }
    if (start2 !== state2.pos) {
      return result;
    }
  } else {
    state2.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state2)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state2);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state2) {
  var start2 = state2.pos;
  if (this.regexp_eatClassSetCharacter(state2)) {
    var left = state2.lastIntValue;
    if (state2.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state2)) {
      var right = state2.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state2.raise("Range out of order in character class");
      }
      return true;
    }
    state2.pos = start2;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state2) {
  if (this.regexp_eatClassSetCharacter(state2)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state2) || this.regexp_eatNestedClass(state2);
};
pp$1.regexp_eatNestedClass = function(state2) {
  var start2 = state2.pos;
  if (state2.eat(
    91
    /* [ */
  )) {
    var negate = state2.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state2);
    if (state2.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state2.raise("Negated character class may contain strings");
      }
      return result;
    }
    state2.pos = start2;
  }
  if (state2.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state2);
    if (result$1) {
      return result$1;
    }
    state2.pos = start2;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state2) {
  var start2 = state2.pos;
  if (state2.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state2.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state2);
      if (state2.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state2.raise("Invalid escape");
    }
    state2.pos = start2;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state2) {
  var result = this.regexp_classString(state2);
  while (state2.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state2) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state2) {
  var count2 = 0;
  while (this.regexp_eatClassSetCharacter(state2)) {
    count2++;
  }
  return count2 === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state2) {
  var start2 = state2.pos;
  if (state2.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state2) || this.regexp_eatClassSetReservedPunctuator(state2)) {
      return true;
    }
    if (state2.eat(
      98
      /* b */
    )) {
      state2.lastIntValue = 8;
      return true;
    }
    state2.pos = start2;
    return false;
  }
  var ch = state2.current();
  if (ch < 0 || ch === state2.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state2.advance();
  state2.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state2) {
  var ch = state2.current();
  if (isClassSetReservedPunctuator(ch)) {
    state2.lastIntValue = ch;
    state2.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state2) {
  var ch = state2.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state2.lastIntValue = ch % 32;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state2) {
  var start2 = state2.pos;
  if (state2.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state2, 2)) {
      return true;
    }
    if (state2.switchU) {
      state2.raise("Invalid escape");
    }
    state2.pos = start2;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state2) {
  var start2 = state2.pos;
  var ch = 0;
  state2.lastIntValue = 0;
  while (isDecimalDigit(ch = state2.current())) {
    state2.lastIntValue = 10 * state2.lastIntValue + (ch - 48);
    state2.advance();
  }
  return state2.pos !== start2;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state2) {
  var start2 = state2.pos;
  var ch = 0;
  state2.lastIntValue = 0;
  while (isHexDigit(ch = state2.current())) {
    state2.lastIntValue = 16 * state2.lastIntValue + hexToInt(ch);
    state2.advance();
  }
  return state2.pos !== start2;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state2) {
  if (this.regexp_eatOctalDigit(state2)) {
    var n1 = state2.lastIntValue;
    if (this.regexp_eatOctalDigit(state2)) {
      var n2 = state2.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state2)) {
        state2.lastIntValue = n1 * 64 + n2 * 8 + state2.lastIntValue;
      } else {
        state2.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state2.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state2) {
  var ch = state2.current();
  if (isOctalDigit(ch)) {
    state2.lastIntValue = ch - 48;
    state2.advance();
    return true;
  }
  state2.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state2, length) {
  var start2 = state2.pos;
  state2.lastIntValue = 0;
  for (var i2 = 0; i2 < length; ++i2) {
    var ch = state2.current();
    if (!isHexDigit(ch)) {
      state2.pos = start2;
      return false;
    }
    state2.lastIntValue = 16 * state2.lastIntValue + hexToInt(ch);
    state2.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code4) {
  if (isIdentifierStart(code4, this.options.ecmaVersion >= 6) || code4 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code4);
};
pp.fullCharCodeAtPos = function() {
  var code4 = this.input.charCodeAt(this.pos);
  if (code4 <= 55295 || code4 >= 56320) {
    return code4;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code4 : (code4 << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start2 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start2 + 2, end),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start2 = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start2 + startSkip, this.pos),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code4) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size4 = 1;
  var tokentype = code4 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code4 === 42 && next === 42) {
    ++size4;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size4 + 1);
  }
  return this.finishOp(tokentype, size4);
};
pp.readToken_pipe_amp = function(code4) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code4) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code4 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code4 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code4) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code4) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code4) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size4 = 1;
  if (next === code4) {
    size4 = code4 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size4) === 61) {
      return this.finishOp(types$1.assign, size4 + 1);
    }
    return this.finishOp(types$1.bitShift, size4);
  }
  if (next === 33 && code4 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size4 = 2;
  }
  return this.finishOp(types$1.relational, size4);
};
pp.readToken_eq_excl = function(code4) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code4 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code4 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code4 = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code4 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code4, true) || code4 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code4) + "'");
};
pp.getTokenFromCode = function(code4) {
  switch (code4) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code4);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code4);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code4);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code4);
    case 60:
    case 62:
      return this.readToken_lt_gt(code4);
    case 61:
    case 33:
      return this.readToken_eq_excl(code4);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code4) + "'");
};
pp.finishOp = function(type, size4) {
  var str = this.input.slice(this.pos, this.pos + size4);
  this.pos += size4;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start2 = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start2, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start2, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start2, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state2 = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state2.reset(start2, pattern, flags);
  this.validateRegExpFlags(state2);
  this.validateRegExpPattern(state2);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e3) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start2 = this.pos, total = 0, lastCode = 0;
  for (var i2 = 0, e3 = len == null ? Infinity : len; i2 < e3; ++i2, ++this.pos) {
    var code4 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code4 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i2 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code4;
      continue;
    }
    if (code4 >= 97) {
      val = code4 - 97 + 10;
    } else if (code4 >= 65) {
      val = code4 - 65 + 10;
    } else if (code4 >= 48 && code4 <= 57) {
      val = code4 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code4;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start2 || len != null && this.pos - start2 !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start2 = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start2 = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start2, "Invalid number");
  }
  var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
  if (octal && this.strict) {
    this.raise(start2, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start2, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start2, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code4;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code4 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code4 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code4 = this.readHexChar(4);
  }
  return code4;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position2, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position2, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.12.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node: Node5,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types3,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};

// node_modules/micromark-extension-mdxjs/index.js
var import_acorn_jsx = __toESM(require_acorn_jsx());

// node_modules/estree-util-visit/lib/color.default.js
function color2(d) {
  return d;
}

// node_modules/estree-util-visit/lib/index.js
var own6 = {}.hasOwnProperty;
var CONTINUE2 = Symbol("continue");
var EXIT2 = Symbol("exit");
var SKIP2 = Symbol("skip");
function visit2(tree, visitor) {
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    if (visitor.enter) enter = visitor.enter;
    if (visitor.leave) leave = visitor.leave;
  }
  build(tree, void 0, void 0, [])();
  function build(node3, key3, index4, parents) {
    if (nodelike(node3)) {
      visit3.displayName = "node (" + color2(node3.type) + ")";
    }
    return visit3;
    function visit3() {
      const result = enter ? toResult2(enter(node3, key3, index4, parents)) : [];
      if (result[0] === EXIT2) {
        return result;
      }
      if (result[0] !== SKIP2) {
        let cKey;
        for (cKey in node3) {
          if (own6.call(node3, cKey) && node3[cKey] && typeof node3[cKey] === "object" && // @ts-expect-error: custom esast extension.
          cKey !== "data" && // @ts-expect-error: custom esast extension.
          cKey !== "position") {
            const grandparents = parents.concat(node3);
            const value = node3[cKey];
            if (Array.isArray(value)) {
              const nodes = (
                /** @type {Array<unknown>} */
                value
              );
              let cIndex = 0;
              while (cIndex > -1 && cIndex < nodes.length) {
                const subvalue = nodes[cIndex];
                if (nodelike(subvalue)) {
                  const subresult = build(
                    subvalue,
                    cKey,
                    cIndex,
                    grandparents
                  )();
                  if (subresult[0] === EXIT2) return subresult;
                  cIndex = typeof subresult[1] === "number" ? subresult[1] : cIndex + 1;
                } else {
                  cIndex++;
                }
              }
            } else if (nodelike(value)) {
              const subresult = build(value, cKey, void 0, grandparents)();
              if (subresult[0] === EXIT2) return subresult;
            }
          }
        }
      }
      return leave ? toResult2(leave(node3, key3, index4, parents)) : result;
    }
  }
}
function toResult2(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE2, value];
  }
  return [value];
}
function nodelike(value) {
  return Boolean(
    value && typeof value === "object" && "type" in value && typeof value.type === "string" && value.type.length > 0
  );
}

// node_modules/micromark-util-events-to-acorn/dev/index.js
function eventsToAcorn(events, options) {
  const prefix = options.prefix || "";
  const suffix = options.suffix || "";
  const acornOptions = Object.assign({}, options.acornOptions);
  const comments = [];
  const tokens = [];
  const onComment = acornOptions.onComment;
  const onToken = acornOptions.onToken;
  let swallow = false;
  let estree;
  let exception;
  const acornConfig = Object.assign({}, acornOptions, {
    onComment: comments,
    preserveParens: true
  });
  if (onToken) {
    acornConfig.onToken = tokens;
  }
  const collection2 = collect(events, options.tokenTypes);
  const source = collection2.value;
  const value = prefix + source + suffix;
  const isEmptyExpression = options.expression && empty4(source);
  if (isEmptyExpression && !options.allowEmpty) {
    throw new VFileMessage("Unexpected empty expression", {
      place: parseOffsetToUnistPoint(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression"
    });
  }
  try {
    estree = options.expression && !isEmptyExpression ? options.acorn.parseExpressionAt(value, 0, acornConfig) : options.acorn.parse(value, acornConfig);
  } catch (error_) {
    const error3 = (
      /** @type {AcornError} */
      error_
    );
    const point3 = parseOffsetToUnistPoint(error3.pos);
    error3.message = String(error3.message).replace(/ \(\d+:\d+\)$/, "");
    ok(point3.offset !== void 0, "expected `offset`");
    error3.pos = point3.offset;
    error3.loc = { line: point3.line, column: point3.column - 1 };
    exception = error3;
    swallow = error3.raisedAt >= prefix.length + source.length || // Broken comments are raised at their start, not their end.
    error3.message === "Unterminated comment";
  }
  if (estree && options.expression && !isEmptyExpression) {
    if (empty4(value.slice(estree.end, value.length - suffix.length))) {
      estree = {
        type: "Program",
        start: 0,
        end: prefix.length + source.length,
        // @ts-expect-error: It’s good.
        body: [
          {
            type: "ExpressionStatement",
            expression: estree,
            start: 0,
            end: prefix.length + source.length
          }
        ],
        sourceType: "module",
        comments: []
      };
    } else {
      const point3 = parseOffsetToUnistPoint(estree.end);
      const error3 = (
        /** @type {AcornError} */
        new Error("Unexpected content after expression")
      );
      ok(point3.offset !== void 0, "expected `offset`");
      error3.pos = point3.offset;
      error3.loc = { line: point3.line, column: point3.column - 1 };
      exception = error3;
      estree = void 0;
    }
  }
  if (estree) {
    estree.comments = comments;
    visit2(estree, function(esnode, field, index4, parents) {
      let context = (
        /** @type {AcornNode | Array<AcornNode>} */
        parents[parents.length - 1]
      );
      let prop = field;
      if (esnode.type === "ParenthesizedExpression" && context && prop) {
        if (typeof index4 === "number") {
          context = context[prop];
          prop = index4;
        }
        context[prop] = esnode.expression;
      }
      fixPosition(esnode);
    });
    if (Array.isArray(onComment)) {
      onComment.push(...comments);
    } else if (typeof onComment === "function") {
      for (const comment2 of comments) {
        ok(comment2.loc, "expected `loc` on comment");
        onComment(
          comment2.type === "Block",
          comment2.value,
          comment2.start,
          comment2.end,
          comment2.loc.start,
          comment2.loc.end
        );
      }
    }
    for (const token of tokens) {
      if (token.end <= prefix.length || token.start - prefix.length >= source.length) {
        continue;
      }
      fixPosition(token);
      if (Array.isArray(onToken)) {
        onToken.push(token);
      } else {
        ok(typeof onToken === "function", "expected function");
        onToken(token);
      }
    }
  }
  return { estree, error: exception, swallow };
  function fixPosition(nodeOrToken) {
    ok(
      "start" in nodeOrToken,
      "expected `start` in node or token from acorn"
    );
    ok("end" in nodeOrToken, "expected `end` in node or token from acorn");
    const pointStart = parseOffsetToUnistPoint(nodeOrToken.start);
    const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end);
    ok(pointStart.offset !== void 0, "expected `offset`");
    ok(pointEnd.offset !== void 0, "expected `offset`");
    nodeOrToken.start = pointStart.offset;
    nodeOrToken.end = pointEnd.offset;
    nodeOrToken.loc = {
      start: {
        line: pointStart.line,
        column: pointStart.column - 1,
        offset: pointStart.offset
      },
      end: {
        line: pointEnd.line,
        column: pointEnd.column - 1,
        offset: pointEnd.offset
      }
    };
    nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end];
  }
  function parseOffsetToUnistPoint(acornOffset) {
    let sourceOffset = acornOffset - prefix.length;
    if (sourceOffset < 0) {
      sourceOffset = 0;
    } else if (sourceOffset > source.length) {
      sourceOffset = source.length;
    }
    let point3 = relativeToPoint(collection2.stops, sourceOffset);
    if (!point3) {
      ok(
        options.start,
        "empty expressions are need `options.start` being passed"
      );
      point3 = {
        line: options.start.line,
        column: options.start.column,
        offset: options.start.offset
      };
    }
    return point3;
  }
}
function empty4(value) {
  return /^\s*$/.test(
    value.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, "")
  );
}
function collect(events, tokenTypes) {
  const result = { value: "", stops: [] };
  let index4 = -1;
  while (++index4 < events.length) {
    const event = events[index4];
    if (event[0] === "enter") {
      const type = event[1].type;
      if (type === types2.lineEnding || tokenTypes.includes(type)) {
        const chunks = event[2].sliceStream(event[1]);
        while (chunks.length > 0 && chunks[0] === codes.virtualSpace) {
          chunks.shift();
        }
        const value = serializeChunks2(chunks);
        result.stops.push([result.value.length, event[1].start]);
        result.value += value;
        result.stops.push([result.value.length, event[1].end]);
      }
    }
  }
  return result;
}
function relativeToPoint(stops, relative) {
  let index4 = 0;
  while (index4 < stops.length && stops[index4][0] <= relative) {
    index4 += 1;
  }
  if (index4 === 0) {
    return void 0;
  }
  const [stopRelative, stopAbsolute] = stops[index4 - 1];
  const rest = relative - stopRelative;
  return {
    line: stopAbsolute.line,
    column: stopAbsolute.column + rest,
    offset: stopAbsolute.offset + rest
  };
}
function serializeChunks2(chunks) {
  let index4 = -1;
  const result = [];
  let atTab;
  while (++index4 < chunks.length) {
    const chunk = chunks[index4];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (atTab) continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}

// node_modules/unist-util-position-from-estree/lib/index.js
function positionFromEstree(node3) {
  const nodeLike = node3 || {};
  const loc = nodeLike.loc || {};
  const range = nodeLike.range || [void 0, void 0];
  const start2 = pointOrUndefined(loc.start, range[0] || nodeLike.start);
  const end = pointOrUndefined(loc.end, range[1] || nodeLike.end);
  if (start2 && end) {
    return { start: start2, end };
  }
}
function pointOrUndefined(estreePoint, estreeOffset) {
  if (estreePoint && typeof estreePoint === "object") {
    const line = "line" in estreePoint ? numberOrUndefined(estreePoint.line) : void 0;
    const column = "column" in estreePoint ? numberOrUndefined(estreePoint.column) : void 0;
    if (line && column !== void 0) {
      return {
        line,
        column: column + 1,
        offset: numberOrUndefined(estreeOffset)
      };
    }
  }
}
function numberOrUndefined(value) {
  return typeof value === "number" && value > -1 ? value : void 0;
}

// node_modules/micromark-factory-mdx-expression/dev/index.js
var trouble = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression";
var unexpectedEofHash = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-";
var unexpectedLazyHash = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed";
var nonSpreadHash = "#unexpected-type-in-code-expected-an-object-spread-spread";
var spreadExtraHash = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported";
var acornHash = "#could-not-parse-expression-with-acorn";
function factoryMdxExpression(effects, ok3, type, markerType, chunkType, acorn, acornOptions, addResult, spread, allowEmpty, allowLazy) {
  const self2 = this;
  const eventStart = this.events.length + 3;
  let size4 = 0;
  let pointStart;
  let lastCrash;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftCurlyBrace, "expected `{`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code4);
    effects.exit(markerType);
    pointStart = self2.now();
    return before;
  }
  function before(code4) {
    if (code4 === codes.eof) {
      if (lastCrash) throw lastCrash;
      const error3 = new VFileMessage(
        "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
        {
          place: self2.now(),
          ruleId: "unexpected-eof",
          source: "micromark-extension-mdx-expression"
        }
      );
      error3.url = trouble + unexpectedEofHash;
      throw error3;
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      return eolAfter;
    }
    if (code4 === codes.rightCurlyBrace && size4 === 0) {
      const next = acorn ? mdxExpressionParse.call(
        self2,
        acorn,
        acornOptions,
        chunkType,
        eventStart,
        pointStart,
        allowEmpty || false,
        spread || false
      ) : { type: "ok", estree: void 0 };
      if (next.type === "ok") {
        effects.enter(markerType);
        effects.consume(code4);
        effects.exit(markerType);
        const token = effects.exit(type);
        if (addResult && next.estree) {
          Object.assign(token, { estree: next.estree });
        }
        return ok3;
      }
      lastCrash = next.message;
      effects.enter(chunkType);
      effects.consume(code4);
      return inside;
    }
    effects.enter(chunkType);
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === codes.rightCurlyBrace && size4 === 0 || code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(chunkType);
      return before(code4);
    }
    if (code4 === codes.leftCurlyBrace && !acorn) {
      size4 += 1;
    } else if (code4 === codes.rightCurlyBrace) {
      size4 -= 1;
    }
    effects.consume(code4);
    return inside;
  }
  function eolAfter(code4) {
    const now = self2.now();
    if (now.line !== pointStart.line && !allowLazy && self2.parser.lazy[now.line]) {
      const error3 = new VFileMessage(
        "Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        {
          place: self2.now(),
          ruleId: "unexpected-lazy",
          source: "micromark-extension-mdx-expression"
        }
      );
      error3.url = trouble + unexpectedLazyHash;
      throw error3;
    }
    return before(code4);
  }
}
function mdxExpressionParse(acorn, acornOptions, chunkType, eventStart, pointStart, allowEmpty, spread) {
  const result = eventsToAcorn(this.events.slice(eventStart), {
    acorn,
    tokenTypes: [chunkType],
    acornOptions,
    start: pointStart,
    expression: true,
    allowEmpty,
    prefix: spread ? "({" : "",
    suffix: spread ? "})" : ""
  });
  const estree = result.estree;
  if (spread && estree) {
    ok(estree.type === "Program", "expected program");
    const head = estree.body[0];
    ok(head, "expected body");
    if (head.type !== "ExpressionStatement" || head.expression.type !== "ObjectExpression") {
      const place = positionFromEstree(head);
      ok(place, "expected position");
      const error3 = new VFileMessage(
        "Unexpected `" + head.type + "` in code: expected an object spread (`{...spread}`)",
        {
          place: place.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression"
        }
      );
      error3.url = trouble + nonSpreadHash;
      throw error3;
    }
    if (head.expression.properties[1]) {
      const place = positionFromEstree(head.expression.properties[1]);
      ok(place, "expected position");
      const error3 = new VFileMessage(
        "Unexpected extra content in spread: only a single spread is supported",
        {
          place: place.start,
          ruleId: "spread-extra",
          source: "micromark-extension-mdx-expression"
        }
      );
      error3.url = trouble + spreadExtraHash;
      throw error3;
    }
    if (head.expression.properties[0] && head.expression.properties[0].type !== "SpreadElement") {
      const place = positionFromEstree(head.expression.properties[0]);
      ok(place, "expected position");
      const error3 = new VFileMessage(
        "Unexpected `" + head.expression.properties[0].type + "` in code: only spread elements are supported",
        {
          place: place.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression"
        }
      );
      error3.url = trouble + nonSpreadHash;
      throw error3;
    }
  }
  if (result.error) {
    const error3 = new VFileMessage("Could not parse expression with acorn", {
      cause: result.error,
      place: {
        line: result.error.loc.line,
        column: result.error.loc.column + 1,
        offset: result.error.pos
      },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression"
    });
    error3.url = trouble + acornHash;
    return { type: "nok", message: error3 };
  }
  return { type: "ok", estree };
}

// node_modules/micromark-extension-mdx-expression/dev/lib/syntax.js
function mdxExpression(options) {
  const options_ = options || {};
  const addResult = options_.addResult;
  const acorn = options_.acorn;
  const spread = options_.spread;
  let allowEmpty = options_.allowEmpty;
  let acornOptions;
  if (allowEmpty === null || allowEmpty === void 0) {
    allowEmpty = true;
  }
  if (acorn) {
    if (!acorn.parseExpressionAt) {
      throw new Error(
        "Expected a proper `acorn` instance passed in as `options.acorn`"
      );
    }
    acornOptions = Object.assign(
      { ecmaVersion: 2024, sourceType: "module" },
      options_.acornOptions
    );
  } else if (options_.acornOptions || options_.addResult) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  return {
    flow: {
      [codes.leftCurlyBrace]: {
        name: "mdxFlowExpression",
        tokenize: tokenizeFlowExpression,
        concrete: true
      }
    },
    text: {
      [codes.leftCurlyBrace]: {
        name: "mdxTextExpression",
        tokenize: tokenizeTextExpression
      }
    }
  };
  function tokenizeFlowExpression(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code4) {
      ok(code4 === codes.leftCurlyBrace, "expected `{`");
      return before(code4);
    }
    function before(code4) {
      return factoryMdxExpression.call(
        self2,
        effects,
        after,
        "mdxFlowExpression",
        "mdxFlowExpressionMarker",
        "mdxFlowExpressionChunk",
        acorn,
        acornOptions,
        addResult,
        spread,
        allowEmpty
      )(code4);
    }
    function after(code4) {
      return markdownSpace(code4) ? factorySpace(effects, end, types2.whitespace)(code4) : end(code4);
    }
    function end(code4) {
      const lessThanValue = self2.parser.constructs.flow[codes.lessThan];
      const constructs2 = Array.isArray(lessThanValue) ? lessThanValue : (
        /* c8 ignore next 3 -- always a list when normalized. */
        lessThanValue ? [lessThanValue] : []
      );
      const jsxTag = constructs2.find(function(d) {
        return d.name === "mdxJsxFlowTag";
      });
      if (code4 === codes.lessThan && jsxTag) {
        return effects.attempt(jsxTag, end, nok)(code4);
      }
      return code4 === codes.eof || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
    }
  }
  function tokenizeTextExpression(effects, ok3) {
    const self2 = this;
    return start2;
    function start2(code4) {
      ok(code4 === codes.leftCurlyBrace, "expected `{`");
      return factoryMdxExpression.call(
        self2,
        effects,
        ok3,
        "mdxTextExpression",
        "mdxTextExpressionMarker",
        "mdxTextExpressionChunk",
        acorn,
        acornOptions,
        addResult,
        spread,
        allowEmpty,
        true
      )(code4);
    }
  }
}

// node_modules/estree-util-is-identifier-name/lib/index.js
var startRe = /[$_\p{ID_Start}]/u;
var contRe = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u;
var contReJsx = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u;
var emptyOptions2 = {};
function start(code4) {
  return code4 ? startRe.test(String.fromCodePoint(code4)) : false;
}
function cont(code4, options) {
  const settings = options || emptyOptions2;
  const re = settings.jsx ? contReJsx : contRe;
  return code4 ? re.test(String.fromCodePoint(code4)) : false;
}

// node_modules/micromark-extension-mdx-jsx/dev/lib/factory-tag.js
var trouble2 = "https://github.com/micromark/micromark-extension-mdx-jsx";
function factoryTag(effects, ok3, nok, acorn, acornOptions, addResult, allowLazy, tagType, tagMarkerType, tagClosingMarkerType, tagSelfClosingMarker, tagNameType, tagNamePrimaryType, tagNameMemberMarkerType, tagNameMemberType, tagNamePrefixMarkerType, tagNameLocalType, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, tagAttributeType, tagAttributeNameType, tagAttributeNamePrimaryType, tagAttributeNamePrefixMarkerType, tagAttributeNameLocalType, tagAttributeInitializerMarkerType, tagAttributeValueLiteralType, tagAttributeValueLiteralMarkerType, tagAttributeValueLiteralValueType, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionValueType) {
  const self2 = this;
  let returnState;
  let marker;
  return start2;
  function start2(code4) {
    ok(code4 === codes.lessThan, "expected `<`");
    effects.enter(tagType);
    effects.enter(tagMarkerType);
    effects.consume(code4);
    effects.exit(tagMarkerType);
    return startAfter;
  }
  function startAfter(code4) {
    if (markdownLineEndingOrSpace(code4)) {
      return nok(code4);
    }
    returnState = nameBefore;
    return esWhitespaceStart(code4);
  }
  function nameBefore(code4) {
    if (code4 === codes.slash) {
      effects.enter(tagClosingMarkerType);
      effects.consume(code4);
      effects.exit(tagClosingMarkerType);
      returnState = closingTagNameBefore;
      return esWhitespaceStart;
    }
    if (code4 === codes.greaterThan) {
      return tagEnd(code4);
    }
    if (code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code4);
      return primaryName;
    }
    crash(
      code4,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code4 === codes.exclamationMark ? " (note: to create a comment in MDX, use `{/* text */}`)" : "")
    );
  }
  function closingTagNameBefore(code4) {
    if (code4 === codes.greaterThan) {
      return tagEnd(code4);
    }
    if (code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code4);
      return primaryName;
    }
    crash(
      code4,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code4 === codes.asterisk || code4 === codes.slash ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function primaryName(code4) {
    if (code4 !== codes.eof && code4 >= 0 && cont(code4, { jsx: true })) {
      effects.consume(code4);
      return primaryName;
    }
    if (code4 === codes.dot || code4 === codes.slash || code4 === codes.colon || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      effects.exit(tagNamePrimaryType);
      returnState = primaryNameAfter;
      return esWhitespaceStart(code4);
    }
    crash(
      code4,
      "in name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code4 === codes.atSign ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function primaryNameAfter(code4) {
    if (code4 === codes.dot) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code4);
      effects.exit(tagNameMemberMarkerType);
      returnState = memberNameBefore;
      return esWhitespaceStart;
    }
    if (code4 === codes.colon) {
      effects.enter(tagNamePrefixMarkerType);
      effects.consume(code4);
      effects.exit(tagNamePrefixMarkerType);
      returnState = localNameBefore;
      return esWhitespaceStart;
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.exit(tagNameType);
      return attributeBefore(code4);
    }
    crash(
      code4,
      "after name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function memberNameBefore(code4) {
    if (code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.enter(tagNameMemberType);
      effects.consume(code4);
      return memberName;
    }
    crash(
      code4,
      "before member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function memberName(code4) {
    if (code4 !== codes.eof && code4 >= 0 && cont(code4, { jsx: true })) {
      effects.consume(code4);
      return memberName;
    }
    if (code4 === codes.dot || code4 === codes.slash || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      effects.exit(tagNameMemberType);
      returnState = memberNameAfter;
      return esWhitespaceStart(code4);
    }
    crash(
      code4,
      "in member name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code4 === codes.atSign ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function memberNameAfter(code4) {
    if (code4 === codes.dot) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code4);
      effects.exit(tagNameMemberMarkerType);
      returnState = memberNameBefore;
      return esWhitespaceStart;
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.exit(tagNameType);
      return attributeBefore(code4);
    }
    crash(
      code4,
      "after member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function localNameBefore(code4) {
    if (code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.enter(tagNameLocalType);
      effects.consume(code4);
      return localName;
    }
    crash(
      code4,
      "before local name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code4 === codes.plusSign || code4 !== null && code4 > codes.dot && code4 < codes.colon ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function localName(code4) {
    if (code4 !== codes.eof && code4 >= 0 && cont(code4, { jsx: true })) {
      effects.consume(code4);
      return localName;
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      effects.exit(tagNameLocalType);
      returnState = localNameAfter;
      return esWhitespaceStart(code4);
    }
    crash(
      code4,
      "in local name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function localNameAfter(code4) {
    if (code4 === codes.slash || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.exit(tagNameType);
      return attributeBefore(code4);
    }
    crash(
      code4,
      "after local name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeBefore(code4) {
    if (code4 === codes.slash) {
      effects.enter(tagSelfClosingMarker);
      effects.consume(code4);
      effects.exit(tagSelfClosingMarker);
      returnState = selfClosing;
      return esWhitespaceStart;
    }
    if (code4 === codes.greaterThan) {
      return tagEnd(code4);
    }
    if (code4 === codes.leftCurlyBrace) {
      return factoryMdxExpression.call(
        self2,
        effects,
        attributeExpressionAfter,
        tagExpressionAttributeType,
        tagExpressionAttributeMarkerType,
        tagExpressionAttributeValueType,
        acorn,
        acornOptions,
        addResult,
        true,
        false,
        allowLazy
      )(code4);
    }
    if (code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.enter(tagAttributeType);
      effects.enter(tagAttributeNameType);
      effects.enter(tagAttributeNamePrimaryType);
      effects.consume(code4);
      return attributePrimaryName;
    }
    crash(
      code4,
      "before attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeExpressionAfter(code4) {
    returnState = attributeBefore;
    return esWhitespaceStart(code4);
  }
  function attributePrimaryName(code4) {
    if (code4 !== codes.eof && code4 >= 0 && cont(code4, { jsx: true })) {
      effects.consume(code4);
      return attributePrimaryName;
    }
    if (code4 === codes.slash || code4 === codes.colon || code4 === codes.equalsTo || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      effects.exit(tagAttributeNamePrimaryType);
      returnState = attributePrimaryNameAfter;
      return esWhitespaceStart(code4);
    }
    crash(
      code4,
      "in attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function attributePrimaryNameAfter(code4) {
    if (code4 === codes.colon) {
      effects.enter(tagAttributeNamePrefixMarkerType);
      effects.consume(code4);
      effects.exit(tagAttributeNamePrefixMarkerType);
      returnState = attributeLocalNameBefore;
      return esWhitespaceStart;
    }
    if (code4 === codes.equalsTo) {
      effects.exit(tagAttributeNameType);
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code4);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = attributeValueBefore;
      return esWhitespaceStart;
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.exit(tagAttributeNameType);
      effects.exit(tagAttributeType);
      returnState = attributeBefore;
      return esWhitespaceStart(code4);
    }
    crash(
      code4,
      "after attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeLocalNameBefore(code4) {
    if (code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.enter(tagAttributeNameLocalType);
      effects.consume(code4);
      return attributeLocalName;
    }
    crash(
      code4,
      "before local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeLocalName(code4) {
    if (code4 !== codes.eof && code4 >= 0 && cont(code4, { jsx: true })) {
      effects.consume(code4);
      return attributeLocalName;
    }
    if (code4 === codes.slash || code4 === codes.equalsTo || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      effects.exit(tagAttributeNameLocalType);
      effects.exit(tagAttributeNameType);
      returnState = attributeLocalNameAfter;
      return esWhitespaceStart(code4);
    }
    crash(
      code4,
      "in local attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeLocalNameAfter(code4) {
    if (code4 === codes.equalsTo) {
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code4);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = attributeValueBefore;
      return esWhitespaceStart;
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || code4 === codes.leftCurlyBrace || code4 !== codes.eof && code4 >= 0 && start(code4)) {
      effects.exit(tagAttributeType);
      return attributeBefore(code4);
    }
    crash(
      code4,
      "after local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeValueBefore(code4) {
    if (code4 === codes.quotationMark || code4 === codes.apostrophe) {
      effects.enter(tagAttributeValueLiteralType);
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code4);
      effects.exit(tagAttributeValueLiteralMarkerType);
      marker = code4;
      return attributeValueQuotedStart;
    }
    if (code4 === codes.leftCurlyBrace) {
      return factoryMdxExpression.call(
        self2,
        effects,
        attributeValueExpressionAfter,
        tagAttributeValueExpressionType,
        tagAttributeValueExpressionMarkerType,
        tagAttributeValueExpressionValueType,
        acorn,
        acornOptions,
        addResult,
        false,
        false,
        allowLazy
      )(code4);
    }
    crash(
      code4,
      "before attribute value",
      "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (code4 === codes.lessThan ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : "")
    );
  }
  function attributeValueExpressionAfter(code4) {
    effects.exit(tagAttributeType);
    returnState = attributeBefore;
    return esWhitespaceStart(code4);
  }
  function attributeValueQuotedStart(code4) {
    ok(marker !== void 0, "expected `marker` to be defined");
    if (code4 === codes.eof) {
      crash(
        code4,
        "in attribute value",
        "a corresponding closing quote `" + String.fromCodePoint(marker) + "`"
      );
    }
    if (code4 === marker) {
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code4);
      effects.exit(tagAttributeValueLiteralMarkerType);
      effects.exit(tagAttributeValueLiteralType);
      effects.exit(tagAttributeType);
      marker = void 0;
      returnState = attributeBefore;
      return esWhitespaceStart;
    }
    if (markdownLineEnding(code4)) {
      returnState = attributeValueQuotedStart;
      return esWhitespaceStart(code4);
    }
    effects.enter(tagAttributeValueLiteralValueType);
    return attributeValueQuoted(code4);
  }
  function attributeValueQuoted(code4) {
    if (code4 === codes.eof || code4 === marker || markdownLineEnding(code4)) {
      effects.exit(tagAttributeValueLiteralValueType);
      return attributeValueQuotedStart(code4);
    }
    effects.consume(code4);
    return attributeValueQuoted;
  }
  function selfClosing(code4) {
    if (code4 === codes.greaterThan) {
      return tagEnd(code4);
    }
    crash(
      code4,
      "after self-closing slash",
      "`>` to end the tag" + (code4 === codes.asterisk || code4 === codes.slash ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function tagEnd(code4) {
    ok(code4 === codes.greaterThan, "expected `>`");
    effects.enter(tagMarkerType);
    effects.consume(code4);
    effects.exit(tagMarkerType);
    effects.exit(tagType);
    return ok3;
  }
  function esWhitespaceStart(code4) {
    if (markdownLineEnding(code4)) {
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      return esWhitespaceEolAfter;
    }
    if (markdownSpace(code4) || unicodeWhitespace(code4)) {
      effects.enter("esWhitespace");
      return esWhitespaceInside(code4);
    }
    return returnState(code4);
  }
  function esWhitespaceInside(code4) {
    if (markdownLineEnding(code4)) {
      effects.exit("esWhitespace");
      return esWhitespaceStart(code4);
    }
    if (markdownSpace(code4) || unicodeWhitespace(code4)) {
      effects.consume(code4);
      return esWhitespaceInside;
    }
    effects.exit("esWhitespace");
    return returnState(code4);
  }
  function esWhitespaceEolAfter(code4) {
    if (!allowLazy && self2.parser.lazy[self2.now().line]) {
      const error3 = new VFileMessage(
        "Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        self2.now(),
        "micromark-extension-mdx-jsx:unexpected-lazy"
      );
      error3.url = trouble2 + "#unexpected-lazy-line-in-container-expected-line-to-be";
      throw error3;
    }
    return esWhitespaceStart(code4);
  }
  function crash(code4, at2, expect) {
    const error3 = new VFileMessage(
      "Unexpected " + (code4 === codes.eof ? "end of file" : "character `" + (code4 === codes.graveAccent ? "` ` `" : String.fromCodePoint(code4)) + "` (" + serializeCharCode(code4) + ")") + " " + at2 + ", expected " + expect,
      self2.now(),
      "micromark-extension-mdx-jsx:unexpected-" + (code4 === codes.eof ? "eof" : "character")
    );
    error3.url = trouble2 + (code4 === codes.eof ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect");
    throw error3;
  }
}
function serializeCharCode(code4) {
  return "U+" + code4.toString(constants.numericBaseHexadecimal).toUpperCase().padStart(4, "0");
}

// node_modules/micromark-extension-mdx-jsx/dev/lib/jsx-text.js
function jsxText(acorn, options) {
  return { name: "mdxJsxTextTag", tokenize: tokenizeJsxText };
  function tokenizeJsxText(effects, ok3, nok) {
    return factoryTag.call(
      this,
      effects,
      ok3,
      nok,
      acorn,
      options.acornOptions,
      options.addResult,
      true,
      "mdxJsxTextTag",
      "mdxJsxTextTagMarker",
      "mdxJsxTextTagClosingMarker",
      "mdxJsxTextTagSelfClosingMarker",
      "mdxJsxTextTagName",
      "mdxJsxTextTagNamePrimary",
      "mdxJsxTextTagNameMemberMarker",
      "mdxJsxTextTagNameMember",
      "mdxJsxTextTagNamePrefixMarker",
      "mdxJsxTextTagNameLocal",
      "mdxJsxTextTagExpressionAttribute",
      "mdxJsxTextTagExpressionAttributeMarker",
      "mdxJsxTextTagExpressionAttributeValue",
      "mdxJsxTextTagAttribute",
      "mdxJsxTextTagAttributeName",
      "mdxJsxTextTagAttributeNamePrimary",
      "mdxJsxTextTagAttributeNamePrefixMarker",
      "mdxJsxTextTagAttributeNameLocal",
      "mdxJsxTextTagAttributeInitializerMarker",
      "mdxJsxTextTagAttributeValueLiteral",
      "mdxJsxTextTagAttributeValueLiteralMarker",
      "mdxJsxTextTagAttributeValueLiteralValue",
      "mdxJsxTextTagAttributeValueExpression",
      "mdxJsxTextTagAttributeValueExpressionMarker",
      "mdxJsxTextTagAttributeValueExpressionValue"
    );
  }
}

// node_modules/micromark-extension-mdx-jsx/dev/lib/jsx-flow.js
function jsxFlow(acorn, options) {
  return { name: "mdxJsxFlowTag", tokenize: tokenizeJsxFlow, concrete: true };
  function tokenizeJsxFlow(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code4) {
      ok(code4 === codes.lessThan, "expected `<`");
      return before(code4);
    }
    function before(code4) {
      return factoryTag.call(
        self2,
        effects,
        after,
        nok,
        acorn,
        options.acornOptions,
        options.addResult,
        false,
        "mdxJsxFlowTag",
        "mdxJsxFlowTagMarker",
        "mdxJsxFlowTagClosingMarker",
        "mdxJsxFlowTagSelfClosingMarker",
        "mdxJsxFlowTagName",
        "mdxJsxFlowTagNamePrimary",
        "mdxJsxFlowTagNameMemberMarker",
        "mdxJsxFlowTagNameMember",
        "mdxJsxFlowTagNamePrefixMarker",
        "mdxJsxFlowTagNameLocal",
        "mdxJsxFlowTagExpressionAttribute",
        "mdxJsxFlowTagExpressionAttributeMarker",
        "mdxJsxFlowTagExpressionAttributeValue",
        "mdxJsxFlowTagAttribute",
        "mdxJsxFlowTagAttributeName",
        "mdxJsxFlowTagAttributeNamePrimary",
        "mdxJsxFlowTagAttributeNamePrefixMarker",
        "mdxJsxFlowTagAttributeNameLocal",
        "mdxJsxFlowTagAttributeInitializerMarker",
        "mdxJsxFlowTagAttributeValueLiteral",
        "mdxJsxFlowTagAttributeValueLiteralMarker",
        "mdxJsxFlowTagAttributeValueLiteralValue",
        "mdxJsxFlowTagAttributeValueExpression",
        "mdxJsxFlowTagAttributeValueExpressionMarker",
        "mdxJsxFlowTagAttributeValueExpressionValue"
      )(code4);
    }
    function after(code4) {
      return markdownSpace(code4) ? factorySpace(effects, end, types2.whitespace)(code4) : end(code4);
    }
    function end(code4) {
      const leftBraceValue = self2.parser.constructs.flow[codes.leftCurlyBrace];
      const constructs2 = Array.isArray(leftBraceValue) ? leftBraceValue : leftBraceValue ? [leftBraceValue] : [];
      const expression = constructs2.find((d) => d.name === "mdxFlowExpression");
      return code4 === codes.lessThan ? (
        // We can’t just say: fine. Lines of blocks have to be parsed until an eol/eof.
        start2(code4)
      ) : code4 === codes.leftCurlyBrace && expression ? effects.attempt(expression, end, nok)(code4) : code4 === codes.eof || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
    }
  }
}

// node_modules/micromark-extension-mdx-jsx/dev/lib/syntax.js
function mdxJsx(options) {
  const settings = options || {};
  const acorn = settings.acorn;
  let acornOptions;
  if (acorn) {
    if (!acorn.parse || !acorn.parseExpressionAt) {
      throw new Error(
        "Expected a proper `acorn` instance passed in as `options.acorn`"
      );
    }
    acornOptions = Object.assign(
      { ecmaVersion: 2024, sourceType: "module" },
      settings.acornOptions,
      { locations: true }
    );
  } else if (settings.acornOptions || settings.addResult) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  return {
    flow: {
      [codes.lessThan]: jsxFlow(acorn || void 0, {
        acornOptions,
        addResult: settings.addResult || void 0
      })
    },
    text: {
      [codes.lessThan]: jsxText(acorn || void 0, {
        acornOptions,
        addResult: settings.addResult || void 0
      })
    }
  };
}

// node_modules/micromark-extension-mdx-md/index.js
function mdxMd() {
  return {
    disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
  };
}

// node_modules/micromark-extension-mdxjs-esm/dev/lib/syntax.js
var blankLineBefore2 = { tokenize: tokenizeNextBlank, partial: true };
var trouble3 = "https://github.com/micromark/micromark-extension-mdxjs-esm";
var allowedAcornTypes = /* @__PURE__ */ new Set([
  "ExportAllDeclaration",
  "ExportDefaultDeclaration",
  "ExportNamedDeclaration",
  "ImportDeclaration"
]);
function mdxjsEsm(options) {
  const exportImportConstruct = { tokenize: tokenizeExportImport, concrete: true };
  if (!options || !options.acorn || !options.acorn.parse) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  const acorn = options.acorn;
  const acornOptions = Object.assign(
    { ecmaVersion: 2024, sourceType: "module" },
    options.acornOptions,
    { locations: true }
  );
  return {
    flow: {
      [codes.lowercaseE]: exportImportConstruct,
      [codes.lowercaseI]: exportImportConstruct
    }
  };
  function tokenizeExportImport(effects, ok3, nok) {
    const self2 = this;
    const definedModuleSpecifiers = self2.parser.definedModuleSpecifiers || (self2.parser.definedModuleSpecifiers = []);
    const eventStart = this.events.length + 1;
    let buffer = "";
    return self2.interrupt ? nok : start2;
    function start2(code4) {
      ok(
        code4 === codes.lowercaseE || code4 === codes.lowercaseI,
        "expected `e` or `i`"
      );
      if (self2.now().column > 1) return nok(code4);
      effects.enter("mdxjsEsm");
      effects.enter("mdxjsEsmData");
      effects.consume(code4);
      buffer += String.fromCharCode(code4);
      return word;
    }
    function word(code4) {
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        buffer += String.fromCharCode(code4);
        return word;
      }
      if ((buffer === "import" || buffer === "export") && code4 === codes.space) {
        effects.consume(code4);
        return inside;
      }
      return nok(code4);
    }
    function inside(code4) {
      if (code4 === codes.eof || markdownLineEnding(code4)) {
        effects.exit("mdxjsEsmData");
        return lineStart(code4);
      }
      effects.consume(code4);
      return inside;
    }
    function lineStart(code4) {
      if (code4 === codes.eof) {
        return atEnd(code4);
      }
      if (markdownLineEnding(code4)) {
        return effects.check(blankLineBefore2, atEnd, continuationStart)(code4);
      }
      effects.enter("mdxjsEsmData");
      return inside(code4);
    }
    function continuationStart(code4) {
      ok(markdownLineEnding(code4));
      effects.enter(types2.lineEnding);
      effects.consume(code4);
      effects.exit(types2.lineEnding);
      return lineStart;
    }
    function atEnd(code4) {
      const result = eventsToAcorn(self2.events.slice(eventStart), {
        acorn,
        acornOptions,
        tokenTypes: ["mdxjsEsmData"],
        prefix: definedModuleSpecifiers.length > 0 ? "var " + definedModuleSpecifiers.join(",") + "\n" : ""
      });
      if (result.error) {
        if (code4 !== codes.eof && result.swallow) {
          return continuationStart(code4);
        }
        const error3 = new VFileMessage(
          "Could not parse import/exports with acorn",
          {
            cause: result.error,
            place: {
              line: result.error.loc.line,
              column: result.error.loc.column + 1,
              offset: result.error.pos
            },
            ruleId: "acorn",
            source: "micromark-extension-mdxjs-esm"
          }
        );
        error3.url = trouble3 + "#could-not-parse-importexports-with-acorn";
        throw error3;
      }
      ok(result.estree, "expected `estree` to be defined");
      if (definedModuleSpecifiers.length > 0) {
        const declaration = result.estree.body.shift();
        ok(declaration);
        ok(declaration.type === "VariableDeclaration");
      }
      let index4 = -1;
      while (++index4 < result.estree.body.length) {
        const node3 = result.estree.body[index4];
        if (!allowedAcornTypes.has(node3.type)) {
          const error3 = new VFileMessage(
            "Unexpected `" + node3.type + "` in code: only import/exports are supported",
            {
              place: positionFromEstree(node3),
              ruleId: "non-esm",
              source: "micromark-extension-mdxjs-esm"
            }
          );
          error3.url = trouble3 + "#unexpected-type-in-code-only-importexports-are-supported";
          throw error3;
        }
        if (node3.type === "ImportDeclaration" && !self2.interrupt) {
          let index5 = -1;
          while (++index5 < node3.specifiers.length) {
            const specifier = node3.specifiers[index5];
            definedModuleSpecifiers.push(specifier.local.name);
          }
        }
      }
      Object.assign(
        effects.exit("mdxjsEsm"),
        options.addResult ? { estree: result.estree } : void 0
      );
      return ok3(code4);
    }
  }
}
function tokenizeNextBlank(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    ok(markdownLineEnding(code4));
    effects.enter(types2.lineEndingBlank);
    effects.consume(code4);
    effects.exit(types2.lineEndingBlank);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-extension-mdxjs/index.js
function mdxjs(options) {
  const settings = Object.assign(
    {
      acorn: Parser.extend((0, import_acorn_jsx.default)()),
      acornOptions: { ecmaVersion: 2024, sourceType: "module" },
      addResult: true
    },
    options
  );
  return combineExtensions([
    mdxjsEsm(settings),
    mdxExpression(settings),
    mdxJsx(settings),
    mdxMd()
  ]);
}

// node_modules/@keystatic/core/dist/index-cb6d8e27.js
var import_react55 = __toESM(require_react(), 1);
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_is_hotkey = __toESM(require_lib(), 1);
var import_sanitize_url = __toESM(require_dist(), 1);
var import_slugify = __toESM(require_slugify(), 1);
var import_react_dom6 = __toESM(require_react_dom(), 1);
var import_escape_string_regexp2 = __toESM(require_escape_string_regexp3(), 1);
var l10nMessages = {
  "ar-AE": {
    add: "يضيف",
    branchName: "اسم الفرع",
    basedOn: "مرتكز على",
    branches: "الفروع",
    cancel: "يلغي",
    clear: "مسح",
    collection: "مجموعة",
    collections: "المجموعات",
    create: "يخلق",
    createPullRequest: "إنشاء طلب سحب",
    currentBranch: "الفرع الحالي",
    dashboard: "لوحة القيادة",
    defaultBranch: "الفرع الافتراضي",
    "delete": "يمسح",
    deleteBranch: "حذف الفرع",
    edit: "يحرر",
    loading: "جارٍ التحميل",
    newBranch: "فرع جديد",
    otherBranches: "الفروع الأخرى",
    pullRequests: "طلبات السحب",
    search: "بحث",
    save: "يحفظ",
    singleton: "سينجلتون",
    singletons: "الفردي",
    theCurrentlyCheckedOutBranch: "الفرع المعاد حاليا. اختر هذا إذا كنت بحاجة إلى البناء على العمل الحالي من الفرع الحالي.",
    theDefaultBranchInYourRepository: "الفرع الافتراضي في المستودع الخاص بك. اختر هذا لبدء شيء جديد لا يعتمد على فرعك الحالي.",
    viewPullRequests: "عرض طلبات السحب"
  },
  "da-DK": {
    add: "Tilføje",
    basedOn: "Baseret på",
    branchName: "Afdelingsnavn",
    branches: "Grene",
    cancel: "Afbestille",
    clear: "Ryd",
    collection: "Kollektion",
    collections: "Samlinger",
    create: "skab",
    createPullRequest: "Opret pull-anmodning",
    currentBranch: "Nuværende filial",
    dashboard: "Dashboard",
    "delete": "Slet",
    defaultBranch: "Standard gren",
    deleteBranch: "Slet filial",
    edit: "Redigere",
    loading: "Indlæser",
    newBranch: "Ny filial",
    otherBranches: "Andre grene",
    pullRequests: "Træk anmodninger",
    save: "Gemme",
    search: "Søg",
    singleton: "Singleton",
    singletons: "Singletoner",
    theDefaultBranchInYourRepository: "Standardgrenen i dit lager. Vælg dette for at starte på noget nyt, der ikke er afhængigt af din nuværende filial.",
    viewPullRequests: "Se pull-anmodninger",
    theCurrentlyCheckedOutBranch: "Den aktuelt tjekkede filial. Vælg dette, hvis du skal bygge videre på eksisterende arbejde fra den nuværende filial."
  },
  "cs-CZ": {
    add: "Přidat",
    basedOn: "Na základě",
    branchName: "Jméno pobočky",
    branches: "Větve",
    clear: "Vymazat",
    cancel: "zrušení",
    collection: "Sbírka",
    create: "Vytvořit",
    collections: "Sbírky",
    createPullRequest: "Vytvořit požadavek na stažení",
    currentBranch: "Současná pobočka",
    dashboard: "Přístrojová deska",
    "delete": "Vymazat",
    defaultBranch: "Výchozí větev",
    deleteBranch: "Smazat větev",
    edit: "Upravit",
    loading: "Načítání",
    newBranch: "Nová pobočka",
    otherBranches: "Ostatní pobočky",
    pullRequests: "Vytáhněte požadavky",
    save: "Uložit",
    singleton: "Jedináček",
    search: "Hledat",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Aktuálně odhlášená pobočka. Tuto možnost vyberte, pokud potřebujete navázat na stávající práci z aktuální pobočky.",
    theDefaultBranchInYourRepository: "Výchozí větev ve vašem úložišti. Zvolte tuto možnost, chcete-li začít s něčím novým, co není závislé na vaší aktuální větvi.",
    viewPullRequests: "Zobrazit žádosti o stažení"
  },
  "de-DE": {
    basedOn: "Bezogen auf",
    add: "Hinzufügen",
    branches: "Geäst",
    branchName: "Zweigname",
    cancel: "Stornieren",
    clear: "Löschen",
    collection: "Sammlung",
    collections: "Sammlungen",
    create: "Erstellen",
    createPullRequest: "Pull-Request erstellen",
    currentBranch: "Aktueller Zweig",
    dashboard: "Armaturenbrett",
    defaultBranch: "Standardzweig",
    "delete": "Löschen",
    deleteBranch: "Zweig löschen",
    edit: "Bearbeiten",
    newBranch: "Neue Zweig",
    loading: "Wird geladen",
    otherBranches: "Andere Filialen",
    save: "Speichern",
    singletons: "Singles",
    singleton: "Einzelling",
    theCurrentlyCheckedOutBranch: "Der aktuell ausgecheckte Zweig. Wählen Sie diese Option, wenn Sie auf vorhandener Arbeit aus dem aktuellen Zweig aufbauen müssen.",
    theDefaultBranchInYourRepository: "Der Standard-Branch in Ihrem Repository. Wählen Sie dies, um etwas Neues zu starten, das nicht von Ihrem aktuellen Zweig abhängt.",
    search: "Suchen",
    viewPullRequests: "Pull-Requests anzeigen",
    pullRequests: "Pull-Requests"
  },
  "el-GR": {
    add: "Προσθήκη",
    basedOn: "Βασισμένο στο",
    branchName: "Όνομα υποκαταστήματος",
    cancel: "Ματαίωση",
    branches: "Κλαδια δεντρου",
    clear: "Καθαρισμός",
    collections: "Συλλογές",
    collection: "Συλλογή",
    create: "Δημιουργώ",
    currentBranch: "Τρέχον υποκατάστημα",
    createPullRequest: "Δημιουργία αιτήματος έλξης",
    defaultBranch: "Προεπιλεγμένος κλάδος",
    dashboard: "Ταμπλό",
    "delete": "Διαγράφω",
    deleteBranch: "Διαγραφή υποκαταστήματος",
    edit: "Επεξεργασία",
    loading: "Φόρτωση",
    newBranch: "Νέο υποκατάστημα",
    pullRequests: "Τραβήξτε αιτήματα",
    otherBranches: "Άλλα υποκαταστήματα",
    save: "Αποθηκεύσετε",
    singleton: "Μοναδικό χαρτί",
    search: "Αναζήτηση",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Το υποκατάστημα που ελέγχεται αυτήν τη στιγμή. Επιλέξτε αυτό εάν χρειάζεται να βασιστείτε σε υπάρχουσες εργασίες από τον τρέχοντα κλάδο.",
    theDefaultBranchInYourRepository: "Ο προεπιλεγμένος κλάδος στο αποθετήριο σας. Επιλέξτε αυτό για να ξεκινήσετε κάτι νέο που δεν εξαρτάται από το τρέχον υποκατάστημά σας.",
    viewPullRequests: "Προβολή αιτημάτων έλξης"
  },
  "es-ES": {
    basedOn: "Residencia en",
    add: "Agregar",
    branches: "Sucursales",
    branchName: "Nombre de la sucursal",
    clear: "Borrar",
    collection: "Colección",
    collections: "Colecciones",
    cancel: "Cancelar",
    create: "Crear",
    createPullRequest: "Crear solicitud de extracción",
    dashboard: "Panel",
    currentBranch: "Rama actual",
    defaultBranch: "Rama predeterminada",
    deleteBranch: "Eliminar rama",
    "delete": "Borrar",
    edit: "Editar",
    loading: "Cargando",
    newBranch: "Nueva sucursal",
    otherBranches: "Otras sucursales",
    pullRequests: "Solicitudes de extracción",
    save: "Ahorrar",
    singleton: "Semifallo",
    singletons: "Solteros",
    theCurrentlyCheckedOutBranch: "La sucursal actualmente desprotegida. Elija esto si necesita desarrollar el trabajo existente de la rama actual.",
    search: "Buscar",
    viewPullRequests: "Ver solicitudes de extracción",
    theDefaultBranchInYourRepository: "La rama predeterminada en su repositorio. Elija esto para comenzar algo nuevo que no dependa de su sucursal actual."
  },
  "et-EE": {
    basedOn: "Põhineb",
    add: "Lisama",
    branchName: "Filiaali nimi",
    cancel: "Tühista",
    clear: "Puhasta",
    collection: "Kollektsioon",
    branches: "Filiaalid",
    collections: "Kollektsioonid",
    create: "Loo",
    createPullRequest: "Loo tõmbamistaotlus",
    currentBranch: "Praegune filiaal",
    dashboard: "Armatuurlaud",
    defaultBranch: "Vaikeharu",
    loading: "Laadimine",
    "delete": "Kustuta",
    edit: "Muuda",
    deleteBranch: "Kustuta haru",
    newBranch: "Uus filiaal",
    otherBranches: "Muud oksad",
    pullRequests: "Tõmbetaotlused",
    search: "Otsi",
    singleton: "üksikud",
    singletons: "Üksikud",
    save: "Salvesta",
    theCurrentlyCheckedOutBranch: "Praegu välja registreeritud filiaal. Valige see, kui peate kasutama praeguse haru olemasolevaid töid.",
    theDefaultBranchInYourRepository: "Vaikeharu teie hoidlas. Valige see, et alustada midagi uut, mis ei sõltu teie praegusest harust.",
    viewPullRequests: "Vaadake tõmbamistaotlusi"
  },
  "en-US": {
    branchName: "Branch name",
    add: "Add",
    cancel: "Cancel",
    branches: "Branches",
    clear: "Clear",
    collection: "Collection",
    create: "Create",
    collections: "Collections",
    createPullRequest: "Create pull request",
    currentBranch: "Current branch",
    dashboard: "Dashboard",
    defaultBranch: "Default branch",
    "delete": "Delete",
    deleteBranch: "Delete branch",
    edit: "Edit",
    loading: "Loading",
    otherBranches: "Other branches",
    pullRequests: "Pull requests",
    newBranch: "New branch…",
    save: "Save",
    search: "Search",
    singleton: "Singleton",
    singletons: "Singletons",
    theDefaultBranchInYourRepository: "The default branch in your repository. Choose this to start something new that's not dependent on your current branch.",
    theCurrentlyCheckedOutBranch: "The currently checked out branch. Choose this if you need to build on existing work from the current branch.",
    viewPullRequests: "View pull requests",
    basedOn: "Based on"
  },
  "fi-FI": {
    add: "Lisätä",
    basedOn: "Perustuen",
    branches: "Oksat",
    collection: "Kokoelma",
    branchName: "Sivukonttorin nimi",
    clear: "Kirkas",
    cancel: "Tühista",
    collections: "Kokoelmat",
    createPullRequest: "Luo vetopyyntö",
    currentBranch: "Nykyinen haara",
    create: "Luoda",
    dashboard: "Kojelauta",
    defaultBranch: "Oletushaara",
    "delete": "Poistaa",
    edit: "Muokata",
    deleteBranch: "Poista haara",
    newBranch: "Uusi haara",
    otherBranches: "Muut haarat",
    loading: "Ladataan",
    pullRequests: "Vedä pyyntöjä",
    save: "Tallentaa",
    search: "Hae",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Tällä hetkellä uloskirjautunut sivuliike. Valitse tämä, jos haluat rakentaa nykyisen haaran olemassa olevaan työhön.",
    theDefaultBranchInYourRepository: "Oletushaara arkistossasi. Valitse tämä aloittaaksesi jotain uutta, joka ei ole riippuvainen nykyisestä haarastasi.",
    viewPullRequests: "Näytä vetopyynnöt"
  },
  "fr-FR": {
    add: "Ajouter",
    branchName: "Nom de la filiale",
    basedOn: "Basé sur",
    cancel: "Annuler",
    branches: "Branches",
    clear: "Effacer",
    create: "Créer",
    collections: "Collections",
    collection: "Collection",
    createPullRequest: "Créer une demande d'extraction",
    currentBranch: "Succursale actuelle",
    defaultBranch: "Branche par défaut",
    dashboard: "Tableau de bord",
    deleteBranch: "Supprimer la branche",
    edit: "Modifier",
    "delete": "Supprimer",
    loading: "Chargement en cours",
    otherBranches: "Autres succursales",
    newBranch: "Nouvelle branche",
    pullRequests: "Demandes d'extraction",
    save: "Sauvegarder",
    search: "Rechercher",
    singleton: "Singleton",
    theCurrentlyCheckedOutBranch: "La branche actuellement extraite. Choisissez cette option si vous devez vous appuyer sur le travail existant de la branche actuelle.",
    singletons: "Célibataires",
    viewPullRequests: "Afficher les demandes d'extraction",
    theDefaultBranchInYourRepository: "La branche par défaut de votre référentiel. Choisissez ceci pour commencer quelque chose de nouveau qui ne dépend pas de votre branche actuelle."
  },
  "he-IL": {
    add: "לְהוֹסִיף",
    basedOn: "מבוסס על",
    branches: "ענפים",
    branchName: "שם הסניף",
    cancel: "לְבַטֵל",
    clear: "נקי",
    collection: "אוסף",
    collections: "אוספים",
    createPullRequest: "צור בקשת משיכה",
    dashboard: "לוּחַ מַחווָנִים",
    create: "לִיצוֹר",
    "delete": "לִמְחוֹק",
    currentBranch: "סניף נוכחי",
    defaultBranch: "סניף ברירת מחדל",
    deleteBranch: "מחק סניף",
    edit: "לַעֲרוֹך",
    loading: "טוען",
    otherBranches: "סניפים אחרים",
    newBranch: "סניף חדש",
    pullRequests: "משוך בקשות",
    save: "להציל",
    search: "חפש",
    singleton: "קְלָף בּוֹדֵד",
    singletons: "רווקים",
    theCurrentlyCheckedOutBranch: "הסניף שנקבע כעת. בחר באפשרות זו אם אתה צריך לבנות על עבודה קיימת מהסניף הנוכחי.",
    theDefaultBranchInYourRepository: "סניף ברירת המחדל במאגר שלך. בחר באפשרות זו כדי להתחיל משהו חדש שאינו תלוי בסניף הנוכחי שלך.",
    viewPullRequests: "הצג בקשות משיכה"
  },
  "hr-HR": {
    add: "Dodati",
    branchName: "Naziv podružnice",
    basedOn: "Na temelju",
    branches: "Podružnice",
    clear: "Izbriši",
    cancel: "Otkazati",
    collection: "Kolekcija",
    collections: "Zbirke",
    create: "Stvoriti",
    createPullRequest: "Kreirajte zahtjev za povlačenjem",
    currentBranch: "Trenutna grana",
    defaultBranch: "Zadana grana",
    deleteBranch: "Izbriši granu",
    dashboard: "Nadzorna ploča",
    loading: "Učitavam",
    edit: "Uredi",
    "delete": "Izbrisati",
    otherBranches: "Ostale grane",
    newBranch: "Nova grana",
    pullRequests: "Zahtjevi za povlačenjem",
    save: "Uštedjeti",
    search: "Traži",
    singletons: "Samci",
    singleton: "samac",
    theCurrentlyCheckedOutBranch: "Trenutno odjavljena poslovnica. Odaberite ovo ako trebate graditi na postojećem radu iz trenutne grane.",
    theDefaultBranchInYourRepository: "Zadana grana u vašem spremištu. Odaberite ovo da započnete nešto novo što ne ovisi o vašoj trenutnoj grani.",
    viewPullRequests: "Pregledajte zahtjeve za povlačenjem"
  },
  "hu-HU": {
    basedOn: "Alapján",
    branchName: "Fiók neve",
    branches: "Ágak",
    add: "Hozzáadás",
    clear: "Törlés",
    cancel: "Megszünteti",
    collection: "Gyűjtemény",
    collections: "Gyűjtemények",
    createPullRequest: "Lehívási kérelem létrehozása",
    create: "Teremt",
    currentBranch: "Jelenlegi ág",
    dashboard: "Irányítópult",
    "delete": "Töröl",
    defaultBranch: "Alapértelmezett ág",
    edit: "Szerkesztés",
    deleteBranch: "Elágazás törlése",
    loading: "Betöltés folyamatban",
    newBranch: "Új ág",
    pullRequests: "Lehívási kérések",
    otherBranches: "Egyéb ágak",
    save: "Megment",
    search: "Keresés",
    singleton: "szingli",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "A jelenleg kivett fiók. Válassza ezt, ha az aktuális ág meglévő munkájára kell építenie.",
    theDefaultBranchInYourRepository: "Az alapértelmezett ág az adattárban. Válassza ezt, ha valami újat szeretne indítani, amely nem függ az aktuális ágtól.",
    viewPullRequests: "Lehívási kérelmek megtekintése"
  },
  "it-IT": {
    add: "Aggiungere",
    basedOn: "Basato su",
    branchName: "Nome ramo",
    branches: "Rami",
    cancel: "Annulla",
    clear: "Cancella",
    collection: "Collezione",
    create: "Creare",
    collections: "Collezioni",
    dashboard: "Pannello di controllo",
    createPullRequest: "Crea richiesta pull",
    defaultBranch: "Ramo predefinito",
    "delete": "Eliminare",
    currentBranch: "Ramo attuale",
    edit: "Modificare",
    deleteBranch: "Elimina ramo",
    loading: "Caricamento in corso",
    newBranch: "Nuova filiale",
    otherBranches: "Altri rami",
    pullRequests: "Richieste pull",
    save: "Salva",
    search: "Cerca",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "La filiale attualmente verificata. Scegli questa opzione se devi basarti su un lavoro esistente dal ramo corrente.",
    singleton: "Singleton",
    theDefaultBranchInYourRepository: "Il ramo predefinito nel tuo repository. Scegli questa opzione per iniziare qualcosa di nuovo che non dipenda dal tuo ramo attuale.",
    viewPullRequests: "Visualizza le richieste pull"
  },
  "bg-BG": {
    add: "Добавете",
    branchName: "Име на клон",
    basedOn: "Базиран на",
    branches: "Клонове",
    cancel: "Отказ",
    collections: "Колекции",
    clear: "Изчисти",
    createPullRequest: "Създайте заявка за изтегляне",
    collection: "колекция",
    create: "Създавайте",
    currentBranch: "Текущ клон",
    dashboard: "Табло",
    defaultBranch: "Клон по подразбиране",
    "delete": "Изтрий",
    deleteBranch: "Изтриване на клон",
    edit: "редактиране",
    loading: "Зареждане",
    newBranch: "Нов клон",
    pullRequests: "Заявки за изтегляне",
    otherBranches: "Други клонове",
    search: "Търсене",
    save: "Запазване",
    singleton: "Сингълтън",
    singletons: "Единични",
    theDefaultBranchInYourRepository: "Клонът по подразбиране във вашето хранилище. Изберете това, за да започнете с нещо ново, което не зависи от текущия ви клон.",
    theCurrentlyCheckedOutBranch: "Текущо провереният клон. Изберете това, ако трябва да надграждате върху съществуваща работа от текущия клон.",
    viewPullRequests: "Преглед на заявките за изтегляне"
  },
  "ja-JP": {
    add: "追加",
    basedOn: "に基づく",
    branchName: "支店名",
    branches: "支店",
    collection: "コレクション",
    cancel: "キャンセル",
    collections: "コレクション",
    clear: "クリア",
    create: "作成",
    currentBranch: "現在のブランチ",
    defaultBranch: "デフォルトのブランチ",
    createPullRequest: "プルリクエストを作成",
    dashboard: "ダッシュボード",
    "delete": "消去",
    deleteBranch: "ブランチを削除",
    loading: "読み込み中",
    edit: "編集",
    otherBranches: "その他の支店",
    newBranch: "新しい支店",
    pullRequests: "プルリクエスト",
    save: "保存",
    search: "検索",
    singleton: "シングルトン",
    singletons: "シングルトン",
    theCurrentlyCheckedOutBranch: "現在チェックアウトされているブランチ。 現在のブランチの既存の作業に基づいて構築する必要がある場合は、これを選択してください。",
    viewPullRequests: "プル リクエストを表示",
    theDefaultBranchInYourRepository: "リポジトリのデフォルト ブランチ。 これを選択して、現在のブランチに依存しない新しい何かを開始します。"
  },
  "ko-KR": {
    add: "추가하다",
    basedOn: "기반으로",
    branches: "가지",
    branchName: "지점명",
    cancel: "취소",
    collection: "수집",
    clear: "지우기",
    collections: "컬렉션",
    create: "만들다",
    createPullRequest: "풀 요청 생성",
    currentBranch: "현재 지점",
    dashboard: "계기반",
    "delete": "삭제",
    defaultBranch: "기본 분기",
    deleteBranch: "분기 삭제",
    newBranch: "새 지점",
    edit: "편집하다",
    otherBranches: "기타 지점",
    pullRequests: "풀 리퀘스트",
    loading: "로드 중",
    save: "구하다",
    singleton: "하나씩 일어나는 것",
    search: "검색",
    singletons: "싱글톤",
    theCurrentlyCheckedOutBranch: "현재 체크아웃된 브랜치. 현재 브랜치의 기존 작업을 기반으로 빌드해야 하는 경우 이 옵션을 선택하세요.",
    viewPullRequests: "풀 요청 보기",
    theDefaultBranchInYourRepository: "리포지토리의 기본 브랜치입니다. 현재 분기에 의존하지 않는 새로운 것을 시작하려면 이것을 선택하십시오."
  },
  "lt-LT": {
    add: "Papildyti",
    branchName: "Filialo pavadinimas",
    basedOn: "Remiantis",
    cancel: "Atšaukti",
    branches: "Filialai",
    collection: "Kolekcija",
    clear: "Skaidrus",
    createPullRequest: "Sukurti ištraukimo užklausą",
    collections: "Kolekcijos",
    create: "Sukurti",
    currentBranch: "Dabartinis filialas",
    dashboard: "Prietaisų skydelis",
    defaultBranch: "Numatytoji šaka",
    "delete": "Ištrinti",
    deleteBranch: "Ištrinti šaką",
    edit: "Redaguoti",
    loading: "Įkeliama",
    newBranch: "Naujas filialas",
    otherBranches: "Kitos šakos",
    pullRequests: "Ištraukti užklausas",
    save: "Sutaupyti",
    singleton: "vienvietis",
    search: "Ieškoti",
    singletons: "Vienišiai",
    theCurrentlyCheckedOutBranch: "Šiuo metu išregistruotas filialas. Pasirinkite tai, jei reikia remtis esamu darbu iš dabartinės šakos.",
    viewPullRequests: "Peržiūrėkite ištraukimo užklausas",
    theDefaultBranchInYourRepository: "Numatytoji šaka jūsų saugykloje. Pasirinkite tai, kad pradėtumėte ką nors naujo, nepriklausančio nuo dabartinės šakos."
  },
  "lv-LV": {
    branchName: "Filiāles nosaukums",
    basedOn: "Balstoties uz",
    cancel: "Atcelt",
    branches: "Nozares",
    add: "Pievienot",
    collection: "Kolekcija",
    clear: "Notīrīt",
    collections: "Kolekcijas",
    create: "Izveidot",
    currentBranch: "Pašreizējā filiāle",
    createPullRequest: "Izveidot izvilkšanas pieprasījumu",
    dashboard: "Mērinstrumentu panelis",
    "delete": "Dzēst",
    defaultBranch: "Noklusējuma filiāle",
    deleteBranch: "Dzēst filiāli",
    edit: "Rediģēt",
    loading: "Notiek ielāde",
    newBranch: "Jauna filiāle",
    otherBranches: "Citas filiāles",
    pullRequests: "Izvilkšanas pieprasījumi",
    save: "Saglabāt",
    search: "Meklēt",
    singleton: "Singleton",
    singletons: "Vientuļi",
    viewPullRequests: "Skatīt izvilkšanas pieprasījumus",
    theCurrentlyCheckedOutBranch: "Pašlaik izrakstītā filiāle. Izvēlieties šo, ja vēlaties izmantot esošo darbu no pašreizējās filiāles.",
    theDefaultBranchInYourRepository: "Noklusējuma filiāle jūsu repozitorijā. Izvēlieties šo, lai sāktu kaut ko jaunu, kas nav atkarīgs no jūsu pašreizējās filiāles."
  },
  "nb-NO": {
    add: "Legg til",
    basedOn: "Basert på",
    branchName: "Filialnavn",
    branches: "Grener",
    clear: "Tøm",
    cancel: "Avbryt",
    create: "Skape",
    collection: "Samling",
    collections: "Samlinger",
    createPullRequest: "Opprett pull-forespørsel",
    currentBranch: "Nåværende gren",
    dashboard: "Dashbord",
    "delete": "Slett",
    defaultBranch: "Standard gren",
    edit: "Redigere",
    deleteBranch: "Slett filial",
    loading: "Laster inn",
    newBranch: "Ny gren",
    otherBranches: "Andre grener",
    pullRequests: "Trekk forespørsler",
    save: "Lagre",
    search: "Søk",
    singleton: "Singleton",
    singletons: "Singletoner",
    theDefaultBranchInYourRepository: "Standardgrenen i depotet ditt. Velg dette for å starte noe nytt som ikke er avhengig av din nåværende filial.",
    theCurrentlyCheckedOutBranch: "Den utsjekkede grenen. Velg dette hvis du skal bygge på eksisterende arbeid fra gjeldende gren.",
    viewPullRequests: "Se pull-forespørsler"
  },
  "nl-NL": {
    add: "Toevoegen",
    branchName: "Filiaal naam",
    basedOn: "Gebaseerd op",
    cancel: "Annuleren",
    clear: "Helder",
    branches: "Takken",
    collection: "Verzameling",
    collections: "Collecties",
    create: "Creëren",
    currentBranch: "Huidige tak",
    createPullRequest: "Pull-aanvraag maken",
    dashboard: "Dashboard",
    defaultBranch: "Standaard filiaal",
    "delete": "Verwijderen",
    deleteBranch: "Filiaal verwijderen",
    edit: "Bewerking",
    loading: "Laden",
    newBranch: "Nieuwe tak",
    pullRequests: "Trek verzoeken",
    otherBranches: "Andere takken",
    search: "Zoeken",
    save: "Redden",
    singleton: "eenling",
    singletons: "Eenlingen",
    theCurrentlyCheckedOutBranch: "Het momenteel uitgecheckte filiaal. Kies dit als u moet voortbouwen op bestaand werk van de huidige branch.",
    theDefaultBranchInYourRepository: "De standaard branch in uw repository. Kies dit om iets nieuws te starten dat niet afhankelijk is van uw huidige branche.",
    viewPullRequests: "Bekijk pull-aanvragen"
  },
  "pl-PL": {
    add: "Dodać",
    basedOn: "Oparte na",
    branchName: "Nazwa filii",
    cancel: "Anulować",
    branches: "Gałęzie",
    clear: "Wyczyść",
    collection: "Kolekcja",
    collections: "Kolekcje",
    createPullRequest: "Utwórz żądanie ściągnięcia",
    create: "Tworzyć",
    currentBranch: "Obecny oddział",
    defaultBranch: "Oddział domyślny",
    "delete": "Usuwać",
    dashboard: "Panel",
    deleteBranch: "Usuń oddział",
    loading: "Trwa ładowanie",
    edit: "Edytować",
    newBranch: "Nowa gałąź",
    otherBranches: "Inne gałęzie",
    pullRequests: "Żądania ściągnięcia",
    save: "Ratować",
    search: "Szukaj",
    singletons: "Singletony",
    singleton: "singel",
    theCurrentlyCheckedOutBranch: "Aktualnie wyewidencjonowana gałąź. Wybierz tę opcję, jeśli chcesz oprzeć się na istniejącej pracy z bieżącej gałęzi.",
    viewPullRequests: "Wyświetl żądania ściągnięcia",
    theDefaultBranchInYourRepository: "Domyślna gałąź w twoim repozytorium. Wybierz tę opcję, aby rozpocząć coś nowego, co nie jest zależne od bieżącej gałęzi."
  },
  "pt-BR": {
    basedOn: "Baseado em",
    add: "Adicionar",
    branchName: "Nome da filial",
    branches: "Galhos",
    cancel: "Cancelar",
    clear: "Limpar",
    collection: "Coleção",
    collections: "Coleções",
    create: "Criar",
    createPullRequest: "Criar solicitação pull",
    dashboard: "Painel",
    currentBranch: "filial atual",
    defaultBranch: "ramo padrão",
    "delete": "Excluir",
    edit: "Editar",
    loading: "Carregando",
    deleteBranch: "Excluir ramificação",
    newBranch: "Nova filial",
    otherBranches: "Outros ramos",
    search: "Pesquisar",
    pullRequests: "Requisições pull",
    singleton: "solteiro",
    save: "Guardar",
    theCurrentlyCheckedOutBranch: "A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
    singletons: "Solteiros",
    viewPullRequests: "Ver solicitações pull",
    theDefaultBranchInYourRepository: "A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual."
  },
  "pt-PT": {
    add: "Adicionar",
    basedOn: "Baseado em",
    branchName: "Nome da filial",
    branches: "Galhos",
    collection: "Coleção",
    clear: "Limpar",
    cancel: "Cancelar",
    collections: "Coleções",
    create: "Criar",
    currentBranch: "filial atual",
    dashboard: "Painel",
    createPullRequest: "Criar solicitação pull",
    deleteBranch: "Excluir ramificação",
    "delete": "Excluir",
    defaultBranch: "ramo padrão",
    edit: "Editar",
    loading: "A carregar",
    newBranch: "Nova filial",
    otherBranches: "Outros ramos",
    pullRequests: "Requisições pull",
    save: "Guardar",
    search: "Procurar",
    singleton: "solteiro",
    theCurrentlyCheckedOutBranch: "A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
    singletons: "Solteiros",
    theDefaultBranchInYourRepository: "A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
    viewPullRequests: "Ver solicitações pull"
  },
  "ro-RO": {
    basedOn: "Bazat pe",
    add: "Adăuga",
    branchName: "Numele sucursalei",
    branches: "Ramuri",
    cancel: "Anulare",
    clear: "Golire",
    collection: "Colectie",
    collections: "Colecții",
    createPullRequest: "Creați cerere de tragere",
    create: "Crea",
    currentBranch: "Filiala actuală",
    dashboard: "Bord",
    defaultBranch: "Ramura implicită",
    "delete": "Șterge",
    edit: "Editați",
    deleteBranch: "Ștergeți ramura",
    newBranch: "Filiala noua",
    loading: "Se încarcă",
    otherBranches: "Alte ramuri",
    pullRequests: "Solicitări de tragere",
    save: "Salvați",
    search: "Căutare",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Sucursala verificată în prezent. Alegeți acest lucru dacă trebuie să vă bazați pe munca existentă din ramura curentă.",
    theDefaultBranchInYourRepository: "Ramura implicită din depozitul dvs. Alegeți acest lucru pentru a începe ceva nou, care nu depinde de ramura dvs. actuală.",
    viewPullRequests: "Vizualizați solicitările de extragere"
  },
  "sk-SK": {
    add: "Pridať",
    branchName: "Meno pobočky",
    basedOn: "Založené na",
    branches: "Pobočky",
    cancel: "Zrušiť",
    clear: "Vymazať",
    collections: "zbierky",
    create: "Vytvorte",
    collection: "Zbierka",
    createPullRequest: "Vytvorte požiadavku na stiahnutie",
    currentBranch: "Aktuálna pobočka",
    dashboard: "Dashboard",
    defaultBranch: "Predvolená vetva",
    deleteBranch: "Odstrániť vetvu",
    "delete": "Odstrániť",
    edit: "Upraviť",
    otherBranches: "Ostatné pobočky",
    loading: "Načítava sa",
    pullRequests: "Vytiahnite žiadosti",
    newBranch: "Nová pobočka",
    save: "Uložiť",
    singleton: "Singleton",
    singletons: "Singletons",
    search: "Vyhľadávať",
    theCurrentlyCheckedOutBranch: "Aktuálne odhlásená pobočka. Túto možnosť vyberte, ak potrebujete stavať na existujúcej práci z aktuálnej pobočky.",
    theDefaultBranchInYourRepository: "Predvolená vetva vo vašom úložisku. Zvoľte túto možnosť, ak chcete začať niečo nové, čo nezávisí od vašej aktuálnej pobočky.",
    viewPullRequests: "Zobraziť požiadavky na stiahnutie"
  },
  "ru-RU": {
    add: "Добавлять",
    basedOn: "На основе",
    branchName: "Название филиала",
    cancel: "Отмена",
    branches: "Ветви",
    clear: "Очистить",
    collection: "Коллекция",
    collections: "Коллекции",
    create: "Создавать",
    createPullRequest: "Создать запрос на включение",
    dashboard: "Панель приборов",
    currentBranch: "Текущая ветвь",
    defaultBranch: "Ветка по умолчанию",
    "delete": "Удалить",
    deleteBranch: "Удалить ветку",
    edit: "Редактировать",
    loading: "Загрузка",
    newBranch: "Новая ветка",
    pullRequests: "Пулл-реквесты",
    otherBranches: "Другие филиалы",
    search: "Поиск",
    save: "Сохранять",
    singletons: "Одиночки",
    singleton: "Синглтон",
    theCurrentlyCheckedOutBranch: "Текущая проверенная ветвь. Выберите это, если вам нужно опираться на существующую работу из текущей ветки.",
    viewPullRequests: "Посмотреть пул-реквесты",
    theDefaultBranchInYourRepository: "Ветка по умолчанию в вашем репозитории. Выберите это, чтобы начать что-то новое, не зависящее от вашей текущей ветки."
  },
  "sl-SI": {
    add: "Dodaj",
    branchName: "Ime podružnice",
    basedOn: "Temelji na",
    branches: "Podružnice",
    clear: "Jasen",
    cancel: "Prekliči",
    collection: "Zbirka",
    collections: "Zbirke",
    create: "Ustvari",
    currentBranch: "Trenutna veja",
    createPullRequest: "Ustvari zahtevo za vleko",
    dashboard: "Nadzorna plošča",
    defaultBranch: "Privzeta veja",
    "delete": "Izbriši",
    deleteBranch: "Izbriši vejo",
    edit: "Uredi",
    loading: "Nalaganje",
    newBranch: "Nova podružnica",
    otherBranches: "Druge veje",
    save: "Shrani",
    pullRequests: "Zahteve za vlečenje",
    singleton: "Singleton",
    search: "Iskanje",
    singletons: "Samski",
    theCurrentlyCheckedOutBranch: "Trenutno odjavljena podružnica. To izberite, če morate graditi na obstoječem delu iz trenutne veje.",
    theDefaultBranchInYourRepository: "Privzeta veja v vašem skladišču. Izberite to, da začnete nekaj novega, kar ni odvisno od vaše trenutne veje.",
    viewPullRequests: "Oglejte si zahteve za vlečenje"
  },
  "sr-SP": {
    basedOn: "На бази",
    add: "Додати",
    branches: "Огранци",
    branchName: "Назив огранка",
    cancel: "Поништити, отказати",
    collections: "Збирке",
    clear: "Izbriši",
    collection: "Цоллецтион",
    createPullRequest: "Креирајте захтев за повлачење",
    dashboard: "Командна табла",
    create: "Креирај",
    currentBranch: "Тренутна грана",
    defaultBranch: "Подразумевана грана",
    "delete": "Избриши",
    deleteBranch: "Обриши грану",
    edit: "Уредити",
    loading: "Učitavam",
    otherBranches: "Остале гране",
    newBranch: "Нова грана",
    pullRequests: "Захтеви за повлачење",
    save: "сачувати",
    singleton: "Синглетон",
    singletons: "Синглетонс",
    search: "Pretraga",
    theCurrentlyCheckedOutBranch: "Тренутно одјављена филијала. Изаберите ово ако треба да надоградите постојећи рад из тренутне гране.",
    theDefaultBranchInYourRepository: "Подразумевана грана у вашем спремишту. Изаберите ово да започнете нешто ново што не зависи од ваше тренутне гране.",
    viewPullRequests: "Прегледајте захтеве за повлачењем"
  },
  "sv-SE": {
    add: "Lägg till",
    basedOn: "Baserat på",
    branchName: "Filialens namn",
    cancel: "Поништити, отказати",
    clear: "Rensa",
    branches: "Grenar",
    collection: "Samling",
    create: "Skapa",
    createPullRequest: "Skapa pull-förfrågan",
    collections: "Samlingar",
    currentBranch: "Nuvarande gren",
    dashboard: "instrumentbräda",
    defaultBranch: "Standardgren",
    "delete": "Radera",
    edit: "Redigera",
    deleteBranch: "Ta bort gren",
    loading: "Läser in",
    newBranch: "Ny gren",
    otherBranches: "Andra grenar",
    pullRequests: "Dra förfrågningar",
    save: "Spara",
    search: "Sök",
    singleton: "Singleton",
    singletons: "Singlar",
    theCurrentlyCheckedOutBranch: "Den utcheckade filialen. Välj detta om du behöver bygga på befintligt arbete från den aktuella grenen.",
    theDefaultBranchInYourRepository: "Standardgrenen i ditt arkiv. Välj detta för att starta något nytt som inte är beroende av din nuvarande filial.",
    viewPullRequests: "Visa pull-förfrågningar"
  },
  "tr-TR": {
    add: "Avbryt",
    branchName: "şube adı",
    basedOn: "Dayalı",
    branches: "Şubeler",
    cancel: "iptal etmek",
    clear: "Temizle",
    collection: "Toplamak",
    collections: "Koleksiyonlar",
    create: "Yaratmak",
    createPullRequest: "Çekme isteği oluştur",
    dashboard: "Gösterge Paneli",
    currentBranch: "Mevcut şube",
    defaultBranch: "varsayılan dal",
    "delete": "Silmek",
    deleteBranch: "Şubeyi sil",
    loading: "Yükleniyor",
    edit: "Düzenlemek",
    newBranch: "Yeni dal",
    otherBranches: "Diğer şubeler",
    pullRequests: "Çekme istekleri",
    search: "Ara",
    save: "Kaydetmek",
    singletons: "Singleton'lar",
    singleton: "Tekil",
    theCurrentlyCheckedOutBranch: "Şu anda kontrol edilen şube. Geçerli daldaki mevcut işi geliştirmeniz gerekiyorsa bunu seçin.",
    theDefaultBranchInYourRepository: "Deponuzdaki varsayılan şube. Mevcut şubenize bağlı olmayan yeni bir şey başlatmak için bunu seçin.",
    viewPullRequests: "Çekme isteklerini görüntüle"
  },
  "uk-UA": {
    add: "додати",
    branches: "Відділення",
    cancel: "скасувати",
    branchName: "Назва гілки",
    basedOn: "На основі",
    collections: "Колекції",
    collection: "Колекція",
    create: "Створити",
    clear: "Очистити",
    createPullRequest: "Створити запит на отримання",
    currentBranch: "Поточне відділення",
    dashboard: "Панель приладів",
    defaultBranch: "Гілка за замовчуванням",
    "delete": "Видалити",
    deleteBranch: "Видалити гілку",
    loading: "Завантаження",
    edit: "Редагувати",
    newBranch: "Нова гілка",
    save: "зберегти",
    pullRequests: "Запити на витягування",
    otherBranches: "Інші гілки",
    search: "Пошук",
    singleton: "Синглтон",
    singletons: "Одиночки",
    theCurrentlyCheckedOutBranch: "Поточна перевірена гілка. Виберіть це, якщо вам потрібно створити на основі існуючої роботи з поточної гілки.",
    theDefaultBranchInYourRepository: "Стандартна гілка у вашому сховищі. Виберіть це, щоб почати щось нове, що не залежить від вашої поточної гілки.",
    viewPullRequests: "Перегляд запитів на отримання"
  },
  "zh-CN": {
    add: "添加",
    basedOn: "基于",
    branchName: "分店名称",
    cancel: "取消",
    branches: "分支机构",
    collection: "收藏",
    collections: "收藏品",
    clear: "透明",
    create: "创造",
    currentBranch: "当前分支",
    createPullRequest: "创建拉取请求",
    defaultBranch: "默认分支",
    dashboard: "仪表板",
    deleteBranch: "删除分支",
    "delete": "删除",
    loading: "正在加载",
    edit: "编辑",
    newBranch: "新分行",
    otherBranches: "其他分行",
    pullRequests: "拉取请求",
    save: "节省",
    singleton: "单例",
    theCurrentlyCheckedOutBranch: "当前签出的分支。 如果您需要在当前分支的现有工作的基础上构建，请选择此项。",
    search: "搜索",
    singletons: "单例",
    theDefaultBranchInYourRepository: "存储库中的默认分支。 选择此选项可开始一些不依赖于当前分支的新操作。",
    viewPullRequests: "查看拉取请求"
  },
  "zh-TW": {
    basedOn: "基於",
    add: "添加",
    branches: "分支機構",
    branchName: "分店名稱",
    cancel: "取消",
    clear: "清除",
    collections: "收藏品",
    collection: "收藏",
    create: "創造",
    createPullRequest: "創建拉取請求",
    dashboard: "儀表板",
    currentBranch: "當前分支",
    "delete": "刪除",
    defaultBranch: "默認分支",
    deleteBranch: "刪除分支",
    edit: "編輯",
    loading: "正在載入",
    newBranch: "新分行",
    otherBranches: "其他分行",
    pullRequests: "拉取請求",
    save: "節省",
    search: "搜尋",
    singletons: "單例",
    singleton: "單例",
    theCurrentlyCheckedOutBranch: "當前簽出的分支。 如果您需要在當前分支的現有工作的基礎上構建，請選擇此項。",
    theDefaultBranchInYourRepository: "存儲庫中的默認分支。 選擇此選項可開始一些不依賴於當前分支的新操作。",
    viewPullRequests: "查看拉取請求"
  }
};
var SIDE_PANEL_ID = "keystatic-side-panel";
var MAIN_PANEL_ID = "keystatic-main-panel";
var View = (props) => {
  return (0, import_jsx_runtime70.jsx)(Box, {
    height: "100%",
    minHeight: 0,
    minWidth: 0,
    ...props
  });
};
var ScrollView2 = (props) => {
  let {
    isDisabled,
    ...otherProps
  } = props;
  return (0, import_jsx_runtime70.jsx)(View, {
    "data-scrollable": isDisabled ? void 0 : true,
    UNSAFE_className: css({
      "&[data-scrollable]": {
        overflowY: "auto",
        WebkitOverflowScrolling: "touch"
      }
    }),
    ...otherProps
  });
};
var NAVIGATION_DIVIDER_KEY = "---";
function config2(config3) {
  return config3;
}
function collection(collection2) {
  return collection2;
}
function singleton(collection2) {
  return collection2;
}
function useNavItems() {
  var _config$ui;
  let {
    basePath
  } = useAppState();
  let config3 = useConfig();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  let changeMap = useChanged();
  const collectionKeys = Object.keys(config3.collections || {});
  const singletonKeys = Object.keys(config3.singletons || {});
  const items = ((_config$ui = config3.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.navigation) || {
    ...!!collectionKeys.length && {
      [stringFormatter.format("collections")]: collectionKeys
    },
    ...!!singletonKeys.length && {
      [stringFormatter.format("singletons")]: singletonKeys
    }
  };
  const options = {
    basePath,
    changeMap,
    config: config3
  };
  if (Array.isArray(items)) {
    return items.map((key3) => populateItemData(key3, options));
  }
  return Object.entries(items).map(([section, keys3]) => ({
    title: section,
    children: keys3.map((key3) => populateItemData(key3, options))
  }));
}
function populateItemData(key3, options) {
  let {
    basePath,
    changeMap,
    config: config3
  } = options;
  if (key3 === NAVIGATION_DIVIDER_KEY) {
    return {
      isDivider: true
    };
  }
  if (config3.collections && key3 in config3.collections) {
    const href = `${basePath}/collection/${encodeURIComponent(key3)}`;
    const changes = changeMap.collections.get(key3);
    const changed = changes ? changes.changed.size + changes.added.size + changes.removed.size : 0;
    const label = config3.collections[key3].label;
    return {
      key: key3,
      href,
      label,
      changed,
      entryCount: changes === null || changes === void 0 ? void 0 : changes.totalCount
    };
  }
  if (config3.singletons && key3 in config3.singletons) {
    const href = `${basePath}/singleton/${encodeURIComponent(key3)}`;
    const changed = changeMap.singletons.has(key3);
    const label = config3.singletons[key3].label;
    return {
      key: key3,
      href,
      label,
      changed
    };
  }
  throw new Error(`Unknown navigation key: "${key3}".`);
}
function useBrand() {
  var _config$ui, _config$ui2;
  let {
    colorScheme
  } = useProvider();
  let config3 = useConfig();
  let prefersDark = useMediaQuery("(prefers-color-scheme: dark)");
  let brandMark = (0, import_jsx_runtime70.jsx)(ZapLogo, {});
  let brandName = "Keystatic";
  if ((_config$ui = config3.ui) !== null && _config$ui !== void 0 && (_config$ui = _config$ui.brand) !== null && _config$ui !== void 0 && _config$ui.mark) {
    let BrandMark = config3.ui.brand.mark;
    let resolvedColorScheme = colorScheme === "auto" ? prefersDark ? "dark" : "light" : colorScheme;
    brandMark = (0, import_jsx_runtime70.jsx)(BrandMark, {
      colorScheme: resolvedColorScheme
    });
  }
  if ("repo" in config3.storage) {
    brandName = serializeRepoConfig(config3.storage.repo);
  }
  if (config3.cloud) {
    brandName = config3.cloud.project;
  }
  if ((_config$ui2 = config3.ui) !== null && _config$ui2 !== void 0 && (_config$ui2 = _config$ui2.brand) !== null && _config$ui2 !== void 0 && _config$ui2.name) {
    brandName = config3.ui.brand.name;
  }
  return {
    brandMark,
    brandName
  };
}
function ZapLogo() {
  let id = "brand-mark-gradient";
  let size4 = 24;
  return (0, import_jsx_runtime70.jsxs)("svg", {
    width: size4,
    height: size4,
    viewBox: "0 0 32 32",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [(0, import_jsx_runtime70.jsx)("path", {
      d: "M18 8L14 24L12 32L30 14L18 8Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime70.jsx)("path", {
      d: "M2 18L20 0L18 8L2 18Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime70.jsx)("path", {
      d: "M18 8L2 18L14 24L18 8Z",
      fill: `url(#${id})`
    }), (0, import_jsx_runtime70.jsx)("defs", {
      children: (0, import_jsx_runtime70.jsxs)("linearGradient", {
        id,
        x1: "2",
        y1: "18",
        x2: "20",
        y2: "14",
        gradientUnits: "userSpaceOnUse",
        children: [(0, import_jsx_runtime70.jsx)("stop", {
          stopColor: "currentColor",
          stopOpacity: "0.2"
        }), (0, import_jsx_runtime70.jsx)("stop", {
          offset: "1",
          stopColor: "currentColor"
        })]
      })
    })]
  });
}
function BranchPicker() {
  const {
    allBranches,
    currentBranch,
    defaultBranch
  } = (0, import_react55.useContext)(BranchInfoContext);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const router = useRouter();
  const config3 = useConfig();
  const branchPrefix = getBranchPrefix(config3);
  const items = (0, import_react55.useMemo)(() => {
    let defaultItems = allBranches.map((name2) => ({
      id: name2,
      name: name2
    }));
    if (defaultBranch) {
      return [{
        id: defaultBranch,
        name: defaultBranch,
        description: stringFormatter.format("defaultBranch")
      }, ...defaultItems.filter((i2) => i2.name !== defaultBranch)];
    }
    return defaultItems;
  }, [allBranches, defaultBranch, stringFormatter]);
  const filteredBranches = (0, import_react55.useMemo)(() => items.filter((item2) => item2.name === defaultBranch || !branchPrefix || item2.name.startsWith(branchPrefix) || item2.name === currentBranch), [branchPrefix, currentBranch, defaultBranch, items]);
  return (0, import_jsx_runtime70.jsx)(_Combobox, {
    "aria-label": stringFormatter.format("currentBranch"),
    defaultItems: filteredBranches,
    loadingState: filteredBranches.length === 0 ? "loading" : void 0,
    selectedKey: currentBranch,
    onSelectionChange: (key3) => {
      if (typeof key3 === "string") {
        router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(key3)));
      }
    },
    menuTrigger: "focus",
    flex: true,
    children: (item2) => (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      textValue: item2.name,
      children: [(0, import_jsx_runtime70.jsx)(Icon, {
        src: gitBranchIcon
      }), (0, import_jsx_runtime70.jsx)(Text, {
        truncate: true,
        children: item2.name
      }), "description" in item2 && (0, import_jsx_runtime70.jsx)(Text, {
        slot: "description",
        children: item2.description
      })]
    }, item2.id)
  });
}
function CreateBranchDialog(props) {
  const config3 = useConfig();
  const branchInfo = (0, import_react55.useContext)(BranchInfoContext);
  const isDefaultBranch = branchInfo.defaultBranch === branchInfo.currentBranch;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const [{
    error: error3,
    fetching
  }, createBranch] = useCreateBranchMutation();
  const repositoryId = useRepositoryId();
  const createBranchSubmitButtonId = "create-branch-submit-button";
  const [branchName, setBranchName] = (0, import_react55.useState)("");
  const [baseBranch, setBaseBranch] = (0, import_react55.useState)(branchInfo.defaultBranch);
  const branchPrefix = getBranchPrefix(config3);
  const propsForBranchPrefix = branchPrefix ? {
    UNSAFE_className: css({
      "& input": {
        paddingInlineStart: tokenSchema.size.space.xsmall
      }
    }),
    startElement: (0, import_jsx_runtime70.jsx)(Flex, {
      alignItems: "center",
      paddingStart: "regular",
      justifyContent: "center",
      pointerEvents: "none",
      children: (0, import_jsx_runtime70.jsx)(Text, {
        color: "neutralSecondary",
        children: branchPrefix
      })
    })
  } : {};
  return (0, import_jsx_runtime70.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime70.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: async (event) => {
        var _result$data;
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        const fullBranchName = (branchPrefix !== null && branchPrefix !== void 0 ? branchPrefix : "") + branchName;
        const name2 = `refs/heads/${fullBranchName}`;
        const result = await createBranch({
          input: {
            name: name2,
            oid: branchInfo.branchNameToBaseCommit.get(baseBranch),
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(fullBranchName);
        }
      },
      children: [(0, import_jsx_runtime70.jsx)(Heading, {
        children: stringFormatter.format("newBranch")
      }), (0, import_jsx_runtime70.jsx)(Content, {
        children: isDefaultBranch ? (0, import_jsx_runtime70.jsx)(TextField, {
          value: branchName,
          onChange: setBranchName,
          label: stringFormatter.format("branchName"),
          autoFocus: true,
          errorMessage: prettyErrorForCreateBranchMutation(error3),
          ...propsForBranchPrefix
        }) : (0, import_jsx_runtime70.jsxs)(Grid, {
          gap: "xlarge",
          children: [(0, import_jsx_runtime70.jsx)(TextField, {
            label: stringFormatter.format("branchName"),
            value: branchName,
            onChange: setBranchName,
            autoFocus: true,
            errorMessage: prettyErrorForCreateBranchMutation(error3),
            ...propsForBranchPrefix
          }), (0, import_jsx_runtime70.jsxs)(RadioGroup, {
            label: stringFormatter.format("basedOn"),
            value: baseBranch,
            onChange: setBaseBranch,
            children: [(0, import_jsx_runtime70.jsxs)(Radio, {
              value: branchInfo.defaultBranch,
              children: [(0, import_jsx_runtime70.jsxs)(Text, {
                children: [branchInfo.defaultBranch, (0, import_jsx_runtime70.jsx)(Text, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), (0, import_jsx_runtime70.jsx)(Text, {
                slot: "description",
                children: stringFormatter.format("theDefaultBranchInYourRepository")
              })]
            }), (0, import_jsx_runtime70.jsxs)(Radio, {
              value: branchInfo.currentBranch,
              children: [(0, import_jsx_runtime70.jsxs)(Text, {
                children: [branchInfo.currentBranch, (0, import_jsx_runtime70.jsx)(Text, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), (0, import_jsx_runtime70.jsx)(Text, {
                slot: "description",
                children: stringFormatter.format("theCurrentlyCheckedOutBranch")
              })]
            })]
          })]
        })
      }), (0, import_jsx_runtime70.jsx)(Footer, {
        UNSAFE_style: {
          justifyContent: "flex-end"
        },
        children: fetching && (0, import_jsx_runtime70.jsx)(ProgressCircle, {
          "aria-labelledby": createBranchSubmitButtonId,
          isIndeterminate: true,
          size: "small"
        })
      }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime70.jsx)(Button, {
          onPress: props.onDismiss,
          isDisabled: fetching,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime70.jsx)(Button, {
          isDisabled: fetching,
          prominence: "high",
          type: "submit",
          id: createBranchSubmitButtonId,
          children: stringFormatter.format("create")
        })]
      })]
    })
  });
}
var invalidAnywhere = [" ", "~", "^", ":", "*", "?", "[", "..", "@{", "\\"];
var invalidStart = [".", "/"];
var invalidEnd = [".", "/", ".lock"];
function prettyErrorForCreateBranchMutation(error3) {
  if (!error3) {
    return void 0;
  }
  if (error3.message.includes("is not a valid ref name")) {
    let refnameMatch = error3.message.match(/"([^"]+)"/);
    let branchname = refnameMatch ? refnameMatch[1].replace("refs/heads/", "") : "";
    for (let char of invalidStart) {
      if (branchname.startsWith(char)) {
        return `Cannot start with "${char}"`;
      }
    }
    for (let char of invalidEnd) {
      if (branchname.endsWith(char)) {
        return `Cannot end with "${char}"`;
      }
    }
    let invalidMatches = invalidAnywhere.filter((c) => branchname.includes(c));
    if (invalidMatches.length > 0) {
      let options = {
        style: "long",
        type: "conjunction"
      };
      let formatter = new Intl.ListFormat("en-US", options);
      let list5 = invalidMatches.map((char) => `"${char}"`);
      return `Some characters are not allowed: ${formatter.format(list5)}`;
    }
    return "Invalid branch name";
  }
  return error3.message;
}
function useCreateBranchMutation() {
  return useMutation(lib_default`
      mutation CreateBranch($input: CreateRefInput!) {
        createRef(input: $input) {
          __typename
          ref {
            ...Ref_base
          }
        }
      }
      ${Ref_base}
    `);
}
var ThemeContext = (0, import_react55.createContext)({
  theme: "auto",
  setTheme: () => {
    throw new Error("ThemeContext was not initialized.");
  }
});
var ThemeProvider = ThemeContext.Provider;
var STORAGE_KEY = "keystatic-color-scheme";
function useTheme() {
  let [theme, setThemeValue] = (0, import_react55.useState)(() => {
    let storedValue = localStorage.getItem(STORAGE_KEY);
    if (storedValue === "light" || storedValue === "dark") {
      return storedValue;
    }
    return "auto";
  });
  let setTheme = (theme2) => {
    localStorage.setItem(STORAGE_KEY, theme2);
    setThemeValue(theme2);
  };
  return {
    theme,
    setTheme
  };
}
function useThemeContext() {
  return (0, import_react55.useContext)(ThemeContext);
}
var BlockWrapper$1 = (props) => {
  let {
    attributes,
    children,
    draggable = false
  } = props;
  return (0, import_jsx_runtime70.jsx)("div", {
    draggable,
    className: blockElementSpacing,
    ...attributes,
    children
  });
};
var ToolbarSeparator = () => {
  return (0, import_jsx_runtime70.jsx)(Divider, {
    orientation: "vertical",
    flexShrink: 0
  });
};
var units = {
  seconds: 60,
  minutes: 60,
  hours: 24,
  days: 7,
  weeks: 4,
  months: 12,
  years: Infinity
};
function formatTimeAgo(targetDate, currentDate, formatter) {
  let duration = (targetDate.getTime() - currentDate.getTime()) / 1e3;
  for (const [name2, amount] of Object.entries(units)) {
    if (Math.abs(duration) < amount) {
      return formatter.format(Math.round(duration), name2);
    }
    duration /= amount;
  }
  return "unknown";
}
function RelativeTime(props) {
  const {
    locale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const [now] = (0, import_react55.useState)(() => /* @__PURE__ */ new Date());
  const formatted = (0, import_react55.useMemo)(() => {
    const formatter = new Intl.RelativeTimeFormat(locale);
    formatter.format(props.date.getTime() - now.getTime(), "second");
    return formatTimeAgo(props.date, now, formatter);
  }, [locale, now, props.date]);
  return (0, import_jsx_runtime70.jsx)("time", {
    dateTime: props.date.toISOString(),
    children: formatted
  });
}
function showDraftRestoredToast(savedAt, hasChangedSince) {
  toastQueue.info((0, import_jsx_runtime70.jsxs)(Text, {
    children: ["Restored draft from ", (0, import_jsx_runtime70.jsx)(RelativeTime, {
      date: savedAt
    }), ".", " ", hasChangedSince && (0, import_jsx_runtime70.jsx)(Text, {
      color: "accent",
      children: "Other changes have been made to this entry since the draft. You may want to discard the draft changes."
    })]
  }), {
    timeout: 8e3
  });
}
var store;
function getStore() {
  if (!store) {
    store = createStore("keystatic", "items");
  }
  return store;
}
function setDraft(key3, val) {
  return set(key3, val, getStore());
}
function delDraft(key3) {
  return del(key3, getStore());
}
function getDraft(key3) {
  return get(key3, getStore());
}
async function clearDrafts() {
  await clear(getStore());
}
var THEME_MODE = {
  light: {
    icon: sunIcon,
    label: "Light"
  },
  dark: {
    icon: moonIcon,
    label: "Dark"
  },
  auto: {
    icon: monitorIcon,
    label: "System"
  }
};
var themeItems = Object.entries(THEME_MODE).map(([id, {
  icon,
  label
}]) => ({
  id,
  icon,
  label
}));
function ThemeMenu() {
  let {
    theme,
    setTheme
  } = useThemeContext();
  let matchesDark = useMediaQuery("(prefers-color-scheme: dark)");
  let icon = THEME_MODE[theme].icon;
  if (theme === "auto") {
    icon = matchesDark ? moonIcon : sunIcon;
  }
  return (0, import_jsx_runtime70.jsxs)(MenuTrigger, {
    align: "end",
    children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
      "aria-label": "theme",
      prominence: "low",
      children: (0, import_jsx_runtime70.jsx)(Icon, {
        src: icon
      })
    }), (0, import_jsx_runtime70.jsx)(_Menu, {
      items: themeItems,
      onSelectionChange: ([key3]) => setTheme(key3),
      disallowEmptySelection: true,
      selectedKeys: [theme],
      selectionMode: "single",
      children: (item2) => (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: item2.label,
        children: [(0, import_jsx_runtime70.jsx)(Icon, {
          src: item2.icon
        }), (0, import_jsx_runtime70.jsx)(Text, {
          children: item2.label
        })]
      })
    })]
  });
}
function UserActions() {
  let config3 = useConfig();
  let userData = useUserData();
  let router = useRouter();
  if (!userData) {
    return null;
  }
  if (userData === "unauthorized") {
    return (0, import_jsx_runtime70.jsx)(ActionButton, {
      onPress: () => {
        redirectToCloudAuth(router.params.map(encodeURIComponent).join("/"), config3);
      },
      flex: true,
      children: "Sign into Cloud"
    });
  }
  return (0, import_jsx_runtime70.jsx)(UserMenu, {
    ...userData
  });
}
function UserMenu(user) {
  let config3 = useConfig();
  const cloudInfo = useCloudInfo();
  const imageLibraryUrl = useImageLibraryURL();
  const menuItems = (0, import_react55.useMemo)(() => {
    var _config$cloud;
    let items = [{
      key: "logout",
      label: "Log out",
      icon: logOutIcon
    }];
    if ((_config$cloud = config3.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
      items.unshift({
        key: "manage",
        label: "Account",
        icon: userIcon,
        href: "https://keystatic.cloud/account",
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    if (cloudInfo !== null && cloudInfo !== void 0 && cloudInfo.team.images) {
      items.unshift({
        key: "image-library",
        label: "Image library",
        icon: imageIcon,
        href: imageLibraryUrl,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    return items;
  }, [cloudInfo, config3, imageLibraryUrl]);
  if (!user) {
    return null;
  }
  return (0, import_jsx_runtime70.jsxs)(MenuTrigger, {
    children: [(0, import_jsx_runtime70.jsx)(UserDetailsButton, {
      ...user
    }), (0, import_jsx_runtime70.jsx)(import_jsx_runtime70.Fragment, {
      children: (0, import_jsx_runtime70.jsx)(_Menu, {
        items: menuItems,
        minWidth: "scale.2400",
        onAction: async (key3) => {
          await Promise.all([clearObjectCache(), clearDrafts()]);
          switch (key3) {
            case "logout":
              switch (config3.storage.kind) {
                case "github": {
                  window.location.href = "/api/keystatic/github/logout";
                  break;
                }
                case "cloud":
                case "local": {
                  var _getCloudAuth;
                  const token = (_getCloudAuth = getCloudAuth(config3)) === null || _getCloudAuth === void 0 ? void 0 : _getCloudAuth.accessToken;
                  if (token) {
                    await fetch(`${KEYSTATIC_CLOUD_API_URL}/oauth/revoke`, {
                      method: "POST",
                      body: new URLSearchParams({
                        token
                      }).toString(),
                      headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                        ...KEYSTATIC_CLOUD_HEADERS
                      }
                    });
                  }
                  localStorage.removeItem("keystatic-cloud-access-token");
                  window.location.reload();
                  break;
                }
              }
          }
        },
        children: (item2) => (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          href: item2.href,
          rel: item2.rel,
          target: item2.target,
          children: [(0, import_jsx_runtime70.jsx)(Icon, {
            src: item2.icon
          }), (0, import_jsx_runtime70.jsx)(Text, {
            children: item2.label
          })]
        }, item2.key)
      })
    })]
  });
}
var UserDetailsButton = (0, import_react55.forwardRef)(function UserDetailsButton2(props, ref2) {
  let {
    avatarUrl,
    login,
    name: name2,
    ...otherProps
  } = props;
  return (0, import_jsx_runtime70.jsx)(ActionButton, {
    ...otherProps,
    ref: ref2,
    "aria-label": "User menu",
    prominence: "low",
    flexGrow: 1,
    UNSAFE_className: css({
      justifyContent: "start",
      textAlign: "start"
    }),
    children: (0, import_jsx_runtime70.jsxs)(Flex, {
      alignItems: "center",
      gap: "regular",
      children: [(0, import_jsx_runtime70.jsx)(Avatar, {
        src: avatarUrl,
        name: name2 !== null && name2 !== void 0 ? name2 : void 0,
        size: "small"
      }), (0, import_jsx_runtime70.jsx)(ClearSlots, {
        children: (0, import_jsx_runtime70.jsxs)(Flex, {
          direction: "column",
          gap: "small",
          children: [(0, import_jsx_runtime70.jsx)(Text, {
            size: "small",
            weight: "semibold",
            color: "neutralEmphasis",
            children: name2
          }), name2 === login ? null : (0, import_jsx_runtime70.jsx)(Text, {
            size: "small",
            color: "neutralTertiary",
            children: login
          })]
        })
      })]
    })
  });
});
function useAssociatedPullRequest() {
  var _prResult$data, _prResult$data$node$a, _prResult$data$node$a2;
  const data2 = useBranchInfo();
  const currentBranchId = data2.branchNameToId.get(data2.currentBranch);
  const [prResult] = useQuery({
    query: lib_default`
      query PullRequestForBranch($refId: ID!) {
        node(id: $refId) {
          __typename
          id
          ... on Ref {
            associatedPullRequests(states: [OPEN], first: 1) {
              nodes {
                id
                number
              }
            }
          }
        }
      }
    `,
    pause: !currentBranchId || data2.currentBranch === data2.defaultBranch,
    variables: {
      refId: currentBranchId
    }
  });
  return (_prResult$data = prResult.data) !== null && _prResult$data !== void 0 && _prResult$data.node && prResult.data.node.__typename === "Ref" ? (_prResult$data$node$a = (_prResult$data$node$a2 = prResult.data.node.associatedPullRequests) === null || _prResult$data$node$a2 === void 0 || (_prResult$data$node$a2 = _prResult$data$node$a2.nodes) === null || _prResult$data$node$a2 === void 0 || (_prResult$data$node$a2 = _prResult$data$node$a2[0]) === null || _prResult$data$node$a2 === void 0 ? void 0 : _prResult$data$node$a2.number) !== null && _prResult$data$node$a !== void 0 ? _prResult$data$node$a : false : void 0;
}
function GitMenu() {
  var _appShellData$data, _appShellData$data$re;
  const data2 = useBranchInfo();
  const prNumber = useAssociatedPullRequest();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const [newBranchDialogVisible, toggleNewBranchDialog] = (0, import_react55.useReducer)((v) => !v, false);
  const [deleteBranchDialogVisible, toggleDeleteBranchDialog] = (0, import_react55.useReducer)((v) => !v, false);
  const [, deleteBranch] = useMutation(lib_default`
      mutation DeleteBranch($refId: ID!) {
        deleteRef(input: { refId: $refId }) {
          __typename
        }
      }
    `);
  const repoURL = getRepoUrl(data2);
  const appShellData = (0, import_react55.useContext)(GitHubAppShellDataContext);
  const fork = (appShellData === null || appShellData === void 0 || (_appShellData$data = appShellData.data) === null || _appShellData$data === void 0 ? void 0 : _appShellData$data.repository) && "forks" in appShellData.data.repository && ((_appShellData$data$re = appShellData.data.repository.forks.nodes) === null || _appShellData$data$re === void 0 ? void 0 : _appShellData$data$re[0]);
  const gitMenuItems = (0, import_react55.useMemo)(() => {
    let isDefaultBranch = data2.currentBranch === data2.defaultBranch;
    let items = [];
    let branchSection = [{
      key: "new-branch",
      icon: gitBranchPlusIcon,
      label: stringFormatter.format("newBranch")
    }];
    let prSection = [];
    let repoSection = [{
      key: "repo",
      icon: githubIcon,
      href: repoURL,
      target: "_blank",
      rel: "noopener noreferrer",
      label: "Github repo"
      // TODO: l10n
    }];
    if (!isDefaultBranch && prNumber !== void 0) {
      if (prNumber === false) {
        prSection.push({
          key: "create-pull-request",
          icon: gitPullRequestIcon,
          href: `${repoURL}/pull/new/${data2.currentBranch}`,
          target: "_blank",
          rel: "noopener noreferrer",
          label: stringFormatter.format("createPullRequest")
        });
        branchSection.push({
          key: "delete-branch",
          icon: trash2Icon,
          label: stringFormatter.format("deleteBranch")
        });
      } else {
        prSection.push({
          key: "view-pull-request",
          icon: gitPullRequestIcon,
          href: `${repoURL}/pull/${prNumber}`,
          target: "_blank",
          rel: "noopener noreferrer",
          label: `Pull Request #${prNumber}`
        });
      }
    }
    if (fork) {
      repoSection.push({
        key: "fork",
        icon: gitForkIcon,
        href: `https://github.com/${fork.owner.login}/${fork.name}`,
        target: "_blank",
        rel: "noopener noreferrer",
        label: "View fork"
        // TODO: l10n
      });
    }
    if (branchSection.length) {
      items.push({
        key: "branch-section",
        label: stringFormatter.format("branches"),
        children: branchSection
      });
    }
    if (prSection.length) {
      items.push({
        key: "pr-section",
        label: stringFormatter.format("pullRequests"),
        children: prSection
      });
    }
    if (repoSection.length) {
      items.push({
        key: "repo-section",
        label: "Repository",
        // TODO: l10n
        children: repoSection
      });
    }
    return items;
  }, [fork, data2.currentBranch, data2.defaultBranch, prNumber, repoURL, stringFormatter]);
  const router = useRouter();
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsx)(_ActionMenu, {
      "aria-label": "git actions",
      align: "end",
      items: gitMenuItems,
      onAction: (key3) => {
        switch (key3) {
          case "new-branch":
            toggleNewBranchDialog();
            break;
          case "delete-branch": {
            toggleDeleteBranchDialog();
            break;
          }
        }
      },
      children: (item2) => (0, import_jsx_runtime70.jsx)($9fc4852771d079eb$export$6e2c8f0811a474ce, {
        items: item2.children,
        "aria-label": item2.label,
        children: (item3) => (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item3.label,
          href: item3.href,
          rel: item3.rel,
          target: item3.target,
          children: [(0, import_jsx_runtime70.jsx)(Icon, {
            src: item3.icon
          }), (0, import_jsx_runtime70.jsx)(Text, {
            children: item3.label
          })]
        }, item3.key)
      }, item2.key)
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: toggleNewBranchDialog,
      children: newBranchDialogVisible && (0, import_jsx_runtime70.jsx)(CreateBranchDialog, {
        onDismiss: toggleNewBranchDialog,
        onCreate: (branchName) => {
          toggleNewBranchDialog();
          router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(branchName)));
        }
      })
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: toggleDeleteBranchDialog,
      children: deleteBranchDialogVisible && (0, import_jsx_runtime70.jsxs)(AlertDialog, {
        title: "Delete branch",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: async () => {
          await deleteBranch({
            refId: data2.branchNameToId.get(data2.currentBranch)
          });
          router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(data2.defaultBranch)));
        },
        children: ['Are you sure you want to delete the "', data2.currentBranch, '" branch? This cannot be undone.']
      })
    })]
  });
}
function useUserData() {
  const config3 = useConfig();
  const user = useViewer();
  const rawCloudInfo = useRawCloudInfo();
  if (rawCloudInfo) {
    if (rawCloudInfo === "unauthorized") {
      return rawCloudInfo;
    }
    return {
      avatarUrl: rawCloudInfo.user.avatarUrl,
      login: rawCloudInfo.user.email,
      name: rawCloudInfo.user.name
    };
  }
  if (isGitHubConfig(config3) && user) {
    var _user$name;
    return {
      avatarUrl: user.avatarUrl,
      login: user.login,
      name: (_user$name = user.name) !== null && _user$name !== void 0 ? _user$name : user.login
    };
  }
  return void 0;
}
var SidebarContext = (0, import_react55.createContext)(null);
function useSidebar() {
  let context = (0, import_react55.useContext)(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be within a SidebarProvider");
  }
  return context;
}
var breakpointNames = typedKeys(breakpoints);
function SidebarProvider(props) {
  const matchedBreakpoints = useBreakpoint();
  const state2 = $fc909762b330b746$export$61c6a8c84e605fb6({
    defaultOpen: matchedBreakpoints.includes("desktop")
  });
  let breakpointIndex = breakpointNames.indexOf(matchedBreakpoints[0]);
  let previousIndex = usePrevious(breakpointIndex) || 0;
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => {
    let larger = previousIndex < breakpointIndex;
    if (larger && breakpointIndex >= 2) {
      state2.open();
    } else if (breakpointIndex < 2) {
      state2.close();
    }
  }, [matchedBreakpoints]);
  return (0, import_jsx_runtime70.jsx)(SidebarContext.Provider, {
    value: state2,
    children: props.children
  });
}
function SidebarPanel() {
  return (0, import_jsx_runtime70.jsxs)(VStack, {
    backgroundColor: "surface",
    height: "100%",
    children: [(0, import_jsx_runtime70.jsx)(SidebarHeader, {}), (0, import_jsx_runtime70.jsx)(SidebarGitActions, {}), (0, import_jsx_runtime70.jsx)(SidebarNav, {}), (0, import_jsx_runtime70.jsx)(SidebarFooter, {})]
  });
}
function SidebarHeader() {
  let isLocalNoCloud = useIsLocalNoCloud();
  let {
    brandMark,
    brandName
  } = useBrand();
  return (0, import_jsx_runtime70.jsxs)(HStack, {
    alignItems: "center",
    gap: "regular",
    paddingY: "regular",
    paddingX: "medium",
    height: {
      mobile: "element.large",
      tablet: "element.xlarge"
    },
    children: [(0, import_jsx_runtime70.jsxs)(HStack, {
      flex: true,
      alignItems: "center",
      gap: "regular",
      UNSAFE_className: css({
        // let consumers use "currentColor" in SVG for their brand mark
        color: tokenSchema.color.foreground.neutralEmphasis,
        // ensure that the brand mark doesn't get squashed
        "& :first-child": {
          flexShrink: 0
        }
      }),
      children: [brandMark, (0, import_jsx_runtime70.jsx)(Text, {
        color: "inherit",
        weight: "medium",
        truncate: true,
        children: brandName
      })]
    }), isLocalNoCloud && (0, import_jsx_runtime70.jsx)(ThemeMenu, {})]
  });
}
function SidebarFooter() {
  let isLocalNoCloud = useIsLocalNoCloud();
  if (isLocalNoCloud) {
    return null;
  }
  return (0, import_jsx_runtime70.jsxs)(HStack, {
    alignItems: "center",
    paddingY: "regular",
    paddingX: "medium",
    gap: "regular",
    children: [(0, import_jsx_runtime70.jsx)(UserActions, {}), (0, import_jsx_runtime70.jsx)(ThemeMenu, {})]
  });
}
function SidebarGitActions() {
  let config3 = useConfig();
  if (isLocalConfig(config3)) {
    return null;
  }
  return (0, import_jsx_runtime70.jsxs)(HStack, {
    gap: "regular",
    paddingY: "regular",
    paddingX: "medium",
    children: [(0, import_jsx_runtime70.jsx)(BranchPicker, {}), (0, import_jsx_runtime70.jsx)(GitMenu, {})]
  });
}
function SidebarDialog() {
  const state2 = useSidebar();
  const router = useRouter();
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => {
    state2.close();
  }, [router.href]);
  let dialogRef = (0, import_react55.useRef)(null);
  let {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb({
    isDismissable: true
  }, state2, dialogRef);
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsx)(Blanket, {
      ...underlayProps,
      isOpen: state2.isOpen,
      zIndex: 10
    }), (0, import_jsx_runtime70.jsxs)("div", {
      "data-visible": state2.isOpen,
      id: SIDE_PANEL_ID,
      ref: dialogRef,
      ...modalProps,
      // styles
      className: css({
        backgroundColor: tokenSchema.color.background.surface,
        boxShadow: `${tokenSchema.size.shadow.large} ${tokenSchema.color.shadow.regular}`,
        display: "flex",
        flexDirection: "column",
        inset: 0,
        insetInlineEnd: "auto",
        // ensure that there's always enough of gutter for the user to press
        // and exit the sidebar
        maxWidth: `calc(100% - ${tokenSchema.size.element.medium})`,
        minWidth: tokenSchema.size.scale[3e3],
        outline: 0,
        pointerEvents: "none",
        position: "fixed",
        transform: "translateX(-100%)",
        visibility: "hidden",
        zIndex: 10,
        // exit animation
        transition: [transition("transform", {
          easing: "easeIn",
          duration: "short"
          // delay: 'short',
        }), transition("visibility", {
          delay: "regular",
          duration: 0,
          easing: "linear"
        })].join(", "),
        "&[data-visible=true]": {
          transform: "translateX(0)",
          // enter animation
          transition: transition("transform", {
            easing: "easeOut"
          }),
          pointerEvents: "auto",
          visibility: "visible"
        }
      }),
      children: [(0, import_jsx_runtime70.jsx)(SidebarHeader, {}), (0, import_jsx_runtime70.jsx)(SidebarGitActions, {}), (0, import_jsx_runtime70.jsx)(SidebarNav, {}), (0, import_jsx_runtime70.jsx)(SidebarFooter, {}), (0, import_jsx_runtime70.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: state2.close
      })]
    })]
  });
}
function SidebarNav() {
  const {
    basePath
  } = useAppState();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const navItems = useNavItems();
  const isCurrent = useIsCurrent();
  return (0, import_jsx_runtime70.jsx)(ScrollView, {
    flex: true,
    paddingY: "large",
    paddingEnd: "medium",
    children: (0, import_jsx_runtime70.jsxs)(NavList, {
      children: [(0, import_jsx_runtime70.jsx)(NavItem, {
        href: basePath,
        "aria-current": isCurrent(basePath, {
          exact: true
        }),
        children: stringFormatter.format("dashboard")
      }), navItems.map((item2) => renderItemOrGroup(item2, isCurrent))]
    })
  });
}
function useIsLocalNoCloud() {
  const config3 = useConfig();
  return isLocalConfig(config3) && !config3.cloud;
}
function useIsCurrent() {
  const router = useRouter();
  return (0, import_react55.useCallback)((href, {
    exact = false
  } = {}) => {
    if (exact) {
      return href === router.pathname ? "page" : void 0;
    }
    return href === router.pathname || router.pathname.startsWith(`${router.pathname}/`) ? "page" : void 0;
  }, [router.pathname]);
}
var dividerCount = 0;
function renderItemOrGroup(itemOrGroup, isCurrent) {
  if ("isDivider" in itemOrGroup) {
    return (0, import_jsx_runtime70.jsx)(Divider, {}, dividerCount++);
  }
  if ("children" in itemOrGroup) {
    return (0, import_jsx_runtime70.jsx)(NavGroup, {
      title: itemOrGroup.title,
      children: itemOrGroup.children.map((child) => renderItemOrGroup(child, isCurrent))
    }, itemOrGroup.title);
  }
  let changeElement = (() => {
    if (!itemOrGroup.changed) {
      return null;
    }
    return typeof itemOrGroup.changed === "number" ? (0, import_jsx_runtime70.jsxs)(Badge, {
      tone: "accent",
      marginStart: "auto",
      children: [(0, import_jsx_runtime70.jsx)(Text, {
        children: itemOrGroup.changed
      }), (0, import_jsx_runtime70.jsx)(Text, {
        visuallyHidden: true,
        children: pluralize(itemOrGroup.changed, {
          singular: "change",
          plural: "changes",
          inclusive: false
        })
      })]
    }) : (0, import_jsx_runtime70.jsx)(StatusLight, {
      tone: "accent",
      marginStart: "auto",
      "aria-label": "Changed",
      role: "status"
    });
  })();
  return (0, import_jsx_runtime70.jsxs)(NavItem, {
    href: itemOrGroup.href,
    "aria-current": isCurrent(itemOrGroup.href),
    children: [(0, import_jsx_runtime70.jsx)(Text, {
      truncate: true,
      title: itemOrGroup.label,
      children: itemOrGroup.label
    }), changeElement]
  }, itemOrGroup.key);
}
var PageContext = (0, import_react55.createContext)({
  containerWidth: "medium"
});
var PageRoot = ({
  children,
  containerWidth = "medium"
}) => {
  return (0, import_jsx_runtime70.jsx)(PageContext.Provider, {
    value: {
      containerWidth
    },
    children: (0, import_jsx_runtime70.jsx)(Flex, {
      elementType: "main",
      direction: "column",
      id: MAIN_PANEL_ID,
      flex: true,
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children
    })
  });
};
var PageHeader = ({
  children
}) => {
  const sidebarState = useSidebar();
  const menuButtonRef = (0, import_react55.useRef)(null);
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let icon = sidebarState.isOpen ? panelLeftCloseIcon : panelLeftOpenIcon;
  if (direction === "rtl") {
    icon = sidebarState.isOpen ? panelRightCloseIcon : panelRightOpenIcon;
  }
  return (0, import_jsx_runtime70.jsx)(Box, {
    borderBottom: "muted",
    elementType: "header",
    flexShrink: 0,
    children: (0, import_jsx_runtime70.jsxs)(Flex, {
      alignItems: "center",
      gap: {
        mobile: "small",
        tablet: "regular"
      },
      height: {
        mobile: "element.large",
        tablet: "element.xlarge"
      },
      paddingX: {
        mobile: "medium",
        tablet: "xlarge",
        desktop: "xxlarge"
      },
      children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
        prominence: "low",
        "aria-label": "Open app navigation",
        "aria-pressed": sidebarState.isOpen,
        isHidden: sidebarState.isOpen ? {
          above: "tablet"
        } : void 0,
        onPress: sidebarState.toggle,
        ref: menuButtonRef,
        UNSAFE_className: css({
          marginInlineStart: `calc(${tokenSchema.size.space.regular} * -1)`
        }),
        children: (0, import_jsx_runtime70.jsx)(Icon, {
          src: icon
        })
      }), children]
    })
  });
};
var PageBody = ({
  children,
  isScrollable
}) => {
  return (0, import_jsx_runtime70.jsx)(ScrollView2, {
    isDisabled: !isScrollable,
    children: (0, import_jsx_runtime70.jsx)(
      PageContainer,
      {
        paddingY: "xxlarge",
        children
      }
    )
  });
};
var PageContainer = (props) => {
  const {
    containerWidth
  } = (0, import_react55.useContext)(PageContext);
  const maxWidth = containerWidth === "none" ? void 0 : `container.${containerWidth}`;
  return (0, import_jsx_runtime70.jsx)(Box, {
    minHeight: 0,
    minWidth: 0,
    maxWidth,
    paddingX: {
      mobile: "medium",
      tablet: "xlarge",
      desktop: "xxlarge"
    },
    ...props
  });
};
function validateArrayLength(schema, val, path3) {
  var _schema$validation, _schema$validation2;
  if (((_schema$validation = schema.validation) === null || _schema$validation === void 0 || (_schema$validation = _schema$validation.length) === null || _schema$validation === void 0 ? void 0 : _schema$validation.min) !== void 0 && val.length < schema.validation.length.min) {
    return new PropValidationError(new FieldDataError(`Must have at least ${schema.validation.length.min} element${schema.validation.length.min === 1 ? "" : "s"}`), path3, schema);
  }
  if (((_schema$validation2 = schema.validation) === null || _schema$validation2 === void 0 || (_schema$validation2 = _schema$validation2.length) === null || _schema$validation2 === void 0 ? void 0 : _schema$validation2.max) !== void 0 && val.length > schema.validation.length.max) {
    return new PropValidationError(new FieldDataError(`Must have at most ${schema.validation.length.max} element${schema.validation.length.max === 1 ? "" : "s"}}`), path3, schema);
  }
}
var arrayValuesToElementKeys = /* @__PURE__ */ new WeakMap();
var counter = 0;
function getKeysForArrayValue(value) {
  if (!arrayValuesToElementKeys.has(value)) {
    arrayValuesToElementKeys.set(value, Array.from({
      length: value.length
    }, getNewArrayElementKey));
  }
  return arrayValuesToElementKeys.get(value);
}
function setKeysForArrayValue(value, elementIds) {
  arrayValuesToElementKeys.set(value, elementIds);
}
function getNewArrayElementKey() {
  return (counter++).toString();
}
var getInitialPropsValue = _getInitialPropsValue;
function _getInitialPropsValue(schema) {
  switch (schema.kind) {
    case "form":
      return schema.defaultValue();
    case "child":
      return schema.options.kind === "block" ? [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }] : null;
    case "conditional": {
      const defaultValue = schema.discriminant.defaultValue();
      return {
        discriminant: defaultValue,
        value: getInitialPropsValue(schema.values[defaultValue.toString()])
      };
    }
    case "object": {
      const obj = {};
      for (const key3 of Object.keys(schema.fields)) {
        obj[key3] = getInitialPropsValue(schema.fields[key3]);
      }
      return obj;
    }
    case "array": {
      return [];
    }
  }
  assertNever(schema);
}
function getInitialPropsValueFromInitializer(schema, initializer) {
  switch (schema.kind) {
    case "form":
      return initializer === void 0 ? schema.defaultValue() : initializer;
    case "child":
      return initializer !== null && initializer !== void 0 ? initializer : schema.options.kind === "block" ? [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }] : null;
    case "conditional": {
      const defaultValue = initializer === void 0 ? schema.discriminant.defaultValue() : initializer.discriminant;
      if (defaultValue === void 0) {
        debugger;
      }
      return {
        discriminant: defaultValue,
        value: getInitialPropsValueFromInitializer(schema.values[defaultValue.toString()], initializer === void 0 ? void 0 : initializer.value)
      };
    }
    case "object": {
      const obj = {};
      for (const key3 of Object.keys(schema.fields)) {
        obj[key3] = getInitialPropsValueFromInitializer(schema.fields[key3], initializer === void 0 ? void 0 : initializer[key3]);
      }
      return obj;
    }
    case "array": {
      return (initializer !== null && initializer !== void 0 ? initializer : []).map((x) => getInitialPropsValueFromInitializer(schema.element, x.value));
    }
  }
  assertNever(schema);
}
function updateValue(schema, currentValue, updater) {
  if (updater === void 0) return currentValue;
  switch (schema.kind) {
    case "form":
      return updater;
    case "child":
      return updater;
    case "conditional": {
      return {
        discriminant: updater.discriminant,
        value: updater.discriminant === currentValue.discriminant ? updateValue(schema.values[updater.discriminant.toString()], currentValue.value, updater.value) : getInitialPropsValueFromInitializer(schema.values[updater.discriminant.toString()], updater.value)
      };
    }
    case "object": {
      const obj = {};
      for (const key3 of Object.keys(schema.fields)) {
        obj[key3] = updateValue(schema.fields[key3], currentValue[key3], updater[key3]);
      }
      return obj;
    }
    case "array": {
      const currentArrVal = currentValue;
      const newVal = updater;
      const uniqueKeys = /* @__PURE__ */ new Set();
      for (const x of newVal) {
        if (x.key !== void 0) {
          if (uniqueKeys.has(x.key)) {
            throw new Error("Array elements must have unique keys");
          }
          uniqueKeys.add(x.key);
        }
      }
      const keys3 = newVal.map((x) => {
        if (x.key !== void 0) return x.key;
        let elementKey = getNewArrayElementKey();
        while (uniqueKeys.has(elementKey)) {
          elementKey = getNewArrayElementKey();
        }
        uniqueKeys.add(elementKey);
        return elementKey;
      });
      const prevKeys = getKeysForArrayValue(currentArrVal);
      const prevValuesByKey = new Map(currentArrVal.map((value, i2) => {
        return [prevKeys[i2], value];
      }));
      const val = newVal.map((x, i2) => {
        const id = keys3[i2];
        if (prevValuesByKey.has(id)) {
          return updateValue(schema.element, prevValuesByKey.get(id), x.value);
        }
        return getInitialPropsValueFromInitializer(schema.element, x.value);
      });
      setKeysForArrayValue(val, keys3);
      return val;
    }
  }
  assertNever(schema);
}
var PropValidationError = class extends Error {
  constructor(cause, path3, schema) {
    super(`field error at ${path3.join(".")}`, {
      cause
    });
    this.path = path3;
    this.schema = schema;
    this.cause = cause;
  }
};
function toFormFieldStoredValue(val) {
  if (val === null) {
    return void 0;
  }
  return val;
}
var isArray2 = Array.isArray;
function parseProps(schema, _value, path3, pathWithArrayFieldSlugs, parseFormField, validateArrayFieldLength) {
  let value = toFormFieldStoredValue(_value);
  if (schema.kind === "form") {
    try {
      return parseFormField(schema, value, path3, pathWithArrayFieldSlugs);
    } catch (err) {
      throw new PropValidationError(err, path3, schema);
    }
  }
  if (schema.kind === "child") {
    return null;
  }
  if (schema.kind === "conditional") {
    if (value === void 0) {
      return getInitialPropsValue(schema);
    }
    try {
      if (typeof value !== "object" || value === null || isArray2(value) || value instanceof Date) {
        throw new FieldDataError("Must be an object");
      }
      for (const key3 of Object.keys(value)) {
        if (key3 !== "discriminant" && key3 !== "value") {
          throw new FieldDataError(`Must only contain keys "discriminant" and "value", not "${key3}"`);
        }
      }
    } catch (err) {
      throw new PropValidationError(err, path3, schema);
    }
    const parsedDiscriminant = parseProps(schema.discriminant, value.discriminant, path3.concat("discriminant"), pathWithArrayFieldSlugs.concat("discriminant"), parseFormField, validateArrayFieldLength);
    return {
      discriminant: parsedDiscriminant,
      value: parseProps(schema.values[parsedDiscriminant], value.value, path3.concat("value"), pathWithArrayFieldSlugs.concat("value"), parseFormField, validateArrayFieldLength)
    };
  }
  if (schema.kind === "object") {
    if (value === void 0) {
      value = {};
    }
    try {
      if (typeof value !== "object" || value === null || isArray2(value) || value instanceof Date) {
        throw new FieldDataError("Must be an object");
      }
      const allowedKeysSet = new Set(Object.keys(schema.fields));
      for (const key3 of Object.keys(value)) {
        if (!allowedKeysSet.has(key3)) {
          throw new FieldDataError(`Key on object value "${key3}" is not allowed`);
        }
      }
    } catch (err) {
      throw new PropValidationError(err, path3, schema);
    }
    const val = {};
    const errors = [];
    for (const key3 of Object.keys(schema.fields)) {
      let individualVal = value[key3];
      try {
        const propVal = parseProps(schema.fields[key3], individualVal, path3.concat(key3), pathWithArrayFieldSlugs.concat(key3), parseFormField, validateArrayFieldLength);
        val[key3] = propVal;
      } catch (err) {
        errors.push(err);
      }
    }
    if (errors.length) {
      throw new AggregateError(errors);
    }
    return val;
  }
  if (schema.kind === "array") {
    if (value === void 0) {
      return [];
    }
    try {
      if (!isArray2(value)) {
        throw new FieldDataError("Must be an array");
      }
    } catch (err) {
      throw new PropValidationError(err, path3, schema);
    }
    const errors = [];
    try {
      if (validateArrayFieldLength) {
        const error3 = validateArrayLength(schema, value, path3);
        if (error3 !== void 0) {
          errors.push(error3);
        }
      }
      return value.map((innerVal, i2) => {
        try {
          let slug = i2.toString();
          if (schema.slugField && typeof innerVal === "object" && innerVal !== null && !isArray2(innerVal) && !(innerVal instanceof Date)) {
            if (schema.element.kind !== "object") {
              throw new Error("slugField on array fields requires the an object field element");
            }
            const slugField = schema.element.fields[schema.slugField];
            if (!slugField) {
              throw new Error(`slugField "${schema.slugField}" does not exist on object field`);
            }
            if (slugField.kind !== "form") {
              throw new Error(`slugField "${schema.slugField}" is not a form field`);
            }
            if (slugField.formKind !== "slug") {
              throw new Error(`slugField "${schema.slugField}" is not a slug field`);
            }
            let parsedSlugFieldValue;
            try {
              parsedSlugFieldValue = slugField.parse(toFormFieldStoredValue(innerVal[schema.slugField]), void 0);
            } catch (err) {
              throw new AggregateError([err]);
            }
            slug = slugField.serializeWithSlug(parsedSlugFieldValue).slug;
          }
          return parseProps(schema.element, innerVal, path3.concat(i2), pathWithArrayFieldSlugs.concat(slug), parseFormField, validateArrayFieldLength);
        } catch (err) {
          errors.push(err);
        }
      });
    } finally {
      if (errors.length) {
        throw new AggregateError(errors);
      }
    }
  }
  assertNever(schema);
}
function flattenErrors(error3) {
  if (error3 instanceof AggregateError) {
    return error3.errors.flatMap(flattenErrors);
  }
  return [error3];
}
function formatFormDataError(error3) {
  const flatErrors = flattenErrors(error3);
  return flatErrors.map((error4) => {
    if (error4 instanceof PropValidationError) {
      const path3 = error4.path.join(".");
      return `${path3}: ${error4.cause instanceof FieldDataError ? error4.cause.message : `Unexpected error: ${error4.cause}`}`;
    }
    return `Unexpected error: ${error4}`;
  }).join("\n");
}
function toFormattedFormDataError(error3) {
  const formatted = formatFormDataError(error3);
  return new Error(`Field validation failed:
` + formatted);
}
function clientSideValidateProp(schema, value, slugField) {
  try {
    validateValueWithSchema(schema, value, slugField);
    return true;
  } catch (error3) {
    console.warn(toFormattedFormDataError(error3));
    return false;
  }
}
function validateValueWithSchema(schema, value, slugField, path3 = []) {
  switch (schema.kind) {
    case "child": {
      return;
    }
    case "form": {
      try {
        if (slugField && path3[path3.length - 1] === (slugField === null || slugField === void 0 ? void 0 : slugField.field)) {
          schema.validate(value, {
            slugField: {
              slugs: slugField.slugs,
              glob: slugField.glob
            }
          });
          return;
        }
        schema.validate(value, void 0);
      } catch (err) {
        throw new PropValidationError(err, path3, schema);
      }
      return;
    }
    case "conditional": {
      schema.discriminant.validate(value.discriminant);
      validateValueWithSchema(schema.values[value.discriminant], value.value, void 0, path3.concat("value"));
      return;
    }
    case "object": {
      const errors = [];
      for (const [key3, childProp] of Object.entries(schema.fields)) {
        try {
          validateValueWithSchema(childProp, value[key3], key3 === (slugField === null || slugField === void 0 ? void 0 : slugField.field) ? slugField : void 0, path3.concat(key3));
        } catch (err) {
          errors.push(err);
        }
      }
      if (errors.length > 0) {
        throw new AggregateError(errors);
      }
      return;
    }
    case "array": {
      let slugInfo;
      if (schema.slugField !== void 0 && schema.element.kind === "object") {
        const innerSchema = schema.element.fields;
        const {
          slugField: slugField2
        } = schema;
        slugInfo = {
          slugField: slugField2,
          slugs: value.map((val2) => getSlugFromState({
            schema: innerSchema,
            slugField: slugField2
          }, val2))
        };
      }
      const errors = [];
      const val = value;
      const error3 = validateArrayLength(schema, value, path3);
      if (error3 !== void 0) {
        errors.push(error3);
      }
      for (const [idx, innerVal] of val.entries()) {
        try {
          validateValueWithSchema(schema.element, innerVal, slugInfo === void 0 ? void 0 : {
            field: slugInfo.slugField,
            slugs: new Set(slugInfo.slugs.filter((_, i2) => idx !== i2)),
            glob: "*"
          }, path3.concat(idx));
        } catch (err) {
          errors.push(err);
        }
      }
      if (errors.length > 0) {
        throw new AggregateError(errors);
      }
      return;
    }
  }
}
var FIELD_GRID_COLUMNS = 12;
var FieldContext = (0, import_react55.createContext)({
  span: FIELD_GRID_COLUMNS
});
var useFieldContext = () => (0, import_react55.useContext)(FieldContext);
var FieldContextProvider = FieldContext.Provider;
function ObjectFieldInput({
  schema,
  autoFocus,
  fields,
  forceValidation
}) {
  validateLayout(schema);
  const firstFocusable = autoFocus ? findFocusableObjectFieldKey(schema) : void 0;
  const inner = (0, import_jsx_runtime70.jsx)(Grid, {
    columns: `repeat(${FIELD_GRID_COLUMNS}, minmax(auto, 1fr))`,
    columnGap: "medium",
    rowGap: "xlarge",
    children: Object.entries(fields).map(([key3, propVal], index4) => {
      var _schema$layout$index, _schema$layout;
      let span = (_schema$layout$index = (_schema$layout = schema.layout) === null || _schema$layout === void 0 ? void 0 : _schema$layout[index4]) !== null && _schema$layout$index !== void 0 ? _schema$layout$index : FIELD_GRID_COLUMNS;
      return (0, import_jsx_runtime70.jsx)(FieldContextProvider, {
        value: {
          span
        },
        children: (0, import_jsx_runtime70.jsx)("div", {
          className: css({
            gridColumn: `span ${span}`,
            [containerQueries.below.tablet]: {
              gridColumn: `span ${FIELD_GRID_COLUMNS}`
            }
          }),
          children: (0, import_jsx_runtime70.jsx)(AddToPathProvider, {
            part: key3,
            children: (0, import_jsx_runtime70.jsx)(InnerFormValueContentFromPreviewProps, {
              forceValidation,
              autoFocus: key3 === firstFocusable,
              marginBottom: "xlarge",
              ...propVal
            })
          })
        })
      }, key3);
    })
  });
  const id = (0, import_react55.useId)();
  if (!schema.label) {
    return inner;
  }
  const labelId = `${id}-label`;
  const descriptionId = `${id}-description`;
  return (0, import_jsx_runtime70.jsxs)(Grid, {
    role: "group",
    gap: "medium",
    marginY: "xlarge",
    "aria-labelledby": labelId,
    "aria-describedby": schema.description ? descriptionId : void 0,
    children: [(0, import_jsx_runtime70.jsx)(Text, {
      color: "neutralEmphasis",
      size: "medium",
      weight: "semibold",
      id: labelId,
      children: schema.label
    }), !!schema.description && (0, import_jsx_runtime70.jsx)(Text, {
      id: descriptionId,
      size: "regular",
      color: "neutralSecondary",
      children: schema.description
    }), (0, import_jsx_runtime70.jsx)("div", {}), inner]
  });
}
function validateLayout(schema) {
  if (!schema.layout) {
    return;
  }
  assert(schema.layout.length === Object.keys(schema.fields).length, 'A column "span" is required for every field in the layout');
  assert(schema.layout.every((span) => span > 0), "The layout must not contain empty columns");
  assert(schema.layout.every((span) => span <= 12), "Fields may not span more than 12 columns");
  assert(schema.layout.reduce((acc, cur) => acc + cur, 0) % 12 === 0, "The layout must span exactly 12 columns");
}
function findFocusableObjectFieldKey(schema) {
  for (const [key3, innerProp] of Object.entries(schema.fields)) {
    const childFocusable = canFieldBeFocused(innerProp);
    if (childFocusable) {
      return key3;
    }
  }
  return void 0;
}
function canFieldBeFocused(schema) {
  if (schema.kind === "array" || schema.kind === "conditional" || schema.kind === "form") {
    return true;
  }
  if (schema.kind === "child") {
    return false;
  }
  if (schema.kind === "object") {
    for (const innerProp of Object.values(schema.fields)) {
      if (canFieldBeFocused(innerProp)) {
        return true;
      }
    }
    return false;
  }
  assertNever(schema);
}
function ConditionalFieldInput({
  schema,
  autoFocus,
  discriminant,
  onChange,
  value,
  forceValidation
}) {
  const schemaDiscriminant = schema.discriminant;
  return (0, import_jsx_runtime70.jsxs)(Flex, {
    gap: "xlarge",
    direction: "column",
    children: [(0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(AddToPathProvider, {
      part: "discriminant",
      children: (0, import_jsx_runtime70.jsx)(schemaDiscriminant.Input, {
        autoFocus: !!autoFocus,
        value: discriminant,
        onChange,
        forceValidation
      })
    }), [autoFocus, schemaDiscriminant, discriminant, onChange, forceValidation]), (0, import_jsx_runtime70.jsx)(AddToPathProvider, {
      part: "value",
      children: (0, import_jsx_runtime70.jsx)(InnerFormValueContentFromPreviewProps, {
        forceValidation,
        ...value
      })
    })]
  });
}
function castToMemoizedInfoForSchema(val) {
  return val;
}
function getOrInsert(map6, key3, val) {
  if (!map6.has(key3)) {
    map6.set(key3, val(key3));
  }
  return map6.get(key3);
}
var childFieldData = /* @__PURE__ */ new WeakMap();
function storeChildFieldData(value) {
  let key3 = {};
  childFieldData.set(key3, value);
  return key3;
}
function getChildFieldData(props) {
  const val = childFieldData.get(props._);
  if (!val) {
    throw new Error("expected child field data to exist");
  }
  return val;
}
function createGetPreviewProps(rootSchema, rootOnChange, getChildFieldElement) {
  const memoizedInfoForSchema = castToMemoizedInfoForSchema({
    form(schema, onChange) {
      return (newVal) => onChange(() => newVal);
    },
    array(schema, onChange) {
      return {
        rawOnChange: onChange,
        inner: /* @__PURE__ */ new Map(),
        onChange(updater) {
          onChange((value) => updateValue(schema, value, updater));
        }
      };
    },
    child(schema, onChange) {
      return (newVal) => onChange(() => newVal);
    },
    conditional(schema, onChange) {
      return {
        onChange: (discriminant, value) => onChange((val) => updateValue(schema, val, {
          discriminant,
          value
        })),
        onChangeForValue: (cb) => onChange((val) => ({
          discriminant: val.discriminant,
          value: cb(val.value)
        }))
      };
    },
    object(schema, onChange) {
      return {
        onChange: (updater) => {
          onChange((value) => updateValue(schema, value, updater));
        },
        innerOnChanges: Object.fromEntries(Object.keys(schema.fields).map((key3) => {
          return [key3, (newVal) => {
            onChange((val) => ({
              ...val,
              [key3]: newVal(val[key3])
            }));
          }];
        }))
      };
    }
  });
  const previewPropsFactories = {
    form(schema, value, onChange) {
      return {
        value,
        onChange,
        schema
      };
    },
    child(schema, value, onChange, path3) {
      return {
        element: getChildFieldElement(path3),
        schema,
        _: storeChildFieldData({
          value,
          onChange
        })
      };
    },
    object(schema, value, memoized, path3, getInnerProp) {
      const fields = {};
      for (const key3 of Object.keys(schema.fields)) {
        fields[key3] = getInnerProp(schema.fields[key3], value[key3], memoized.innerOnChanges[key3], key3);
      }
      const previewProps = {
        fields,
        onChange: memoized.onChange,
        schema
      };
      return previewProps;
    },
    array(schema, value, memoized, path3, getInnerProp) {
      const arrayValue = value;
      const keys3 = getKeysForArrayValue(arrayValue);
      const unusedKeys = new Set(getKeysForArrayValue(value));
      const props = {
        elements: arrayValue.map((val, i2) => {
          const key3 = keys3[i2];
          unusedKeys.delete(key3);
          const element3 = getOrInsert(memoized.inner, key3, () => {
            const onChange = (val2) => {
              memoized.rawOnChange((prev) => {
                const keys4 = getKeysForArrayValue(prev);
                const index4 = keys4.indexOf(key3);
                const newValue = [...prev];
                newValue[index4] = val2(newValue[index4]);
                setKeysForArrayValue(newValue, keys4);
                return newValue;
              });
            };
            const element4 = getInnerProp(schema.element, val, onChange, key3);
            return {
              element: element4,
              elementWithKey: {
                ...element4,
                key: key3
              },
              onChange
            };
          });
          const currentInnerProp = getInnerProp(schema.element, val, element3.onChange, key3);
          if (element3.element !== currentInnerProp) {
            element3.element = currentInnerProp;
            element3.elementWithKey = {
              ...currentInnerProp,
              key: key3
            };
          }
          return element3.elementWithKey;
        }),
        schema,
        onChange: memoized.onChange
      };
      for (const key3 of unusedKeys) {
        memoized.inner.delete(key3);
      }
      return props;
    },
    conditional(schema, value, memoized, path3, getInnerProp) {
      const props = {
        discriminant: value.discriminant,
        onChange: memoized.onChange,
        value: getInnerProp(schema.values[value.discriminant.toString()], value.value, memoized.onChangeForValue, "value"),
        schema
      };
      return props;
    }
  };
  function getPreviewPropsForProp(schema, value, memoedThing, path3, getInnerProp) {
    return previewPropsFactories[schema.kind](schema, value, memoedThing, path3, getInnerProp);
  }
  function getInitialMemoState(schema, value, onChange, path3) {
    const innerState = /* @__PURE__ */ new Map();
    const memoizedInfo = memoizedInfoForSchema[schema.kind](schema, onChange);
    const state2 = {
      value,
      inner: innerState,
      props: getPreviewPropsForProp(schema, value, memoizedInfo, path3, (schema2, value2, onChange2, key3) => {
        const state3 = getInitialMemoState(schema2, value2, onChange2, path3.concat(key3));
        innerState.set(key3, state3);
        return state3.props;
      }),
      schema,
      cached: memoizedInfo
    };
    return state2;
  }
  function getUpToDateProps(schema, value, onChange, memoState2, path3) {
    if (memoState2.schema !== schema) {
      Object.assign(memoState2, getInitialMemoState(schema, value, onChange, path3));
      return memoState2.props;
    }
    if (memoState2.value === value) {
      return memoState2.props;
    }
    memoState2.value = value;
    const unusedKeys = new Set(memoState2.inner.keys());
    memoState2.props = getPreviewPropsForProp(schema, value, memoState2.cached, path3, (schema2, value2, onChange2, innerMemoStateKey) => {
      unusedKeys.delete(innerMemoStateKey);
      if (!memoState2.inner.has(innerMemoStateKey)) {
        const innerState = getInitialMemoState(schema2, value2, onChange2, path3.concat(innerMemoStateKey));
        memoState2.inner.set(innerMemoStateKey, innerState);
        return innerState.props;
      }
      return getUpToDateProps(schema2, value2, onChange2, memoState2.inner.get(innerMemoStateKey), path3.concat(innerMemoStateKey));
    });
    for (const key3 of unusedKeys) {
      memoState2.inner.delete(key3);
    }
    return memoState2.props;
  }
  let memoState;
  return (value) => {
    if (memoState === void 0) {
      memoState = getInitialMemoState(rootSchema, value, rootOnChange, []);
      return memoState.props;
    }
    return getUpToDateProps(rootSchema, value, rootOnChange, memoState, []);
  };
}
var previewPropsToValueConverter = {
  child(props) {
    const childFieldData2 = getChildFieldData(props);
    return childFieldData2.value;
  },
  form(props) {
    return props.value;
  },
  array(props) {
    const values3 = props.elements.map((x) => previewPropsToValue(x));
    setKeysForArrayValue(values3, props.elements.map((x) => x.key));
    return values3;
  },
  conditional(props) {
    return {
      discriminant: props.discriminant,
      value: previewPropsToValue(props.value)
    };
  },
  object(props) {
    return Object.fromEntries(Object.entries(props.fields).map(([key3, val]) => [key3, previewPropsToValue(val)]));
  }
};
function previewPropsToValue(props) {
  return previewPropsToValueConverter[props.schema.kind](props);
}
var valueToUpdaters = {
  child(value) {
    return value !== null && value !== void 0 ? value : void 0;
  },
  form(value) {
    return value;
  },
  array(value, schema) {
    const keys3 = getKeysForArrayValue(value);
    return value.map((x, i2) => ({
      key: keys3[i2],
      value: valueToUpdater(x, schema.element)
    }));
  },
  conditional(value, schema) {
    return {
      discriminant: value.discriminant,
      value: valueToUpdater(value.value, schema.values[value.discriminant.toString()])
    };
  },
  object(value, schema) {
    return Object.fromEntries(Object.entries(schema.fields).map(([key3, schema2]) => [key3, valueToUpdater(value[key3], schema2)]));
  }
};
function valueToUpdater(value, schema) {
  return valueToUpdaters[schema.kind](value, schema);
}
function setValueToPreviewProps(value, props) {
  if (isKind(props, "child")) {
    const {
      onChange
    } = getChildFieldData(props);
    onChange(value);
    return;
  }
  if (isKind(props, "form") || isKind(props, "object") || isKind(props, "array")) {
    props.onChange(valueToUpdater(value, props.schema));
    return;
  }
  if (isKind(props, "conditional")) {
    const updater = valueToUpdater(value, props.schema);
    props.onChange(updater.discriminant, updater.value);
    return;
  }
  assertNever(props);
}
function isKind(props, kind) {
  return props.schema.kind === kind;
}
function move(items, indices, toIndex) {
  toIndex -= indices.filter((index4) => index4 < toIndex).length;
  let moves = indices.map((from2) => ({
    from: from2,
    to: toIndex++
  }));
  for (let i2 = 0; i2 < moves.length; i2++) {
    let a = moves[i2].from;
    for (let j = i2; j < moves.length; j++) {
      let b = moves[j].from;
      if (b > a) {
        moves[j].from--;
      }
    }
  }
  for (let i2 = 0; i2 < moves.length; i2++) {
    let a = moves[i2];
    for (let j = moves.length - 1; j > i2; j--) {
      let b = moves[j];
      if (b.from < a.to) {
        a.to++;
      } else {
        b.from++;
      }
    }
  }
  let copy2 = items.slice();
  for (let move2 of moves) {
    let [item2] = copy2.splice(move2.from, 1);
    copy2.splice(move2.to, 0, item2);
  }
  return copy2;
}
function ArrayFieldInput(props) {
  var _props$schema$validat, _props$schema$validat2;
  const minLength = (_props$schema$validat = (_props$schema$validat2 = props.schema.validation) === null || _props$schema$validat2 === void 0 || (_props$schema$validat2 = _props$schema$validat2.length) === null || _props$schema$validat2 === void 0 ? void 0 : _props$schema$validat2.min) !== null && _props$schema$validat !== void 0 ? _props$schema$validat : 0;
  const formId = (0, import_react55.useId)();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const errorMessage = useArrayFieldValidationMessage(props);
  const {
    descriptionProps,
    errorMessageProps,
    fieldProps: groupProps,
    labelProps
  } = $2baaea4c71418dea$export$294aa081a6c6f55d({
    description: props.schema.description,
    errorMessage,
    isInvalid: !!errorMessage,
    label: props.schema.label,
    labelElementType: "span"
  });
  const [modalState, setModalState] = (0, import_react55.useState)({
    state: "closed"
  });
  return (0, import_jsx_runtime70.jsxs)(VStack, {
    gap: "medium",
    role: "group",
    minWidth: 0,
    ...groupProps,
    children: [(0, import_jsx_runtime70.jsx)(FieldLabel, {
      elementType: "span",
      isRequired: minLength > 0,
      supplementRequiredState: true,
      ...labelProps,
      children: props.schema.label
    }), props.schema.description && (0, import_jsx_runtime70.jsx)(Text, {
      size: "small",
      color: "neutralSecondary",
      ...descriptionProps,
      children: props.schema.description
    }), (0, import_jsx_runtime70.jsx)(ActionButton, {
      autoFocus: props.autoFocus,
      onPress: () => {
        setModalState({
          state: "new"
        });
      },
      alignSelf: "start",
      children: stringFormatter.format("add")
    }), (0, import_jsx_runtime70.jsx)(ArrayFieldListView, {
      ...props,
      "aria-label": props.schema.label,
      onOpenItem: (idx) => {
        setModalState({
          state: "edit",
          index: idx
        });
      }
    }), errorMessage && (0, import_jsx_runtime70.jsx)(FieldMessage, {
      ...errorMessageProps,
      children: errorMessage
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setModalState({
          state: "closed"
        });
      },
      children: (() => {
        if (props.schema.element.kind === "child") return;
        if (modalState.state === "new") {
          return (0, import_jsx_runtime70.jsx)(ArrayFieldAddItemModalContent, {
            formId,
            onClose: () => {
              setModalState({
                state: "closed"
              });
            },
            previewProps: props
          });
        }
        if (modalState.state !== "edit") return;
        return (0, import_jsx_runtime70.jsxs)(Dialog, {
          children: [(0, import_jsx_runtime70.jsx)(Heading, {
            children: "Edit item"
          }), (0, import_jsx_runtime70.jsx)(ArrayEditItemModalContent, {
            formId,
            modalStateIndex: modalState.index,
            onClose: () => {
              setModalState({
                state: "closed"
              });
            },
            previewProps: props
          }), (0, import_jsx_runtime70.jsx)(ButtonGroup, {
            children: (0, import_jsx_runtime70.jsx)(Button, {
              form: formId,
              prominence: "high",
              type: "submit",
              children: "Done"
            })
          })]
        });
      })()
    })]
  });
}
function ArrayFieldAddItemModalContent(props) {
  const [forceValidation, setForceValidation] = (0, import_react55.useState)(false);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const slugInfo = (0, import_react55.useMemo)(() => {
    if (props.previewProps.schema.slugField === void 0 || props.previewProps.schema.element.kind !== "object") {
      return;
    }
    const val = previewPropsToValue(props.previewProps);
    const schema = props.previewProps.schema.element.fields;
    const slugField = props.previewProps.schema.slugField;
    const slugs = new Set(val.map((x) => getSlugFromState({
      schema,
      slugField
    }, x)));
    return {
      slugs,
      field: slugField,
      glob: "*"
    };
  }, [props.previewProps]);
  const [value, setValue] = (0, import_react55.useState)(() => getInitialPropsValue(props.previewProps.schema.element));
  const previewProps = (0, import_react55.useMemo)(() => createGetPreviewProps(props.previewProps.schema.element, setValue, () => void 0), [props.previewProps.schema.element, setValue])(value);
  return (0, import_jsx_runtime70.jsxs)(Dialog, {
    children: [(0, import_jsx_runtime70.jsx)(Heading, {
      children: "Add item"
    }), (0, import_jsx_runtime70.jsx)(Content, {
      children: (0, import_jsx_runtime70.jsx)(VStack, {
        id: props.formId,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget) return;
          event.preventDefault();
          if (!clientSideValidateProp(props.previewProps.schema.element, value, void 0)) {
            setForceValidation(true);
            return;
          }
          props.previewProps.onChange([...props.previewProps.elements.map((x) => ({
            key: x.key
          })), {
            key: void 0,
            value: valueToUpdater(value, props.previewProps.schema.element)
          }]);
          props.onClose();
        },
        gap: "xxlarge",
        children: (0, import_jsx_runtime70.jsx)(FormValueContentFromPreviewProps, {
          slugField: slugInfo,
          autoFocus: true,
          ...previewProps,
          forceValidation
        })
      })
    }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime70.jsx)(Button, {
        onPress: () => {
          props.onClose();
        },
        children: stringFormatter.format("cancel")
      }), (0, import_jsx_runtime70.jsx)(Button, {
        form: props.formId,
        prominence: "high",
        type: "submit",
        children: stringFormatter.format("add")
      })]
    })]
  });
}
function ArrayEditItemModalContent(props) {
  const slugInfo = (0, import_react55.useMemo)(() => {
    if (props.previewProps.schema.slugField === void 0 || props.previewProps.schema.element.kind !== "object") {
      return;
    }
    const val = previewPropsToValue(props.previewProps);
    const schema = props.previewProps.schema.element.fields;
    const slugField = props.previewProps.schema.slugField;
    const slugs = new Set(val.filter((x, i2) => i2 !== props.modalStateIndex).map((x) => getSlugFromState({
      schema,
      slugField
    }, x)));
    return {
      slugs,
      field: slugField,
      glob: "*"
    };
  }, [props.previewProps, props.modalStateIndex]);
  return (0, import_jsx_runtime70.jsx)(Content, {
    children: (0, import_jsx_runtime70.jsx)(VStack, {
      id: props.formId,
      elementType: "form",
      onSubmit: (event) => {
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        props.onClose();
      },
      gap: "xxlarge",
      children: (0, import_jsx_runtime70.jsx)(FormValueContentFromPreviewProps, {
        slugField: slugInfo,
        autoFocus: true,
        ...props.previewProps.elements[props.modalStateIndex]
      })
    })
  });
}
function useArrayFieldValidationMessage(props) {
  var _schema$validation, _schema$validation2;
  const {
    elements,
    forceValidation,
    schema
  } = props;
  const minLength = (_schema$validation = schema.validation) === null || _schema$validation === void 0 || (_schema$validation = _schema$validation.length) === null || _schema$validation === void 0 ? void 0 : _schema$validation.min;
  const maxLength = (_schema$validation2 = schema.validation) === null || _schema$validation2 === void 0 || (_schema$validation2 = _schema$validation2.length) === null || _schema$validation2 === void 0 ? void 0 : _schema$validation2.max;
  return (0, import_react55.useMemo)(() => {
    if (forceValidation) {
      if (minLength && elements.length < minLength) {
        return `Must have at least ${pluralize(minLength, {
          singular: "item"
        })}.`;
      } else if (maxLength && elements.length > maxLength) {
        return `Must have at most ${pluralize(maxLength, {
          singular: "item"
        })}.`;
      }
    }
  }, [elements.length, forceValidation, maxLength, minLength]);
}
function ArrayFieldListView(props) {
  let onMove = (keys3, target) => {
    const targetIndex = props.elements.findIndex((x) => x.key === target.key);
    if (targetIndex === -1) return;
    const allKeys = props.elements.map((x) => ({
      key: x.key
    }));
    const indexToMoveTo = target.dropPosition === "before" ? targetIndex : targetIndex + 1;
    const indices = keys3.map((key3) => allKeys.findIndex((x) => x.key === key3));
    props.onChange(move(allKeys, indices, indexToMoveTo));
  };
  const dragType = (0, import_react55.useMemo)(() => Math.random().toString(36), []);
  let {
    dragAndDropHooks
  } = useDragAndDrop({
    getItems(keys3) {
      return [...keys3].map((key3) => {
        key3 = JSON.stringify(key3);
        return {
          [dragType]: key3,
          "text/plain": key3
        };
      });
    },
    getAllowedDropOperations() {
      return ["move", "cancel"];
    },
    async onDrop(e3) {
      if (e3.target.type !== "root" && e3.target.dropPosition !== "on") {
        let keys3 = [];
        for (let item2 of e3.items) {
          if (item2.kind === "text") {
            let key3;
            if (item2.types.has(dragType)) {
              key3 = JSON.parse(await item2.getText(dragType));
              keys3.push(key3);
            } else if (item2.types.has("text/plain")) {
              key3 = await item2.getText("text/plain");
              keys3 = key3.split("\n").map((val) => val.replaceAll('"', ""));
            }
          }
        }
        onMove(keys3, e3.target);
      }
    },
    getDropOperation(target) {
      if (target.type === "root" || target.dropPosition === "on") {
        return "cancel";
      }
      return "move";
    }
  });
  const onRemoveKey = useEventCallback((key3) => {
    props.onChange(props.elements.map((x) => ({
      key: x.key
    })).filter((val) => val.key !== key3));
  });
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime70.jsx)(_ListView, {
    "aria-label": props["aria-label"],
    items: props.elements,
    dragAndDropHooks,
    height: props.elements.length ? void 0 : "scale.2000",
    selectionMode: "none",
    renderEmptyState: arrayFieldEmptyState,
    onAction: (key3) => {
      const idx = props.elements.findIndex((x) => x.key === key3);
      if (idx === -1) return;
      props.onOpenItem(idx);
    },
    children: (item2) => {
      var _props$schema$itemLab, _props$schema;
      const label = ((_props$schema$itemLab = (_props$schema = props.schema).itemLabel) === null || _props$schema$itemLab === void 0 ? void 0 : _props$schema$itemLab.call(_props$schema, item2)) || `Item ${props.elements.indexOf(item2) + 1}`;
      return (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: label,
        children: [(0, import_jsx_runtime70.jsx)(Text, {
          children: label
        }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
          placement: "start",
          children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
            onPress: () => {
              onRemoveKey(item2.key);
            },
            children: (0, import_jsx_runtime70.jsx)(Icon, {
              src: trash2Icon
            })
          }), (0, import_jsx_runtime70.jsx)(Tooltip, {
            children: stringFormatter.format("delete")
          })]
        })]
      }, item2.key);
    }
  });
}
function arrayFieldEmptyState() {
  return (0, import_jsx_runtime70.jsxs)(VStack, {
    gap: "large",
    alignItems: "center",
    justifyContent: "center",
    height: "100%",
    padding: "regular",
    children: [(0, import_jsx_runtime70.jsx)(Text, {
      elementType: "h3",
      align: "center",
      color: "neutralSecondary",
      size: "large",
      weight: "medium",
      children: "Empty list"
    }), (0, import_jsx_runtime70.jsx)(Text, {
      align: "center",
      color: "neutralTertiary",
      children: "Add the first item to see it here."
    })]
  });
}
var isListType = (type) => type === "ordered-list" || type === "unordered-list";
var isListNode = (node3) => isListType(node3.type);
function getAncestorList(editor) {
  if (editor.selection) {
    const listItem2 = Editor.above(editor, {
      match: nodeTypeMatcher("list-item")
    });
    const list5 = Editor.above(editor, {
      match: isListNode
    });
    if (listItem2 && list5) {
      return {
        isInside: true,
        listItem: listItem2,
        list: list5
      };
    }
  }
  return {
    isInside: false
  };
}
function withList(editor) {
  const {
    insertBreak,
    normalizeNode,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const ancestorList = getAncestorList(editor);
      if (ancestorList.isInside && Range.isCollapsed(editor.selection) && Editor.isStart(editor, editor.selection.anchor, ancestorList.list[1])) {
        Transforms.unwrapNodes(editor, {
          match: isListNode,
          split: true
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const [listItem2] = Editor.nodes(editor, {
      match: (node3) => node3.type === "list-item",
      mode: "lowest"
    });
    if (listItem2 && Node2.string(listItem2[0]) === "") {
      Transforms.unwrapNodes(editor, {
        match: isListNode,
        split: true
      });
      return;
    }
    insertBreak();
  };
  editor.normalizeNode = (entry) => {
    const [node3, path3] = entry;
    if (Element2.isElement(node3) || Editor.isEditor(node3)) {
      const isElementBeingNormalizedAList = isListNode(node3);
      for (const [childNode, childPath] of Node2.children(editor, path3)) {
        const index4 = childPath[childPath.length - 1];
        if (isListNode(childNode)) {
          var _node$children;
          if (((_node$children = node3.children[childPath[childPath.length - 1] + 1]) === null || _node$children === void 0 ? void 0 : _node$children.type) === childNode.type) {
            const siblingNodePath = Path.next(childPath);
            moveChildren(editor, siblingNodePath, [...childPath, childNode.children.length]);
            Transforms.removeNodes(editor, {
              at: siblingNodePath
            });
            return;
          }
          if (isElementBeingNormalizedAList) {
            const previousChild = node3.children[index4 - 1];
            if (Element2.isElement(previousChild)) {
              Transforms.moveNodes(editor, {
                at: childPath,
                to: [...Path.previous(childPath), previousChild.children.length - 1]
              });
            } else {
              Transforms.unwrapNodes(editor, {
                at: childPath
              });
            }
            return;
          }
        }
        if (node3.type === "list-item" && childNode.type !== "list-item-content" && index4 === 0 && isBlock(childNode)) {
          if (path3[path3.length - 1] !== 0) {
            const previousChild = Node2.get(editor, Path.previous(path3));
            if (Element2.isElement(previousChild)) {
              Transforms.moveNodes(editor, {
                at: path3,
                to: [...Path.previous(path3), previousChild.children.length]
              });
              return;
            }
          }
          Transforms.unwrapNodes(editor, {
            at: childPath
          });
          return;
        }
        if (node3.type === "list-item" && childNode.type === "list-item-content" && index4 !== 0) {
          Transforms.splitNodes(editor, {
            at: childPath
          });
          return;
        }
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var ToolbarStateContext = import_react55.default.createContext(null);
function useToolbarState() {
  const toolbarState = (0, import_react55.useContext)(ToolbarStateContext);
  if (!toolbarState) {
    throw new Error("ToolbarStateProvider must be used to use useToolbarState");
  }
  return toolbarState;
}
var createToolbarState = (editor, componentBlocks, editorDocumentFeatures) => {
  const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) || {
    kind: "block",
    inlineMarks: "inherit",
    documentFeatures: {
      dividers: true,
      formatting: {
        alignment: {
          center: true,
          end: true
        },
        blockTypes: {
          blockquote: true,
          code: editorDocumentFeatures.formatting.blockTypes.code
        },
        headings: editorDocumentFeatures.formatting.headings,
        listTypes: {
          ordered: true,
          unordered: true
        }
      },
      layouts: editorDocumentFeatures.layouts,
      links: true,
      images: editorDocumentFeatures.images,
      tables: true
    },
    softBreaks: true,
    componentBlocks: true
  };
  let [maybeCodeBlockEntry] = Editor.nodes(editor, {
    match: (node3) => node3.type !== "code" && isBlock(node3)
  });
  const editorMarks = Editor.marks(editor) || {};
  const marks = Object.fromEntries(allMarks.map((mark) => [mark, {
    isDisabled: locationDocumentFeatures.inlineMarks !== "inherit" && !locationDocumentFeatures.inlineMarks[mark] || !maybeCodeBlockEntry,
    isSelected: !!editorMarks[mark]
  }]));
  if (editor.selection && Range.isExpanded(editor.selection)) {
    for (const node3 of Editor.nodes(editor, {
      match: Text2.isText
    })) {
      for (const key3 of Object.keys(node3[0])) {
        if (key3 === "insertMenu" || key3 === "text") {
          continue;
        }
        if (key3 in marks) {
          marks[key3].isSelected = true;
        }
      }
    }
  }
  let [headingEntry] = Editor.nodes(editor, {
    match: nodeTypeMatcher("heading")
  });
  let [listEntry] = Editor.nodes(editor, {
    match: isListNode
  });
  let [alignableEntry] = Editor.nodes(editor, {
    match: nodeTypeMatcher("paragraph", "heading")
  });
  const listTypeAbove = getListTypeAbove(editor);
  return {
    marks,
    textStyles: {
      selected: headingEntry ? headingEntry[0].level : "normal",
      allowedHeadingLevels: locationDocumentFeatures.kind === "block" && !listEntry ? locationDocumentFeatures.documentFeatures.formatting.headings.levels : []
    },
    code: {
      isSelected: isElementActive(editor, "code"),
      isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)
    },
    lists: {
      ordered: {
        isSelected: isElementActive(editor, "ordered-list") && (listTypeAbove === "none" || listTypeAbove === "ordered-list"),
        isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.listTypes.ordered && !headingEntry)
      },
      unordered: {
        isSelected: isElementActive(editor, "unordered-list") && (listTypeAbove === "none" || listTypeAbove === "unordered-list"),
        isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.listTypes.unordered && !headingEntry)
      }
    },
    alignment: {
      isDisabled: !alignableEntry && !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.alignment),
      selected: (alignableEntry === null || alignableEntry === void 0 ? void 0 : alignableEntry[0].textAlign) || "start"
    },
    blockquote: {
      isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.blockTypes.blockquote),
      isSelected: isElementActive(editor, "blockquote")
    },
    layouts: {
      isSelected: isElementActive(editor, "layout")
    },
    links: {
      isDisabled: !editor.selection || Range.isCollapsed(editor.selection) || !locationDocumentFeatures.documentFeatures.links,
      isSelected: isElementActive(editor, "link")
    },
    editor,
    dividers: {
      isDisabled: locationDocumentFeatures.kind === "inline" || !locationDocumentFeatures.documentFeatures.dividers
    },
    clearFormatting: {
      isDisabled: !(Object.values(marks).some((x) => x.isSelected) || !!hasBlockThatClearsOnClearFormatting(editor))
    },
    editorDocumentFeatures
  };
};
function hasBlockThatClearsOnClearFormatting(editor) {
  const [node3] = Editor.nodes(editor, {
    match: (node4) => node4.type === "heading" || node4.type === "code" || node4.type === "blockquote"
  });
  return !!node3;
}
function getListTypeAbove(editor) {
  const listAbove = Editor.above(editor, {
    match: isListNode
  });
  if (!listAbove) {
    return "none";
  }
  return listAbove[0].type;
}
var DocumentEditorConfigContext = (0, import_react55.createContext)(null);
function useDocumentEditorConfig() {
  const context = (0, import_react55.useContext)(DocumentEditorConfigContext);
  if (!context) {
    throw new Error("useDocumentEditorConfig must be used within a DocumentEditorConfigContext.Provider");
  }
  return context;
}
var ToolbarStateProvider = ({
  children,
  componentBlocks,
  editorDocumentFeatures
}) => {
  const editor = useSlate();
  return (0, import_jsx_runtime70.jsx)(DocumentEditorConfigContext.Provider, {
    value: (0, import_react55.useMemo)(() => ({
      componentBlocks,
      documentFeatures: editorDocumentFeatures
    }), [componentBlocks, editorDocumentFeatures]),
    children: (0, import_jsx_runtime70.jsx)(ToolbarStateContext.Provider, {
      value: createToolbarState(editor, componentBlocks, editorDocumentFeatures),
      children
    })
  });
};
globalThis.Prism = {
  manual: true
};
var _self = globalThis;
var Prism = function(_self2) {
  var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
  var uniqueId = 0;
  var plainTextGrammar = {};
  var _ = {
    /**
     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
     * additional languages or plugins yourself.
     *
     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
     *
     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.manual = true;
     * // add a new <script> to load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */
    manual: _self2.Prism && _self2.Prism.manual,
    /**
     * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
     * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
     * own worker, you don't want it to do this.
     *
     * By setting this value to `true`, Prism will not add its own listeners to the worker.
     *
     * You obviously have to change this value before Prism executes. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.disableWorkerMessageHandler = true;
     * // Load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */
    disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
    /**
     * A namespace for utility methods.
     *
     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
     * change or disappear at any time.
     *
     * @namespace
     * @memberof Prism
     */
    util: {
      encode: function encode2(tokens) {
        if (tokens instanceof Token3) {
          return new Token3(tokens.type, encode2(tokens.content), tokens.alias);
        } else if (Array.isArray(tokens)) {
          return tokens.map(encode2);
        } else {
          return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        }
      },
      /**
       * Returns the name of the type of the given value.
       *
       * @param {any} o
       * @returns {string}
       * @example
       * type(null)      === 'Null'
       * type(undefined) === 'Undefined'
       * type(123)       === 'Number'
       * type('foo')     === 'String'
       * type(true)      === 'Boolean'
       * type([1, 2])    === 'Array'
       * type({})        === 'Object'
       * type(String)    === 'Function'
       * type(/abc+/)    === 'RegExp'
       */
      type: function(o3) {
        return Object.prototype.toString.call(o3).slice(8, -1);
      },
      /**
       * Returns a unique number for the given object. Later calls will still return the same number.
       *
       * @param {Object} obj
       * @returns {number}
       */
      objId: function(obj) {
        if (!obj["__id"]) {
          Object.defineProperty(obj, "__id", {
            value: ++uniqueId
          });
        }
        return obj["__id"];
      },
      /**
       * Creates a deep clone of the given object.
       *
       * The main intended use of this function is to clone language definitions.
       *
       * @param {T} o
       * @param {Record<number, any>} [visited]
       * @returns {T}
       * @template T
       */
      clone: function deepClone(o3, visited) {
        visited = visited || {};
        var clone2;
        var id;
        switch (_.util.type(o3)) {
          case "Object":
            id = _.util.objId(o3);
            if (visited[id]) {
              return visited[id];
            }
            clone2 = /** @type {Record<string, any>} */
            {};
            visited[id] = clone2;
            for (var key3 in o3) {
              if (o3.hasOwnProperty(key3)) {
                clone2[key3] = deepClone(o3[key3], visited);
              }
            }
            return (
              /** @type {any} */
              clone2
            );
          case "Array":
            id = _.util.objId(o3);
            if (visited[id]) {
              return visited[id];
            }
            clone2 = [];
            visited[id] = clone2;
            /** @type {Array} */
            /** @type {any} */
            o3.forEach(function(v, i2) {
              clone2[i2] = deepClone(v, visited);
            });
            return (
              /** @type {any} */
              clone2
            );
          default:
            return o3;
        }
      },
      /**
       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
       *
       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
       *
       * @param {Element} element
       * @returns {string}
       */
      getLanguage: function(element3) {
        while (element3) {
          var m = lang.exec(element3.className);
          if (m) {
            return m[1].toLowerCase();
          }
          element3 = element3.parentElement;
        }
        return "none";
      },
      /**
       * Sets the Prism `language-xxxx` class of the given element.
       *
       * @param {Element} element
       * @param {string} language
       * @returns {void}
       */
      setLanguage: function(element3, language) {
        element3.className = element3.className.replace(RegExp(lang, "gi"), "");
        element3.classList.add("language-" + language);
      },
      /**
       * Returns the script element that is currently executing.
       *
       * This does __not__ work for line script element.
       *
       * @returns {HTMLScriptElement | null}
       */
      currentScript: function() {
        if (typeof document === "undefined") {
          return null;
        }
        if ("currentScript" in document && 1 < 2) {
          return (
            /** @type {any} */
            document.currentScript
          );
        }
        try {
          throw new Error();
        } catch (err) {
          var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
          if (src) {
            var scripts = document.getElementsByTagName("script");
            for (var i2 in scripts) {
              if (scripts[i2].src == src) {
                return scripts[i2];
              }
            }
          }
          return null;
        }
      },
      /**
       * Returns whether a given class is active for `element`.
       *
       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
       * given class is just the given class with a `no-` prefix.
       *
       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
       * ancestors have the given class or the negated version of it, then the default activation will be returned.
       *
       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
       * version of it, the class is considered active.
       *
       * @param {Element} element
       * @param {string} className
       * @param {boolean} [defaultActivation=false]
       * @returns {boolean}
       */
      isActive: function(element3, className, defaultActivation) {
        var no = "no-" + className;
        while (element3) {
          var classList = element3.classList;
          if (classList.contains(className)) {
            return true;
          }
          if (classList.contains(no)) {
            return false;
          }
          element3 = element3.parentElement;
        }
        return !!defaultActivation;
      }
    },
    /**
     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
     *
     * @namespace
     * @memberof Prism
     * @public
     */
    languages: {
      /**
       * The grammar for plain, unformatted text.
       */
      plain: plainTextGrammar,
      plaintext: plainTextGrammar,
      text: plainTextGrammar,
      txt: plainTextGrammar,
      /**
       * Creates a deep copy of the language with the given id and appends the given tokens.
       *
       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
       * will be overwritten at its original position.
       *
       * ## Best practices
       *
       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
       *
       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
       *
       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
       * @param {Grammar} redef The new tokens to append.
       * @returns {Grammar} The new language created.
       * @public
       * @example
       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
       *     // at its original position
       *     'comment': { ... },
       *     // CSS doesn't have a 'color' token, so this token will be appended
       *     'color': /\b(?:red|green|blue)\b/
       * });
       */
      extend: function(id, redef) {
        var lang2 = _.util.clone(_.languages[id]);
        for (var key3 in redef) {
          lang2[key3] = redef[key3];
        }
        return lang2;
      },
      /**
       * Inserts tokens _before_ another token in a language definition or any other grammar.
       *
       * ## Usage
       *
       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
       * this:
       *
       * ```js
       * Prism.languages.markup.style = {
       *     // token
       * };
       * ```
       *
       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
       * before existing tokens. For the CSS example above, you would use it like this:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'cdata', {
       *     'style': {
       *         // token
       *     }
       * });
       * ```
       *
       * ## Special cases
       *
       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
       * will be ignored.
       *
       * This behavior can be used to insert tokens after `before`:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'comment', {
       *     'comment': Prism.languages.markup.comment,
       *     // tokens after 'comment'
       * });
       * ```
       *
       * ## Limitations
       *
       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
       * deleting properties which is necessary to insert at arbitrary positions.
       *
       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
       * Instead, it will create a new object and replace all references to the target object with the new one. This
       * can be done without temporarily deleting properties, so the iteration order is well-defined.
       *
       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
       * you hold the target object in a variable, then the value of the variable will not change.
       *
       * ```js
       * var oldMarkup = Prism.languages.markup;
       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
       *
       * assert(oldMarkup !== Prism.languages.markup);
       * assert(newMarkup === Prism.languages.markup);
       * ```
       *
       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
       * object to be modified.
       * @param {string} before The key to insert before.
       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
       * object to be modified.
       *
       * Defaults to `Prism.languages`.
       * @returns {Grammar} The new grammar object.
       * @public
       */
      insertBefore: function(inside, before, insert, root2) {
        root2 = root2 || /** @type {any} */
        _.languages;
        var grammar = root2[inside];
        var ret = {};
        for (var token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }
            if (!insert.hasOwnProperty(token)) {
              ret[token] = grammar[token];
            }
          }
        }
        var old = root2[inside];
        root2[inside] = ret;
        _.languages.DFS(_.languages, function(key3, value) {
          if (value === old && key3 != inside) {
            this[key3] = ret;
          }
        });
        return ret;
      },
      // Traverse a language definition with Depth First Search
      DFS: function DFS(o3, callback, type, visited) {
        visited = visited || {};
        var objId = _.util.objId;
        for (var i2 in o3) {
          if (o3.hasOwnProperty(i2)) {
            callback.call(o3, i2, o3[i2], type || i2);
            var property = o3[i2];
            var propertyType = _.util.type(property);
            if (propertyType === "Object" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, null, visited);
            } else if (propertyType === "Array" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, i2, visited);
            }
          }
        }
      }
    },
    plugins: {},
    /**
     * This is the most high-level function in Prism’s API.
     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
     * each one of them.
     *
     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
     *
     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
     * @memberof Prism
     * @public
     */
    highlightAll: function(async, callback) {
      _.highlightAllUnder(document, async, callback);
    },
    /**
     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
     * {@link Prism.highlightElement} on each one of them.
     *
     * The following hooks will be run:
     * 1. `before-highlightall`
     * 2. `before-all-elements-highlight`
     * 3. All hooks of {@link Prism.highlightElement} for each element.
     *
     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
     * @memberof Prism
     * @public
     */
    highlightAllUnder: function(container, async, callback) {
      var env = {
        callback,
        container,
        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
      };
      _.hooks.run("before-highlightall", env);
      env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
      _.hooks.run("before-all-elements-highlight", env);
      for (var i2 = 0, element3; element3 = env.elements[i2++]; ) {
        _.highlightElement(element3, async === true, env.callback);
      }
    },
    /**
     * Highlights the code inside a single element.
     *
     * The following hooks will be run:
     * 1. `before-sanity-check`
     * 2. `before-highlight`
     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
     * 4. `before-insert`
     * 5. `after-highlight`
     * 6. `complete`
     *
     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
     * the element's language.
     *
     * @param {Element} element The element containing the code.
     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
     *
     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
     * asynchronous highlighting to work. You can build your own bundle on the
     * [Download page](https://prismjs.com/download.html).
     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
     * @memberof Prism
     * @public
     */
    highlightElement: function(element3, async, callback) {
      var language = _.util.getLanguage(element3);
      var grammar = _.languages[language];
      _.util.setLanguage(element3, language);
      var parent = element3.parentElement;
      if (parent && parent.nodeName.toLowerCase() === "pre") {
        _.util.setLanguage(parent, language);
      }
      var code4 = element3.textContent;
      var env = {
        element: element3,
        language,
        grammar,
        code: code4
      };
      function insertHighlightedCode(highlightedCode) {
        env.highlightedCode = highlightedCode;
        _.hooks.run("before-insert", env);
        env.element.innerHTML = env.highlightedCode;
        _.hooks.run("after-highlight", env);
        _.hooks.run("complete", env);
        callback && callback.call(env.element);
      }
      _.hooks.run("before-sanity-check", env);
      parent = env.element.parentElement;
      if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
        parent.setAttribute("tabindex", "0");
      }
      if (!env.code) {
        _.hooks.run("complete", env);
        callback && callback.call(env.element);
        return;
      }
      _.hooks.run("before-highlight", env);
      if (!env.grammar) {
        insertHighlightedCode(_.util.encode(env.code));
        return;
      }
      if (async && _self2.Worker) {
        var worker = new Worker(_.filename);
        worker.onmessage = function(evt) {
          insertHighlightedCode(evt.data);
        };
        worker.postMessage(JSON.stringify({
          language: env.language,
          code: env.code,
          immediateClose: true
        }));
      } else {
        insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
      }
    },
    /**
     * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
     * and the language definitions to use, and returns a string with the HTML produced.
     *
     * The following hooks will be run:
     * 1. `before-tokenize`
     * 2. `after-tokenize`
     * 3. `wrap`: On each {@link Token}.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @param {string} language The name of the language definition passed to `grammar`.
     * @returns {string} The highlighted HTML.
     * @memberof Prism
     * @public
     * @example
     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
     */
    highlight: function(text7, grammar, language) {
      var env = {
        code: text7,
        grammar,
        language
      };
      _.hooks.run("before-tokenize", env);
      if (!env.grammar) {
        throw new Error('The language "' + env.language + '" has no grammar.');
      }
      env.tokens = _.tokenize(env.code, env.grammar);
      _.hooks.run("after-tokenize", env);
      return Token3.stringify(_.util.encode(env.tokens), env.language);
    },
    /**
     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
     * and the language definitions to use, and returns an array with the tokenized code.
     *
     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
     *
     * This method could be useful in other contexts as well, as a very crude parser.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @returns {TokenStream} An array of strings and tokens, a token stream.
     * @memberof Prism
     * @public
     * @example
     * let code = `var foo = 0;`;
     * let tokens = Prism.tokenize(code, Prism.languages.javascript);
     * tokens.forEach(token => {
     *     if (token instanceof Prism.Token && token.type === 'number') {
     *         console.log(`Found numeric literal: ${token.content}`);
     *     }
     * });
     */
    tokenize: function(text7, grammar) {
      var rest = grammar.rest;
      if (rest) {
        for (var token in rest) {
          grammar[token] = rest[token];
        }
        delete grammar.rest;
      }
      var tokenList = new LinkedList();
      addAfter(tokenList, tokenList.head, text7);
      matchGrammar(text7, tokenList, grammar, tokenList.head, 0);
      return toArray(tokenList);
    },
    /**
     * @namespace
     * @memberof Prism
     * @public
     */
    hooks: {
      all: {},
      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string} name The name of the hook.
       * @param {HookCallback} callback The callback function which is given environment variables.
       * @public
       */
      add: function(name2, callback) {
        var hooks = _.hooks.all;
        hooks[name2] = hooks[name2] || [];
        hooks[name2].push(callback);
      },
      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run: function(name2, env) {
        var callbacks = _.hooks.all[name2];
        if (!callbacks || !callbacks.length) {
          return;
        }
        for (var i2 = 0, callback; callback = callbacks[i2++]; ) {
          callback(env);
        }
      }
    },
    Token: Token3
  };
  _self2.Prism = _;
  function Token3(type, content3, alias, matchedStr) {
    this.type = type;
    this.content = content3;
    this.alias = alias;
    this.length = (matchedStr || "").length | 0;
  }
  Token3.stringify = function stringify(o3, language) {
    if (typeof o3 == "string") {
      return o3;
    }
    if (Array.isArray(o3)) {
      var s2 = "";
      o3.forEach(function(e3) {
        s2 += stringify(e3, language);
      });
      return s2;
    }
    var env = {
      type: o3.type,
      content: stringify(o3.content, language),
      tag: "span",
      classes: ["token", o3.type],
      attributes: {},
      language
    };
    var aliases = o3.alias;
    if (aliases) {
      if (Array.isArray(aliases)) {
        Array.prototype.push.apply(env.classes, aliases);
      } else {
        env.classes.push(aliases);
      }
    }
    _.hooks.run("wrap", env);
    var attributes = "";
    for (var name2 in env.attributes) {
      attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
    }
    return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
  };
  function matchPattern(pattern, pos, text7, lookbehind) {
    pattern.lastIndex = pos;
    var match2 = pattern.exec(text7);
    if (match2 && lookbehind && match2[1]) {
      var lookbehindLength = match2[1].length;
      match2.index += lookbehindLength;
      match2[0] = match2[0].slice(lookbehindLength);
    }
    return match2;
  }
  function matchGrammar(text7, tokenList, grammar, startNode, startPos, rematch) {
    for (var token in grammar) {
      if (!grammar.hasOwnProperty(token) || !grammar[token]) {
        continue;
      }
      var patterns = grammar[token];
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      for (var j = 0; j < patterns.length; ++j) {
        if (rematch && rematch.cause == token + "," + j) {
          return;
        }
        var patternObj = patterns[j];
        var inside = patternObj.inside;
        var lookbehind = !!patternObj.lookbehind;
        var greedy = !!patternObj.greedy;
        var alias = patternObj.alias;
        if (greedy && !patternObj.pattern.global) {
          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
          patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
        }
        var pattern = patternObj.pattern || patternObj;
        for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
          if (rematch && pos >= rematch.reach) {
            break;
          }
          var str = currentNode.value;
          if (tokenList.length > text7.length) {
            return;
          }
          if (str instanceof Token3) {
            continue;
          }
          var removeCount = 1;
          var match2;
          if (greedy) {
            match2 = matchPattern(pattern, pos, text7, lookbehind);
            if (!match2 || match2.index >= text7.length) {
              break;
            }
            var from2 = match2.index;
            var to = match2.index + match2[0].length;
            var p = pos;
            p += currentNode.value.length;
            while (from2 >= p) {
              currentNode = currentNode.next;
              p += currentNode.value.length;
            }
            p -= currentNode.value.length;
            pos = p;
            if (currentNode.value instanceof Token3) {
              continue;
            }
            for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
              removeCount++;
              p += k.value.length;
            }
            removeCount--;
            str = text7.slice(pos, p);
            match2.index -= pos;
          } else {
            match2 = matchPattern(pattern, 0, str, lookbehind);
            if (!match2) {
              continue;
            }
          }
          var from2 = match2.index;
          var matchStr = match2[0];
          var before = str.slice(0, from2);
          var after = str.slice(from2 + matchStr.length);
          var reach = pos + str.length;
          if (rematch && reach > rematch.reach) {
            rematch.reach = reach;
          }
          var removeFrom = currentNode.prev;
          if (before) {
            removeFrom = addAfter(tokenList, removeFrom, before);
            pos += before.length;
          }
          removeRange2(tokenList, removeFrom, removeCount);
          var wrapped = new Token3(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
          currentNode = addAfter(tokenList, removeFrom, wrapped);
          if (after) {
            addAfter(tokenList, currentNode, after);
          }
          if (removeCount > 1) {
            var nestedRematch = {
              cause: token + "," + j,
              reach
            };
            matchGrammar(text7, tokenList, grammar, currentNode.prev, pos, nestedRematch);
            if (rematch && nestedRematch.reach > rematch.reach) {
              rematch.reach = nestedRematch.reach;
            }
          }
        }
      }
    }
  }
  function LinkedList() {
    var head = {
      value: null,
      prev: null,
      next: null
    };
    var tail = {
      value: null,
      prev: head,
      next: null
    };
    head.next = tail;
    this.head = head;
    this.tail = tail;
    this.length = 0;
  }
  function addAfter(list5, node3, value) {
    var next = node3.next;
    var newNode = {
      value,
      prev: node3,
      next
    };
    node3.next = newNode;
    next.prev = newNode;
    list5.length++;
    return newNode;
  }
  function removeRange2(list5, node3, count2) {
    var next = node3.next;
    for (var i2 = 0; i2 < count2 && next !== list5.tail; i2++) {
      next = next.next;
    }
    node3.next = next;
    next.prev = node3;
    list5.length -= i2;
  }
  function toArray(list5) {
    var array = [];
    var node3 = list5.head.next;
    while (node3 !== list5.tail) {
      array.push(node3.value);
      node3 = node3.next;
    }
    return array;
  }
  if (!_self2.document) {
    if (!_self2.addEventListener) {
      return _;
    }
    if (!_.disableWorkerMessageHandler) {
      _self2.addEventListener("message", function(evt) {
        var message = JSON.parse(evt.data);
        var lang2 = message.language;
        var code4 = message.code;
        var immediateClose = message.immediateClose;
        _self2.postMessage(_.highlight(code4, _.languages[lang2], lang2));
        if (immediateClose) {
          _self2.close();
        }
      }, false);
    }
    return _;
  }
  var script = _.util.currentScript();
  if (script) {
    _.filename = script.src;
    if (script.hasAttribute("data-manual")) {
      _.manual = true;
    }
  }
  function highlightAutomaticallyCallback() {
    if (!_.manual) {
      _.highlightAll();
    }
  }
  if (!_.manual) {
    var readyState = document.readyState;
    if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
      document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
    } else {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(highlightAutomaticallyCallback);
      } else {
        window.setTimeout(highlightAutomaticallyCallback, 16);
      }
    }
  }
  return _;
}(_self);
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, {
            pattern: /^(\s*)["']|["']$/,
            lookbehind: true
          }]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName3, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName3] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName3;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism2) {
  var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string3.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string3.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string3,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
Prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [Prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }
  var LOADING_MESSAGE = "Loading…";
  var FAILURE_MESSAGE = function(status, message) {
    return "✖ Error " + status + " while fetching file: " + message;
  };
  var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
  var EXTENSIONS = {
    "js": "javascript",
    "py": "python",
    "rb": "ruby",
    "ps1": "powershell",
    "psm1": "powershell",
    "sh": "bash",
    "bat": "batch",
    "h": "c",
    "tex": "latex"
  };
  var STATUS_ATTR = "data-src-status";
  var STATUS_LOADING = "loading";
  var STATUS_LOADED = "loaded";
  var STATUS_FAILED = "failed";
  var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
  function loadFile(src, success, error3) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", src, true);
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) {
        if (xhr.status < 400 && xhr.responseText) {
          success(xhr.responseText);
        } else {
          if (xhr.status >= 400) {
            error3(FAILURE_MESSAGE(xhr.status, xhr.statusText));
          } else {
            error3(FAILURE_EMPTY_MESSAGE);
          }
        }
      }
    };
    xhr.send(null);
  }
  function parseRange(range) {
    var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
    if (m) {
      var start2 = Number(m[1]);
      var comma = m[2];
      var end = m[3];
      if (!comma) {
        return [start2, start2];
      }
      if (!end) {
        return [start2, void 0];
      }
      return [start2, Number(end)];
    }
    return void 0;
  }
  Prism.hooks.add("before-highlightall", function(env) {
    env.selector += ", " + SELECTOR;
  });
  Prism.hooks.add("before-sanity-check", function(env) {
    var pre = (
      /** @type {HTMLPreElement} */
      env.element
    );
    if (pre.matches(SELECTOR)) {
      env.code = "";
      pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
      var code4 = pre.appendChild(document.createElement("CODE"));
      code4.textContent = LOADING_MESSAGE;
      var src = pre.getAttribute("data-src");
      var language = env.language;
      if (language === "none") {
        var extension2 = (/\.(\w+)$/.exec(src) || [, "none"])[1];
        language = EXTENSIONS[extension2] || extension2;
      }
      Prism.util.setLanguage(code4, language);
      Prism.util.setLanguage(pre, language);
      var autoloader = Prism.plugins.autoloader;
      if (autoloader) {
        autoloader.loadLanguages(language);
      }
      loadFile(src, function(text7) {
        pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
        var range = parseRange(pre.getAttribute("data-range"));
        if (range) {
          var lines = text7.split(/\r\n?|\n/g);
          var start2 = range[0];
          var end = range[1] == null ? lines.length : range[1];
          if (start2 < 0) {
            start2 += lines.length;
          }
          start2 = Math.max(0, Math.min(start2 - 1, lines.length));
          if (end < 0) {
            end += lines.length;
          }
          end = Math.max(0, Math.min(end, lines.length));
          text7 = lines.slice(start2, end).join("\n");
          if (!pre.hasAttribute("data-start")) {
            pre.setAttribute("data-start", String(start2 + 1));
          }
        }
        code4.textContent = text7;
        Prism.highlightElement(code4);
      }, function(error3) {
        pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
        code4.textContent = error3;
      });
    }
  });
  Prism.plugins.fileHighlight = {
    /**
     * Executes the File Highlight plugin for all matching `pre` elements under the given container.
     *
     * Note: Elements which are already loaded or currently loading will not be touched by this method.
     *
     * @param {ParentNode} [container=document]
     */
    highlight: function highlight(container) {
      var elements = (container || document).querySelectorAll(SELECTOR);
      for (var i2 = 0, element3; element3 = elements[i2++]; ) {
        Prism.highlightElement(element3);
      }
    }
  };
  var logged = false;
  Prism.fileHighlight = function() {
    if (!logged) {
      console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
      logged = true;
    }
    Prism.plugins.fileHighlight.highlight.apply(this, arguments);
  };
})();
Prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [{
        // highlight the path of the include statement as a string
        pattern: /^(#\s*include\s*)<[^>]+>/,
        lookbehind: true
      }, Prism.languages.c["string"]],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [{
        pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
        lookbehind: true
      }, {
        pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
        lookbehind: true,
        alias: "function"
      }],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + // header-name
      /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
      /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
        return modName;
      }) + ")"),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);
Prism.languages.arduino = Prism.languages.extend("cpp", {
  "keyword": /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
  "constant": /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
  "builtin": /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
});
Prism.languages.ino = Prism.languages.arduino;
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [{
            pattern: /(^\$\(\([\s\S]+)\)\)/,
            lookbehind: true
          }, /^\$\(\(/],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "parameter", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
  var inside = insideString.variable[1].inside;
  for (var i2 = 0; i2 < toBeCopied.length; i2++) {
    inside[toBeCopied[i2]] = Prism2.languages.bash[toBeCopied[i2]];
  }
  Prism2.languages.sh = Prism2.languages.bash;
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);
(function(Prism2) {
  function replace3(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m, index4) {
      return "(?:" + replacements[+index4] + ")";
    });
  }
  function re(pattern, replacements, flags) {
    return RegExp(replace3(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i2 = 0; i2 < depthLog2; i2++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    // keywords which represent a return or variable type
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    // keywords which are used to declare a type
    typeDeclaration: "class enum interface record struct",
    // contextual keywords
    // ("var" and "dynamic" are missing because they are used like types)
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    // all other keywords
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords2 = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name2 = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace3(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
  var identifier2 = replace3(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace3(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier2, array]);
  var tupleElement = replace3(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
  var tuple = replace3(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace3(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier2, array]);
  var typeInside = {
    "keyword": keywords2,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism2.languages.csharp = Prism2.languages.extend("clike", {
    "string": [{
      pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
      lookbehind: true,
      greedy: true
    }, {
      pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
      lookbehind: true,
      greedy: true
    }],
    "class-name": [{
      // Using static
      // using static System.Math;
      pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier2]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (type)
      // using Project = PC.MyCompany.Project;
      pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name2, typeExpression]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (alias)
      // using Project = PC.MyCompany.Project;
      pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
      lookbehind: true
    }, {
      // Type declarations
      // class Foo<A, B>
      // interface Foo<out A, B>
      pattern: re(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Single catch exception declaration
      // catch(Foo)
      // (things like catch(Foo e) is covered by variable declaration)
      pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier2]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Name of the type parameter of generic constraints
      // where Foo : class
      pattern: re(/(\bwhere\s+)<<0>>/.source, [name2]),
      lookbehind: true
    }, {
      // Casts and checks via as and is.
      // as Foo<A>, is Bar<B>
      // (things like if(a is Foo b) is covered by variable declaration)
      pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Variable, field and parameter declaration
      // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
      pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name2]),
      inside: typeInside
    }],
    "keyword": keywords2,
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism2.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism2.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      // namespace Foo.Bar {}
      // using Foo.Bar;
      pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name2]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      // default(Foo), typeof(Foo<Bar>), sizeof(int)
      pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
      // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
      // int Foo => 0; int Foo { get; set } = 0;
      pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier2]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      // new List<Foo<Bar[]>> { }
      pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    /*'explicit-implementation': {
    	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
    	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
    	inside: classNameInside,
    	alias: 'class-name'
    },*/
    "generic-method": {
      // foo<Bar>()
      pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
      inside: {
        "function": re(/^<<0>>/.source, [name2]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      // The list of types inherited or of generic constraints
      // class Foo<F> : Bar, IList<FooBar>
      // where F : Bar, IList<int>
      pattern: re(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [typeDeclarationKeywords, genericName, name2, typeExpression, keywords2.source, nestedRound, /\bnew\s*\(\s*\)/.source]),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.csharp
        },
        "keyword": keywords2,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        // highlight preprocessor directives as keywords
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character;
  var regularStringCharacterOrComment = replace3(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace3(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace3(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier2, roundExpression]);
  Prism2.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      // Attributes
      // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
      pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism2.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier2),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace3(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace3(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace3(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace3(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism2.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism2.languages.insertBefore("csharp", "string", {
    "interpolation-string": [{
      pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(mInterpolation, mInterpolationRound)
    }, {
      pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(sInterpolation, sInterpolationRound)
    }],
    "char": {
      pattern: RegExp(character),
      greedy: true
    }
  });
  Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
})(Prism);
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, {
            pattern: /^(\s*)["']|["']$/,
            lookbehind: true
          }]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined2(tagName3, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName3] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName3;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism2) {
  var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string3.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string3.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string3,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
(function(Prism2) {
  Prism2.languages.diff = {
    "coord": [
      // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
      /^(?:\*{3}|-{3}|\+{3}).*$/m,
      // Match "@@ ... @@" coord lines in unified diff.
      /^@@.*@@$/m,
      // Match coord lines in normal diff (starts with a number).
      /^\d.*$/m
    ]
    // deleted, inserted, unchanged, diff
  };
  var PREFIXES = {
    "deleted-sign": "-",
    "deleted-arrow": "<",
    "inserted-sign": "+",
    "inserted-arrow": ">",
    "unchanged": " ",
    "diff": "!"
  };
  Object.keys(PREFIXES).forEach(function(name2) {
    var prefix = PREFIXES[name2];
    var alias = [];
    if (!/^\w+$/.test(name2)) {
      alias.push(/\w+/.exec(name2)[0]);
    }
    if (name2 === "diff") {
      alias.push("bold");
    }
    Prism2.languages.diff[name2] = {
      pattern: RegExp("^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
      alias,
      inside: {
        "line": {
          pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
          lookbehind: true
        },
        "prefix": {
          pattern: /[\s\S]/,
          alias: /\w+/.exec(name2)[0]
        }
      }
    };
  });
  Object.defineProperty(Prism2.languages.diff, "PREFIXES", {
    value: PREFIXES
  });
})(Prism);
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];
Prism.languages.ini = {
  /**
   * The component mimics the behavior of the Win32 API parser.
   *
   * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
   */
  "comment": {
    pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
    lookbehind: true
  },
  "section": {
    pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
    lookbehind: true,
    inside: {
      "section-name": {
        pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
        lookbehind: true,
        alias: "selector"
      },
      "punctuation": /\[|\]/
    }
  },
  "key": {
    pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
    lookbehind: true,
    alias: "attr-name"
  },
  "value": {
    pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
    lookbehind: true,
    alias: "attr-value",
    inside: {
      "inner-value": {
        pattern: /^("|').+(?=\1$)/,
        lookbehind: true
      }
    }
  },
  "punctuation": /=/
};
(function(Prism2) {
  var keywords2 = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [className, {
      // variables, parameters, and constructor references
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
      lookbehind: true,
      inside: className.inside
    }, {
      // class names based on keyword
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
      lookbehind: true,
      inside: className.inside
    }],
    "keyword": keywords2,
    "function": [Prism2.languages.clike.function, {
      pattern: /(::\s*)[a-z_]\w*/,
      lookbehind: true
    }],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords2,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [{
      pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
      lookbehind: true,
      inside: {
        "namespace": className.inside.namespace,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }, {
      pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
      lookbehind: true,
      alias: "static",
      inside: {
        "namespace": className.inside.namespace,
        "static": /\b\w+$/,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }],
    "namespace": {
      pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
        return keywords2.source;
      })),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);
(function(Prism2) {
  var specialEscape = {
    pattern: /\\[\\(){}[\]^$+*?|.]/,
    alias: "escape"
  };
  var escape3 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
  var charSet = {
    pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
    alias: "class-name"
  };
  var charSetWithoutDot = {
    pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
    alias: "class-name"
  };
  var rangeChar = "(?:[^\\\\-]|" + escape3.source + ")";
  var range = RegExp(rangeChar + "-" + rangeChar);
  var groupName = {
    pattern: /(<|')[^<>']+(?=[>']$)/,
    lookbehind: true,
    alias: "variable"
  };
  Prism2.languages.regex = {
    "char-class": {
      pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
      lookbehind: true,
      inside: {
        "char-class-negation": {
          pattern: /(^\[)\^/,
          lookbehind: true,
          alias: "operator"
        },
        "char-class-punctuation": {
          pattern: /^\[|\]$/,
          alias: "punctuation"
        },
        "range": {
          pattern: range,
          inside: {
            "escape": escape3,
            "range-punctuation": {
              pattern: /-/,
              alias: "operator"
            }
          }
        },
        "special-escape": specialEscape,
        "char-set": charSetWithoutDot,
        "escape": escape3
      }
    },
    "special-escape": specialEscape,
    "char-set": charSet,
    "backreference": [{
      // a backreference which is not an octal escape
      pattern: /\\(?![123][0-7]{2})[1-9]/,
      alias: "keyword"
    }, {
      pattern: /\\k<[^<>']+>/,
      alias: "keyword",
      inside: {
        "group-name": groupName
      }
    }],
    "anchor": {
      pattern: /[$^]|\\[ABbGZz]/,
      alias: "function"
    },
    "escape": escape3,
    "group": [{
      // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
      // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
      // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
      pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
      alias: "punctuation",
      inside: {
        "group-name": groupName
      }
    }, {
      pattern: /\)/,
      alias: "punctuation"
    }],
    "quantifier": {
      pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
      alias: "number"
    },
    "alternation": {
      pattern: /\|/,
      alias: "keyword"
    }
  };
})(Prism);
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [Prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function(Prism2) {
  var javascript = Prism2.util.clone(Prism2.languages.javascript);
  var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
  var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
  var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function re(source, flags) {
    source = source.replace(/<S>/g, function() {
      return space;
    }).replace(/<BRACES>/g, function() {
      return braces;
    }).replace(/<SPREAD>/g, function() {
      return spread;
    });
    return RegExp(source, flags);
  }
  spread = re(spread).source;
  Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
  Prism2.languages.jsx.tag.pattern = re(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
  Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
  Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
  Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
  Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
  Prism2.languages.insertBefore("inside", "attr-name", {
    "spread": {
      pattern: re(/<SPREAD>/.source),
      inside: Prism2.languages.jsx
    }
  }, Prism2.languages.jsx.tag);
  Prism2.languages.insertBefore("inside", "special-attr", {
    "script": {
      // Allow for two levels of nesting
      pattern: re(/=<BRACES>/.source),
      alias: "language-javascript",
      inside: {
        "script-punctuation": {
          pattern: /^=(?=\{)/,
          alias: "punctuation"
        },
        rest: Prism2.languages.jsx
      }
    }
  }, Prism2.languages.jsx.tag);
  var stringifyToken = function(token) {
    if (!token) {
      return "";
    }
    if (typeof token === "string") {
      return token;
    }
    if (typeof token.content === "string") {
      return token.content;
    }
    return token.content.map(stringifyToken).join("");
  };
  var walkTokens = function(tokens) {
    var openedTags = [];
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      var notTagNorBrace = false;
      if (typeof token !== "string") {
        if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
          if (token.content[0].content[0].content === "</") {
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
              openedTags.pop();
            }
          } else {
            if (token.content[token.content.length - 1].content === "/>") ;
            else {
              openedTags.push({
                tagName: stringifyToken(token.content[0].content[1]),
                openedBraces: 0
              });
            }
          }
        } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
          openedTags[openedTags.length - 1].openedBraces++;
        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
          openedTags[openedTags.length - 1].openedBraces--;
        } else {
          notTagNorBrace = true;
        }
      }
      if (notTagNorBrace || typeof token === "string") {
        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
          var plainText = stringifyToken(token);
          if (i2 < tokens.length - 1 && (typeof tokens[i2 + 1] === "string" || tokens[i2 + 1].type === "plain-text")) {
            plainText += stringifyToken(tokens[i2 + 1]);
            tokens.splice(i2 + 1, 1);
          }
          if (i2 > 0 && (typeof tokens[i2 - 1] === "string" || tokens[i2 - 1].type === "plain-text")) {
            plainText = stringifyToken(tokens[i2 - 1]) + plainText;
            tokens.splice(i2 - 1, 1);
            i2--;
          }
          tokens[i2] = new Prism2.Token("plain-text", plainText, null, plainText);
        }
      }
      if (token.content && typeof token.content !== "string") {
        walkTokens(token.content);
      }
    }
  };
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "jsx" && env.language !== "tsx") {
      return;
    }
    walkTokens(env.tokens);
  });
})(Prism);
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism2) {
  Prism2.languages.kotlin = Prism2.languages.extend("clike", {
    "keyword": {
      // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
      pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
      lookbehind: true
    },
    "function": [{
      pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
      greedy: true
    }, {
      pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
      lookbehind: true,
      greedy: true
    }],
    "number": /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
    "operator": /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
  });
  delete Prism2.languages.kotlin["class-name"];
  var interpolationInside = {
    "interpolation-punctuation": {
      pattern: /^\$\{?|\}$/,
      alias: "punctuation"
    },
    "expression": {
      pattern: /[\s\S]+/,
      inside: Prism2.languages.kotlin
    }
  };
  Prism2.languages.insertBefore("kotlin", "string", {
    // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
    "string-literal": [{
      pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
      alias: "multiline",
      inside: {
        "interpolation": {
          pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
          inside: interpolationInside
        },
        "string": /[\s\S]+/
      }
    }, {
      pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
      alias: "singleline",
      inside: {
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
          lookbehind: true,
          inside: interpolationInside
        },
        "string": /[\s\S]+/
      }
    }],
    "char": {
      // https://kotlinlang.org/spec/expressions.html#character-literals
      pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
      greedy: true
    }
  });
  delete Prism2.languages.kotlin["string"];
  Prism2.languages.insertBefore("kotlin", "keyword", {
    "annotation": {
      pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
      alias: "builtin"
    }
  });
  Prism2.languages.insertBefore("kotlin", "function", {
    "label": {
      pattern: /\b\w+@|@\w+\b/,
      alias: "symbol"
    }
  });
  Prism2.languages.kt = Prism2.languages.kotlin;
  Prism2.languages.kts = Prism2.languages.kotlin;
})(Prism);
Prism.languages.less = Prism.languages.extend("css", {
  "comment": [/\/\*[\s\S]*?\*\//, {
    pattern: /(^|[^\\])\/\/.*/,
    lookbehind: true
  }],
  "atrule": {
    pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      "punctuation": /[:()]/
    }
  },
  // selectors and mixins are considered the same
  "selector": {
    pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      // mixin parameters
      "variable": /@+[\w-]+/
    }
  },
  "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
  "operator": /[+\-*\/]/
});
Prism.languages.insertBefore("less", "property", {
  "variable": [
    // Variable declaration (the colon must be consumed!)
    {
      pattern: /@[\w-]+\s*:/,
      inside: {
        "punctuation": /:/
      }
    },
    // Variable usage
    /@@?[\w-]+/
  ],
  "mixin-usage": {
    pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
    lookbehind: true,
    alias: "function"
  }
});
Prism.languages.lua = {
  "comment": /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
  // \z may be used to skip the following space
  "string": {
    pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
    greedy: true
  },
  "number": /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
  "keyword": /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
  "function": /(?!\d)\w+(?=\s*(?:[({]))/,
  "operator": [/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/, {
    // Match ".." but don't break "..."
    pattern: /(^|[^.])\.\.(?!\.)/,
    lookbehind: true
  }],
  "punctuation": /[\[\](){},;]|\.+|:+/
};
Prism.languages.makefile = {
  "comment": {
    pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
    lookbehind: true
  },
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "builtin-target": {
    pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
    alias: "builtin"
  },
  "target": {
    pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
    alias: "symbol",
    inside: {
      "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
    }
  },
  "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
  // Directives
  "keyword": /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
  "function": {
    pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
    lookbehind: true
  },
  "operator": /(?:::|[?:+!])?=|[|@]/,
  "punctuation": /[:;(){}]/
};
(function(Prism2) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string3 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism2.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string3 + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string3),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism2.languages.yml = Prism2.languages.yaml;
})(Prism);
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [{
      // Prefixed by 4 spaces or 1 tab and preceded by an empty line
      pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
      lookbehind: true,
      alias: "keyword"
    }, {
      // ```optional language
      // code block
      // ```
      pattern: /^```[\s\S]*?^```$/m,
      greedy: true,
      inside: {
        "code-block": {
          pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
          lookbehind: true
        },
        "code-language": {
          pattern: /^(```).+/,
          lookbehind: true
        },
        "punctuation": /```/
      }
    }],
    "title": [{
      // title 1
      // =======
      // title 2
      // -------
      pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
      alias: "important",
      inside: {
        punctuation: /==+$|--+$/
      }
    }, {
      // # title 1
      // ###### title 6
      pattern: /(^\s*)#.+/m,
      lookbehind: true,
      alias: "important",
      inside: {
        punctuation: /^#+|#+$/
      }
    }],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token !== inside) {
        Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
        var token = tokens[i2];
        if (token.type !== "code") {
          walkTokens(token.content);
          continue;
        }
        var codeLang = token.content[1];
        var codeBlock = token.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i2 = 0, l2 = env.classes.length; i2 < l2; i2++) {
      var cls = env.classes[i2];
      var match2 = /language-(.+)/.exec(cls);
      if (match2) {
        codeLang = match2[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  function textContent(html2) {
    var text7 = html2.replace(tagPattern, "");
    text7 = text7.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code4) {
      code4 = code4.toLowerCase();
      if (code4[0] === "#") {
        var value;
        if (code4[1] === "x") {
          value = parseInt(code4.slice(2), 16);
        } else {
          value = Number(code4.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code4];
        if (known) {
          return known;
        }
        return m;
      }
    });
    return text7;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
(function(Prism2) {
  var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
  Prism2.languages.perl = {
    "comment": [{
      // POD
      pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
      lookbehind: true,
      greedy: true
    }, {
      pattern: /(^|[^\\$])#.*/,
      lookbehind: true,
      greedy: true
    }],
    // TODO Could be nice to handle Heredoc too.
    "string": [
      {
        pattern: RegExp(/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // q/.../
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
          // q a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // q(...)
          // q{...}
          // q[...]
          // q<...>
          brackets
        ].join("|") + ")"),
        greedy: true
      },
      // "...", `...`
      {
        pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
        greedy: true
      },
      // '...'
      // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
      {
        pattern: /'(?:[^'\\\r\n]|\\.)*'/,
        greedy: true
      }
    ],
    "regex": [
      {
        pattern: RegExp(/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // m/.../
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
          // m a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // m(...)
          // m{...}
          // m[...]
          // m<...>
          brackets
        ].join("|") + ")" + /[msixpodualngc]*/.source),
        greedy: true
      },
      // The lookbehinds prevent -s from breaking
      {
        pattern: RegExp(/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // s/.../.../
          // eslint-disable-next-line regexp/strict
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // s a...a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
          // s(...)(...)
          // s{...}{...}
          // s[...][...]
          // s<...><...>
          // s(...)[...]
          brackets + /\s*/.source + brackets
        ].join("|") + ")" + /[msixpodualngcer]*/.source),
        lookbehind: true,
        greedy: true
      },
      // /.../
      // The look-ahead tries to prevent two divisions on
      // the same line from being highlighted as regex.
      // This does not support multi-line regex.
      {
        pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
        greedy: true
      }
    ],
    // FIXME Not sure about the handling of ::, ', and #
    "variable": [
      // ${^POSTMATCH}
      /[&*$@%]\{\^[A-Z]+\}/,
      // $^V
      /[&*$@%]\^[A-Z_]/,
      // ${...}
      /[&*$@%]#?(?=\{)/,
      // $foo
      /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
      // $1
      /[&*$@%]\d+/,
      // $_, @_, %!
      // The negative lookahead prevents from breaking the %= operator
      /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
    ],
    "filehandle": {
      // <>, <FOO>, _
      pattern: /<(?![<=])\S*?>|\b_\b/,
      alias: "symbol"
    },
    "v-string": {
      // v1.2, 1.2.3
      pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
      alias: "string"
    },
    "function": {
      pattern: /(\bsub[ \t]+)\w+/,
      lookbehind: true
    },
    "keyword": /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
    "operator": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
    "punctuation": /[{}[\];(),:]/
  };
})(Prism);
(function(Prism2) {
  function getPlaceholder(language, index4) {
    return "___" + language.toUpperCase() + index4 + "___";
  }
  Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
    buildPlaceholders: {
      /**
       * Tokenize all inline templating expressions matching `placeholderPattern`.
       *
       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
       * `true` will be replaced.
       *
       * @param {object} env The environment of the `before-tokenize` hook.
       * @param {string} language The language id.
       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
       * @param {(match: string) => boolean} [replaceFilter]
       */
      value: function(env, language, placeholderPattern, replaceFilter) {
        if (env.language !== language) {
          return;
        }
        var tokenStack = env.tokenStack = [];
        env.code = env.code.replace(placeholderPattern, function(match2) {
          if (typeof replaceFilter === "function" && !replaceFilter(match2)) {
            return match2;
          }
          var i2 = tokenStack.length;
          var placeholder;
          while (env.code.indexOf(placeholder = getPlaceholder(language, i2)) !== -1) {
            ++i2;
          }
          tokenStack[i2] = match2;
          return placeholder;
        });
        env.grammar = Prism2.languages.markup;
      }
    },
    tokenizePlaceholders: {
      /**
       * Replace placeholders with proper tokens after tokenizing.
       *
       * @param {object} env The environment of the `after-tokenize` hook.
       * @param {string} language The language id.
       */
      value: function(env, language) {
        if (env.language !== language || !env.tokenStack) {
          return;
        }
        env.grammar = Prism2.languages[language];
        var j = 0;
        var keys3 = Object.keys(env.tokenStack);
        function walkTokens(tokens) {
          for (var i2 = 0; i2 < tokens.length; i2++) {
            if (j >= keys3.length) {
              break;
            }
            var token = tokens[i2];
            if (typeof token === "string" || token.content && typeof token.content === "string") {
              var k = keys3[j];
              var t2 = env.tokenStack[k];
              var s2 = typeof token === "string" ? token : token.content;
              var placeholder = getPlaceholder(language, k);
              var index4 = s2.indexOf(placeholder);
              if (index4 > -1) {
                ++j;
                var before = s2.substring(0, index4);
                var middle = new Prism2.Token(language, Prism2.tokenize(t2, env.grammar), "language-" + language, t2);
                var after = s2.substring(index4 + placeholder.length);
                var replacement = [];
                if (before) {
                  replacement.push.apply(replacement, walkTokens([before]));
                }
                replacement.push(middle);
                if (after) {
                  replacement.push.apply(replacement, walkTokens([after]));
                }
                if (typeof token === "string") {
                  tokens.splice.apply(tokens, [i2, 1].concat(replacement));
                } else {
                  token.content = replacement;
                }
              }
            } else if (token.content) {
              walkTokens(token.content);
            }
          }
          return tokens;
        }
        walkTokens(env.tokens);
      }
    }
  });
})(Prism);
(function(Prism2) {
  var comment2 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
  var constant = [{
    pattern: /\b(?:false|true)\b/i,
    alias: "boolean"
  }, {
    pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
    greedy: true,
    lookbehind: true
  }, {
    pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
    greedy: true,
    lookbehind: true
  }, /\b(?:null)\b/i, /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/];
  var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
  var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
  var punctuation = /[{}\[\](),:;]/;
  Prism2.languages.php = {
    "delimiter": {
      pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
      alias: "important"
    },
    "comment": comment2,
    "variable": /\$+(?:\w+\b|(?=\{))/,
    "package": {
      pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "class-name-definition": {
      pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
      lookbehind: true,
      alias: "class-name"
    },
    "function-definition": {
      pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
      lookbehind: true,
      alias: "function"
    },
    "keyword": [
      {
        pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
        alias: "type-casting",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
        alias: "type-declaration",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:parent|self|static)(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      {
        // yield from
        pattern: /(\byield\s+)from\b/i,
        lookbehind: true
      },
      // `class` is always a keyword unlike other keywords
      /\bclass\b/i,
      {
        // https://www.php.net/manual/en/reserved.keywords.php
        //
        // keywords cannot be preceded by "->"
        // the complex lookbehind means `(?<!(?:->|::)\s*)`
        pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
        lookbehind: true
      }
    ],
    "argument-name": {
      pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
      lookbehind: true
    },
    "class-name": [{
      pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
      greedy: true,
      lookbehind: true
    }, {
      pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
      greedy: true,
      lookbehind: true
    }, {
      pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
      greedy: true
    }, {
      pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /\b[a-z_]\w*(?=\s*\$)/i,
      alias: "type-declaration",
      greedy: true
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
      alias: ["class-name-fully-qualified", "type-declaration"],
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /\b[a-z_]\w*(?=\s*::)/i,
      alias: "static-context",
      greedy: true
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
      alias: ["class-name-fully-qualified", "static-context"],
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
      alias: "type-hint",
      greedy: true,
      lookbehind: true
    }, {
      pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
      alias: ["class-name-fully-qualified", "type-hint"],
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
      alias: "return-type",
      greedy: true,
      lookbehind: true
    }, {
      pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      alias: ["class-name-fully-qualified", "return-type"],
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }],
    "constant": constant,
    "function": {
      pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "property": {
      pattern: /(->\s*)\w+/,
      lookbehind: true
    },
    "number": number,
    "operator": operator,
    "punctuation": punctuation
  };
  var string_interpolation = {
    pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
    lookbehind: true,
    inside: Prism2.languages.php
  };
  var string3 = [{
    pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
    alias: "nowdoc-string",
    greedy: true,
    inside: {
      "delimiter": {
        pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
        alias: "symbol",
        inside: {
          "punctuation": /^<<<'?|[';]$/
        }
      }
    }
  }, {
    pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
    alias: "heredoc-string",
    greedy: true,
    inside: {
      "delimiter": {
        pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
        alias: "symbol",
        inside: {
          "punctuation": /^<<<"?|[";]$/
        }
      },
      "interpolation": string_interpolation
    }
  }, {
    pattern: /`(?:\\[\s\S]|[^\\`])*`/,
    alias: "backtick-quoted-string",
    greedy: true
  }, {
    pattern: /'(?:\\[\s\S]|[^\\'])*'/,
    alias: "single-quoted-string",
    greedy: true
  }, {
    pattern: /"(?:\\[\s\S]|[^\\"])*"/,
    alias: "double-quoted-string",
    greedy: true,
    inside: {
      "interpolation": string_interpolation
    }
  }];
  Prism2.languages.insertBefore("php", "variable", {
    "string": string3,
    "attribute": {
      pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
      greedy: true,
      inside: {
        "attribute-content": {
          pattern: /^(#\[)[\s\S]+(?=\]$)/,
          lookbehind: true,
          // inside can appear subset of php
          inside: {
            "comment": comment2,
            "string": string3,
            "attribute-class-name": [{
              pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
              alias: "class-name",
              greedy: true,
              lookbehind: true
            }, {
              pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
              alias: ["class-name", "class-name-fully-qualified"],
              greedy: true,
              lookbehind: true,
              inside: {
                "punctuation": /\\/
              }
            }],
            "constant": constant,
            "number": number,
            "operator": operator,
            "punctuation": punctuation
          }
        },
        "delimiter": {
          pattern: /^#\[|\]$/,
          alias: "punctuation"
        }
      }
    }
  });
  Prism2.hooks.add("before-tokenize", function(env) {
    if (!/<\?/.test(env.code)) {
      return;
    }
    var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
    Prism2.languages["markup-templating"].buildPlaceholders(env, "php", phpPattern);
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    Prism2.languages["markup-templating"].tokenizePlaceholders(env, "php");
  });
})(Prism);
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
Prism.languages.r = {
  "comment": /#.*/,
  "string": {
    pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "percent-operator": {
    // Includes user-defined operators
    // and %%, %*%, %/%, %in%, %o%, %x%
    pattern: /%[^%\s]*%/,
    alias: "operator"
  },
  "boolean": /\b(?:FALSE|TRUE)\b/,
  "ellipsis": /\.\.(?:\.|\d+)/,
  "number": [/\b(?:Inf|NaN)\b/, /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/],
  "keyword": /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
  "operator": /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
  "punctuation": /[(){}\[\],;]/
};
(function(Prism2) {
  Prism2.languages.ruby = Prism2.languages.extend("clike", {
    "comment": {
      pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
    "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
    "punctuation": /[(){}[\].,;]/
  });
  Prism2.languages.insertBefore("ruby", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  var interpolation = {
    pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
    lookbehind: true,
    inside: {
      "content": {
        pattern: /^(#\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: Prism2.languages.ruby
      },
      "delimiter": {
        pattern: /^#\{|\}$/,
        alias: "punctuation"
      }
    }
  };
  delete Prism2.languages.ruby.function;
  var percentExpression = "(?:" + [/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source, /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source, /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source].join("|") + ")";
  var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
  Prism2.languages.insertBefore("ruby", "keyword", {
    "regex-literal": [{
      pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }, {
      pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }],
    "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
    "symbol": [{
      pattern: RegExp(/(^|[^:]):/.source + symbolName),
      lookbehind: true,
      greedy: true
    }, {
      pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
      lookbehind: true,
      greedy: true
    }],
    "method-definition": {
      pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
      lookbehind: true,
      inside: {
        "function": /\b\w+$/,
        "keyword": /^self\b/,
        "class-name": /^\w+/,
        "punctuation": /\./
      }
    }
  });
  Prism2.languages.insertBefore("ruby", "string", {
    "string-literal": [{
      pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?/
          }
        },
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?'|'$/
          }
        },
        "string": /[\s\S]+/
      }
    }],
    "command-literal": [{
      pattern: RegExp(/%x/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }, {
      pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }]
  });
  delete Prism2.languages.ruby.string;
  Prism2.languages.insertBefore("ruby", "number", {
    "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
    "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
  });
  Prism2.languages.rb = Prism2.languages.ruby;
})(Prism);
(function(Prism2) {
  var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
  for (var i2 = 0; i2 < 2; i2++) {
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return multilineComment;
    });
  }
  multilineComment = multilineComment.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  });
  Prism2.languages.rust = {
    "comment": [{
      pattern: RegExp(/(^|[^\\])/.source + multilineComment),
      lookbehind: true,
      greedy: true
    }, {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }],
    "string": {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    "char": {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    "attribute": {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: {
        "string": null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    "variable": /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [{
      pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
      lookbehind: true,
      alias: "namespace"
    }, {
      pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
      lookbehind: true,
      alias: "namespace",
      inside: {
        "punctuation": /::/
      }
    }],
    "keyword": [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    "macro": {
      pattern: /\b\w+!/,
      alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        "punctuation": /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    "boolean": /\b(?:false|true)\b/,
    "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  };
  Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
  Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
})(Prism);
(function(Prism2) {
  Prism2.languages.sass = Prism2.languages.extend("css", {
    // Sass comments don't need to be closed, only indented
    "comment": {
      pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
      lookbehind: true,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("sass", "atrule", {
    // We want to consume the whole line
    "atrule-line": {
      // Includes support for = and + shortcuts
      pattern: /^(?:[ \t]*)[@+=].+/m,
      greedy: true,
      inside: {
        "atrule": /(?:@[\w-]+|[+=])/
      }
    }
  });
  delete Prism2.languages.sass.atrule;
  var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
  var operator = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
    pattern: /(\s)-(?=\s)/,
    lookbehind: true
  }];
  Prism2.languages.insertBefore("sass", "property", {
    // We want to consume the whole line
    "variable-line": {
      pattern: /^[ \t]*\$.+/m,
      greedy: true,
      inside: {
        "punctuation": /:/,
        "variable": variable,
        "operator": operator
      }
    },
    // We want to consume the whole line
    "property-line": {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
      greedy: true,
      inside: {
        "property": [/[^:\s]+(?=\s*:)/, {
          pattern: /(:)[^:\s]+/,
          lookbehind: true
        }],
        "punctuation": /:/,
        "variable": variable,
        "operator": operator,
        "important": Prism2.languages.sass.important
      }
    }
  });
  delete Prism2.languages.sass.property;
  delete Prism2.languages.sass.important;
  Prism2.languages.insertBefore("sass", "punctuation", {
    "selector": {
      pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
      lookbehind: true,
      greedy: true
    }
  });
})(Prism);
Prism.languages.scss = Prism.languages.extend("css", {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true
  },
  "atrule": {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      "rule": /@[\w-]+/
      // See rest below
    }
  },
  // url, compassified
  "url": /(?:[-a-z]+-)?url(?=\()/i,
  // CSS selector regex is not appropriate for Sass
  // since there can be lot more things (var, @ directive, nesting..)
  // a selector must start at the end of a property or after a brace (end of other rules or nesting)
  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
  // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
  // can "pass" as a selector- e.g: proper#{$erty})
  // this one was hard to do, so please be careful if you edit this one :)
  "selector": {
    // Initial look-ahead is used to prevent matching of blank selectors
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      "parent": {
        pattern: /&/,
        alias: "important"
      },
      "placeholder": /%[-\w]+/,
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  "property": {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
Prism.languages.insertBefore("scss", "atrule", {
  "keyword": [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
    pattern: /( )(?:from|through)(?= )/,
    lookbehind: true
  }]
});
Prism.languages.insertBefore("scss", "important", {
  // var and interpolated vars
  "variable": /\$[-\w]+|#\{\$[-\w]+\}/
});
Prism.languages.insertBefore("scss", "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  "placeholder": {
    pattern: /%[-\w]+/,
    alias: "selector"
  },
  "statement": {
    pattern: /\B!(?:default|optional)\b/i,
    alias: "keyword"
  },
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  },
  "operator": {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: true
  }
});
Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [{
    pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    greedy: true
  }, /@[\w.$]+/],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};
Prism.languages.swift = {
  "comment": {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    // directives with conditions
    pattern: RegExp(/#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);
(function(Prism2) {
  var typescript = Prism2.util.clone(Prism2.languages.typescript);
  Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
  delete Prism2.languages.tsx["parameter"];
  delete Prism2.languages.tsx["literal-property"];
  var tag = Prism2.languages.tsx.tag;
  tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
  tag.lookbehind = true;
})(Prism);
Prism.languages.basic = {
  "comment": {
    pattern: /(?:!|REM\b).+/i,
    inside: {
      "keyword": /^REM/i
    }
  },
  "string": {
    pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
    greedy: true
  },
  "number": /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
  "keyword": /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
  "function": /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
  "operator": /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
  "punctuation": /[,;:()]/
};
Prism.languages.vbnet = Prism.languages.extend("basic", {
  "comment": [{
    pattern: /(?:!|REM\b).+/i,
    inside: {
      "keyword": /^REM/i
    }
  }, {
    pattern: /(^|[^\\:])'.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
  "punctuation": /[,;:(){}]/
});
var emptyArray$1 = [];
var RESPONSIVE_PADDING = {
  mobile: "medium",
  tablet: "xlarge",
  desktop: "xxlarge"
};
function containerWidthForEntryLayout(config3) {
  return config3.entryLayout === "content" ? "none" : "medium";
}
var EntryLayoutSplitPaneContext = (0, import_react55.createContext)(null);
function useEntryLayoutSplitPaneContext() {
  return (0, import_react55.useContext)(EntryLayoutSplitPaneContext);
}
function ResetEntryLayoutContext(props) {
  return (0, import_jsx_runtime70.jsx)(EntryLayoutSplitPaneContext.Provider, {
    value: null,
    children: props.children
  });
}
function FormForEntry({
  formatInfo,
  forceValidation,
  slugField,
  entryLayout,
  previewProps: props
}) {
  const isAboveMobile = useContentPanelQuery({
    above: "mobile"
  });
  if (entryLayout === "content" && formatInfo.contentField && isAboveMobile) {
    const {
      contentField
    } = formatInfo;
    return (0, import_jsx_runtime70.jsx)(PathContextProvider, {
      value: emptyArray$1,
      children: (0, import_jsx_runtime70.jsx)(SlugFieldProvider, {
        value: slugField,
        children: (0, import_jsx_runtime70.jsxs)(SplitView, {
          autoSaveId: "keystatic-content-split-view",
          defaultSize: 320,
          minSize: 240,
          maxSize: 480,
          flex: true,
          children: [(0, import_jsx_runtime70.jsx)(SplitPaneSecondary, {
            children: (0, import_jsx_runtime70.jsx)(EntryLayoutSplitPaneContext.Provider, {
              value: "main",
              children: (0, import_jsx_runtime70.jsx)(ScrollView2, {
                children: (0, import_jsx_runtime70.jsx)(AddToPathProvider, {
                  part: contentField.key,
                  children: (0, import_jsx_runtime70.jsx)(InnerFormValueContentFromPreviewProps, {
                    forceValidation,
                    ...props.fields[contentField.key]
                  })
                })
              })
            })
          }), (0, import_jsx_runtime70.jsx)(SplitPanePrimary, {
            children: (0, import_jsx_runtime70.jsx)(EntryLayoutSplitPaneContext.Provider, {
              value: "side",
              children: (0, import_jsx_runtime70.jsx)(ScrollView2, {
                children: (0, import_jsx_runtime70.jsx)(Grid, {
                  gap: "xlarge",
                  padding: RESPONSIVE_PADDING,
                  children: Object.entries(props.fields).map(([key3, propVal]) => key3 === contentField.key ? null : (0, import_jsx_runtime70.jsx)(AddToPathProvider, {
                    part: key3,
                    children: (0, import_jsx_runtime70.jsx)(InnerFormValueContentFromPreviewProps, {
                      forceValidation,
                      ...propVal
                    })
                  }, key3))
                })
              })
            })
          })]
        })
      })
    });
  }
  return (0, import_jsx_runtime70.jsx)(ScrollView2, {
    children: (0, import_jsx_runtime70.jsx)(PageContainer, {
      paddingY: RESPONSIVE_PADDING,
      children: (0, import_jsx_runtime70.jsx)(
        FormValueContentFromPreviewProps,
        {
          forceValidation,
          slugField,
          ...props
        }
      )
    })
  });
}
function isValidURL$1(url) {
  return url === (0, import_sanitize_url.sanitizeUrl)(url);
}
var isLinkActive = (editor) => {
  return isElementActive(editor, "link");
};
var wrapLink = (editor, url) => {
  if (isLinkActive(editor)) {
    Transforms.unwrapNodes(editor, {
      match: (n2) => n2.type === "link"
    });
    return;
  }
  const {
    selection
  } = editor;
  const isCollapsed = selection && Range.isCollapsed(selection);
  if (isCollapsed) {
    Transforms.insertNodes(editor, {
      type: "link",
      href: url,
      children: [{
        text: url
      }]
    });
  } else {
    Transforms.wrapNodes(editor, {
      type: "link",
      href: url,
      children: [{
        text: ""
      }]
    }, {
      split: true
    });
  }
};
var LinkElement = ({
  attributes,
  children,
  element: __elementForGettingPath
}) => {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const editor = useSlateStatic();
  const [currentElement, setNode] = useElementWithSetNodes(editor, __elementForGettingPath);
  const href = currentElement.href;
  const text7 = Node2.string(currentElement);
  const [dialogOpen, setDialogOpen] = (0, import_react55.useState)(false);
  const activePopoverElement = useActiveBlockPopover();
  const selected = activePopoverElement === __elementForGettingPath;
  (0, import_react55.useEffect)(() => {
    if (selected && !href) {
      setDialogOpen(true);
    }
  }, [href, selected]);
  const unlink = useEventCallback(() => {
    Transforms.unwrapNodes(editor, {
      at: ReactEditor.findPath(editor, __elementForGettingPath)
    });
    ReactEditor.focus(editor);
  });
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsxs)(BlockPopoverTrigger, {
      element: __elementForGettingPath,
      children: [(0, import_jsx_runtime70.jsx)("a", {
        href,
        ...attributes,
        children
      }), (0, import_jsx_runtime70.jsx)(BlockPopover, {
        placement: "bottom start",
        children: (0, import_jsx_runtime70.jsxs)(Flex, {
          gap: "small",
          padding: "regular",
          children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => setDialogOpen(true),
              children: (0, import_jsx_runtime70.jsx)(Icon, {
                src: editIcon
              })
            }), (0, import_jsx_runtime70.jsx)(Tooltip, {
              children: stringFormatter.format("edit")
            })]
          }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => {
                window.open(href, "_blank", "noopener,noreferrer");
              },
              children: (0, import_jsx_runtime70.jsx)(Icon, {
                src: externalLinkIcon
              })
            }), (0, import_jsx_runtime70.jsx)(Tooltip, {
              children: (0, import_jsx_runtime70.jsx)(Text, {
                truncate: 3,
                children: href
              })
            })]
          }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
              prominence: "low",
              onPress: unlink,
              children: (0, import_jsx_runtime70.jsx)(Icon, {
                src: unlinkIcon
              })
            }), (0, import_jsx_runtime70.jsx)(Tooltip, {
              children: "Unlink"
            })]
          })]
        })
      })]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setDialogOpen(false);
        focusWithPreviousSelection(editor);
      },
      children: dialogOpen && (0, import_jsx_runtime70.jsx)(LinkDialog$1, {
        text: text7,
        href,
        onSubmit: ({
          href: href2
        }) => {
          setNode({
            href: href2
          });
        }
      })
    })]
  });
};
function LinkDialog$1({
  onSubmit,
  ...props
}) {
  let [href, setHref] = (0, import_react55.useState)(props.href || "");
  let [touched, setTouched] = (0, import_react55.useState)(false);
  let {
    dismiss
  } = useDialogContainer();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const showInvalidState = touched && !isValidURL$1(href);
  return (0, import_jsx_runtime70.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime70.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        if (!showInvalidState) {
          dismiss();
          onSubmit({
            href
          });
        }
      },
      children: [(0, import_jsx_runtime70.jsxs)(Heading, {
        children: [props.href ? "Edit" : "Add", " link"]
      }), (0, import_jsx_runtime70.jsx)(Content, {
        children: (0, import_jsx_runtime70.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          children: [(0, import_jsx_runtime70.jsx)(TextField, {
            label: "Text",
            value: props.text,
            isReadOnly: true
          }), (0, import_jsx_runtime70.jsx)(TextField, {
            autoFocus: true,
            isRequired: true,
            onBlur: () => setTouched(true),
            label: "Link",
            onChange: setHref,
            value: href,
            errorMessage: showInvalidState && "Please provide a valid URL."
          })]
        })
      }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime70.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime70.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
var _linkIcon = (0, import_jsx_runtime70.jsx)(Icon, {
  src: linkIcon
});
function LinkButton$1() {
  const {
    editor,
    links: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(ActionButton, {
    prominence: "low",
    isDisabled,
    isSelected,
    onPress: () => {
      wrapLink(editor, "");
      ReactEditor.focus(editor);
    },
    children: _linkIcon
  }), [isSelected, isDisabled, editor]);
}
var linkButton = (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime70.jsx)(LinkButton$1, {}), (0, import_jsx_runtime70.jsx)(Tooltip, {
    children: (0, import_jsx_runtime70.jsx)(Text, {
      children: "Link"
    })
  })]
});
var values2 = {
  start: {
    key: "start",
    label: "Align Start",
    icon: (0, import_jsx_runtime70.jsx)(Icon, {
      src: alignLeftIcon
    })
  },
  center: {
    key: "center",
    label: "Align Center",
    icon: (0, import_jsx_runtime70.jsx)(Icon, {
      src: alignCenterIcon
    })
  },
  end: {
    key: "end",
    label: "Align End",
    icon: (0, import_jsx_runtime70.jsx)(Icon, {
      src: alignRightIcon
    })
  }
};
var TextAlignMenu = ({
  alignment
}) => {
  const toolbarState = useToolbarState();
  const items = (0, import_react55.useMemo)(() => [values2.start, ...Object.keys(alignment).map((x) => values2[x])], [alignment]);
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsxs)(MenuTrigger, {
    children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsxs)(ActionButton, {
        prominence: "low",
        children: [values2[toolbarState.alignment.selected].icon, (0, import_jsx_runtime70.jsx)(Icon, {
          src: chevronDownIcon
        })]
      }), (0, import_jsx_runtime70.jsx)(Tooltip, {
        children: (0, import_jsx_runtime70.jsx)(Text, {
          children: "Text Alignment"
        })
      })]
    }), (0, import_jsx_runtime70.jsx)(_Menu, {
      selectionMode: "single",
      selectedKeys: [toolbarState.alignment.selected],
      items,
      onAction: (key3) => {
        if (key3 === "start") {
          Transforms.unsetNodes(toolbarState.editor, "textAlign", {
            match: (node3) => node3.type === "paragraph" || node3.type === "heading"
          });
        } else {
          Transforms.setNodes(toolbarState.editor, {
            textAlign: key3
          }, {
            match: (node3) => node3.type === "paragraph" || node3.type === "heading"
          });
        }
        ReactEditor.focus(toolbarState.editor);
      },
      children: (item2) => {
        return (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          children: [(0, import_jsx_runtime70.jsx)(Text, {
            children: item2.label
          }), item2.icon]
        }, item2.key);
      }
    })]
  }), [items, toolbarState.alignment.selected, toolbarState.editor]);
};
var insertBlockquote = (editor) => {
  const isActive = isElementActive(editor, "blockquote");
  if (isActive) {
    Transforms.unwrapNodes(editor, {
      match: (node3) => node3.type === "blockquote"
    });
  } else {
    Transforms.wrapNodes(editor, {
      type: "blockquote",
      children: []
    });
  }
};
var BlockquoteButton = () => {
  const {
    editor,
    blockquote: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(ActionButton, {
    prominence: "low",
    isSelected,
    isDisabled,
    onPress: () => {
      insertBlockquote(editor);
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime70.jsx)(Icon, {
      src: quoteIcon
    })
  }), [editor, isDisabled, isSelected]);
};
var blockquoteButton = (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime70.jsx)(BlockquoteButton, {}), (0, import_jsx_runtime70.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime70.jsx)(Text, {
      children: "Quote"
    }), (0, import_jsx_runtime70.jsx)(Kbd, {
      children: ">⎵"
    })]
  })]
});
var languages = [{
  label: "C",
  value: "c"
}, {
  label: "C++",
  value: "cpp"
}, {
  label: "Arduino",
  value: "arduino"
}, {
  label: "Bash",
  value: "bash"
}, {
  label: "C#",
  value: "csharp"
}, {
  label: "CSS",
  value: "css"
}, {
  label: "Diff",
  value: "diff"
}, {
  label: "Go",
  value: "go"
}, {
  label: "INI",
  value: "ini"
}, {
  label: "Java",
  value: "java"
}, {
  label: "JavaScript",
  value: "javascript"
}, {
  label: "JSX",
  value: "jsx"
}, {
  label: "JSON",
  value: "json"
}, {
  label: "Kotlin",
  value: "kotlin"
}, {
  label: "Less",
  value: "less"
}, {
  label: "Lua",
  value: "lua"
}, {
  label: "Makefile",
  value: "makefile"
}, {
  label: "Markdown",
  value: "markdown"
}, {
  label: "Objective-C",
  value: "objectivec"
}, {
  label: "Perl",
  value: "perl"
}, {
  label: "PHP",
  value: "php"
}, {
  label: "Python",
  value: "python"
}, {
  label: "R",
  value: "r"
}, {
  label: "Ruby",
  value: "ruby"
}, {
  label: "Rust",
  value: "rust"
}, {
  label: "Sass",
  value: "sass"
}, {
  label: "SCSS",
  value: "scss"
}, {
  label: "SQL",
  value: "sql"
}, {
  label: "Swift",
  value: "swift"
}, {
  label: "TypeScript",
  value: "typescript"
}, {
  label: "TSX",
  value: "tsx"
}, {
  label: "VB.NET",
  value: "vbnet"
}, {
  label: "YAML",
  value: "yaml"
}];
var canonicalNameToLabel = new Map(languages.map((x) => [x.value, x.label]));
var labelToCanonicalName = new Map(languages.map((x) => [x.label, x.value]));
var languageToCanonicalName = new Map(languages.map((lang) => [Prism.languages[lang.value], lang.value]));
var aliasesToCanonicalName = new Map(Object.keys(Prism.languages).flatMap((lang) => {
  const canonicalName = languageToCanonicalName.get(Prism.languages[lang]);
  if (canonicalName === void 0) {
    return [];
  }
  return [[lang, canonicalName]];
}));
var languagesToAliases = new Map(languages.map((lang) => [lang.value, []]));
for (const [alias, canonicalName] of aliasesToCanonicalName) {
  languagesToAliases.get(canonicalName).push(alias);
}
var languagesWithAliases = [{
  label: "Plain text",
  value: "plain",
  aliases: []
}, ...[...languagesToAliases].map(([canonicalName, aliases]) => ({
  label: canonicalNameToLabel.get(canonicalName),
  value: canonicalName,
  aliases
}))];
var aliasesToLabel = new Map([...aliasesToCanonicalName].map(([alias, canonicalName]) => [alias, canonicalNameToLabel.get(canonicalName)]));
function CustomAttributesDialogInner(props) {
  const editor = useSlateStatic();
  const [state2, setState] = (0, import_react55.useState)(() => {
    return getInitialPropsValueFromInitializer(props.schema, Object.fromEntries(Object.keys(props.schema.fields).map((key3) => [key3, props.element[key3]])));
  });
  const [forceValidation, setForceValidation] = (0, import_react55.useState)(false);
  const previewProps = (0, import_react55.useMemo)(() => createGetPreviewProps(props.schema, setState, () => void 0), [props.schema])(state2);
  let {
    dismiss
  } = useDialogContainer();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime70.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime70.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        setForceValidation(true);
        if (clientSideValidateProp(props.schema, state2, void 0)) {
          dismiss();
          const path3 = ReactEditor.findPath(editor, props.element);
          console.log(state2);
          Transforms.setNodes(editor, state2, {
            at: path3
          });
        }
      },
      children: [(0, import_jsx_runtime70.jsxs)(Heading, {
        children: [props.nodeLabel, " details"]
      }), (0, import_jsx_runtime70.jsx)(Content, {
        children: (0, import_jsx_runtime70.jsx)(FormValueContentFromPreviewProps, {
          forceValidation,
          autoFocus: true,
          ...previewProps
        })
      }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime70.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime70.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
function CustomAttributesEditButton(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
      prominence: "low",
      onPress: props.onPress,
      children: (0, import_jsx_runtime70.jsx)(Icon, {
        src: editIcon
      })
    }), (0, import_jsx_runtime70.jsx)(Tooltip, {
      children: stringFormatter.format("edit")
    })]
  });
}
function CustomAttributesDialog(props) {
  const editor = useSlateStatic();
  return (0, import_jsx_runtime70.jsx)(DialogContainer, {
    onDismiss: () => {
      props.onDismiss();
      focusWithPreviousSelection(editor);
    },
    children: props.isOpen && (0, import_jsx_runtime70.jsx)(CustomAttributesDialogInner, {
      element: props.element,
      nodeLabel: props.nodeLabel,
      schema: props.schema
    })
  });
}
function CodeButton() {
  const {
    editor,
    code: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(ActionButton, {
    isSelected,
    isDisabled,
    prominence: "low",
    onPress: () => {
      if (isSelected) {
        Transforms.unwrapNodes(editor, {
          match: (node3) => node3.type === "code"
        });
      } else {
        Transforms.wrapNodes(editor, {
          type: "code",
          children: [{
            text: ""
          }]
        });
      }
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime70.jsx)(Icon, {
      src: codeIcon
    })
  }), [isDisabled, isSelected, editor]);
}
var codeButton = (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime70.jsx)(CodeButton, {}), (0, import_jsx_runtime70.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime70.jsx)(Text, {
      children: "Code block"
    }), (0, import_jsx_runtime70.jsx)(Kbd, {
      children: "```"
    })]
  })]
});
function CodeElement({
  attributes,
  children,
  element: element3
}) {
  var _aliasesToLabel$get;
  const editor = useSlateStatic();
  const triggerRef = (0, import_react55.useRef)(null);
  const [inputValue, setInputValue] = (0, import_react55.useState)(element3.language ? (_aliasesToLabel$get = aliasesToLabel.get(element3.language)) !== null && _aliasesToLabel$get !== void 0 ? _aliasesToLabel$get : element3.language : "Plain text");
  const [dialogOpen, setDialogOpen] = (0, import_react55.useState)(false);
  const {
    documentFeatures
  } = useDocumentEditorConfig();
  const customAttributesSchema = documentFeatures.formatting.blockTypes.code && Object.keys(documentFeatures.formatting.blockTypes.code.schema.fields).length ? documentFeatures.formatting.blockTypes.code.schema : void 0;
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsx)(BlockWrapper$1, {
      children: (0, import_jsx_runtime70.jsxs)(BlockPopoverTrigger, {
        element: element3,
        children: [(0, import_jsx_runtime70.jsx)("pre", {
          spellCheck: "false",
          ref: triggerRef,
          children: (0, import_jsx_runtime70.jsx)("code", {
            ...attributes,
            children
          })
        }), (0, import_jsx_runtime70.jsx)(BlockPopover, {
          children: (0, import_jsx_runtime70.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime70.jsx)(_Combobox, {
              "aria-label": "Language",
              width: "scale.2000",
              allowsCustomValue: true,
              inputValue,
              onInputChange: setInputValue,
              onBlur: () => {
                const path3 = ReactEditor.findPath(editor, element3);
                const canonicalName = aliasesToCanonicalName.get(inputValue);
                if (canonicalName !== void 0) {
                  if (canonicalName === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path3
                    });
                    return;
                  }
                  setInputValue(canonicalNameToLabel.get(canonicalName));
                  Transforms.setNodes(editor, {
                    language: canonicalName
                  }, {
                    at: path3
                  });
                  return;
                }
                const nameFromLabel = labelToCanonicalName.get(inputValue);
                if (nameFromLabel !== void 0) {
                  if (nameFromLabel === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path3
                    });
                    return;
                  }
                  Transforms.setNodes(editor, {
                    language: nameFromLabel
                  }, {
                    at: path3
                  });
                  return;
                }
                if (inputValue === "") {
                  Transforms.unsetNodes(editor, "language", {
                    at: path3
                  });
                  setInputValue("Plain text");
                  return;
                }
                if (inputValue !== element3.language) {
                  Transforms.setNodes(editor, {
                    language: inputValue
                  }, {
                    at: path3
                  });
                }
              },
              onSelectionChange: (selection) => {
                const path3 = ReactEditor.findPath(editor, element3);
                if (aliasesToCanonicalName.has(inputValue)) {
                  selection = aliasesToCanonicalName.get(inputValue);
                }
                if (selection === null) {
                  if (inputValue === "") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path3
                    });
                  } else {
                    Transforms.setNodes(editor, {
                      language: inputValue
                    }, {
                      at: path3
                    });
                  }
                } else if (typeof selection === "string") {
                  if (selection === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path3
                    });
                    setInputValue("Plain text");
                    return;
                  }
                  Transforms.setNodes(editor, {
                    language: selection
                  }, {
                    at: path3
                  });
                  const label = canonicalNameToLabel.get(selection);
                  if (label) {
                    setInputValue(label);
                  }
                }
              },
              selectedKey: element3.language ? aliasesToCanonicalName.get(element3.language) : "plain",
              items: (0, import_react55.useMemo)(() => inputValue === "Plain text" || labelToCanonicalName.has(inputValue) ? languagesWithAliases : matchSorter(languagesWithAliases, inputValue, {
                keys: ["label", "value", "aliases"]
              }), [inputValue]),
              children: (item2) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
                children: item2.label
              }, item2.value)
            }), (0, import_jsx_runtime70.jsx)(ToolbarSeparator, {}), customAttributesSchema !== void 0 && (0, import_jsx_runtime70.jsx)(CustomAttributesEditButton, {
              onPress: () => setDialogOpen(true)
            }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, element3)
                  });
                },
                children: (0, import_jsx_runtime70.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime70.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      })
    }), customAttributesSchema !== void 0 && (0, import_jsx_runtime70.jsx)(CustomAttributesDialog, {
      element: element3,
      isOpen: dialogOpen,
      nodeLabel: "Code block",
      schema: customAttributesSchema,
      onDismiss: () => {
        setDialogOpen(false);
      }
    })]
  });
}
function getValueAtPropPath(value, inputPath) {
  const path3 = [...inputPath];
  while (path3.length) {
    const key3 = path3.shift();
    value = value[key3];
  }
  return value;
}
function traverseProps(schema, value, visitor, path3 = []) {
  if (schema.kind === "form" || schema.kind === "child") {
    visitor(schema, value, path3);
    return;
  }
  if (schema.kind === "object") {
    for (const [key3, childProp] of Object.entries(schema.fields)) {
      traverseProps(childProp, value[key3], visitor, [...path3, key3]);
    }
    visitor(schema, value, path3);
    return;
  }
  if (schema.kind === "array") {
    for (const [idx, val] of value.entries()) {
      traverseProps(schema.element, val, visitor, path3.concat(idx));
    }
    return visitor(schema, value, path3);
  }
  if (schema.kind === "conditional") {
    const discriminant = value.discriminant;
    visitor(schema, discriminant, path3.concat("discriminant"));
    traverseProps(schema.values[discriminant.toString()], value.value, visitor, path3.concat("value"));
    visitor(schema, value, path3);
    return;
  }
  assertNever(schema);
}
function transformProps(schema, value, visitors, path3 = []) {
  if (schema.kind === "form" || schema.kind === "child") {
    if (visitors[schema.kind]) {
      return visitors[schema.kind](schema, value, path3);
    }
    return value;
  }
  if (schema.kind === "object") {
    const val = Object.fromEntries(Object.entries(schema.fields).map(([key3, val2]) => {
      return [key3, transformProps(val2, value[key3], visitors, [...path3, key3])];
    }));
    if (visitors.object) {
      return visitors[schema.kind](schema, val, path3);
    }
    return val;
  }
  if (schema.kind === "array") {
    const val = value.map((val2, idx) => transformProps(schema.element, val2, visitors, path3.concat(idx)));
    if (visitors.array) {
      return visitors[schema.kind](schema, val, path3);
    }
    return val;
  }
  if (schema.kind === "conditional") {
    const discriminant = transformProps(schema.discriminant, value.discriminant, visitors, path3.concat("discriminant"));
    const conditionalVal = transformProps(schema.values[discriminant.toString()], value.value, visitors, path3.concat("value"));
    const val = {
      discriminant,
      value: conditionalVal
    };
    if (visitors.conditional) {
      return visitors[schema.kind](schema, val, path3);
    }
    return val;
  }
  assertNever(schema);
}
function replaceValueAtPropPath(schema, value, newValue, path3) {
  if (path3.length === 0) {
    return newValue;
  }
  const [key3, ...newPath] = path3;
  if (schema.kind === "object") {
    return {
      ...value,
      [key3]: replaceValueAtPropPath(schema.fields[key3], value[key3], newValue, newPath)
    };
  }
  if (schema.kind === "conditional") {
    const conditionalValue = value;
    assert(key3 === "value");
    return {
      discriminant: conditionalValue.discriminant,
      value: replaceValueAtPropPath(schema.values[key3], conditionalValue.value, newValue, newPath)
    };
  }
  if (schema.kind === "array") {
    const prevVal = value;
    const newVal = [...prevVal];
    setKeysForArrayValue(newVal, getKeysForArrayValue(prevVal));
    newVal[key3] = replaceValueAtPropPath(schema.element, newVal[key3], newValue, newPath);
    return newVal;
  }
  assert(schema.kind !== "form" && schema.kind !== "child");
  assertNever(schema);
}
function getYjsValFromParsedValue(schema, value) {
  if (schema.kind === "form") {
    if (schema.formKind === "content" && schema.collaboration) {
      return schema.collaboration.toYjs(value);
    }
    return value;
  }
  if (schema.kind === "child") {
    return null;
  }
  if (schema.kind === "object") {
    return new YMap(Object.entries(schema.fields).map(([key3, val]) => [key3, getYjsValFromParsedValue(val, value[key3])]));
  }
  if (schema.kind === "array") {
    const arr = new YArray();
    arr.push(value.map((val) => getYjsValFromParsedValue(schema.element, val)));
    return arr;
  }
  if (schema.kind === "conditional") {
    const discriminant = value.discriminant;
    return new YMap([["discriminant", discriminant], ["value", getYjsValFromParsedValue(schema.values[discriminant + ""], value.value)]]);
  }
  assertNever(schema);
}
function yjsToVal(schema, awareness, yjsValue) {
  if (schema.kind === "form") {
    if (schema.formKind === "content" && schema.collaboration) {
      return schema.collaboration.fromYjs(yjsValue, awareness);
    }
    return yjsValue;
  }
  if (schema.kind === "child") {
    return null;
  }
  if (schema.kind === "object") {
    return Object.fromEntries(Object.entries(schema.fields).map(([key3, val]) => [key3, yjsToVal(val, awareness, yjsValue.get(key3))]));
  }
  if (schema.kind === "array") {
    const yArr = yjsValue;
    if (!yArr) {
      debugger;
    }
    const val = yArr.map((val2) => yjsToVal(schema.element, awareness, val2));
    setKeysForArrayValue(val, getKeysForArrayValue(yArr));
    return val;
  }
  if (schema.kind === "conditional") {
    const yjsMap = yjsValue;
    return {
      discriminant: yjsToVal(schema.discriminant, awareness, yjsMap.get("discriminant")),
      value: yjsToVal(schema.values[yjsMap.get("discriminant") + ""], awareness, yjsMap.get("value"))
    };
  }
}
function parsedValToYjs(schema, value) {
  if (schema.kind === "form" || schema.kind === "child") {
    return value;
  }
  if (schema.kind === "object") {
    return new YMap(Object.entries(schema.fields).map(([key3, val]) => [key3, parsedValToYjs(val, value[key3])]));
  }
  if (schema.kind === "array") {
    const arr = new YArray();
    arr.push(value.map((val) => parsedValToYjs(schema.element, val)));
    return arr;
  }
  if (schema.kind === "conditional") {
    const discriminant = value.discriminant;
    return new YMap([["discriminant", discriminant], ["value", parsedValToYjs(schema.values[discriminant.toString()], value.value)]]);
  }
}
function updateComponentBlockElementProps(editor, componentBlock, prevProps, _newProps, basePath, setElement, ignoreChildFields) {
  Editor.withoutNormalizing(editor, () => {
    const propPathsWithNodesToReplace = /* @__PURE__ */ new Map();
    const schema = {
      kind: "object",
      fields: componentBlock.schema
    };
    const newProps = transformProps(schema, _newProps, {
      child(schema2, value, path3) {
        if (!ignoreChildFields && schema2.options.kind === "block" && value) {
          try {
            let prevVal = getValueAtPropPath(prevProps, path3);
            if (prevVal === value) {
              return null;
            }
          } catch {
          }
          propPathsWithNodesToReplace.set(JSON.stringify(path3), value.map(cloneDescendent));
        }
        return null;
      }
    });
    setElement({
      props: newProps
    });
    const childPropPaths = findChildPropPathsWithPrevious(newProps, prevProps, schema, [], [], []);
    const getNode = () => Node2.get(editor, basePath);
    const elementForChildren = getNode();
    if (childPropPaths.length === 0) {
      const indexes = elementForChildren.children.map((_, i2) => i2).reverse();
      for (const idx of indexes) {
        Transforms.removeNodes(editor, {
          at: [...basePath, idx]
        });
      }
      Transforms.insertNodes(editor, {
        type: "component-inline-prop",
        propPath: void 0,
        children: [{
          text: ""
        }]
      }, {
        at: [...basePath, 0]
      });
      return;
    }
    const initialPropPathsToEditorPath = /* @__PURE__ */ new Map();
    for (const [idx, node3] of elementForChildren.children.entries()) {
      assert(node3.type === "component-block-prop" || node3.type === "component-inline-prop");
      initialPropPathsToEditorPath.set(node3.propPath === void 0 ? void 0 : JSON.stringify(node3.propPath), idx);
    }
    const childrenLeftToAdd = new Set(childPropPaths);
    for (const childProp of childPropPaths) {
      if (childProp.prevPath === void 0) {
        continue;
      }
      const stringifiedPath = JSON.stringify(childProp.prevPath);
      const idxInChildren = initialPropPathsToEditorPath.get(stringifiedPath);
      if (idxInChildren !== void 0) {
        const prevNode = elementForChildren.children[idxInChildren];
        assert(prevNode.propPath !== void 0);
        if (!areArraysEqual(childProp.path, prevNode.propPath)) {
          Transforms.setNodes(editor, {
            propPath: childProp.path
          }, {
            at: [...basePath, idxInChildren]
          });
        }
        childrenLeftToAdd.delete(childProp);
        initialPropPathsToEditorPath.delete(stringifiedPath);
      }
    }
    let newIdx = getNode().children.length;
    for (const childProp of childrenLeftToAdd) {
      Transforms.insertNodes(editor, {
        type: `component-${childProp.options.kind}-prop`,
        propPath: childProp.path,
        children: [childProp.options.kind === "block" ? {
          type: "paragraph",
          children: [{
            text: ""
          }]
        } : {
          text: ""
        }]
      }, {
        at: [...basePath, newIdx]
      });
      newIdx++;
    }
    const pathsToRemove = [];
    for (const [, idxInChildren] of initialPropPathsToEditorPath) {
      pathsToRemove.push(Editor.pathRef(editor, [...basePath, idxInChildren]));
    }
    for (const pathRef of pathsToRemove) {
      const path3 = pathRef.unref();
      assert(path3 !== null);
      Transforms.removeNodes(editor, {
        at: path3
      });
    }
    const propPathsToExpectedIndexes = /* @__PURE__ */ new Map();
    for (const [idx, thing] of childPropPaths.entries()) {
      propPathsToExpectedIndexes.set(JSON.stringify(thing.path), idx);
    }
    outer: while (true) {
      for (const [idx, childNode] of getNode().children.entries()) {
        assert(childNode.type === "component-block-prop" || childNode.type === "component-inline-prop");
        const expectedIndex = propPathsToExpectedIndexes.get(JSON.stringify(childNode.propPath));
        assert(expectedIndex !== void 0);
        if (idx === expectedIndex) continue;
        Transforms.moveNodes(editor, {
          at: [...basePath, idx],
          to: [...basePath, expectedIndex]
        });
        continue outer;
      }
      break;
    }
    for (const [propPath, val] of propPathsWithNodesToReplace) {
      const idx = propPathsToExpectedIndexes.get(propPath);
      if (idx !== void 0) {
        Transforms.removeNodes(editor, {
          at: [...basePath, idx]
        });
        Transforms.insertNodes(editor, {
          type: "component-block-prop",
          propPath: JSON.parse(propPath),
          children: val
        }, {
          at: [...basePath, idx]
        });
      }
    }
  });
}
function findChildPropPathsWithPrevious(value, prevValue, schema, newPath, prevPath, pathWithKeys) {
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        path: newPath,
        prevPath,
        options: schema.options
      }];
    case "conditional":
      const hasChangedDiscriminant = value.discriminant === prevValue.discriminant;
      return findChildPropPathsWithPrevious(value.value, hasChangedDiscriminant ? prevValue.value : getInitialPropsValue(schema.values[value.discriminant]), schema.values[value.discriminant], newPath.concat("value"), hasChangedDiscriminant ? void 0 : prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat("value"), hasChangedDiscriminant ? void 0 : pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat("value"));
    case "object": {
      const paths = [];
      for (const key3 of Object.keys(schema.fields)) {
        paths.push(...findChildPropPathsWithPrevious(value[key3], prevValue[key3], schema.fields[key3], newPath.concat(key3), prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat(key3), pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat(key3)));
      }
      return paths;
    }
    case "array": {
      const paths = [];
      const prevKeys = getKeysForArrayValue(prevValue);
      const keys3 = getKeysForArrayValue(value);
      for (const [i2, val] of value.entries()) {
        const key3 = keys3[i2];
        const prevIdx = prevKeys.indexOf(key3);
        let prevVal;
        if (prevIdx === -1) {
          prevVal = getInitialPropsValue(schema.element);
        } else {
          prevVal = prevValue[prevIdx];
        }
        paths.push(...findChildPropPathsWithPrevious(val, prevVal, schema.element, newPath.concat(i2), prevIdx === -1 ? void 0 : prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat(prevIdx), prevIdx === -1 ? void 0 : pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat(key3)));
      }
      return paths;
    }
  }
}
var ChildrenByPathContext = import_react55.default.createContext({});
function ChildFieldEditable({
  path: path3
}) {
  const childrenByPath = (0, import_react55.useContext)(ChildrenByPathContext);
  const child = childrenByPath[JSON.stringify(path3)];
  if (child === void 0) {
    return null;
  }
  return child;
}
function ComponentBlockRender({
  componentBlock,
  element: element3,
  onChange,
  children,
  onRemove
}) {
  const getPreviewProps = (0, import_react55.useMemo)(() => {
    return createGetPreviewProps({
      kind: "object",
      fields: componentBlock.schema
    }, (cb) => onChange(cb, true), (path3) => (0, import_jsx_runtime70.jsx)(ChildFieldEditable, {
      path: path3
    }));
  }, [onChange, componentBlock]);
  const previewProps = getPreviewProps(element3.props);
  const childrenByPath = {};
  let maybeChild;
  let extraChildren = [];
  children.forEach((child) => {
    const propPath = child.props.children.props.element.propPath;
    if (propPath === void 0) {
      maybeChild = child;
    } else {
      const schema = getSchemaAtPropPath(propPath, element3.props, componentBlock.schema);
      if ((schema === null || schema === void 0 ? void 0 : schema.kind) === "child" && schema.options.kind === "block" && schema.options.editIn === "modal") {
        extraChildren.push(child);
        return;
      }
      childrenByPath[JSON.stringify(propPathWithIndiciesToKeys(propPath, element3.props))] = child;
    }
  });
  const ComponentBlockPreview = componentBlock.preview;
  return (0, import_jsx_runtime70.jsxs)(ChildrenByPathContext.Provider, {
    value: childrenByPath,
    children: [(0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(ComponentBlockPreview, {
      onRemove,
      ...previewProps
    }), [ComponentBlockPreview, onRemove, previewProps]), (0, import_jsx_runtime70.jsxs)("span", {
      className: css({
        caretColor: "transparent",
        "& ::selection": {
          backgroundColor: "transparent"
        },
        overflow: "hidden",
        width: 1,
        height: 1,
        position: "absolute"
      }),
      children: [maybeChild, extraChildren]
    })]
  });
}
function propPathWithIndiciesToKeys(propPath, val) {
  return propPath.map((key3) => {
    var _val2;
    if (typeof key3 === "string") {
      var _val;
      val = (_val = val) === null || _val === void 0 ? void 0 : _val[key3];
      return key3;
    }
    if (!Array.isArray(val)) {
      val = void 0;
      return "";
    }
    const keys3 = getKeysForArrayValue(val);
    val = (_val2 = val) === null || _val2 === void 0 ? void 0 : _val2[key3];
    return keys3[key3];
  });
}
function ChromefulComponentBlockElement(props) {
  var _props$componentBlock;
  const selected = useSelected();
  const isValid = (0, import_react55.useMemo)(() => clientSideValidateProp({
    kind: "object",
    fields: props.componentBlock.schema
  }, props.elementProps, void 0), [props.componentBlock, props.elementProps]);
  const [editMode, setEditMode] = (0, import_react55.useState)(false);
  const onCloseEditMode = (0, import_react55.useCallback)(() => {
    setEditMode(false);
  }, []);
  const onShowEditMode = (0, import_react55.useCallback)(() => {
    setEditMode(true);
  }, []);
  const ChromefulToolbar = (_props$componentBlock = props.componentBlock.toolbar) !== null && _props$componentBlock !== void 0 ? _props$componentBlock : DefaultToolbarWithChrome;
  return (0, import_jsx_runtime70.jsx)(BlockPrimitive, {
    selected,
    ...props.attributes,
    children: (0, import_jsx_runtime70.jsxs)(Flex, {
      gap: "medium",
      direction: "column",
      children: [(0, import_jsx_runtime70.jsx)(NotEditable, {
        children: (0, import_jsx_runtime70.jsx)(Text, {
          casing: "uppercase",
          color: "neutralSecondary",
          weight: "medium",
          size: "small",
          children: props.componentBlock.label
        })
      }), (0, import_jsx_runtime70.jsxs)(import_react55.Fragment, {
        children: [props.renderedBlock, (0, import_jsx_runtime70.jsx)(ChromefulToolbar, {
          isValid,
          onRemove: props.onRemove,
          props: props.previewProps,
          onShowEditMode
        }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
          onDismiss: () => onCloseEditMode(),
          children: (() => {
            if (!editMode) {
              return;
            }
            return (0, import_jsx_runtime70.jsxs)(Dialog, {
              children: [(0, import_jsx_runtime70.jsxs)(Heading, {
                children: ["Edit ", props.componentBlock.label]
              }), (0, import_jsx_runtime70.jsx)(FormValue$1, {
                props: props.previewProps,
                onClose: onCloseEditMode
              })]
            });
          })()
        })]
      })]
    })
  });
}
var BlockPrimitive = (0, import_react55.forwardRef)(function BlockPrimitive2({
  children,
  selected,
  ...attributes
}, ref2) {
  return (0, import_jsx_runtime70.jsx)("div", {
    ...attributes,
    ref: ref2,
    className: css(blockElementSpacing, {
      position: "relative",
      paddingInlineStart: tokenSchema.size.space.xlarge,
      marginBottom: tokenSchema.size.space.xlarge,
      "::before": {
        display: "block",
        content: '" "',
        backgroundColor: selected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle,
        borderRadius: 4,
        width: 4,
        position: "absolute",
        left: 0,
        top: 0,
        bottom: 0,
        zIndex: 1
      }
    }),
    children
  });
});
function DefaultToolbarWithChrome({
  onShowEditMode,
  onRemove,
  isValid
}) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime70.jsx)(NotEditable, {
    children: (0, import_jsx_runtime70.jsxs)(Flex, {
      direction: "column",
      gap: "medium",
      children: [(0, import_jsx_runtime70.jsxs)(Flex, {
        alignItems: "center",
        gap: "regular",
        UNSAFE_style: {
          userSelect: "none"
        },
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          onPress: () => onShowEditMode(),
          children: stringFormatter.format("edit")
        }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
            prominence: "low",
            onPress: onRemove,
            children: (0, import_jsx_runtime70.jsx)(Icon, {
              src: trash2Icon
            })
          }), (0, import_jsx_runtime70.jsx)(Tooltip, {
            tone: "critical",
            children: stringFormatter.format("delete")
          })]
        })]
      }), !isValid && (0, import_jsx_runtime70.jsx)(FieldMessage, {
        children: "Contains invalid fields. Please edit."
      })]
    })
  });
}
function FormValue$1({
  onClose,
  props
}) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const formId = (0, import_react55.useId)();
  const [forceValidation, setForceValidation] = (0, import_react55.useState)(false);
  const [state2, setState] = (0, import_react55.useState)(() => previewPropsToValue(props));
  const previewProps = (0, import_react55.useMemo)(() => createGetPreviewProps(props.schema, setState, () => void 0), [props.schema])(state2);
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsx)(Content, {
      children: (0, import_jsx_runtime70.jsx)(Flex, {
        id: formId,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget) return;
          event.preventDefault();
          if (!clientSideValidateProp(props.schema, state2, void 0)) {
            setForceValidation(true);
          } else {
            console.log(valueToUpdater(state2, props.schema));
            setValueToPreviewProps(state2, props);
            onClose();
          }
        },
        direction: "column",
        gap: "xxlarge",
        children: (0, import_jsx_runtime70.jsx)(FormValueContentFromPreviewProps, {
          ...previewProps,
          forceValidation
        })
      })
    }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime70.jsx)(Button, {
        onPress: onClose,
        children: stringFormatter.format("cancel")
      }), (0, import_jsx_runtime70.jsx)(Button, {
        form: formId,
        prominence: "high",
        type: "submit",
        children: "Done"
      })]
    })]
  });
}
function ChromelessComponentBlockElement(props) {
  var _props$componentBlock;
  const hasToolbar = props.componentBlock.toolbar !== null;
  const ChromelessToolbar = (_props$componentBlock = props.componentBlock.toolbar) !== null && _props$componentBlock !== void 0 ? _props$componentBlock : DefaultToolbarWithoutChrome;
  return (0, import_jsx_runtime70.jsx)("div", {
    ...props.attributes,
    className: blockElementSpacing,
    children: hasToolbar ? (0, import_jsx_runtime70.jsxs)(BlockPopoverTrigger, {
      element: props.element,
      children: [(0, import_jsx_runtime70.jsx)("div", {
        children: props.renderedBlock
      }), (0, import_jsx_runtime70.jsx)(BlockPopover, {
        children: (0, import_jsx_runtime70.jsx)(ChromelessToolbar, {
          onRemove: props.onRemove,
          props: props.previewProps
        })
      })]
    }) : (0, import_jsx_runtime70.jsx)("div", {
      children: props.renderedBlock
    })
  });
}
function DefaultToolbarWithoutChrome({
  onRemove
}) {
  return (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
      onPress: onRemove,
      margin: "regular",
      children: (0, import_jsx_runtime70.jsx)(Icon, {
        src: trashIcon
      })
    }), (0, import_jsx_runtime70.jsx)(Tooltip, {
      tone: "critical",
      children: "Remove"
    })]
  });
}
function findChildPropPathsForProp(value, schema, path3) {
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        path: path3,
        options: schema.options
      }];
    case "conditional":
      return findChildPropPathsForProp(value.value, schema.values[value.discriminant], path3.concat("value"));
    case "object": {
      const paths = [];
      Object.keys(schema.fields).forEach((key3) => {
        paths.push(...findChildPropPathsForProp(value[key3], schema.fields[key3], path3.concat(key3)));
      });
      return paths;
    }
    case "array": {
      const paths = [];
      value.forEach((val, i2) => {
        paths.push(...findChildPropPathsForProp(val, schema.element, path3.concat(i2)));
      });
      return paths;
    }
  }
}
function findChildPropPaths(value, props) {
  const propPaths = findChildPropPathsForProp(value, {
    kind: "object",
    fields: props
  }, []);
  if (!propPaths.length) {
    return [{
      path: void 0,
      options: {
        kind: "inline",
        placeholder: ""
      }
    }];
  }
  return propPaths;
}
function getAncestorComponentBlock(editor) {
  if (editor.selection) {
    const ancestorEntry = Editor.above(editor, {
      match: (node3) => isBlock(node3) && node3.type !== "paragraph"
    });
    if (ancestorEntry && (ancestorEntry[0].type === "component-block-prop" || ancestorEntry[0].type === "component-inline-prop")) {
      return {
        isInside: true,
        componentBlock: Editor.parent(editor, ancestorEntry[1]),
        prop: ancestorEntry
      };
    }
  }
  return {
    isInside: false
  };
}
var alreadyNormalizedThings = /* @__PURE__ */ new WeakMap();
function normalizeNodeWithinComponentProp([node3, path3], editor, fieldOptions) {
  let alreadyNormalizedNodes = alreadyNormalizedThings.get(fieldOptions);
  if (!alreadyNormalizedNodes) {
    alreadyNormalizedNodes = /* @__PURE__ */ new WeakSet();
    alreadyNormalizedThings.set(fieldOptions, alreadyNormalizedNodes);
  }
  if (alreadyNormalizedNodes.has(node3)) {
    return false;
  }
  let didNormalization = false;
  if (fieldOptions.inlineMarks !== "inherit" && Text2.isText(node3)) {
    didNormalization = normalizeTextBasedOnInlineMarksAndSoftBreaks([node3, path3], editor, fieldOptions.inlineMarks, fieldOptions.softBreaks);
  }
  if (Element2.isElement(node3)) {
    let childrenHasChanged = node3.children.map((node4, i2) => normalizeNodeWithinComponentProp([node4, [...path3, i2]], editor, fieldOptions)).some((x) => x);
    if (fieldOptions.kind === "block") {
      if (node3.type === "component-block") {
        if (!fieldOptions.componentBlocks) {
          Transforms.unwrapNodes(editor, {
            at: path3
          });
          didNormalization = true;
        }
      } else {
        didNormalization = normalizeElementBasedOnDocumentFeatures([node3, path3], editor, fieldOptions.documentFeatures) || childrenHasChanged;
      }
    } else {
      didNormalization = normalizeInlineBasedOnLinks([node3, path3], editor, fieldOptions.documentFeatures.links);
    }
  }
  if (didNormalization === false) {
    alreadyNormalizedNodes.add(node3);
  }
  return didNormalization;
}
function canSchemaContainChildField(rootSchema) {
  const queue = /* @__PURE__ */ new Set([rootSchema]);
  for (const schema of queue) {
    if (schema.kind === "form") ;
    else if (schema.kind === "child") {
      return true;
    } else if (schema.kind === "array") {
      queue.add(schema.element);
    } else if (schema.kind === "object") {
      for (const innerProp of Object.values(schema.fields)) {
        queue.add(innerProp);
      }
    } else if (schema.kind === "conditional") {
      for (const innerProp of Object.values(schema.values)) {
        queue.add(innerProp);
      }
    } else {
      assertNever(schema);
    }
  }
  return false;
}
function doesSchemaOnlyEverContainASingleChildField(rootSchema) {
  const queue = /* @__PURE__ */ new Set([rootSchema]);
  let hasFoundChildField = false;
  for (const schema of queue) {
    if (schema.kind === "form") ;
    else if (schema.kind === "child") {
      if (hasFoundChildField) {
        return false;
      }
      hasFoundChildField = true;
    } else if (schema.kind === "array") {
      if (canSchemaContainChildField(schema.element)) {
        return false;
      }
    } else if (schema.kind === "object") {
      for (const innerProp of Object.values(schema.fields)) {
        queue.add(innerProp);
      }
    } else if (schema.kind === "conditional") {
      for (const innerProp of Object.values(schema.values)) {
        queue.add(innerProp);
      }
    } else {
      assertNever(schema);
    }
  }
  return hasFoundChildField;
}
function findArrayFieldsWithSingleChildField(schema, value) {
  const propPaths = [];
  traverseProps(schema, value, (schema2, value2, path3) => {
    if (schema2.kind === "array" && doesSchemaOnlyEverContainASingleChildField(schema2.element)) {
      propPaths.push([path3, schema2]);
    }
  });
  return propPaths;
}
function isEmptyChildFieldNode(element3) {
  const firstChild = element3.children[0];
  return element3.children.length === 1 && (element3.type === "component-inline-prop" && firstChild.type === void 0 && firstChild.text === "" || element3.type === "component-block-prop" && firstChild.type === "paragraph" && firstChild.children.length === 1 && firstChild.children[0].type === void 0 && firstChild.children[0].text === "");
}
function withComponentBlocks(blockComponents, editorDocumentFeatures, editor) {
  const memoizedGetDocumentFeaturesForChildField = weakMemoize((options) => {
    return getDocumentFeaturesForChildField(editorDocumentFeatures, options);
  });
  const {
    normalizeNode,
    deleteBackward,
    insertBreak
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const ancestorComponentBlock = getAncestorComponentBlock(editor);
      if (ancestorComponentBlock.isInside && Range.isCollapsed(editor.selection) && Editor.isStart(editor, editor.selection.anchor, ancestorComponentBlock.prop[1]) && ancestorComponentBlock.prop[1][ancestorComponentBlock.prop[1].length - 1] === 0) {
        Transforms.unwrapNodes(editor, {
          at: ancestorComponentBlock.componentBlock[1]
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const ancestorComponentBlock = getAncestorComponentBlock(editor);
    if (editor.selection && ancestorComponentBlock.isInside) {
      const {
        prop: [componentPropNode, componentPropPath],
        componentBlock: [componentBlockNode, componentBlockPath]
      } = ancestorComponentBlock;
      const isLastProp = componentPropPath[componentPropPath.length - 1] === componentBlockNode.children.length - 1;
      if (componentPropNode.type === "component-block-prop") {
        const [[paragraphNode, paragraphPath]] = Editor.nodes(editor, {
          match: (node3) => node3.type === "paragraph"
        });
        const isLastParagraph = paragraphPath[paragraphPath.length - 1] === componentPropNode.children.length - 1;
        if (Node2.string(paragraphNode) === "" && isLastParagraph) {
          if (isLastProp) {
            Transforms.moveNodes(editor, {
              at: paragraphPath,
              to: Path.next(ancestorComponentBlock.componentBlock[1])
            });
          } else {
            Transforms.move(editor, {
              distance: 1,
              unit: "line"
            });
            Transforms.removeNodes(editor, {
              at: paragraphPath
            });
          }
          return;
        }
      }
      if (componentPropNode.type === "component-inline-prop") {
        Editor.withoutNormalizing(editor, () => {
          const componentBlock = blockComponents[componentBlockNode.component];
          if (componentPropNode.propPath !== void 0 && componentBlock !== void 0) {
            const rootSchema = {
              kind: "object",
              fields: componentBlock.schema
            };
            const ancestorFields = getAncestorSchemas(rootSchema, componentPropNode.propPath, componentBlockNode.props);
            const idx = [...ancestorFields].reverse().findIndex((item2) => item2.kind === "array");
            if (idx !== -1) {
              const arrayFieldIdx = ancestorFields.length - 1 - idx;
              const arrayField = ancestorFields[arrayFieldIdx];
              assert(arrayField.kind === "array");
              const val = getValueAtPropPath(componentBlockNode.props, componentPropNode.propPath.slice(0, arrayFieldIdx));
              if (doesSchemaOnlyEverContainASingleChildField(arrayField.element)) {
                if (Node2.string(componentPropNode) === "" && val.length - 1 === componentPropNode.propPath[arrayFieldIdx]) {
                  Transforms.removeNodes(editor, {
                    at: componentPropPath
                  });
                  if (isLastProp) {
                    Transforms.insertNodes(editor, {
                      type: "paragraph",
                      children: [{
                        text: ""
                      }]
                    }, {
                      at: Path.next(componentBlockPath)
                    });
                    Transforms.select(editor, Path.next(componentBlockPath));
                  } else {
                    Transforms.move(editor, {
                      distance: 1,
                      unit: "line"
                    });
                  }
                } else {
                  insertBreak();
                }
                return;
              }
            }
          }
          Transforms.splitNodes(editor, {
            always: true
          });
          const splitNodePath = Path.next(componentPropPath);
          if (isLastProp) {
            Transforms.moveNodes(editor, {
              at: splitNodePath,
              to: Path.next(componentBlockPath)
            });
          } else {
            moveChildren(editor, splitNodePath, [...Path.next(splitNodePath), 0]);
            Transforms.removeNodes(editor, {
              at: splitNodePath
            });
          }
        });
        return;
      }
    }
    insertBreak();
  };
  editor.normalizeNode = (entry) => {
    const [node3, path3] = entry;
    if (node3.type === "component-inline-prop" && !node3.propPath && (node3.children.length !== 1 || !Text2.isText(node3.children[0]) || node3.children[0].text !== "")) {
      Transforms.removeNodes(editor, {
        at: path3
      });
      return;
    }
    if (node3.type === "component-block") {
      const componentBlock = blockComponents[node3.component];
      if (componentBlock) {
        const rootSchema = {
          kind: "object",
          fields: componentBlock.schema
        };
        const updatedProps = addMissingFields(node3.props, rootSchema);
        if (updatedProps !== node3.props) {
          Transforms.setNodes(editor, {
            props: updatedProps
          }, {
            at: path3
          });
          return;
        }
        for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(rootSchema, node3.props)) {
          if (node3.children.length === 1 && node3.children[0].type === "component-inline-prop" && node3.children[0].propPath === void 0) {
            break;
          }
          const nodesWithin = [];
          for (const [idx, childNode] of node3.children.entries()) {
            if ((childNode.type === "component-block-prop" || childNode.type === "component-inline-prop") && childNode.propPath !== void 0) {
              const subPath = childNode.propPath.concat();
              while (subPath.length) {
                if (typeof subPath.pop() === "number") break;
              }
              if (areArraysEqual(propPath, subPath)) {
                nodesWithin.push([idx, childNode]);
              }
            }
          }
          const arrVal = getValueAtPropPath(node3.props, propPath);
          const prevKeys = getKeysForArrayValue(arrVal);
          const prevKeysSet = new Set(prevKeys);
          const alreadyUsedIndicies = /* @__PURE__ */ new Set();
          const newVal = [];
          const newKeys = [];
          const getNewKey = () => {
            let key3 = getNewArrayElementKey();
            while (prevKeysSet.has(key3)) {
              key3 = getNewArrayElementKey();
            }
            return key3;
          };
          for (const [, node4] of nodesWithin) {
            const idxFromValue = node4.propPath[propPath.length];
            assert(typeof idxFromValue === "number");
            if (arrVal.length <= idxFromValue || alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node4)) {
              newVal.push(getInitialPropsValue(arrayField.element));
              newKeys.push(getNewKey());
            } else {
              alreadyUsedIndicies.add(idxFromValue);
              newVal.push(arrVal[idxFromValue]);
              newKeys.push(alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]);
            }
          }
          setKeysForArrayValue(newVal, newKeys);
          if (!areArraysEqual(arrVal, newVal)) {
            const transformedProps = replaceValueAtPropPath(rootSchema, node3.props, newVal, propPath);
            Transforms.setNodes(editor, {
              props: transformedProps
            }, {
              at: path3
            });
            for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()) {
              const newPropPath = [...nodeWithin.propPath];
              newPropPath[propPath.length] = idx;
              Transforms.setNodes(editor, {
                propPath: newPropPath
              }, {
                at: [...path3, idxInChildrenOfBlock]
              });
            }
            return;
          }
        }
        const missingKeys = new Map(findChildPropPaths(node3.props, componentBlock.schema).map((x) => [JSON.stringify(x.path), x.options.kind]));
        node3.children.forEach((node4) => {
          assert(node4.type === "component-block-prop" || node4.type === "component-inline-prop");
          missingKeys.delete(JSON.stringify(node4.propPath));
        });
        if (missingKeys.size) {
          Transforms.insertNodes(editor, [...missingKeys].map(([prop, kind]) => ({
            type: `component-${kind}-prop`,
            propPath: prop ? JSON.parse(prop) : prop,
            children: [{
              text: ""
            }]
          })), {
            at: [...path3, node3.children.length]
          });
          return;
        }
        const foundProps = /* @__PURE__ */ new Set();
        const stringifiedInlinePropPaths = {};
        findChildPropPaths(node3.props, blockComponents[node3.component].schema).forEach((x, index4) => {
          stringifiedInlinePropPaths[JSON.stringify(x.path)] = {
            options: x.options,
            index: index4
          };
        });
        for (const [index4, childNode] of node3.children.entries()) {
          if (
            // children that are not these will be handled by
            // the generic allowedChildren normalization
            childNode.type !== "component-inline-prop" && childNode.type !== "component-block-prop"
          ) {
            continue;
          }
          const childPath = [...path3, index4];
          const stringifiedPropPath = JSON.stringify(childNode.propPath);
          if (stringifiedInlinePropPaths[stringifiedPropPath] === void 0) {
            Transforms.removeNodes(editor, {
              at: childPath
            });
            return;
          }
          if (foundProps.has(stringifiedPropPath)) {
            Transforms.removeNodes(editor, {
              at: childPath
            });
            return;
          }
          foundProps.add(stringifiedPropPath);
          const propInfo = stringifiedInlinePropPaths[stringifiedPropPath];
          const expectedIndex = propInfo.index;
          if (index4 !== expectedIndex) {
            Transforms.moveNodes(editor, {
              at: childPath,
              to: [...path3, expectedIndex]
            });
            return;
          }
          const expectedChildNodeType = `component-${propInfo.options.kind}-prop`;
          if (childNode.type !== expectedChildNodeType) {
            Transforms.setNodes(editor, {
              type: expectedChildNodeType
            }, {
              at: childPath
            });
            return;
          }
          const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);
          if (normalizeNodeWithinComponentProp([childNode, childPath], editor, documentFeatures)) {
            return;
          }
        }
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
function addMissingFields(value, schema) {
  if (schema.kind === "child" || schema.kind === "form") {
    return value;
  }
  if (schema.kind === "conditional") {
    const conditionalValue = value;
    const updatedInnerValue = addMissingFields(conditionalValue.value, schema.values[conditionalValue.discriminant.toString()]);
    if (updatedInnerValue === conditionalValue.value) {
      return value;
    }
    return {
      discriminant: conditionalValue.discriminant,
      value: updatedInnerValue
    };
  }
  if (schema.kind === "array") {
    const arrValue = value;
    const newArrValue = arrValue.map((x) => addMissingFields(x, schema.element));
    if (areArraysEqual(arrValue, newArrValue)) {
      return value;
    }
    return newArrValue;
  }
  if (schema.kind === "object") {
    const objectValue = value;
    let hasChanged = false;
    const newObjectValue = {};
    for (const [key3, innerSchema] of Object.entries(schema.fields)) {
      const innerValue = objectValue[key3];
      if (innerValue === void 0) {
        hasChanged = true;
        newObjectValue[key3] = getInitialPropsValue(innerSchema);
        continue;
      }
      const newInnerValue = addMissingFields(innerValue, innerSchema);
      if (newInnerValue !== innerValue) {
        hasChanged = true;
      }
      newObjectValue[key3] = newInnerValue;
    }
    if (hasChanged) {
      return newObjectValue;
    }
    return value;
  }
  assertNever(schema);
}
function ComponentInlineProp(props) {
  return (0, import_jsx_runtime70.jsx)("span", {
    ...props.attributes,
    children: props.children
  });
}
function getInitialValue(type, componentBlock) {
  const props = getInitialPropsValue({
    kind: "object",
    fields: componentBlock.schema
  });
  return {
    type: "component-block",
    component: type,
    props,
    children: findChildPropPaths(props, componentBlock.schema).map((x) => ({
      type: `component-${x.options.kind}-prop`,
      propPath: x.path,
      children: [x.options.kind === "block" ? {
        type: "paragraph",
        children: [{
          text: ""
        }]
      } : {
        text: ""
      }]
    }))
  };
}
function insertComponentBlock(editor, componentBlocks, componentBlock) {
  const node3 = getInitialValue(componentBlock, componentBlocks[componentBlock]);
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, node3);
  const componentBlockEntry = Editor.above(editor, {
    match: (node4) => node4.type === "component-block"
  });
  if (componentBlockEntry) {
    const start2 = Editor.start(editor, componentBlockEntry[1]);
    Transforms.setSelection(editor, {
      anchor: start2,
      focus: start2
    });
  }
}
var ComponentBlocksElement = ({
  attributes,
  children,
  element: __elementToGetPath
}) => {
  const editor = useSlateStatic();
  const [currentElement, setElement] = useElementWithSetNodes(editor, __elementToGetPath);
  const blockComponents = useDocumentEditorConfig().componentBlocks;
  const componentBlock = blockComponents[currentElement.component];
  const propsWithChildFields = (0, import_react55.useMemo)(() => {
    if (!componentBlock) return;
    const blockChildrenByPath = /* @__PURE__ */ new Map();
    for (const child of currentElement.children) {
      if (child.type === "component-block-prop" && child.propPath) {
        blockChildrenByPath.set(JSON.stringify(child.propPath), child.children);
      }
    }
    if (!blockChildrenByPath.size) return currentElement.props;
    return transformProps({
      kind: "object",
      fields: componentBlock.schema
    }, currentElement.props, {
      child(schema, value, propPath) {
        if (schema.options.kind === "block") {
          const key3 = JSON.stringify(propPath);
          const children2 = blockChildrenByPath.get(key3);
          if (children2) {
            return children2.map(cloneDescendent);
          }
        }
        return value;
      }
    });
  }, [componentBlock, currentElement]);
  const elementToGetPathRef = (0, import_react55.useRef)({
    __elementToGetPath,
    currentElement,
    propsWithChildFields
  });
  (0, import_react55.useEffect)(() => {
    elementToGetPathRef.current = {
      __elementToGetPath,
      currentElement,
      propsWithChildFields
    };
  });
  const onRemove = useEventCallback(() => {
    const path3 = ReactEditor.findPath(editor, __elementToGetPath);
    Transforms.removeNodes(editor, {
      at: path3
    });
  });
  const onPropsChange = (0, import_react55.useCallback)((cb, ignoreChildFields) => {
    const prevProps = elementToGetPathRef.current.propsWithChildFields;
    updateComponentBlockElementProps(editor, componentBlock, prevProps, cb(prevProps), ReactEditor.findPath(editor, elementToGetPathRef.current.__elementToGetPath), setElement, ignoreChildFields);
  }, [setElement, componentBlock, editor]);
  const getToolbarPreviewProps = (0, import_react55.useMemo)(() => {
    if (!componentBlock) {
      return () => {
        throw new Error("expected component block to exist when called");
      };
    }
    return createGetPreviewProps({
      kind: "object",
      fields: componentBlock.schema
    }, (cb) => onPropsChange(cb, false), () => void 0);
  }, [componentBlock, onPropsChange]);
  if (!componentBlock) {
    return (0, import_jsx_runtime70.jsxs)("div", {
      style: {
        border: "red 4px solid",
        padding: 8
      },
      children: [(0, import_jsx_runtime70.jsx)("pre", {
        contentEditable: false,
        style: {
          userSelect: "none"
        },
        children: `The block "${currentElement.component}" no longer exists.

Props:

${JSON.stringify(currentElement.props, null, 2)}

Content:`
      }), children]
    });
  }
  const toolbarPreviewProps = getToolbarPreviewProps(propsWithChildFields);
  const renderedBlock = (0, import_jsx_runtime70.jsx)(ComponentBlockRender, {
    children,
    componentBlock,
    element: currentElement,
    onChange: onPropsChange,
    onRemove
  });
  return componentBlock.chromeless ? (0, import_jsx_runtime70.jsx)(ChromelessComponentBlockElement, {
    element: __elementToGetPath,
    attributes,
    renderedBlock,
    componentBlock,
    onRemove,
    previewProps: toolbarPreviewProps
  }) : (0, import_jsx_runtime70.jsx)(ChromefulComponentBlockElement, {
    attributes,
    children,
    componentBlock,
    onRemove,
    previewProps: toolbarPreviewProps,
    renderedBlock,
    elementProps: currentElement.props
  });
};
function insertDivider(editor) {
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
    type: "divider",
    children: [{
      text: ""
    }]
  });
  Editor.insertNode(editor, {
    type: "paragraph",
    children: [{
      text: ""
    }]
  });
}
var DividerButton = () => {
  const {
    editor,
    dividers: {
      isDisabled
    }
  } = useToolbarState();
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(ActionButton, {
    prominence: "low",
    isDisabled,
    onPress: () => {
      insertDivider(editor);
    },
    children: (0, import_jsx_runtime70.jsx)(Icon, {
      src: minusIcon
    })
  }), [editor, isDisabled]);
};
var dividerButton = (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
  delay: 200,
  children: [(0, import_jsx_runtime70.jsx)(DividerButton, {}), (0, import_jsx_runtime70.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime70.jsx)(Text, {
      children: "Divider"
    }), (0, import_jsx_runtime70.jsx)(Kbd, {
      children: "---"
    })]
  })]
});
function DividerElement({
  attributes,
  children
}) {
  const selected = useSelected();
  return (0, import_jsx_runtime70.jsxs)("div", {
    ...attributes,
    style: {
      caretColor: "transparent"
    },
    children: [(0, import_jsx_runtime70.jsx)("hr", {
      style: {
        backgroundColor: selected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle
      }
    }), children]
  });
}
var LayoutContainer = ({
  attributes,
  children,
  element: element3
}) => {
  const editor = useSlateStatic();
  const layout = element3.layout;
  const layoutOptions = useDocumentEditorConfig().documentFeatures.layouts;
  const currentLayoutIndex = layoutOptions.findIndex((x) => x.toString() === layout.toString());
  return (0, import_jsx_runtime70.jsx)("div", {
    className: blockElementSpacing,
    ...attributes,
    children: (0, import_jsx_runtime70.jsxs)(BlockPopoverTrigger, {
      element: element3,
      children: [(0, import_jsx_runtime70.jsx)("div", {
        className: css({
          columnGap: tokenSchema.size.space.regular,
          display: "grid"
        }),
        style: {
          gridTemplateColumns: layout.map((x) => `${x}fr`).join(" ")
        },
        children
      }), (0, import_jsx_runtime70.jsx)(BlockPopover, {
        children: (0, import_jsx_runtime70.jsxs)(Flex, {
          padding: "regular",
          gap: "regular",
          children: [(0, import_jsx_runtime70.jsx)(_ActionGroup, {
            selectionMode: "single",
            prominence: "low",
            density: "compact",
            onAction: (key3) => {
              const path3 = ReactEditor.findPath(editor, element3);
              const layoutOption = layoutOptions[key3];
              Transforms.setNodes(editor, {
                type: "layout",
                layout: layoutOption
              }, {
                at: path3
              });
              ReactEditor.focus(editor);
            },
            selectedKeys: currentLayoutIndex !== -1 ? [currentLayoutIndex.toString()] : [],
            children: layoutOptions.map((layoutOption, i2) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
              children: makeLayoutIcon(layoutOption)
            }, i2))
          }), (0, import_jsx_runtime70.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => {
                const path3 = ReactEditor.findPath(editor, element3);
                Transforms.removeNodes(editor, {
                  at: path3
                });
              },
              children: (0, import_jsx_runtime70.jsx)(Icon, {
                src: trash2Icon
              })
            }), (0, import_jsx_runtime70.jsx)(Tooltip, {
              tone: "critical",
              children: "Remove"
            })]
          })]
        })
      })]
    })
  });
};
var LayoutArea = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime70.jsx)("div", {
    className: css({
      borderColor: tokenSchema.color.border.neutral,
      borderRadius: tokenSchema.size.radius.regular,
      borderStyle: "dashed",
      borderWidth: tokenSchema.size.border.regular,
      padding: tokenSchema.size.space.medium
    }),
    ...attributes,
    children
  });
};
var insertLayout = (editor, layout) => {
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, [{
    type: "layout",
    layout,
    children: [{
      type: "layout-area",
      children: [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }]
    }]
  }]);
  const layoutEntry = Editor.above(editor, {
    match: (x) => x.type === "layout"
  });
  if (layoutEntry) {
    Transforms.select(editor, [...layoutEntry[1], 0]);
  }
};
function makeLayoutIcon(ratios) {
  const size4 = 16;
  const element3 = (0, import_jsx_runtime70.jsx)("div", {
    role: "img",
    className: css({
      display: "grid",
      gridTemplateColumns: ratios.map((r2) => `${r2}fr`).join(" "),
      gap: 2,
      width: size4,
      height: size4
    }),
    children: ratios.map((_, i2) => {
      return (0, import_jsx_runtime70.jsx)("div", {
        className: css({
          backgroundColor: "currentcolor",
          borderRadius: 1
        })
      }, i2);
    })
  });
  return element3;
}
var layoutsIcon = (0, import_jsx_runtime70.jsx)(Icon, {
  src: columnsIcon
});
var LayoutsButton = ({
  layouts
}) => {
  const {
    editor,
    layouts: {
      isSelected
    }
  } = useToolbarState();
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
      prominence: "low",
      isSelected,
      onPress: () => {
        if (isElementActive(editor, "layout")) {
          Transforms.unwrapNodes(editor, {
            match: (node3) => node3.type === "layout"
          });
        } else {
          insertLayout(editor, layouts[0]);
        }
        ReactEditor.focus(editor);
      },
      children: layoutsIcon
    }), (0, import_jsx_runtime70.jsx)(Tooltip, {
      children: "Layouts"
    })]
  }), [editor, isSelected, layouts]);
};
var toggleList$1 = (editor, format2) => {
  const listAbove = getListTypeAbove(editor);
  const isActive = isElementActive(editor, format2) && (listAbove === "none" || listAbove === format2);
  Editor.withoutNormalizing(editor, () => {
    Transforms.unwrapNodes(editor, {
      match: isListNode,
      split: true,
      mode: isActive ? "all" : "lowest"
    });
    if (!isActive) {
      Transforms.wrapNodes(editor, {
        type: format2,
        children: []
      }, {
        match: (x) => x.type !== "list-item-content" && isBlock(x)
      });
    }
  });
};
function ListButtons$1(props) {
  const {
    editor,
    lists
  } = useToolbarState();
  return (0, import_react55.useMemo)(() => {
    const disabledKeys = [];
    if (lists.ordered.isDisabled) disabledKeys.push("ordered");
    if (lists.unordered.isDisabled) disabledKeys.push("unordered");
    const selectedKeys = [];
    if (lists.ordered.isSelected) selectedKeys.push("ordered");
    if (lists.unordered.isSelected) selectedKeys.push("unordered");
    return (0, import_jsx_runtime70.jsx)(_ActionGroup, {
      flexShrink: 0,
      "aria-label": "Lists",
      selectionMode: "single",
      buttonLabelBehavior: "hide",
      density: "compact",
      prominence: "low",
      summaryIcon: (0, import_jsx_runtime70.jsx)(Icon, {
        src: listIcon
      }),
      selectedKeys,
      disabledKeys,
      onAction: (key3) => {
        const format2 = `${key3}-list`;
        toggleList$1(editor, format2);
        ReactEditor.focus(editor);
      },
      children: [props.lists.unordered && (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: "Bullet List (- )",
        children: [(0, import_jsx_runtime70.jsx)(Icon, {
          src: listIcon
        }), (0, import_jsx_runtime70.jsx)(Text, {
          children: "Bullet List"
        }), (0, import_jsx_runtime70.jsx)(Kbd, {
          children: "-⎵"
        })]
      }, "unordered"), props.lists.ordered && (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: "Numbered List (1.)",
        children: [(0, import_jsx_runtime70.jsx)(Icon, {
          src: listOrderedIcon
        }), (0, import_jsx_runtime70.jsx)(Text, {
          children: "Numbered List"
        }), (0, import_jsx_runtime70.jsx)(Kbd, {
          children: "1.⎵"
        })]
      }, "ordered")].filter((x) => x !== false)
    });
  }, [editor, lists.ordered.isDisabled, lists.ordered.isSelected, lists.unordered.isDisabled, lists.unordered.isSelected, props.lists.ordered, props.lists.unordered]);
}
function nestList(editor) {
  const block4 = Editor.above(editor, {
    match: isBlock
  });
  if (!block4 || block4[0].type !== "list-item-content") {
    return false;
  }
  const listItemPath = Path.parent(block4[1]);
  if (listItemPath[listItemPath.length - 1] === 0) {
    return false;
  }
  const previousListItemPath = Path.previous(listItemPath);
  const previousListItemNode = Node2.get(editor, previousListItemPath);
  if (previousListItemNode.children.length !== 1) {
    Transforms.moveNodes(editor, {
      at: listItemPath,
      to: [...previousListItemPath, previousListItemNode.children.length - 1, previousListItemNode.children[previousListItemNode.children.length - 1].children.length]
    });
    return true;
  }
  const type = Editor.parent(editor, Path.parent(block4[1]))[0].type;
  Editor.withoutNormalizing(editor, () => {
    Transforms.wrapNodes(editor, {
      type,
      children: []
    }, {
      at: listItemPath
    });
    Transforms.moveNodes(editor, {
      to: [...previousListItemPath, previousListItemNode.children.length],
      at: listItemPath
    });
  });
  return true;
}
function unnestList(editor) {
  const block4 = Editor.above(editor, {
    match: isBlock
  });
  if (block4 && block4[0].type === "list-item-content") {
    Transforms.unwrapNodes(editor, {
      match: isListNode,
      split: true
    });
    return true;
  }
  return false;
}
function getUploadedFileObject(accept) {
  return new Promise((resolve3) => {
    const input = document.createElement("input");
    input.type = "file";
    input.style.display = "none";
    input.accept = accept;
    input.onchange = () => {
      var _input$files;
      const file = (_input$files = input.files) === null || _input$files === void 0 ? void 0 : _input$files[0];
      if (file) {
        resolve3(file);
      }
    };
    document.body.appendChild(input);
    input.click();
  });
}
async function getUploadedFile(accept) {
  const file = await getUploadedFileObject(accept);
  if (!file) return void 0;
  return {
    content: new Uint8Array(await file.arrayBuffer()),
    filename: file.name
  };
}
function getUploadedImage() {
  return getUploadedFile("image/*");
}
function useObjectURL(data2, contentType) {
  const [url, setUrl] = (0, import_react55.useState)(null);
  (0, import_react55.useEffect)(() => {
    if (data2) {
      const url2 = URL.createObjectURL(new Blob([data2], {
        type: contentType
      }));
      setUrl(url2);
      return () => URL.revokeObjectURL(url2);
    } else {
      setUrl(null);
    }
  }, [contentType, data2]);
  return url;
}
function ImageFieldInput(props) {
  var _props$validation, _props$validation2;
  const {
    value
  } = props;
  const [blurred, onBlur] = (0, import_react55.useReducer)(() => true, false);
  const isInEditor = useIsInDocumentEditor();
  const objectUrl = useObjectURL(value === null ? null : value.data, (value === null || value === void 0 ? void 0 : value.extension) === "svg" ? "image/svg+xml" : void 0);
  const labelId = (0, import_react55.useId)();
  const descriptionId = (0, import_react55.useId)();
  return (0, import_jsx_runtime70.jsxs)(Flex, {
    "aria-describedby": props.description ? descriptionId : void 0,
    "aria-labelledby": labelId,
    direction: "column",
    gap: "medium",
    role: "group",
    children: [(0, import_jsx_runtime70.jsx)(FieldLabel, {
      id: labelId,
      elementType: "span",
      isRequired: (_props$validation = props.validation) === null || _props$validation === void 0 ? void 0 : _props$validation.isRequired,
      children: props.label
    }), props.description && (0, import_jsx_runtime70.jsx)(Text, {
      size: "small",
      color: "neutralSecondary",
      id: descriptionId,
      children: props.description
    }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
        onPress: async () => {
          const image3 = await getUploadedImage();
          if (image3) {
            var _image$filename$match;
            const extension2 = (_image$filename$match = image3.filename.match(/\.([^.]+$)/)) === null || _image$filename$match === void 0 ? void 0 : _image$filename$match[1];
            if (extension2) {
              props.onChange({
                data: image3.content,
                extension: extension2,
                filename: image3.filename
              });
            }
          }
        },
        children: "Choose file"
      }), value !== null && (0, import_jsx_runtime70.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => {
          props.onChange(null);
          onBlur();
        },
        children: "Remove"
      })]
    }), objectUrl && (0, import_jsx_runtime70.jsx)(Box, {
      alignSelf: "start",
      backgroundColor: "canvas",
      borderRadius: "regular",
      border: "neutral",
      padding: "regular",
      children: (0, import_jsx_runtime70.jsx)("img", {
        src: objectUrl,
        alt: "",
        style: {
          display: "block",
          maxHeight: tokenSchema.size.alias.singleLineWidth,
          maxWidth: "100%"
        }
      })
    }), isInEditor && value !== null && (0, import_jsx_runtime70.jsx)(TextField, {
      label: "Filename",
      onChange: (filename) => {
        props.onChange({
          ...value,
          filename
        });
      },
      value: value.filename
    }), (props.forceValidation || blurred) && ((_props$validation2 = props.validation) === null || _props$validation2 === void 0 ? void 0 : _props$validation2.isRequired) && value === null && (0, import_jsx_runtime70.jsxs)(FieldMessage, {
      children: [props.label, " is required"]
    })]
  });
}
var ImageElement = ({
  attributes,
  children,
  element: __elementForGettingPath
}) => {
  const [dialogOpen, setDialogOpen] = (0, import_react55.useState)(false);
  const [aspectRatio, setAspectRatio] = (0, import_react55.useState)();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const editor = useSlateStatic();
  const [currentElement, setNode] = useElementWithSetNodes(editor, __elementForGettingPath);
  const objectUrl = useObjectURL(currentElement.src.content, currentElement.src.filename.endsWith(".svg") ? "image/svg+xml" : void 0);
  const activePopoverElement = useActiveBlockPopover();
  const selected = activePopoverElement === __elementForGettingPath;
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsxs)(BlockWrapper$1, {
      attributes,
      children: [children, (0, import_jsx_runtime70.jsxs)(BlockPopoverTrigger, {
        element: __elementForGettingPath,
        children: [(0, import_jsx_runtime70.jsx)("div", {
          style: {
            alignItems: "center",
            display: "flex",
            flexDirection: "column"
          },
          children: (0, import_jsx_runtime70.jsx)(NotEditable, {
            children: (0, import_jsx_runtime70.jsx)("img", {
              ...attributes,
              src: objectUrl,
              alt: currentElement.alt,
              "data-selected": selected,
              onLoad: (e3) => {
                const target = e3.target;
                setAspectRatio(target.width / target.height);
              },
              className: css({
                boxSizing: "border-box",
                borderRadius: tokenSchema.size.radius.regular,
                display: "block",
                maxHeight: tokenSchema.size.scale[3600],
                maxWidth: "100%",
                transition: transition("box-shadow"),
                "&[data-selected=true]": {
                  boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.alias.borderSelected}`
                }
              })
            })
          })
        }), (0, import_jsx_runtime70.jsx)(BlockPopover, {
          hideArrow: true,
          children: (0, import_jsx_runtime70.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime70.jsxs)(Flex, {
              gap: "small",
              children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: () => setDialogOpen(true),
                  children: (0, import_jsx_runtime70.jsx)(Icon, {
                    src: editIcon
                  })
                }), (0, import_jsx_runtime70.jsx)(Tooltip, {
                  children: stringFormatter.format("edit")
                })]
              }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: async () => {
                    const src = await getUploadedImage();
                    if (src) {
                      setNode({
                        src
                      });
                    }
                  },
                  children: (0, import_jsx_runtime70.jsx)(Icon, {
                    src: fileUpIcon
                  })
                }), (0, import_jsx_runtime70.jsx)(Tooltip, {
                  children: "Choose file"
                })]
              })]
            }), (0, import_jsx_runtime70.jsx)(Divider, {
              orientation: "vertical"
            }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, __elementForGettingPath)
                  });
                },
                children: (0, import_jsx_runtime70.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime70.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      }, aspectRatio)]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setDialogOpen(false);
        focusWithPreviousSelection(editor);
      },
      children: dialogOpen && (0, import_jsx_runtime70.jsx)(ImageDialog$1, {
        alt: currentElement.alt,
        title: currentElement.title,
        filename: currentElement.src.filename,
        onSubmit: ({
          alt,
          filename,
          title
        }) => {
          setNode({
            alt,
            title,
            src: {
              content: currentElement.src.content,
              filename
            }
          });
        }
      })
    })]
  });
};
function ImageDialog$1(props) {
  const {
    images
  } = useDocumentEditorConfig().documentFeatures;
  if (!images) {
    throw new Error("unexpected image rendered when images are disabled");
  }
  const schema = (0, import_react55.useMemo)(() => object(images.schema), [images]);
  const [state2, setState] = (0, import_react55.useState)({
    alt: props.alt,
    title: props.title
  });
  const previewProps = (0, import_react55.useMemo)(() => createGetPreviewProps(schema, setState, () => void 0), [schema])(state2);
  const [filenameWithoutExtension, filenameExtension] = splitFilename$1(props.filename);
  const [forceValidation, setForceValidation] = (0, import_react55.useState)(false);
  let [fileName, setFileName] = (0, import_react55.useState)(filenameWithoutExtension);
  let [fileNameTouched, setFileNameTouched] = (0, import_react55.useState)(false);
  let {
    dismiss
  } = useDialogContainer();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime70.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime70.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        setForceValidation(true);
        if (fileName && clientSideValidateProp(schema, state2, void 0)) {
          dismiss();
          props.onSubmit({
            alt: state2.alt,
            title: state2.title,
            filename: [fileName, filenameExtension].join(".")
          });
        }
      },
      children: [(0, import_jsx_runtime70.jsx)(Heading, {
        children: "Image details"
      }), (0, import_jsx_runtime70.jsx)(Content, {
        children: (0, import_jsx_runtime70.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          children: [(0, import_jsx_runtime70.jsx)(TextField, {
            label: "File name",
            onChange: setFileName,
            onBlur: () => setFileNameTouched(true),
            value: fileName,
            isRequired: true,
            errorMessage: (fileNameTouched || forceValidation) && !fileName ? "Please provide a file name." : void 0,
            endElement: filenameExtension ? (0, import_jsx_runtime70.jsx)(Flex, {
              alignItems: "center",
              justifyContent: "center",
              paddingEnd: "regular",
              children: (0, import_jsx_runtime70.jsxs)(Text, {
                color: "neutralTertiary",
                children: [".", filenameExtension]
              })
            }) : null
          }), (0, import_jsx_runtime70.jsx)(FormValueContentFromPreviewProps, {
            forceValidation,
            autoFocus: true,
            ...previewProps
          })]
        })
      }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime70.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime70.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
function splitFilename$1(filename) {
  const dotIndex = filename.lastIndexOf(".");
  if (dotIndex === -1) {
    return [filename, ""];
  }
  return [filename.substring(0, dotIndex), filename.substring(dotIndex + 1)];
}
var _imageIcon = (0, import_jsx_runtime70.jsx)(Icon, {
  src: imageIcon
});
function ImageButton() {
  const editor = useSlateStatic();
  return (0, import_jsx_runtime70.jsx)(import_jsx_runtime70.Fragment, {
    children: (0, import_jsx_runtime70.jsx)(ActionButton, {
      prominence: "low",
      onPress: async () => {
        const src = await getUploadedImage();
        if (src) {
          Transforms.insertNodes(editor, {
            type: "image",
            src,
            alt: "",
            title: "",
            children: [{
              text: ""
            }]
          });
        }
      },
      children: _imageIcon
    })
  });
}
var imageButton = (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime70.jsx)(ImageButton, {}), (0, import_jsx_runtime70.jsx)(Tooltip, {
    children: (0, import_jsx_runtime70.jsx)(Text, {
      children: "Image"
    })
  })]
});
function withImages(editor) {
  const {
    insertData
  } = editor;
  editor.insertData = (data2) => {
    const images = Array.from(data2.files).filter((x) => x.type.startsWith("image/"));
    if (images.length) {
      Promise.all(images.map(async (file) => ({
        name: file.name,
        data: new Uint8Array(await file.arrayBuffer())
      }))).then((images2) => {
        insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
          type: "image",
          src: {
            content: images2[0].data,
            filename: images2[0].name
          },
          alt: "",
          title: "",
          children: [{
            text: ""
          }]
        });
      });
      return;
    }
    insertData(data2);
  };
  return editor;
}
function order(a, b) {
  return {
    start: Math.min(a, b),
    end: Math.max(a, b)
  };
}
function getRelativeRowPath(hasHead, rowIndex) {
  return hasHead ? rowIndex === 0 ? [0, 0] : [1, rowIndex - 1] : [0, rowIndex];
}
function getSelectedTableArea(editor) {
  var _Editor$above, _editor$selection, _Editor$above2, _editor$selection2;
  const anchor = (_Editor$above = Editor.above(editor, {
    match: nodeTypeMatcher("table-cell"),
    at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor.path
  })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];
  const focus = (_Editor$above2 = Editor.above(editor, {
    match: nodeTypeMatcher("table-cell"),
    at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.focus.path
  })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];
  const table3 = Editor.above(editor, {
    match: nodeTypeMatcher("table")
  });
  if (editor.selection && table3 && Element2.isElement(table3[0].children[0]) && anchor && focus && Path.equals(anchor.slice(0, -3), focus.slice(0, -3))) {
    const [start2, end] = Editor.edges(editor, editor.selection);
    return {
      tablePath: table3[1],
      table: table3[0],
      singleCell: Path.equals(anchor, focus) ? Point.equals(Editor.start(editor, anchor), start2) && Point.equals(Editor.end(editor, anchor), end) && !Point.equals(start2, end) ? "selected" : "not-selected" : "many",
      row: order(anchor[anchor.length - 2] + anchor[anchor.length - 3], focus[focus.length - 2] + focus[anchor.length - 3]),
      column: order(anchor[anchor.length - 1], focus[focus.length - 1])
    };
  }
}
var cell = (header) => ({
  type: "table-cell",
  ...header ? {
    header: true
  } : {},
  children: [{
    type: "paragraph",
    children: [{
      text: ""
    }]
  }]
});
function cloneDescendant(node3) {
  if (Text2.isText(node3)) return {
    ...node3
  };
  return {
    ...node3,
    children: node3.children.map(cloneDescendant)
  };
}
function withTable(editor) {
  const {
    deleteFragment,
    normalizeNode,
    getFragment,
    insertFragment,
    deleteBackward
  } = editor;
  editor.insertFragment = (fragment) => {
    const selectedTableArea = getSelectedTableArea(editor);
    if (!selectedTableArea || fragment.length !== 1 || fragment[0].type !== "table") {
      insertFragment(fragment);
      return;
    }
    const newRows = fragment[0].children.flatMap((child) => child.type === "table-head" || child.type === "table-body" ? child.children : []);
    if (!newRows.every(nodeTypeMatcher("table-row"))) {
      insertFragment(fragment);
      return;
    }
    let {
      row,
      column,
      tablePath,
      table: table3
    } = selectedTableArea;
    const existingBody = selectedTableArea.table.children[selectedTableArea.table.children.length === 1 ? 0 : 1];
    if (newRows[0].type !== "table-row" || existingBody.type !== "table-body" || existingBody.children[0].type !== "table-row") {
      insertFragment(fragment);
      return;
    }
    const hasHead = table3.children[0].type === "table-head";
    if (selectedTableArea.singleCell !== "many") {
      row = {
        start: row.start,
        end: Math.min(row.start + newRows.length - 1, existingBody.children.length - 1 + (hasHead ? 1 : 0))
      };
      column = {
        start: column.start,
        end: Math.min(column.start + newRows[0].children.length - 1, existingBody.children[0].children.length - 1)
      };
    }
    Editor.withoutNormalizing(editor, () => {
      for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
        const newRow = newRows[(rowIndex - row.start) % newRows.length];
        for (let cellIndex = column.start; cellIndex <= column.end; cellIndex++) {
          const relativeCellPath = [...getRelativeRowPath(hasHead, rowIndex), cellIndex];
          const cell2 = Node2.get(table3, relativeCellPath);
          const newCell = newRow.children[(cellIndex - column.start) % newRow.children.length];
          if (cell2.type !== "table-cell" || newCell.type !== "table-cell") {
            continue;
          }
          const cellPath = [...tablePath, ...relativeCellPath];
          for (const childIdx of [...cell2.children.keys()].reverse()) {
            Transforms.removeNodes(editor, {
              at: [...cellPath, childIdx]
            });
          }
          Transforms.insertNodes(editor, newCell.children.map(cloneDescendant), {
            at: [...cellPath, 0]
          });
        }
      }
      Transforms.setSelection(editor, {
        anchor: Editor.start(editor, [...tablePath, ...getRelativeRowPath(hasHead, row.start), column.start]),
        focus: Editor.end(editor, [...tablePath, ...getRelativeRowPath(hasHead, row.end), column.end])
      });
    });
  };
  editor.deleteBackward = (unit) => {
    if (editor.selection && Range.isCollapsed(editor.selection) && editor.selection.anchor.offset === 0) {
      const tableCell = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell")
      });
      if (tableCell && tableCell[0].children[0].type === "paragraph" && tableCell[0].children[0].children[0].type === void 0 && Path.equals(editor.selection.anchor.path, [...tableCell[1], 0, 0])) {
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.getFragment = () => {
    const selectedTableArea = getSelectedTableArea(editor);
    if (selectedTableArea && selectedTableArea.singleCell !== "not-selected") {
      var _table$children$;
      const {
        table: table3
      } = selectedTableArea;
      const first = table3.children[0].type === "table-head" || table3.children[0].type === "table-body" ? table3.children[0] : void 0;
      if (!first) {
        return getFragment();
      }
      const second = ((_table$children$ = table3.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === "table-body" ? table3.children[1] : void 0;
      const body = second || first;
      const hasHead = first.type === "table-head";
      const isSelectionInHead = selectedTableArea.row.start === 0 && !!second;
      const columnLength = selectedTableArea.column.end - selectedTableArea.column.start + 1;
      return [{
        type: "table",
        children: [...isSelectionInHead ? [{
          type: "table-head",
          children: [{
            type: "table-row",
            children: Array.from({
              length: columnLength
            }).map((_, columnIndex) => first.children[0].children[columnIndex + selectedTableArea.column.start])
          }]
        }] : [], {
          type: "table-body",
          children: Array.from({
            length: selectedTableArea.row.end - selectedTableArea.row.start + (isSelectionInHead ? 0 : 1)
          }).map((_, rowIndex) => ({
            type: "table-row",
            children: Array.from({
              length: columnLength
            }).map((_2, columnIndex) => body.children[rowIndex + selectedTableArea.row.start - (hasHead && !isSelectionInHead ? 1 : 0)].children[columnIndex + selectedTableArea.column.start])
          }))
        }]
      }];
    }
    return getFragment();
  };
  editor.deleteFragment = (direction) => {
    if (!editor.selection || Range.isCollapsed(editor.selection)) {
      deleteFragment(direction);
      return;
    }
    const selectedTableArea = getSelectedTableArea(editor);
    if (!selectedTableArea || selectedTableArea.singleCell === "not-selected") {
      deleteFragment(direction);
      return;
    }
    const headOrBody = selectedTableArea.table.children[0];
    if (!Element2.isElement(headOrBody) || !Element2.isElement(headOrBody.children[0])) {
      deleteFragment(direction);
      return;
    }
    const maxRowIdx = selectedTableArea.table.children.reduce((sum, headOrBody2) => sum + (headOrBody2.type === "table-head" || headOrBody2.type === "table-body" ? headOrBody2.children.length : 0), 0) - 1;
    const {
      row,
      column,
      tablePath
    } = selectedTableArea;
    const hasWholeColumnSelected = row.start === 0 && row.end === maxRowIdx;
    const hasWholeRowSelected = column.start === 0 && column.end === headOrBody.children[0].children.length - 1;
    if (hasWholeColumnSelected && hasWholeRowSelected) {
      Transforms.removeNodes(editor, {
        at: tablePath
      });
      return;
    }
    const hasHead = headOrBody.type === "table-head";
    if (hasWholeRowSelected) {
      Editor.withoutNormalizing(editor, () => {
        for (let i2 = row.end; i2 >= row.start; i2--) {
          if (hasHead) {
            if (i2 === 0) {
              Transforms.removeNodes(editor, {
                at: [...tablePath, 0]
              });
              continue;
            }
            Transforms.removeNodes(editor, {
              at: [...tablePath, 1, i2 - 1]
            });
            continue;
          }
          Transforms.removeNodes(editor, {
            at: [...tablePath, 0, i2]
          });
        }
      });
      return;
    }
    if (hasWholeColumnSelected) {
      Editor.withoutNormalizing(editor, () => {
        for (let i2 = column.end; i2 >= column.start; i2--) {
          for (let rowIdx = 0; rowIdx <= maxRowIdx; rowIdx++) {
            Transforms.removeNodes(editor, {
              at: [...tablePath, ...getRelativeRowPath(hasHead, rowIdx), i2]
            });
          }
        }
        const selectionPath = [...tablePath, 0, 0, column.start];
        const point3 = Editor.start(editor, column.start === 0 ? selectionPath : Path.previous(selectionPath));
        Transforms.select(editor, point3);
      });
      return;
    }
    const selectionStart = Editor.start(editor, editor.selection).path;
    Editor.withoutNormalizing(editor, () => {
      for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
        for (let cellIndex = column.start; cellIndex <= column.end; cellIndex++) {
          const relativeCellPath = [...getRelativeRowPath(hasHead, rowIndex), cellIndex];
          const cell2 = Node2.get(selectedTableArea.table, relativeCellPath);
          if (!Element2.isElement(cell2)) {
            continue;
          }
          const cellPath = [...tablePath, ...relativeCellPath];
          Transforms.insertNodes(editor, {
            type: "paragraph",
            children: [{
              text: ""
            }]
          }, {
            at: [...cellPath, 0]
          });
          for (const childIdx of [...cell2.children.keys()].reverse()) {
            Transforms.removeNodes(editor, {
              at: [...cellPath, childIdx + 1]
            });
          }
        }
      }
      Transforms.select(editor, selectionStart);
    });
  };
  editor.normalizeNode = (entry) => {
    const [node3, path3] = entry;
    if (node3.type === "table-head" && node3.children.length > 1) {
      moveChildren(editor, path3, Path.next(path3), (_, i2) => i2 !== 0);
      return;
    }
    let didUpdateThings = false;
    for (const parent of ["table-body", "table-head"]) {
      if (node3.type === parent) {
        for (const [rowIdx, row] of node3.children.entries()) {
          if (row.type === "table-row") {
            for (const [cellIdx, cell2] of row.children.entries()) {
              if (cell2.type === "table-cell") {
                const at2 = [...path3, rowIdx, cellIdx];
                if (cell2.header && parent === "table-body") {
                  Transforms.unsetNodes(editor, "header", {
                    at: at2
                  });
                  didUpdateThings = true;
                }
                if (!cell2.header && parent === "table-head") {
                  Transforms.setNodes(editor, {
                    header: true
                  }, {
                    at: at2
                  });
                  didUpdateThings = true;
                }
              }
            }
          }
        }
      }
    }
    if (didUpdateThings) {
      return;
    }
    if (node3.type === "table") {
      const maxRowCount = node3.children.reduce((max4, node4) => node4.type === "table-head" || node4.type === "table-body" ? node4.children.reduce((max5, node5) => node5.type === "table-row" ? Math.max(max5, node5.children.length) : max5, max4) : max4, 0);
      let didInsert = false;
      for (const [idx, child] of node3.children.entries()) {
        if (child.type === "table-body" || child.type === "table-head") {
          for (const [rowIdx, row] of child.children.entries()) {
            if (row.type === "table-row" && row.children.length !== maxRowCount) {
              Transforms.insertNodes(editor, Array.from({
                length: maxRowCount - row.children.length
              }, () => cell(child.type === "table-head")), {
                at: [...path3, idx, rowIdx, row.children.length]
              });
              didInsert = true;
            }
          }
        }
      }
      if (didInsert) {
        return;
      }
      if (node3.children.length === 1 && node3.children[0].type === "table-head") {
        Transforms.insertNodes(editor, {
          type: "table-body",
          children: Array.from({
            length: node3.children[0].children.length
          }, () => cell(false))
        }, {
          at: [...path3, 1]
        });
        return;
      }
      if (node3.children.length === 2 && node3.children[1].type === "table-head") {
        Transforms.moveNodes(editor, {
          at: [...path3, 1],
          to: [...path3, 0]
        });
        return;
      }
      if (node3.children.length > 2) {
        moveChildren(editor, path3, Path.next(path3), (_, i2) => i2 !== 0 && i2 !== 1);
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var insertTable$1 = (editor) => {
  Transforms.insertNodes(editor, {
    type: "table",
    children: [{
      type: "table-head",
      children: [{
        type: "table-row",
        children: [cell(true), cell(true), cell(true)]
      }]
    }, {
      type: "table-body",
      children: [{
        type: "table-row",
        children: [cell(false), cell(false), cell(false)]
      }, {
        type: "table-row",
        children: [cell(false), cell(false), cell(false)]
      }]
    }]
  });
};
var SelectedCellsContext = (0, import_react55.createContext)(void 0);
function getSelectedCells(table3, row, column) {
  var _table$children$;
  const selectedCells = /* @__PURE__ */ new Set();
  const first = table3.children[0].type === "table-head" || table3.children[0].type === "table-body" ? table3.children[0] : void 0;
  if (!first) return selectedCells;
  const second = ((_table$children$ = table3.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === "table-body" ? table3.children[1] : void 0;
  for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
    const row2 = second ? rowIndex === 0 ? first.children[0] : second.children[rowIndex - 1] : first.children[rowIndex];
    if (!Element2.isElement(row2)) continue;
    for (let cellIndex = column.start; cellIndex <= column.end; cellIndex++) {
      selectedCells.add(row2.children[cellIndex]);
    }
  }
  return selectedCells;
}
function TableSelectionProvider(props) {
  const editor = useSlate();
  const selectedTableArea = getSelectedTableArea(editor);
  if (selectedTableArea) {
    var _Editor$above, _editor$selection;
    return (0, import_jsx_runtime70.jsx)(SelectedCellsContext.Provider, {
      value: {
        cells: selectedTableArea.singleCell === "not-selected" ? /* @__PURE__ */ new Set() : getSelectedCells(selectedTableArea.table, selectedTableArea.row, selectedTableArea.column),
        table: selectedTableArea.table,
        focus: (_Editor$above = Editor.above(editor, {
          match: nodeTypeMatcher("table-cell"),
          at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus.path
        })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[0]
      },
      children: props.children
    });
  }
  return (0, import_jsx_runtime70.jsx)(SelectedCellsContext.Provider, {
    value: void 0,
    children: props.children
  });
}
var StartElementsContext = (0, import_react55.createContext)({
  top: /* @__PURE__ */ new Map(),
  left: /* @__PURE__ */ new Map()
});
var TableElement = ({
  attributes,
  children,
  element: element3
}) => {
  var _element$children$;
  const editor = useSlateStatic();
  const selectedCellsContext = (0, import_react55.useContext)(SelectedCellsContext);
  const selectedCells = (selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.table) === element3 ? selectedCellsContext : void 0;
  const startElements = (0, import_react55.useMemo)(() => {
    const firstTableChild = element3.children[0];
    if (!Element2.isElement(firstTableChild) || !Element2.isElement(firstTableChild.children[0])) {
      return {
        top: /* @__PURE__ */ new Map(),
        left: /* @__PURE__ */ new Map()
      };
    }
    const top = /* @__PURE__ */ new Map();
    const left = /* @__PURE__ */ new Map();
    for (const [idx, cell2] of firstTableChild.children[0].children.entries()) {
      if (cell2.type !== "table-cell") continue;
      top.set(cell2, element3.children.every((headOrBody) => Element2.isElement(headOrBody) ? headOrBody.children.every((row) => Element2.isElement(row) && (selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.cells.has(row.children[idx]))) : false));
    }
    for (const headOrBody of element3.children) {
      if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
        continue;
      }
      for (const row of headOrBody.children) {
        if (row.type !== "table-row" || row.children[0].type !== "table-cell") {
          continue;
        }
        left.set(row.children[0], row.children.every((element4) => selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.cells.has(element4)));
      }
    }
    return {
      top,
      left
    };
  }, [element3, selectedCells]);
  return (0, import_jsx_runtime70.jsx)(StartElementsContext.Provider, {
    value: startElements,
    children: (0, import_jsx_runtime70.jsx)(SelectedCellsContext.Provider, {
      value: selectedCells,
      children: (0, import_jsx_runtime70.jsx)(BlockWrapper$1, {
        attributes,
        children: (0, import_jsx_runtime70.jsxs)(BlockPopoverTrigger, {
          element: element3,
          children: [(0, import_jsx_runtime70.jsx)("table", {
            className: css({
              width: "100%",
              tableLayout: "fixed",
              position: "relative",
              borderSpacing: 0,
              "& *::selection": selectedCells !== null && selectedCells !== void 0 && selectedCells.cells.size ? {
                backgroundColor: "transparent"
              } : void 0
            }),
            children
          }), (0, import_jsx_runtime70.jsx)(BlockPopover, {
            children: (0, import_jsx_runtime70.jsxs)(Flex, {
              gap: "regular",
              padding: "regular",
              children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
                  prominence: "low",
                  isSelected: ((_element$children$ = element3.children[0]) === null || _element$children$ === void 0 ? void 0 : _element$children$.type) === "table-head",
                  onPress: () => {
                    const tablePath = ReactEditor.findPath(editor, element3);
                    Editor.withoutNormalizing(editor, () => {
                      if (element3.children[0].type === "table-head") {
                        Transforms.moveNodes(editor, {
                          at: [...tablePath, 0, 0],
                          to: [...tablePath, 1, 0]
                        });
                        Transforms.removeNodes(editor, {
                          at: [...tablePath, 0]
                        });
                        return;
                      }
                      Transforms.insertNodes(editor, {
                        type: "table-head",
                        children: []
                      }, {
                        at: [...tablePath, 0]
                      });
                      Transforms.moveNodes(editor, {
                        at: [...tablePath, 1, 0],
                        to: [...tablePath, 0, 0]
                      });
                    });
                  },
                  children: (0, import_jsx_runtime70.jsx)(Icon, {
                    src: sheetIcon
                  })
                }), (0, import_jsx_runtime70.jsx)(Tooltip, {
                  children: "Header row"
                })]
              }), (0, import_jsx_runtime70.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: () => {
                    Transforms.removeNodes(editor, {
                      at: ReactEditor.findPath(editor, element3)
                    });
                  },
                  children: (0, import_jsx_runtime70.jsx)(Icon, {
                    src: trash2Icon
                  })
                }), (0, import_jsx_runtime70.jsx)(Tooltip, {
                  tone: "critical",
                  children: "Remove"
                })]
              })]
            })
          })]
        })
      })
    })
  });
};
var TableBodyElement = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime70.jsx)("tbody", {
    ...attributes,
    children
  });
};
var TableHeadElement = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime70.jsx)("thead", {
    ...attributes,
    children
  });
};
var TableRowElement = ({
  attributes,
  children,
  element: element3
}) => {
  var _useContext, _table$children$index;
  const table3 = (_useContext = (0, import_react55.useContext)(SelectedCellsContext)) === null || _useContext === void 0 ? void 0 : _useContext.table;
  return (0, import_jsx_runtime70.jsx)(RowIndexContext.Provider, {
    value: (_table$children$index = table3 === null || table3 === void 0 ? void 0 : table3.children.indexOf(element3)) !== null && _table$children$index !== void 0 ? _table$children$index : -1,
    children: (0, import_jsx_runtime70.jsx)("tr", {
      ...attributes,
      children
    })
  });
};
var RowIndexContext = (0, import_react55.createContext)(-1);
function TableCellElement({
  attributes,
  children,
  element: element3
}) {
  const editor = useSlateStatic();
  const selectedCellsContext = (0, import_react55.useContext)(SelectedCellsContext);
  const startElements = (0, import_react55.useContext)(StartElementsContext);
  const isSelected = selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.cells.has(element3);
  const size4 = `calc(100% + 2px)`;
  const ElementType = element3.header ? "th" : "td";
  const borderColor2 = isSelected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle;
  return (0, import_jsx_runtime70.jsxs)(ElementType, {
    className: css({
      borderInlineEnd: `1px solid ${borderColor2}`,
      borderBottom: `1px solid ${borderColor2}`,
      borderTop: startElements.top.has(element3) ? `1px solid ${borderColor2}` : void 0,
      borderInlineStart: startElements.left.has(element3) ? `1px solid ${borderColor2}` : void 0,
      backgroundColor: selectedCellsContext !== null && selectedCellsContext !== void 0 && selectedCellsContext.cells.has(element3) ? tokenSchema.color.alias.backgroundSelected : element3.header ? tokenSchema.color.scale.slate3 : void 0,
      position: "relative",
      margin: 0,
      padding: tokenSchema.size.space.regular,
      fontWeight: "inherit",
      boxSizing: "border-box",
      textAlign: "start",
      verticalAlign: "top"
    }),
    ...attributes,
    children: [isSelected && (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
      children: [(0, import_jsx_runtime70.jsx)("div", {
        contentEditable: false,
        className: css({
          position: "absolute",
          top: -1,
          insetInlineStart: -1,
          background: tokenSchema.color.alias.borderSelected,
          height: size4,
          width: 1
        })
      }), (0, import_jsx_runtime70.jsx)("div", {
        contentEditable: false,
        className: css({
          position: "absolute",
          top: -1,
          insetInlineStart: -1,
          background: tokenSchema.color.alias.borderSelected,
          height: 1,
          width: size4
        })
      })]
    }), startElements.top.has(element3) && (0, import_jsx_runtime70.jsx)(CellSelection2, {
      location: "top",
      selected: !!startElements.top.get(element3),
      label: "Select Column",
      onClick: () => {
        const path3 = ReactEditor.findPath(editor, element3);
        const table3 = Editor.above(editor, {
          match: nodeTypeMatcher("table"),
          at: path3
        });
        if (!table3) return;
        const lastTableIndex = table3[0].children.length - 1;
        const tableBody = table3[0].children[lastTableIndex];
        if (tableBody.type !== "table-body") return;
        const cellIndex = path3[path3.length - 1];
        const endPath = [...table3[1], table3[0].children.length - 1, tableBody.children.length - 1, cellIndex];
        Transforms.select(editor, {
          anchor: Editor.start(editor, path3),
          focus: Editor.end(editor, endPath)
        });
      }
    }), startElements.left.has(element3) && (0, import_jsx_runtime70.jsx)(CellSelection2, {
      location: "left",
      selected: !!startElements.left.get(element3),
      label: "Select Row",
      onClick: () => {
        const path3 = ReactEditor.findPath(editor, element3);
        Transforms.select(editor, {
          anchor: Editor.start(editor, Path.parent(path3)),
          focus: Editor.end(editor, Path.parent(path3))
        });
      }
    }), startElements.left.has(element3) && startElements.top.has(element3) && (0, import_jsx_runtime70.jsx)(CellSelection2, {
      location: "top-left",
      selected: !!(startElements.top.get(element3) && startElements.left.get(element3)),
      label: "Select Table",
      onClick: () => {
        const path3 = ReactEditor.findPath(editor, element3);
        const table3 = Editor.above(editor, {
          match: nodeTypeMatcher("table"),
          at: path3
        });
        if (!table3) return;
        Transforms.select(editor, {
          anchor: Editor.start(editor, table3[1]),
          focus: Editor.end(editor, table3[1])
        });
      }
    }), (0, import_jsx_runtime70.jsx)("div", {
      children
    }), (selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.focus) === element3 && (0, import_jsx_runtime70.jsx)(CellMenu$1, {
      cell: element3,
      table: selectedCellsContext.table
    })]
  });
}
function CellSelection2(props) {
  const selectedCellsContext = (0, import_react55.useContext)(SelectedCellsContext);
  const editor = useSlateStatic();
  let {
    location,
    selected
  } = props;
  return (0, import_jsx_runtime70.jsxs)("div", {
    contentEditable: false,
    children: [(0, import_jsx_runtime70.jsx)("button", {
      tabIndex: -1,
      type: "button",
      ...toDataAttributes({
        location,
        selected
      }),
      className: css({
        background: tokenSchema.color.scale.slate3,
        border: `1px solid ${tokenSchema.color.alias.borderIdle}`,
        margin: 0,
        padding: 0,
        position: "absolute",
        ":hover": {
          background: tokenSchema.color.scale.slate4
        },
        // ever so slightly larger hit area
        "::before": {
          content: '""',
          inset: -1,
          position: "absolute"
        },
        // location
        "&[data-location=top]": {
          top: -9,
          insetInlineStart: -1,
          width: "calc(100% + 2px)",
          height: 8
        },
        "&[data-location=left]": {
          top: -1,
          insetInlineStart: -9,
          width: 8,
          height: "calc(100% + 2px)"
        },
        "&[data-location=top-left]": {
          top: -9,
          insetInlineStart: -9,
          width: 8,
          height: 8
        },
        "&:not([data-location=top])": {
          borderInlineEnd: "none"
        },
        "&:not([data-location=left])": {
          borderBottom: "none"
        },
        // state
        "&[data-selected=true]": {
          background: tokenSchema.color.scale.indigo8,
          borderColor: tokenSchema.color.alias.borderSelected
        }
      }),
      style: {
        visibility: selectedCellsContext !== null && selectedCellsContext !== void 0 && selectedCellsContext.focus ? "visible" : "hidden"
      },
      "aria-label": props.label,
      onClick: () => {
        ReactEditor.focus(editor);
        props.onClick();
      }
    }), props.selected && (props.location === "top" ? (0, import_jsx_runtime70.jsx)("div", {
      className: css({
        position: "absolute",
        top: -9,
        insetInlineEnd: -1,
        background: tokenSchema.color.alias.borderSelected,
        height: 8,
        width: 1,
        zIndex: 2
      })
    }) : (0, import_jsx_runtime70.jsx)("div", {
      className: css({
        position: "absolute",
        bottom: -1,
        insetInlineStart: -9,
        background: tokenSchema.color.alias.borderSelected,
        height: 1,
        width: 8,
        zIndex: 2
      })
    }))]
  });
}
var cellActions$1 = {
  deleteRow: {
    label: "Delete row",
    action: (editor, cellPath) => {
      const tablePath = cellPath.slice(0, -3);
      const table3 = Node2.get(editor, tablePath);
      if (table3.type !== "table") return;
      const hasHead = table3.children[0].type === "table-head";
      const rowPath = Path.parent(cellPath);
      Transforms.removeNodes(editor, {
        at: hasHead && rowPath[cellPath.length - 3] === 0 ? Path.parent(rowPath) : rowPath
      });
    }
  },
  deleteColumn: {
    label: "Delete column",
    action: (editor, path3) => {
      const cellIndex = path3[path3.length - 1];
      const tablePath = path3.slice(0, -3);
      const table3 = Node2.get(editor, tablePath);
      if (table3.type !== "table") return;
      Editor.withoutNormalizing(editor, () => {
        for (const [headOrBodyIdx, headOrBody] of table3.children.entries()) {
          if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
            continue;
          }
          for (const idx of headOrBody.children.keys()) {
            Transforms.removeNodes(editor, {
              at: [...tablePath, headOrBodyIdx, idx, cellIndex]
            });
          }
        }
      });
    }
  },
  insertRowBelow: {
    label: "Insert row below",
    action: (editor, path3) => {
      const tableRow = Node2.get(editor, Path.parent(path3));
      const tablePath = path3.slice(0, -3);
      const table3 = Node2.get(editor, tablePath);
      if (tableRow.type !== "table-row" || table3.type !== "table") {
        return;
      }
      const hasHead = table3.children[0].type === "table-head";
      const newRowPath = [...tablePath, hasHead ? 1 : 0, hasHead && path3[path3.length - 3] === 0 ? 0 : path3[path3.length - 2] + 1];
      Editor.withoutNormalizing(editor, () => {
        Transforms.insertNodes(editor, {
          type: "table-row",
          children: tableRow.children.map(() => cell(false))
        }, {
          at: newRowPath
        });
        Transforms.select(editor, [...newRowPath, path3[path3.length - 1]]);
      });
    }
  },
  insertColumnRight: {
    label: "Insert column right",
    action: (editor, path3) => {
      const newCellIndex = path3[path3.length - 1] + 1;
      const tablePath = path3.slice(0, -3);
      const table3 = Node2.get(editor, tablePath);
      if (table3.type !== "table") return;
      Editor.withoutNormalizing(editor, () => {
        for (const [headOrBodyIdx, headOrBody] of table3.children.entries()) {
          if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
            continue;
          }
          for (const rowIdx of headOrBody.children.keys()) {
            Transforms.insertNodes(editor, cell(headOrBody.type === "table-head"), {
              at: [...tablePath, headOrBodyIdx, rowIdx, newCellIndex]
            });
          }
        }
        Transforms.select(editor, Editor.start(editor, Path.next(path3)));
      });
    }
  }
};
var _cellActions = cellActions$1;
function CellMenu$1(props) {
  const editor = useSlateStatic();
  const gutter = tokenSchema.size.space.small;
  return (0, import_jsx_runtime70.jsx)("div", {
    contentEditable: false,
    className: css({
      top: gutter,
      insetInlineEnd: gutter,
      position: "absolute"
    }),
    children: (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsxs)(MenuTrigger, {
        align: "end",
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          UNSAFE_className: css({
            borderRadius: tokenSchema.size.radius.small,
            height: "auto",
            minWidth: 0,
            padding: 0,
            // tiny buttons; increase the hit area
            "&::before": {
              content: '""',
              inset: `calc(${gutter} * -1)`,
              position: "absolute"
            }
          }),
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: chevronDownIcon
          })
        }), (0, import_jsx_runtime70.jsx)(_Menu, {
          onAction: (key3) => {
            if (key3 in _cellActions) {
              _cellActions[key3].action(editor, ReactEditor.findPath(editor, props.cell));
            }
          },
          items: Object.entries(_cellActions).map(([key3, item2]) => ({
            ...item2,
            key: key3
          })),
          children: (item2) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
            children: item2.label
          }, item2.key)
        })]
      }), (0, import_jsx_runtime70.jsx)(Tooltip, {
        children: "Options"
      })]
    })
  });
}
var TableButton = () => {
  const {
    editor,
    blockquote: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(ActionButton, {
    prominence: "low",
    isSelected,
    isDisabled,
    onPress: () => {
      insertTable$1(editor);
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime70.jsx)(Icon, {
      src: tableIcon
    })
  }), [editor, isDisabled, isSelected]);
};
var tableButton = (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime70.jsx)(TableButton, {}), (0, import_jsx_runtime70.jsx)(Tooltip, {
    children: (0, import_jsx_runtime70.jsx)(Text, {
      children: "Table"
    })
  })]
});
function getCellPathInDirection(editor, path3, direction) {
  if (direction === "left" || direction === "right") {
    const row = Editor.above(editor, {
      match: nodeTypeMatcher("table-row"),
      at: path3
    });
    if (!row) return;
    const currentCellIdx = path3[path3.length - 1];
    const diff2 = direction === "left" ? -1 : 1;
    const nextCellIdx = currentCellIdx + diff2;
    const nextCell2 = row[0].children[nextCellIdx];
    if (!nextCell2) return;
    return [...row[1], nextCellIdx];
  }
  const table3 = Editor.above(editor, {
    match: nodeTypeMatcher("table"),
    at: path3
  });
  if (!table3) return;
  const diff = direction === "up" ? -1 : 1;
  const rowIndex = path3[path3.length - 3] + path3[path3.length - 2];
  const nextRowIndex = rowIndex + diff;
  const relativeRowPath = getRelativeRowPath(table3[0].children[0].type === "table-head", nextRowIndex);
  if (!Node2.has(table3[0], relativeRowPath)) return;
  return [...table3[1], ...relativeRowPath, path3[path3.length - 1]];
}
function Toolbar$1({
  documentFeatures,
  viewState
}) {
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  let hasComponentBlocksForInsertMenu = false, hasComponentBlocksForToolbar = false;
  for (const componentBlock of Object.values(componentBlocks)) {
    if (componentBlock.toolbarIcon) {
      hasComponentBlocksForToolbar = true;
    }
    if (!componentBlock.toolbarIcon) {
      hasComponentBlocksForInsertMenu = true;
    }
  }
  const hasMarks = Object.values(documentFeatures.formatting.inlineMarks).some((x) => x);
  const hasAlignment = documentFeatures.formatting.alignment.center || documentFeatures.formatting.alignment.end;
  const hasLists = documentFeatures.formatting.listTypes.unordered || documentFeatures.formatting.listTypes.ordered;
  return (0, import_jsx_runtime70.jsxs)(ToolbarWrapper$1, {
    children: [(0, import_jsx_runtime70.jsxs)(ToolbarScrollArea$1, {
      children: [!!documentFeatures.formatting.headings.levels.length && (0, import_jsx_runtime70.jsx)(HeadingMenu$1, {
        headingLevels: documentFeatures.formatting.headings.levels
      }), hasMarks && (0, import_jsx_runtime70.jsx)(InlineMarks$1, {
        marks: documentFeatures.formatting.inlineMarks
      }), (hasAlignment || hasLists) && (0, import_jsx_runtime70.jsxs)(ToolbarGroup, {
        children: [hasAlignment && (0, import_jsx_runtime70.jsx)(TextAlignMenu, {
          alignment: documentFeatures.formatting.alignment
        }), hasLists && (0, import_jsx_runtime70.jsx)(ListButtons$1, {
          lists: documentFeatures.formatting.listTypes
        })]
      }), (documentFeatures.dividers || documentFeatures.links || !!documentFeatures.images || documentFeatures.formatting.blockTypes.blockquote || documentFeatures.tables || !!documentFeatures.layouts.length || documentFeatures.formatting.blockTypes.code || hasComponentBlocksForToolbar) && (0, import_jsx_runtime70.jsxs)(ToolbarGroup, {
        children: [documentFeatures.dividers && dividerButton, documentFeatures.links && linkButton, documentFeatures.images && imageButton, documentFeatures.formatting.blockTypes.blockquote && blockquoteButton, !!documentFeatures.layouts.length && (0, import_jsx_runtime70.jsx)(LayoutsButton, {
          layouts: documentFeatures.layouts
        }), documentFeatures.formatting.blockTypes.code && codeButton, documentFeatures.tables && tableButton, hasComponentBlocksForInsertMenu && insertBlocksInToolbar]
      }), (0, import_jsx_runtime70.jsx)(Box, {
        flex: true
      })]
    }), (0, import_react55.useMemo)(() => {
      return viewState && (0, import_jsx_runtime70.jsxs)(Flex, {
        gap: "xsmall",
        children: [(0, import_jsx_runtime70.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime70.jsx)(Button, {
            prominence: "low",
            onPress: () => {
              viewState.toggle();
            },
            children: (0, import_jsx_runtime70.jsx)(Icon, {
              src: viewState.expanded ? minimizeIcon : maximizeIcon
            })
          }), (0, import_jsx_runtime70.jsx)(Tooltip, {
            children: viewState.expanded ? "Collapse" : "Expand"
          })]
        })]
      });
    }, [viewState]), !!hasComponentBlocksForInsertMenu && (0, import_jsx_runtime70.jsx)(InsertBlockMenu$1, {})]
  });
}
var ToolbarGroup = ({
  children
}) => {
  return (0, import_jsx_runtime70.jsx)(Flex, {
    gap: "regular",
    children
  });
};
var ToolbarContainer$1 = ({
  children
}) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  if (entryLayoutPane === "main") {
    return (0, import_jsx_runtime70.jsx)("div", {
      className: css({
        boxSizing: "border-box",
        display: "flex",
        paddingInline: tokenSchema.size.space.medium,
        minWidth: 0,
        maxWidth: 800,
        marginInline: "auto",
        [breakpointQueries$1.above.mobile]: {
          paddingInline: tokenSchema.size.space.xlarge
        },
        [breakpointQueries$1.above.tablet]: {
          paddingInline: tokenSchema.size.space.xxlarge
        }
      }),
      children
    });
  }
  return (0, import_jsx_runtime70.jsx)("div", {
    className: css({
      display: "flex"
    }),
    children
  });
};
var ToolbarWrapper$1 = ({
  children
}) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime70.jsx)(import_jsx_runtime70.Fragment, {
    children: (0, import_jsx_runtime70.jsx)("div", {
      "data-layout": entryLayoutPane,
      className: css({
        backdropFilter: "blur(8px)",
        backgroundClip: "padding-box",
        backgroundColor: `color-mix(in srgb, transparent, ${tokenSchema.color.background.canvas} 90%)`,
        borderBottom: `${tokenSchema.size.border.regular} solid color-mix(in srgb, transparent, ${tokenSchema.color.foreground.neutral} 10%)`,
        borderStartEndRadius: tokenSchema.size.radius.medium,
        borderStartStartRadius: tokenSchema.size.radius.medium,
        minWidth: 0,
        position: "sticky",
        top: 0,
        zIndex: 2,
        '&[data-layout="main"]': {
          borderRadius: 0
        }
      }),
      children: (0, import_jsx_runtime70.jsx)(ToolbarContainer$1, {
        children
      })
    })
  });
};
var ToolbarScrollArea$1 = (props) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime70.jsx)(Flex, {
    "data-layout": entryLayoutPane,
    paddingY: "regular",
    paddingX: "medium",
    gap: "large",
    flex: true,
    minWidth: 0,
    UNSAFE_className: css({
      msOverflowStyle: "none",
      scrollbarWidth: "none",
      overflowX: "auto",
      /* for Chrome, Safari, and Opera */
      "&::-webkit-scrollbar": {
        display: "none"
      },
      '&[data-layout="main"]': {
        paddingInline: 0
      }
    }),
    ...props
  });
};
var headingMenuVals$1 = /* @__PURE__ */ new Map([["normal", "normal"], ["1", 1], ["2", 2], ["3", 3], ["4", 4], ["5", 5], ["6", 6]]);
var HeadingMenu$1 = ({
  headingLevels
}) => {
  const {
    editor,
    textStyles
  } = useToolbarState();
  const isDisabled = textStyles.allowedHeadingLevels.length === 0;
  const items = (0, import_react55.useMemo)(() => {
    let resolvedItems = [{
      name: "Paragraph",
      id: "normal"
    }];
    headingLevels.forEach((level) => {
      resolvedItems.push({
        name: `Heading ${level}`,
        id: level.toString()
      });
    });
    return resolvedItems;
  }, [headingLevels]);
  const selected = textStyles.selected.toString();
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(_Picker, {
    flexShrink: 0,
    width: "scale.1700",
    prominence: "low",
    "aria-label": "Text block",
    items,
    isDisabled,
    selectedKey: selected,
    onSelectionChange: (selected2) => {
      let key3 = headingMenuVals$1.get(selected2);
      if (key3 === "normal") {
        Editor.withoutNormalizing(editor, () => {
          Transforms.unsetNodes(editor, "level", {
            match: (n2) => n2.type === "heading"
          });
          Transforms.setNodes(editor, {
            type: "paragraph"
          }, {
            match: (n2) => n2.type === "heading"
          });
        });
      } else if (key3) {
        Transforms.setNodes(editor, {
          type: "heading",
          level: key3
        }, {
          match: (node3) => node3.type === "paragraph" || node3.type === "heading"
        });
      }
      ReactEditor.focus(editor);
    },
    children: (item2) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      children: item2.name
    }, item2.id)
  }), [editor, isDisabled, items, selected]);
};
var insertBlocksInToolbar = (0, import_jsx_runtime70.jsx)(InsertBlocksInToolbar, {});
function InsertBlocksInToolbar() {
  const editor = useSlateStatic();
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  return Object.entries(componentBlocks).filter(([, val]) => val.toolbarIcon).map(([key3, item2]) => {
    return (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => {
          insertComponentBlock(editor, componentBlocks, key3);
          ReactEditor.focus(editor);
        },
        children: (0, import_jsx_runtime70.jsx)(Icon, {
          src: item2.toolbarIcon
        })
      }), (0, import_jsx_runtime70.jsx)(Tooltip, {
        children: item2.label
      })]
    }, key3);
  });
}
function InsertBlockMenu$1() {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = useSlateStatic();
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  return (0, import_jsx_runtime70.jsxs)(MenuTrigger, {
    align: "end",
    children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsxs)(ActionButton, {
        marginY: "regular",
        marginEnd: entryLayoutPane === "main" ? void 0 : "medium",
        children: [(0, import_jsx_runtime70.jsx)(Icon, {
          src: plusIcon
        }), (0, import_jsx_runtime70.jsx)(Icon, {
          src: chevronDownIcon
        })]
      }), (0, import_jsx_runtime70.jsxs)(Tooltip, {
        children: [(0, import_jsx_runtime70.jsx)(Text, {
          children: "Insert"
        }), (0, import_jsx_runtime70.jsx)(Kbd, {
          children: "/"
        })]
      })]
    }), (0, import_jsx_runtime70.jsx)(_Menu, {
      onAction: (key3) => {
        insertComponentBlock(editor, componentBlocks, key3);
      },
      items: Object.entries(componentBlocks).filter(([, val]) => !val.toolbarIcon),
      children: ([key3, item2]) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        children: item2.label
      }, key3)
    })]
  });
}
var inlineMarks = [{
  key: "bold",
  label: "Bold",
  icon: boldIcon,
  shortcut: `B`
}, {
  key: "italic",
  label: "Italic",
  icon: italicIcon,
  shortcut: `I`
}, {
  key: "underline",
  label: "Underline",
  icon: underlineIcon,
  shortcut: `U`
}, {
  key: "strikethrough",
  label: "Strikethrough",
  icon: strikethroughIcon
}, {
  key: "code",
  label: "Code",
  icon: codeIcon
}, {
  key: "superscript",
  label: "Superscript",
  icon: superscriptIcon
}, {
  key: "subscript",
  label: "Subscript",
  icon: subscriptIcon
}, {
  key: "clearFormatting",
  label: "Clear formatting",
  icon: removeFormattingIcon
}];
function InlineMarks$1({
  marks: _marksShown
}) {
  const {
    editor,
    clearFormatting: {
      isDisabled
    },
    marks
  } = useToolbarState();
  const marksShown = useMemoStringified$1(_marksShown);
  const selectedKeys = useMemoStringified$1(Object.keys(marks).filter((key3) => marks[key3].isSelected));
  const disabledKeys = useMemoStringified$1(Object.keys(marks).filter((key3) => marks[key3].isDisabled).concat(isDisabled ? "clearFormatting" : []));
  return (0, import_react55.useMemo)(() => {
    const items = inlineMarks.filter((item2) => item2.key === "clearFormatting" || marksShown[item2.key]);
    return (0, import_jsx_runtime70.jsx)(_ActionGroup, {
      UNSAFE_className: css({
        minWidth: `calc(${tokenSchema.size.element.medium} * 4)`
      }),
      prominence: "low",
      density: "compact",
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      summaryIcon: (0, import_jsx_runtime70.jsx)(Icon, {
        src: typeIcon
      }),
      items,
      selectionMode: "multiple",
      selectedKeys,
      disabledKeys,
      onAction: (key3) => {
        if (key3 === "clearFormatting") {
          clearFormatting(editor);
        } else {
          var _Editor$marks;
          const mark = key3;
          if ((_Editor$marks = Editor.marks(editor)) !== null && _Editor$marks !== void 0 && _Editor$marks[mark]) {
            Editor.removeMark(editor, mark);
          } else {
            Editor.addMark(editor, mark, true);
          }
        }
        ReactEditor.focus(editor);
      },
      children: (item2) => {
        return (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          children: [(0, import_jsx_runtime70.jsx)(Text, {
            children: item2.label
          }), "shortcut" in item2 && (0, import_jsx_runtime70.jsx)(Kbd, {
            meta: true,
            children: item2.shortcut
          }), (0, import_jsx_runtime70.jsx)(Icon, {
            src: item2.icon
          })]
        }, item2.key);
      }
    });
  }, [disabledKeys, editor, marksShown, selectedKeys]);
}
function useMemoStringified$1(value) {
  return (0, import_react55.useMemo)(() => value, [JSON.stringify(value)]);
}
var HeadingElement = ({
  attributes,
  children,
  element: element3
}) => {
  const ElementType = `h${element3.level}`;
  const editor = useSlateStatic();
  const {
    documentFeatures
  } = useDocumentEditorConfig();
  const [dialogOpen, setDialogOpen] = (0, import_react55.useState)(false);
  if (Object.keys(documentFeatures.formatting.headings.schema.fields).length === 0) {
    return (0, import_jsx_runtime70.jsx)(ElementType, {
      ...attributes,
      style: {
        textAlign: element3.textAlign
      },
      children
    });
  }
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsx)(ElementType, {
      style: {
        textAlign: element3.textAlign
      },
      children: (0, import_jsx_runtime70.jsxs)(BlockPopoverTrigger, {
        element: element3,
        children: [(0, import_jsx_runtime70.jsx)("div", {
          children
        }), (0, import_jsx_runtime70.jsx)(BlockPopover, {
          children: (0, import_jsx_runtime70.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime70.jsx)(CustomAttributesEditButton, {
              onPress: () => setDialogOpen(true)
            }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, element3)
                  });
                },
                children: (0, import_jsx_runtime70.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime70.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      })
    }), (0, import_jsx_runtime70.jsx)(CustomAttributesDialog, {
      element: element3,
      schema: documentFeatures.formatting.headings.schema,
      isOpen: dialogOpen,
      nodeLabel: "Heading",
      onDismiss: () => setDialogOpen(false)
    })]
  });
};
var renderElement = (props) => {
  switch (props.element.type) {
    case "layout":
      return (0, import_jsx_runtime70.jsx)(LayoutContainer, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "layout-area":
      return (0, import_jsx_runtime70.jsx)(LayoutArea, {
        ...props
      });
    case "code":
      return (0, import_jsx_runtime70.jsx)(CodeElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "component-block": {
      return (0, import_jsx_runtime70.jsx)(ComponentBlocksElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    }
    case "component-inline-prop":
    case "component-block-prop":
      return (0, import_jsx_runtime70.jsx)(ComponentInlineProp, {
        ...props
      });
    case "heading":
      return (0, import_jsx_runtime70.jsx)(HeadingElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "link":
      return (0, import_jsx_runtime70.jsx)(LinkElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "ordered-list":
      return (0, import_jsx_runtime70.jsx)("ol", {
        ...props.attributes,
        children: props.children
      });
    case "unordered-list":
      return (0, import_jsx_runtime70.jsx)("ul", {
        ...props.attributes,
        children: props.children
      });
    case "list-item":
      return (0, import_jsx_runtime70.jsx)("li", {
        ...props.attributes,
        children: props.children
      });
    case "list-item-content":
      return (0, import_jsx_runtime70.jsx)("span", {
        ...props.attributes,
        children: props.children
      });
    case "blockquote":
      return (0, import_jsx_runtime70.jsx)("blockquote", {
        ...props.attributes,
        children: props.children
      });
    case "divider":
      return (0, import_jsx_runtime70.jsx)(DividerElement, {
        ...props
      });
    case "image":
      return (0, import_jsx_runtime70.jsx)(ImageElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table":
      return (0, import_jsx_runtime70.jsx)(TableElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-head":
      return (0, import_jsx_runtime70.jsx)(TableHeadElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-body":
      return (0, import_jsx_runtime70.jsx)(TableBodyElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-row":
      return (0, import_jsx_runtime70.jsx)(TableRowElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-cell":
      return (0, import_jsx_runtime70.jsx)(TableCellElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    default:
      let {
        textAlign
      } = props.element;
      return (0, import_jsx_runtime70.jsx)("p", {
        style: {
          textAlign
        },
        ...props.attributes,
        children: props.children
      });
  }
};
function getOptions2(toolbarState, componentBlocks) {
  const options = [...Object.keys(componentBlocks).map((key3) => ({
    label: componentBlocks[key3].label,
    insert: (editor) => {
      insertComponentBlock(editor, componentBlocks, key3);
    }
  })), ...toolbarState.textStyles.allowedHeadingLevels.filter((a) => toolbarState.editorDocumentFeatures.formatting.headings.levels.includes(a)).map((level) => ({
    label: `Heading ${level}`,
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "heading",
        level,
        children: [{
          text: ""
        }]
      });
    }
  })), !toolbarState.blockquote.isDisabled && toolbarState.editorDocumentFeatures.formatting.blockTypes.blockquote && {
    label: "Blockquote",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "blockquote",
        children: [{
          text: ""
        }]
      });
    }
  }, !toolbarState.code.isDisabled && toolbarState.editorDocumentFeatures.formatting.blockTypes.code && {
    label: "Code block",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "code",
        children: [{
          text: ""
        }]
      });
    }
  }, !!toolbarState.editorDocumentFeatures.images && {
    label: "Image",
    async insert(editor) {
      const image3 = await getUploadedImage();
      if (image3) {
        insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
          type: "image",
          src: image3,
          alt: "",
          title: "",
          children: [{
            text: ""
          }]
        });
      }
    }
  }, !!toolbarState.editorDocumentFeatures.tables && {
    label: "Table",
    insert: insertTable$1
  }, !toolbarState.dividers.isDisabled && toolbarState.editorDocumentFeatures.dividers && {
    label: "Divider",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "divider",
        children: [{
          text: ""
        }]
      });
    }
  }, !!toolbarState.editorDocumentFeatures.layouts.length && {
    label: "Layout",
    insert(editor) {
      insertLayout(editor, toolbarState.editorDocumentFeatures.layouts[0]);
    }
  }, !toolbarState.lists.ordered.isDisabled && toolbarState.editorDocumentFeatures.formatting.listTypes.ordered && {
    label: "Numbered List",
    keywords: ["ordered list"],
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "ordered-list",
        children: [{
          text: ""
        }]
      });
    }
  }, !toolbarState.lists.unordered.isDisabled && toolbarState.editorDocumentFeatures.formatting.listTypes.unordered && {
    label: "Bullet List",
    keywords: ["unordered list"],
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "unordered-list",
        children: [{
          text: ""
        }]
      });
    }
  }];
  return options.filter((x) => typeof x !== "boolean");
}
function insertOption(editor, text7, option) {
  const path3 = ReactEditor.findPath(editor, text7);
  Transforms.delete(editor, {
    at: {
      focus: Editor.start(editor, path3),
      anchor: Editor.end(editor, path3)
    }
  });
  option.insert(editor);
}
function InsertMenu$1({
  children,
  text: text7
}) {
  const toolbarState = useToolbarState();
  const {
    editor
  } = toolbarState;
  const {
    componentBlocks
  } = useDocumentEditorConfig();
  const options = matchSorter(getOptions2(toolbarState, componentBlocks), text7.text.slice(1), {
    keys: ["label", "keywords"]
  }).map((option, index4) => ({
    ...option,
    index: index4
  }));
  const stateRef = (0, import_react55.useRef)({
    options,
    text: text7
  });
  (0, import_react55.useEffect)(() => {
    stateRef.current = {
      options,
      text: text7
    };
  });
  const listenerRef = (0, import_react55.useRef)((_event) => {
  });
  (0, import_react55.useEffect)(() => {
    listenerRef.current = (event) => {
      if (event.defaultPrevented) return;
      switch (event.key) {
        case "ArrowDown": {
          if (stateRef.current.options.length) {
            event.preventDefault();
            state2.selectionManager.setFocused(true);
            state2.selectionManager.setFocusedKey((Number(state2.selectionManager.focusedKey) === stateRef.current.options.length - 1 ? 0 : Number(state2.selectionManager.focusedKey) + 1).toString());
          }
          return;
        }
        case "ArrowUp": {
          if (stateRef.current.options.length) {
            event.preventDefault();
            state2.selectionManager.setFocused(true);
            state2.selectionManager.setFocusedKey((state2.selectionManager.focusedKey === "0" ? stateRef.current.options.length - 1 : Number(state2.selectionManager.focusedKey) - 1).toString());
          }
          return;
        }
        case "Enter": {
          const option = stateRef.current.options[Number(state2.selectionManager.focusedKey)];
          if (option) {
            insertOption(editor, stateRef.current.text, option);
            event.preventDefault();
          }
          return;
        }
        case "Escape": {
          const path3 = ReactEditor.findPath(editor, stateRef.current.text);
          Transforms.unsetNodes(editor, "insertMenu", {
            at: path3
          });
          event.preventDefault();
          return;
        }
      }
    };
  });
  (0, import_react55.useEffect)(() => {
    const domNode = ReactEditor.toDOMNode(editor, editor);
    let listener = (event) => listenerRef.current(event);
    domNode.addEventListener("keydown", listener);
    return () => {
      domNode.removeEventListener("keydown", listener);
    };
  }, [editor]);
  const triggerRef = (0, import_react55.useRef)(null);
  const overlayState = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: true
  });
  const {
    triggerProps: {
      onPress,
      ...triggerProps
    },
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d({
    type: "listbox"
  }, overlayState, triggerRef);
  let state2 = $e72dd72e1c76a225$export$2f645645f7bca764({
    items: options,
    children: (item2) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      children: item2.label
    }, item2.index)
  });
  (0, import_react55.useEffect)(() => {
    if (!state2.selectionManager.isFocused && state2.collection.size) {
      state2.selectionManager.setFocused(true);
      state2.selectionManager.setFocusedKey("0");
    }
  }, [state2]);
  const scrollableRef = (0, import_react55.useRef)(null);
  (0, import_react55.useEffect)(() => {
    var _scrollableRef$curren;
    const element3 = (_scrollableRef$curren = scrollableRef.current) === null || _scrollableRef$curren === void 0 || (_scrollableRef$curren = _scrollableRef$curren.querySelector('[role="listbox"] [role="presentation"]')) === null || _scrollableRef$curren === void 0 ? void 0 : _scrollableRef$curren.children[state2.selectionManager.focusedKey];
    if (element3) {
      e2(element3, {
        scrollMode: "if-needed",
        boundary: scrollableRef.current,
        block: "nearest"
      });
    }
  }, [state2.selectionManager.focusedKey]);
  const listboxRef = (0, import_react55.useRef)(null);
  let layout = useListBoxLayout(state2);
  return (0, import_jsx_runtime70.jsxs)(import_react55.Fragment, {
    children: [(0, import_jsx_runtime70.jsx)("span", {
      ...triggerProps,
      role: "button",
      className: css({
        color: tokenSchema.color.foreground.accent,
        fontWeight: tokenSchema.typography.fontWeight.medium
      }),
      ref: triggerRef,
      children
    }), (0, import_jsx_runtime70.jsx)(Popover, {
      width: "alias.singleLineWidth",
      placement: "bottom start",
      isNonModal: true,
      hideArrow: true,
      ...overlayProps,
      state: overlayState,
      triggerRef,
      children: (0, import_jsx_runtime70.jsx)("div", {
        className: css({
          overflow: "scroll",
          maxHeight: 300
        }),
        ref: scrollableRef,
        children: (0, import_jsx_runtime70.jsx)(_ListBoxBase, {
          "aria-label": "Insert block",
          state: state2,
          shouldUseVirtualFocus: true,
          layout,
          ref: listboxRef,
          onAction: (key3) => {
            insertOption(editor, text7, options[key3]);
          }
        })
      })
    })]
  });
}
var nodeListsWithoutInsertMenu = /* @__PURE__ */ new WeakSet();
var nodesWithoutInsertMenu = /* @__PURE__ */ new WeakSet();
function findPathWithInsertMenu(node3, path3) {
  if (Text2.isText(node3)) {
    return node3.insertMenu ? path3 : void 0;
  }
  if (nodeListsWithoutInsertMenu.has(node3.children)) {
    return;
  }
  for (const [index4, child] of node3.children.entries()) {
    if (nodesWithoutInsertMenu.has(child)) continue;
    let maybePath = findPathWithInsertMenu(child, [...path3, index4]);
    if (maybePath) {
      return maybePath;
    }
    nodesWithoutInsertMenu.add(child);
  }
  nodeListsWithoutInsertMenu.add(node3.children);
}
function removeInsertMenuMarkWhenOutsideOfSelection(editor) {
  var _Editor$marks;
  const path3 = findPathWithInsertMenu(editor, []);
  if (path3 && !((_Editor$marks = Editor.marks(editor)) !== null && _Editor$marks !== void 0 && _Editor$marks.insertMenu) && (!editor.selection || !Path.equals(editor.selection.anchor.path, path3) || !Path.equals(editor.selection.focus.path, path3))) {
    Transforms.unsetNodes(editor, "insertMenu", {
      at: path3
    });
    return true;
  }
  return false;
}
function withInsertMenu(editor) {
  const {
    normalizeNode,
    apply: apply2,
    insertText
  } = editor;
  editor.normalizeNode = ([node3, path3]) => {
    if (Text2.isText(node3) && node3.insertMenu) {
      if (node3.text[0] !== "/") {
        Transforms.unsetNodes(editor, "insertMenu", {
          at: path3
        });
        return;
      }
      const whitespaceMatch = /\s/.exec(node3.text);
      if (whitespaceMatch) {
        Transforms.unsetNodes(editor, "insertMenu", {
          at: {
            anchor: {
              path: path3,
              offset: whitespaceMatch.index
            },
            focus: Editor.end(editor, path3)
          },
          match: Text2.isText,
          split: true
        });
        return;
      }
    }
    if (Editor.isEditor(editor) && removeInsertMenuMarkWhenOutsideOfSelection(editor)) {
      return;
    }
    normalizeNode([node3, path3]);
  };
  editor.apply = (op) => {
    apply2(op);
    if (op.type === "set_selection") {
      removeInsertMenuMarkWhenOutsideOfSelection(editor);
    }
  };
  editor.insertText = (text7) => {
    insertText(text7);
    if (editor.selection && text7 === "/") {
      const startOfBlock = Editor.start(editor, Editor.above(editor, {
        match: isBlock
      })[1]);
      const before = Editor.before(editor, editor.selection.anchor, {
        unit: "character"
      });
      if (before && (Point.equals(startOfBlock, before) || before.offset !== 0 && /\s/.test(Node2.get(editor, before.path).text[before.offset - 1]))) {
        Transforms.setNodes(editor, {
          insertMenu: true
        }, {
          at: {
            anchor: before,
            focus: editor.selection.anchor
          },
          match: Text2.isText,
          split: true
        });
      }
    }
  };
  return editor;
}
function Placeholder({
  placeholder,
  children
}) {
  const [width, setWidth] = (0, import_react55.useState)(0);
  return (0, import_jsx_runtime70.jsxs)("span", {
    className: css({
      position: "relative",
      display: "inline-block",
      width
    }),
    children: [(0, import_jsx_runtime70.jsx)("span", {
      contentEditable: false,
      className: css({
        position: "absolute",
        pointerEvents: "none",
        display: "inline-block",
        left: 0,
        top: 0,
        maxWidth: "100%",
        whiteSpace: "nowrap",
        opacity: "0.5",
        userSelect: "none",
        fontStyle: "normal",
        fontWeight: "normal",
        textDecoration: "none",
        textAlign: "left"
      }),
      children: (0, import_jsx_runtime70.jsx)("span", {
        ref: (node3) => {
          if (node3) {
            const offsetWidth = node3.offsetWidth;
            if (offsetWidth !== width) {
              setWidth(offsetWidth);
            }
          }
        },
        children: placeholder
      })
    }), children]
  });
}
var Leaf2 = ({
  leaf,
  text: text7,
  children,
  attributes
}) => {
  const {
    underline,
    strikethrough,
    bold,
    italic,
    code: code4,
    keyboard,
    superscript,
    subscript,
    placeholder,
    insertMenu,
    ...rest
  } = leaf;
  if (placeholder !== void 0) {
    children = (0, import_jsx_runtime70.jsx)(Placeholder, {
      placeholder,
      children
    });
  }
  if (insertMenu) {
    children = (0, import_jsx_runtime70.jsx)(InsertMenu$1, {
      text: text7,
      children
    });
  }
  if (code4) {
    children = (0, import_jsx_runtime70.jsx)("code", {
      children
    });
  }
  if (bold) {
    children = (0, import_jsx_runtime70.jsx)("strong", {
      children
    });
  }
  if (strikethrough) {
    children = (0, import_jsx_runtime70.jsx)("s", {
      children
    });
  }
  if (italic) {
    children = (0, import_jsx_runtime70.jsx)("em", {
      children
    });
  }
  if (keyboard) {
    children = (0, import_jsx_runtime70.jsx)("kbd", {
      children
    });
  }
  if (superscript) {
    children = (0, import_jsx_runtime70.jsx)("sup", {
      children
    });
  }
  if (subscript) {
    children = (0, import_jsx_runtime70.jsx)("sub", {
      children
    });
  }
  if (underline) {
    children = (0, import_jsx_runtime70.jsx)("u", {
      children
    });
  }
  const prismClassNames = Object.keys(rest).filter((x) => x.startsWith("prism_")).map((x) => styles$2.get(x.replace("prism_", "")));
  if (prismClassNames.length) {
    const className = prismClassNames.join(" ");
    children = (0, import_jsx_runtime70.jsx)("span", {
      className,
      children
    });
  }
  return (0, import_jsx_runtime70.jsx)("span", {
    ...attributes,
    children
  });
};
var renderLeaf = (props) => {
  return (0, import_jsx_runtime70.jsx)(Leaf2, {
    ...props
  });
};
var styles$2 = new Map([{
  types: ["comment", "prolog", "doctype", "cdata"],
  style: {
    color: tokenSchema.color.foreground.neutralTertiary,
    fontStyle: "italic"
  }
}, {
  types: ["atrule", "attr-name", "class-name", "selector"],
  style: {
    color: tokenSchema.color.scale.amber11
  }
}, {
  types: ["boolean", "constant", "inserted-sign", "entity", "inserted", "number", "regex", "symbol", "variable"],
  style: {
    color: tokenSchema.color.scale.green11
  }
}, {
  types: ["attr-value", "builtin", "char", "constant", "generics", "url"],
  style: {
    color: tokenSchema.color.scale.pink11
  }
}, {
  types: ["string"],
  style: {
    color: tokenSchema.color.scale.indigo9
  }
}, {
  types: ["annotation", "deleted", "deleted-sign", "decorator", "important", "tag"],
  style: {
    color: tokenSchema.color.scale.red11
  }
}, {
  types: ["function", "function-variable", "operator"],
  style: {
    color: tokenSchema.color.scale.purple11
  }
}, {
  types: ["tag", "selector", "keyword"],
  style: {
    color: tokenSchema.color.scale.indigo11
  }
}, {
  types: ["punctuation"],
  style: {
    color: tokenSchema.color.foreground.neutralSecondary
  }
}].flatMap((style) => {
  const className = css(style.style);
  return style.types.map((x) => [x, className]);
}));
var codeBlockShortcutPattern = /^```(\w+)? ?$/;
function withCodeBlock(documentFeatures, componentBlocks, editor) {
  const {
    insertBreak,
    normalizeNode,
    insertText
  } = editor;
  function codeBlockShortcut(block4) {
    var _aliasesToCanonicalNa;
    if ((block4 === null || block4 === void 0 ? void 0 : block4[0].type) !== "paragraph" || block4[0].children.length !== 1 || block4[0].children[0].type !== void 0) {
      return false;
    }
    const match2 = codeBlockShortcutPattern.exec(block4[0].children[0].text);
    if (!match2) {
      return false;
    }
    const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);
    if (locationDocumentFeatures && (locationDocumentFeatures.kind === "inline" || !locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)) {
      return false;
    }
    editor.history.undos.push({
      operations: [],
      selectionBefore: editor.selection
    });
    Transforms.select(editor, block4[1]);
    Transforms.delete(editor);
    Transforms.wrapNodes(editor, {
      type: "code",
      ...match2[1] ? {
        language: (_aliasesToCanonicalNa = aliasesToCanonicalName.get(match2[1].toLowerCase())) !== null && _aliasesToCanonicalNa !== void 0 ? _aliasesToCanonicalNa : match2[1]
      } : {},
      children: []
    }, {
      match: (node3) => node3.type === "paragraph"
    });
    return true;
  }
  editor.insertBreak = () => {
    const block4 = Editor.above(editor, {
      match: isBlock
    });
    if ((block4 === null || block4 === void 0 ? void 0 : block4[0].type) === "code" && Text2.isText(block4[0].children[0])) {
      const text7 = block4[0].children[0].text;
      if (text7[text7.length - 1] === "\n" && editor.selection && Range.isCollapsed(editor.selection) && Point.equals(Editor.end(editor, block4[1]), editor.selection.anchor)) {
        insertBreak();
        Transforms.setNodes(editor, {
          type: "paragraph",
          children: []
        });
        Transforms.delete(editor, {
          distance: 1,
          at: {
            path: [...block4[1], 0],
            offset: text7.length - 1
          }
        });
        return;
      }
      editor.insertText("\n");
      return;
    }
    if (editor.selection && Range.isCollapsed(editor.selection) && codeBlockShortcut(block4)) {
      return;
    }
    insertBreak();
  };
  editor.insertText = (text7) => {
    insertText(text7);
    if (text7 === " " && editor.selection && Range.isCollapsed(editor.selection)) {
      codeBlockShortcut(Editor.above(editor, {
        match: isBlock
      }));
    }
  };
  editor.normalizeNode = ([node3, path3]) => {
    if (node3.type === "code" && Element2.isElement(node3)) {
      for (const [index4, childNode] of node3.children.entries()) {
        if (!Text2.isText(childNode)) {
          if (editor.isVoid(childNode)) {
            Transforms.removeNodes(editor, {
              at: [...path3, index4]
            });
          } else {
            Transforms.unwrapNodes(editor, {
              at: [...path3, index4]
            });
          }
          return;
        }
        const marks = Object.keys(childNode).filter((x) => x !== "text");
        if (marks.length) {
          Transforms.unsetNodes(editor, marks, {
            at: [...path3, index4]
          });
          return;
        }
      }
    }
    normalizeNode([node3, path3]);
  };
  return editor;
}
var paragraphElement = () => ({
  type: "paragraph",
  children: [{
    text: ""
  }]
});
function withParagraphs(editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = (entry) => {
    const [node3, path3] = entry;
    if (Editor.isEditor(node3)) {
      let lastNode = node3.children[node3.children.length - 1];
      if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) !== "paragraph") {
        Transforms.insertNodes(editor, paragraphElement(), {
          at: [...path3, node3.children.length]
        });
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
function withLayouts(editor) {
  const {
    normalizeNode,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection && Range.isCollapsed(editor.selection) && // this is just an little optimisation
    // we're only doing things if we're at the start of a layout area
    // and the start of anything will always be offset 0
    // so we'll bailout if we're not at offset 0
    editor.selection.anchor.offset === 0) {
      const [aboveNode, abovePath] = Editor.above(editor, {
        match: (node3) => node3.type === "layout-area"
      }) || [editor, []];
      if (aboveNode.type === "layout-area" && Point.equals(Editor.start(editor, abovePath), editor.selection.anchor)) {
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.normalizeNode = (entry) => {
    const [node3, path3] = entry;
    if (Element2.isElement(node3) && node3.type === "layout") {
      if (node3.layout === void 0) {
        Transforms.unwrapNodes(editor, {
          at: path3
        });
        return;
      }
      if (node3.children.length < node3.layout.length) {
        Transforms.insertNodes(editor, Array.from({
          length: node3.layout.length - node3.children.length
        }).map(() => ({
          type: "layout-area",
          children: [paragraphElement()]
        })), {
          at: [...path3, node3.children.length]
        });
        return;
      }
      if (node3.children.length > node3.layout.length) {
        Array.from({
          length: node3.children.length - node3.layout.length
        }).map((_, i2) => i2).reverse().forEach((i2) => {
          const layoutAreaToRemovePath = [...path3, i2 + node3.layout.length];
          const child = node3.children[i2 + node3.layout.length];
          moveChildren(editor, layoutAreaToRemovePath, [...path3, node3.layout.length - 1, node3.children[node3.layout.length - 1].children.length], (node4) => node4.type !== "paragraph" || Node2.string(child) !== "");
          Transforms.removeNodes(editor, {
            at: layoutAreaToRemovePath
          });
        });
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var markdownLinkPattern = /(^|\s)\[(.+?)\]\((\S+)\)$/;
function withLink(editorDocumentFeatures, componentBlocks, editor) {
  const {
    insertText,
    isInline: isInline2,
    normalizeNode
  } = editor;
  editor.isInline = (element3) => {
    return element3.type === "link" ? true : isInline2(element3);
  };
  if (editorDocumentFeatures.links) {
    editor.insertText = (text7) => {
      insertText(text7);
      if (text7 !== ")" || !editor.selection) {
        return;
      }
      const startOfBlock = Editor.start(editor, Editor.above(editor, {
        match: isBlock
      })[1]);
      const startOfBlockToEndOfShortcutString = Editor.string(editor, {
        anchor: editor.selection.anchor,
        focus: startOfBlock
      });
      const match2 = markdownLinkPattern.exec(startOfBlockToEndOfShortcutString);
      if (!match2) {
        return;
      }
      const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);
      if ((ancestorComponentChildFieldDocumentFeatures === null || ancestorComponentChildFieldDocumentFeatures === void 0 ? void 0 : ancestorComponentChildFieldDocumentFeatures.documentFeatures.links) === false) {
        return;
      }
      const [, maybeWhitespace, linkText, href] = match2;
      editor.history.undos.push({
        operations: [],
        selectionBefore: editor.selection
      });
      const startOfShortcut = match2.index === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {
        distance: match2.index
      });
      const startOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfShortcut, {
        distance: maybeWhitespace === "" ? 1 : 2
      });
      const endOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfLinkText, {
        distance: linkText.length
      });
      Transforms.delete(editor, {
        at: {
          anchor: endOfLinkText,
          focus: editor.selection.anchor
        }
      });
      Transforms.delete(editor, {
        at: {
          anchor: startOfShortcut,
          focus: startOfLinkText
        }
      });
      Transforms.wrapNodes(editor, {
        type: "link",
        href,
        children: []
      }, {
        at: {
          anchor: editor.selection.anchor,
          focus: startOfShortcut
        },
        split: true
      });
      const nextNode = Editor.next(editor);
      if (nextNode) {
        Transforms.select(editor, nextNode[1]);
      }
    };
  }
  editor.normalizeNode = ([node3, path3]) => {
    if (node3.type === "link") {
      if (Node2.string(node3) === "") {
        Transforms.unwrapNodes(editor, {
          at: path3
        });
        return;
      }
      for (const [idx, child] of node3.children.entries()) {
        if (child.type === "link") {
          Transforms.unwrapNodes(editor, {
            at: [...path3, idx]
          });
          return;
        }
      }
    }
    if (isInlineContainer(node3)) {
      let lastMergableLink = null;
      for (const [idx, child] of node3.children.entries()) {
        var _lastMergableLink;
        if (child.type === "link" && child.href === ((_lastMergableLink = lastMergableLink) === null || _lastMergableLink === void 0 ? void 0 : _lastMergableLink.node.href)) {
          const firstLinkPath = [...path3, lastMergableLink.index];
          const secondLinkPath = [...path3, idx];
          const to = [...firstLinkPath, lastMergableLink.node.children.length];
          for (let i2 = child.children.length - 1; i2 >= 0; i2--) {
            const childPath = [...secondLinkPath, i2];
            Transforms.moveNodes(editor, {
              at: childPath,
              to
            });
          }
          Transforms.removeNodes(editor, {
            at: secondLinkPath
          });
          return;
        }
        if (!Text2.isText(child) || child.text !== "") {
          lastMergableLink = null;
        }
        if (child.type === "link") {
          lastMergableLink = {
            index: idx,
            node: child
          };
        }
      }
    }
    normalizeNode([node3, path3]);
  };
  return editor;
}
function createDocumentEditorForNormalization(documentFeatures, componentBlocks) {
  return _createDocumentEditor(createEditor(), documentFeatures, componentBlocks);
}
function _createDocumentEditor(baseEditor, documentFeatures, componentBlocks) {
  return withBlocksSchema(withParagraphs(withLink(documentFeatures, componentBlocks, withList(withTable(withComponentBlocks(componentBlocks, documentFeatures, withVoidElements(withLayouts(withCodeBlock(documentFeatures, componentBlocks, withDocumentFeaturesNormalization(documentFeatures, baseEditor))))))))));
}
function withBlocksSchema(editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([node3, path3]) => {
    if (!Text2.isText(node3) && node3.type !== "link") {
      const nodeType = Editor.isEditor(node3) ? "editor" : node3.type;
      if (typeof nodeType !== "string" || editorSchema[nodeType] === void 0) {
        Transforms.unwrapNodes(editor, {
          at: path3
        });
        return;
      }
      const info = editorSchema[nodeType];
      if (info.kind === "blocks" && node3.children.length !== 0 && node3.children.every((child) => !isBlock(child))) {
        Transforms.wrapNodes(editor, {
          type: info.blockToWrapInlinesIn,
          children: []
        }, {
          at: path3,
          match: (node4) => !isBlock(node4)
        });
        return;
      }
      let didUpdate = false;
      for (const [index4, childNode] of [...node3.children.entries()].reverse()) {
        const childPath = [...path3, index4];
        if (info.kind === "inlines") {
          if (!Text2.isText(childNode) && isBlock(childNode)) {
            handleNodeInInvalidPosition(editor, [childNode, childPath], path3);
            didUpdate = true;
            continue;
          }
        } else {
          if (!isBlock(childNode)) {
            Transforms.wrapNodes(editor, {
              type: info.blockToWrapInlinesIn,
              children: []
            }, {
              at: childPath
            });
            didUpdate = true;
            continue;
          }
          if (!info.allowedChildren.has(childNode.type)) {
            handleNodeInInvalidPosition(editor, [childNode, childPath], path3);
            didUpdate = true;
            continue;
          }
        }
      }
      if (didUpdate) {
        return;
      }
    }
    normalizeNode([node3, path3]);
  };
  return editor;
}
function handleNodeInInvalidPosition(editor, [node3, path3], ancestorPath) {
  const nodeType = node3.type;
  const childNodeInfo = editorSchema[nodeType];
  const ancestorNode = Node2.get(editor, ancestorPath);
  const parentNodeType = Editor.isEditor(ancestorNode) ? "editor" : ancestorNode.type;
  const parentNodeInfo = editorSchema[parentNodeType];
  if (!childNodeInfo || childNodeInfo.invalidPositionHandleMode === "unwrap") {
    if (parentNodeInfo.kind === "blocks" && parentNodeInfo.blockToWrapInlinesIn) {
      Transforms.setNodes(editor, {
        type: parentNodeInfo.blockToWrapInlinesIn,
        ...Object.fromEntries(Object.keys(node3).filter((key3) => key3 !== "type" && key3 !== "children").map((key3) => [key3, null]))
        // the Slate types don't understand that null is allowed and it will unset properties with setNodes
      }, {
        at: path3
      });
      return;
    }
    Transforms.unwrapNodes(editor, {
      at: path3
    });
    return;
  }
  const info = editorSchema[ancestorNode.type || "editor"];
  if ((info === null || info === void 0 ? void 0 : info.kind) === "blocks" && info.allowedChildren.has(nodeType)) {
    if (ancestorPath.length === 0) {
      Transforms.moveNodes(editor, {
        at: path3,
        to: [path3[0] + 1]
      });
    } else {
      Transforms.moveNodes(editor, {
        at: path3,
        to: Path.next(ancestorPath)
      });
    }
    return;
  }
  if (Editor.isEditor(ancestorNode)) {
    Transforms.moveNodes(editor, {
      at: path3,
      to: [path3[0] + 1]
    });
    Transforms.unwrapNodes(editor, {
      at: [path3[0] + 1]
    });
    return;
  }
  handleNodeInInvalidPosition(editor, [node3, path3], ancestorPath.slice(0, -1));
}
function withVoidElements(editor) {
  const {
    isVoid
  } = editor;
  editor.isVoid = (node3) => {
    return node3.type === "divider" || node3.type === "image" || isVoid(node3);
  };
  return editor;
}
function withBlockMarkdownShortcuts(documentFeatures, componentBlocks, editor) {
  const {
    insertText
  } = editor;
  const shortcuts2 = /* @__PURE__ */ Object.create(null);
  const editorDocumentFeaturesForNormalizationToCheck = {
    ...documentFeatures
  };
  let addShortcut = (text7, insert, shouldBeEnabledInComponentBlock, type = "paragraph") => {
    if (!shouldBeEnabledInComponentBlock(editorDocumentFeaturesForNormalizationToCheck)) {
      return;
    }
    const trigger = text7[text7.length - 1];
    if (!shortcuts2[trigger]) {
      shortcuts2[trigger] = /* @__PURE__ */ Object.create(null);
    }
    shortcuts2[trigger][text7] = {
      insert,
      type,
      shouldBeEnabledInComponentBlock
    };
  };
  addShortcut("1. ", () => {
    Transforms.wrapNodes(editor, {
      type: "ordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.ordered);
  addShortcut("- ", () => {
    Transforms.wrapNodes(editor, {
      type: "unordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.unordered);
  addShortcut("* ", () => {
    Transforms.wrapNodes(editor, {
      type: "unordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.unordered);
  documentFeatures.formatting.headings.levels.forEach((level) => {
    addShortcut("#".repeat(level) + " ", () => {
      Transforms.setNodes(editor, {
        type: "heading",
        level
      }, {
        match: (node3) => node3.type === "paragraph" || node3.type === "heading"
      });
    }, (features) => features.formatting.headings.levels.includes(level), "heading-or-paragraph");
  });
  addShortcut("> ", () => {
    Transforms.wrapNodes(editor, {
      type: "blockquote",
      children: []
    }, {
      match: (node3) => node3.type === "paragraph"
    });
  }, (features) => features.formatting.blockTypes.blockquote);
  addShortcut("---", () => {
    insertDivider(editor);
  }, (features) => features.dividers);
  editor.insertText = (text7) => {
    insertText(text7);
    const shortcutsForTrigger = shortcuts2[text7];
    if (shortcutsForTrigger && editor.selection && Range.isCollapsed(editor.selection)) {
      const {
        anchor
      } = editor.selection;
      const block4 = Editor.above(editor, {
        match: isBlock
      });
      if (!block4 || block4[0].type !== "paragraph" && block4[0].type !== "heading") {
        return;
      }
      const start2 = Editor.start(editor, block4[1]);
      const range = {
        anchor,
        focus: start2
      };
      const shortcutText = Editor.string(editor, range);
      const shortcut = shortcutsForTrigger[shortcutText];
      if (!shortcut || shortcut.type === "paragraph" && block4[0].type !== "paragraph") {
        return;
      }
      const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);
      if (locationDocumentFeatures && (locationDocumentFeatures.kind === "inline" || !shortcut.shouldBeEnabledInComponentBlock(locationDocumentFeatures.documentFeatures))) {
        return;
      }
      editor.history.undos.push({
        operations: [],
        selectionBefore: editor.selection
      });
      Transforms.select(editor, range);
      Transforms.delete(editor);
      shortcut.insert();
    }
  };
  return editor;
}
function getDirectBlockquoteParentFromSelection(editor) {
  if (!editor.selection) return {
    isInside: false
  };
  const [, parentPath] = Editor.parent(editor, editor.selection);
  if (!parentPath.length) {
    return {
      isInside: false
    };
  }
  const [maybeBlockquoteParent, maybeBlockquoteParentPath] = Editor.parent(editor, parentPath);
  const isBlockquote = maybeBlockquoteParent.type === "blockquote";
  return isBlockquote ? {
    isInside: true,
    path: maybeBlockquoteParentPath
  } : {
    isInside: false
  };
}
function withBlockquote(editor) {
  const {
    insertBreak,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const parentBlockquote = getDirectBlockquoteParentFromSelection(editor);
      if (parentBlockquote.isInside && Range.isCollapsed(editor.selection) && // the selection is at the start of the paragraph
      editor.selection.anchor.offset === 0 && // it's the first paragraph in the panel
      editor.selection.anchor.path[editor.selection.anchor.path.length - 2] === 0) {
        Transforms.unwrapNodes(editor, {
          match: (node3) => node3.type === "blockquote",
          split: true
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const panel = getDirectBlockquoteParentFromSelection(editor);
    if (editor.selection && panel.isInside) {
      const [node3, nodePath] = Editor.node(editor, editor.selection);
      if (Path.isDescendant(nodePath, panel.path) && Node2.string(node3) === "") {
        Transforms.unwrapNodes(editor, {
          match: (node4) => node4.type === "blockquote",
          split: true
        });
        return;
      }
    }
    insertBreak();
  };
  return editor;
}
function withHeading(editor) {
  const {
    insertBreak
  } = editor;
  editor.insertBreak = () => {
    insertBreak();
    const entry = Editor.above(editor, {
      match: (n2) => n2.type === "heading"
    });
    if (!entry || !editor.selection || !Range.isCollapsed(editor.selection)) {
      return;
    }
    const path3 = entry[1];
    if (
      // we want to unwrap the heading when the user inserted a break at the end of the heading
      // when the user inserts a break at the end of a heading, the new heading
      // that we want to unwrap will be empty so the end will be equal to the selection
      Point.equals(Editor.end(editor, path3), editor.selection.anchor)
    ) {
      Transforms.unwrapNodes(editor, {
        at: path3
      });
      return;
    }
    if (!Path.hasPrevious(path3)) {
      return;
    }
    const previousPath = Path.previous(path3);
    const previousNode = Node2.get(editor, previousPath);
    if (previousNode.type === "heading" && previousNode.children.length === 1 && Text2.isText(previousNode.children[0]) && previousNode.children[0].text === "") {
      Transforms.unwrapNodes(editor, {
        at: previousPath
      });
    }
  };
  return editor;
}
var allMarkdownShortcuts = {
  bold: ["**", "__"],
  italic: ["*", "_"],
  strikethrough: ["~~"],
  code: ["`"]
};
function applyMark(editor, mark, shortcutText, startOfStartPoint) {
  editor.history.undos.push({
    operations: [],
    selectionBefore: editor.selection
  });
  const startPointRef = Editor.pointRef(editor, startOfStartPoint);
  Transforms.delete(editor, {
    at: editor.selection.anchor,
    distance: shortcutText.length,
    reverse: true
  });
  Transforms.delete(editor, {
    at: startOfStartPoint,
    distance: shortcutText.length
  });
  Transforms.setNodes(editor, {
    [mark]: true
  }, {
    match: Text2.isText,
    split: true,
    at: {
      anchor: startPointRef.unref(),
      focus: editor.selection.anchor
    }
  });
  editor.removeMark(mark);
}
function withMarks(editorDocumentFeatures, componentBlocks, editor) {
  const {
    insertText,
    insertBreak
  } = editor;
  editor.insertBreak = () => {
    insertBreak();
    const marksAfterInsertBreak = Editor.marks(editor);
    if (!marksAfterInsertBreak || !editor.selection) return;
    const parentBlock = Editor.above(editor, {
      match: isBlock
    });
    if (!parentBlock) return;
    const point3 = EditorAfterButIgnoringingPointsWithNoContent(editor, editor.selection.anchor);
    const marksAfterInsertBreakArr = Object.keys(marksAfterInsertBreak);
    if (!point3 || !Path.isDescendant(point3.path, parentBlock[1])) {
      for (const mark of marksAfterInsertBreakArr) {
        editor.removeMark(mark);
      }
      return;
    }
    const textNode = Node2.get(editor, point3.path);
    for (const mark of marksAfterInsertBreakArr) {
      if (!textNode[mark]) {
        editor.removeMark(mark);
      }
    }
  };
  const selectedMarkdownShortcuts = {};
  const enabledMarks = editorDocumentFeatures.formatting.inlineMarks;
  Object.keys(allMarkdownShortcuts).forEach((mark) => {
    if (enabledMarks[mark]) {
      selectedMarkdownShortcuts[mark] = allMarkdownShortcuts[mark];
    }
  });
  if (Object.keys(selectedMarkdownShortcuts).length === 0) return editor;
  editor.insertText = (text7) => {
    insertText(text7);
    if (editor.selection && Range.isCollapsed(editor.selection)) {
      for (const [mark, shortcuts2] of Object.entries(selectedMarkdownShortcuts)) {
        for (const shortcutText of shortcuts2) {
          if (text7 === shortcutText[shortcutText.length - 1]) {
            const startOfBlock = getStartOfBlock(editor);
            let startOfBlockToEndOfShortcutString = Editor.string(editor, {
              anchor: editor.selection.anchor,
              focus: startOfBlock
            });
            const hasWhitespaceBeforeEndOfShortcut = /\s/.test(startOfBlockToEndOfShortcutString.slice(-shortcutText.length - 1, -shortcutText.length));
            const endOfShortcutContainsExpectedContent = shortcutText === startOfBlockToEndOfShortcutString.slice(-shortcutText.length);
            if (hasWhitespaceBeforeEndOfShortcut || !endOfShortcutContainsExpectedContent) {
              continue;
            }
            const strToMatchOn = startOfBlockToEndOfShortcutString.slice(0, -shortcutText.length - 1);
            for (const [offsetFromStartOfBlock] of [...strToMatchOn].reverse().entries()) {
              const expectedShortcutText = strToMatchOn.slice(offsetFromStartOfBlock, offsetFromStartOfBlock + shortcutText.length);
              if (expectedShortcutText !== shortcutText) {
                continue;
              }
              const startOfStartOfShortcut = offsetFromStartOfBlock === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {
                distance: offsetFromStartOfBlock
              });
              const endOfStartOfShortcut = Editor.after(editor, startOfStartOfShortcut, {
                distance: shortcutText.length
              });
              if (offsetFromStartOfBlock !== 0 && !/\s/.test(Editor.string(editor, {
                anchor: Editor.before(editor, startOfStartOfShortcut, {
                  unit: "character"
                }),
                focus: startOfStartOfShortcut
              }))) {
                continue;
              }
              const contentBetweenShortcuts = Editor.string(editor, {
                anchor: endOfStartOfShortcut,
                focus: editor.selection.anchor
              }).slice(0, -shortcutText.length);
              if (contentBetweenShortcuts === "" || /\s/.test(contentBetweenShortcuts[0])) {
                continue;
              }
              if (mark === "italic" && (contentBetweenShortcuts[0] === "_" || contentBetweenShortcuts[0] === "*")) {
                continue;
              }
              if (mark === "code" && contentBetweenShortcuts === "`") {
                continue;
              }
              const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);
              if (ancestorComponentChildFieldDocumentFeatures && ancestorComponentChildFieldDocumentFeatures.inlineMarks !== "inherit" && ancestorComponentChildFieldDocumentFeatures.inlineMarks[mark] === false) {
                continue;
              }
              applyMark(editor, mark, shortcutText, startOfStartOfShortcut);
              return;
            }
          }
        }
      }
    }
  };
  return editor;
}
function getStartOfBlock(editor) {
  return Editor.start(editor, Editor.above(editor, {
    match: isBlock
  })[1]);
}
var currentlyActiveMarks = /* @__PURE__ */ new Set();
var currentlyDisabledMarks = /* @__PURE__ */ new Set();
var currentLink = null;
function addMarkToChildren(mark, cb) {
  const wasPreviouslyActive = currentlyActiveMarks.has(mark);
  currentlyActiveMarks.add(mark);
  try {
    return cb();
  } finally {
    if (!wasPreviouslyActive) {
      currentlyActiveMarks.delete(mark);
    }
  }
}
function setLinkForChildren(href, cb) {
  if (currentLink !== null) {
    return cb();
  }
  currentLink = href;
  try {
    return cb();
  } finally {
    currentLink = null;
  }
}
function addMarksToChildren(marks, cb) {
  const marksToRemove = /* @__PURE__ */ new Set();
  for (const mark of marks) {
    if (!currentlyActiveMarks.has(mark)) {
      marksToRemove.add(mark);
    }
    currentlyActiveMarks.add(mark);
  }
  try {
    return cb();
  } finally {
    for (const mark of marksToRemove) {
      currentlyActiveMarks.delete(mark);
    }
  }
}
function forceDisableMarkForChildren(mark, cb) {
  const wasPreviouslyDisabled = currentlyDisabledMarks.has(mark);
  currentlyDisabledMarks.add(mark);
  try {
    return cb();
  } finally {
    if (!wasPreviouslyDisabled) {
      currentlyDisabledMarks.delete(mark);
    }
  }
}
function getInlineNodes(text7) {
  const node3 = {
    text: text7
  };
  for (const mark of currentlyActiveMarks) {
    if (!currentlyDisabledMarks.has(mark)) {
      node3[mark] = true;
    }
  }
  if (currentLink !== null) {
    return [{
      text: ""
    }, {
      type: "link",
      href: currentLink,
      children: [node3]
    }, {
      text: ""
    }];
  }
  return [node3];
}
function getAlignmentFromElement(element3) {
  const parent = element3.parentElement;
  const attribute = parent === null || parent === void 0 ? void 0 : parent.getAttribute("data-align");
  if (attribute === "center" || attribute === "end") {
    return attribute;
  }
  if (element3 instanceof HTMLElement) {
    const textAlign = element3.style.textAlign;
    if (textAlign === "center") {
      return "center";
    }
    if (textAlign === "right" || textAlign === "end") {
      return "end";
    }
  }
}
var headings = {
  H1: 1,
  H2: 2,
  H3: 3,
  H4: 4,
  H5: 5,
  H6: 6
};
var TEXT_TAGS = {
  CODE: "code",
  DEL: "strikethrough",
  S: "strikethrough",
  STRIKE: "strikethrough",
  EM: "italic",
  I: "italic",
  STRONG: "bold",
  U: "underline",
  SUP: "superscript",
  SUB: "subscript",
  KBD: "keyboard"
};
function marksFromElementAttributes(element3) {
  const marks = /* @__PURE__ */ new Set();
  const style = element3.style;
  const {
    nodeName
  } = element3;
  const markFromNodeName = TEXT_TAGS[nodeName];
  if (markFromNodeName) {
    marks.add(markFromNodeName);
  }
  const {
    fontWeight,
    textDecoration,
    verticalAlign
  } = style;
  if (textDecoration === "underline") {
    marks.add("underline");
  } else if (textDecoration === "line-through") {
    marks.add("strikethrough");
  }
  if (nodeName === "SPAN" && element3.classList.contains("code")) {
    marks.add("code");
  }
  if (nodeName === "B" && fontWeight !== "normal") {
    marks.add("bold");
  } else if (typeof fontWeight === "string" && (fontWeight === "bold" || fontWeight === "bolder" || fontWeight === "1000" || /^[5-9]\d{2}$/.test(fontWeight))) {
    marks.add("bold");
  }
  if (style.fontStyle === "italic") {
    marks.add("italic");
  }
  if (verticalAlign === "super") {
    marks.add("superscript");
  } else if (verticalAlign === "sub") {
    marks.add("subscript");
  }
  return marks;
}
function deserializeHTML(html2) {
  const parsed = new DOMParser().parseFromString(html2, "text/html");
  return fixNodesForBlockChildren(deserializeNodes(parsed.body.childNodes));
}
function deserializeHTMLNode(el) {
  if (!(el instanceof globalThis.HTMLElement)) {
    const text7 = el.textContent;
    if (!text7) {
      return [];
    }
    return getInlineNodes(text7);
  }
  if (el.nodeName === "BR") {
    return getInlineNodes("\n");
  }
  if (el.nodeName === "IMG") {
    const alt = el.getAttribute("alt");
    return getInlineNodes(alt !== null && alt !== void 0 ? alt : "");
  }
  if (el.nodeName === "HR") {
    return [{
      type: "divider",
      children: [{
        text: ""
      }]
    }];
  }
  const marks = marksFromElementAttributes(el);
  if (el.classList.contains("listtype-quote")) {
    marks.delete("italic");
    return addMarksToChildren(marks, () => [{
      type: "blockquote",
      children: fixNodesForBlockChildren(deserializeNodes(el.childNodes))
    }]);
  }
  return addMarksToChildren(marks, () => {
    const {
      nodeName
    } = el;
    if (nodeName === "A") {
      const href = el.getAttribute("href");
      if (href) {
        return setLinkForChildren(href, () => forceDisableMarkForChildren("underline", () => deserializeNodes(el.childNodes)));
      }
    }
    if (nodeName === "PRE" && el.textContent) {
      return [{
        type: "code",
        children: [{
          text: el.textContent || ""
        }]
      }];
    }
    const deserialized = deserializeNodes(el.childNodes);
    const children = fixNodesForBlockChildren(deserialized);
    if (nodeName === "LI") {
      let nestedList;
      const listItemContent = {
        type: "list-item-content",
        children: children.filter((node3) => {
          if (nestedList === void 0 && (node3.type === "ordered-list" || node3.type === "unordered-list")) {
            nestedList = node3;
            return false;
          }
          return true;
        })
      };
      const listItemChildren = nestedList ? [listItemContent, nestedList] : [listItemContent];
      return [{
        type: "list-item",
        children: listItemChildren
      }];
    }
    if (nodeName === "P") {
      return [{
        type: "paragraph",
        textAlign: getAlignmentFromElement(el),
        children
      }];
    }
    const headingLevel = headings[nodeName];
    if (typeof headingLevel === "number") {
      return [{
        type: "heading",
        level: headingLevel,
        textAlign: getAlignmentFromElement(el),
        children
      }];
    }
    if (nodeName === "BLOCKQUOTE") {
      return [{
        type: "blockquote",
        children
      }];
    }
    if (nodeName === "OL") {
      return [{
        type: "ordered-list",
        children
      }];
    }
    if (nodeName === "UL") {
      return [{
        type: "unordered-list",
        children
      }];
    }
    if (nodeName === "DIV" && !isBlock(children[0])) {
      return [{
        type: "paragraph",
        children
      }];
    }
    return deserialized;
  });
}
function deserializeNodes(nodes) {
  const outputNodes = [];
  for (const node3 of nodes) {
    outputNodes.push(...deserializeHTMLNode(node3));
  }
  return outputNodes;
}
function fixNodesForBlockChildren(deserializedNodes) {
  if (!deserializedNodes.length) {
    return [{
      text: ""
    }];
  }
  if (deserializedNodes.some(isBlock)) {
    const result = [];
    let queuedInlines = [];
    const flushInlines = () => {
      if (queuedInlines.length) {
        result.push({
          type: "paragraph",
          children: queuedInlines
        });
        queuedInlines = [];
      }
    };
    for (const node3 of deserializedNodes) {
      if (isBlock(node3)) {
        flushInlines();
        result.push(node3);
        continue;
      }
      if (Node2.string(node3).trim() !== "") {
        queuedInlines.push(node3);
      }
    }
    flushInlines();
    return result;
  }
  return deserializedNodes;
}
var markdownConfig = {
  mdastExtensions: [gfmAutolinkLiteralFromMarkdown(), gfmStrikethroughFromMarkdown()],
  extensions: [gfmAutolinkLiteral(), gfmStrikethrough()]
};
function deserializeMarkdown(markdown) {
  const root2 = fromMarkdown(markdown, markdownConfig);
  let nodes = root2.children;
  if (nodes.length === 1 && nodes[0].type === "paragraph") {
    nodes = nodes[0].children;
  }
  return deserializeChildren(nodes, markdown);
}
function deserializeChildren(nodes, input) {
  const outputNodes = [];
  for (const node3 of nodes) {
    const result = deserializeMarkdownNode(node3, input);
    if (result.length) {
      outputNodes.push(...result);
    }
  }
  if (!outputNodes.length) {
    outputNodes.push({
      text: ""
    });
  }
  return outputNodes;
}
function deserializeMarkdownNode(node3, input) {
  switch (node3.type) {
    case "blockquote": {
      return [{
        type: "blockquote",
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "link": {
      return setLinkForChildren(node3.url, () => deserializeChildren(node3.children, input));
    }
    case "code": {
      return [{
        type: "code",
        children: [{
          text: node3.value
        }]
      }];
    }
    case "paragraph": {
      return [{
        type: "paragraph",
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "heading": {
      return [{
        type: "heading",
        level: node3.depth,
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "list": {
      return [{
        type: node3.ordered ? "ordered-list" : "unordered-list",
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "listItem": {
      return [{
        type: "list-item",
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "thematicBreak": {
      return [{
        type: "divider",
        children: [{
          text: ""
        }]
      }];
    }
    case "break": {
      return getInlineNodes("\n");
    }
    case "delete": {
      return addMarkToChildren("strikethrough", () => deserializeChildren(node3.children, input));
    }
    case "strong": {
      return addMarkToChildren("bold", () => deserializeChildren(node3.children, input));
    }
    case "emphasis": {
      return addMarkToChildren("italic", () => deserializeChildren(node3.children, input));
    }
    case "inlineCode": {
      return addMarkToChildren("code", () => getInlineNodes(node3.value));
    }
    case "text": {
      return getInlineNodes(node3.value);
    }
  }
  return getInlineNodes(input.slice(node3.position.start.offset, node3.position.end.offset));
}
var urlPattern$1 = /https?:\/\//;
function insertFragmentButDifferent(editor, nodes) {
  if (isBlock(nodes[0])) {
    insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes);
  } else {
    Transforms.insertFragment(editor, nodes);
  }
}
var clipboardFormatKey = "x-keystatic-fragment";
var getDefaultView = (value) => {
  return value && value.ownerDocument && value.ownerDocument.defaultView || null;
};
var isDOMNode = (value) => {
  const window2 = getDefaultView(value);
  return !!window2 && value instanceof window2.Node;
};
var isDOMText = (value) => {
  return isDOMNode(value) && value.nodeType === 3;
};
var isDOMElement = (value) => {
  return isDOMNode(value) && value.nodeType === 1;
};
var getPlainText = (domNode) => {
  let text7 = "";
  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }
  if (isDOMElement(domNode)) {
    for (const childNode of Array.from(domNode.childNodes)) {
      text7 += getPlainText(childNode);
    }
    const display = getComputedStyle(domNode).getPropertyValue("display");
    if (display === "block" || display === "list" || domNode.tagName === "BR") {
      text7 += "\n";
    }
  }
  return text7;
};
function setFragmentData(e3, data2) {
  const {
    selection
  } = e3;
  if (!selection) {
    return;
  }
  const [start2, end] = Range.edges(selection);
  const startVoid = Editor.void(e3, {
    at: start2.path
  });
  const endVoid = Editor.void(e3, {
    at: end.path
  });
  if (Range.isCollapsed(selection) && !startVoid) {
    return;
  }
  const domRange = ReactEditor.toDOMRange(e3, selection);
  let contents = domRange.cloneContents();
  let attach = contents.childNodes[0];
  contents.childNodes.forEach((node3) => {
    if (node3.textContent && node3.textContent.trim() !== "") {
      attach = node3;
    }
  });
  if (endVoid) {
    const [voidNode] = endVoid;
    const r2 = domRange.cloneRange();
    const domNode = ReactEditor.toDOMNode(e3, voidNode);
    r2.setEndAfter(domNode);
    contents = r2.cloneContents();
  }
  if (startVoid) {
    attach = contents.querySelector("[data-slate-spacer]");
  }
  Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
    const isNewline = zw.getAttribute("data-slate-zero-width") === "n";
    zw.textContent = isNewline ? "\n" : "";
  });
  if (isDOMText(attach)) {
    const span = attach.ownerDocument.createElement("span");
    span.style.whiteSpace = "pre";
    span.appendChild(attach);
    contents.appendChild(span);
    attach = span;
  }
  const fragment = e3.getFragment();
  const string3 = JSON.stringify(fragment, (key3, val) => {
    if (val instanceof Uint8Array) {
      return {
        [bytesName]: base64UrlEncode(val)
      };
    }
    return val;
  });
  const encoded = window.btoa(encodeURIComponent(string3));
  attach.setAttribute("data-keystatic-fragment", encoded);
  data2.setData(`application/${clipboardFormatKey}`, encoded);
  const div = contents.ownerDocument.createElement("div");
  div.appendChild(contents);
  div.setAttribute("hidden", "true");
  contents.ownerDocument.body.appendChild(div);
  data2.setData("text/html", div.innerHTML);
  data2.setData("text/plain", getPlainText(div));
  contents.ownerDocument.body.removeChild(div);
}
var catchSlateFragment = /data-keystatic-fragment="(.+?)"/m;
var getSlateFragmentAttribute = (dataTransfer) => {
  const htmlData = dataTransfer.getData("text/html");
  const [, fragment] = htmlData.match(catchSlateFragment) || [];
  return fragment;
};
var bytesName = "$$keystaticUint8Array$$";
function withPasting(editor) {
  const {
    insertTextData
  } = editor;
  editor.setFragmentData = (data2) => {
    setFragmentData(editor, data2);
  };
  editor.insertFragmentData = (data2) => {
    const fragment = data2.getData(`application/${clipboardFormatKey}`) || getSlateFragmentAttribute(data2);
    if (fragment) {
      const decoded = decodeURIComponent(window.atob(fragment));
      const parsed = JSON.parse(decoded, (key3, val) => typeof val === "object" && val !== null && bytesName in val && typeof val[bytesName] === "string" ? base64UrlDecode(val[bytesName]) : val);
      editor.insertFragment(parsed);
      return true;
    }
    return false;
  };
  editor.insertTextData = (data2) => {
    const blockAbove = Editor.above(editor, {
      match: isBlock
    });
    if ((blockAbove === null || blockAbove === void 0 ? void 0 : blockAbove[0].type) === "code") {
      const plain2 = data2.getData("text/plain");
      editor.insertText(plain2);
      return true;
    }
    let vsCodeEditorData = data2.getData("vscode-editor-data");
    if (vsCodeEditorData) {
      try {
        const vsCodeData = JSON.parse(vsCodeEditorData);
        if ((vsCodeData === null || vsCodeData === void 0 ? void 0 : vsCodeData.mode) === "markdown" || (vsCodeData === null || vsCodeData === void 0 ? void 0 : vsCodeData.mode) === "mdx") {
          const plain2 = data2.getData("text/plain");
          if (plain2) {
            const fragment = deserializeMarkdown(plain2);
            insertFragmentButDifferent(editor, fragment);
            return true;
          }
        }
      } catch (err) {
        console.log(err);
      }
    }
    const plain = data2.getData("text/plain");
    if (
      // isValidURL is a bit more permissive than a user might expect
      // so for pasting, we'll constrain it to starting with https:// or http://
      urlPattern$1.test(plain) && isValidURL$1(plain) && editor.selection && !Range.isCollapsed(editor.selection) && // we only want to turn the selected text into a link if the selection is within the same block
      Editor.above(editor, {
        match: (node3) => isBlock(node3) && !isBlock(node3.children[0])
      }) && // and there is only text(potentially with marks) in the selection
      // no other links
      Editor.nodes(editor, {
        match: (node3) => node3.type === "link"
      }).next().done
    ) {
      Transforms.wrapNodes(editor, {
        type: "link",
        href: plain,
        children: []
      }, {
        split: true
      });
      return true;
    }
    const html2 = data2.getData("text/html");
    if (html2) {
      const fragment = deserializeHTML(html2);
      insertFragmentButDifferent(editor, fragment);
      return true;
    }
    if (plain) {
      const fragment = deserializeMarkdown(plain);
      insertFragmentButDifferent(editor, fragment);
      return true;
    }
    return insertTextData(data2);
  };
  return editor;
}
var shortcuts$1 = {
  "...": "…",
  "-->": "→",
  "->": "→",
  "<-": "←",
  "<--": "←",
  "--": "–"
};
function withShortcuts(editor) {
  const {
    insertText
  } = editor;
  editor.insertText = (text7) => {
    insertText(text7);
    if (text7 === " " && editor.selection && Range.isCollapsed(editor.selection)) {
      const selectionPoint = editor.selection.anchor;
      const ancestorBlock = Editor.above(editor, {
        match: isBlock
      });
      if (ancestorBlock) {
        Object.keys(shortcuts$1).forEach((shortcut) => {
          const pointBefore = Editor.before(editor, selectionPoint, {
            unit: "character",
            distance: shortcut.length + 1
          });
          if (pointBefore && Path.isDescendant(pointBefore.path, ancestorBlock[1])) {
            const range = {
              anchor: selectionPoint,
              focus: pointBefore
            };
            const str = Editor.string(editor, range);
            if (str.slice(0, shortcut.length) === shortcut) {
              editor.history.undos.push({
                operations: [],
                selectionBefore: editor.selection
              });
              Transforms.select(editor, range);
              editor.insertText(shortcuts$1[shortcut] + " ");
            }
          }
        });
      }
    }
  };
  return editor;
}
function withSoftBreaks(editor) {
  editor.insertSoftBreak = () => {
    Transforms.insertText(editor, "\n");
  };
  return editor;
}
var HOTKEYS = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline"
};
function isMarkActive$1(editor, mark) {
  const marks = Editor.marks(editor);
  if (marks !== null && marks !== void 0 && marks[mark]) {
    return true;
  }
  for (const entry of Editor.nodes(editor, {
    match: Text2.isText
  })) {
    if (entry[0][mark]) {
      return true;
    }
  }
  return false;
}
var arrowKeyToDirection = /* @__PURE__ */ new Map([["ArrowUp", "up"], ["ArrowDown", "down"], ["ArrowLeft", "left"], ["ArrowRight", "right"]]);
var getKeyDownHandler = (editor, documentFeatures) => (event) => {
  if (event.defaultPrevented) return;
  for (const hotkey in HOTKEYS) {
    if (documentFeatures.formatting.inlineMarks[HOTKEYS[hotkey]] && (0, import_is_hotkey.isHotkey)(hotkey, event.nativeEvent)) {
      event.preventDefault();
      const mark = HOTKEYS[hotkey];
      const isActive = isMarkActive$1(editor, mark);
      if (isActive) {
        Editor.removeMark(editor, mark);
      } else {
        Editor.addMark(editor, mark, true);
      }
      return;
    }
  }
  if ((0, import_is_hotkey.isHotkey)("mod+\\", event.nativeEvent)) {
    clearFormatting(editor);
    return;
  }
  if (documentFeatures.links && (0, import_is_hotkey.isHotkey)("mod+k", event.nativeEvent)) {
    event.preventDefault();
    wrapLink(editor, "");
    return;
  }
  if (event.key === "Tab") {
    const didAction = event.shiftKey ? unnestList(editor) : nestList(editor);
    if (didAction) {
      event.preventDefault();
      return;
    }
  }
  if (event.key === "Tab" && editor.selection) {
    const layoutArea = Editor.above(editor, {
      match: (node3) => node3.type === "layout-area" || node3.type === "table-cell"
    });
    if (layoutArea) {
      const layoutAreaToEnter = event.shiftKey ? Editor.before(editor, layoutArea[1], {
        unit: "block"
      }) : Editor.after(editor, layoutArea[1], {
        unit: "block"
      });
      Transforms.setSelection(editor, {
        anchor: layoutAreaToEnter,
        focus: layoutAreaToEnter
      });
      event.preventDefault();
    }
  }
  if ((0, import_is_hotkey.isHotkey)("mod+a", event)) {
    const parentTable = Editor.above(editor, {
      match: nodeTypeMatcher("table")
    });
    if (parentTable) {
      Transforms.select(editor, parentTable[1]);
      event.preventDefault();
      return;
    }
  }
  const direction = arrowKeyToDirection.get(event.key);
  const {
    selection
  } = editor;
  if (direction && selection) {
    const selectedTableArea = getSelectedTableArea(editor);
    if (selectedTableArea) {
      var _Editor$above, _Editor$above2;
      const focusCellPath = (_Editor$above = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell"),
        at: selection.focus.path
      })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];
      const anchorCellPath = (_Editor$above2 = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell"),
        at: selection.anchor.path
      })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];
      if (!focusCellPath || !anchorCellPath) return;
      const newCellPath = getCellPathInDirection(editor, focusCellPath, direction);
      if (newCellPath) {
        if (selectedTableArea.singleCell === "not-selected") {
          if (direction !== "up" && direction !== "down") return;
          const [node3, offset5] = ReactEditor.toDOMPoint(editor, selection.focus);
          const blockElement = Editor.above(editor, {
            match: isBlock,
            at: selection.focus.path
          });
          if (!blockElement) return;
          if (direction === "up" && blockElement[1].slice(focusCellPath.length).some((idx) => idx !== 0)) {
            return;
          }
          if (direction === "down") {
            const [parentNode2] = Editor.parent(editor, blockElement[1]);
            if (parentNode2.children.length - 1 !== blockElement[1][blockElement[1].length - 1]) {
              return;
            }
            for (const [node4, path3] of Node2.ancestors(editor, blockElement[1], {
              reverse: true
            })) {
              if (node4.type === "table-cell") break;
              const [parentNode3] = Editor.parent(editor, path3);
              if (parentNode3.children.length - 1 === path3[path3.length - 1]) {
                continue;
              }
              return;
            }
          }
          const domNodeForBlockElement = ReactEditor.toDOMNode(editor, blockElement[0]);
          const rangeOfWholeBlock = document.createRange();
          rangeOfWholeBlock.selectNodeContents(domNodeForBlockElement);
          const rectsOfRangeOfWholeBlock = Array.from(rangeOfWholeBlock.getClientRects());
          const newRange = document.createRange();
          newRange.setStart(node3, offset5);
          newRange.setEnd(node3, offset5);
          const rangeRects = Array.from(newRange.getClientRects());
          const lastRangeRect = rangeRects[rangeRects.length - 1];
          const key3 = direction === "up" ? "top" : "bottom";
          const expected = key3 === "top" ? Math.min(...rectsOfRangeOfWholeBlock.map((x) => x.top)) : Math.max(...rectsOfRangeOfWholeBlock.map((x) => x.bottom));
          if (lastRangeRect[key3] === expected) {
            const focus = Editor[direction === "up" ? "end" : "start"](editor, newCellPath);
            Transforms.select(editor, {
              focus,
              anchor: event.shiftKey ? selection.anchor : focus
            });
            event.preventDefault();
          }
          return;
        }
        if (!event.shiftKey) return;
        if (Path.equals(newCellPath, anchorCellPath)) {
          Transforms.select(editor, newCellPath);
        } else {
          Transforms.select(editor, {
            anchor: selection.anchor,
            focus: Editor.start(editor, newCellPath)
          });
        }
        event.preventDefault();
      }
    }
  }
};
function createDocumentEditor(documentFeatures, componentBlocks) {
  return withPasting(withImages(withSoftBreaks(withInsertMenu(withShortcuts(withHeading(withBlockquote(withMarks(documentFeatures, componentBlocks, withBlockMarkdownShortcuts(documentFeatures, componentBlocks, _createDocumentEditor(withHistory(withReact(createEditor())), documentFeatures, componentBlocks))))))))));
}
function DocumentEditor({
  onChange,
  value,
  componentBlocks,
  documentFeatures,
  ...props
}) {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = (0, import_react55.useMemo)(() => createDocumentEditor(documentFeatures, componentBlocks), [documentFeatures, componentBlocks]);
  return (0, import_jsx_runtime70.jsx)("div", {
    "data-layout": entryLayoutPane,
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      minWidth: 0,
      '&[data-layout="main"]': {
        flex: 1,
        display: "flex",
        flexDirection: "column"
      },
      '&:not([data-layout="main"])': {
        border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
        borderRadius: tokenSchema.size.radius.medium
      }
    }), "keystar-document-editor"),
    children: (0, import_jsx_runtime70.jsxs)(DocumentEditorProvider, {
      componentBlocks,
      documentFeatures,
      editor,
      value,
      onChange: (value2) => {
        onChange === null || onChange === void 0 || onChange(value2);
        const selection = window.getSelection();
        if (selection && !ReactEditor.isFocused(editor)) {
          const editorNode = ReactEditor.toDOMNode(editor, editor);
          if (selection.anchorNode === editorNode) {
            ReactEditor.focus(editor);
          }
        }
      },
      children: [
        (0, import_react55.useMemo)(() => onChange !== void 0 && (0, import_jsx_runtime70.jsx)(Toolbar$1, {
          documentFeatures
        }), [documentFeatures, onChange]),
        (0, import_jsx_runtime70.jsx)(DocumentEditorEditable, {
          ...props,
          readOnly: onChange === void 0
        }),
        // for debugging
        false
      ]
    })
  });
}
var IsInEditorContext = (0, import_react55.createContext)(false);
function useIsInDocumentEditor() {
  return (0, import_react55.useContext)(IsInEditorContext);
}
function DocumentEditorProvider({
  children,
  editor,
  onChange,
  value,
  componentBlocks,
  documentFeatures
}) {
  const identity = (0, import_react55.useMemo)(() => Math.random().toString(36), [editor]);
  return (0, import_jsx_runtime70.jsx)(IsInEditorContext.Provider, {
    value: true,
    children: (0, import_jsx_runtime70.jsx)(
      Slate,
      {
        editor,
        value,
        onChange: (value2) => {
          onChange(value2);
          const selection = window.getSelection();
          if (selection && !ReactEditor.isFocused(editor)) {
            const editorNode = ReactEditor.toDOMNode(editor, editor);
            if (selection.anchorNode === editorNode) {
              ReactEditor.focus(editor);
            }
          }
        },
        children: (0, import_jsx_runtime70.jsx)(TableSelectionProvider, {
          children: (0, import_jsx_runtime70.jsx)(ToolbarStateProvider, {
            componentBlocks,
            editorDocumentFeatures: documentFeatures,
            children
          })
        })
      },
      identity
    )
  });
}
function getPrismTokenLength$1(token) {
  if (typeof token === "string") {
    return token.length;
  } else if (Array.isArray(token.content)) {
    return token.content.reduce((l2, t2) => l2 + getPrismTokenLength$1(t2), 0);
  } else {
    return getPrismTokenLength$1(token.content);
  }
}
function DocumentEditorEditable(props) {
  const containerSize = useContentPanelSize();
  const entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = useSlate();
  const {
    componentBlocks,
    documentFeatures
  } = useDocumentEditorConfig();
  const onKeyDown = (0, import_react55.useMemo)(() => getKeyDownHandler(editor, documentFeatures), [editor, documentFeatures]);
  return (0, import_jsx_runtime70.jsx)(ActiveBlockPopoverProvider, {
    editor,
    children: (0, import_jsx_runtime70.jsx)(Prose, {
      size: entryLayoutPane === "main" ? "medium" : "regular",
      children: (0, import_jsx_runtime70.jsx)(Editable, {
        placeholder: 'Start writing or press "/" for commands...',
        decorate: (0, import_react55.useCallback)(([node3, path3]) => {
          let decorations = [];
          if (node3.type === "component-block") {
            if (node3.children.length === 1 && Element2.isElement(node3.children[0]) && node3.children[0].type === "component-inline-prop" && node3.children[0].propPath === void 0) {
              return decorations;
            }
            node3.children.forEach((child, index4) => {
              if (Node2.string(child) === "" && Element2.isElement(child) && (child.type === "component-block-prop" || child.type === "component-inline-prop") && child.propPath !== void 0) {
                const start2 = Editor.start(editor, [...path3, index4]);
                const placeholder = getPlaceholderTextForPropPath(child.propPath, componentBlocks[node3.component].schema, node3.props);
                if (placeholder) {
                  decorations.push({
                    placeholder,
                    anchor: start2,
                    focus: start2
                  });
                }
              }
            });
          }
          if (node3.type === "code" && node3.children.length === 1 && node3.children[0].type === void 0 && node3.language && node3.language in Prism.languages) {
            let consumeTokens = function(start2, tokens2) {
              for (const token of tokens2) {
                const length = getPrismTokenLength$1(token);
                const end = start2 + length;
                if (typeof token !== "string") {
                  decorations.push({
                    ["prism_" + token.type]: true,
                    anchor: {
                      path: textPath,
                      offset: start2
                    },
                    focus: {
                      path: textPath,
                      offset: end
                    }
                  });
                  consumeTokens(start2, Array.isArray(token.content) ? token.content : [token.content]);
                }
                start2 = end;
              }
            };
            const textPath = [...path3, 0];
            const tokens = Prism.tokenize(node3.children[0].text, Prism.languages[node3.language]);
            consumeTokens(0, tokens);
          }
          return decorations;
        }, [editor, componentBlocks]),
        onKeyDown,
        renderElement,
        renderLeaf,
        ...props,
        ...toDataAttributes({
          container: containerSize,
          layout: entryLayoutPane
        }),
        className: classNames(editableStyles, props.className)
      })
    })
  });
}
var styles$1 = {
  flex: 1,
  height: "auto",
  minHeight: tokenSchema.size.scale[2e3],
  minWidth: 0,
  padding: tokenSchema.size.space.medium,
  '&[data-layout="main"]': {
    boxSizing: "border-box",
    height: "100%",
    padding: 0,
    paddingTop: tokenSchema.size.space.medium,
    minHeight: 0,
    minWidth: 0,
    maxWidth: 800,
    marginInline: "auto",
    [breakpointQueries$1.above.mobile]: {
      padding: tokenSchema.size.space.xlarge
    },
    [breakpointQueries$1.above.tablet]: {
      padding: tokenSchema.size.space.xxlarge
    },
    '&[data-container="wide"]': {
      padding: tokenSchema.size.scale[600]
    }
  }
};
var editableStyles = css({
  ...styles$1,
  a: {
    color: tokenSchema.color.foreground.accent
  }
});
var emptyObj = {};
var i$2 = 0;
function newKey$1() {
  return i$2++;
}
function InnerChildFieldInput(props) {
  const outerConfig = useDocumentEditorConfig();
  const [state2, setState] = (0, import_react55.useState)(() => ({
    key: newKey$1(),
    value: props.value
  }));
  const documentFeatures = (0, import_react55.useMemo)(() => {
    return getWholeDocumentFeaturesForChildField(outerConfig.documentFeatures, props.schema.options);
  }, [props.schema, outerConfig.documentFeatures]);
  if (state2.value !== props.value) {
    setState({
      key: newKey$1(),
      value: props.value
    });
  }
  return (0, import_jsx_runtime70.jsx)(ResetEntryLayoutContext, {
    children: (0, import_jsx_runtime70.jsx)(Field, {
      label: props.schema.options.label,
      children: (inputProps) => (0, import_react55.createElement)(DocumentEditor, {
        ...inputProps,
        key: state2.key,
        componentBlocks: props.schema.options.componentBlocks === "inherit" ? outerConfig.componentBlocks : emptyObj,
        documentFeatures,
        onChange: (val) => {
          setState((state3) => ({
            key: state3.key,
            value: val
          }));
          props.onChange(val);
        },
        value: state2.value
      })
    })
  });
}
function ChildFieldInput(props) {
  const data2 = getChildFieldData(props);
  if (props.schema.options.kind === "block" && (props.schema.options.editIn === "both" || props.schema.options.editIn === "modal") && data2.value) {
    return (0, import_jsx_runtime70.jsx)(InnerChildFieldInput, {
      schema: props.schema,
      ...data2
    });
  }
  return null;
}
function getInputComponent(schema) {
  if (schema.kind === "object") {
    var _schema$Input;
    return (_schema$Input = schema.Input) !== null && _schema$Input !== void 0 ? _schema$Input : ObjectFieldInput;
  }
  if (schema.kind === "conditional") {
    var _schema$Input2;
    return (_schema$Input2 = schema.Input) !== null && _schema$Input2 !== void 0 ? _schema$Input2 : ConditionalFieldInput;
  }
  if (schema.kind === "array") {
    var _schema$Input3;
    return (_schema$Input3 = schema.Input) !== null && _schema$Input3 !== void 0 ? _schema$Input3 : ArrayFieldInput;
  }
  if (schema.kind === "child") {
    return ChildFieldInput;
  }
  return schema.Input;
}
var InnerFormValueContentFromPreviewProps = (0, import_react55.memo)(function InnerFormValueContentFromPreview(props) {
  let Input = getInputComponent(props.schema);
  return (0, import_jsx_runtime70.jsx)(Input, {
    ...props,
    autoFocus: !!props.autoFocus,
    forceValidation: !!props.forceValidation
  });
});
var emptyArray = [];
var FormValueContentFromPreviewProps = (0, import_react55.memo)(function FormValueContentFromPreview({
  slugField,
  ...props
}) {
  let Input = getInputComponent(props.schema);
  return (0, import_jsx_runtime70.jsx)(PathContextProvider, {
    value: emptyArray,
    children: (0, import_jsx_runtime70.jsx)(SlugFieldProvider, {
      value: slugField,
      children: (0, import_jsx_runtime70.jsx)(Input, {
        ...props,
        autoFocus: !!props.autoFocus,
        forceValidation: !!props.forceValidation
      })
    })
  });
});
var VariableChildFields = class extends Error {
  constructor() {
    super("There are a variable number of child fields");
  }
};
function findSingleChildField(schema) {
  try {
    const result = _findConstantChildFields(schema, [], /* @__PURE__ */ new Set());
    if (result.length === 1) {
      return result[0];
    }
    return;
  } catch (err) {
    if (err instanceof VariableChildFields) {
      return;
    }
    throw err;
  }
}
function _findConstantChildFields(schema, path3, seenSchemas) {
  if (seenSchemas.has(schema)) {
    return [];
  }
  seenSchemas.add(schema);
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        relativePath: path3,
        options: schema.options,
        kind: "child"
      }];
    case "conditional": {
      if (couldContainChildField(schema)) {
        throw new VariableChildFields();
      }
      return [];
    }
    case "array": {
      if (schema.asChildTag) {
        const child = _findConstantChildFields(schema.element, [], seenSchemas);
        if (child.length > 1) {
          return [];
        }
        return [{
          kind: "array",
          asChildTag: schema.asChildTag,
          field: schema,
          relativePath: path3,
          child: child[0]
        }];
      }
      if (couldContainChildField(schema)) {
        throw new VariableChildFields();
      }
      return [];
    }
    case "object": {
      const paths = [];
      for (const [key3, value] of Object.entries(schema.fields)) {
        paths.push(..._findConstantChildFields(value, path3.concat(key3), seenSchemas));
      }
      return paths;
    }
  }
}
function couldContainChildField(schema, seen = /* @__PURE__ */ new Set()) {
  if (seen.has(schema)) {
    return false;
  }
  seen.add(schema);
  switch (schema.kind) {
    case "form":
      return false;
    case "child":
      return true;
    case "conditional":
      return Object.values(schema.values).some((value) => couldContainChildField(value, seen));
    case "object":
      return Object.keys(schema.fields).some((key3) => couldContainChildField(schema.fields[key3], seen));
    case "array":
      return couldContainChildField(schema.element, seen);
  }
}
function inlineNodeFromMarkdoc(node3) {
  if (node3.type === "inline") {
    return inlineChildrenFromMarkdoc(node3.children);
  }
  if (node3.type === "link") {
    return setLinkForChildren(node3.attributes.href, () => inlineChildrenFromMarkdoc(node3.children));
  }
  if (node3.type === "text") {
    return getInlineNodes(node3.attributes.content);
  }
  if (node3.type === "strong") {
    return addMarkToChildren("bold", () => inlineChildrenFromMarkdoc(node3.children));
  }
  if (node3.type === "code") {
    return addMarkToChildren("code", () => getInlineNodes(node3.attributes.content));
  }
  if (node3.type === "em") {
    return addMarkToChildren("italic", () => inlineChildrenFromMarkdoc(node3.children));
  }
  if (node3.type === "s") {
    return addMarkToChildren("strikethrough", () => inlineChildrenFromMarkdoc(node3.children));
  }
  if (node3.type === "tag") {
    if (node3.tag === "u") {
      return addMarkToChildren("underline", () => inlineChildrenFromMarkdoc(node3.children));
    }
    if (node3.tag === "kbd") {
      return addMarkToChildren("keyboard", () => inlineChildrenFromMarkdoc(node3.children));
    }
    if (node3.tag === "sub") {
      return addMarkToChildren("subscript", () => inlineChildrenFromMarkdoc(node3.children));
    }
    if (node3.tag === "sup") {
      return addMarkToChildren("superscript", () => inlineChildrenFromMarkdoc(node3.children));
    }
  }
  if (node3.type === "softbreak") {
    return getInlineNodes(" ");
  }
  if (node3.type === "hardbreak") {
    return getInlineNodes("\n");
  }
  if (node3.tag === "component-inline-prop" && Array.isArray(node3.attributes.propPath) && node3.attributes.propPath.every((x) => typeof x === "string" || typeof x === "number")) {
    return {
      type: "component-inline-prop",
      children: inlineFromMarkdoc(node3.children),
      propPath: node3.attributes.propPath
    };
  }
  throw new Error(`Unknown inline node type: ${node3.type}`);
}
function inlineChildrenFromMarkdoc(nodes) {
  return nodes.flatMap(inlineNodeFromMarkdoc);
}
function inlineFromMarkdoc(nodes) {
  const transformedNodes = nodes.flatMap(inlineNodeFromMarkdoc);
  const nextNodes = [];
  let lastNode;
  for (const [idx, node3] of transformedNodes.entries()) {
    var _lastNode;
    if (node3.type === void 0 && node3.text === "" && ((_lastNode = lastNode) === null || _lastNode === void 0 ? void 0 : _lastNode.type) === void 0 && idx !== transformedNodes.length - 1) {
      continue;
    }
    nextNodes.push(node3);
    lastNode = node3;
  }
  if (!nextNodes.length) {
    nextNodes.push({
      text: ""
    });
  }
  return nextNodes;
}
function fromMarkdoc(node3, componentBlocks) {
  const nodes = node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks));
  if (nodes.length === 0) {
    return [{
      type: "paragraph",
      children: [{
        text: ""
      }]
    }];
  }
  if (nodes[nodes.length - 1].type !== "paragraph") {
    nodes.push({
      type: "paragraph",
      children: [{
        text: ""
      }]
    });
  }
  return nodes;
}
function fromMarkdocNode(node3, componentBlocks) {
  if (node3.type === "blockquote") {
    return {
      type: "blockquote",
      children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
    };
  }
  if (node3.type === "fence") {
    const {
      language,
      content: content3,
      ...rest
    } = node3.attributes;
    return {
      type: "code",
      children: [{
        text: content3.replace(/\n$/, "")
      }],
      ...typeof language === "string" ? {
        language
      } : {},
      ...rest
    };
  }
  if (node3.type === "heading") {
    return {
      ...node3.attributes,
      level: node3.attributes.level,
      type: "heading",
      children: inlineFromMarkdoc(node3.children)
    };
  }
  if (node3.type === "list") {
    return {
      type: node3.attributes.ordered ? "ordered-list" : "unordered-list",
      children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
    };
  }
  if (node3.type === "item") {
    var _node$children$;
    const children = [{
      type: "list-item-content",
      children: node3.children.length ? inlineFromMarkdoc([node3.children[0]]) : [{
        text: ""
      }]
    }];
    if (((_node$children$ = node3.children[1]) === null || _node$children$ === void 0 ? void 0 : _node$children$.type) === "list") {
      const list5 = node3.children[1];
      children.push({
        type: list5.attributes.ordered ? "ordered-list" : "unordered-list",
        children: list5.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
      });
    }
    return {
      type: "list-item",
      children
    };
  }
  if (node3.type === "paragraph") {
    if (node3.children.length === 1 && node3.children[0].type === "inline" && node3.children[0].children.length === 1 && node3.children[0].children[0].type === "image") {
      var _image$attributes$tit;
      const image3 = node3.children[0].children[0];
      return {
        type: "image",
        src: decodeURI(image3.attributes.src),
        alt: image3.attributes.alt,
        title: (_image$attributes$tit = image3.attributes.title) !== null && _image$attributes$tit !== void 0 ? _image$attributes$tit : "",
        children: [{
          text: ""
        }]
      };
    }
    const children = inlineFromMarkdoc(node3.children);
    if (children.length === 1 && children[0].type === "component-inline-prop") {
      return children[0];
    }
    return {
      type: "paragraph",
      children,
      textAlign: node3.attributes.textAlign
    };
  }
  if (node3.type === "hr") {
    return {
      type: "divider",
      children: [{
        text: ""
      }]
    };
  }
  if (node3.type === "table") {
    return {
      type: "table",
      children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
    };
  }
  if (node3.type === "tbody") {
    return {
      type: "table-body",
      children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
    };
  }
  if (node3.type === "thead") {
    if (!node3.children.length) return [];
    return {
      type: "table-head",
      children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
    };
  }
  if (node3.type === "tr") {
    return {
      type: "table-row",
      children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
    };
  }
  if (node3.type === "td") {
    return {
      type: "table-cell",
      children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
    };
  }
  if (node3.type === "th") {
    return {
      type: "table-cell",
      header: true,
      children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
    };
  }
  if (node3.type === "tag") {
    if (node3.tag === "table") {
      return fromMarkdocNode(node3.children[0], componentBlocks);
    }
    if (node3.tag === "layout") {
      return {
        type: "layout",
        layout: node3.attributes.layout,
        children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
      };
    }
    if (node3.tag === "layout-area") {
      return {
        type: "layout-area",
        children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
      };
    }
    if (node3.tag === "component-block") {
      return {
        type: "component-block",
        component: node3.attributes.component,
        props: node3.attributes.props,
        children: node3.children.length === 0 ? [{
          type: "component-inline-prop",
          children: [{
            text: ""
          }]
        }] : node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
      };
    }
    if (node3.tag === "component-block-prop" && Array.isArray(node3.attributes.propPath) && node3.attributes.propPath.every((x) => typeof x === "string" || typeof x === "number")) {
      return {
        type: "component-block-prop",
        children: node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks)),
        propPath: node3.attributes.propPath
      };
    }
    if (node3.tag) {
      const componentBlock = componentBlocks[node3.tag];
      if (componentBlock) {
        const singleChildField = findSingleChildField({
          kind: "object",
          fields: componentBlock.schema
        });
        if (singleChildField) {
          const newAttributes = JSON.parse(JSON.stringify(node3.attributes));
          const children = [];
          toChildrenAndProps$1(node3.children, children, newAttributes, singleChildField, [], componentBlocks);
          return {
            type: "component-block",
            component: node3.tag,
            props: newAttributes,
            children
          };
        }
        return {
          type: "component-block",
          component: node3.tag,
          props: node3.attributes,
          children: node3.children.length === 0 ? [{
            type: "component-inline-prop",
            children: [{
              text: ""
            }]
          }] : node3.children.flatMap((x) => fromMarkdocNode(x, componentBlocks))
        };
      }
    }
    throw new Error(`Unknown tag: ${node3.tag}`);
  }
  return inlineNodeFromMarkdoc(node3);
}
function toChildrenAndProps$1(fromMarkdoc2, resultingChildren, value, singleChildField, parentPropPath, componentBlocks) {
  if (singleChildField.kind === "child") {
    const children = fromMarkdoc2.flatMap((x) => fromMarkdocNode(x, componentBlocks));
    resultingChildren.push({
      type: `component-${singleChildField.options.kind}-prop`,
      propPath: [...parentPropPath, ...singleChildField.relativePath],
      children
    });
  }
  if (singleChildField.kind === "array") {
    const arr = [];
    for (let [idx, child] of fromMarkdoc2.entries()) {
      if (child.type === "paragraph") {
        child = child.children[0].children[0];
      }
      if (child.type !== "tag") {
        throw new Error(`expected tag ${singleChildField.asChildTag}, found type: ${child.type}`);
      }
      if (child.tag !== singleChildField.asChildTag) {
        throw new Error(`expected tag ${singleChildField.asChildTag}, found tag: ${child.tag}`);
      }
      const attributes = JSON.parse(JSON.stringify(child.attributes));
      if (singleChildField.child) {
        toChildrenAndProps$1(child.children, resultingChildren, attributes, singleChildField.child, [...parentPropPath, ...singleChildField.relativePath, idx], componentBlocks);
      }
      arr.push(attributes);
    }
    const key3 = singleChildField.relativePath[singleChildField.relativePath.length - 1];
    const parent = getValueAtPropPath(value, singleChildField.relativePath.slice(0, -1));
    parent[key3] = arr;
  }
}
function getSrcPrefix(publicPath, slug) {
  return typeof publicPath === "string" ? `${publicPath.replace(/\/*$/, "")}/${slug === void 0 ? "" : slug + "/"}` : "";
}
function deserializeFiles(nodes, componentBlocks, files, otherFiles, mode, documentFeatures, slug) {
  return nodes.map((node3) => {
    if (node3.type === "component-block") {
      const componentBlock = componentBlocks[node3.component];
      if (!componentBlock) return node3;
      const schema = object(componentBlock.schema);
      return {
        ...node3,
        props: deserializeProps$2(schema, node3.props, files, otherFiles, mode, slug)
      };
    }
    if (node3.type === "image" && typeof node3.src === "string" && mode === "edit") {
      var _ref;
      const prefix = getSrcPrefixForImageBlock$1(documentFeatures, slug);
      const filename = node3.src.slice(prefix.length);
      const content3 = (_ref = typeof documentFeatures.images === "object" && typeof documentFeatures.images.directory === "string" ? otherFiles.get(fixPath(documentFeatures.images.directory)) : files) === null || _ref === void 0 ? void 0 : _ref.get(filename);
      if (!content3) {
        return {
          type: "paragraph",
          children: [{
            text: `Missing image ${filename}`
          }]
        };
      }
      return {
        type: "image",
        src: {
          filename,
          content: content3
        },
        alt: node3.alt,
        title: node3.title,
        children: [{
          text: ""
        }]
      };
    }
    if (typeof node3.type === "string") {
      const children = deserializeFiles(node3.children, componentBlocks, files, otherFiles, mode, documentFeatures, slug);
      return {
        ...node3,
        children
      };
    }
    return node3;
  });
}
function deserializeProps$2(schema, value, files, otherFiles, mode, slug) {
  return transformProps(schema, value, {
    form: (schema2, value2) => {
      if (schema2.formKind === "asset") {
        var _otherFiles$get;
        if (mode === "read") {
          return schema2.reader.parse(value2);
        }
        const filename = schema2.filename(value2, {
          slug,
          suggestedFilenamePrefix: void 0
        });
        return schema2.parse(value2, {
          asset: filename ? schema2.directory ? (_otherFiles$get = otherFiles.get(schema2.directory)) === null || _otherFiles$get === void 0 ? void 0 : _otherFiles$get.get(filename) : files.get(filename) : void 0,
          slug
        });
      }
      if (schema2.formKind === "content") {
        throw new Error("Not implemented");
      }
      if (mode === "read") {
        return schema2.reader.parse(value2);
      }
      return schema2.parse(value2, void 0);
    }
  });
}
function getSrcPrefixForImageBlock$1(documentFeatures, slug) {
  return getSrcPrefix(typeof documentFeatures.images === "object" ? documentFeatures.images.publicPath : void 0, slug);
}
function serializeProps$1(rootValue, rootSchema, slugField, slug, shouldSuggestFilenamePrefix) {
  const extraFiles = [];
  return {
    value: transformProps(rootSchema, rootValue, {
      form(schema, value, propPath) {
        if (propPath.length === 1 && slugField === propPath[0]) {
          if (schema.formKind !== "slug") {
            throw new Error("slugField is a not a slug field");
          }
          return schema.serializeWithSlug(value).value;
        }
        if (schema.formKind === "asset") {
          const {
            asset,
            value: forYaml
          } = schema.serialize(value, {
            suggestedFilenamePrefix: shouldSuggestFilenamePrefix ? getPropPathPortion(propPath, rootSchema, rootValue) : void 0,
            slug
          });
          if (asset) {
            extraFiles.push({
              path: asset.filename,
              contents: asset.content,
              parent: schema.directory
            });
          }
          return forYaml;
        }
        if (schema.formKind === "content") {
          const {
            other,
            external: external2,
            content: content3,
            value: forYaml
          } = schema.serialize(value, {
            slug
          });
          if (content3) {
            extraFiles.push({
              path: getPropPathPortion(propPath, rootSchema, rootValue) + schema.contentExtension,
              contents: content3,
              parent: void 0
            });
          }
          for (const [key3, contents] of other) {
            extraFiles.push({
              path: getPropPathPortion(propPath, rootSchema, rootValue) + "/" + key3,
              contents,
              parent: void 0
            });
          }
          const allowedDirectories = new Set(schema.directories);
          for (const [directory, contents] of external2) {
            if (!allowedDirectories.has(directory)) {
              throw new Error(`Invalid directory ${directory} in content field serialization`);
            }
            for (const [filename, fileContents] of contents) {
              extraFiles.push({
                path: filename,
                contents: fileContents,
                parent: directory
              });
            }
          }
          return forYaml;
        }
        return schema.serialize(value).value;
      },
      object(_schema, value) {
        return Object.fromEntries(Object.entries(value).filter(([_, val]) => val !== void 0));
      },
      array(_schema, value) {
        return value.map((val) => val === void 0 ? null : val);
      },
      child() {
        return void 0;
      }
    }),
    extraFiles
  };
}
function getPropPathPortion(path3, schema, value) {
  const end = [];
  for (const portion of path3) {
    if (schema.kind === "array") {
      value = value[portion];
      if (schema.slugField && schema.element.kind === "object") {
        const slug = getSlugFromState({
          schema: schema.element.fields,
          slugField: schema.slugField
        }, value);
        end.push(slug);
      } else {
        end.push(portion);
      }
      schema = schema.element;
      continue;
    }
    end.push(portion);
    if (schema.kind === "object") {
      value = value[portion];
      schema = schema.fields[portion];
      continue;
    }
    if (schema.kind === "conditional") {
      if (portion === "discriminant") {
        schema = schema.discriminant;
      } else if (portion === "value") {
        schema = schema.values[value.discriminant];
      }
      value = value[portion];
      continue;
    }
    throw new Error(`unexpected ${schema.kind}`);
  }
  return end.join("/");
}
function toInline(nodes) {
  return new ast_default.Node("inline", {}, nodes.flatMap(toMarkdocInline));
}
var markToMarkdoc = {
  bold: {
    type: "strong"
  },
  code: {
    type: "code"
  },
  italic: {
    type: "em"
  },
  underline: {
    type: "tag",
    tag: "u"
  },
  keyboard: {
    type: "tag",
    tag: "kbd"
  },
  strikethrough: {
    type: "s"
  },
  subscript: {
    type: "tag",
    tag: "sub"
  },
  superscript: {
    type: "tag",
    tag: "sup"
  }
};
function toMarkdocInline(node3) {
  var _exec, _exec2;
  if (node3.type === "link") {
    return new ast_default.Node("link", {
      href: node3.href
    }, node3.children.flatMap(toMarkdocInline));
  }
  if (node3.type !== void 0) {
    throw new Error(`unexpected inline node type: ${node3.type}`);
  }
  const marks = Object.keys(node3).filter((mark) => mark !== "text" && mark !== "code").sort();
  const splitByNewLines = node3.text.split(/\n/);
  if (splitByNewLines.length > 1) {
    return splitByNewLines.flatMap((x, i2) => {
      if (i2 === 0) {
        return toMarkdocInline({
          ...node3,
          text: x
        });
      }
      const inner = toMarkdocInline({
        ...node3,
        text: x
      });
      return [new ast_default.Node("hardbreak"), ...Array.isArray(inner) ? inner : [inner]];
    });
  }
  const leadingWhitespace = (_exec = /^\s+/.exec(node3.text)) === null || _exec === void 0 ? void 0 : _exec[0];
  const trailingWhitespace = (_exec2 = /\s+$/.exec(node3.text)) === null || _exec2 === void 0 ? void 0 : _exec2[0];
  let children = node3.code ? [new ast_default.Node("code", {
    content: node3.text.trim()
  }, [])] : [new ast_default.Node("text", {
    content: node3.text.trim()
  })];
  for (const mark of marks) {
    const config3 = markToMarkdoc[mark];
    if (config3) {
      children = [new ast_default.Node(config3.type, {}, children, config3.tag)];
    }
  }
  if (/^\s+$/.test(node3.text)) {
    children.unshift(new ast_default.Node("text", {
      content: leadingWhitespace
    }, []));
  } else {
    if (leadingWhitespace !== null && leadingWhitespace !== void 0 && leadingWhitespace.length) {
      children.unshift(new ast_default.Node("text", {
        content: leadingWhitespace
      }, []));
    }
    if (trailingWhitespace !== null && trailingWhitespace !== void 0 && trailingWhitespace.length) {
      children.push(new ast_default.Node("text", {
        content: trailingWhitespace
      }, []));
    }
  }
  return children;
}
function toMarkdocDocument(nodes, _config) {
  const extraFiles = [];
  const config3 = {
    ..._config,
    extraFiles
  };
  const node3 = new ast_default.Node("document", {}, nodes.flatMap((x) => toMarkdoc(x, config3)));
  return {
    node: node3,
    extraFiles
  };
}
function toChildrenAndProps(childrenAsMarkdoc, resultingChildren, value, singleChildField) {
  if (singleChildField.kind === "child") {
    const child = childrenAsMarkdoc.find((x) => areArraysEqual(x.propPath, singleChildField.relativePath));
    if (child) {
      resultingChildren.push(...child.children);
    }
    return;
  }
  if (singleChildField.kind === "array") {
    const key3 = singleChildField.relativePath[singleChildField.relativePath.length - 1];
    const parent = getValueAtPropPath(value, singleChildField.relativePath.slice(0, -1));
    const valueAtPropPath = parent[key3];
    delete parent[key3];
    const childNodes = /* @__PURE__ */ new Map();
    for (const child of childrenAsMarkdoc) {
      const innerPropPath = child.propPath.slice(singleChildField.relativePath.length + 1);
      const num = child.propPath[singleChildField.relativePath.length];
      if (childNodes.get(num) === void 0) {
        childNodes.set(num, []);
      }
      childNodes.get(num).push({
        children: child.children,
        propPath: innerPropPath
      });
    }
    resultingChildren.push(...valueAtPropPath.map((x, i2) => {
      var _childNodes$get;
      const newChildrenAsMarkdoc = (_childNodes$get = childNodes.get(i2)) !== null && _childNodes$get !== void 0 ? _childNodes$get : [];
      const children = [];
      toChildrenAndProps(newChildrenAsMarkdoc, children, x, singleChildField.child);
      return new ast_default.Node("tag", x, children, singleChildField.asChildTag);
    }));
  }
}
function toMarkdoc(node3, config3) {
  if (node3.type === "paragraph") {
    const markdocNode = new ast_default.Node("paragraph", node3.textAlign ? {
      textAlign: node3.textAlign
    } : {}, [toInline(node3.children)]);
    if (node3.textAlign) {
      markdocNode.annotations.push({
        name: "textAlign",
        value: node3.textAlign,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  if (node3.type === "image") {
    config3.extraFiles.push({
      contents: node3.src.content,
      path: node3.src.filename,
      parent: typeof config3.documentFeatures.images === "object" && typeof config3.documentFeatures.images.directory === "string" ? fixPath(config3.documentFeatures.images.directory) : void 0
    });
    return new ast_default.Node("paragraph", {}, [new ast_default.Node("inline", {}, [new ast_default.Node("image", {
      src: encodeURI(`${getSrcPrefixForImageBlock$1(config3.documentFeatures, config3.slug)}${node3.src.filename}`),
      alt: node3.alt,
      title: node3.title
    })])]);
  }
  if (node3.type === "code") {
    const extraAttributes = {};
    const {
      children,
      language,
      type,
      ...rest
    } = node3;
    const schema = typeof config3.documentFeatures.formatting.blockTypes.code === "object" ? config3.documentFeatures.formatting.blockTypes.code.schema : void 0;
    if (schema && Object.keys(schema.fields).length > 0) {
      const serialized = serializeProps$1(getInitialPropsValueFromInitializer(schema, rest), schema, void 0, config3.slug, false);
      Object.assign(extraAttributes, serialized.value);
      config3.extraFiles.push(...serialized.extraFiles);
    }
    let content3 = children[0].text + "\n";
    const markdocNode = new ast_default.Node("fence", {
      content: content3,
      language,
      ...extraAttributes
    }, [new ast_default.Node("text", {
      content: content3
    })]);
    for (const [key3, value] of Object.entries(extraAttributes)) {
      markdocNode.annotations.push({
        name: key3,
        value,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  const _toMarkdoc = (node4) => toMarkdoc(node4, config3);
  if (node3.type === "blockquote") {
    return new ast_default.Node("blockquote", {}, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "divider") {
    return new ast_default.Node("hr");
  }
  if (node3.type === "table") {
    const head = node3.children.find((x) => x.type === "table-head");
    return new ast_default.Node("tag", {}, [new ast_default.Node("table", {}, [new ast_default.Node("thead", {}, head ? head.children.map(_toMarkdoc) : []), _toMarkdoc(node3.children.find((x) => x.type === "table-body"))])], "table");
  }
  if (node3.type === "table-body") {
    return new ast_default.Node("tbody", {}, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "table-row") {
    return new ast_default.Node("tr", {}, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "table-cell") {
    return new ast_default.Node(node3.header ? "th" : "td", {}, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "heading") {
    const extraAttributes = {};
    if (node3.textAlign) {
      extraAttributes.textAlign = node3.textAlign;
    }
    const {
      children,
      level,
      textAlign,
      type,
      ...rest
    } = node3;
    const schema = config3.documentFeatures.formatting.headings.schema;
    if (Object.keys(schema.fields).length > 0) {
      Object.assign(extraAttributes, serializeProps$1(getInitialPropsValueFromInitializer(schema, rest), schema, void 0, config3.slug, false).value);
    }
    const markdocNode = new ast_default.Node("heading", {
      level: node3.level,
      ...extraAttributes
    }, [toInline(node3.children)]);
    for (const [key3, value] of Object.entries(extraAttributes)) {
      markdocNode.annotations.push({
        name: key3,
        value,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  if (node3.type === "ordered-list") {
    return new ast_default.Node("list", {
      ordered: true
    }, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "unordered-list") {
    return new ast_default.Node("list", {
      ordered: false
    }, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "layout") {
    return new ast_default.Node("tag", {
      layout: node3.layout
    }, node3.children.map(_toMarkdoc), "layout");
  }
  if (node3.type === "layout-area") {
    return new ast_default.Node("tag", {}, node3.children.flatMap(_toMarkdoc), "layout-area");
  }
  if (node3.type === "component-block") {
    const isVoid = node3.children.length === 1 && node3.children[0].type === "component-inline-prop" && node3.children[0].propPath === void 0;
    const componentBlock = config3.componentBlocks[node3.component];
    const childrenAsMarkdoc = [];
    for (const child of node3.children) {
      if ((child.type === "component-block-prop" || child.type === "component-inline-prop") && child.propPath !== void 0) {
        childrenAsMarkdoc.push({
          type: child.type,
          propPath: child.propPath,
          children: child.type === "component-block-prop" ? child.children.flatMap(_toMarkdoc) : [toInline(child.children)]
        });
      }
    }
    let attributes = node3.props;
    if (componentBlock) {
      const serialized = serializeProps$1(node3.props, {
        kind: "object",
        fields: componentBlock.schema
      }, void 0, config3.slug, false);
      attributes = serialized.value;
      config3.extraFiles.push(...serialized.extraFiles);
      const singleChildField = findSingleChildField({
        kind: "object",
        fields: componentBlock.schema
      });
      if (singleChildField) {
        const children2 = [];
        toChildrenAndProps(childrenAsMarkdoc, children2, attributes, singleChildField);
        return new ast_default.Node("tag", attributes, children2, node3.component);
      }
    }
    const children = isVoid ? [] : childrenAsMarkdoc.map((x) => new ast_default.Node("tag", {
      propPath: x.propPath
    }, x.children, x.type));
    return new ast_default.Node("tag", attributes, children, node3.component);
  }
  if (node3.type === "component-block-prop" || node3.type === "component-inline-prop") {
    return new ast_default.Node("tag", {
      propPath: node3.propPath
    }, node3.type === "component-inline-prop" ? [toInline(node3.children)] : node3.children.flatMap(_toMarkdoc), node3.type);
  }
  if (node3.type === "list-item") {
    const listItemContent = node3.children[0];
    if (listItemContent.type !== "list-item-content") {
      throw new Error("list item content must contain a list-item-content");
    }
    const inline7 = toInline(listItemContent.children);
    const children = [inline7];
    const nestedList = node3.children[1];
    if (nestedList) {
      children.push(toMarkdoc(nestedList, config3));
    }
    return new ast_default.Node("item", {}, children);
  }
  if (node3.type === "list-item-content") {
    throw new Error("list-item-content in unexpected position");
  }
  debugger;
  throw new Error(`unexpected node type: ${node3.type}`);
}
var i$1 = 0;
function newKey() {
  return i$1++;
}
var encoder = new TextEncoder();
function serializeMarkdoc(value, opts, componentBlocks, documentFeatures) {
  const {
    extraFiles,
    node: node3
  } = toMarkdocDocument(value, {
    componentBlocks,
    documentFeatures,
    slug: opts.slug
  });
  const other = /* @__PURE__ */ new Map();
  const external2 = /* @__PURE__ */ new Map();
  for (const file of extraFiles) {
    if (file.parent === void 0) {
      other.set(file.path, file.contents);
      continue;
    }
    if (!external2.has(file.parent)) {
      external2.set(file.parent, /* @__PURE__ */ new Map());
    }
    external2.get(file.parent).set(file.path, file.contents);
  }
  return {
    content: encoder.encode(format(parse3(format(node3)))),
    other,
    external: external2,
    value: void 0
  };
}
function normalizeDocumentFieldChildren(documentFeatures, componentBlocks, document5) {
  const editor = createDocumentEditorForNormalization(documentFeatures, componentBlocks);
  editor.children = document5;
  Editor.normalize(editor, {
    force: true
  });
  return editor.children;
}
function DocumentFieldInput$1(props) {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const [state2, setState] = (0, import_react55.useState)(() => ({
    key: newKey(),
    value: props.value
  }));
  if (state2.value !== props.value) {
    setState({
      key: newKey(),
      value: props.value
    });
  }
  let fieldProps = {
    label: props.label,
    labelElementType: "span",
    // the editor element isn't an input, so we need to use a span for the label
    description: props.description
  };
  if (entryLayoutPane === "main") {
    fieldProps = {
      "aria-label": props.label
      // `aria-description` is still in W3C Editor's Draft for ARIA 1.3.
    };
  }
  return (0, import_jsx_runtime70.jsx)(Field, {
    height: entryLayoutPane === "main" ? "100%" : void 0,
    ...fieldProps,
    children: (inputProps) => (0, import_react55.createElement)(DocumentEditor, {
      ...inputProps,
      key: state2.key,
      componentBlocks: props.componentBlocks,
      documentFeatures: props.documentFeatures,
      onChange: (val) => {
        setState((state3) => ({
          key: state3.key,
          value: val
        }));
        props.onChange(val);
      },
      value: state2.value
    })
  });
}
var textDecoder$2 = new TextDecoder();
var defaultAltField$1 = text({
  label: "Alt text",
  description: "This text will be used by screen readers and search engines."
});
var emptyTitleField$1 = basicFormFieldWithSimpleReaderParse({
  Input() {
    return null;
  },
  defaultValue() {
    return "";
  },
  parse(value) {
    if (value === void 0) return "";
    if (typeof value !== "string") {
      throw new FieldDataError("Must be string");
    }
    return value;
  },
  validate(value) {
    return value;
  },
  serialize(value) {
    return {
      value
    };
  },
  label: "Title"
});
function normaliseDocumentFeatures(config3) {
  var _config$formatting, _formatting$alignment, _formatting$alignment2, _formatting$blockType, _formatting$inlineMar, _formatting$inlineMar2, _formatting$inlineMar3, _formatting$inlineMar4, _formatting$inlineMar5, _formatting$inlineMar6, _formatting$inlineMar7, _formatting$inlineMar8, _formatting$listTypes, _formatting$listTypes2, _imagesConfig$schema$, _imagesConfig$schema, _imagesConfig$schema$2, _imagesConfig$schema2;
  const formatting = config3.formatting === true ? {
    // alignment: true, // not supported natively in markdown
    blockTypes: true,
    headingLevels: true,
    inlineMarks: true,
    listTypes: true,
    softBreaks: true
  } : (_config$formatting = config3.formatting) !== null && _config$formatting !== void 0 ? _config$formatting : {};
  const imagesConfig = config3.images === true ? {} : config3.images;
  return {
    formatting: {
      alignment: formatting.alignment === true ? {
        center: true,
        end: true
      } : {
        center: !!((_formatting$alignment = formatting.alignment) !== null && _formatting$alignment !== void 0 && _formatting$alignment.center),
        end: !!((_formatting$alignment2 = formatting.alignment) !== null && _formatting$alignment2 !== void 0 && _formatting$alignment2.end)
      },
      blockTypes: (formatting === null || formatting === void 0 ? void 0 : formatting.blockTypes) === true ? {
        blockquote: true,
        code: {
          schema: object({})
        }
      } : {
        blockquote: !!((_formatting$blockType = formatting.blockTypes) !== null && _formatting$blockType !== void 0 && _formatting$blockType.blockquote),
        code: ((_formatting$blockType2) => {
          if (((_formatting$blockType2 = formatting.blockTypes) === null || _formatting$blockType2 === void 0 ? void 0 : _formatting$blockType2.code) === void 0) {
            return false;
          }
          if (formatting.blockTypes.code === true || !formatting.blockTypes.code.schema) {
            return {
              schema: object({})
            };
          }
          for (const key3 of ["type", "children", "language"]) {
            if (key3 in formatting.blockTypes.code.schema) {
              throw new Error(`"${key3}" cannot be a key in the schema for code blocks`);
            }
          }
          return {
            schema: object(formatting.blockTypes.code.schema)
          };
        })()
      },
      headings: ((_obj$schema) => {
        const opt = formatting === null || formatting === void 0 ? void 0 : formatting.headingLevels;
        const obj = typeof opt === "object" && "levels" in opt ? opt : {
          levels: opt,
          schema: void 0
        };
        if (obj.schema) {
          for (const key3 of ["type", "children", "level", "textAlign"]) {
            if (key3 in obj.schema) {
              throw new Error(`"${key3}" cannot be a key in the schema for headings`);
            }
          }
        }
        return {
          levels: [...new Set(obj.levels === true ? [1, 2, 3, 4, 5, 6] : obj.levels)],
          schema: object((_obj$schema = obj.schema) !== null && _obj$schema !== void 0 ? _obj$schema : {})
        };
      })(),
      inlineMarks: formatting.inlineMarks === true ? {
        bold: true,
        code: true,
        italic: true,
        keyboard: false,
        // not supported natively in markdown
        strikethrough: true,
        subscript: false,
        // not supported natively in markdown
        superscript: false,
        // not supported natively in markdown
        underline: false
        // not supported natively in markdown
      } : {
        bold: !!((_formatting$inlineMar = formatting.inlineMarks) !== null && _formatting$inlineMar !== void 0 && _formatting$inlineMar.bold),
        code: !!((_formatting$inlineMar2 = formatting.inlineMarks) !== null && _formatting$inlineMar2 !== void 0 && _formatting$inlineMar2.code),
        italic: !!((_formatting$inlineMar3 = formatting.inlineMarks) !== null && _formatting$inlineMar3 !== void 0 && _formatting$inlineMar3.italic),
        strikethrough: !!((_formatting$inlineMar4 = formatting.inlineMarks) !== null && _formatting$inlineMar4 !== void 0 && _formatting$inlineMar4.strikethrough),
        underline: !!((_formatting$inlineMar5 = formatting.inlineMarks) !== null && _formatting$inlineMar5 !== void 0 && _formatting$inlineMar5.underline),
        keyboard: !!((_formatting$inlineMar6 = formatting.inlineMarks) !== null && _formatting$inlineMar6 !== void 0 && _formatting$inlineMar6.keyboard),
        subscript: !!((_formatting$inlineMar7 = formatting.inlineMarks) !== null && _formatting$inlineMar7 !== void 0 && _formatting$inlineMar7.subscript),
        superscript: !!((_formatting$inlineMar8 = formatting.inlineMarks) !== null && _formatting$inlineMar8 !== void 0 && _formatting$inlineMar8.superscript)
      },
      listTypes: formatting.listTypes === true ? {
        ordered: true,
        unordered: true
      } : {
        ordered: !!((_formatting$listTypes = formatting.listTypes) !== null && _formatting$listTypes !== void 0 && _formatting$listTypes.ordered),
        unordered: !!((_formatting$listTypes2 = formatting.listTypes) !== null && _formatting$listTypes2 !== void 0 && _formatting$listTypes2.unordered)
      },
      softBreaks: !!formatting.softBreaks
    },
    links: !!config3.links,
    layouts: [...new Set((config3.layouts || []).map((x) => JSON.stringify(x)))].map((x) => JSON.parse(x)),
    dividers: !!config3.dividers,
    images: imagesConfig === void 0 ? false : {
      ...imagesConfig,
      schema: {
        alt: (_imagesConfig$schema$ = (_imagesConfig$schema = imagesConfig.schema) === null || _imagesConfig$schema === void 0 ? void 0 : _imagesConfig$schema.alt) !== null && _imagesConfig$schema$ !== void 0 ? _imagesConfig$schema$ : defaultAltField$1,
        title: (_imagesConfig$schema$2 = (_imagesConfig$schema2 = imagesConfig.schema) === null || _imagesConfig$schema2 === void 0 ? void 0 : _imagesConfig$schema2.title) !== null && _imagesConfig$schema$2 !== void 0 ? _imagesConfig$schema$2 : emptyTitleField$1
      }
    },
    tables: !!config3.tables
  };
}
function document$1({
  label,
  componentBlocks = {},
  description,
  ...documentFeaturesConfig
}) {
  const documentFeatures = normaliseDocumentFeatures(documentFeaturesConfig);
  return {
    kind: "form",
    formKind: "content",
    defaultValue() {
      return [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }];
    },
    Input(props) {
      return (0, import_jsx_runtime70.jsx)(DocumentFieldInput$1, {
        componentBlocks,
        description,
        label,
        documentFeatures,
        ...props
      });
    },
    parse(_, data2) {
      const markdoc2 = textDecoder$2.decode(data2.content);
      const document5 = fromMarkdoc(parse3(markdoc2), componentBlocks);
      return deserializeFiles(normalizeDocumentFieldChildren(documentFeatures, componentBlocks, document5), componentBlocks, data2.other, data2.external, "edit", documentFeatures, data2.slug);
    },
    contentExtension: ".mdoc",
    validate(value) {
      return value;
    },
    directories: [...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(componentBlocks).map(([name2, block4]) => [name2, object(block4.schema)])))), ...typeof documentFeatures.images === "object" && typeof documentFeatures.images.directory === "string" ? [fixPath(documentFeatures.images.directory)] : []],
    serialize(value, opts) {
      return serializeMarkdoc(value, opts, componentBlocks, documentFeatures);
    },
    reader: {
      parse(value, data2) {
        const markdoc2 = textDecoder$2.decode(data2.content);
        const document5 = fromMarkdoc(parse3(markdoc2), componentBlocks);
        return deserializeFiles(document5, componentBlocks, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), "read", documentFeatures, void 0);
      }
    }
  };
}
var classes = {
  blockParent: "ProseMirror-blockParent",
  focused: "ProseMirror-focused",
  hideselection: "ProseMirror-hideselection",
  nodeInSelection: "ProseMirror-nodeInSelection",
  nodeSelection: "ProseMirror-selectednode",
  placeholder: "ProseMirror-placeholder"
};
function weakMemoize2(func) {
  const cache = /* @__PURE__ */ new WeakMap();
  return (arg) => {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    const result = func(arg);
    cache.set(arg, result);
    return result;
  };
}
var maskColor = tokenSchema.color.background.canvas;
var borderColor = tokenSchema.color.alias.borderSelected;
var borderSize = tokenSchema.size.border.medium;
var circleSize = tokenSchema.size.space.regular;
injectGlobal({
  ".prosemirror-dropcursor-block": {
    "&::before, &::after": {
      backgroundColor: maskColor,
      border: `${borderSize} solid ${borderColor}`,
      borderRadius: "50%",
      content: '" "',
      height: circleSize,
      position: "absolute",
      width: circleSize,
      top: `calc(${circleSize} / -2 - ${borderSize} / 2)`
    },
    "&::before": {
      left: `calc(${circleSize} * -1)`
    },
    "&::after": {
      right: `calc(${circleSize} * -1)`
    }
  }
});
var voidElements2 = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"];
var prosemirrorStyles = css`
  /* Provide our own selection indicator */
  .${classes.nodeSelection} {
    position: relative;
  }
  .${classes.nodeSelection}::after {
    background-color: ${tokenSchema.color.alias.backgroundSelected};
    border-radius: ${tokenSchema.size.radius.small};
    content: '';
    inset: calc(${tokenSchema.size.alias.focusRingGap} * -1);
    pointer-events: none;
    position: absolute;
  }
  .${classes.nodeSelection}:is(${voidElements2.join(", ")}) {
    outline: ${tokenSchema.size.alias.focusRing} solid
      ${tokenSchema.color.border.accent};
    outline-offset: ${tokenSchema.size.alias.focusRingGap};
  }
  .${classes.hideselection} *::selection {
    background: transparent;
  }
  .${classes.hideselection} *::-moz-selection {
    background: transparent;
  }
  .${classes.hideselection} {
    caret-color: transparent;
  }

  /* Style the placeholder element */
  .${classes.placeholder} {
    color: ${tokenSchema.color.foreground.neutralTertiary};
    pointer-events: none;
  }

  /* Protect against generic img rules */
  img.ProseMirror-separator {
    display: inline !important;
    border: none !important;
    margin: 0 !important;
  }

  /* Provide an indicator for focusing places that don't allow regular selection */
  .ProseMirror-gapcursor {
    display: none;
    pointer-events: none;
    position: absolute;
  }
  .ProseMirror-gapcursor:after {
    content: '';
    display: block;
    position: absolute;
    top: -2px;
    width: 20px;
    border-top: 1px solid black;
    animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
  }

  @keyframes ProseMirror-cursor-blink {
    to {
      visibility: hidden;
    }
  }

  .ProseMirror-focused .ProseMirror-gapcursor {
    display: block;
  }
  .ProseMirror > .ProseMirror-yjs-cursor:first-child {
    margin-top: 16px;
  }
  /* This gives the remote user caret. The colors are automatically overwritten*/
  .ProseMirror-yjs-cursor {
    position: relative;
    margin-left: -1px;
    margin-right: -1px;
    border-left: 1px solid black;
    border-right: 1px solid black;
    border-color: orange;
    word-break: normal;
    pointer-events: none;
  }
  /* This renders the username above the caret */
  .ProseMirror-yjs-cursor > div {
    position: absolute;
    top: -1.05em;
    left: -1px;
    font-size: 13px;
    background-color: rgb(250, 129, 0);
    font-family: ${tokenSchema.typography.fontFamily.base};
    font-style: normal;
    font-weight: normal;
    line-height: normal;
    user-select: none;
    color: white;
    padding-left: 2px;
    padding-right: 2px;
    white-space: nowrap;
  }
`;
function useEventCallback2(callback) {
  const callbackRef = (0, import_react55.useRef)(callback);
  const cb = (0, import_react55.useCallback)((...args) => {
    return callbackRef.current(...args);
  }, []);
  (0, import_react55.useEffect)(() => {
    callbackRef.current = callback;
  });
  return cb;
}
function insertNode(nodeType) {
  return (state2, dispatch) => {
    if (state2.selection instanceof NodeSelection && state2.selection.node.type === nodeType) {
      return false;
    }
    if (dispatch) {
      dispatch(state2.tr.replaceSelectionWith(nodeType.createAndFill()));
    }
    return true;
  };
}
function toggleCodeBlock(codeBlock, paragraph3) {
  return (state2, dispatch, view) => {
    const codeBlockPositions = [];
    for (const range of state2.selection.ranges) {
      state2.doc.nodesBetween(range.$from.pos, range.$to.pos, (node3, pos) => {
        if (node3.type === codeBlock) {
          codeBlockPositions.push([pos, pos + node3.nodeSize]);
        }
      });
    }
    if (!codeBlockPositions.length) {
      return setBlockType2(codeBlock)(state2, dispatch, view);
    }
    if (dispatch) {
      const tr2 = state2.tr;
      for (const [start2, end] of codeBlockPositions) {
        tr2.setBlockType(start2, end, paragraph3);
      }
      dispatch(tr2);
    }
    return true;
  };
}
function insertTable(tableType) {
  const rowType = tableType.contentMatch.defaultType;
  const cellType = rowType.contentMatch.defaultType;
  return (state2, dispatch) => {
    const cell2 = cellType.createAndFill();
    const row = rowType.create(void 0, [cell2, cell2, cell2]);
    dispatch === null || dispatch === void 0 || dispatch(state2.tr.replaceSelectionWith(tableType.create(void 0, [row, row, row])));
    return true;
  };
}
function findParentList(range, listItemType) {
  for (let d = range.depth; d > 0; d--) {
    let parent = range.$from.node(d);
    if (parent.type.contentMatch.defaultType === listItemType) {
      return {
        node: parent,
        pos: range.$from.before(d)
      };
    }
  }
}
function toggleList(listType, attrs = null) {
  const listItemType = listType.contentMatch.defaultType;
  return function(state2, dispatch) {
    let {
      $from,
      $to
    } = state2.selection;
    let range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range) return false;
    const parentList = findParentList(range, listItemType);
    if ((parentList === null || parentList === void 0 ? void 0 : parentList.node.type) == listType) {
      return liftListItem(listItemType)(state2, dispatch);
    }
    if (parentList && parentList.node.type !== listType) {
      if (dispatch) {
        dispatch(state2.tr.setNodeMarkup(parentList.pos, listType, attrs).scrollIntoView());
      }
      return true;
    }
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0) return false;
      let $insert = state2.doc.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount) {
        range = new NodeRange($from, state2.doc.resolve($to.end(range.depth)), range.depth);
      }
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap2) return false;
    if (dispatch) {
      dispatch(doWrapInList(state2.tr, range, wrap2, doJoin, listType).scrollIntoView());
    }
    return true;
  };
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content3 = Fragment2.empty;
  for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
    content3 = Fragment2.from(wrappers[i2].type.create(wrappers[i2].attrs, content3));
  }
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content3, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i2 = 0; i2 < wrappers.length; i2++) {
    if (wrappers[i2].type == listType) found2 = i2 + 1;
  }
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i2 = range.startIndex, e3 = range.endIndex, first = true; i2 < e3; i2++, first = false) {
    if (!first && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i2).nodeSize;
  }
  return tr2;
}
function splitListItem(itemType) {
  return function(state2, dispatch) {
    let {
      $from,
      $to,
      node: node3
    } = state2.selection;
    if (node3 && node3.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    let grandParent = $from.node(-1);
    if (grandParent.type != itemType) return false;
    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch) {
        let wrap2 = Fragment2.empty;
        let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--) {
          wrap2 = Fragment2.from($from.node(d).copy(wrap2));
        }
        let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        wrap2 = wrap2.append(Fragment2.from(itemType.createAndFill()));
        let start2 = $from.before($from.depth - (depthBefore - 1));
        let tr3 = state2.tr.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
        let sel = -1;
        tr3.doc.nodesBetween(start2, tr3.doc.content.size, (node4, pos) => {
          if (sel > -1) return false;
          if (node4.isTextblock && node4.content.size == 0) sel = pos + 1;
        });
        if (sel > -1) tr3.setSelection(Selection.near(tr3.doc.resolve(sel)));
        dispatch(tr3.scrollIntoView());
      }
      return true;
    }
    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    let tr2 = state2.tr.delete($from.pos, $to.pos);
    let types4 = nextType ? [null, {
      type: nextType
    }] : void 0;
    if (!canSplit(tr2.doc, $from.pos, 2, types4)) return false;
    if (dispatch) dispatch(tr2.split($from.pos, 2, types4).scrollIntoView());
    return true;
  };
}
function liftListItem(itemType) {
  return function(state2, dispatch) {
    let {
      $from,
      $to
    } = state2.selection;
    let range = $from.blockRange($to, (node3) => node3.childCount > 0 && node3.firstChild.type == itemType);
    if (!range) return false;
    if (!dispatch) return true;
    if ($from.node(range.depth - 1).type == itemType) {
      return liftToOuterList(state2, dispatch, itemType, range);
    } else {
      return liftOutOfList(state2, dispatch, range);
    }
  };
}
function liftToOuterList(state2, dispatch, itemType, range) {
  let tr2 = state2.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment2.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null) return false;
  tr2.lift(range, target);
  let after = tr2.mapping.map(end, -1) - 1;
  if (canJoin(tr2.doc, after)) tr2.join(after);
  dispatch(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state2, dispatch, range) {
  let tr2 = state2.tr, list5 = range.parent;
  for (let pos = range.end, i2 = range.endIndex - 1, e3 = range.startIndex; i2 > e3; i2--) {
    pos -= list5.child(i2).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item2 = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) {
    return false;
  }
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list5.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item2.content.append(atEnd ? Fragment2.empty : Fragment2.from(list5)))) {
    return false;
  }
  let start2 = $start.pos, end = start2 + item2.nodeSize;
  tr2.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start2 + 1, end - 1, new Slice((atStart ? Fragment2.empty : Fragment2.from(list5.copy(Fragment2.empty))).append(atEnd ? Fragment2.empty : Fragment2.from(list5.copy(Fragment2.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state2, dispatch) {
    let {
      $from,
      $to
    } = state2.selection;
    let range = $from.blockRange($to, (node3) => node3.childCount > 0 && node3.firstChild.type == itemType);
    if (!range) return false;
    let startIndex = range.startIndex;
    if (startIndex == 0) return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType) return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment2.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment2.from(itemType.create(null, Fragment2.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state2.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
var independentForGapCursor = "@@independentForGapCursor";
var GapCursor = class _GapCursor extends Selection {
  /// Create a gap cursor.
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc4, mapping) {
    let $pos = doc4.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return {
      type: "ksgapcursor",
      pos: this.head
    };
  }
  /// @internal
  static fromJSON(doc4, json) {
    if (typeof json.pos != "number") {
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    }
    return new _GapCursor(doc4.resolve(json.pos));
  }
  /// @internal
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /// @internal
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) {
      return false;
    }
    let override = parent.type.spec.allowGapCursor;
    if (override != null) return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /// @internal
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && _GapCursor.valid($pos)) return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (_GapCursor.valid($cur)) return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (_GapCursor.valid($cur)) return $cur;
      }
      return null;
    }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
try {
  Selection.jsonID("ksgapcursor", GapCursor);
} catch {
}
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc4) {
    let $pos = doc4.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index4 = $pos.index(d), parent = $pos.node(d);
    if (index4 == 0) {
      if (parent.type.spec.isolating) return true;
      continue;
    }
    for (let before = parent.child(index4 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating || before.type.spec[independentForGapCursor]) {
        return true;
      }
      if (before.inlineContent) return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index4 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index4 == parent.childCount) {
      if (parent.type.spec.isolating) return true;
      continue;
    }
    for (let after = parent.child(index4); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating || after.type.spec[independentForGapCursor]) {
        return true;
      }
      if (after.inlineContent) return false;
    }
  }
  return true;
}
function FormValue(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const formId = (0, import_react55.useId)();
  const [forceValidation, setForceValidation] = (0, import_react55.useState)(false);
  const [state2, setState] = (0, import_react55.useState)(props.value);
  const previewProps = (0, import_react55.useMemo)(() => createGetPreviewProps(props.schema, setState, () => void 0), [props.schema])(state2);
  const {
    dismiss
  } = useDialogContainer();
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsx)(Content, {
      children: (0, import_jsx_runtime70.jsx)(Flex, {
        id: formId,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget) return;
          event.preventDefault();
          if (!clientSideValidateProp(props.schema, state2, void 0)) {
            setForceValidation(true);
          } else {
            props.onSave(state2);
            dismiss();
          }
        },
        direction: "column",
        gap: "xxlarge",
        children: (0, import_jsx_runtime70.jsx)(FormValueContentFromPreviewProps, {
          ...previewProps,
          forceValidation
        })
      })
    }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime70.jsx)(Button, {
        onPress: dismiss,
        children: stringFormatter.format("cancel")
      }), (0, import_jsx_runtime70.jsx)(Button, {
        form: formId,
        prominence: "high",
        type: "submit",
        children: "Done"
      })]
    })]
  });
}
function deserializeProps$1(fields, value, state2) {
  try {
    return parseProps({
      kind: "object",
      fields
    }, value, [], [], (schema, value2) => {
      if (schema.formKind === "asset") {
        var _state$otherFiles$get;
        const filename = schema.filename(value2, {
          slug: state2.slug,
          suggestedFilenamePrefix: void 0
        });
        return schema.parse(value2, {
          asset: filename ? schema.directory ? (_state$otherFiles$get = state2.otherFiles.get(schema.directory)) === null || _state$otherFiles$get === void 0 ? void 0 : _state$otherFiles$get.get(filename) : state2.extraFiles.get(filename) : void 0,
          slug: state2.slug
        });
      }
      if (schema.formKind === "content") {
        throw new Error("Not implemented");
      }
      return schema.parse(value2, void 0);
    }, false);
  } catch (err) {
    throw new Error(formatFormDataError(err));
  }
}
function toSerialized(deserialized, schema) {
  const serialized = serializeProps$1(deserialized, {
    kind: "object",
    fields: schema
  }, void 0, void 0, false);
  return {
    value: serialized.value,
    extraFiles: serialized.extraFiles.map((x) => ({
      ...x,
      contents: x.contents
    }))
  };
}
function deserializeValue(value, schema) {
  const files = /* @__PURE__ */ new Map();
  const extraFiles = /* @__PURE__ */ new Map();
  for (const file of value.extraFiles) {
    if (file.parent) {
      if (!extraFiles.has(file.parent)) {
        extraFiles.set(file.parent, /* @__PURE__ */ new Map());
      }
      extraFiles.get(file.parent).set(file.path, file.contents);
    } else {
      files.set(file.path, file.contents);
    }
  }
  return deserializeProps$1(schema, value.value, {
    slug: void 0,
    extraFiles: files,
    otherFiles: extraFiles
  });
}
function internalToSerialized(fields, value, state2) {
  const deserialized = deserializeValue(value, fields);
  const serialized = serializeProps$1(deserialized, {
    kind: "object",
    fields
  }, void 0, state2.slug, false);
  for (const file of serialized.extraFiles) {
    if (file.parent) {
      if (!state2.otherFiles.has(file.parent)) {
        state2.otherFiles.set(file.parent, /* @__PURE__ */ new Map());
      }
      state2.otherFiles.get(file.parent).set(file.path, file.contents);
    } else {
      state2.extraFiles.set(file.path, file.contents);
    }
  }
  return serialized.value;
}
var useDeserializedValue = function useDeserializedValue2(value, schema) {
  return (0, import_react55.useMemo)(() => deserializeValue(value, schema), [schema, value]);
};
function serializeProps(props) {
  return JSON.stringify({
    value: props.value,
    extraFiles: props.extraFiles.map((x) => ({
      path: x.path,
      parent: x.parent,
      contents: base64UrlEncode(x.contents)
    }))
  });
}
function deserializeProps(node3) {
  if (typeof node3 === "string") return false;
  const serialized = node3.dataset.props;
  if (!serialized) return false;
  try {
    const parsed = JSON.parse(serialized);
    return {
      props: {
        value: parsed.value,
        extraFiles: parsed.extraFiles.map((x) => ({
          path: x.path,
          parent: x.parent,
          contents: base64UrlDecode(x.contents)
        }))
      }
    };
  } catch {
    return false;
  }
}
function BlockWrapper(props) {
  const [isOpen, setIsOpen] = (0, import_react55.useState)(false);
  const runCommand = useEditorDispatchCommand();
  const schema = (0, import_react55.useMemo)(() => ({
    kind: "object",
    fields: props.component.schema
  }), [props.component.schema]);
  const value = useDeserializedValue(props.node.attrs.props, props.component.schema);
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsxs)(Box, {
      UNSAFE_className: `${classes.blockParent} ${css({
        marginBlock: "1em",
        position: "relative",
        ...props.hasNodeSelection ? {
          "&::after": {
            backgroundColor: tokenSchema.color.alias.backgroundSelected,
            borderRadius: tokenSchema.size.radius.regular,
            content: "''",
            inset: 0,
            pointerEvents: "none",
            position: "absolute"
          }
        } : {}
      })}${props.hasNodeSelection ? ` ${classes.hideselection}` : ""}`,
      border: props.hasNodeSelection ? "color.alias.borderSelected" : "color.alias.borderDisabled",
      borderRadius: "regular",
      children: [(0, import_jsx_runtime70.jsxs)(Flex, {
        backgroundColor: props.hasNodeSelection ? "color.alias.backgroundSelected" : "color.alias.backgroundIdle",
        contentEditable: false,
        alignItems: "center",
        "data-ignore-content": "",
        children: [(0, import_jsx_runtime70.jsx)(Box, {
          flex: 1,
          paddingX: "regular",
          paddingY: "small",
          UNSAFE_className: css({
            color: props.hasNodeSelection ? tokenSchema.color.foreground.accent : tokenSchema.color.foreground.neutralTertiary,
            textTransform: "uppercase",
            fontWeight: tokenSchema.typography.fontWeight.semibold,
            fontSize: "0.9rem"
          }),
          onClick: () => {
            runCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.setSelection(NodeSelection.create(state2.doc, props.getPos())));
              }
              return true;
            });
          },
          children: props.component.label
        }), props.toolbar, !!Object.keys(props.component.schema).length && (0, import_jsx_runtime70.jsx)(Button, {
          prominence: "low",
          onPress: () => {
            setIsOpen(true);
          },
          UNSAFE_className: css({
            borderBottomRightRadius: 0
          }),
          children: "Edit"
        })]
      }), (0, import_jsx_runtime70.jsx)(Box, {
        padding: "regular",
        children: props.children
      })]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setIsOpen(false);
      },
      children: isOpen && (0, import_jsx_runtime70.jsxs)(Dialog, {
        children: [(0, import_jsx_runtime70.jsxs)(Heading, {
          children: ["Edit ", props.component.label]
        }), (0, import_jsx_runtime70.jsx)(FormValue, {
          schema,
          value,
          onSave: (value2) => {
            runCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.setNodeAttribute(props.getPos(), "props", toSerialized(value2, schema.fields)));
              }
              return true;
            });
          }
        })]
      })
    })]
  });
}
function getCustomNodeSpecs(components) {
  const componentNames = new Map(Object.keys(components).map((name2, i2) => [name2, `component${i2}`]));
  return Object.fromEntries(Object.entries(components).flatMap(([name2, component]) => {
    let spec;
    const schema = {
      kind: "object",
      fields: component.schema
    };
    if (component.kind === "block") {
      spec = {
        group: `${component.forSpecificLocations ? "" : "block "}${componentNames.get(name2)}`,
        defining: true,
        attrs: {
          props: {
            default: toSerialized(getInitialPropsValue(schema), schema.fields)
          }
        },
        reactNodeView: {
          component: function Block(props) {
            const runCommand = useEditorDispatchCommand();
            const value = useDeserializedValue(props.node.attrs.props, component.schema);
            return "NodeView" in component && component.NodeView ? (0, import_jsx_runtime70.jsx)(component.NodeView, {
              isSelected: props.hasNodeSelection || props.isNodeCompletelyWithinSelection,
              onRemove: () => {
                runCommand((state2, dispatch) => {
                  if (dispatch) {
                    const pos = props.getPos();
                    dispatch(state2.tr.delete(pos, pos + props.node.nodeSize));
                  }
                  return true;
                });
              },
              onChange: (value2) => {
                runCommand((state2, dispatch) => {
                  if (dispatch) {
                    dispatch(state2.tr.setNodeAttribute(props.getPos(), "props", toSerialized(value2, schema.fields)));
                  }
                  return true;
                });
              },
              value
            }) : (0, import_jsx_runtime70.jsx)(BlockWrapper, {
              node: props.node,
              hasNodeSelection: props.hasNodeSelection || props.isNodeCompletelyWithinSelection,
              component,
              getPos: props.getPos,
              children: "ContentView" in component && component.ContentView && (0, import_jsx_runtime70.jsx)(component.ContentView, {
                value
              })
            });
          },
          rendersOwnContent: false
        },
        parseDOM: [{
          tag: `div[data-component="${name2}"]`,
          getAttrs(node3) {
            if (typeof node3 === "string") return false;
            return deserializeProps(node3);
          }
        }],
        toDOM(node3) {
          return ["div", {
            "data-component": name2,
            "data-props": serializeProps(node3.attrs.props)
          }];
        },
        insertMenu: component.forSpecificLocations ? void 0 : {
          label: component.label,
          command: insertNode,
          forToolbar: true,
          description: component.description,
          icon: component.icon
        }
      };
    } else if (component.kind === "wrapper") {
      spec = {
        group: `${component.forSpecificLocations ? "" : "block "}${componentNames.get(name2)}`,
        content: "block+",
        defining: true,
        attrs: {
          props: {
            default: toSerialized(getInitialPropsValue(schema), schema.fields)
          }
        },
        reactNodeView: {
          component: function Block(props) {
            const runCommand = useEditorDispatchCommand();
            const value = useDeserializedValue(props.node.attrs.props, component.schema);
            return "NodeView" in component && component.NodeView ? (0, import_jsx_runtime70.jsx)(component.NodeView, {
              isSelected: props.hasNodeSelection || props.isNodeCompletelyWithinSelection,
              onRemove: () => {
                runCommand((state2, dispatch) => {
                  if (dispatch) {
                    const pos = props.getPos();
                    dispatch(state2.tr.delete(pos, pos + props.node.nodeSize));
                  }
                  return true;
                });
              },
              onChange: (value2) => {
                runCommand((state2, dispatch) => {
                  if (dispatch) {
                    dispatch(state2.tr.setNodeAttribute(props.getPos(), "props", toSerialized(value2, schema.fields)));
                  }
                  return true;
                });
              },
              value,
              children: props.children
            }) : (0, import_jsx_runtime70.jsx)(BlockWrapper, {
              node: props.node,
              hasNodeSelection: props.hasNodeSelection || props.isNodeCompletelyWithinSelection,
              component,
              getPos: props.getPos,
              children: "ContentView" in component && component.ContentView ? (0, import_jsx_runtime70.jsx)(component.ContentView, {
                value,
                children: props.children
              }) : props.children
            });
          },
          rendersOwnContent: false
        },
        toDOM(node3) {
          return ["div", {
            "data-component": name2,
            "data-props": serializeProps(node3.attrs.props)
          }, 0];
        },
        parseDOM: [{
          tag: `div[data-component="${name2}"]`,
          getAttrs: deserializeProps
        }],
        insertMenu: component.forSpecificLocations ? void 0 : {
          label: component.label,
          command: insertNode,
          forToolbar: true,
          description: component.description,
          icon: component.icon
        }
      };
    } else if (component.kind === "inline") {
      spec = {
        group: "inline inline_component",
        inline: true,
        attrs: {
          props: {
            default: toSerialized(getInitialPropsValue(schema), schema.fields)
          }
        },
        toDOM: (node3) => ["span", {
          "data-component": name2,
          "data-props": serializeProps(node3.attrs.props)
        }],
        parseDOM: [{
          tag: `span[data-component="${name2}"]`,
          getAttrs: deserializeProps
        }],
        reactNodeView: {
          component: function Inline(props) {
            const value = useDeserializedValue(props.node.attrs.props, component.schema);
            const runCommand = useEditorDispatchCommand();
            if (component.NodeView) {
              return (0, import_jsx_runtime70.jsx)("span", {
                contentEditable: false,
                children: (0, import_jsx_runtime70.jsx)(component.NodeView, {
                  value,
                  onChange: (value2) => {
                    runCommand((state2, dispatch) => {
                      if (dispatch) {
                        dispatch(state2.tr.setNodeAttribute(props.getPos(), "props", toSerialized(value2, schema.fields)));
                      }
                      return true;
                    });
                  },
                  isSelected: props.hasNodeSelection || props.isNodeCompletelyWithinSelection,
                  onRemove: () => {
                    runCommand((state2, dispatch) => {
                      if (dispatch) {
                        const pos = props.getPos();
                        dispatch(state2.tr.delete(pos, pos + props.node.nodeSize));
                      }
                      return true;
                    });
                  }
                })
              });
            }
            return (0, import_jsx_runtime70.jsx)(Box, {
              elementType: "span",
              contentEditable: false,
              border: props.hasNodeSelection ? "color.alias.borderSelected" : "color.alias.borderIdle",
              "data-component": name2,
              borderRadius: "regular",
              UNSAFE_className: css({
                "::after": {
                  content: "attr(data-component)"
                }
              })
            });
          },
          rendersOwnContent: false
        },
        insertMenu: {
          label: component.label,
          command: insertNode,
          forToolbar: true,
          description: component.description,
          icon: component.icon
        }
      };
    } else if (component.kind === "repeating") {
      const items = component.children.map((x) => ({
        key: x,
        label: components[x].label
      }));
      spec = {
        group: `${component.forSpecificLocations ? "" : "block "}${componentNames.get(name2)}`,
        content: `(${component.children.map((x) => componentNames.get(x)).join(" | ")}){${component.validation.children.min},${component.validation.children.max === Infinity ? "" : component.validation.children.max}}`,
        defining: true,
        attrs: {
          props: {
            default: toSerialized(getInitialPropsValue(schema), schema.fields)
          }
        },
        reactNodeView: {
          component: function Block(props) {
            const runCommand = useEditorDispatchCommand();
            const value = useDeserializedValue(props.node.attrs.props, component.schema);
            return "NodeView" in component && component.NodeView ? (0, import_jsx_runtime70.jsx)(component.NodeView, {
              isSelected: props.hasNodeSelection || props.isNodeCompletelyWithinSelection,
              onRemove: () => {
                runCommand((state2, dispatch) => {
                  if (dispatch) {
                    const pos = props.getPos();
                    dispatch(state2.tr.delete(pos, pos + props.node.nodeSize));
                  }
                  return true;
                });
              },
              onChange: (value2) => {
                runCommand((state2, dispatch) => {
                  if (dispatch) {
                    dispatch(state2.tr.setNodeAttribute(props.getPos(), "props", toSerialized(value2, schema.fields)));
                  }
                  return true;
                });
              },
              value,
              children: props.children
            }) : (0, import_jsx_runtime70.jsx)(BlockWrapper, {
              node: props.node,
              hasNodeSelection: props.hasNodeSelection || props.isNodeCompletelyWithinSelection,
              component,
              getPos: props.getPos,
              toolbar: props.node.contentMatchAt(props.node.childCount).defaultType && (component.children.length === 1 ? (0, import_jsx_runtime70.jsx)(Button, {
                onPress: () => {
                  runCommand((state2, dispatch) => {
                    if (dispatch) {
                      dispatch(state2.tr.insert(props.getPos() + props.node.nodeSize - 1, state2.schema.nodes[component.children[0]].createAndFill()));
                    }
                    return true;
                  });
                },
                children: "Insert"
              }) : (0, import_jsx_runtime70.jsxs)(MenuTrigger, {
                children: [(0, import_jsx_runtime70.jsx)(Button, {
                  children: "Insert"
                }), (0, import_jsx_runtime70.jsx)(_Menu, {
                  onAction: (key3) => {
                    runCommand((state2, dispatch) => {
                      if (dispatch) {
                        dispatch(state2.tr.insert(props.getPos() + props.node.nodeSize - 1, state2.schema.nodes[key3].createAndFill()));
                      }
                      return true;
                    });
                  },
                  items,
                  children: (item2) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
                    children: item2.label
                  }, item2.key)
                })]
              })),
              children: "ContentView" in component && component.ContentView ? (0, import_jsx_runtime70.jsx)(component.ContentView, {
                value,
                children: props.children
              }) : props.children
            });
          },
          rendersOwnContent: false
        },
        toDOM(node3) {
          return ["div", {
            "data-component": name2,
            "data-props": serializeProps(node3.attrs.props)
          }, 0];
        },
        parseDOM: [{
          tag: `div[data-component="${name2}"]`,
          getAttrs: deserializeProps
        }],
        insertMenu: component.forSpecificLocations ? void 0 : {
          label: component.label,
          command: insertNode,
          forToolbar: true,
          description: component.description,
          icon: component.icon
        }
      };
    }
    if (spec) {
      return [[name2, spec]];
    }
    return [];
  }));
}
function getCustomMarkSpecs(components) {
  return Object.fromEntries(Object.entries(components).flatMap(([name2, component]) => {
    var _component$tag;
    if (component.kind !== "mark") return [];
    const schema = {
      kind: "object",
      fields: component.schema
    };
    const tag = (_component$tag = component.tag) !== null && _component$tag !== void 0 ? _component$tag : "span";
    const spec = {
      attrs: {
        props: {
          default: toSerialized(getInitialPropsValue(schema), schema.fields)
        }
      },
      toDOM(mark) {
        const element3 = document.createElement(tag);
        element3.setAttribute("data-component", name2);
        element3.setAttribute("data-props", serializeProps(mark.attrs.props));
        let deserialized;
        let getDeserialized = () => {
          if (!deserialized) {
            deserialized = deserializeValue(mark.attrs.props, component.schema);
          }
          return deserialized;
        };
        if (typeof component.className === "function") {
          element3.className = component.className({
            value: getDeserialized()
          });
        } else if (typeof component.className === "string") {
          element3.className = component.className;
        }
        if (typeof component.style === "function") {
          Object.assign(element3.style, component.style({
            value: getDeserialized()
          }));
        } else if (component.style) {
          Object.assign(element3.style, component.style);
        }
        return element3;
      },
      parseDOM: [{
        tag: `${tag}[data-component="${name2}"]`,
        getAttrs: deserializeProps
      }]
    };
    return [[name2, spec]];
  }));
}
var blockElementSpacing2 = css({
  marginBlock: "1em"
});
var paragraphDOM = ["p", {
  class: blockElementSpacing2
}, 0];
var blockquoteDOM = ["blockquote", {
  class: classNames(classes.blockParent, css({
    [`&.${classes.nodeInSelection}, &.${classes.nodeSelection}`]: {
      borderColor: tokenSchema.color.alias.borderSelected
    }
  }))
}, 0];
var dividerDOM = ["hr", {
  contenteditable: "false",
  class: css({
    cursor: "pointer",
    [`&.${classes.nodeInSelection}, &.${classes.nodeSelection}`]: {
      backgroundColor: tokenSchema.color.alias.borderSelected
    }
  })
}];
var codeDOM = ["pre", {
  spellcheck: "false"
}, ["code", {}, 0]];
var hardBreakDOM = ["br"];
var olDOM = ["ol", {}, 0];
var ulDOM = ["ul", {}, 0];
var liDOM = ["li", {}, 0];
var inlineContent = `(text | inline_component | hard_break)*`;
var levelsMeta = [{
  description: "Use this for a top level heading",
  icon: heading1Icon
}, {
  description: "Use this for key sections",
  icon: heading2Icon
}, {
  description: "Use this for sub-sections",
  icon: heading3Icon
}, {
  description: "Use this for deep headings",
  icon: heading4Icon
}, {
  description: "Use this for grouping list items",
  icon: heading5Icon
}, {
  description: "Use this for low-level headings",
  icon: heading6Icon
}];
var cellAttrs = {
  colspan: {
    default: 1
  },
  rowspan: {
    default: 1
  }
};
var tableCellClass = css({
  borderBottom: `1px solid ${tokenSchema.color.alias.borderIdle}`,
  borderInlineEnd: `1px solid ${tokenSchema.color.alias.borderIdle}`,
  boxSizing: "border-box",
  margin: 0,
  padding: tokenSchema.size.space.regular,
  position: "relative",
  textAlign: "start",
  verticalAlign: "top",
  "&.selectedCell": {
    backgroundColor: tokenSchema.color.alias.backgroundSelected,
    "& *::selection": {
      backgroundColor: "transparent"
    }
  },
  "&.selectedCell::after": {
    border: `1px solid ${tokenSchema.color.alias.borderSelected}`,
    position: "absolute",
    top: -1,
    left: -1,
    content: '""',
    height: "100%",
    width: "100%"
  }
});
var tableHeaderClass = css(tableCellClass, {
  backgroundColor: tokenSchema.color.scale.slate3,
  fontWeight: tokenSchema.typography.fontWeight.semibold
});
var nodeSpecs = {
  doc: {
    content: "block+"
  },
  paragraph: {
    content: inlineContent,
    group: "block",
    parseDOM: [{
      tag: "p"
    }, {
      tag: "[data-ignore-content]",
      ignore: true
    }],
    toDOM() {
      return paragraphDOM;
    }
  },
  text: {
    group: "inline"
  },
  blockquote: {
    content: "block+",
    group: "block",
    defining: true,
    parseDOM: [{
      tag: "blockquote"
    }],
    toDOM() {
      return blockquoteDOM;
    },
    insertMenu: {
      label: "Blockquote",
      description: "Insert a quote or citation",
      icon: quoteIcon,
      command: wrapIn
    }
  },
  divider: {
    group: "block",
    parseDOM: [{
      tag: "hr"
    }],
    toDOM() {
      return dividerDOM;
    },
    insertMenu: {
      label: "Divider",
      description: "A horizontal line to separate content",
      icon: separatorHorizontalIcon,
      command: insertNode
    }
  },
  code_block: {
    content: "text*",
    group: "block",
    defining: true,
    [independentForGapCursor]: true,
    attrs: {
      language: {
        default: ""
      }
    },
    insertMenu: {
      label: "Code block",
      description: "Display code with syntax highlighting",
      icon: fileCodeIcon,
      command: setBlockType2
    },
    marks: "",
    code: true,
    parseDOM: [{
      tag: "pre",
      preserveWhitespace: "full"
    }],
    toDOM() {
      return codeDOM;
    }
  },
  list_item: {
    content: "block+",
    parseDOM: [{
      tag: "li"
    }],
    toDOM() {
      return liDOM;
    },
    defining: true
  },
  unordered_list: {
    content: "list_item+",
    group: "block",
    parseDOM: [{
      tag: "ul"
    }],
    toDOM() {
      return ulDOM;
    },
    insertMenu: {
      label: "Bullet list",
      description: "Insert an unordered list",
      icon: listIcon,
      command: toggleList
    }
  },
  ordered_list: {
    content: "list_item+",
    group: "block",
    parseDOM: [{
      tag: "ol"
    }],
    toDOM() {
      return olDOM;
    },
    insertMenu: {
      label: "Ordered list",
      description: "Insert an ordered list",
      icon: listOrderedIcon,
      command: toggleList
    }
  },
  hard_break: {
    inline: true,
    group: "inline",
    selectable: false,
    parseDOM: [{
      tag: "br"
    }],
    toDOM() {
      return hardBreakDOM;
    }
  },
  table: {
    content: "table_row+",
    insertMenu: {
      label: "Table",
      description: "Insert a table",
      icon: tableIcon,
      command: insertTable
    },
    tableRole: "table",
    isolating: true,
    group: "block",
    parseDOM: [{
      tag: "table"
    }],
    toDOM() {
      return ["table", {
        class: css({
          width: "100%",
          tableLayout: "fixed",
          position: "relative",
          borderSpacing: 0,
          borderInlineStart: `1px solid ${tokenSchema.color.alias.borderIdle}`,
          borderTop: `1px solid ${tokenSchema.color.alias.borderIdle}`,
          "&:has(.selectedCell) *::selection": {
            backgroundColor: "transparent"
          },
          // stop content from bouncing around when widgets are added
          ".ProseMirror-widget + *": {
            marginTop: 0
          }
        })
      }, ["tbody", 0]];
    }
  },
  table_row: {
    content: "(table_cell | table_header)*",
    tableRole: "row",
    allowGapCursor: false,
    parseDOM: [{
      tag: "tr"
    }],
    toDOM() {
      return ["tr", 0];
    }
  },
  table_cell: {
    content: "block+",
    tableRole: "cell",
    isolating: true,
    attrs: cellAttrs,
    parseDOM: [{
      tag: "td"
    }],
    toDOM() {
      return ["td", {
        class: tableCellClass
      }, 0];
    }
  },
  table_header: {
    content: "block+",
    tableRole: "header_cell",
    attrs: cellAttrs,
    isolating: true,
    parseDOM: [{
      tag: "th"
    }],
    toDOM() {
      return ["th", {
        class: tableHeaderClass
      }, 0];
    }
  },
  image: {
    content: "",
    group: "inline inline_component",
    inline: true,
    attrs: {
      src: {},
      filename: {},
      alt: {
        default: ""
      },
      title: {
        default: ""
      }
    },
    insertMenu: {
      label: "Image",
      description: "Insert an image",
      icon: imageIcon,
      command: (nodeType) => {
        return (state2, dispatch, view) => {
          if (dispatch && view) {
            (async () => {
              const file = await getUploadedFileObject("image/*");
              if (!file) return;
              view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createChecked({
                src: new Uint8Array(await file.arrayBuffer()),
                filename: file.name
              })));
            })();
          }
          return true;
        };
      }
    },
    nodeView(node3) {
      const blob = new Blob([node3.attrs.src], {
        type: node3.attrs.filename.endsWith(".svg") ? "image/svg+xml" : void 0
      });
      const dom = document.createElement("img");
      dom.src = URL.createObjectURL(blob);
      dom.alt = node3.attrs.alt;
      dom.title = node3.attrs.title;
      dom.dataset.filename = node3.attrs.filename;
      dom.classList.add(css({
        boxSizing: "border-box",
        borderRadius: tokenSchema.size.radius.regular,
        display: "inline-block",
        maxHeight: tokenSchema.size.scale[3600],
        maxWidth: "100%",
        transition: transition("box-shadow"),
        "&::selection": {
          backgroundColor: "transparent"
        }
      }));
      return {
        dom,
        destroy() {
          URL.revokeObjectURL(dom.src);
        }
      };
    },
    toDOM(node3) {
      return ["img", {
        src: `data:${node3.attrs.filename.endsWith(".svg") ? "image/svg+xml" : "application/octet-stream"};base64,${base64UrlEncode(node3.attrs.src)}`,
        alt: node3.attrs.alt,
        title: node3.attrs.title,
        "data-filename": node3.attrs.filename
      }];
    },
    parseDOM: [{
      tag: "img[src][data-filename]",
      getAttrs(node3) {
        var _node$getAttribute, _node$getAttribute2;
        if (typeof node3 === "string") return false;
        const src = node3.getAttribute("src");
        const filename = node3.getAttribute("data-filename");
        if (!(src !== null && src !== void 0 && src.startsWith("data:")) || !filename) return false;
        const srcAsUint8Array = base64UrlDecode(src.replace(/^data:[a-z/-]+;base64,/, ""));
        return {
          src: srcAsUint8Array,
          filename,
          alt: (_node$getAttribute = node3.getAttribute("alt")) !== null && _node$getAttribute !== void 0 ? _node$getAttribute : "",
          title: (_node$getAttribute2 = node3.getAttribute("title")) !== null && _node$getAttribute2 !== void 0 ? _node$getAttribute2 : ""
        };
      }
    }]
  }
};
var italicDOM = ["em", 0];
var boldDOM = ["strong", 0];
var inlineCodeDOM = ["code", 0];
var strikethroughDOM = ["s", 0];
var markSpecs = {
  link: {
    attrs: {
      href: {},
      title: {
        default: ""
      }
    },
    inclusive: false,
    parseDOM: [{
      tag: "a[href]",
      getAttrs(node3) {
        var _node$getAttribute3;
        if (typeof node3 === "string") return false;
        const href = node3.getAttribute("href");
        if (!href) return false;
        return {
          href,
          title: (_node$getAttribute3 = node3.getAttribute("title")) !== null && _node$getAttribute3 !== void 0 ? _node$getAttribute3 : ""
        };
      }
    }],
    toDOM(node3) {
      return ["a", {
        href: node3.attrs.href,
        title: node3.attrs.title === "" ? void 0 : node3.attrs.title
      }, 0];
    }
  },
  italic: {
    shortcuts: ["Mod-i", "Mod-I"],
    parseDOM: [{
      tag: "i"
    }, {
      tag: "em"
    }, {
      style: "font-style=italic"
    }, {
      style: "font-style=normal",
      clearMark: (m) => m.type.name == "italic"
    }],
    toDOM() {
      return italicDOM;
    }
  },
  bold: {
    shortcuts: ["Mod-b", "Mod-B"],
    parseDOM: [{
      tag: "strong"
    }, {
      tag: "b",
      getAttrs: (node3) => typeof node3 === "string" ? false : node3.style.fontWeight != "normal" && null
    }, {
      style: "font-weight=400",
      clearMark: (m) => m.type.name == "strong"
    }, {
      style: "font-weight",
      getAttrs: (value) => typeof value === "string" ? /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null : false
    }],
    toDOM() {
      return boldDOM;
    }
  },
  strikethrough: {
    shortcuts: ["Mod-Shift-s", "Mod-Shift-S"],
    parseDOM: [{
      tag: "s"
    }],
    toDOM() {
      return strikethroughDOM;
    }
  },
  code: {
    shortcuts: ["Mod-`", "Mod-Shift-M", "Mod-E", "Mod-e"],
    parseDOM: [{
      tag: "code"
    }],
    toDOM() {
      return inlineCodeDOM;
    }
  }
};
function createEditorSchema(config3, components, isMDX) {
  const nodeSpecsWithCustomNodes = {
    doc: nodeSpecs.doc,
    paragraph: nodeSpecs.paragraph,
    text: nodeSpecs.text,
    hard_break: nodeSpecs.hard_break,
    ...getCustomNodeSpecs(components)
  };
  if (config3.blockquote) {
    nodeSpecsWithCustomNodes.blockquote = nodeSpecs.blockquote;
  }
  if (config3.divider) {
    nodeSpecsWithCustomNodes.divider = nodeSpecs.divider;
  }
  if (config3.codeBlock) {
    nodeSpecsWithCustomNodes.code_block = {
      ...nodeSpecs.code_block,
      attrs: {
        ...nodeSpecs.code_block.attrs,
        props: {
          default: toSerialized(getInitialPropsValue({
            kind: "object",
            fields: config3.heading.schema
          }), config3.heading.schema)
        }
      }
    };
  }
  if (config3.orderedList) {
    nodeSpecsWithCustomNodes.ordered_list = nodeSpecs.ordered_list;
  }
  if (config3.unorderedList) {
    nodeSpecsWithCustomNodes.unordered_list = nodeSpecs.unordered_list;
  }
  if (config3.orderedList || config3.unorderedList) {
    nodeSpecsWithCustomNodes.list_item = nodeSpecs.list_item;
  }
  if (config3.heading.levels.length) {
    nodeSpecsWithCustomNodes.heading = {
      attrs: {
        level: {
          default: config3.heading.levels[0]
        },
        props: {
          default: toSerialized(getInitialPropsValue({
            kind: "object",
            fields: config3.heading.schema
          }), config3.heading.schema)
        }
      },
      content: inlineContent,
      group: "block",
      parseDOM: config3.heading.levels.map((level) => ({
        tag: "h" + level,
        attrs: {
          level
        }
      })),
      defining: true,
      toDOM(node3) {
        return ["h" + node3.attrs.level, 0];
      },
      insertMenu: config3.heading.levels.map((level, index4) => ({
        ...levelsMeta[index4],
        label: "Heading " + level,
        command: (type) => setBlockType2(type, {
          level
        })
      }))
    };
  }
  if (config3.table) {
    nodeSpecsWithCustomNodes.table = nodeSpecs.table;
    nodeSpecsWithCustomNodes.table_row = nodeSpecs.table_row;
    if (isMDX) {
      nodeSpecsWithCustomNodes.table_cell = {
        ...nodeSpecs.table_cell,
        content: "paragraph"
      };
    } else {
      nodeSpecsWithCustomNodes.table_cell = nodeSpecs.table_cell;
    }
    nodeSpecsWithCustomNodes.table_header = nodeSpecs.table_header;
  }
  if (config3.image) {
    nodeSpecsWithCustomNodes.image = nodeSpecs.image;
  }
  const markSpecsWithCustomMarks = {
    ...getCustomMarkSpecs(components)
  };
  if (config3.link) {
    markSpecsWithCustomMarks.link = markSpecs.link;
  }
  if (config3.italic) {
    markSpecsWithCustomMarks.italic = markSpecs.italic;
  }
  if (config3.bold) {
    markSpecsWithCustomMarks.bold = markSpecs.bold;
  }
  if (config3.strikethrough) {
    markSpecsWithCustomMarks.strikethrough = markSpecs.strikethrough;
  }
  if (config3.code) {
    markSpecsWithCustomMarks.code = markSpecs.code;
  }
  const schema = new Schema({
    nodes: nodeSpecsWithCustomNodes,
    marks: markSpecsWithCustomMarks
  });
  const nodes = schema.nodes;
  const marks = schema.marks;
  const editorSchema2 = {
    schema,
    marks,
    nodes,
    config: config3,
    components,
    insertMenuItems: []
  };
  schemaToEditorSchema.set(schema, editorSchema2);
  const insertMenuItems = [];
  for (const node3 of Object.values(schema.nodes)) {
    const insertMenuSpec = node3.spec.insertMenu;
    if (insertMenuSpec) {
      if (Array.isArray(insertMenuSpec)) {
        for (const item2 of insertMenuSpec) {
          insertMenuItems.push({
            label: item2.label,
            description: item2.description,
            icon: item2.icon,
            command: item2.command(node3, editorSchema2),
            forToolbar: item2.forToolbar
          });
        }
      } else {
        insertMenuItems.push({
          label: insertMenuSpec.label,
          description: insertMenuSpec.description,
          icon: insertMenuSpec.icon,
          command: insertMenuSpec.command(node3, editorSchema2),
          forToolbar: insertMenuSpec.forToolbar
        });
      }
    }
  }
  editorSchema2.insertMenuItems = insertMenuItems.sort((a, b) => a.label.localeCompare(b.label)).map((item2, i2) => ({
    ...item2,
    id: i2.toString()
  }));
  return editorSchema2;
}
var schemaToEditorSchema = /* @__PURE__ */ new WeakMap();
function getEditorSchema(schema) {
  const editorSchema2 = schemaToEditorSchema.get(schema);
  if (!editorSchema2) {
    throw new Error("No editor schema for schema");
  }
  return editorSchema2;
}
var EditorStateContext = import_react55.default.createContext(null);
function useEditorState() {
  const state2 = (0, import_react55.useContext)(EditorStateContext);
  if (state2 === null) {
    throw new Error("useEditorState must be used inside ProseMirrorEditorView");
  }
  return state2;
}
function useEditorDispatchCommand() {
  return useStableEditorContext().dispatchCommand;
}
function useEditorSchema() {
  return useStableEditorContext().schema;
}
function useEditorViewRef() {
  return useStableEditorContext().view;
}
function useEditorViewInEffect() {
  const editorViewRef = useEditorViewRef();
  const state2 = useEditorState();
  return (0, import_react55.useCallback)(() => {
    if (editorViewRef.current && editorViewRef.current.state !== state2) {
      var _editorViewRef$curren;
      (_editorViewRef$curren = editorViewRef.current) === null || _editorViewRef$curren === void 0 || _editorViewRef$curren.updateState(state2);
    }
    return editorViewRef.current;
  }, [editorViewRef, state2]);
}
function useEditorView(state2, _onEditorStateChange) {
  const mountRef = (0, import_react55.useRef)(null);
  const viewRef = (0, import_react55.useRef)(null);
  const config3 = useConfig();
  const onEditorStateChange = useEventCallback2(_onEditorStateChange);
  (0, import_react55.useLayoutEffect)(() => {
    if (mountRef.current === null) {
      return;
    }
    const view = new EditorView({
      mount: mountRef.current
    }, {
      state: state2,
      ...{
        config: config3
      },
      dispatchTransaction(tr2) {
        const newEditorState = view.state.apply(tr2);
        view.updateState(newEditorState);
        onEditorStateChange(newEditorState);
      }
    });
    viewRef.current = view;
    return () => {
      view.destroy();
      viewRef.current = null;
    };
  }, [mountRef, onEditorStateChange, config3]);
  (0, import_react55.useLayoutEffect)(() => {
    var _viewRef$current;
    (_viewRef$current = viewRef.current) === null || _viewRef$current === void 0 || _viewRef$current.updateState(state2);
  }, [state2]);
  return {
    view: viewRef,
    mount: mountRef
  };
}
function ProseMirrorEditable(props) {
  const {
    mount
  } = useStableEditorContext();
  return (0, import_jsx_runtime70.jsx)("div", {
    ...props,
    ref: mount
  });
}
var StableEditorContext = import_react55.default.createContext(null);
function useStableEditorContext() {
  const context = (0, import_react55.useContext)(StableEditorContext);
  if (context === null) {
    throw new Error("editor hooks must be used inside a ProseMirrorEditorView");
  }
  return context;
}
var ProseMirrorEditor = (0, import_react55.forwardRef)(function ProseMirrorEditorView(props, ref2) {
  const {
    view,
    mount
  } = useEditorView(props.value, props.onChange);
  (0, import_react55.useImperativeHandle)(ref2, () => ({
    get view() {
      return view.current;
    }
  }), [view]);
  const stableContext = (0, import_react55.useMemo)(() => {
    return {
      view,
      mount,
      dispatchCommand: (command) => {
        if (!view.current) return;
        command(view.current.state, view.current.dispatch, view.current);
        view.current.focus();
      },
      schema: getEditorSchema(props.value.schema)
    };
  }, [mount, props.value.schema, view]);
  return (0, import_jsx_runtime70.jsx)(StableEditorContext.Provider, {
    value: stableContext,
    children: (0, import_jsx_runtime70.jsx)(EditorStateContext.Provider, {
      value: props.value,
      children: props.children
    })
  });
});
function getSrcPrefixForImageBlock(config3, slug) {
  return getSrcPrefix(typeof config3.image === "object" ? config3.image.publicPath : void 0, slug);
}
function imageDropPlugin(schema) {
  if (!schema.nodes.image) return new Plugin({});
  const imageType = schema.nodes.image;
  return new Plugin({
    props: {
      handleDrop(view, event) {
        var _event$dataTransfer;
        if ((_event$dataTransfer = event.dataTransfer) !== null && _event$dataTransfer !== void 0 && _event$dataTransfer.files.length) {
          const file = event.dataTransfer.files[0];
          let eventPos = view.posAtCoords({
            left: event.clientX,
            top: event.clientY
          });
          if (!eventPos) return;
          let $mouse = view.state.doc.resolve(eventPos.pos);
          for (const [name2, component] of Object.entries(schema.components)) {
            if (component.kind !== "block" || !component.handleFile) continue;
            const result = component.handleFile(file, view.props.config);
            if (!result) continue;
            (async () => {
              const value = await result;
              const slice2 = Slice.maxOpen(Fragment2.from(schema.schema.nodes[name2].createChecked({
                props: toSerialized(value, component.schema)
              })));
              const pos = dropPoint(view.state.doc, view.state.selection.from, slice2);
              if (pos === null) return;
              view.dispatch(view.state.tr.replace(pos, pos, slice2));
            })();
            return true;
          }
          if (file.type.startsWith("image/")) {
            (async () => {
              const slice2 = Slice.maxOpen(Fragment2.from(imageType.createChecked({
                src: new Uint8Array(await file.arrayBuffer()),
                filename: file.name
              })));
              const pos = dropPoint(view.state.doc, $mouse.pos, slice2);
              if (pos === null) return false;
              view.dispatch(view.state.tr.replace(pos, pos, slice2));
            })();
            return true;
          }
        }
      },
      handlePaste(view, event) {
        var _event$clipboardData;
        if ((_event$clipboardData = event.clipboardData) !== null && _event$clipboardData !== void 0 && _event$clipboardData.files.length) {
          const file = event.clipboardData.files[0];
          for (const [name2, component] of Object.entries(schema.components)) {
            if (component.kind !== "block" || !component.handleFile) continue;
            const result = component.handleFile(file, view.props.config);
            if (!result) continue;
            (async () => {
              const value = await result;
              view.dispatch(view.state.tr.replaceSelectionWith(schema.schema.nodes[name2].createChecked({
                props: toSerialized(value, component.schema)
              })));
            })();
            return true;
          }
          if (file.type.startsWith("image/")) {
            (async () => {
              view.dispatch(view.state.tr.replaceSelectionWith(imageType.createChecked({
                src: new Uint8Array(await file.arrayBuffer()),
                filename: file.name
              })));
            })();
            return true;
          }
        }
      }
    }
  });
}
function ImageToolbarButton() {
  return (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime70.jsx)(ToolbarButton, {
      "aria-label": "Image",
      command: (_, dispatch, view) => {
        if (dispatch && view) {
          (async () => {
            const file = await getUploadedFileObject("image/*");
            if (!file) return;
            view.dispatch(view.state.tr.replaceSelectionWith(view.state.schema.nodes.image.createChecked({
              src: new Uint8Array(await file.arrayBuffer()),
              filename: file.name
            })));
          })();
        }
        return true;
      },
      children: (0, import_jsx_runtime70.jsx)(Icon, {
        src: imageIcon
      })
    }), (0, import_jsx_runtime70.jsx)(Tooltip, {
      children: (0, import_jsx_runtime70.jsx)(Text, {
        children: "Image"
      })
    })]
  });
}
var key$1 = new PluginKey("AutocompleteDecoration");
function hasSelectionInDecorations(selection, decorations) {
  return decorations.find(selection.from, selection.to).length > 0;
}
var inactiveDecorationState = {
  kind: "inactive"
};
weakMemoize((state2) => {
  const tr2 = removeAutocompleteDecorationAndContent(state2);
  if (!tr2) {
    return {
      state: state2
    };
  }
  return {
    state: state2.apply(tr2),
    tr: tr2
  };
});
function addAutocompleteDecoration(tr2, menu, from2, to, pattern) {
  return tr2.setMeta(key$1, {
    action: "add",
    from: from2,
    to,
    menu,
    pattern
  });
}
function AutocompleteDecoration() {
  const state2 = useEditorState();
  const pluginState = key$1.getState(state2);
  if (!pluginState || pluginState.kind === "inactive") return null;
  return (0, import_jsx_runtime70.jsx)(AutocompleteDecorationInner, {
    state: pluginState
  });
}
function AutocompleteDecorationInner(props) {
  const state2 = useEditorState();
  const decoration = props.state.decorations.find()[0];
  const text7 = state2.doc.textBetween(decoration.from, decoration.to).slice(1);
  return (0, import_jsx_runtime70.jsx)(props.state.component, {
    query: text7,
    from: decoration.from,
    to: decoration.to
  });
}
function removeAutocompleteDecoration(tr2) {
  return tr2.setMeta(key$1, {
    action: "remove"
  });
}
function getAutocompleteDecoration(state2) {
  const pluginState = key$1.getState(state2);
  if ((pluginState === null || pluginState === void 0 ? void 0 : pluginState.kind) === "active") return pluginState.decorations.find()[0];
}
function removeAutocompleteDecorationAndContent(state2) {
  const decoration = getAutocompleteDecoration(state2);
  if (!decoration) return;
  return removeAutocompleteDecoration(state2.tr.delete(decoration.from, decoration.to));
}
var accentForeground = css({
  color: tokenSchema.color.foreground.accent
});
function autocompleteDecoration() {
  return new Plugin({
    key: key$1,
    state: {
      init: () => ({
        kind: "inactive"
      }),
      apply(tr2, value, oldState, newState) {
        const meta = tr2.getMeta(key$1);
        if ((meta === null || meta === void 0 ? void 0 : meta.action) === "add") {
          const deco = Decoration.inline(meta.from, meta.to, {
            nodeName: "decoration-autocomplete",
            class: accentForeground
          }, {
            inclusiveStart: false,
            inclusiveEnd: true
          });
          const trigger = newState.doc.textBetween(meta.from, meta.to, "");
          const decorations2 = DecorationSet.create(tr2.doc, [deco]);
          return {
            kind: "active",
            trigger,
            decorations: decorations2,
            component: meta.menu,
            pattern: meta.pattern
          };
        }
        if (value.kind === "inactive") return value;
        const decorations = value.decorations.map(tr2.mapping, tr2.doc);
        const decorationsArr = decorations.find();
        if ((meta === null || meta === void 0 ? void 0 : meta.action) === "remove" || !hasSelectionInDecorations(tr2.selection, decorations) || decorationsArr.length !== 1) {
          return inactiveDecorationState;
        }
        const {
          from: from2,
          to
        } = decorationsArr[0];
        const replacementChar = "�";
        const textBetween = newState.doc.textBetween(from2, to, replacementChar, replacementChar);
        if (value.trigger !== textBetween.slice(0, value.trigger.length) || textBetween.includes(replacementChar) || value.pattern && !value.pattern.test(textBetween)) {
          return inactiveDecorationState;
        }
        return {
          ...value,
          decorations
        };
      }
    },
    props: {
      decorations: (state2) => {
        const pluginState = key$1.getState(state2);
        if ((pluginState === null || pluginState === void 0 ? void 0 : pluginState.kind) === "active") return pluginState.decorations;
        return DecorationSet.empty;
      },
      handlePaste: handlePaste2,
      handleDrop: handlePaste2,
      handleKeyDown(view, event) {
        const state2 = key$1.getState(view.state);
        if ((state2 === null || state2 === void 0 ? void 0 : state2.kind) === "active" && event.key === "Escape") {
          removeAutocompleteDecoration(view.state.tr);
          return true;
        }
        return false;
      }
    }
  });
}
function handlePaste2(view) {
  const state2 = key$1.getState(view.state);
  if ((state2 === null || state2 === void 0 ? void 0 : state2.kind) === "active") {
    view.dispatch(removeAutocompleteDecoration(view.state.tr));
  }
  return false;
}
function useEditorListbox(props) {
  let {
    listenerRef,
    onEscape,
    scrollRef,
    ...otherProps
  } = props;
  let state2 = $e72dd72e1c76a225$export$2f645645f7bca764(props);
  let layout = useListBoxLayout(state2);
  let listboxRef = (0, import_react55.useRef)(null);
  let {
    collectionProps
  } = $ae20dd8cbca75726$export$d6daf82dcd84e87c({
    keyboardDelegate: layout,
    ref: listenerRef,
    scrollRef: scrollRef !== null && scrollRef !== void 0 ? scrollRef : listboxRef,
    selectionManager: state2.selectionManager,
    disallowEmptySelection: true,
    disallowTypeAhead: true,
    isVirtualized: true,
    shouldFocusWrap: true
  });
  let onKeyDown = (e3) => {
    var _props$onAction;
    switch (e3.key) {
      case "Enter":
        state2.selectionManager.select(state2.selectionManager.focusedKey);
        (_props$onAction = props.onAction) === null || _props$onAction === void 0 || _props$onAction.call(props, state2.selectionManager.focusedKey);
        e3.preventDefault();
        break;
      case "Escape":
        onEscape === null || onEscape === void 0 || onEscape();
        break;
    }
  };
  let keydownListener = $ff5963eb1fccf552$export$e08e3b67e392101e(onKeyDown, collectionProps.onKeyDown);
  return {
    keydownListener,
    listbox: (0, import_jsx_runtime70.jsx)(_ListBoxBase, {
      ref: listboxRef,
      renderEmptyState,
      layout,
      state: state2,
      autoFocus: "first",
      shouldUseVirtualFocus: true,
      shouldFocusWrap: true,
      UNSAFE_className: listStyles,
      ...otherProps
    })
  };
}
function renderEmptyState() {
  return (0, import_jsx_runtime70.jsx)(HStack, {
    alignItems: "center",
    gap: "regular",
    height: "element.regular",
    paddingX: "medium",
    children: (0, import_jsx_runtime70.jsx)(Text, {
      color: "neutralSecondary",
      weight: "medium",
      children: "No results…"
    })
  });
}
var key2 = new PluginKey("keydown");
function useEditorKeydownListener(handler) {
  const state2 = useEditorState();
  const pluginState = key2.getState(state2);
  const stableHandler = useEventCallback2(handler);
  (0, import_react55.useEffect)(() => {
    if (!pluginState) return;
    const obj = {
      fn: stableHandler
    };
    pluginState.add(obj);
    return () => {
      pluginState.delete(obj);
    };
  }, [pluginState, stableHandler]);
}
function keydownHandler2() {
  return new Plugin({
    key: key2,
    state: {
      init() {
        return /* @__PURE__ */ new Set();
      },
      apply(tr2, value) {
        return value;
      }
    },
    props: {
      handleKeyDown(view, event) {
        const pluginState = key2.getState(view.state);
        if (!pluginState) return false;
        for (const handler of pluginState) {
          if (handler.fn(event)) return true;
        }
        return false;
      }
    }
  });
}
function getReferenceElementForRange(view, from2, to) {
  const nodeAtFrom = view.state.doc.nodeAt(from2);
  if (nodeAtFrom !== null && to === from2 + nodeAtFrom.nodeSize) {
    const node3 = view.nodeDOM(from2);
    if (node3 instanceof Element) {
      return virtualElement(node3, view);
    }
  }
  const fromDom = view.domAtPos(from2);
  const toDom = view.domAtPos(to);
  const range = document.createRange();
  range.setStart(fromDom.node, fromDom.offset);
  range.setEnd(toDom.node, toDom.offset);
  return virtualElement(range, view);
}
function useEditorReferenceElement(from2, to) {
  const [referenceElement, setReferenceElement] = (0, import_react55.useState)(null);
  const getEditorView = useEditorViewInEffect();
  (0, import_react55.useLayoutEffect)(() => {
    const view = getEditorView();
    if (!view) {
      setReferenceElement(null);
      return;
    }
    setReferenceElement(getReferenceElementForRange(view, from2, to));
  }, [getEditorView, from2, to]);
  return referenceElement;
}
function virtualElement(el, view) {
  const contextElement = view.dom;
  const getBoundingClientRect2 = () => el.getBoundingClientRect();
  return {
    contextElement,
    getBoundingClientRect: getBoundingClientRect2
  };
}
function EditorAutocomplete(props) {
  const viewRef = useEditorViewRef();
  const referenceElement = useEditorReferenceElement(props.from, props.to);
  const listenerRef = (0, import_react55.useMemo)(() => {
    return {
      get current() {
        var _viewRef$current$dom, _viewRef$current;
        return (_viewRef$current$dom = (_viewRef$current = viewRef.current) === null || _viewRef$current === void 0 ? void 0 : _viewRef$current.dom) !== null && _viewRef$current$dom !== void 0 ? _viewRef$current$dom : null;
      }
    };
  }, [viewRef]);
  const {
    keydownListener,
    listbox
  } = useEditorListbox({
    listenerRef,
    ...props,
    UNSAFE_style: {
      width: 320,
      ...props.UNSAFE_style
    }
  });
  useEditorKeydownListener((event) => {
    keydownListener(event);
    return event.defaultPrevented;
  });
  return referenceElement && (0, import_jsx_runtime70.jsx)(EditorPopover, {
    adaptToBoundary: "stretch",
    portal: false,
    minWidth: "element.medium",
    placement: "bottom-start",
    reference: referenceElement,
    children: listbox
  });
}
var insertMenuInputRule = {
  pattern: /(?:^|\s)\/$/,
  handler(state2, _match, _start, end) {
    return addAutocompleteDecoration(state2.tr, InsertMenu, end - 1, end, void 0);
  }
};
var getStateWithoutAutocompleteDecoration = weakMemoize2((state2) => {
  const tr2 = removeAutocompleteDecorationAndContent(state2);
  if (!tr2) {
    return {
      state: state2
    };
  }
  return {
    state: state2.apply(tr2),
    tr: tr2
  };
});
function wrapInsertMenuCommand(command) {
  return (stateWithInsertMenuText, dispatch, view) => {
    const {
      state: state2,
      tr: tr2
    } = getStateWithoutAutocompleteDecoration(stateWithInsertMenuText);
    if (!tr2) return false;
    if (dispatch) dispatch(tr2);
    return command(state2, dispatch, view);
  };
}
function itemRenderer(item2) {
  return (0, import_jsx_runtime70.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
    textValue: item2.label,
    children: [(0, import_jsx_runtime70.jsx)(Text, {
      children: item2.label
    }), item2.description && (0, import_jsx_runtime70.jsx)(Text, {
      slot: "description",
      children: item2.description
    }), item2.icon && (0, import_jsx_runtime70.jsx)(Icon, {
      src: item2.icon
    })]
  }, item2.id);
}
function InsertMenu(props) {
  const viewRef = useEditorViewRef();
  const dispatchCommand = useEditorDispatchCommand();
  const schema = useEditorSchema();
  const editorState = useEditorState();
  const options = (0, import_react55.useMemo)(() => matchSorter(schema.insertMenuItems, props.query, {
    keys: ["label"]
  }).filter((option) => option.command(editorState)), [editorState, schema.insertMenuItems, props.query]);
  useEditorKeydownListener((event) => {
    if (event.key !== " ") return false;
    if (options.length === 1) {
      dispatchCommand(wrapInsertMenuCommand(options[0].command));
      return true;
    }
    if (options.length === 0) {
      var _viewRef$current;
      (_viewRef$current = viewRef.current) === null || _viewRef$current === void 0 || _viewRef$current.dispatch(removeAutocompleteDecoration(editorState.tr));
    }
    return false;
  });
  return (0, import_jsx_runtime70.jsx)(EditorAutocomplete, {
    from: props.from,
    to: props.to,
    "aria-label": "Insert menu",
    items: options,
    children: itemRenderer,
    onEscape: () => {
      var _viewRef$current2;
      const tr2 = removeAutocompleteDecorationAndContent(editorState);
      if (!tr2) return;
      (_viewRef$current2 = viewRef.current) === null || _viewRef$current2 === void 0 || _viewRef$current2.dispatch(tr2);
    },
    onAction: (key3) => {
      const option = options.find((option2) => option2.id === key3);
      if (!option) return;
      dispatchCommand(wrapInsertMenuCommand(option.command));
    }
  });
}
function LinkToolbar(props) {
  const [dialogOpen, setDialogOpen] = (0, import_react55.useState)(false);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime70.jsxs)(Flex, {
    gap: "small",
    padding: "regular",
    children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => setDialogOpen(true),
        children: (0, import_jsx_runtime70.jsx)(Icon, {
          src: editIcon
        })
      }), (0, import_jsx_runtime70.jsx)(Tooltip, {
        children: stringFormatter.format("edit")
      })]
    }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => {
          window.open(props.href, "_blank", "noopener,noreferrer");
        },
        children: (0, import_jsx_runtime70.jsx)(Icon, {
          src: externalLinkIcon
        })
      }), (0, import_jsx_runtime70.jsx)(Tooltip, {
        children: (0, import_jsx_runtime70.jsx)(Text, {
          truncate: 3,
          children: props.href
        })
      })]
    }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
        prominence: "low",
        onPress: props.onUnlink,
        children: (0, import_jsx_runtime70.jsx)(Icon, {
          src: unlinkIcon
        })
      }), (0, import_jsx_runtime70.jsx)(Tooltip, {
        children: "Unlink"
      })]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setDialogOpen(false);
      },
      children: dialogOpen && (0, import_jsx_runtime70.jsx)(LinkDialog, {
        text: props.text,
        href: props.href,
        onSubmit: ({
          href
        }) => {
          props.onHrefChange(href);
        }
      })
    })]
  });
}
function LinkDialog({
  onSubmit,
  ...props
}) {
  let [href, setHref] = (0, import_react55.useState)(props.href || "");
  let [touched, setTouched] = (0, import_react55.useState)(false);
  let {
    dismiss
  } = useDialogContainer();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const showInvalidState = touched && !isValidURL$1(href);
  return (0, import_jsx_runtime70.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime70.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        if (!showInvalidState) {
          dismiss();
          onSubmit({
            href
          });
        }
      },
      children: [(0, import_jsx_runtime70.jsxs)(Heading, {
        children: [props.href ? "Edit" : "Add", " link"]
      }), (0, import_jsx_runtime70.jsx)(Content, {
        children: (0, import_jsx_runtime70.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          children: [(0, import_jsx_runtime70.jsx)(TextField, {
            label: "Text",
            value: props.text,
            isReadOnly: true
          }), (0, import_jsx_runtime70.jsx)(TextField, {
            autoFocus: true,
            isRequired: true,
            onBlur: () => setTouched(true),
            label: "Link",
            onChange: setHref,
            value: href,
            errorMessage: showInvalidState && "Please provide a valid URL."
          })]
        })
      }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime70.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime70.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
function ImagePopover(props) {
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  const runCommand = useEditorDispatchCommand();
  const [dialogOpen, setDialogOpen] = (0, import_react55.useState)(false);
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsxs)(Flex, {
      gap: "regular",
      padding: "regular",
      children: [(0, import_jsx_runtime70.jsxs)(Flex, {
        gap: "small",
        children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
            prominence: "low",
            onPress: () => setDialogOpen(true),
            children: (0, import_jsx_runtime70.jsx)(Icon, {
              src: editIcon
            })
          }), (0, import_jsx_runtime70.jsx)(Tooltip, {
            children: stringFormatter.format("edit")
          })]
        }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
            prominence: "low",
            onPress: async () => {
              const file = await getUploadedFileObject("image/*");
              if (!file) return;
              const src = new Uint8Array(await file.arrayBuffer());
              runCommand((state2, dispatch) => {
                if (dispatch) {
                  const {
                    tr: tr2
                  } = state2;
                  tr2.setNodeAttribute(props.pos, "src", src);
                  const newState = state2.apply(tr2);
                  tr2.setSelection(NodeSelection.create(newState.doc, props.pos));
                  dispatch(tr2);
                }
                return true;
              });
            },
            children: (0, import_jsx_runtime70.jsx)(Icon, {
              src: fileUpIcon
            })
          }), (0, import_jsx_runtime70.jsx)(Tooltip, {
            children: "Choose file"
          })]
        })]
      }), (0, import_jsx_runtime70.jsx)(Divider, {
        orientation: "vertical"
      }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          onPress: () => {
            runCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.delete(props.pos, props.pos + props.node.nodeSize));
              }
              return true;
            });
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: trash2Icon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          tone: "critical",
          children: "Remove"
        })]
      })]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setDialogOpen(false);
      },
      children: dialogOpen && (0, import_jsx_runtime70.jsx)(ImageDialog, {
        alt: props.node.attrs.alt,
        title: props.node.attrs.title,
        filename: props.node.attrs.filename,
        onSubmit: (value) => {
          runCommand((state2, dispatch) => {
            if (dispatch) {
              const {
                tr: tr2
              } = state2;
              tr2.setNodeMarkup(props.pos, void 0, {
                ...props.node.attrs,
                ...value
              });
              const newState = state2.apply(tr2);
              tr2.setSelection(NodeSelection.create(newState.doc, props.pos));
              dispatch(tr2);
            }
            return true;
          });
          setDialogOpen(false);
        }
      })
    })]
  });
}
function ImageDialog(props) {
  const schema = useEditorSchema();
  const [state2, setState] = (0, import_react55.useState)({
    alt: props.alt,
    title: props.title
  });
  const imagesSchema = (0, import_react55.useMemo)(() => ({
    kind: "object",
    fields: schema.config.image.schema
  }), [schema.config.image]);
  const previewProps = (0, import_react55.useMemo)(() => createGetPreviewProps(imagesSchema, setState, () => void 0), [imagesSchema])(state2);
  const [filenameWithoutExtension, filenameExtension] = splitFilename(props.filename);
  const [forceValidation, setForceValidation] = (0, import_react55.useState)(false);
  let [fileName, setFileName] = (0, import_react55.useState)(filenameWithoutExtension);
  let [fileNameTouched, setFileNameTouched] = (0, import_react55.useState)(false);
  let {
    dismiss
  } = useDialogContainer();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(l10nMessages);
  return (0, import_jsx_runtime70.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime70.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        setForceValidation(true);
        if (fileName && clientSideValidateProp(imagesSchema, state2, void 0)) {
          dismiss();
          props.onSubmit({
            alt: state2.alt,
            title: state2.title,
            filename: [fileName, filenameExtension].join(".")
          });
        }
      },
      children: [(0, import_jsx_runtime70.jsx)(Heading, {
        children: "Image details"
      }), (0, import_jsx_runtime70.jsx)(Content, {
        children: (0, import_jsx_runtime70.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          children: [(0, import_jsx_runtime70.jsx)(TextField, {
            label: "File name",
            onChange: setFileName,
            onBlur: () => setFileNameTouched(true),
            value: fileName,
            isRequired: true,
            errorMessage: (fileNameTouched || forceValidation) && !fileName ? "Please provide a file name." : void 0,
            endElement: filenameExtension ? (0, import_jsx_runtime70.jsx)(Flex, {
              alignItems: "center",
              justifyContent: "center",
              paddingEnd: "regular",
              children: (0, import_jsx_runtime70.jsxs)(Text, {
                color: "neutralTertiary",
                children: [".", filenameExtension]
              })
            }) : null
          }), (0, import_jsx_runtime70.jsx)(FormValueContentFromPreviewProps, {
            forceValidation,
            autoFocus: true,
            ...previewProps
          })]
        })
      }), (0, import_jsx_runtime70.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime70.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime70.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
function splitFilename(filename) {
  const dotIndex = filename.lastIndexOf(".");
  if (dotIndex === -1) {
    return [filename, ""];
  }
  return [filename.substring(0, dotIndex), filename.substring(dotIndex + 1)];
}
function ExtraAttributesMenuItem(props) {
  const [isOpen, setIsOpen] = (0, import_react55.useState)(false);
  const componentSchema = (0, import_react55.useMemo)(() => ({
    kind: "object",
    fields: props.schema
  }), [props.schema]);
  const value = useDeserializedValue(props.serialized, props.schema);
  const runCommand = useEditorDispatchCommand();
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => {
          setIsOpen(true);
        },
        children: (0, import_jsx_runtime70.jsx)(Icon, {
          src: pencilIcon
        })
      }), (0, import_jsx_runtime70.jsx)(Tooltip, {
        children: "Edit"
      })]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setIsOpen(false);
      },
      children: isOpen && (0, import_jsx_runtime70.jsxs)(Dialog, {
        children: [(0, import_jsx_runtime70.jsxs)(Heading, {
          children: ["Edit ", props.name]
        }), (0, import_jsx_runtime70.jsx)(FormValue, {
          schema: componentSchema,
          value,
          onSave: (value2) => {
            runCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.setNodeAttribute(props.pos, "props", toSerialized(value2, props.schema)));
              }
              return true;
            });
          }
        })]
      })
    })]
  });
}
function withShouldUse(val, shouldShow) {
  return Object.assign(val, {
    shouldShow
  });
}
var popoverComponents = {
  code_block: function CodeBlockPopover(props) {
    const dispatchCommand = useEditorDispatchCommand();
    const schema = useEditorSchema();
    const viewRef = useEditorViewRef();
    return (0, import_jsx_runtime70.jsxs)(Flex, {
      gap: "regular",
      padding: "regular",
      children: [(0, import_jsx_runtime70.jsx)(TextField, {
        "aria-label": "Code block language",
        value: props.node.attrs.language,
        onChange: (val) => {
          const view = viewRef.current;
          view.dispatch(view.state.tr.setNodeAttribute(props.pos, "language", val));
        }
      }), !!Object.keys(schema.config.codeBlock.schema).length && (0, import_jsx_runtime70.jsx)(ExtraAttributesMenuItem, {
        name: "Code Block",
        schema: schema.config.codeBlock.schema,
        pos: props.pos,
        serialized: props.node.attrs.props
      }), (0, import_jsx_runtime70.jsx)(Divider, {
        orientation: "vertical"
      }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          onPress: () => {
            dispatchCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.delete(props.pos, props.pos + props.node.nodeSize));
              }
              return true;
            });
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: trash2Icon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          tone: "critical",
          children: "Remove"
        })]
      })]
    });
  },
  image: ImagePopover,
  table: function TablePopover(props) {
    var _props$node$firstChil;
    const dispatchCommand = useEditorDispatchCommand();
    const schema = useEditorSchema();
    return (0, import_jsx_runtime70.jsxs)(Flex, {
      gap: "regular",
      padding: "regular",
      children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          isSelected: ((_props$node$firstChil = props.node.firstChild) === null || _props$node$firstChil === void 0 || (_props$node$firstChil = _props$node$firstChil.firstChild) === null || _props$node$firstChil === void 0 ? void 0 : _props$node$firstChil.type) === schema.nodes.table_header,
          onPress: () => {
            dispatchCommand(toggleHeader("row"));
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: sheetIcon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          children: "Header row"
        })]
      }), (0, import_jsx_runtime70.jsx)(Divider, {
        orientation: "vertical"
      }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          onPress: () => {
            dispatchCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.delete(props.pos, props.pos + props.node.nodeSize));
              }
              return true;
            });
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: trash2Icon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          tone: "critical",
          children: "Remove"
        })]
      })]
    });
  },
  heading: withShouldUse(function HeadingPopover(props) {
    const dispatchCommand = useEditorDispatchCommand();
    const schema = useEditorSchema();
    return (0, import_jsx_runtime70.jsxs)(Flex, {
      gap: "regular",
      padding: "regular",
      children: [(0, import_jsx_runtime70.jsx)(ExtraAttributesMenuItem, {
        name: "Heading",
        schema: schema.config.heading.schema,
        pos: props.pos,
        serialized: props.node.attrs.props
      }), (0, import_jsx_runtime70.jsx)(Divider, {
        orientation: "vertical"
      }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          onPress: () => {
            dispatchCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.delete(props.pos, props.pos + props.node.nodeSize));
              }
              return true;
            });
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: trash2Icon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          tone: "critical",
          children: "Remove"
        })]
      })]
    });
  }, (schema) => !!Object.keys(schema.config.heading.schema).length)
};
function markAround($pos, markType) {
  const {
    parent,
    parentOffset
  } = $pos;
  const start2 = parent.childAfter(parentOffset);
  if (!start2.node) return null;
  const mark = start2.node.marks.find((mark2) => mark2.type === markType);
  if (!mark) return null;
  let startIndex = $pos.index();
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  while (startIndex > 0 && mark.isInSet(parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= parent.child(startIndex).nodeSize;
  }
  while (endIndex < parent.childCount && mark.isInSet(parent.child(endIndex).marks)) {
    endPos += parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos,
    mark
  };
}
var LinkPopover = (props) => {
  const dispatchCommand = useEditorDispatchCommand();
  const href = props.mark.attrs.href;
  if (typeof href !== "string") {
    return null;
  }
  return (0, import_jsx_runtime70.jsx)(LinkToolbar, {
    text: props.state.doc.textBetween(props.from, props.to),
    href,
    onUnlink: () => {
      dispatchCommand((state2, dispatch) => {
        if (dispatch) {
          dispatch(state2.tr.removeMark(props.from, props.to, state2.schema.marks.link));
        }
        return true;
      });
    },
    onHrefChange: (href2) => {
      dispatchCommand((state2, dispatch) => {
        if (dispatch) {
          dispatch(state2.tr.removeMark(props.from, props.to, state2.schema.marks.link).addMark(props.from, props.to, state2.schema.marks.link.create({
            href: href2
          })));
        }
        return true;
      });
    }
  });
};
function InlineComponentPopover(props) {
  const schema = getEditorSchema(props.state.schema);
  const componentConfig = schema.components[props.node.type.name];
  const runCommand = useEditorDispatchCommand();
  const [isOpen, setIsOpen] = (0, import_react55.useState)(false);
  const componentSchema = (0, import_react55.useMemo)(() => ({
    kind: "object",
    fields: componentConfig.schema
  }), [componentConfig.schema]);
  const value = useDeserializedValue(props.node.attrs.props, componentConfig.schema);
  const editorViewRef = useEditorViewRef();
  if (componentConfig.kind === "inline" && componentConfig.ToolbarView) {
    return (0, import_jsx_runtime70.jsx)(componentConfig.ToolbarView, {
      value,
      onChange: (value2) => {
        const view = editorViewRef.current;
        view.dispatch(view.state.tr.setNodeAttribute(props.pos, "props", toSerialized(value2, componentSchema.fields)));
      },
      onRemove: () => {
        runCommand((state2, dispatch) => {
          if (dispatch) {
            dispatch(state2.tr.delete(props.pos, props.pos + props.node.nodeSize));
          }
          return true;
        });
      }
    });
  }
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsxs)(Flex, {
      gap: "regular",
      padding: "regular",
      children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          onPress: () => {
            setIsOpen(true);
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: pencilIcon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          children: "Edit"
        })]
      }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          onPress: () => {
            runCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.delete(props.pos, props.pos + props.node.nodeSize));
              }
              return true;
            });
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: trash2Icon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          tone: "critical",
          children: "Remove"
        })]
      })]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setIsOpen(false);
      },
      children: isOpen && (0, import_jsx_runtime70.jsxs)(Dialog, {
        children: [(0, import_jsx_runtime70.jsxs)(Heading, {
          children: ["Edit ", componentConfig.label]
        }), (0, import_jsx_runtime70.jsx)(FormValue, {
          schema: componentSchema,
          value,
          onSave: (value2) => {
            runCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.setNodeAttribute(props.pos, "props", toSerialized(value2, componentSchema.fields)));
              }
              return true;
            });
          }
        })]
      })
    })]
  });
}
var CustomMarkPopover = (props) => {
  const schema = getEditorSchema(props.state.schema);
  const componentConfig = schema.components[props.mark.type.name];
  const runCommand = useEditorDispatchCommand();
  const [isOpen, setIsOpen] = (0, import_react55.useState)(false);
  const componentSchema = (0, import_react55.useMemo)(() => ({
    kind: "object",
    fields: componentConfig.schema
  }), [componentConfig.schema]);
  const deserialized = useDeserializedValue(props.mark.attrs.props, componentConfig.schema);
  return (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsxs)(Flex, {
      gap: "regular",
      padding: "regular",
      children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          onPress: () => {
            setIsOpen(true);
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: pencilIcon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          children: "Edit"
        })]
      }), (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          onPress: () => {
            runCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.removeMark(props.from, props.to, props.mark.type));
              }
              return true;
            });
          },
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: trash2Icon
          })
        }), (0, import_jsx_runtime70.jsx)(Tooltip, {
          tone: "critical",
          children: "Remove"
        })]
      })]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setIsOpen(false);
      },
      children: isOpen && (0, import_jsx_runtime70.jsxs)(Dialog, {
        children: [(0, import_jsx_runtime70.jsxs)(Heading, {
          children: ["Edit ", componentConfig.label]
        }), (0, import_jsx_runtime70.jsx)(FormValue, {
          schema: componentSchema,
          value: deserialized,
          onSave: (value) => {
            runCommand((state2, dispatch) => {
              if (dispatch) {
                dispatch(state2.tr.removeMark(props.from, props.to, props.mark.type).addMark(props.from, props.to, props.mark.type.create({
                  props: toSerialized(value, componentConfig.schema)
                })));
              }
              return true;
            });
          }
        })]
      })
    })]
  });
};
function getPopoverDecoration(state2) {
  if (state2.selection instanceof TextSelection) {
    const schema = getEditorSchema(state2.schema);
    for (const [name2, componentConfig] of Object.entries(schema.components)) {
      if (componentConfig.kind !== "mark" || !Object.keys(componentConfig.schema).length) {
        continue;
      }
      const mark = schema.schema.marks[name2];
      const aroundFrom = markAround(state2.selection.$from, mark);
      const aroundTo = markAround(state2.selection.$to, mark);
      if (aroundFrom && aroundFrom.from === (aroundTo === null || aroundTo === void 0 ? void 0 : aroundTo.from) && aroundFrom.to === aroundTo.to) {
        return {
          adaptToBoundary: "flip",
          kind: "mark",
          component: CustomMarkPopover,
          mark: aroundFrom.mark,
          from: aroundFrom.from,
          to: aroundFrom.to
        };
      }
    }
    if (schema.marks.link) {
      const linkAroundFrom = markAround(state2.selection.$from, schema.marks.link);
      const linkAroundTo = markAround(state2.selection.$to, schema.marks.link);
      if (linkAroundFrom && linkAroundFrom.from === (linkAroundTo === null || linkAroundTo === void 0 ? void 0 : linkAroundTo.from) && linkAroundFrom.to === linkAroundTo.to) {
        return {
          adaptToBoundary: "flip",
          kind: "mark",
          component: LinkPopover,
          mark: linkAroundFrom.mark,
          from: linkAroundFrom.from,
          to: linkAroundFrom.to
        };
      }
    }
  }
  const editorSchema2 = getEditorSchema(state2.schema);
  if (state2.selection instanceof NodeSelection) {
    var _editorSchema$compone;
    const node3 = state2.selection.node;
    if (((_editorSchema$compone = editorSchema2.components[node3.type.name]) === null || _editorSchema$compone === void 0 ? void 0 : _editorSchema$compone.kind) === "inline") {
      return {
        adaptToBoundary: "stick",
        kind: "node",
        node: node3,
        component: InlineComponentPopover,
        pos: state2.selection.from
      };
    }
    const component = popoverComponents[node3.type.name];
    if (component !== void 0 && (!component.shouldShow || component.shouldShow(editorSchema2))) {
      return {
        adaptToBoundary: "stick",
        kind: "node",
        node: node3,
        component,
        pos: state2.selection.from
      };
    }
  }
  const commonAncestorPos = state2.selection.$from.start(state2.selection.$from.sharedDepth(state2.selection.to));
  const $pos = state2.doc.resolve(commonAncestorPos);
  for (let i2 = $pos.depth; i2 > 0; i2--) {
    const node3 = $pos.node(i2);
    if (!node3) break;
    const component = popoverComponents[node3.type.name];
    if (component !== void 0 && (!component.shouldShow || component.shouldShow(editorSchema2))) {
      return {
        adaptToBoundary: "stick",
        kind: "node",
        node: node3,
        component,
        pos: $pos.start(i2) - 1
      };
    }
  }
  return null;
}
function PopoverInner(props) {
  const from2 = props.decoration.kind === "node" ? props.decoration.pos : props.decoration.from;
  const to = props.decoration.kind === "node" ? props.decoration.pos + props.decoration.node.nodeSize : props.decoration.to;
  const reference = useEditorReferenceElement(from2, to);
  return reference && (0, import_jsx_runtime70.jsx)(EditorPopover, {
    adaptToBoundary: props.decoration.adaptToBoundary,
    minWidth: "element.medium",
    placement: "bottom",
    portal: false,
    reference,
    children: props.decoration.kind === "node" ? (0, import_jsx_runtime70.jsx)(props.decoration.component, {
      ...props.decoration,
      state: props.state
    }) : (0, import_jsx_runtime70.jsx)(props.decoration.component, {
      ...props.decoration,
      state: props.state
    })
  });
}
function EditorPopoverDecoration(props) {
  const popoverDecoration = (0, import_react55.useMemo)(() => getPopoverDecoration(props.state), [props.state]);
  if (!popoverDecoration) return null;
  return (0, import_jsx_runtime70.jsx)(PopoverInner, {
    decoration: popoverDecoration,
    state: props.state
  });
}
function ToolbarButton(props) {
  var _props$isSelected, _props$isDisabled;
  const state2 = useEditorState();
  const runCommand = useEditorDispatchCommand();
  const isSelected = !!((_props$isSelected = props.isSelected) !== null && _props$isSelected !== void 0 && _props$isSelected.call(props, state2));
  const isDisabled = !props.command(state2) || ((_props$isDisabled = props.isDisabled) === null || _props$isDisabled === void 0 ? void 0 : _props$isDisabled.call(props, state2));
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(EditorToolbarButton, {
    "aria-label": props["aria-label"],
    isSelected,
    isDisabled,
    onPress: () => {
      runCommand(props.command);
    },
    children: props.children
  }), [isDisabled, isSelected, props, runCommand]);
}
function LinkButton(props) {
  const [text7, setText] = (0, import_react55.useState)(null);
  const runCommand = useEditorDispatchCommand();
  const viewRef = useEditorViewRef();
  useEditorKeydownListener((event) => {
    if (event.metaKey && (event.key === "k" || event.key === "K")) {
      const {
        state: state2
      } = viewRef.current;
      if (!isMarkActive(props.link)(state2)) {
        event.preventDefault();
        setText(state2.doc.textBetween(state2.selection.from, state2.selection.to));
        return true;
      }
    }
    return false;
  });
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, {
    children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsx)(ToolbarButton, {
        "aria-label": "Divider",
        command: (state2, dispatch) => {
          const aroundFrom = markAround(state2.selection.$from, props.link);
          const aroundTo = markAround(state2.selection.$to, props.link);
          if (aroundFrom && (!aroundTo || aroundFrom.mark === (aroundTo === null || aroundTo === void 0 ? void 0 : aroundTo.mark))) {
            if (dispatch) {
              var _aroundTo$to;
              dispatch(state2.tr.removeMark(aroundFrom.from, (_aroundTo$to = aroundTo === null || aroundTo === void 0 ? void 0 : aroundTo.to) !== null && _aroundTo$to !== void 0 ? _aroundTo$to : aroundFrom.to, props.link));
            }
            return true;
          }
          if (state2.selection.empty) {
            return false;
          }
          if (dispatch) {
            const text8 = state2.doc.textBetween(state2.selection.from, state2.selection.to);
            setText(text8);
          }
          return true;
        },
        isSelected: isMarkActive(props.link),
        children: (0, import_jsx_runtime70.jsx)(Icon, {
          src: linkIcon
        })
      }), (0, import_jsx_runtime70.jsxs)(Tooltip, {
        children: [(0, import_jsx_runtime70.jsx)(Text, {
          children: "Link"
        }), (0, import_jsx_runtime70.jsx)(Kbd, {
          meta: true,
          children: "K"
        })]
      })]
    }), (0, import_jsx_runtime70.jsx)(DialogContainer, {
      onDismiss: () => {
        setText(null);
      },
      children: text7 && (0, import_jsx_runtime70.jsx)(LinkDialog, {
        href: "",
        text: text7,
        onSubmit: (attrs) => {
          setText(null);
          runCommand(toggleMark(props.link, attrs));
        }
      })
    })]
  }), [props.link, runCommand, text7]);
}
var Toolbar = (0, import_react55.memo)(function Toolbar2(props) {
  const schema = useEditorSchema();
  const {
    nodes,
    marks
  } = schema;
  return (0, import_jsx_runtime70.jsxs)(ToolbarWrapper, {
    ...props,
    children: [(0, import_jsx_runtime70.jsxs)(ToolbarScrollArea, {
      children: [nodes.heading && (0, import_jsx_runtime70.jsx)(HeadingMenu, {
        headingType: nodes.heading
      }), (0, import_jsx_runtime70.jsxs)(EditorToolbar, {
        "aria-label": "Formatting options",
        children: [(0, import_jsx_runtime70.jsx)(EditorToolbarSeparator, {}), (0, import_jsx_runtime70.jsx)(InlineMarks, {}), (0, import_jsx_runtime70.jsx)(EditorToolbarSeparator, {}), (0, import_jsx_runtime70.jsx)(ListButtons, {}), (0, import_jsx_runtime70.jsx)(EditorToolbarSeparator, {}), (0, import_jsx_runtime70.jsxs)(EditorToolbarGroup, {
          "aria-label": "Blocks",
          children: [nodes.divider && (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime70.jsx)(ToolbarButton, {
              "aria-label": "Divider",
              command: insertNode(nodes.divider),
              isSelected: typeInSelection(nodes.divider),
              children: (0, import_jsx_runtime70.jsx)(Icon, {
                src: minusIcon
              })
            }), (0, import_jsx_runtime70.jsxs)(Tooltip, {
              children: [(0, import_jsx_runtime70.jsx)(Text, {
                children: "Divider"
              }), (0, import_jsx_runtime70.jsx)(Kbd, {
                children: "---"
              })]
            })]
          }), marks.link && (0, import_jsx_runtime70.jsx)(LinkButton, {
            link: marks.link
          }), nodes.blockquote && (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime70.jsx)(ToolbarButton, {
              "aria-label": "Quote",
              command: (state2, dispatch) => {
                const hasQuote = typeInSelection(nodes.blockquote)(state2);
                if (hasQuote) {
                  const {
                    $from,
                    $to
                  } = state2.selection;
                  const range = $from.blockRange($to, (node3) => node3.type === nodes.blockquote);
                  if (!range) return false;
                  const target = liftTarget(range);
                  if (target === null) return false;
                  if (dispatch) {
                    dispatch(state2.tr.lift(range, target).scrollIntoView());
                  }
                  return true;
                } else {
                  return wrapIn(nodes.blockquote)(state2, dispatch);
                }
              },
              isSelected: typeInSelection(nodes.blockquote),
              children: (0, import_jsx_runtime70.jsx)(Icon, {
                src: quoteIcon
              })
            }), (0, import_jsx_runtime70.jsxs)(Tooltip, {
              children: [(0, import_jsx_runtime70.jsx)(Text, {
                children: "Quote"
              }), (0, import_jsx_runtime70.jsx)(Kbd, {
                children: ">⎵"
              })]
            })]
          }), nodes.code_block && (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime70.jsx)(ToolbarButton, {
              "aria-label": "Code block",
              command: toggleCodeBlock(nodes.code_block, nodes.paragraph),
              isSelected: typeInSelection(nodes.code_block),
              children: (0, import_jsx_runtime70.jsx)(Icon, {
                src: codeIcon
              })
            }), (0, import_jsx_runtime70.jsxs)(Tooltip, {
              children: [(0, import_jsx_runtime70.jsx)(Text, {
                children: "Code block"
              }), (0, import_jsx_runtime70.jsx)(Kbd, {
                children: "```"
              })]
            })]
          }), nodes.table && (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime70.jsx)(ToolbarButton, {
              "aria-label": "Table",
              command: insertTable(nodes.table),
              children: (0, import_jsx_runtime70.jsx)(Icon, {
                src: tableIcon
              })
            }), (0, import_jsx_runtime70.jsx)(Tooltip, {
              children: (0, import_jsx_runtime70.jsx)(Text, {
                children: "Table"
              })
            })]
          }), (0, import_jsx_runtime70.jsx)(ImageToolbarButton, {})]
        })]
      })]
    }), (0, import_jsx_runtime70.jsx)(InsertBlockMenu, {})]
  });
});
var ToolbarContainer = ({
  children
}) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime70.jsx)("div", {
    "data-layout": entryLayoutPane,
    className: css({
      alignItems: "center",
      boxSizing: "border-box",
      display: "flex",
      height: tokenSchema.size.element.medium,
      [breakpointQueries$1.above.mobile]: {
        height: tokenSchema.size.element.large
      },
      '&[data-layout="main"]': {
        marginInline: "auto",
        maxWidth: 800,
        minWidth: 0,
        paddingInline: tokenSchema.size.space.medium,
        [breakpointQueries$1.above.mobile]: {
          paddingInline: tokenSchema.size.space.xlarge
        },
        [breakpointQueries$1.above.tablet]: {
          paddingInline: tokenSchema.size.space.xxlarge
        }
      }
    }),
    children
  });
};
var ToolbarWrapper = (props) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime70.jsx)("div", {
    ...props,
    "data-layout": entryLayoutPane,
    className: css({
      backdropFilter: "blur(8px)",
      backgroundClip: "padding-box",
      backgroundColor: `color-mix(in srgb, transparent, ${tokenSchema.color.background.canvas} 90%)`,
      borderBottom: `${tokenSchema.size.border.regular} solid color-mix(in srgb, transparent, ${tokenSchema.color.foreground.neutral} 10%)`,
      borderStartEndRadius: tokenSchema.size.radius.medium,
      borderStartStartRadius: tokenSchema.size.radius.medium,
      minWidth: 0,
      position: "sticky",
      top: 0,
      zIndex: 2,
      '&[data-layout="main"]': {
        borderRadius: 0
      }
    }),
    children: (0, import_jsx_runtime70.jsx)(ToolbarContainer, {
      children: props.children
    })
  });
};
var ToolbarScrollArea = (props) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime70.jsx)("div", {
    "data-layout": entryLayoutPane,
    className: css({
      alignItems: "center",
      display: "flex",
      flex: 1,
      gap: tokenSchema.size.space.regular,
      paddingInline: tokenSchema.size.space.medium,
      minWidth: 0,
      overflowX: "auto",
      // avoid cropping focus rings
      marginBlock: `calc(${tokenSchema.size.alias.focusRing} * -1)`,
      paddingBlock: tokenSchema.size.alias.focusRing,
      // hide scrollbars
      msOverflowStyle: "none",
      // for Internet Explorer, Edge
      scrollbarWidth: "none",
      // for Firefox
      "&::-webkit-scrollbar": {
        display: "none"
      },
      // for Chrome, Safari, and Opera
      '&[data-layout="main"]': {
        paddingInline: 0
      }
    }),
    ...props
  });
};
var headingMenuVals = /* @__PURE__ */ new Map([["normal", "normal"], ["1", 1], ["2", 2], ["3", 3], ["4", 4], ["5", 5], ["6", 6]]);
function getHeadingMenuState(state2, headingType, paragraphType) {
  var _activeLevel;
  let activeLevel;
  for (const range of state2.selection.ranges) {
    state2.doc.nodesBetween(range.$from.pos, range.$to.pos, (node3) => {
      if (node3.type === headingType) {
        const level = node3.attrs.level;
        if (activeLevel === void 0) {
          activeLevel = level;
        } else if (activeLevel !== level) {
          activeLevel = "disabled";
        }
      }
      if (node3.type === paragraphType) {
        if (activeLevel === void 0) {
          activeLevel = "normal";
        } else if (activeLevel !== "normal") {
          activeLevel = "disabled";
        }
      }
    });
    if (activeLevel === "disabled") {
      break;
    }
  }
  return (_activeLevel = activeLevel) !== null && _activeLevel !== void 0 ? _activeLevel : "disabled";
}
var HeadingMenu = (props) => {
  const {
    nodes,
    config: config3
  } = useEditorSchema();
  const items = (0, import_react55.useMemo)(() => {
    let resolvedItems = [{
      name: "Paragraph",
      id: "normal"
    }];
    config3.heading.levels.forEach((level) => {
      resolvedItems.push({
        name: `Heading ${level}`,
        id: level.toString()
      });
    });
    return resolvedItems;
  }, [config3.heading.levels]);
  const state2 = useEditorState();
  const menuState = getHeadingMenuState(state2, props.headingType, nodes.paragraph);
  const runCommand = useEditorDispatchCommand();
  return (0, import_react55.useMemo)(() => (0, import_jsx_runtime70.jsx)(_Picker, {
    flexShrink: 0,
    width: "scale.1700",
    prominence: "low",
    "aria-label": "Text block",
    items,
    isDisabled: menuState === "disabled",
    selectedKey: menuState === "disabled" ? "normal" : menuState.toString(),
    onSelectionChange: (selected) => {
      let key3 = headingMenuVals.get(selected);
      if (key3 === "normal") {
        runCommand(setBlockType2(nodes.paragraph));
      } else if (key3) {
        runCommand(setBlockType2(props.headingType, {
          level: parseInt(key3)
        }));
      }
    },
    children: (item2) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      children: item2.name
    }, item2.id)
  }), [items, menuState, nodes.paragraph, props.headingType, runCommand]);
};
function InsertBlockMenu() {
  const entryLayoutPane = useEntryLayoutSplitPaneContext();
  const commandDispatch = useEditorDispatchCommand();
  const schema = useEditorSchema();
  const items = (0, import_react55.useMemo)(() => schema.insertMenuItems.filter((x) => x.forToolbar), [schema.insertMenuItems]);
  const idToItem = (0, import_react55.useMemo)(() => new Map(items.map((item2) => [item2.id, item2])), [items]);
  if (items.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime70.jsxs)(MenuTrigger, {
    align: "end",
    children: [(0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsxs)(ActionButton, {
        marginEnd: entryLayoutPane === "main" ? void 0 : "medium",
        children: [(0, import_jsx_runtime70.jsx)(Icon, {
          src: plusIcon
        }), (0, import_jsx_runtime70.jsx)(Icon, {
          src: chevronDownIcon
        })]
      }), (0, import_jsx_runtime70.jsxs)(Tooltip, {
        children: [(0, import_jsx_runtime70.jsx)(Text, {
          children: "Insert"
        }), (0, import_jsx_runtime70.jsx)(Kbd, {
          children: "/"
        })]
      })]
    }), (0, import_jsx_runtime70.jsx)(_Menu, {
      onAction: (id) => {
        var _idToItem$get;
        const command = (_idToItem$get = idToItem.get(id)) === null || _idToItem$get === void 0 ? void 0 : _idToItem$get.command;
        if (command) {
          commandDispatch(command);
        }
      },
      items,
      children: itemRenderer
    })]
  });
}
var isMarkActive = (markType) => (state2) => {
  if (state2.selection instanceof TextSelection && state2.selection.empty) {
    if (!state2.selection.$cursor) return false;
    return !!markType.isInSet(state2.storedMarks || state2.selection.$cursor.marks());
  }
  for (const range of state2.selection.ranges) {
    if (state2.doc.rangeHasMark(range.$from.pos, range.$to.pos, markType)) {
      return true;
    }
  }
  return false;
};
function InlineMarks() {
  const state2 = useEditorState();
  const schema = useEditorSchema();
  const runCommand = useEditorDispatchCommand();
  const inlineMarks2 = (0, import_react55.useMemo)(() => {
    const marks = [];
    if (schema.marks.bold) {
      marks.push({
        key: "bold",
        label: "Bold",
        icon: boldIcon,
        shortcut: `B`,
        command: toggleMark(schema.marks.bold),
        isSelected: isMarkActive(schema.marks.bold)
      });
    }
    if (schema.marks.italic) {
      marks.push({
        key: "italic",
        label: "Italic",
        icon: italicIcon,
        shortcut: `I`,
        command: toggleMark(schema.marks.italic),
        isSelected: isMarkActive(schema.marks.italic)
      });
    }
    if (schema.marks.strikethrough) {
      marks.push({
        key: "strikethrough",
        label: "Strikethrough",
        icon: strikethroughIcon,
        command: toggleMark(schema.marks.strikethrough),
        isSelected: isMarkActive(schema.marks.strikethrough)
      });
    }
    if (schema.marks.code) {
      marks.push({
        key: "code",
        label: "Code",
        icon: codeIcon,
        command: toggleMark(schema.marks.code),
        isSelected: isMarkActive(schema.marks.code)
      });
    }
    for (const [name2, componentConfig] of Object.entries(schema.components)) {
      if (componentConfig.kind !== "mark") continue;
      marks.push({
        key: name2,
        label: componentConfig.label,
        icon: componentConfig.icon,
        command: toggleMark(schema.schema.marks[name2]),
        isSelected: isMarkActive(schema.schema.marks[name2])
      });
    }
    marks.push({
      key: "clearFormatting",
      label: "Clear formatting",
      icon: removeFormattingIcon,
      command: removeAllMarks(),
      isSelected: () => false
    });
    return marks;
  }, [schema]);
  const selectedKeys = useMemoStringified(inlineMarks2.filter((val) => val.isSelected(state2)).map((val) => val.key));
  const disabledKeys = useMemoStringified(inlineMarks2.filter((val) => !val.command(state2)).map((val) => val.key));
  return (0, import_react55.useMemo)(() => {
    return (0, import_jsx_runtime70.jsx)(EditorToolbarGroup, {
      "aria-label": "Text formatting",
      value: selectedKeys,
      onChange: (key3) => {
        const mark = inlineMarks2.find((mark2) => mark2.key === key3);
        if (mark) {
          runCommand(mark.command);
        }
      },
      disabledKeys,
      selectionMode: "multiple",
      children: inlineMarks2.map((mark) => (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(EditorToolbarItem, {
          value: mark.key,
          "aria-label": mark.label,
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: mark.icon
          })
        }), (0, import_jsx_runtime70.jsxs)(Tooltip, {
          children: [(0, import_jsx_runtime70.jsx)(Text, {
            children: mark.label
          }), "shortcut" in mark && (0, import_jsx_runtime70.jsx)(Kbd, {
            meta: true,
            children: mark.shortcut
          })]
        })]
      }, mark.key))
    });
  }, [disabledKeys, inlineMarks2, runCommand, selectedKeys]);
}
function useMemoStringified(value) {
  return (0, import_react55.useMemo)(() => value, [JSON.stringify(value)]);
}
function getActiveListType(state2, schema) {
  const sharedDepth = state2.selection.$from.sharedDepth(state2.selection.to);
  for (let i2 = sharedDepth; i2 > 0; i2--) {
    const node3 = state2.selection.$from.node(i2);
    if (node3.type === schema.nodes.ordered_list) {
      return "ordered_list";
    } else if (node3.type === schema.nodes.unordered_list) {
      return "unordered_list";
    }
  }
  return null;
}
function ListButtons() {
  const state2 = useEditorState();
  const schema = useEditorSchema();
  const dispatchCommand = useEditorDispatchCommand();
  const canWrapInOrderedList = !!schema.nodes.ordered_list && toggleList(schema.nodes.ordered_list)(state2);
  const canWrapInUnorderedList = !!schema.nodes.unordered_list && toggleList(schema.nodes.unordered_list)(state2);
  const activeListType = getActiveListType(state2, schema);
  const items = (0, import_react55.useMemo)(() => {
    return [!!schema.nodes.unordered_list && {
      label: "Bullet list",
      key: "unordered_list",
      shortcut: "-",
      icon: listIcon
    }, !!schema.nodes.ordered_list && {
      label: "Numbered list",
      key: "ordered_list",
      shortcut: "1.",
      icon: listOrderedIcon
    }].filter(removeFalse);
  }, [schema.nodes.unordered_list, schema.nodes.ordered_list]);
  const disabledKeys = (0, import_react55.useMemo)(() => {
    return [!canWrapInOrderedList && "ordered_list", !canWrapInUnorderedList && "unordered_list"].filter(removeFalse);
  }, [canWrapInOrderedList, canWrapInUnorderedList]);
  return (0, import_react55.useMemo)(() => {
    if (items.length === 0) {
      return null;
    }
    return (0, import_jsx_runtime70.jsx)(EditorToolbarGroup, {
      "aria-label": "Lists",
      value: activeListType,
      onChange: (key3) => {
        const format2 = key3;
        const type = schema.nodes[format2];
        if (type) {
          dispatchCommand(toggleList(type));
        }
      },
      disabledKeys,
      selectionMode: "single",
      children: items.map((item2) => (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
        children: [(0, import_jsx_runtime70.jsx)(EditorToolbarItem, {
          value: item2.key,
          "aria-label": item2.label,
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: item2.icon
          })
        }), (0, import_jsx_runtime70.jsxs)(Tooltip, {
          children: [(0, import_jsx_runtime70.jsx)(Text, {
            children: item2.label
          }), (0, import_jsx_runtime70.jsx)(Kbd, {
            meta: true,
            children: item2.shortcut
          })]
        })]
      }, item2.key))
    });
  }, [activeListType, disabledKeys, dispatchCommand, items, schema.nodes]);
}
function removeFalse(val) {
  return val !== false;
}
function removeAllMarks() {
  return (state2, dispatch) => {
    if (state2.selection.empty) {
      return false;
    }
    if (dispatch) {
      dispatch(state2.tr.removeMark(state2.selection.from, state2.selection.to));
    }
    return true;
  };
}
function typeInSelection(type) {
  return (state2) => {
    let hasBlock = false;
    for (const range of state2.selection.ranges) {
      state2.doc.nodesBetween(range.$from.pos, range.$to.pos, (node3) => {
        if (node3.type === type) {
          hasBlock = true;
        }
      });
      if (hasBlock) break;
    }
    return hasBlock;
  };
}
var i = 0;
function NodeViewContentDOM(props) {
  const viewRef = useEditorViewRef();
  return (0, import_jsx_runtime70.jsx)("span", {
    className: displayContentsClassName,
    ref: (0, import_react55.useCallback)((element3) => {
      if (!element3) return;
      element3.appendChild(props.node);
      const view = viewRef.current;
      if (!view) return;
      if (view.hasFocus()) {
        view.focus();
      }
    }, [props.node, viewRef])
  });
}
var NodeViewWrapper = (0, import_react55.memo)(function NodeViewWrapper2(props) {
  return (0, import_jsx_runtime70.jsx)(props.component, {
    node: props.node,
    getPos: props.getPos,
    hasNodeSelection: props.hasNodeSelection,
    isNodeCompletelyWithinSelection: props.isNodeCompletelyWithinSelection,
    children: props.contentDOM ? (0, import_jsx_runtime70.jsx)(NodeViewContentDOM, {
      node: props.contentDOM
    }) : null
  });
});
function NodeViews(props) {
  const pluginState = reactNodeViewKey.getState(props.state);
  const [nodeViews, setNodeViews] = (0, import_react55.useState)(pluginState.nodeViews);
  (0, import_react55.useLayoutEffect)(() => {
    return pluginState.register(() => {
      setNodeViews(pluginState.nodeViews);
    });
  });
  const nodeSelectionPos = props.state.selection instanceof NodeSelection ? props.state.selection.from : void 0;
  const selectionFrom = props.state.selection.from;
  const selectionTo = props.state.selection.to;
  return (0, import_jsx_runtime70.jsx)(import_jsx_runtime70.Fragment, {
    children: [...nodeViews].map(([key3, {
      contentDOM,
      dom,
      node: node3,
      getPos
    }]) => {
      const nodeViewSpec = getReactNodeViewSpec(node3.type);
      if (!nodeViewSpec) return null;
      const pos = getPos();
      if (pos === void 0) return null;
      return (0, import_react_dom6.createPortal)((0, import_jsx_runtime70.jsx)(NodeViewWrapper, {
        hasNodeSelection: nodeSelectionPos === pos,
        isNodeCompletelyWithinSelection: pos >= selectionFrom && pos + node3.nodeSize <= selectionTo,
        node: node3,
        contentDOM,
        component: nodeViewSpec.component,
        getPos
      }), dom, key3);
    })
  });
}
function getReactNodeViewSpec(type) {
  return type.spec.reactNodeView;
}
var displayContentsClassName = css({
  display: "contents"
});
function elementWithDisplayContents(tag) {
  const element3 = document.createElement(tag);
  element3.classList.add(displayContentsClassName);
  return element3;
}
var reactNodeViewKey = new PluginKey("reactNodeViews");
function reactNodeViews(schema) {
  const nodes = /* @__PURE__ */ new Set();
  for (const nodeType of Object.values(schema.nodes)) {
    if (nodeType.spec.reactNodeView || nodeType.spec.nodeView) {
      nodes.add(nodeType);
    }
  }
  const plugin4 = new Plugin({
    key: reactNodeViewKey,
    state: {
      init() {
        const callbacks = /* @__PURE__ */ new Set();
        return {
          nodeViews: /* @__PURE__ */ new Map(),
          callbacks,
          register: (callback) => {
            callbacks.add(callback);
            return () => {
              callbacks.delete(callback);
            };
          }
        };
      },
      apply(tr2, pluginState) {
        return pluginState;
      }
    },
    props: {
      nodeViews: Object.fromEntries([...nodes].map((type) => [type.name, (node3, view, getPos) => {
        if (type.spec.nodeView) {
          return type.spec.nodeView(node3, view, getPos);
        }
        const reactNodeViewSpec = getReactNodeViewSpec(type);
        const dom = document.createElement(type.isInline ? "span" : "div");
        const contentDOM = reactNodeViewSpec !== null && reactNodeViewSpec !== void 0 && reactNodeViewSpec.rendersOwnContent || type.isLeaf ? void 0 : elementWithDisplayContents(type.inlineContent ? "div" : "span");
        const inner = elementWithDisplayContents(type.inlineContent ? "div" : "span");
        dom.appendChild(inner);
        const key3 = `${i++}`;
        const info = {
          contentDOM,
          dom: inner,
          getPos,
          key: key3,
          node: node3
        };
        const pluginState = reactNodeViewKey.getState(view.state);
        pluginState.nodeViews.set(key3, info);
        const cb = () => {
          for (const callback of pluginState.callbacks) {
            callback();
          }
        };
        cb();
        return {
          dom,
          contentDOM,
          destroy() {
            pluginState.nodeViews.delete(key3);
            cb();
          },
          ignoreMutation(mutation) {
            return !(contentDOM !== null && contentDOM !== void 0 && contentDOM.contains(mutation.target));
          },
          deselectNode() {
          },
          selectNode() {
          },
          update(node4) {
            if (node4.type !== type) return false;
            pluginState.nodeViews.set(key3, {
              ...info,
              node: node4
            });
            cb();
            return true;
          }
        };
      }]))
    }
  });
  return plugin4;
}
var cellActions = {
  deleteRow: {
    label: "Delete row",
    command: deleteRow
  },
  deleteColumn: {
    label: "Delete column",
    command: deleteColumn
  },
  insertRowBelow: {
    label: "Insert row below",
    command: addRowAfter
  },
  insertColumnRight: {
    label: "Insert column right",
    command: addColumnAfter
  }
};
function CellMenu() {
  const runCommand = useEditorDispatchCommand();
  const gutter = tokenSchema.size.space.small;
  return (0, import_jsx_runtime70.jsx)("div", {
    contentEditable: false,
    className: css({
      top: gutter,
      insetInlineEnd: gutter,
      position: "absolute"
    }),
    children: (0, import_jsx_runtime70.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime70.jsxs)(MenuTrigger, {
        align: "end",
        children: [(0, import_jsx_runtime70.jsx)(ActionButton, {
          prominence: "low",
          "aria-label": "Cell options",
          UNSAFE_className: css({
            borderRadius: tokenSchema.size.radius.small,
            height: "auto",
            minWidth: 0,
            padding: 0,
            // tiny buttons; increase the hit area
            "&::before": {
              content: '""',
              inset: `calc(${gutter} * -1)`,
              position: "absolute"
            }
          }),
          children: (0, import_jsx_runtime70.jsx)(Icon, {
            src: chevronDownIcon
          })
        }), (0, import_jsx_runtime70.jsx)(_Menu, {
          onAction: (key3) => {
            if (key3 in cellActions) {
              runCommand(cellActions[key3].command);
            }
          },
          items: Object.entries(cellActions).map(([key3, item2]) => ({
            ...item2,
            key: key3
          })),
          children: (item2) => (0, import_jsx_runtime70.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
            children: item2.label
          }, item2.key)
        })]
      }), (0, import_jsx_runtime70.jsx)(Tooltip, {
        children: "Options"
      })]
    })
  });
}
function getDecoration(state2) {
  const cellPos = findCellPosAbove(state2.selection.$from);
  if (cellPos !== void 0) {
    const element3 = document.createElement("div");
    const decoration = Decoration.widget(cellPos + 1, element3, {
      element: element3,
      side: 1
    });
    return {
      set: DecorationSet.create(state2.doc, [decoration]),
      element: element3
    };
  }
}
var _tableCellMenuPlugin = new Plugin({
  state: {
    init(config3, state2) {
      return getDecoration(state2);
    },
    apply(tr2, oldPluginState, oldState, state2) {
      return getDecoration(state2);
    }
  },
  props: {
    decorations(state2) {
      var _tableCellMenuPlugin$;
      return (_tableCellMenuPlugin$ = _tableCellMenuPlugin.getState(state2)) === null || _tableCellMenuPlugin$ === void 0 ? void 0 : _tableCellMenuPlugin$.set;
    }
  }
});
function tableCellMenuPlugin() {
  return _tableCellMenuPlugin;
}
function CellMenuPortal() {
  var _tableCellMenuPlugin$2;
  const state2 = useEditorState();
  const element3 = (_tableCellMenuPlugin$2 = _tableCellMenuPlugin.getState(state2)) === null || _tableCellMenuPlugin$2 === void 0 ? void 0 : _tableCellMenuPlugin$2.element;
  if (!element3) return null;
  return (0, import_react_dom6.createPortal)((0, import_jsx_runtime70.jsx)(CellMenu, {}), element3);
}
function findCellPosAbove($pos) {
  for (let d = $pos.depth; d > 0; d--) {
    const node3 = $pos.node(d);
    const role = node3.type.spec.tableRole;
    if (role === "cell" || role === "header_cell") {
      return $pos.before(d);
    }
  }
}
var EditorContext = (0, import_react55.createContext)({
  id: ""
});
var EditorContextProvider = EditorContext.Provider;
function getRootId(id) {
  return `keystatic-editor-root-${id}`;
}
function getToolbarId(id) {
  return `keystatic-editor-toolbar-${id}`;
}
function getContentId(id) {
  return `keystatic-editor-content-${id}`;
}
var contentStyles = css({
  flex: 1,
  height: "auto",
  minHeight: tokenSchema.size.scale[2e3],
  minWidth: 0,
  outline: 0,
  padding: tokenSchema.size.space.medium,
  '[data-layout="main"] > div > &': {
    boxSizing: "border-box",
    height: "100%",
    padding: 0,
    paddingTop: tokenSchema.size.space.medium,
    minHeight: 0,
    minWidth: 0,
    maxWidth: 800,
    marginInline: "auto",
    [breakpointQueries$1.above.mobile]: {
      padding: tokenSchema.size.space.xlarge
    },
    [breakpointQueries$1.above.tablet]: {
      padding: tokenSchema.size.space.xxlarge
    },
    '&[data-container="wide"]': {
      padding: tokenSchema.size.scale[600]
    }
  }
});
var Editor2 = (0, import_react55.forwardRef)(function Editor3({
  value: _value,
  onChange: _onChange,
  ...props
}, ref2) {
  const [valueWhileInCollab, setValueWhileInCollab] = (0, import_react55.useState)(_value);
  if ("yjs" in _onChange) {
    var _ySyncPluginKey$getSt;
    const yjsFragment = (_ySyncPluginKey$getSt = ySyncPluginKey.getState(valueWhileInCollab)) === null || _ySyncPluginKey$getSt === void 0 ? void 0 : _ySyncPluginKey$getSt.type;
    if (yjsFragment !== _onChange.yjs()) {
      setValueWhileInCollab(_value);
    }
  }
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const containerSize = useContentPanelSize();
  const styleProps = useProseStyleProps({
    size: entryLayoutPane === "main" ? "medium" : "regular",
    UNSAFE_className: contentStyles,
    ...toDataAttributes({
      layout: entryLayoutPane,
      container: containerSize
    })
  });
  let value, onChange;
  if (yCursorPluginKey.getState(_value)) {
    value = valueWhileInCollab !== null && valueWhileInCollab !== void 0 ? valueWhileInCollab : _value;
    onChange = setValueWhileInCollab;
  } else {
    value = _value;
    onChange = _onChange;
  }
  const id = (0, import_react55.useId)();
  const editorContext = (0, import_react55.useMemo)(() => ({
    id
  }), [id]);
  return (0, import_jsx_runtime70.jsx)(EditorContextProvider, {
    value: editorContext,
    children: (0, import_jsx_runtime70.jsxs)(ProseMirrorEditor, {
      value,
      onChange,
      ref: ref2,
      children: [(0, import_jsx_runtime70.jsxs)(Box, {
        id: getRootId(id),
        "data-keystatic-editor": "root",
        "data-layout": entryLayoutPane,
        backgroundColor: "canvas",
        minWidth: 0,
        UNSAFE_className: css(prosemirrorStyles, {
          '&[data-layout="main"]': {
            flex: 1,
            display: "flex",
            flexDirection: "column"
          },
          '&:not([data-layout="main"])': {
            border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
            borderRadius: tokenSchema.size.radius.medium
          }
        }),
        children: [(0, import_jsx_runtime70.jsx)(Toolbar, {
          id: getToolbarId(id),
          "data-keystatic-editor": "toolbar"
        }), (0, import_jsx_runtime70.jsx)("div", {
          children: (0, import_jsx_runtime70.jsx)(ProseMirrorEditable, {
            ...props,
            ...styleProps,
            role: "textbox",
            "aria-multiline": "true",
            id: getContentId(id),
            "data-keystatic-editor": "content"
          })
        })]
      }), (0, import_jsx_runtime70.jsx)(NodeViews, {
        state: value
      }), (0, import_jsx_runtime70.jsx)(CellMenuPortal, {}), (0, import_jsx_runtime70.jsx)(EditorPopoverDecoration, {
        state: value
      }), (0, import_jsx_runtime70.jsx)(AutocompleteDecoration, {})]
    })
  });
});
var emptyDecorations = [];
function getDecorationsForIndividualNode(node3) {
  if (!node3.type.spec.code || !node3.childCount) return emptyDecorations;
  const text7 = node3.content.child(0).text;
  if (!text7) return emptyDecorations;
  const lang = node3.attrs.language;
  if (typeof lang !== "string" || !Object.prototype.hasOwnProperty.call(Prism.languages, node3.attrs.language)) {
    return emptyDecorations;
  }
  const decorations = [];
  const tokens = Prism.tokenize(text7, Prism.languages[node3.attrs.language]);
  function consumeTokens(start2, tokens2) {
    for (const token of tokens2) {
      const length = getPrismTokenLength(token);
      const end = start2 + length;
      if (typeof token !== "string") {
        const className = styles2.get(token.type);
        if (className) {
          decorations.push({
            attrs: {
              class: className
            },
            from: start2,
            to: end
          });
        }
        consumeTokens(start2, Array.isArray(token.content) ? token.content : [token.content]);
      }
      start2 = end;
    }
  }
  consumeTokens(0, tokens);
  return decorations;
}
function getDecorationsForFragment(fragment) {
  let start2 = 0;
  const allDecorations = [];
  for (let i2 = 0; i2 < fragment.childCount; i2++) {
    const node3 = fragment.child(i2);
    const decorations = getDecorationsForNode(node3);
    if (!decorations.length) {
      start2 += node3.nodeSize;
      continue;
    }
    const textStart = start2 + 1;
    for (const decoration of decorations) {
      allDecorations.push({
        attrs: decoration.attrs,
        from: decoration.from + textStart,
        to: decoration.to + textStart
      });
    }
    start2 += node3.nodeSize;
  }
  return allDecorations;
}
var getDecorationsForNode = weakMemoize2((node3) => {
  if (node3.isTextblock) return getDecorationsForIndividualNode(node3);
  return getDecorationsForFragment(node3.content);
});
function codeBlockSyntaxHighlighting() {
  return new Plugin({
    props: {
      decorations(state2) {
        const decorations = getDecorationsForNode(state2.doc).map((decoration) => Decoration.inline(decoration.from, decoration.to, decoration.attrs));
        return DecorationSet.create(state2.doc, decorations);
      }
    }
  });
}
function getPrismTokenLength(token) {
  if (typeof token === "string") {
    return token.length;
  } else if (Array.isArray(token.content)) {
    return token.content.reduce((l2, t2) => l2 + getPrismTokenLength(t2), 0);
  } else {
    return getPrismTokenLength(token.content);
  }
}
var styles2 = new Map([{
  types: ["comment", "prolog", "doctype", "cdata"],
  style: {
    color: tokenSchema.color.foreground.neutralTertiary,
    fontStyle: "italic"
  }
}, {
  types: ["atrule", "attr-name", "class-name", "selector"],
  style: {
    color: tokenSchema.color.scale.amber11
  }
}, {
  types: ["boolean", "constant", "inserted-sign", "entity", "inserted", "number", "regex", "symbol", "variable"],
  style: {
    color: tokenSchema.color.scale.green11
  }
}, {
  types: ["attr-value", "builtin", "char", "constant", "generics", "url"],
  style: {
    color: tokenSchema.color.scale.pink11
  }
}, {
  types: ["string"],
  style: {
    color: tokenSchema.color.scale.indigo9
  }
}, {
  types: ["annotation", "deleted", "deleted-sign", "decorator", "important", "tag"],
  style: {
    color: tokenSchema.color.scale.red11
  }
}, {
  types: ["function", "function-variable", "operator"],
  style: {
    color: tokenSchema.color.scale.purple11
  }
}, {
  types: ["tag", "selector", "keyword"],
  style: {
    color: tokenSchema.color.scale.indigo11
  }
}, {
  types: ["punctuation"],
  style: {
    color: tokenSchema.color.foreground.neutralSecondary
  }
}].flatMap((style) => {
  const className = css(style.style);
  return style.types.map((x) => [x, className]);
}));
var mac5 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
var codeModiferEnterCommand = (state2, dispatch, view) => {
  const {
    $head,
    $anchor
  } = state2.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  return chainCommands(createParagraphNear, liftEmptyBlock, splitBlock)(state2, dispatch, view);
};
function findSelectableAncestor($pos, startDepth) {
  for (let depth = startDepth; depth > 0; depth--) {
    let pos = $pos.before(depth);
    const node3 = $pos.doc.nodeAt(pos);
    if (node3 && node3.type.spec.selectable !== false) {
      return pos;
    }
  }
}
var selectParentSelectableNode = (state2, dispatch) => {
  const {
    $from,
    to
  } = state2.selection;
  const same = $from.sharedDepth(to);
  if (same === 0) return false;
  const pos = findSelectableAncestor($from, same);
  if (pos === void 0) return false;
  if (dispatch) {
    dispatch(state2.tr.setSelection(NodeSelection.create(state2.doc, pos)));
  }
  return true;
};
function keymapForSchema({
  nodes,
  marks,
  config: config3
}, isCollab) {
  const bindings = {};
  const add2 = (key3, command) => {
    if (bindings[key3]) {
      bindings[key3] = chainCommands(bindings[key3], command);
    } else {
      bindings[key3] = command;
    }
  };
  if (nodes.list_item) {
    add2("Enter", splitListItem(nodes.list_item));
    add2("Tab", sinkListItem(nodes.list_item));
    add2("Shift-Tab", liftListItem(nodes.list_item));
  }
  add2("Enter", chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock));
  let deleteBackward = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
  let deleteForward = chainCommands(deleteSelection, joinForward, selectNodeForward);
  add2("Backspace", deleteBackward);
  add2("Mod-Backspace", deleteBackward);
  add2("Shift-Backspace", deleteBackward);
  add2("Delete", deleteForward);
  add2("Mod-Delete", deleteForward);
  add2("Mod-a", selectAll);
  if (mac5) {
    add2("Ctrl-h", deleteBackward);
    add2("Alt-Backspace", deleteBackward);
    add2("Ctrl-d", deleteForward);
    add2("Ctrl-Alt-Backspace", deleteForward);
    add2("Alt-Delete", deleteForward);
    add2("Alt-d", deleteForward);
    add2("Ctrl-a", selectTextblockStart);
    add2("Ctrl-e", selectTextblockEnd);
  }
  add2("Mod-z", isCollab ? undo : undo2);
  add2("Shift-Mod-z", isCollab ? redo : redo2);
  if (mac5) {
    add2("Mod-y", isCollab ? redo : redo2);
  }
  const modiferEnterKeys = ["Mod-Enter", "Shift-Enter"];
  if (mac5) {
    modiferEnterKeys.push("Ctrl-Enter");
  }
  for (const key3 of modiferEnterKeys) {
    add2(key3, codeModiferEnterCommand);
    if (nodes.hard_break) {
      add2(key3, insertHardBreak(nodes.hard_break));
    }
  }
  for (const mark of Object.values(marks)) {
    if (mark.spec.shortcuts) {
      if (Array.isArray(mark.spec.shortcuts)) {
        for (const shortcut of mark.spec.shortcuts) {
          if (typeof shortcut !== "string") {
            throw new Error(`Invalid shortcut for mark ${mark.name}`);
          }
          add2(shortcut, toggleMark(mark));
        }
        continue;
      }
      throw new Error(`Invalid shortcuts for mark ${mark.name}`);
    }
  }
  add2("Alt-ArrowUp", joinUp);
  add2("Alt-ArrowDown", joinDown);
  add2("Escape", selectParentSelectableNode);
  if (nodes.unordered_list) {
    add2("Shift-Ctrl-8", toggleList(nodes.unordered_list));
  }
  if (nodes.ordered_list) {
    add2("Shift-Ctrl-9", toggleList(nodes.ordered_list));
  }
  add2("Shift-Ctrl-0", setBlockType2(nodes.paragraph));
  if (nodes.heading) {
    for (const level of config3.heading.levels) {
      add2(`Shift-Ctrl-${level}`, setBlockType2(nodes.heading, {
        level
      }));
    }
  }
  return bindings;
}
function insertHardBreak(hardBreakType) {
  return (state2, dispatch) => {
    if (dispatch) {
      dispatch(state2.tr.replaceSelectionWith(hardBreakType.create()).scrollIntoView());
    }
    return true;
  };
}
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options) {
    __publicField(this, "cursorPos", null);
    __publicField(this, "element", null);
    var _options$width;
    this.editorView = editorView;
    this.width = (_options$width = options.width) !== null && _options$width !== void 0 ? _options$width : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name2) => {
      let handler = (e3) => {
        this[name2](e3);
      };
      editorView.dom.addEventListener(name2, handler);
      return {
        name: name2,
        handler
      };
    });
  }
  destroy() {
    this.handlers.forEach(({
      name: name2,
      handler
    }) => this.editorView.dom.removeEventListener(name2, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size) {
        this.setCursor(null);
      } else this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos) return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock2 = !$pos.parent.inlineContent, rect;
    if (isBlock2) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node3 = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node3) {
          let nodeRect = node3.getBoundingClientRect();
          let top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after) {
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          }
          rect = {
            left: nodeRect.left,
            right: nodeRect.right,
            top: top - this.width / 2,
            bottom: top + this.width / 2
          };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = {
        left: coords.left - this.width / 2,
        right: coords.left + this.width / 2,
        top: coords.top,
        bottom: coords.bottom
      };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class) this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock2);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock2);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      parentLeft = rect2.left - parent.scrollLeft;
      parentTop = rect2.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  }
  scheduleRemoval(timeout2) {
    if (this.timeout !== void 0) {
      clearTimeout(this.timeout);
    }
    this.timeout = setTimeout(() => this.setCursor(null), timeout2);
  }
  dragover(event) {
    if (!this.editorView.editable) return;
    let pos = this.editorView.posAtCoords({
      left: event.clientX,
      top: event.clientY
    });
    let node3 = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node3 && node3.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point3 = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point3 != null) target = point3;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget)) {
      this.setCursor(null);
    }
  }
};
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown: handleKeyDown2,
      handleDOMEvents: {
        beforeinput
      }
    }
  });
}
var handleKeyDown2 = keydownHandler({
  ArrowLeft: arrow5("horiz", -1),
  ArrowRight: arrow5("horiz", 1),
  ArrowUp: arrow5("vert", -1),
  ArrowDown: arrow5("vert", 1)
});
function arrow5(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state2, dispatch, view) {
    let sel = state2.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;
      mustMove = false;
      $start = state2.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found) return false;
    if (dispatch) dispatch(state2.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable) return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) return false;
  let clickPos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) {
    return false;
  }
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor)) {
    return false;
  }
  let {
    $from
  } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert) return false;
  let frag = Fragment2.empty;
  for (let i2 = insert.length - 1; i2 >= 0; i2--) {
    frag = Fragment2.from(insert[i2].createAndFill(null, frag));
  }
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state2) {
  if (!(state2.selection instanceof GapCursor)) return null;
  let node3 = document.createElement("div");
  node3.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state2.doc, [Decoration.widget(state2.selection.head, node3, {
    key: "gapcursor"
  })]);
}
var MAX_MATCH = 500;
function inputRules({
  rules,
  enterRules
}) {
  return new Plugin({
    props: {
      handleTextInput(view) {
        setTimeout(() => {
          run(view, rules);
        });
        return false;
      },
      handleKeyDown(view, event) {
        if (event.key === "Enter") {
          return run(view, enterRules);
        }
        return false;
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            run(view, rules);
          });
        }
      }
    }
  });
}
function getMatch(state2, from2, to, rules) {
  const $from = state2.doc.resolve(from2);
  if ($from.parent.type.spec.code) return;
  const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, "￼");
  for (const rule of rules) {
    const match2 = rule.pattern.exec(textBefore);
    if (!match2) continue;
    const matchFrom = from2 - match2[0].length;
    const tr2 = rule.handler(state2, match2, matchFrom, to);
    if (!tr2) continue;
    return tr2;
  }
  return;
}
function run(view, rules) {
  const state2 = view.state;
  if (view.composing || !(state2.selection instanceof TextSelection)) {
    return false;
  }
  const {
    $cursor
  } = state2.selection;
  if (!$cursor) return false;
  const tr2 = getMatch(state2, $cursor.pos, $cursor.pos, rules);
  if (!tr2) return false;
  const yUndoPluginState = yUndoPluginKey.getState(view.state);
  if (yUndoPluginState) {
    const undoManager = yUndoPluginState.undoManager;
    undoManager.stopCapturing();
    view.dispatch(tr2);
  } else {
    view.dispatch(closeHistory(tr2));
  }
  return true;
}
function wrappingInputRuleHandler(nodeType, getAttrs = null, joinPredicate) {
  return (state2, match2, start2, end) => {
    let attrs = getAttrs instanceof Function ? getAttrs(match2) : getAttrs;
    let tr2 = state2.tr.delete(start2, end);
    let $start = tr2.doc.resolve(start2), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping) return null;
    tr2.wrap(range, wrapping);
    let before = tr2.doc.resolve(start2 - 1).nodeBefore;
    if (before && before.type == nodeType && canJoin(tr2.doc, start2 - 1) && (!joinPredicate || joinPredicate(match2, before))) {
      tr2.join(start2 - 1);
    }
    return tr2;
  };
}
function textblockTypeInputRuleHandler(nodeType, getAttrs = null) {
  return (state2, match2, start2, end) => {
    let $start = state2.doc.resolve(start2);
    let attrs = getAttrs instanceof Function ? getAttrs(match2) : getAttrs;
    if (attrs === false) return null;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) {
      return null;
    }
    return state2.tr.delete(start2, end).setBlockType(start2, start2, nodeType, attrs);
  };
}
function replaceTypeInputRuleHandler(nodeType, getAttrs = null) {
  return (state2, match2, start2, end) => {
    let $start = state2.doc.resolve(start2);
    let attrs = getAttrs instanceof Function ? getAttrs(match2) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) {
      return null;
    }
    return state2.tr.delete(start2, end).replaceSelectionWith(nodeType.createAndFill(attrs));
  };
}
function stringHandler(replacement) {
  return (state2, match2, start2, end) => {
    let insert = replacement;
    if (match2[1]) {
      let offset5 = match2[0].lastIndexOf(match2[1]);
      insert += match2[0].slice(offset5 + match2[1].length);
      start2 += offset5;
      let cutOff = start2 - end;
      if (cutOff > 0) {
        insert = match2[0].slice(offset5 - cutOff, offset5) + insert;
        start2 = end;
      }
    }
    return state2.tr.insertText(insert, start2, end);
  };
}
var shortcuts = {
  "...": "…",
  "-->": "→",
  "->": "→",
  "<-": "←",
  "<--": "←",
  "--": "–",
  "(c)": "©",
  "(r)": "®",
  "(tm)": "™"
};
var simpleMarkShortcuts = /* @__PURE__ */ new Map([["bold", ["**", "__"]], ["italic", ["*", "_"]], ["strikethrough", ["~~"]], ["code", ["`"]]]);
var textShortcutRules = Object.entries(shortcuts).map(([shortcut, replacement]) => ({
  pattern: new RegExp(`(${(0, import_escape_string_regexp2.default)(shortcut)})\\s$`),
  handler: stringHandler(replacement)
}));
function inputRulesForSchema({
  nodes,
  marks,
  config: config3
}) {
  const rules = [...textShortcutRules];
  if (nodes.blockquote) {
    rules.push({
      pattern: /^\s*>\s$/,
      handler: wrappingInputRuleHandler(nodes.blockquote)
    });
  }
  if (nodes.ordered_list) {
    rules.push({
      pattern: /^\s*\d+(?:\.|\))\s$/,
      handler: wrappingInputRuleHandler(nodes.ordered_list)
    });
  }
  if (nodes.unordered_list) {
    rules.push({
      pattern: /^\s*([-+*])\s$/,
      handler: wrappingInputRuleHandler(nodes.unordered_list)
    });
  }
  if (nodes.code_block) {
    rules.push({
      pattern: /^```(\w+)?\s$/,
      handler: textblockTypeInputRuleHandler(nodes.code_block, (match2) => {
        var _match$;
        return {
          language: (_match$ = match2[1]) !== null && _match$ !== void 0 ? _match$ : ""
        };
      })
    });
  }
  if (nodes.divider) {
    rules.push({
      pattern: /^---$/,
      handler: replaceTypeInputRuleHandler(nodes.divider)
    });
  }
  if (nodes.heading) {
    rules.push({
      pattern: /^(#{1,6})\s$/,
      handler: textblockTypeInputRuleHandler(nodes.heading, (match2) => config3.heading.levels.includes(match2[1].length) ? {
        level: match2[1].length
      } : null)
    });
  }
  for (const [markName, shortcuts2] of simpleMarkShortcuts) {
    const mark = marks[markName];
    for (const shortcut of shortcuts2) {
      if (!mark) continue;
      rules.push({
        pattern: new RegExp(`${shortcut[0] === "_" ? "(?:^|\\s)" : shortcut === "*" ? "(?:^|[^\\*])" : ""}${(0, import_escape_string_regexp2.default)(shortcut)}([^${(0, import_escape_string_regexp2.default)(shortcut[0])}\\s]|(?:[^${(0, import_escape_string_regexp2.default)(shortcut[0])}\\s].*[^\\s]))${(0, import_escape_string_regexp2.default)(shortcut)}$`),
        handler: (state2, [, content3], __start, end) => {
          const start2 = end - content3.length - shortcut.length * 2;
          if (!allowsMarkType(state2.doc, start2, end, mark)) return null;
          const tr2 = state2.tr;
          tr2.addMark(start2 + shortcut.length, end - shortcut.length, mark.create());
          tr2.delete(end - shortcut.length, end);
          tr2.delete(start2, start2 + shortcut.length);
          tr2.removeStoredMark(mark);
          return tr2;
        }
      });
    }
  }
  const linkType = marks.link;
  if (linkType) {
    rules.push({
      pattern: /(?:^|[^!])\[(.*)\]\((.*)\)$/,
      handler(state2, [, text7, href], __start, end) {
        const start2 = end - href.length - text7.length - 4;
        if (!allowsMarkType(state2.doc, start2, end, linkType)) return null;
        const tr2 = state2.tr;
        tr2.addMark(start2, end, linkType.create({
          href
        }));
        tr2.delete(start2 + 1 + text7.length, end);
        tr2.delete(start2, start2 + 1);
        tr2.removeStoredMark(linkType);
        return tr2;
      }
    });
  }
  rules.push(insertMenuInputRule);
  return rules;
}
function enterInputRulesForSchema({
  nodes
}) {
  const rules = [];
  if (nodes.code_block) {
    rules.push({
      pattern: /^```(\w+)?$/,
      handler: textblockTypeInputRuleHandler(nodes.code_block, (match2) => {
        var _match$2;
        return {
          language: (_match$2 = match2[1]) !== null && _match$2 !== void 0 ? _match$2 : ""
        };
      })
    });
  }
  return rules;
}
function allowsMarkType(doc4, start2, end, markType) {
  let allowsMarkType2 = true;
  doc4.nodesBetween(start2, end, (node3) => {
    if (!node3.isText && !node3.type.allowsMarkType(markType)) {
      allowsMarkType2 = false;
    }
  });
  return allowsMarkType2;
}
function isValidURL(url) {
  return url === (0, import_sanitize_url.sanitizeUrl)(url);
}
var urlPattern = /^https?:\/\//;
function rangeHasLink($from, $to, schema) {
  let hasLink = false;
  $from.doc.nodesBetween($from.pos, $to.pos, (node3) => {
    if (node3.marks.some((x) => x.type === schema.marks.link)) {
      hasLink = true;
      return false;
    }
  });
  return hasLink;
}
function pasteLinks(schema) {
  if (!schema.marks.link) return new Plugin({});
  const linkType = schema.marks.link;
  return new Plugin({
    props: {
      transformPasted(slice2) {
        var _slice$content$firstC, _slice$content$firstC2;
        if (slice2.content.childCount === 1 && ((_slice$content$firstC = slice2.content.firstChild) === null || _slice$content$firstC === void 0 ? void 0 : _slice$content$firstC.type) === schema.nodes.paragraph && ((_slice$content$firstC2 = slice2.content.firstChild.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.text) !== void 0 && urlPattern.test(slice2.content.firstChild.firstChild.text) && isValidURL(slice2.content.firstChild.firstChild.text) && slice2.content.firstChild.firstChild.marks.length === 0) {
          return Slice.maxOpen(Fragment2.from(schema.nodes.paragraph.createChecked(null, schema.schema.text(slice2.content.firstChild.firstChild.text, [linkType.create({
            href: slice2.content.firstChild.firstChild.text,
            title: ""
          })]))));
        }
        return slice2;
      },
      handlePaste(view, event) {
        var _event$clipboardData;
        const plain = (_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.getData("text/plain");
        if (plain && // isValidURL is a bit more permissive than a user might expect
        // so for pasting, we'll constrain it to starting with https:// or http://
        urlPattern.test(plain) && isValidURL(plain) && !view.state.selection.empty && view.state.selection.$from.parent === view.state.selection.$to.parent && !rangeHasLink(view.state.selection.$from, view.state.selection.$to, schema)) {
          const {
            tr: tr2
          } = view.state;
          tr2.addMark(view.state.selection.from, view.state.selection.to, linkType.create({
            href: plain,
            title: ""
          }));
          view.dispatch(tr2);
          return true;
        }
        return false;
      }
    }
  });
}
function textblockChildren(fragment, createTextNode, createLeafNode, createWrapperNode) {
  let content3 = [];
  let depth = 0;
  let active = [];
  let trailing = "";
  function getCurrentChildrenArray() {
    let current2 = content3;
    for (let i2 = 0; i2 < depth; i2++) {
      const last = current2[current2.length - 1];
      if (!("children" in last)) {
        throw new Error("Expected children in last element");
      }
      current2 = last.children;
    }
    return current2;
  }
  const process2 = (node3, offset5, index4) => {
    var _node;
    let marks = node3 ? node3.marks : [];
    let leading = trailing;
    trailing = "";
    if ((_node = node3) !== null && _node !== void 0 && _node.isText && marks.some((mark) => {
      return shouldExpelWhitespace(mark.type) && !mark.isInSet(active);
    })) {
      let [, lead, rest] = /^(\s*)(.*)$/m.exec(node3.text);
      if (lead) {
        leading += lead;
        node3 = rest ? node3.withText(rest) : null;
        if (!node3) marks = active;
      }
    }
    if (node3 && node3.isText && marks.some((mark) => {
      return shouldExpelWhitespace(mark.type) && (index4 == fragment.childCount - 1 || !mark.isInSet(fragment.child(index4 + 1).marks));
    })) {
      let [, rest, trail2] = /^(.*?)(\s*)$/m.exec(node3.text);
      if (trail2) {
        trailing = trail2;
        node3 = rest ? node3.withText(rest) : null;
        if (!node3) marks = active;
      }
    }
    outer: for (const [i2, mark] of marks.entries()) {
      if (!isMarkTypeMixable(mark.type)) {
        continue;
      }
      for (const [j, other] of active.entries()) {
        if (!isMarkTypeMixable(other.type)) break;
        if (mark.eq(other)) {
          if (i2 > j) {
            marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i2)).concat(marks.slice(i2 + 1, marks.length));
          } else if (j > i2) {
            marks = marks.slice(0, i2).concat(marks.slice(i2 + 1, j)).concat(mark).concat(marks.slice(j, marks.length));
          }
          continue outer;
        }
      }
    }
    let keep = 0;
    while (keep < Math.min(active.length, marks.length) && marks[keep].eq(active[keep])) {
      ++keep;
    }
    while (keep < active.length) {
      const mark = active.pop();
      if (mark.type !== getEditorSchema(mark.type.schema).marks.code) {
        depth--;
      }
    }
    if (leading) {
      getCurrentChildrenArray().push(createTextNode(leading));
    }
    if (node3) {
      while (active.length < marks.length) {
        let add2 = marks[active.length];
        active.push(add2);
        const wrapper = createWrapperNode(add2);
        if (wrapper) {
          getCurrentChildrenArray().push(wrapper);
          depth++;
        }
      }
      const leaf = createLeafNode(node3);
      if (leaf) {
        getCurrentChildrenArray().push(leaf);
      }
    }
  };
  fragment.forEach(process2);
  process2(null, 0, fragment.childCount);
  return content3;
}
function shouldExpelWhitespace(markType) {
  const schema = getEditorSchema(markType.schema);
  return markType === schema.marks.bold || markType === schema.marks.italic || markType === schema.marks.strikethrough;
}
function isMarkTypeMixable(markType) {
  const schema = getEditorSchema(markType.schema);
  return markType === schema.marks.bold || markType === schema.marks.italic || markType === schema.marks.strikethrough || markType === schema.marks.link;
}
function _blocks$1(fragment, state2) {
  const children = [];
  fragment.forEach((child) => {
    children.push(proseMirrorToMarkdoc(child, state2));
  });
  return children;
}
function _inline$1(fragment, state2) {
  return [new ast_default.Node("inline", {}, textblockChildren(fragment, (text7) => new ast_default.Node("text", {
    value: text7
  }), (node3) => getLeafContent$1(node3, state2), (mark) => getWrapperForMark$1(mark, state2)))];
}
function getLeafContent$1(node3, state2) {
  const {
    schema
  } = state2;
  if (node3.type === schema.nodes.hard_break) {
    return new ast_default.Node("hardbreak");
  }
  if (node3.type === schema.nodes.image) {
    const {
      src,
      filename
    } = node3.attrs;
    if (typeof state2.schema.config.image === "object" && typeof state2.schema.config.image.directory === "string") {
      const parent = fixPath(state2.schema.config.image.directory);
      if (!state2.otherFiles.has(parent)) {
        state2.otherFiles.set(parent, /* @__PURE__ */ new Map());
      }
      state2.otherFiles.get(parent).set(filename, src);
    } else {
      state2.extraFiles.set(filename, src);
    }
    return new ast_default.Node("image", {
      src: encodeURI(`${getSrcPrefixForImageBlock(state2.schema.config, state2.slug)}${node3.attrs.filename}`),
      alt: node3.attrs.alt,
      title: node3.attrs.title
    });
  }
  const componentConfig = state2.schema.components[node3.type.name];
  if ((componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.kind) === "inline") {
    const tag = new ast_default.Node("tag", internalToSerialized(componentConfig.schema, node3.attrs.props, state2), [], node3.type.name);
    tag.inline = true;
    return tag;
  }
  if (node3.text !== void 0) {
    return new ast_default.Node(node3.marks.some((x) => x.type === schema.marks.code) ? "code" : "text", {
      content: node3.text
    });
  }
}
function getWrapperForMark$1(mark, state2) {
  const {
    schema
  } = state2;
  if (mark.type === schema.marks.code) {
    return;
  }
  const componentConfig = schema.components[mark.type.name];
  if (componentConfig) {
    const node3 = new ast_default.Node("tag", internalToSerialized(componentConfig.schema, mark.attrs.props, state2), [], mark.type.name);
    node3.inline = true;
    return node3;
  }
  let type;
  if (mark.type === schema.marks.bold) {
    type = "strong";
  }
  if (mark.type === schema.marks.italic) {
    type = "em";
  }
  if (mark.type === schema.marks.strikethrough) {
    type = "s";
  }
  if (type) {
    return new ast_default.Node(type, {}, []);
  }
  if (mark.type === schema.marks.link) {
    return new ast_default.Node("link", {
      href: mark.attrs.href,
      title: mark.attrs.title
    });
  }
}
function proseMirrorToMarkdoc(node3, state2) {
  const blocks = (fragment) => _blocks$1(fragment, state2);
  const inline7 = (fragment) => _inline$1(fragment, state2);
  const schema = getEditorSchema(node3.type.schema);
  if (node3.type === schema.nodes.doc) {
    return new ast_default.Node("document", {}, blocks(node3.content));
  }
  if (node3.type === schema.nodes.paragraph) {
    return new ast_default.Node("paragraph", {}, inline7(node3.content));
  }
  if (node3.type === schema.nodes.blockquote) {
    return new ast_default.Node("blockquote", {}, blocks(node3.content));
  }
  if (node3.type === schema.nodes.divider) {
    return new ast_default.Node("hr");
  }
  if (node3.type === schema.nodes.table) {
    const rows = blocks(node3.content);
    const head = new ast_default.Node("thead", {}, []);
    if (rows[0].children[0].type === "th") {
      head.children.push(rows.shift());
    }
    const body = new ast_default.Node("tbody", {}, rows);
    return new ast_default.Node("tag", {}, [new ast_default.Node("table", {}, [head, body])], "table");
  }
  if (node3.type === schema.nodes.table_row) {
    return new ast_default.Node("tr", {}, blocks(node3.content));
  }
  if (node3.type === schema.nodes.table_header) {
    return new ast_default.Node("th", {}, blocks(node3.content));
  }
  if (node3.type === schema.nodes.table_cell) {
    return new ast_default.Node("td", {}, blocks(node3.content));
  }
  if (node3.type === schema.nodes.heading) {
    const extra = internalToSerialized(schema.config.heading.schema, node3.attrs.props, state2);
    const markdocNode = new ast_default.Node("heading", {
      level: node3.attrs.level,
      ...extra
    }, inline7(node3.content));
    for (const [key3, value] of Object.entries(extra)) {
      markdocNode.annotations.push({
        name: key3,
        value,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  if (node3.type === schema.nodes.code_block) {
    const extra = internalToSerialized(schema.config.codeBlock.schema, node3.attrs.props, state2);
    const markdocNode = new ast_default.Node("fence", typeof node3.attrs.language === "string" && node3.attrs.language !== "plain" ? {
      language: node3.attrs.language,
      content: node3.textBetween(0, node3.content.size) + "\n",
      ...extra
    } : {
      content: node3.textBetween(0, node3.content.size) + "\n",
      ...extra
    }, inline7(node3.content));
    for (const [key3, value] of Object.entries(extra)) {
      markdocNode.annotations.push({
        name: key3,
        value,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  if (node3.type === schema.nodes.list_item) {
    let listItemContent = blocks(node3.content);
    if (listItemContent.length === 1 && listItemContent[0].type === "paragraph") {
      listItemContent = listItemContent[0].children;
    }
    return new ast_default.Node("item", {}, listItemContent);
  }
  if (node3.type === schema.nodes.ordered_list) {
    return new ast_default.Node("list", {
      ordered: true
    }, blocks(node3.content));
  }
  if (node3.type === schema.nodes.unordered_list) {
    return new ast_default.Node("list", {
      ordered: false
    }, blocks(node3.content));
  }
  const name2 = node3.type.name;
  const componentConfig = schema.components[name2];
  if (componentConfig) {
    const children = componentConfig.kind === "wrapper" || componentConfig.kind === "repeating" ? blocks(node3.content) : [];
    return new ast_default.Node("tag", internalToSerialized(componentConfig.schema, node3.attrs.props, state2), children, name2);
  }
  return new ast_default.Node("paragraph", {}, inline7(node3.content));
}
var _state;
function getState$1() {
  if (!_state) {
    throw new Error("state not set");
  }
  return _state;
}
function getSchema$1() {
  return getState$1().schema;
}
function error$1(error3) {
  getState$1().errors.push(error3);
}
function withMark$1(mark, fn) {
  const state2 = getState$1();
  const oldMarks = state2.marks;
  state2.marks = mark.addToSet(state2.marks);
  try {
    return fn();
  } finally {
    state2.marks = oldMarks;
  }
}
function childrenToProseMirrorNodes$1(nodes, parentType) {
  const children = [];
  for (const node3 of nodes) {
    const pmNode = markdocNodeToProseMirrorNode$1(node3, parentType);
    if (pmNode) {
      if (Array.isArray(pmNode)) {
        children.push(...pmNode);
      } else {
        children.push(pmNode);
      }
    }
  }
  return children;
}
function notAllowed$1(node3, parentType) {
  error$1({
    error: {
      id: "unspecified-type",
      level: "critical",
      message: `${node3.type} is not allowed`
    },
    lines: node3.lines,
    type: node3.type,
    location: node3.location
  });
  return childrenToProseMirrorNodes$1(node3.children, parentType);
}
function createAndFill$1(markdocNode, nodeType, attrs, mapChildren2) {
  let children = childrenToProseMirrorNodes$1(markdocNode.children, nodeType);
  if (mapChildren2) {
    children = mapChildren2(children);
  }
  const node3 = nodeType.createAndFill(attrs, children);
  if (!node3) {
    error$1({
      error: {
        id: "unexpected-children",
        level: "critical",
        message: `${markdocNode.type} has unexpected children`
      },
      lines: markdocNode.lines,
      type: markdocNode.type,
      location: markdocNode.location
    });
  }
  return node3;
}
function addMark$1(node3, mark, parentType) {
  if (!mark) return notAllowed$1(node3, parentType);
  return withMark$1(mark instanceof MarkType ? mark.create() : mark, () => childrenToProseMirrorNodes$1(node3.children, parentType));
}
function markdocToProseMirror(node3, schema, files, otherFiles, slug) {
  _state = {
    schema,
    errors: [],
    marks: [],
    extraFiles: files !== null && files !== void 0 ? files : /* @__PURE__ */ new Map(),
    otherFiles: otherFiles !== null && otherFiles !== void 0 ? otherFiles : /* @__PURE__ */ new Map(),
    slug
  };
  try {
    let pmNode = markdocNodeToProseMirrorNode$1(node3, void 0);
    if (_state.errors.length) {
      throw new Error(_state.errors.map((e3) => e3.lines[0] + ":" + e3.error.message).join("\n"));
    }
    if (!(pmNode instanceof Node4)) {
      throw new Error("unexpected node");
    }
    return pmNode;
  } finally {
    _state = void 0;
  }
}
var wrapInParagraph$1 = (schema) => (children) => {
  const newChildren = [];
  let inlineQueue = [];
  for (const child of children) {
    if (child.isInline) {
      inlineQueue.push(child);
      continue;
    }
    if (inlineQueue.length) {
      newChildren.push(schema.nodes.paragraph.createChecked({}, inlineQueue));
      inlineQueue = [];
    }
    newChildren.push(child);
  }
  if (inlineQueue.length) {
    newChildren.push(schema.nodes.paragraph.createChecked({}, inlineQueue));
  }
  return newChildren;
};
function markdocNodeToProseMirrorNode$1(node3, parentType) {
  if (node3.errors.length) {
    for (const err of node3.errors) {
      error$1({
        error: err,
        lines: node3.lines,
        type: node3.type,
        location: node3.location
      });
    }
    return null;
  }
  if (node3.type === "error") {
    error$1({
      error: {
        id: "error-node",
        level: "critical",
        message: "Unexpected error node without errors"
      },
      lines: node3.lines,
      type: node3.type,
      location: node3.location
    });
    return null;
  }
  const schema = getSchema$1();
  if (node3.type === "inline") {
    return childrenToProseMirrorNodes$1(node3.children, parentType);
  }
  if (node3.type === "em") {
    return addMark$1(node3, schema.marks.italic, parentType);
  }
  if (node3.type === "code") {
    if (!schema.marks.code) return notAllowed$1(node3, parentType);
    return schema.schema.text(node3.attributes.content, [...getState$1().marks, schema.marks.code.create()]);
  }
  if (node3.type === "s") {
    return addMark$1(node3, schema.marks.strikethrough, parentType);
  }
  if (node3.type === "strong") {
    return addMark$1(node3, schema.marks.bold, parentType);
  }
  if (node3.type === "softbreak") {
    return schema.schema.text("\n");
  }
  if (node3.type === "hardbreak") {
    if (!schema.nodes.hard_break) return notAllowed$1(node3, parentType);
    return schema.nodes.hard_break.create();
  }
  if (node3.type === "blockquote") {
    if (!schema.nodes.blockquote) return notAllowed$1(node3, parentType);
    return createAndFill$1(node3, schema.nodes.blockquote, {});
  }
  if (node3.type === "heading") {
    if (!schema.nodes.heading) return notAllowed$1(node3, parentType);
    const {
      level,
      ...attrs
    } = node3.attributes;
    const state2 = getState$1();
    const fields = state2.schema.config.heading.schema;
    return createAndFill$1(node3, schema.nodes.heading, {
      level: node3.attributes.level,
      props: toSerialized(deserializeProps$1(fields, attrs, state2), fields)
    });
  }
  if (node3.type === "paragraph") {
    return createAndFill$1(node3, schema.nodes.paragraph, {});
  }
  if (node3.type === "comment") {
    return [];
  }
  if (node3.type === "document") {
    return createAndFill$1(node3, schema.nodes.doc, {});
  }
  if (node3.type === "fence") {
    if (!schema.nodes.code_block) return notAllowed$1(node3, parentType);
    let {
      language,
      content: content3,
      ...attrs
    } = node3.attributes;
    const state2 = getState$1();
    const fields = state2.schema.config.codeBlock.schema;
    content3 = content3.slice(0, -1);
    return schema.nodes.code_block.createAndFill({
      language: typeof node3.attributes.language === "string" ? node3.attributes.language : "",
      props: toSerialized(deserializeProps$1(fields, attrs, state2), fields)
    }, content3 ? schema.schema.text(content3) : void 0);
  }
  if (node3.type === "hr") {
    if (!schema.nodes.divider) return notAllowed$1(node3, parentType);
    return createAndFill$1(node3, schema.nodes.divider, {});
  }
  if (node3.type === "link") {
    var _schema$marks$link;
    return addMark$1(node3, (_schema$marks$link = schema.marks.link) === null || _schema$marks$link === void 0 ? void 0 : _schema$marks$link.create({
      href: node3.attributes.href
    }), parentType);
  }
  if (node3.type === "text") {
    return schema.schema.text(node3.attributes.content, getState$1().marks);
  }
  if (node3.type === "item") {
    if (!schema.nodes.list_item) return notAllowed$1(node3, parentType);
    return createAndFill$1(node3, schema.nodes.list_item, {}, wrapInParagraph$1(schema));
  }
  if (node3.type === "list") {
    const listType = node3.attributes.ordered ? schema.nodes.ordered_list : schema.nodes.unordered_list;
    if (!listType) return notAllowed$1(node3, parentType);
    return createAndFill$1(node3, listType, {});
  }
  if (node3.type === "table") {
    if (!schema.nodes.table) return notAllowed$1(node3, parentType);
    return createAndFill$1(node3, schema.nodes.table, {});
  }
  if (node3.type === "tbody" || node3.type === "thead") {
    return childrenToProseMirrorNodes$1(node3.children, parentType);
  }
  if (node3.type === "tr") {
    if (!schema.nodes.table_row) return notAllowed$1(node3, parentType);
    return createAndFill$1(node3, schema.nodes.table_row, {});
  }
  if (node3.type === "th") {
    if (!schema.nodes.table_header) return notAllowed$1(node3, parentType);
    return createAndFill$1(node3, schema.nodes.table_header, {}, wrapInParagraph$1(schema));
  }
  if (node3.type === "td") {
    if (!schema.nodes.table_cell) return notAllowed$1(node3, parentType);
    return createAndFill$1(node3, schema.nodes.table_cell, {}, wrapInParagraph$1(schema));
  }
  if (node3.type === "tag" && node3.tag) {
    if (node3.tag === "table") {
      return markdocNodeToProseMirrorNode$1(node3.children[0], parentType);
    }
    const componentConfig = schema.components[node3.tag];
    if (componentConfig) {
      const state2 = getState$1();
      const deserialized = deserializeProps$1(componentConfig.schema, node3.attributes, state2);
      if (componentConfig.kind === "mark") {
        return addMark$1(node3, schema.schema.marks[node3.tag].create({
          props: toSerialized(deserialized, componentConfig.schema)
        }), parentType);
      }
      const nodeType = schema.schema.nodes[node3.tag];
      const children = childrenToProseMirrorNodes$1(node3.children, nodeType);
      const pmNode = nodeType.createAndFill({
        props: toSerialized(deserialized, componentConfig.schema)
      }, children);
      if (!pmNode) {
        error$1({
          error: {
            id: "unexpected-children",
            level: "critical",
            message: `${node3.type} has unexpected children`
          },
          lines: node3.lines,
          type: node3.type,
          location: node3.location
        });
      }
      if (componentConfig.kind === "inline" && !(parentType !== null && parentType !== void 0 && parentType.isTextblock)) {
        return schema.nodes.paragraph.createAndFill({}, pmNode);
      }
      return pmNode;
    }
    error$1({
      error: {
        id: "unspecified-type",
        level: "critical",
        message: `Missing component definition for ${node3.tag}`
      },
      lines: node3.lines,
      type: node3.type,
      location: node3.location
    });
    return childrenToProseMirrorNodes$1(node3.children, parentType);
  }
  if (node3.type === "image") {
    var _ref, _node$attributes$titl;
    const prefix = getSrcPrefixForImageBlock(schema.config, getState$1().slug);
    const fullFilename = decodeURIComponent(node3.attributes.src);
    const filename = fullFilename.slice(prefix.length);
    const content3 = (_ref = typeof schema.config.image === "object" && typeof schema.config.image.directory === "string" ? getState$1().otherFiles.get(fixPath(schema.config.image.directory)) : getState$1().extraFiles) === null || _ref === void 0 ? void 0 : _ref.get(filename);
    if (content3 && schema.nodes.image) {
      return schema.nodes.image.createChecked({
        src: content3,
        alt: node3.attributes.alt,
        title: node3.attributes.title,
        filename
      });
    }
    return schema.schema.text(`![${node3.attributes.alt || ""}](${node3.attributes.src || ""}${(_node$attributes$titl = node3.attributes.title) !== null && _node$attributes$titl !== void 0 && _node$attributes$titl.length ? ` "${node3.attributes.title}"` : ""})`);
  }
  error$1({
    error: {
      id: "unhandled-type",
      level: "critical",
      message: `Unhandled type ${node3.type}`
    },
    lines: node3.lines,
    type: node3.type,
    location: node3.location
  });
  return null;
}
function markdocClipboard() {
  return new Plugin({
    props: {
      // TODO: for a doc like this:
      // <doc>
      //   <blockquote><paragraph>h<anchor/>ell</head>o</paragraph></blockquote>
      // </doc>
      // you shouldn't get the block quote
      clipboardTextSerializer(content3, view) {
        try {
          return format(proseMirrorToMarkdoc(view.state.doc.type.create({}, content3.content), {
            otherFiles: /* @__PURE__ */ new Map(),
            extraFiles: /* @__PURE__ */ new Map(),
            schema: getEditorSchema(view.state.schema),
            slug: void 0
          }));
        } catch (err) {
          console.log("failed to serialize clipboard text as markdoc", err);
          return content3.content.textBetween(0, content3.content.size, "\n\n");
        }
      },
      clipboardTextParser(text7, $context, plain, view) {
        try {
          return Slice.maxOpen(markdocToProseMirror(parse3(text7), getEditorSchema(view.state.schema), void 0, void 0, void 0).content);
        } catch (err) {
          console.log("failed to parse clipboard text as markdoc", err);
          return defaultClipboardTextParser(text7, $context, plain, view);
        }
      },
      handlePaste(view, event) {
        if (view.props.editable && !view.props.editable(view.state)) {
          return false;
        }
        if (!event.clipboardData) {
          return false;
        }
        const html2 = event.clipboardData.getData("text/html");
        if (html2 && isProbablyHtmlFromVscode(html2)) {
          const plain = event.clipboardData.getData("text/plain");
          view.pasteText(plain);
          return true;
        }
        return false;
      }
    }
  });
}
function isProbablyHtmlFromVscode(html2) {
  const parser2 = new globalThis.DOMParser();
  const parsed = parser2.parseFromString(html2, "text/html");
  const firstDiv = parsed.body.firstElementChild;
  if (parsed.body.childElementCount !== 1 || (firstDiv === null || firstDiv === void 0 ? void 0 : firstDiv.tagName) !== "DIV" || !(firstDiv instanceof HTMLElement) || !firstDiv.style.fontFamily.includes("monospace")) {
    return false;
  }
  for (const line of firstDiv.children) {
    if (line.tagName === "BR") continue;
    if (line.tagName !== "DIV") return false;
    for (const span of line.children) {
      if (span.tagName !== "SPAN") return false;
    }
  }
  return true;
}
function defaultClipboardTextParser(text7, $context, plain, view) {
  let marks = $context.marks();
  let {
    schema
  } = view.state, serializer = DOMSerializer.fromSchema(schema);
  let dom = document.createElement("div");
  text7.split(/(?:\r\n?|\n)+/).forEach((block4) => {
    let p = dom.appendChild(document.createElement("p"));
    if (block4) {
      p.appendChild(serializer.serializeNode(schema.text(block4, marks)));
    }
  });
  let parser2 = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
  return parser2.parseSlice(dom, {
    preserveWhitespace: true,
    context: $context,
    // @ts-expect-error
    ruleFromNode(dom2) {
      if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents2.test(dom2.parentNode.nodeName)) {
        return {
          ignore: true
        };
      }
      return null;
    }
  });
}
var inlineParents2 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function nodeInSelectionDecorations() {
  return new Plugin({
    props: {
      decorations(state2) {
        const decorations = [];
        let from2, to;
        if (state2.selection instanceof TextSelection) {
          ({
            from: from2,
            to
          } = state2.selection);
        }
        if (state2.selection instanceof AllSelection) {
          from2 = 0;
          to = state2.doc.content.size;
        }
        if (from2 !== void 0 && to !== void 0) {
          const _from = from2;
          const _to = to;
          state2.doc.nodesBetween(from2, to, (node3, pos) => {
            if (node3.isText) {
              return;
            }
            const nodeFrom = pos;
            const nodeTo = pos + node3.nodeSize;
            if (nodeFrom >= _from && nodeTo <= _to) {
              decorations.push(Decoration.node(pos, pos + node3.nodeSize, {
                class: classes.nodeInSelection
              }));
            }
          });
        }
        return DecorationSet.create(state2.doc, decorations);
      }
    }
  });
}
function placeholderPlugin(text7) {
  return new Plugin({
    props: {
      decorations(state2) {
        var _doc$firstChild;
        let doc4 = state2.doc;
        if (doc4.childCount === 1 && (_doc$firstChild = doc4.firstChild) !== null && _doc$firstChild !== void 0 && _doc$firstChild.isTextblock && doc4.firstChild.content.size === 0) {
          let placeholder = document.createElement("span");
          placeholder.className = classes.placeholder;
          placeholder.textContent = text7;
          return DecorationSet.create(doc4, [Decoration.widget(1, placeholder)]);
        }
      }
    }
  });
}
var cursorBuilder = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.style.borderColor = user.color;
  const userDiv = document.createElement("div");
  userDiv.style.backgroundColor = user.color;
  userDiv.insertBefore(document.createTextNode(user.name), null);
  cursor.insertBefore(userDiv, null);
  return cursor;
};
function createEditorState(doc4, selection, storedMarks, yXmlFragment, awareness) {
  const schema = getEditorSchema(doc4.type.schema);
  return EditorState.create({
    selection,
    storedMarks,
    plugins: [pasteLinks(schema), imageDropPlugin(schema), keydownHandler2(), ...yXmlFragment && awareness ? [ySyncPlugin(yXmlFragment), yCursorPlugin(awareness, {
      cursorBuilder,
      awarenessStateFilter(userClientId, clientId, awarenessState) {
        const localState = awareness.getLocalState();
        return userClientId !== clientId && awarenessState.location === (localState === null || localState === void 0 ? void 0 : localState.location) && awarenessState.branch === (localState === null || localState === void 0 ? void 0 : localState.branch);
      }
    }), yUndoPlugin()] : [history()], dropCursor({
      color: tokenSchema.color.alias.borderSelected,
      width: 2
    }), inputRules({
      rules: inputRulesForSchema(schema),
      enterRules: enterInputRulesForSchema(schema)
    }), gapCursor(), keymap(keymapForSchema(schema, !!(yXmlFragment && awareness))), markdocClipboard(), nodeInSelectionDecorations(), placeholderPlugin('Start writing or press "/" for commands…'), reactNodeViews(doc4.type.schema), autocompleteDecoration(), tableEditing(), tableCellMenuPlugin(), codeBlockSyntaxHighlighting()],
    doc: doc4
  });
}
var state;
function getState() {
  if (!state) {
    throw new Error("state not set");
  }
  return state;
}
function error2(message) {
  getState().errors.push(message);
}
function getSchema() {
  return getState().schema;
}
function withMark(mark, fn) {
  const state2 = getState();
  const oldMarks = state2.marks;
  state2.marks = mark.addToSet(state2.marks);
  try {
    return fn();
  } finally {
    state2.marks = oldMarks;
  }
}
function childrenToProseMirrorNodes(nodes, parentType) {
  const children = [];
  for (const node3 of nodes) {
    const pmNode = markdocNodeToProseMirrorNode(node3, parentType);
    if (pmNode) {
      if (Array.isArray(pmNode)) {
        children.push(...pmNode);
      } else {
        children.push(pmNode);
      }
    }
  }
  return children;
}
function notAllowed(node3, parentType) {
  error2(`${node3.type} is not allowed`);
  return childrenToProseMirrorNodes("children" in node3 ? node3.children : [], parentType);
}
function createAndFill(mdNode, nodeType, attrs, mapChildren2) {
  let children = childrenToProseMirrorNodes("children" in mdNode ? mdNode.children : [], nodeType);
  if (mapChildren2) {
    children = mapChildren2(children);
  }
  const node3 = nodeType.createAndFill(attrs, children);
  if (!node3) {
    error2(`${mdNode.type} has unexpected children`);
  }
  return node3;
}
function addMark2(node3, mark, parentType) {
  if (!mark) return notAllowed(node3, parentType);
  return withMark(mark instanceof MarkType ? mark.create() : mark, () => childrenToProseMirrorNodes("children" in node3 ? node3.children : [], parentType));
}
function mdxToProseMirror(node3, schema, files, otherFiles, slug) {
  state = {
    schema,
    errors: [],
    marks: [],
    extraFiles: files !== null && files !== void 0 ? files : /* @__PURE__ */ new Map(),
    otherFiles: otherFiles !== null && otherFiles !== void 0 ? otherFiles : /* @__PURE__ */ new Map(),
    slug,
    definitions: /* @__PURE__ */ new Map()
  };
  visit(node3, (node4) => {
    if (node4.type === "definition") {
      const id = String(node4.identifier).toUpperCase();
      if (!getState().definitions.has(id)) {
        getState().definitions.set(id, node4);
      }
    }
  });
  try {
    let pmNode = markdocNodeToProseMirrorNode(node3, void 0);
    if (state.errors.length) {
      throw new Error(state.errors.join("\n"));
    }
    if (!(pmNode instanceof Node4)) {
      throw new Error("unexpected node");
    }
    return pmNode;
  } finally {
    state = void 0;
  }
}
var wrapInParagraph = (schema) => (children) => {
  const newChildren = [];
  let inlineQueue = [];
  for (const child of children) {
    if (child.isInline) {
      inlineQueue.push(child);
      continue;
    }
    if (inlineQueue.length) {
      newChildren.push(schema.nodes.paragraph.createChecked({}, inlineQueue));
      inlineQueue = [];
    }
    newChildren.push(child);
  }
  if (inlineQueue.length) {
    newChildren.push(schema.nodes.paragraph.createChecked({}, inlineQueue));
  }
  return newChildren;
};
function programToValue(program) {
  assert(program.body.length === 1);
  const statement = program.body[0];
  assert(statement.type === "ExpressionStatement");
  return expressionToValue(statement.expression);
}
function expressionToValue(expression) {
  if (expression.type === "Literal") {
    const val = expression.value;
    assert(typeof val === "string" || typeof val === "number" || typeof val === "boolean" || val === null);
    return val;
  }
  if (expression.type === "ArrayExpression") {
    return expression.elements.map((value) => {
      assert(value !== null && value.type !== "SpreadElement");
      return expressionToValue(value);
    });
  }
  if (expression.type === "ObjectExpression") {
    return Object.fromEntries(expression.properties.map((property) => {
      assert(property.type === "Property" && !property.computed && property.kind === "init");
      const key3 = property.key;
      const name2 = key3.type === "Identifier" ? key3.name : key3.type === "Literal" ? key3.value : void 0;
      assert(typeof name2 === "string");
      return [name2, expressionToValue(property.value)];
    }));
  }
  throw new Error(`Unexpected expression type ${expression.type}`);
}
function markdocNodeToProseMirrorNode(node3, parentType) {
  const schema = getSchema();
  if (node3.type === "emphasis") {
    return addMark2(node3, schema.marks.italic, parentType);
  }
  if (node3.type === "inlineCode") {
    if (!schema.marks.code) return notAllowed(node3, parentType);
    return schema.schema.text(node3.value, [...getState().marks, schema.marks.code.create()]);
  }
  if (node3.type === "delete") {
    return addMark2(node3, schema.marks.strikethrough, parentType);
  }
  if (node3.type === "strong") {
    return addMark2(node3, schema.marks.bold, parentType);
  }
  if (node3.type === "break") {
    if (!schema.nodes.hard_break) return notAllowed(node3, parentType);
    return schema.nodes.hard_break.create();
  }
  if (node3.type === "blockquote") {
    if (!schema.nodes.blockquote) return notAllowed(node3, parentType);
    return createAndFill(node3, schema.nodes.blockquote, {});
  }
  if (node3.type === "heading") {
    if (!schema.nodes.heading) return notAllowed(node3, parentType);
    return createAndFill(node3, schema.nodes.heading, {
      level: node3.depth
    });
  }
  if (node3.type === "paragraph") {
    return createAndFill(node3, schema.nodes.paragraph, {});
  }
  if (node3.type === "root") {
    return createAndFill(node3, schema.nodes.doc, {});
  }
  if (node3.type === "code") {
    if (!schema.nodes.code_block) return notAllowed(node3, parentType);
    let language = typeof node3.lang === "string" ? node3.lang : "";
    if (node3.meta) {
      language += " " + node3.meta;
    }
    return schema.nodes.code_block.createAndFill({
      language
    }, schema.schema.text(node3.value));
  }
  if (node3.type === "thematicBreak") {
    if (!schema.nodes.divider) return notAllowed(node3, parentType);
    return createAndFill(node3, schema.nodes.divider, {});
  }
  if (node3.type === "link") {
    var _schema$marks$link;
    return addMark2(node3, (_schema$marks$link = schema.marks.link) === null || _schema$marks$link === void 0 ? void 0 : _schema$marks$link.create({
      href: node3.url
    }), parentType);
  }
  if (node3.type === "linkReference") {
    var _schema$marks$link2;
    const data2 = getState().definitions.get(node3.identifier.toUpperCase());
    if (!data2) {
      error2(`Could not find definition for ${node3.identifier}`);
      return childrenToProseMirrorNodes(node3.children, parentType);
    }
    return addMark2(node3, (_schema$marks$link2 = schema.marks.link) === null || _schema$marks$link2 === void 0 ? void 0 : _schema$marks$link2.create({
      href: data2.url
    }), parentType);
  }
  if (node3.type === "text") {
    return schema.schema.text(node3.value, getState().marks);
  }
  if (node3.type === "listItem") {
    if (!schema.nodes.list_item) return notAllowed(node3, parentType);
    return createAndFill(node3, schema.nodes.list_item, {}, wrapInParagraph(schema));
  }
  if (node3.type === "list") {
    const listType = node3.ordered ? schema.nodes.ordered_list : schema.nodes.unordered_list;
    if (!listType) return notAllowed(node3, parentType);
    return createAndFill(node3, listType, {});
  }
  if (node3.type === "table") {
    if (!schema.nodes.table) return notAllowed(node3, parentType);
    return createAndFill(node3, schema.nodes.table, {});
  }
  if (node3.type === "tableRow") {
    if (!schema.nodes.table_row) return notAllowed(node3, parentType);
    return createAndFill(node3, schema.nodes.table_row, {});
  }
  if (node3.type === "tableCell") {
    if (!schema.nodes.table_cell) return notAllowed(node3, parentType);
    return createAndFill(node3, schema.nodes.table_cell, {}, wrapInParagraph(schema));
  }
  if (node3.type === "mdxJsxFlowElement" || node3.type === "mdxJsxTextElement") {
    if (!node3.name) {
      return notAllowed(node3, parentType);
    }
    const componentConfig = schema.components[node3.name];
    if (componentConfig) {
      const state2 = getState();
      const attributes = {};
      for (const attribute of node3.attributes) {
        if (attribute.type === "mdxJsxAttribute") {
          if (attribute.value == null) {
            attributes[attribute.name] = true;
            continue;
          }
          try {
            attributes[attribute.name] = typeof attribute.value === "string" ? attribute.value : programToValue(attribute.value.data.estree);
          } catch {
            error2(`${node3.type} has unexpected attributes`);
          }
          continue;
        }
        error2(`${node3.type} has unexpected attributes`);
      }
      const deserialized = deserializeProps$1(componentConfig.schema, attributes, state2);
      if (componentConfig.kind === "mark") {
        if (node3.type === "mdxJsxFlowElement") {
          return notAllowed(node3, parentType);
        }
        return addMark2(node3, schema.schema.marks[node3.name].create({
          props: toSerialized(deserialized, componentConfig.schema)
        }), parentType);
      }
      const nodeType = schema.schema.nodes[node3.name];
      const pmNode = nodeType.createAndFill({
        props: toSerialized(deserialized, componentConfig.schema)
      }, childrenToProseMirrorNodes(node3.children, nodeType));
      if (!pmNode) {
        error2(`${node3.type} has unexpected children`);
      }
      if (componentConfig.kind === "inline" && !(parentType !== null && parentType !== void 0 && parentType.isTextblock)) {
        return schema.nodes.paragraph.createAndFill({}, pmNode);
      }
      return pmNode;
    }
    error2(`Missing component definition for ${node3.name}`);
    return childrenToProseMirrorNodes("children" in node3 ? node3.children : [], parentType);
  }
  if (node3.type === "image" || node3.type === "imageReference") {
    var _ref;
    const data2 = node3.type === "image" ? node3 : getState().definitions.get(node3.identifier.toUpperCase());
    if (!data2) {
      error2(`Could not find definition for ${node3.identifier}`);
      return null;
    }
    const prefix = getSrcPrefixForImageBlock(schema.config, getState().slug);
    const fullFilename = decodeURI(data2.url);
    const filename = fullFilename.slice(prefix.length);
    const content3 = (_ref = typeof schema.config.image === "object" && typeof schema.config.image.directory === "string" ? getState().otherFiles.get(fixPath(schema.config.image.directory)) : getState().extraFiles) === null || _ref === void 0 ? void 0 : _ref.get(filename);
    if (content3 && schema.nodes.image) {
      return schema.nodes.image.createChecked({
        src: content3,
        alt: node3.alt,
        title: data2.title,
        filename
      });
    }
    return schema.schema.text(`![${node3.alt || ""}](${data2.url || ""}${data2.title ? ` "${data2.title}"` : ""})`);
  }
  if (node3.type === "definition") return [];
  error2(`Unhandled type ${node3.type}: ${toMarkdown(node3, {
    extensions: [gfmToMarkdown(), mdxToMarkdown()],
    rule: "-"
  })}`);
  return null;
}
function _blocks(fragment, state2) {
  const children = [];
  fragment.forEach((child) => {
    children.push(proseMirrorToMDX(child, state2));
  });
  return children;
}
function _inline(fragment, state2) {
  return textblockChildren(fragment, (text7) => ({
    type: "text",
    value: text7
  }), (node3) => getLeafContent(node3, state2), (mark) => getWrapperForMark(mark, state2));
}
function propsToAttributes(props) {
  return Object.entries(props).map(([key3, value]) => ({
    type: "mdxJsxAttribute",
    name: key3,
    value: value === true ? null : typeof value === "string" ? value : {
      type: "mdxJsxAttributeValueExpression",
      value: JSON.stringify(value)
    }
  }));
}
function getLeafContent(node3, state2) {
  const {
    schema
  } = state2;
  if (node3.type === schema.nodes.hard_break) {
    return {
      type: "break"
    };
  }
  if (node3.type === schema.nodes.image) {
    const {
      src,
      filename
    } = node3.attrs;
    if (typeof state2.schema.config.image === "object" && typeof state2.schema.config.image.directory === "string") {
      const parent = fixPath(state2.schema.config.image.directory);
      if (!state2.otherFiles.has(parent)) {
        state2.otherFiles.set(parent, /* @__PURE__ */ new Map());
      }
      state2.otherFiles.get(parent).set(filename, src);
    } else {
      state2.extraFiles.set(filename, src);
    }
    return {
      type: "image",
      url: encodeURI(`${getSrcPrefixForImageBlock(state2.schema.config, state2.slug)}${node3.attrs.filename}`),
      alt: node3.attrs.alt,
      title: node3.attrs.title
    };
  }
  const componentConfig = state2.schema.components[node3.type.name];
  if ((componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.kind) === "inline") {
    return {
      type: "mdxJsxTextElement",
      name: node3.type.name,
      attributes: propsToAttributes(internalToSerialized(componentConfig.schema, node3.attrs.props, state2)),
      children: []
    };
  }
  if (node3.text !== void 0) {
    return {
      type: node3.marks.some((x) => x.type === schema.marks.code) ? "inlineCode" : "text",
      value: node3.text
    };
  }
}
function getWrapperForMark(mark, state2) {
  const {
    schema
  } = state2;
  if (mark.type === schema.marks.code) {
    return;
  }
  const componentConfig = schema.components[mark.type.name];
  if (componentConfig) {
    return {
      type: "mdxJsxTextElement",
      name: mark.type.name,
      attributes: propsToAttributes(internalToSerialized(componentConfig.schema, mark.attrs.props, state2)),
      children: []
    };
  }
  let type;
  if (mark.type === schema.marks.bold) {
    type = "strong";
  }
  if (mark.type === schema.marks.italic) {
    type = "emphasis";
  }
  if (mark.type === schema.marks.strikethrough) {
    type = "delete";
  }
  if (type) {
    return {
      type,
      children: []
    };
  }
  if (mark.type === schema.marks.link) {
    return {
      type: "link",
      url: mark.attrs.href,
      title: mark.attrs.title,
      children: []
    };
  }
}
function mapContent(node3, fn) {
  const result = [];
  node3.content.forEach((node4) => {
    result.push(fn(node4));
  });
  return result;
}
function convertListItem(listItemContent) {
  return {
    type: "listItem",
    children: listItemContent
  };
}
function proseMirrorToMDXRoot(node3, state2) {
  return {
    type: "root",
    children: _blocks(node3.content, state2)
  };
}
function proseMirrorToMDX(node3, state2) {
  const blocks = (fragment) => _blocks(fragment, state2);
  const inline7 = (fragment) => _inline(fragment, state2);
  const schema = getEditorSchema(node3.type.schema);
  if (node3.type === schema.nodes.paragraph) {
    return {
      type: "paragraph",
      children: inline7(node3.content)
    };
  }
  if (node3.type === schema.nodes.blockquote) {
    return {
      type: "blockquote",
      children: blocks(node3.content)
    };
  }
  if (node3.type === schema.nodes.divider) {
    return {
      type: "thematicBreak"
    };
  }
  if (node3.type === schema.nodes.table) {
    return {
      type: "table",
      children: mapContent(node3, (row) => {
        return {
          type: "tableRow",
          children: mapContent(row, (cell2) => {
            return {
              type: "tableCell",
              children: inline7(cell2.content.child(0).content)
            };
          })
        };
      })
    };
  }
  if (node3.type === schema.nodes.heading) {
    return {
      type: "heading",
      depth: node3.attrs.level,
      children: inline7(node3.content)
    };
  }
  if (node3.type === schema.nodes.code_block) {
    var _lang;
    let lang = typeof node3.attrs.language === "string" && node3.attrs.language !== "plain" ? node3.attrs.language : void 0;
    let meta = null;
    if ((_lang = lang) !== null && _lang !== void 0 && _lang.includes(" ")) {
      [lang, meta] = lang.split(" ", 2);
    }
    return {
      type: "code",
      lang,
      meta,
      value: node3.textContent
    };
  }
  if (node3.type === schema.nodes.ordered_list) {
    return {
      type: "list",
      ordered: true,
      children: mapContent(node3, (node4) => convertListItem(blocks(node4.content)))
    };
  }
  if (node3.type === schema.nodes.unordered_list) {
    return {
      type: "list",
      children: mapContent(node3, (node4) => convertListItem(blocks(node4.content)))
    };
  }
  const name2 = node3.type.name;
  const componentConfig = schema.components[name2];
  if (componentConfig) {
    const children = componentConfig.kind === "wrapper" || componentConfig.kind === "repeating" ? blocks(node3.content) : [];
    return {
      type: "mdxJsxFlowElement",
      name: name2,
      attributes: propsToAttributes(internalToSerialized(componentConfig.schema, node3.attrs.props, state2)),
      children
    };
  }
  return {
    type: "paragraph",
    children: inline7(node3.content)
  };
}
function getDefaultValue(schema) {
  return createEditorState(schema.nodes.doc.createAndFill());
}
var textDecoder$1 = new TextDecoder();
var textEncoder = new TextEncoder();
function parseToEditorState(content3, schema, files, otherFiles, slug) {
  const markdoc2 = textDecoder$1.decode(content3);
  const doc4 = markdocToProseMirror(parse3(markdoc2), schema, files, otherFiles, slug);
  return createEditorState(doc4);
}
function serializeFromEditorState(value, slug) {
  const other = /* @__PURE__ */ new Map();
  const external2 = /* @__PURE__ */ new Map();
  const markdocNode = proseMirrorToMarkdoc(value.doc, {
    extraFiles: other,
    otherFiles: external2,
    schema: getEditorSchema(value.schema),
    slug
  });
  const markdoc2 = format(markdocNode);
  return {
    content: textEncoder.encode(format(parse3(markdoc2))),
    other,
    external: external2
  };
}
function parseToEditorStateMDX(content3, schema, files, otherFiles, slug) {
  const mdx2 = textDecoder$1.decode(content3);
  const root2 = fromMarkdown(mdx2, {
    extensions: [mdxjs(), gfm()],
    mdastExtensions: [mdxFromMarkdown(), gfmFromMarkdown()]
  });
  const doc4 = mdxToProseMirror(root2, schema, files, otherFiles, slug);
  return createEditorState(doc4);
}
function serializeFromEditorStateMDX(value, slug) {
  const other = /* @__PURE__ */ new Map();
  const external2 = /* @__PURE__ */ new Map();
  const mdxNode = proseMirrorToMDXRoot(value.doc, {
    extraFiles: other,
    otherFiles: external2,
    schema: getEditorSchema(value.schema),
    slug
  });
  const mdx2 = toMarkdown(mdxNode, {
    extensions: [gfmToMarkdown(), mdxToMarkdown()],
    rule: "-"
  });
  return {
    content: textEncoder.encode(mdx2),
    other,
    external: external2
  };
}
function DocumentFieldInput(props) {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  let fieldProps = {
    label: props.label,
    labelElementType: "span",
    // the editor element isn't an input, so we need to use a span for the label
    description: props.description
  };
  if (entryLayoutPane === "main") {
    fieldProps = {
      "aria-label": props.label
      // `aria-description` is still in W3C Editor's Draft for ARIA 1.3.
    };
  }
  return (0, import_jsx_runtime70.jsx)(Field, {
    height: entryLayoutPane === "main" ? "100%" : void 0,
    ...fieldProps,
    children: (inputProps) => (0, import_jsx_runtime70.jsx)(Editor2, {
      ...inputProps,
      value: props.value,
      onChange: props.onChange
    })
  });
}
function createEditorStateFromYJS(schema, yXmlFragment, awareness) {
  return createEditorState(yXmlFragmentToProsemirror(schema.schema, yXmlFragment), void 0, void 0, yXmlFragment, awareness);
}
var defaultAltField = text({
  label: "Alt text",
  description: "This text will be used by screen readers and search engines."
});
var emptyTitleField = basicFormFieldWithSimpleReaderParse({
  Input() {
    return null;
  },
  defaultValue() {
    return "";
  },
  parse(value) {
    if (value === void 0) return "";
    if (typeof value !== "string") {
      throw new FieldDataError("Must be string");
    }
    return value;
  },
  validate(value) {
    return value;
  },
  serialize(value) {
    return {
      value
    };
  },
  label: "Title"
});
function editorOptionsToConfig(options) {
  var _options$bold, _options$italic, _options$strikethroug, _options$code, _options$blockquote, _options$orderedList, _options$unorderedLis, _options$table, _options$link, _options$divider;
  return {
    bold: (_options$bold = options.bold) !== null && _options$bold !== void 0 ? _options$bold : true,
    italic: (_options$italic = options.italic) !== null && _options$italic !== void 0 ? _options$italic : true,
    strikethrough: (_options$strikethroug = options.strikethrough) !== null && _options$strikethroug !== void 0 ? _options$strikethroug : true,
    code: (_options$code = options.code) !== null && _options$code !== void 0 ? _options$code : true,
    heading: (() => {
      let levels = [];
      let levelsOpt = typeof options.heading === "object" && !Array.isArray(options.heading) ? options.heading.levels : options.heading;
      if (levelsOpt === true || levelsOpt === void 0) {
        levels = [1, 2, 3, 4, 5, 6];
      }
      if (Array.isArray(levelsOpt)) {
        levels = levelsOpt;
      }
      return {
        levels,
        schema: options.heading && typeof options.heading === "object" && "schema" in options.heading ? options.heading.schema : {}
      };
    })(),
    blockquote: (_options$blockquote = options.blockquote) !== null && _options$blockquote !== void 0 ? _options$blockquote : true,
    orderedList: (_options$orderedList = options.orderedList) !== null && _options$orderedList !== void 0 ? _options$orderedList : true,
    unorderedList: (_options$unorderedLis = options.unorderedList) !== null && _options$unorderedLis !== void 0 ? _options$unorderedLis : true,
    table: (_options$table = options.table) !== null && _options$table !== void 0 ? _options$table : true,
    link: (_options$link = options.link) !== null && _options$link !== void 0 ? _options$link : true,
    image: options.image !== false ? ((_opts$schema$alt, _opts$schema, _opts$schema$title, _opts$schema2) => {
      const opts = options.image === true ? void 0 : options.image;
      return {
        directory: opts === null || opts === void 0 ? void 0 : opts.directory,
        publicPath: opts === null || opts === void 0 ? void 0 : opts.publicPath,
        schema: {
          alt: (_opts$schema$alt = opts === null || opts === void 0 || (_opts$schema = opts.schema) === null || _opts$schema === void 0 ? void 0 : _opts$schema.alt) !== null && _opts$schema$alt !== void 0 ? _opts$schema$alt : defaultAltField,
          title: (_opts$schema$title = opts === null || opts === void 0 || (_opts$schema2 = opts.schema) === null || _opts$schema2 === void 0 ? void 0 : _opts$schema2.title) !== null && _opts$schema$title !== void 0 ? _opts$schema$title : emptyTitleField
        }
      };
    })() : void 0,
    divider: (_options$divider = options.divider) !== null && _options$divider !== void 0 ? _options$divider : true,
    codeBlock: options.codeBlock === false ? void 0 : {
      schema: typeof options.codeBlock === "object" ? options.codeBlock.schema : {}
    }
  };
}
function getTypeForField(field) {
  if (field.kind === "object" || field.kind === "conditional") {
    return {
      type: Object,
      required: true
    };
  }
  if (field.kind === "array") {
    return {
      type: Array,
      required: true
    };
  }
  if (field.kind === "child") {
    return {};
  }
  if (field.formKind === void 0) {
    if (typeof field.defaultValue === "string" && "options" in field && Array.isArray(field.options) && field.options.every((val) => typeof val === "object" && val !== null && "value" in val && typeof val.value === "string")) {
      return {
        type: String,
        matches: field.options.map((x) => x.value),
        required: true
      };
    }
    if (typeof field.defaultValue === "string") {
      let required = false;
      try {
        field.parse("");
      } catch {
        required = true;
      }
      return {
        type: String,
        required
      };
    }
    try {
      field.parse(1);
      return {
        type: Number
      };
    } catch {
    }
    if (typeof field.defaultValue === "boolean") {
      return {
        type: Boolean,
        required: true
      };
    }
    return {};
  }
  if (field.formKind === "slug") {
    let required = false;
    try {
      field.parse("", void 0);
    } catch {
      required = true;
    }
    return {
      type: String,
      required
    };
  }
  if (field.formKind === "asset") {
    let required = false;
    try {
      field.validate(null);
    } catch {
      required = true;
    }
    return {
      type: String,
      required
    };
  }
  return {};
}
function fieldsToMarkdocAttributes(fields) {
  return Object.fromEntries(Object.entries(fields).map(([name2, field]) => {
    const schema = getTypeForField(field);
    return [name2, schema];
  }));
}
function createMarkdocConfig(opts) {
  const editorConfig = editorOptionsToConfig(opts.options || {});
  const config3 = {
    nodes: {
      ...schema_exports
    },
    tags: {}
  };
  if (editorConfig.heading.levels.length) {
    config3.nodes.heading = {
      ...schema_exports.heading,
      attributes: {
        ...schema_exports.heading.attributes,
        ...fieldsToMarkdocAttributes(editorConfig.heading.schema)
      }
    };
  } else {
    config3.nodes.heading = void 0;
  }
  if (!editorConfig.blockquote) {
    config3.nodes.blockquote = void 0;
  }
  if (editorConfig.codeBlock) {
    config3.nodes.fence = {
      ...schema_exports.fence,
      attributes: {
        ...schema_exports.fence.attributes,
        ...fieldsToMarkdocAttributes(editorConfig.codeBlock.schema)
      }
    };
  } else {
    config3.nodes.fence = void 0;
  }
  if (!editorConfig.orderedList && !editorConfig.unorderedList) {
    config3.nodes.list = void 0;
  }
  if (!editorConfig.bold) {
    config3.nodes.strong = void 0;
  }
  if (!editorConfig.italic) {
    config3.nodes.em = void 0;
  }
  if (!editorConfig.strikethrough) {
    config3.nodes.s = void 0;
  }
  if (!editorConfig.link) {
    config3.nodes.link = void 0;
  }
  if (!editorConfig.image) {
    config3.nodes.image = void 0;
  }
  if (!editorConfig.divider) {
    config3.nodes.hr = void 0;
  }
  if (!editorConfig.table) {
    config3.nodes.table = void 0;
  }
  for (const [name2, component] of Object.entries(opts.components || {})) {
    var _opts$render;
    const isEmpty = component.kind === "block" || component.kind === "inline";
    config3.tags[name2] = {
      render: (_opts$render = opts.render) === null || _opts$render === void 0 || (_opts$render = _opts$render.tags) === null || _opts$render === void 0 ? void 0 : _opts$render[name2],
      children: isEmpty ? [] : void 0,
      selfClosing: isEmpty,
      attributes: fieldsToMarkdocAttributes(component.schema),
      description: "description" in component ? component.description : void 0,
      inline: component.kind === "inline" || component.kind === "mark"
    };
  }
  for (const [name2, render3] of Object.entries(((_opts$render2 = opts.render) === null || _opts$render2 === void 0 ? void 0 : _opts$render2.nodes) || {})) {
    var _opts$render2;
    const nodeSchema = config3.nodes[name2];
    if (nodeSchema) {
      nodeSchema.render = render3;
    }
  }
  return config3;
}
var textDecoder = new TextDecoder();
function markdoc({
  label,
  description,
  options = {},
  components = {},
  extension: extension2 = "mdoc"
}) {
  let schema;
  const config3 = editorOptionsToConfig(options);
  let getSchema2 = () => {
    if (!schema) {
      schema = createEditorSchema(config3, components, false);
    }
    return schema;
  };
  return {
    kind: "form",
    formKind: "content",
    defaultValue() {
      return getDefaultValue(getSchema2());
    },
    Input(props) {
      return (0, import_jsx_runtime70.jsx)(DocumentFieldInput, {
        description,
        label,
        ...props
      });
    },
    parse: (_, {
      content: content3,
      other,
      external: external2,
      slug
    }) => {
      return parseToEditorState(content3, getSchema2(), other, external2, slug);
    },
    contentExtension: `.${extension2}`,
    validate(value) {
      return value;
    },
    directories: [...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(components).map(([name2, component]) => [name2, object(component.schema)])))), ...typeof config3.image === "object" && typeof config3.image.directory === "string" ? [fixPath(config3.image.directory)] : []],
    serialize(value, {
      slug
    }) {
      return {
        ...serializeFromEditorState(value, slug),
        value: void 0
      };
    },
    reader: {
      parse: (_, {
        content: content3
      }) => {
        const text7 = textDecoder.decode(content3);
        return {
          node: parse3(text7)
        };
      }
    },
    collaboration: {
      toYjs(value) {
        return prosemirrorToYXmlFragment(value.doc);
      },
      fromYjs(yjsValue, awareness) {
        return createEditorStateFromYJS(getSchema2(), yjsValue, awareness);
      }
    }
  };
}
markdoc.createMarkdocConfig = createMarkdocConfig;
function mdx({
  label,
  description,
  options = {},
  components = {},
  extension: extension2 = "mdx"
}) {
  let schema;
  const config3 = editorOptionsToConfig(options);
  let getSchema2 = () => {
    if (!schema) {
      schema = createEditorSchema(config3, components, true);
    }
    return schema;
  };
  return {
    kind: "form",
    formKind: "content",
    defaultValue() {
      return getDefaultValue(getSchema2());
    },
    Input(props) {
      return (0, import_jsx_runtime70.jsx)(DocumentFieldInput, {
        description,
        label,
        ...props
      });
    },
    parse: (_, {
      content: content3,
      other,
      external: external2,
      slug
    }) => {
      return parseToEditorStateMDX(content3, getSchema2(), other, external2, slug);
    },
    contentExtension: `.${extension2}`,
    validate(value) {
      return value;
    },
    directories: [...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(components).map(([name2, component]) => [name2, object(component.schema)])))), ...typeof config3.image === "object" && typeof config3.image.directory === "string" ? [fixPath(config3.image.directory)] : []],
    serialize(value, {
      slug
    }) {
      return {
        ...serializeFromEditorStateMDX(value, slug),
        value: void 0
      };
    },
    reader: {
      parse: (_, {
        content: content3
      }) => {
        const text7 = textDecoder.decode(content3);
        return text7;
      }
    },
    collaboration: {
      toYjs(value) {
        return prosemirrorToYXmlFragment(value.doc);
      },
      fromYjs(yjsValue, awareness) {
        return createEditorStateFromYJS(getSchema2(), yjsValue, awareness);
      }
    }
  };
}

// node_modules/@keystatic/core/dist/useSlugsInCollection-d43cad70.js
var import_react56 = __toESM(require_react(), 1);
function useSlugsInCollection(collection2) {
  const config3 = useConfig();
  const tree = useTree().current;
  return (0, import_react56.useMemo)(() => {
    const loadedTree = tree.kind === "loaded" ? tree.data.tree : /* @__PURE__ */ new Map();
    return getEntriesInCollectionWithTreeKey(config3, collection2, loadedTree).map((x) => x.slug);
  }, [config3, tree, collection2]);
}

export {
  githubIcon,
  require_lib,
  $c1d7fb2ec91bae71$export$6d08773d2e66f8f2,
  $7613b1592d41b092$export$6cd28814d92fa9c9,
  $c5a24bc478652b5f$export$1005530eda016c13,
  $c5a24bc478652b5f$export$fbdeaa6a76694f71,
  $c5a24bc478652b5f$export$5f3398f8733f90e2,
  $c5a24bc478652b5f$export$7475b2c64539e4cf,
  $7af3f5b51489e0b5$export$253fe78d46329472,
  $d496c0a20b6e58ec$export$6c8a5aaad13c9852,
  $fc0b13b484ac1194$export$1505db82fe357e65,
  $d1c300d9c497e402$export$de9feff04fda126e,
  $83c6e2eafa584c67$export$f6b86a04e5d66d90,
  $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf,
  $4159a7a9cbb0cc18$export$96357d5a73f686fa,
  $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c,
  $7cb39d07f245a780$export$70e2eed1a92976ad,
  $ce415dc67314b753$export$ed5fd5ffe5ab0ac,
  $44a6ee657928b002$export$5665e3d6be6adea,
  $ccf8a0a04e4175ae$export$6796df8ba7398521,
  $ccf8a0a04e4175ae$export$1481e64fbe01b8b3,
  $6d0a5c394373ae64$export$dd6d526d88b5a137,
  $a152112e902709bf$export$62444c3c724b1b20,
  Checkbox,
  _Menu,
  MenuTrigger,
  _Picker,
  chevronLeftIcon,
  chevronRightIcon,
  _ListView,
  SplitView,
  SplitPanePrimary,
  SplitPaneSecondary,
  Badge,
  gitPullRequestIcon,
  gitBranchPlusIcon,
  _Combobox,
  gitBranchIcon,
  externalLinkIcon,
  require_dist,
  _ActionGroup,
  _ActionBar,
  _ActionBarContainer,
  decimal_default,
  filter,
  refreshCwIcon,
  require_slugify,
  require_escape_string_regexp3 as require_escape_string_regexp,
  l10nMessages,
  config2 as config,
  collection,
  singleton,
  useNavItems,
  CreateBranchDialog,
  prettyErrorForCreateBranchMutation,
  useCreateBranchMutation,
  ThemeProvider,
  useTheme,
  BlockWrapper$1,
  ToolbarSeparator,
  showDraftRestoredToast,
  setDraft,
  delDraft,
  getDraft,
  useAssociatedPullRequest,
  useSidebar,
  SidebarProvider,
  SidebarPanel,
  SidebarDialog,
  PageRoot,
  PageHeader,
  PageBody,
  getKeysForArrayValue,
  setKeysForArrayValue,
  getNewArrayElementKey,
  getInitialPropsValue,
  getInitialPropsValueFromInitializer,
  updateValue,
  parseProps,
  toFormattedFormDataError,
  clientSideValidateProp,
  useFieldContext,
  createGetPreviewProps,
  valueToUpdater,
  move,
  useArrayFieldValidationMessage,
  ArrayFieldListView,
  containerWidthForEntryLayout,
  FormForEntry,
  isValidURL$1,
  getYjsValFromParsedValue,
  yjsToVal,
  parsedValToYjs,
  getUploadedFile,
  useObjectURL,
  ImageFieldInput,
  useIsInDocumentEditor,
  FormValueContentFromPreviewProps,
  getSrcPrefix,
  serializeProps$1,
  document$1,
  markdoc,
  mdx,
  useSlugsInCollection
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

match-sorter/dist/match-sorter.esm.js:
  (**
   * @name match-sorter
   * @license MIT license.
   * @copyright (c) 2020 Kent C. Dodds
   * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)
   *)

@keystatic/core/dist/index-cb6d8e27.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
//# sourceMappingURL=chunk-SM3PTJU5.js.map
