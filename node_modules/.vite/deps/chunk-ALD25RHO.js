import {
  $1cd244557c2f97d5$export$816b5d811295e6bc,
  $292bc4e09cd0eb62$export$cb895dcf85db1319,
  $2a25aae57d74318e$export$a05409b8bb224a5a,
  $312ae3b56a94a86e$export$f850895b287ef28e,
  $4159a7a9cbb0cc18$export$96357d5a73f686fa,
  $44a6ee657928b002$export$5665e3d6be6adea,
  $4a0dd036d492cee4$export$907bcc6c48325fd6,
  $4ae5314bf50db1a3$export$76ccd210b9029917,
  $60423f92c7f9ad87$export$c79fc6492f3af13d,
  $70d70eb16ea48428$export$b59bdbef9ce70de2,
  $7cb39d07f245a780$export$70e2eed1a92976ad,
  $83c6e2eafa584c67$export$f6b86a04e5d66d90,
  $941d1d9a6a28982a$export$f6f0c3fe4ec306ea,
  $a152112e902709bf$export$62444c3c724b1b20,
  $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c,
  $c1d7fb2ec91bae71$export$6d08773d2e66f8f2,
  $c5a24bc478652b5f$export$1005530eda016c13,
  $c5a24bc478652b5f$export$5f3398f8733f90e2,
  $c5a24bc478652b5f$export$7475b2c64539e4cf,
  $c5a24bc478652b5f$export$fbdeaa6a76694f71,
  $ccf8a0a04e4175ae$export$1481e64fbe01b8b3,
  $ccf8a0a04e4175ae$export$6796df8ba7398521,
  $ce415dc67314b753$export$ed5fd5ffe5ab0ac,
  $d1c300d9c497e402$export$de9feff04fda126e,
  $d7fd61009c21d0bb$export$7e0eeb9da702a085,
  $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf,
  $f4e2df6bd15f8569$export$1b00cb14a96194e6,
  $fc0b13b484ac1194$export$1505db82fe357e65,
  Badge,
  Checkbox,
  CreateBranchDialog,
  FormForEntry,
  MenuTrigger,
  PageBody,
  PageHeader,
  PageRoot,
  SidebarDialog,
  SidebarPanel,
  SidebarProvider,
  SplitPanePrimary,
  SplitPaneSecondary,
  SplitView,
  ThemeProvider,
  _ActionGroup,
  _Menu,
  chevronLeftIcon,
  chevronRightIcon,
  clientSideValidateProp,
  containerWidthForEntryLayout,
  createGetPreviewProps,
  externalLinkIcon,
  getInitialPropsValue,
  getInitialPropsValueFromInitializer,
  getKeysForArrayValue,
  getNewArrayElementKey,
  gitBranchIcon,
  gitBranchPlusIcon,
  gitPullRequestIcon,
  githubIcon,
  gripVerticalIcon,
  parseProps,
  pluralize,
  prettyErrorForCreateBranchMutation,
  require_dist as require_dist2,
  require_escape_string_regexp,
  require_lib,
  require_slugify,
  serializeProps$1,
  setKeysForArrayValue,
  setValueToPreviewProps,
  strings,
  toFormattedFormDataError,
  updateValue,
  useAssociatedPullRequest,
  useCreateBranchMutation,
  useNavItems,
  useSidebar,
  useSlugsInCollection,
  useTheme
} from "./chunk-GMJMW362.js";
import {
  $18f2051aff69b9bf$export$43bb16f9c6d9e3f7,
  $1dbecbe27a04f9af$export$14d238f342723f25,
  $26f7f3da73fcd9d6$export$7717c92ee915373e,
  $298d61e98472621b$export$dcf14c9974fe2767,
  $2d73ec29415bd339$export$712718f7aec83d5,
  $2f04cbc44ee30ce0$export$53a0910f038337bd,
  $2f04cbc44ee30ce0$export$c826860796309d1b,
  $319e236875307eab$export$a9b970dcc4ae71a9,
  $325a3faab7a68acd$export$a16aca283550c30d,
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $458b0a5536c1a7cf$export$40bfa8c7b0832715,
  $46d819fcbaf35654$export$8f71654801c2f7cd,
  $4f58c5f72bcf79f7$export$496315a1608d9602,
  $507fabe10e71c6fb$export$630ff653c5ada6a9,
  $507fabe10e71c6fb$export$98e20ec92f614cfe,
  $5c3e21d68f1c4674$export$439d29a4e110a164,
  $5c3e21d68f1c4674$export$a966af930f325cab,
  $6179b936705e76d3$export$ae780daf29e6d456,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f,
  $6a99195332edec8b$export$80f3e147d781571c,
  $701a24aa0da5b062$export$ea18c227d4417cc3,
  $8ae05eaa5c114e9c$export$7f54fc3180508a52,
  $907718708eab68af$export$1a38b4ad7f578e1d,
  $96b38030c423d352$export$574e9b0fb070c3b0,
  $9bf71ea28793e738$export$20e40289641fbbb6,
  $9daab02d461809db$export$683480f191c0e3ea,
  $bdb11010cef70236$export$b4cc09c592e8fdb8,
  $bdb11010cef70236$export$f680877a34711e37,
  $c87311424ea30a05$export$a11b0059900ceec8,
  $df56164dff5785e2$export$4338b53315abf666,
  $e6afbd83fe6ebbd2$export$4c014de7c8940b4c,
  $e8a7022cf87cba2a$export$36da96379f79f245,
  $ea8dcbcb9ea1b556$export$bdc77b0c0a3a85d6,
  $ef06256079686ba0$export$f8aeda7b10753fa1,
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c,
  $f6c31cce2adf654f$export$45712eceda6fad21,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  $fca6afa0e843324b$export$f12b703ca79dfbb1,
  $ff5963eb1fccf552$export$e08e3b67e392101e,
  AbstractType,
  ActionButton,
  AlertDialog,
  AppShellErrorContext,
  AppStateContext,
  Avatar,
  Box,
  Button,
  ButtonGroup,
  ClassList,
  ClearButton,
  ClientSideOnlyDocumentElement,
  CloudAppShellQuery,
  CloudInfoProvider,
  ConfigContext,
  Content,
  ContentPanelProvider,
  Dialog,
  DialogContainer,
  Divider,
  Doc,
  Flex,
  FocusRing,
  GitHubAppShellDataContext,
  GitHubAppShellDataProvider,
  GitHubAppShellProvider,
  GitHubAppShellQuery,
  Grid,
  HStack,
  Heading,
  Icon,
  InsertionIndicatorPrimitive,
  KEYSTATIC_CLOUD_API_URL,
  KEYSTATIC_CLOUD_HEADERS,
  KeystarProvider,
  LOADING,
  LRUCache,
  LocalAppShellProvider,
  ProgressCircle,
  Q,
  RouterProvider,
  SlotProvider,
  Text,
  TextField,
  TextFieldPrimitive,
  TextLink,
  Toaster,
  Tooltip,
  VStack,
  YArray,
  YMap,
  _DialogTrigger,
  _TooltipTrigger,
  alertTriangleIcon,
  assert,
  assertNever,
  assertValidRepoConfig,
  blobSha,
  breakpointQueries$1,
  c,
  c2,
  checkCircle2Icon,
  classNames,
  containerQueries,
  createRequest,
  css,
  delDraft,
  e,
  empty,
  f,
  fetchExchange,
  fetchGitHubTreeData,
  filter,
  formatDocument,
  fromPromise,
  getAuth,
  getBlobFromPersistedCache,
  getBranchPrefix,
  getCollection,
  getCollectionFormat,
  getCollectionItemPath,
  getCollectionPath,
  getDataFileExtension,
  getDirectoriesForTreeKey,
  getDraft,
  getEntriesInCollectionWithTreeKey,
  getEntryDataFilepath,
  getPathPrefix,
  getRepoUrl,
  getSingletonFormat,
  getSingletonPath,
  getSlugFromState,
  getSlugGlobForCollection,
  getSyncAuth,
  getTreeKey,
  getTreeNodeAtPath,
  hydrateTreeCacheWithEntries,
  infoIcon,
  injectGlobal,
  isCloudConfig,
  isGitHubConfig,
  isLocalConfig,
  isReactText,
  lib_default,
  makeErrorResult,
  makeOperation,
  makeSubject,
  map as map2,
  merge,
  mergeMap,
  minmax,
  object as object2,
  onStart,
  parseRepoConfig,
  plusIcon,
  r,
  redirectToCloudAuth,
  scopeEntriesWithPathPrefix,
  serializeRepoConfig,
  setBlobToPersistedCache,
  setDraft,
  share,
  stringifyDocument,
  stringifyVariables,
  suspendOnData,
  take,
  takeUntil,
  toDataAttributes,
  toPromise,
  toastQueue,
  tokenSchema,
  transition,
  trash2Icon,
  treeSha,
  updateTreeWithChanges,
  useAwarenessStates,
  useBaseCommit,
  useBranches,
  useClient,
  useCloudInfo,
  useConfig,
  useContentPanelState,
  useCurrentBranch,
  useCurrentUnscopedTree,
  useData,
  useEventCallback,
  useHasChild,
  useMediaQuery,
  useMutation,
  useProviderProps,
  useRepoInfo,
  useRouter,
  useSetTreeSha,
  useShowRestoredDraftMessage,
  useStyleProps,
  useTree,
  useViewer,
  useYjs,
  useYjsIfAvailable,
  valueFromASTUntyped
} from "./chunk-Q6OFX6VE.js";
import {
  base64Encode,
  base64UrlDecode,
  base64UrlEncode,
  coerce,
  date,
  instance,
  literal,
  map,
  number,
  object,
  optional,
  record,
  require_dist,
  string,
  type
} from "./chunk-KBCZ6HQX.js";
import {
  require_jsx_runtime
} from "./chunk-QRIEPQWS.js";
import {
  require_react_dom
} from "./chunk-XQLYTHWV.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __require,
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b2) {
      if (a === b2) return true;
      if (a && b2 && typeof a == "object" && typeof b2 == "object") {
        if (a.constructor !== b2.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b2.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b2[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b2.source && a.flags === b2.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b2.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b2.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b2).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b2[key])) return false;
        }
        return true;
      }
      return a !== a && b2 !== b2;
    };
  }
});

// node_modules/@keystatic/core/dist/keystatic-core-ui.js
var import_react8 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-fileX2Icon.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var fileX2Icon = (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
  children: [(0, import_jsx_runtime.jsx)("path", {
    d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"
  }), (0, import_jsx_runtime.jsx)("path", {
    d: "M14 2v4a2 2 0 0 0 2 2h4M8 12.5l-5 5M3 12.5l5 5"
  })]
});

// node_modules/@keystatic/core/dist/keystatic-core-ui.js
var import_is_hotkey = __toESM(require_lib());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alertCircleIcon.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var alertCircleIcon = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
  children: [(0, import_jsx_runtime2.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 10
  }), (0, import_jsx_runtime2.jsx)("path", {
    d: "M12 8v4M12 16h.01"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-listXIcon.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var listXIcon = (0, import_jsx_runtime3.jsx)("path", {
  d: "M11 12H3M16 6H3M16 18H3M19 10l-4 4M15 10l4 4"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-searchIcon.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var searchIcon = (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, {
  children: [(0, import_jsx_runtime4.jsx)("circle", {
    cx: 11,
    cy: 11,
    r: 8
  }), (0, import_jsx_runtime4.jsx)("path", {
    d: "m21 21-4.3-4.3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-searchXIcon.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var searchXIcon = (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, {
  children: [(0, import_jsx_runtime5.jsx)("path", {
    d: "m13.5 8.5-5 5M8.5 8.5l5 5"
  }), (0, import_jsx_runtime5.jsx)("circle", {
    cx: 11,
    cy: 11,
    r: 8
  }), (0, import_jsx_runtime5.jsx)("path", {
    d: "m21 21-4.3-4.3"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-diffIcon.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var diffIcon = (0, import_jsx_runtime6.jsx)("path", {
  d: "M12 3v14M5 10h14M5 21h14"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-plusSquareIcon.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var plusSquareIcon = (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, {
  children: [(0, import_jsx_runtime7.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime7.jsx)("path", {
    d: "M8 12h8M12 8v8"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-dotSquareIcon.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var dotSquareIcon = (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, {
  children: [(0, import_jsx_runtime8.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime8.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 1
  })]
});

// node_modules/@react-aria/searchfield/dist/ar-AE.mjs
var $03c9a1a10de12f06$exports = {};
$03c9a1a10de12f06$exports = {
  "Clear search": `مسح البحث`
};

// node_modules/@react-aria/searchfield/dist/bg-BG.mjs
var $4da0c2ffa4ba4159$exports = {};
$4da0c2ffa4ba4159$exports = {
  "Clear search": `Изчистване на търсене`
};

// node_modules/@react-aria/searchfield/dist/cs-CZ.mjs
var $8c59fd0c2c96821b$exports = {};
$8c59fd0c2c96821b$exports = {
  "Clear search": `Vymazat hledání`
};

// node_modules/@react-aria/searchfield/dist/da-DK.mjs
var $0a371f9c1df8120f$exports = {};
$0a371f9c1df8120f$exports = {
  "Clear search": `Ryd søgning`
};

// node_modules/@react-aria/searchfield/dist/de-DE.mjs
var $67f4d0b0de9f8a52$exports = {};
$67f4d0b0de9f8a52$exports = {
  "Clear search": `Suche zurücksetzen`
};

// node_modules/@react-aria/searchfield/dist/el-GR.mjs
var $72a312d948f0214b$exports = {};
$72a312d948f0214b$exports = {
  "Clear search": `Απαλοιφή αναζήτησης`
};

// node_modules/@react-aria/searchfield/dist/en-US.mjs
var $5012d21d933388c1$exports = {};
$5012d21d933388c1$exports = {
  "Clear search": `Clear search`
};

// node_modules/@react-aria/searchfield/dist/es-ES.mjs
var $0159854399308e2e$exports = {};
$0159854399308e2e$exports = {
  "Clear search": `Borrar búsqueda`
};

// node_modules/@react-aria/searchfield/dist/et-EE.mjs
var $390613981d970276$exports = {};
$390613981d970276$exports = {
  "Clear search": `Tühjenda otsing`
};

// node_modules/@react-aria/searchfield/dist/fi-FI.mjs
var $961ae0833f811705$exports = {};
$961ae0833f811705$exports = {
  "Clear search": `Tyhjennä haku`
};

// node_modules/@react-aria/searchfield/dist/fr-FR.mjs
var $26d76742decfd829$exports = {};
$26d76742decfd829$exports = {
  "Clear search": `Effacer la recherche`
};

// node_modules/@react-aria/searchfield/dist/he-IL.mjs
var $92ef254c82a5c769$exports = {};
$92ef254c82a5c769$exports = {
  "Clear search": `נקה חיפוש`
};

// node_modules/@react-aria/searchfield/dist/hr-HR.mjs
var $e0321b43bdefb8b3$exports = {};
$e0321b43bdefb8b3$exports = {
  "Clear search": `Obriši pretragu`
};

// node_modules/@react-aria/searchfield/dist/hu-HU.mjs
var $0c1ee0b8d50940d9$exports = {};
$0c1ee0b8d50940d9$exports = {
  "Clear search": `Keresés törlése`
};

// node_modules/@react-aria/searchfield/dist/it-IT.mjs
var $b09198915a38946f$exports = {};
$b09198915a38946f$exports = {
  "Clear search": `Cancella ricerca`
};

// node_modules/@react-aria/searchfield/dist/ja-JP.mjs
var $3a9a3d180c3145c0$exports = {};
$3a9a3d180c3145c0$exports = {
  "Clear search": `検索をクリア`
};

// node_modules/@react-aria/searchfield/dist/ko-KR.mjs
var $b7a611726449f4a3$exports = {};
$b7a611726449f4a3$exports = {
  "Clear search": `검색 지우기`
};

// node_modules/@react-aria/searchfield/dist/lt-LT.mjs
var $d9a3d49db610dd5c$exports = {};
$d9a3d49db610dd5c$exports = {
  "Clear search": `Išvalyti iešką`
};

// node_modules/@react-aria/searchfield/dist/lv-LV.mjs
var $3ab64b73ea27c23a$exports = {};
$3ab64b73ea27c23a$exports = {
  "Clear search": `Notīrīt meklēšanu`
};

// node_modules/@react-aria/searchfield/dist/nb-NO.mjs
var $bf5cce1b47d23baf$exports = {};
$bf5cce1b47d23baf$exports = {
  "Clear search": `Tøm søk`
};

// node_modules/@react-aria/searchfield/dist/nl-NL.mjs
var $4e0c9a9a010e4598$exports = {};
$4e0c9a9a010e4598$exports = {
  "Clear search": `Zoekactie wissen`
};

// node_modules/@react-aria/searchfield/dist/pl-PL.mjs
var $63cf4a75ec270508$exports = {};
$63cf4a75ec270508$exports = {
  "Clear search": `Wyczyść zawartość wyszukiwania`
};

// node_modules/@react-aria/searchfield/dist/pt-BR.mjs
var $083b0cad27fdbd06$exports = {};
$083b0cad27fdbd06$exports = {
  "Clear search": `Limpar pesquisa`
};

// node_modules/@react-aria/searchfield/dist/pt-PT.mjs
var $1b7f0864d830ba6d$exports = {};
$1b7f0864d830ba6d$exports = {
  "Clear search": `Limpar pesquisa`
};

// node_modules/@react-aria/searchfield/dist/ro-RO.mjs
var $d6d2588377fc9718$exports = {};
$d6d2588377fc9718$exports = {
  "Clear search": `Ştergeţi căutarea`
};

// node_modules/@react-aria/searchfield/dist/ru-RU.mjs
var $701c918a4653e946$exports = {};
$701c918a4653e946$exports = {
  "Clear search": `Очистить поиск`
};

// node_modules/@react-aria/searchfield/dist/sk-SK.mjs
var $7cacc29a1e5f4fbe$exports = {};
$7cacc29a1e5f4fbe$exports = {
  "Clear search": `Vymazať vyhľadávanie`
};

// node_modules/@react-aria/searchfield/dist/sl-SI.mjs
var $c63231bcc300d0df$exports = {};
$c63231bcc300d0df$exports = {
  "Clear search": `Počisti iskanje`
};

// node_modules/@react-aria/searchfield/dist/sr-SP.mjs
var $b61510478bc0e6f6$exports = {};
$b61510478bc0e6f6$exports = {
  "Clear search": `Obriši pretragu`
};

// node_modules/@react-aria/searchfield/dist/sv-SE.mjs
var $ce325e6dd3f9c37a$exports = {};
$ce325e6dd3f9c37a$exports = {
  "Clear search": `Rensa sökning`
};

// node_modules/@react-aria/searchfield/dist/tr-TR.mjs
var $1f7e1cf2285af2b2$exports = {};
$1f7e1cf2285af2b2$exports = {
  "Clear search": `Aramayı temizle`
};

// node_modules/@react-aria/searchfield/dist/uk-UA.mjs
var $2d999353ca652e34$exports = {};
$2d999353ca652e34$exports = {
  "Clear search": `Очистити пошук`
};

// node_modules/@react-aria/searchfield/dist/zh-CN.mjs
var $117b536bfb1ae554$exports = {};
$117b536bfb1ae554$exports = {
  "Clear search": `清除搜索`
};

// node_modules/@react-aria/searchfield/dist/zh-TW.mjs
var $525f6fa4ac26e278$exports = {};
$525f6fa4ac26e278$exports = {
  "Clear search": `清除搜尋條件`
};

// node_modules/@react-aria/searchfield/dist/intlStrings.mjs
var $8112f8b883c0272d$exports = {};
$8112f8b883c0272d$exports = {
  "ar-AE": $03c9a1a10de12f06$exports,
  "bg-BG": $4da0c2ffa4ba4159$exports,
  "cs-CZ": $8c59fd0c2c96821b$exports,
  "da-DK": $0a371f9c1df8120f$exports,
  "de-DE": $67f4d0b0de9f8a52$exports,
  "el-GR": $72a312d948f0214b$exports,
  "en-US": $5012d21d933388c1$exports,
  "es-ES": $0159854399308e2e$exports,
  "et-EE": $390613981d970276$exports,
  "fi-FI": $961ae0833f811705$exports,
  "fr-FR": $26d76742decfd829$exports,
  "he-IL": $92ef254c82a5c769$exports,
  "hr-HR": $e0321b43bdefb8b3$exports,
  "hu-HU": $0c1ee0b8d50940d9$exports,
  "it-IT": $b09198915a38946f$exports,
  "ja-JP": $3a9a3d180c3145c0$exports,
  "ko-KR": $b7a611726449f4a3$exports,
  "lt-LT": $d9a3d49db610dd5c$exports,
  "lv-LV": $3ab64b73ea27c23a$exports,
  "nb-NO": $bf5cce1b47d23baf$exports,
  "nl-NL": $4e0c9a9a010e4598$exports,
  "pl-PL": $63cf4a75ec270508$exports,
  "pt-BR": $083b0cad27fdbd06$exports,
  "pt-PT": $1b7f0864d830ba6d$exports,
  "ro-RO": $d6d2588377fc9718$exports,
  "ru-RU": $701c918a4653e946$exports,
  "sk-SK": $7cacc29a1e5f4fbe$exports,
  "sl-SI": $c63231bcc300d0df$exports,
  "sr-SP": $b61510478bc0e6f6$exports,
  "sv-SE": $ce325e6dd3f9c37a$exports,
  "tr-TR": $1f7e1cf2285af2b2$exports,
  "uk-UA": $2d999353ca652e34$exports,
  "zh-CN": $117b536bfb1ae554$exports,
  "zh-TW": $525f6fa4ac26e278$exports
};

// node_modules/@react-aria/searchfield/dist/useSearchField.mjs
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $4d52238874b24f86$export$9bb30bbe003b82e0(props, state, inputRef) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault($8112f8b883c0272d$exports)), "@react-aria/searchfield");
  let { isDisabled, isReadOnly, onSubmit, onClear, type: type3 = "search" } = props;
  let onKeyDown = (e2) => {
    const key = e2.key;
    if (key === "Enter" && (isDisabled || isReadOnly)) e2.preventDefault();
    if (isDisabled || isReadOnly) return;
    if (key === "Enter" && onSubmit) {
      e2.preventDefault();
      onSubmit(state.value);
    }
    if (key === "Escape") {
      if (state.value === "") e2.continuePropagation();
      else {
        state.setValue("");
        if (onClear) onClear();
      }
    }
  };
  let onClearButtonClick = () => {
    state.setValue("");
    if (onClear) onClear();
  };
  let onPressStart = () => {
    var _inputRef_current;
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
  };
  let { labelProps, inputProps, descriptionProps, errorMessageProps, ...validation } = (0, $2d73ec29415bd339$export$712718f7aec83d5)({
    ...props,
    value: state.value,
    onChange: state.setValue,
    onKeyDown: !isReadOnly ? (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(onKeyDown, props.onKeyDown) : props.onKeyDown,
    type: type3
  }, inputRef);
  return {
    labelProps,
    inputProps: {
      ...inputProps,
      // already handled by useSearchFieldState
      defaultValue: void 0
    },
    clearButtonProps: {
      "aria-label": stringFormatter.format("Clear search"),
      excludeFromTabOrder: true,
      preventFocusOnPress: true,
      isDisabled: isDisabled || isReadOnly,
      onPress: onClearButtonClick,
      onPressStart
    },
    descriptionProps,
    errorMessageProps,
    ...validation
  };
}

// node_modules/@react-stately/searchfield/dist/useSearchFieldState.mjs
function $0b2218c4e3fe7d7e$export$3f8be18b0f41eaf2(props) {
  let [value, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)($0b2218c4e3fe7d7e$var$toString(props.value), $0b2218c4e3fe7d7e$var$toString(props.defaultValue) || "", props.onChange);
  return {
    value,
    setValue
  };
}
function $0b2218c4e3fe7d7e$var$toString(val) {
  if (val == null) return;
  return val.toString();
}

// node_modules/@keystar/ui/dist/keystar-ui-search-field.js
var import_react = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var SearchField = (0, import_react.forwardRef)(function SearchField2(props, forwardedRef) {
  const $ = c2(30);
  let t0;
  let isDisabled;
  let styleProps;
  let isReadOnly;
  let isRequired;
  let label;
  let description;
  let errorMessage;
  if ($[0] !== props) {
    const {
      autoFocus,
      description: t12,
      errorMessage: t22,
      id,
      isDisabled: t32,
      isReadOnly: t42,
      isRequired: t52,
      label: t62,
      showIcon: t72,
      ...t8
    } = props;
    description = t12;
    errorMessage = t22;
    isDisabled = t32;
    isReadOnly = t42;
    isRequired = t52;
    label = t62;
    t0 = t72;
    styleProps = t8;
    $[0] = props;
    $[1] = t0;
    $[2] = isDisabled;
    $[3] = styleProps;
    $[4] = isReadOnly;
    $[5] = isRequired;
    $[6] = label;
    $[7] = description;
    $[8] = errorMessage;
  } else {
    t0 = $[1];
    isDisabled = $[2];
    styleProps = $[3];
    isReadOnly = $[4];
    isRequired = $[5];
    label = $[6];
    description = $[7];
    errorMessage = $[8];
  }
  const showIcon = t0 === void 0 ? true : t0;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const state = $0b2218c4e3fe7d7e$export$3f8be18b0f41eaf2(props);
  const {
    labelProps,
    inputProps,
    clearButtonProps,
    descriptionProps,
    errorMessageProps
  } = $4d52238874b24f86$export$9bb30bbe003b82e0(props, state, domRef);
  const clearButtonVisible = state.value !== "" && !props.isReadOnly;
  let t1;
  if ($[9] !== clearButtonProps || $[10] !== isDisabled) {
    t1 = (0, import_jsx_runtime9.jsx)(ClearButton, {
      ...clearButtonProps,
      preventFocus: true,
      isDisabled
    });
    $[9] = clearButtonProps;
    $[10] = isDisabled;
    $[11] = t1;
  } else {
    t1 = $[11];
  }
  const clearButton = t1;
  const t2 = props.isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary";
  let t3;
  if ($[12] !== t2) {
    t3 = (0, import_jsx_runtime9.jsx)(Flex, {
      alignItems: "center",
      flexShrink: 0,
      justifyContent: "center",
      pointerEvents: "none",
      width: "element.regular",
      children: (0, import_jsx_runtime9.jsx)(Icon, {
        src: searchIcon,
        color: t2
      })
    });
    $[12] = t2;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  const startElement = t3;
  let t4;
  if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      className: css({
        input: {
          '&[data-adornment="start"]': {
            paddingInlineStart: 0
          },
          '&[data-adornment="end"]': {
            paddingInlineEnd: 0
          },
          '&[data-adornment="both"]': {
            paddingInline: 0
          }
        }
      })
    };
    $[14] = t4;
  } else {
    t4 = $[14];
  }
  const t5 = showIcon && startElement;
  const t6 = clearButtonVisible && clearButton;
  let t7;
  if ($[15] !== domRef || $[16] !== styleProps || $[17] !== isDisabled || $[18] !== isReadOnly || $[19] !== isRequired || $[20] !== label || $[21] !== labelProps || $[22] !== inputProps || $[23] !== description || $[24] !== descriptionProps || $[25] !== errorMessage || $[26] !== errorMessageProps || $[27] !== t5 || $[28] !== t6) {
    t7 = (0, import_jsx_runtime9.jsx)(TextFieldPrimitive, {
      ref: domRef,
      ...styleProps,
      isDisabled,
      isReadOnly,
      isRequired,
      label,
      labelProps,
      inputProps,
      inputWrapperProps: t4,
      description,
      descriptionProps,
      errorMessage,
      errorMessageProps,
      startElement: t5,
      endElement: t6
    });
    $[15] = domRef;
    $[16] = styleProps;
    $[17] = isDisabled;
    $[18] = isReadOnly;
    $[19] = isRequired;
    $[20] = label;
    $[21] = labelProps;
    $[22] = inputProps;
    $[23] = description;
    $[24] = descriptionProps;
    $[25] = errorMessage;
    $[26] = errorMessageProps;
    $[27] = t5;
    $[28] = t6;
    $[29] = t7;
  } else {
    t7 = $[29];
  }
  return t7;
});

// node_modules/@keystar/ui/dist/keystar-ui-table.js
var import_react5 = __toESM(require_react());

// node_modules/@react-aria/table/dist/utils.mjs
var $2140fb2337097f2d$export$552312adfd451dab = /* @__PURE__ */ new WeakMap();
function $2140fb2337097f2d$var$normalizeKey(key) {
  if (typeof key === "string") return key.replace(/\s*/g, "");
  return "" + key;
}
function $2140fb2337097f2d$export$37cd4213f2ad742e(state, columnKey) {
  let gridId = $2140fb2337097f2d$export$552312adfd451dab.get(state);
  if (!gridId) throw new Error("Unknown grid");
  return `${gridId}-${$2140fb2337097f2d$var$normalizeKey(columnKey)}`;
}
function $2140fb2337097f2d$export$19baff3266315d44(state, rowKey, columnKey) {
  let gridId = $2140fb2337097f2d$export$552312adfd451dab.get(state);
  if (!gridId) throw new Error("Unknown grid");
  return `${gridId}-${$2140fb2337097f2d$var$normalizeKey(rowKey)}-${$2140fb2337097f2d$var$normalizeKey(columnKey)}`;
}
function $2140fb2337097f2d$export$85069b70317f543(state, rowKey) {
  return [
    ...state.collection.rowHeaderColumnKeys
  ].map((columnKey) => $2140fb2337097f2d$export$19baff3266315d44(state, rowKey, columnKey)).join(" ");
}

// node_modules/@react-aria/table/dist/ar-AE.mjs
var $ce3de3ff2fd66848$exports = {};
$ce3de3ff2fd66848$exports = {
  "ascending": `تصاعدي`,
  "ascendingSort": (args) => `ترتيب حسب العمود ${args.columnName} بترتيب تصاعدي`,
  "columnSize": (args) => `${args.value} بالبكسل`,
  "descending": `تنازلي`,
  "descendingSort": (args) => `ترتيب حسب العمود ${args.columnName} بترتيب تنازلي`,
  "resizerDescription": `اضغط على مفتاح Enter لبدء تغيير الحجم`,
  "select": `تحديد`,
  "selectAll": `تحديد الكل`,
  "sortable": `عمود قابل للترتيب`
};

// node_modules/@react-aria/table/dist/bg-BG.mjs
var $cb80dcce530985b9$exports = {};
$cb80dcce530985b9$exports = {
  "ascending": `възходящ`,
  "ascendingSort": (args) => `сортирано по колона ${args.columnName} във възходящ ред`,
  "columnSize": (args) => `${args.value} пиксела`,
  "descending": `низходящ`,
  "descendingSort": (args) => `сортирано по колона ${args.columnName} в низходящ ред`,
  "resizerDescription": `Натиснете „Enter“, за да започнете да преоразмерявате`,
  "select": `Изберете`,
  "selectAll": `Изберете всичко`,
  "sortable": `сортираща колона`
};

// node_modules/@react-aria/table/dist/cs-CZ.mjs
var $68ac86749db4c0fb$exports = {};
$68ac86749db4c0fb$exports = {
  "ascending": `vzestupně`,
  "ascendingSort": (args) => `řazeno vzestupně podle sloupce ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixelů`,
  "descending": `sestupně`,
  "descendingSort": (args) => `řazeno sestupně podle sloupce ${args.columnName}`,
  "resizerDescription": `Stisknutím klávesy Enter začnete měnit velikost`,
  "select": `Vybrat`,
  "selectAll": `Vybrat vše`,
  "sortable": `sloupec s možností řazení`
};

// node_modules/@react-aria/table/dist/da-DK.mjs
var $9a6cbac08487e661$exports = {};
$9a6cbac08487e661$exports = {
  "ascending": `stigende`,
  "ascendingSort": (args) => `sorteret efter kolonne ${args.columnName} i stigende rækkefølge`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `faldende`,
  "descendingSort": (args) => `sorteret efter kolonne ${args.columnName} i faldende rækkefølge`,
  "resizerDescription": `Tryk på Enter for at ændre størrelse`,
  "select": `Vælg`,
  "selectAll": `Vælg alle`,
  "sortable": `sorterbar kolonne`
};

// node_modules/@react-aria/table/dist/de-DE.mjs
var $c963661d89486e72$exports = {};
$c963661d89486e72$exports = {
  "ascending": `aufsteigend`,
  "ascendingSort": (args) => `sortiert nach Spalte ${args.columnName} in aufsteigender Reihenfolge`,
  "columnSize": (args) => `${args.value} Pixel`,
  "descending": `absteigend`,
  "descendingSort": (args) => `sortiert nach Spalte ${args.columnName} in absteigender Reihenfolge`,
  "resizerDescription": `Eingabetaste zum Starten der Größenänderung drücken`,
  "select": `Auswählen`,
  "selectAll": `Alles auswählen`,
  "sortable": `sortierbare Spalte`
};

// node_modules/@react-aria/table/dist/el-GR.mjs
var $ac03861c6e8605f4$exports = {};
$ac03861c6e8605f4$exports = {
  "ascending": `αύξουσα`,
  "ascendingSort": (args) => `διαλογή ανά στήλη ${args.columnName} σε αύξουσα σειρά`,
  "columnSize": (args) => `${args.value} pixel`,
  "descending": `φθίνουσα`,
  "descendingSort": (args) => `διαλογή ανά στήλη ${args.columnName} σε φθίνουσα σειρά`,
  "resizerDescription": `Πατήστε Enter για έναρξη της αλλαγής μεγέθους`,
  "select": `Επιλογή`,
  "selectAll": `Επιλογή όλων`,
  "sortable": `Στήλη διαλογής`
};

// node_modules/@react-aria/table/dist/en-US.mjs
var $09e6b82e0d6e466a$exports = {};
$09e6b82e0d6e466a$exports = {
  "select": `Select`,
  "selectAll": `Select All`,
  "sortable": `sortable column`,
  "ascending": `ascending`,
  "descending": `descending`,
  "ascendingSort": (args) => `sorted by column ${args.columnName} in ascending order`,
  "descendingSort": (args) => `sorted by column ${args.columnName} in descending order`,
  "columnSize": (args) => `${args.value} pixels`,
  "resizerDescription": `Press Enter to start resizing`
};

// node_modules/@react-aria/table/dist/es-ES.mjs
var $8cc39eb66c2bf220$exports = {};
$8cc39eb66c2bf220$exports = {
  "ascending": `de subida`,
  "ascendingSort": (args) => `ordenado por columna ${args.columnName} en orden de subida`,
  "columnSize": (args) => `${args.value} píxeles`,
  "descending": `de bajada`,
  "descendingSort": (args) => `ordenado por columna ${args.columnName} en orden de bajada`,
  "resizerDescription": `Pulse Intro para empezar a redimensionar`,
  "select": `Seleccionar`,
  "selectAll": `Seleccionar todos`,
  "sortable": `columna ordenable`
};

// node_modules/@react-aria/table/dist/et-EE.mjs
var $4e11db3c25a38112$exports = {};
$4e11db3c25a38112$exports = {
  "ascending": `tõusev järjestus`,
  "ascendingSort": (args) => `sorditud veeru järgi ${args.columnName} tõusvas järjestuses`,
  "columnSize": (args) => `${args.value} pikslit`,
  "descending": `laskuv järjestus`,
  "descendingSort": (args) => `sorditud veeru järgi ${args.columnName} laskuvas järjestuses`,
  "resizerDescription": `Suuruse muutmise alustamiseks vajutage klahvi Enter`,
  "select": `Vali`,
  "selectAll": `Vali kõik`,
  "sortable": `sorditav veerg`
};

// node_modules/@react-aria/table/dist/fi-FI.mjs
var $da1e751a92575e02$exports = {};
$da1e751a92575e02$exports = {
  "ascending": `nouseva`,
  "ascendingSort": (args) => `lajiteltu sarakkeen ${args.columnName} mukaan nousevassa järjestyksessä`,
  "columnSize": (args) => `${args.value} pikseliä`,
  "descending": `laskeva`,
  "descendingSort": (args) => `lajiteltu sarakkeen ${args.columnName} mukaan laskevassa järjestyksessä`,
  "resizerDescription": `Aloita koon muutos painamalla Enter-näppäintä`,
  "select": `Valitse`,
  "selectAll": `Valitse kaikki`,
  "sortable": `lajiteltava sarake`
};

// node_modules/@react-aria/table/dist/fr-FR.mjs
var $1b5d6c6c47d55106$exports = {};
$1b5d6c6c47d55106$exports = {
  "ascending": `croissant`,
  "ascendingSort": (args) => `trié en fonction de la colonne ${args.columnName} par ordre croissant`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `décroissant`,
  "descendingSort": (args) => `trié en fonction de la colonne ${args.columnName} par ordre décroissant`,
  "resizerDescription": `Appuyez sur Entrée pour commencer le redimensionnement.`,
  "select": `Sélectionner`,
  "selectAll": `Sélectionner tout`,
  "sortable": `colonne triable`
};

// node_modules/@react-aria/table/dist/he-IL.mjs
var $7c18ba27b86d3308$exports = {};
$7c18ba27b86d3308$exports = {
  "ascending": `עולה`,
  "ascendingSort": (args) => `מוין לפי עמודה ${args.columnName} בסדר עולה`,
  "columnSize": (args) => `${args.value} פיקסלים`,
  "descending": `יורד`,
  "descendingSort": (args) => `מוין לפי עמודה ${args.columnName} בסדר יורד`,
  "resizerDescription": `הקש Enter כדי לשנות את הגודל`,
  "select": `בחר`,
  "selectAll": `בחר הכול`,
  "sortable": `עמודה שניתן למיין`
};

// node_modules/@react-aria/table/dist/hr-HR.mjs
var $2cb40998e20e8a46$exports = {};
$2cb40998e20e8a46$exports = {
  "ascending": `rastući`,
  "ascendingSort": (args) => `razvrstano po stupcima ${args.columnName} rastućem redoslijedom`,
  "columnSize": (args) => `${args.value} piksela`,
  "descending": `padajući`,
  "descendingSort": (args) => `razvrstano po stupcima ${args.columnName} padajućim redoslijedom`,
  "resizerDescription": `Pritisnite Enter da biste započeli promenu veličine`,
  "select": `Odaberite`,
  "selectAll": `Odaberite sve`,
  "sortable": `stupac koji se može razvrstati`
};

// node_modules/@react-aria/table/dist/hu-HU.mjs
var $189e23eec1d6aa3a$exports = {};
$189e23eec1d6aa3a$exports = {
  "ascending": `növekvő`,
  "ascendingSort": (args) => `rendezve a(z) ${args.columnName} oszlop szerint, növekvő sorrendben`,
  "columnSize": (args) => `${args.value} képpont`,
  "descending": `csökkenő`,
  "descendingSort": (args) => `rendezve a(z) ${args.columnName} oszlop szerint, csökkenő sorrendben`,
  "resizerDescription": `Nyomja le az Enter billentyűt az átméretezés megkezdéséhez`,
  "select": `Kijelölés`,
  "selectAll": `Összes kijelölése`,
  "sortable": `rendezendő oszlop`
};

// node_modules/@react-aria/table/dist/it-IT.mjs
var $3c5ec8e4f015dfd0$exports = {};
$3c5ec8e4f015dfd0$exports = {
  "ascending": `crescente`,
  "ascendingSort": (args) => `in ordine crescente in base alla colonna ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixel`,
  "descending": `decrescente`,
  "descendingSort": (args) => `in ordine decrescente in base alla colonna ${args.columnName}`,
  "resizerDescription": `Premi Invio per iniziare a ridimensionare`,
  "select": `Seleziona`,
  "selectAll": `Seleziona tutto`,
  "sortable": `colonna ordinabile`
};

// node_modules/@react-aria/table/dist/ja-JP.mjs
var $d021d50e6b315ebb$exports = {};
$d021d50e6b315ebb$exports = {
  "ascending": `昇順`,
  "ascendingSort": (args) => `列 ${args.columnName} を昇順で並べ替え`,
  "columnSize": (args) => `${args.value} ピクセル`,
  "descending": `降順`,
  "descendingSort": (args) => `列 ${args.columnName} を降順で並べ替え`,
  "resizerDescription": `Enter キーを押してサイズ変更を開始`,
  "select": `選択`,
  "selectAll": `すべて選択`,
  "sortable": `並べ替え可能な列`
};

// node_modules/@react-aria/table/dist/ko-KR.mjs
var $52535c35c24ec937$exports = {};
$52535c35c24ec937$exports = {
  "ascending": `오름차순`,
  "ascendingSort": (args) => `${args.columnName} 열을 기준으로 오름차순으로 정렬됨`,
  "columnSize": (args) => `${args.value} 픽셀`,
  "descending": `내림차순`,
  "descendingSort": (args) => `${args.columnName} 열을 기준으로 내림차순으로 정렬됨`,
  "resizerDescription": `크기 조정을 시작하려면 Enter를 누르세요.`,
  "select": `선택`,
  "selectAll": `모두 선택`,
  "sortable": `정렬 가능한 열`
};

// node_modules/@react-aria/table/dist/lt-LT.mjs
var $b37ee03672edfd1d$exports = {};
$b37ee03672edfd1d$exports = {
  "ascending": `didėjančia tvarka`,
  "ascendingSort": (args) => `surikiuota pagal stulpelį ${args.columnName} didėjančia tvarka`,
  "columnSize": (args) => `${args.value} piks.`,
  "descending": `mažėjančia tvarka`,
  "descendingSort": (args) => `surikiuota pagal stulpelį ${args.columnName} mažėjančia tvarka`,
  "resizerDescription": `Paspauskite „Enter“, kad pradėtumėte keisti dydį`,
  "select": `Pasirinkti`,
  "selectAll": `Pasirinkti viską`,
  "sortable": `rikiuojamas stulpelis`
};

// node_modules/@react-aria/table/dist/lv-LV.mjs
var $c7df6686b4189d56$exports = {};
$c7df6686b4189d56$exports = {
  "ascending": `augošā secībā`,
  "ascendingSort": (args) => `kārtots pēc kolonnas ${args.columnName} augošā secībā`,
  "columnSize": (args) => `${args.value} pikseļi`,
  "descending": `dilstošā secībā`,
  "descendingSort": (args) => `kārtots pēc kolonnas ${args.columnName} dilstošā secībā`,
  "resizerDescription": `Nospiediet Enter, lai sāktu izmēru mainīšanu`,
  "select": `Atlasīt`,
  "selectAll": `Atlasīt visu`,
  "sortable": `kārtojamā kolonna`
};

// node_modules/@react-aria/table/dist/nb-NO.mjs
var $da07fe8ec87e6b68$exports = {};
$da07fe8ec87e6b68$exports = {
  "ascending": `stigende`,
  "ascendingSort": (args) => `sortert etter kolonne ${args.columnName} i stigende rekkefølge`,
  "columnSize": (args) => `${args.value} piksler`,
  "descending": `synkende`,
  "descendingSort": (args) => `sortert etter kolonne ${args.columnName} i synkende rekkefølge`,
  "resizerDescription": `Trykk på Enter for å starte størrelsesendring`,
  "select": `Velg`,
  "selectAll": `Velg alle`,
  "sortable": `kolonne som kan sorteres`
};

// node_modules/@react-aria/table/dist/nl-NL.mjs
var $64b7e390f5791490$exports = {};
$64b7e390f5791490$exports = {
  "ascending": `oplopend`,
  "ascendingSort": (args) => `gesorteerd in oplopende volgorde in kolom ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `aflopend`,
  "descendingSort": (args) => `gesorteerd in aflopende volgorde in kolom ${args.columnName}`,
  "resizerDescription": `Druk op Enter om het formaat te wijzigen`,
  "select": `Selecteren`,
  "selectAll": `Alles selecteren`,
  "sortable": `sorteerbare kolom`
};

// node_modules/@react-aria/table/dist/pl-PL.mjs
var $2a03621e773f1678$exports = {};
$2a03621e773f1678$exports = {
  "ascending": `rosnąco`,
  "ascendingSort": (args) => `posortowano według kolumny ${args.columnName} w porządku rosnącym`,
  "columnSize": (args) => `Liczba pikseli: ${args.value}`,
  "descending": `malejąco`,
  "descendingSort": (args) => `posortowano według kolumny ${args.columnName} w porządku malejącym`,
  "resizerDescription": `Naciśnij Enter, aby rozpocząć zmienianie rozmiaru`,
  "select": `Zaznacz`,
  "selectAll": `Zaznacz wszystko`,
  "sortable": `kolumna z możliwością sortowania`
};

// node_modules/@react-aria/table/dist/pt-BR.mjs
var $0a79c0aba9e5ecc6$exports = {};
$0a79c0aba9e5ecc6$exports = {
  "ascending": `crescente`,
  "ascendingSort": (args) => `classificado pela coluna ${args.columnName} em ordem crescente`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `decrescente`,
  "descendingSort": (args) => `classificado pela coluna ${args.columnName} em ordem decrescente`,
  "resizerDescription": `Pressione Enter para começar a redimensionar`,
  "select": `Selecionar`,
  "selectAll": `Selecionar tudo`,
  "sortable": `coluna classificável`
};

// node_modules/@react-aria/table/dist/pt-PT.mjs
var $de7b4d0f7dc86fc8$exports = {};
$de7b4d0f7dc86fc8$exports = {
  "ascending": `ascendente`,
  "ascendingSort": (args) => `Ordenar por coluna ${args.columnName} em ordem ascendente`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `descendente`,
  "descendingSort": (args) => `Ordenar por coluna ${args.columnName} em ordem descendente`,
  "resizerDescription": `Prima Enter para iniciar o redimensionamento`,
  "select": `Selecionar`,
  "selectAll": `Selecionar tudo`,
  "sortable": `Coluna ordenável`
};

// node_modules/@react-aria/table/dist/ro-RO.mjs
var $28ea7e849d77bd1c$exports = {};
$28ea7e849d77bd1c$exports = {
  "ascending": `crescătoare`,
  "ascendingSort": (args) => `sortate după coloana ${args.columnName} în ordine crescătoare`,
  "columnSize": (args) => `${args.value} pixeli`,
  "descending": `descrescătoare`,
  "descendingSort": (args) => `sortate după coloana ${args.columnName} în ordine descrescătoare`,
  "resizerDescription": `Apăsați pe Enter pentru a începe redimensionarea`,
  "select": `Selectare`,
  "selectAll": `Selectare totală`,
  "sortable": `coloană sortabilă`
};

// node_modules/@react-aria/table/dist/ru-RU.mjs
var $9a09321cf046b187$exports = {};
$9a09321cf046b187$exports = {
  "ascending": `возрастание`,
  "ascendingSort": (args) => `сортировать столбец ${args.columnName} в порядке возрастания`,
  "columnSize": (args) => `${args.value} пикс.`,
  "descending": `убывание`,
  "descendingSort": (args) => `сортировать столбец ${args.columnName} в порядке убывания`,
  "resizerDescription": `Нажмите клавишу Enter для начала изменения размеров`,
  "select": `Выбрать`,
  "selectAll": `Выбрать все`,
  "sortable": `сортируемый столбец`
};

// node_modules/@react-aria/table/dist/sk-SK.mjs
var $5afe469a63fcac7b$exports = {};
$5afe469a63fcac7b$exports = {
  "ascending": `vzostupne`,
  "ascendingSort": (args) => `zoradené zostupne podľa stĺpca ${args.columnName}`,
  "columnSize": (args) => `Počet pixelov: ${args.value}`,
  "descending": `zostupne`,
  "descendingSort": (args) => `zoradené zostupne podľa stĺpca ${args.columnName}`,
  "resizerDescription": `Stlačením klávesu Enter začnete zmenu veľkosti`,
  "select": `Vybrať`,
  "selectAll": `Vybrať všetko`,
  "sortable": `zoraditeľný stĺpec`
};

// node_modules/@react-aria/table/dist/sl-SI.mjs
var $2956757ac31a7ce2$exports = {};
$2956757ac31a7ce2$exports = {
  "ascending": `naraščajoče`,
  "ascendingSort": (args) => `razvrščeno po stolpcu ${args.columnName} v naraščajočem vrstnem redu`,
  "columnSize": (args) => `${args.value} slikovnih pik`,
  "descending": `padajoče`,
  "descendingSort": (args) => `razvrščeno po stolpcu ${args.columnName} v padajočem vrstnem redu`,
  "resizerDescription": `Pritisnite tipko Enter da začnete spreminjati velikost`,
  "select": `Izberite`,
  "selectAll": `Izberite vse`,
  "sortable": `razvrstljivi stolpec`
};

// node_modules/@react-aria/table/dist/sr-SP.mjs
var $cedee0e66b175529$exports = {};
$cedee0e66b175529$exports = {
  "ascending": `rastući`,
  "ascendingSort": (args) => `sortirano po kolonama ${args.columnName} rastućim redosledom`,
  "columnSize": (args) => `${args.value} piksela`,
  "descending": `padajući`,
  "descendingSort": (args) => `sortirano po kolonama ${args.columnName} padajućim redosledom`,
  "resizerDescription": `Pritisnite Enter da biste započeli promenu veličine`,
  "select": `Izaberite`,
  "selectAll": `Izaberite sve`,
  "sortable": `kolona koja se može sortirati`
};

// node_modules/@react-aria/table/dist/sv-SE.mjs
var $6db19998ba4427da$exports = {};
$6db19998ba4427da$exports = {
  "ascending": `stigande`,
  "ascendingSort": (args) => `sorterat på kolumn ${args.columnName} i stigande ordning`,
  "columnSize": (args) => `${args.value} pixlar`,
  "descending": `fallande`,
  "descendingSort": (args) => `sorterat på kolumn ${args.columnName} i fallande ordning`,
  "resizerDescription": `Tryck på Retur för att börja ändra storlek`,
  "select": `Markera`,
  "selectAll": `Markera allt`,
  "sortable": `sorterbar kolumn`
};

// node_modules/@react-aria/table/dist/tr-TR.mjs
var $166b7c9cc1adb1a1$exports = {};
$166b7c9cc1adb1a1$exports = {
  "ascending": `artan sırada`,
  "ascendingSort": (args) => `${args.columnName} sütuna göre artan düzende sırala`,
  "columnSize": (args) => `${args.value} piksel`,
  "descending": `azalan sırada`,
  "descendingSort": (args) => `${args.columnName} sütuna göre azalan düzende sırala`,
  "resizerDescription": `Yeniden boyutlandırmak için Enter'a basın`,
  "select": `Seç`,
  "selectAll": `Tümünü Seç`,
  "sortable": `Sıralanabilir sütun`
};

// node_modules/@react-aria/table/dist/uk-UA.mjs
var $c7ab180b401e49ff$exports = {};
$c7ab180b401e49ff$exports = {
  "ascending": `висхідний`,
  "ascendingSort": (args) => `відсортовано за стовпцем ${args.columnName} у висхідному порядку`,
  "columnSize": (args) => `${args.value} пікс.`,
  "descending": `низхідний`,
  "descendingSort": (args) => `відсортовано за стовпцем ${args.columnName} у низхідному порядку`,
  "resizerDescription": `Натисніть Enter, щоб почати зміну розміру`,
  "select": `Вибрати`,
  "selectAll": `Вибрати все`,
  "sortable": `сортувальний стовпець`
};

// node_modules/@react-aria/table/dist/zh-CN.mjs
var $1648ec00941567f3$exports = {};
$1648ec00941567f3$exports = {
  "ascending": `升序`,
  "ascendingSort": (args) => `按列 ${args.columnName} 升序排序`,
  "columnSize": (args) => `${args.value} 像素`,
  "descending": `降序`,
  "descendingSort": (args) => `按列 ${args.columnName} 降序排序`,
  "resizerDescription": `按“输入”键开始调整大小。`,
  "select": `选择`,
  "selectAll": `全选`,
  "sortable": `可排序的列`
};

// node_modules/@react-aria/table/dist/zh-TW.mjs
var $b26f22384b3c1526$exports = {};
$b26f22384b3c1526$exports = {
  "ascending": `遞增`,
  "ascendingSort": (args) => `已依據「${args.columnName}」欄遞增排序`,
  "columnSize": (args) => `${args.value} 像素`,
  "descending": `遞減`,
  "descendingSort": (args) => `已依據「${args.columnName}」欄遞減排序`,
  "resizerDescription": `按 Enter 鍵以開始調整大小`,
  "select": `選取`,
  "selectAll": `全選`,
  "sortable": `可排序的欄`
};

// node_modules/@react-aria/table/dist/intlStrings.mjs
var $7476b46781682bf5$exports = {};
$7476b46781682bf5$exports = {
  "ar-AE": $ce3de3ff2fd66848$exports,
  "bg-BG": $cb80dcce530985b9$exports,
  "cs-CZ": $68ac86749db4c0fb$exports,
  "da-DK": $9a6cbac08487e661$exports,
  "de-DE": $c963661d89486e72$exports,
  "el-GR": $ac03861c6e8605f4$exports,
  "en-US": $09e6b82e0d6e466a$exports,
  "es-ES": $8cc39eb66c2bf220$exports,
  "et-EE": $4e11db3c25a38112$exports,
  "fi-FI": $da1e751a92575e02$exports,
  "fr-FR": $1b5d6c6c47d55106$exports,
  "he-IL": $7c18ba27b86d3308$exports,
  "hr-HR": $2cb40998e20e8a46$exports,
  "hu-HU": $189e23eec1d6aa3a$exports,
  "it-IT": $3c5ec8e4f015dfd0$exports,
  "ja-JP": $d021d50e6b315ebb$exports,
  "ko-KR": $52535c35c24ec937$exports,
  "lt-LT": $b37ee03672edfd1d$exports,
  "lv-LV": $c7df6686b4189d56$exports,
  "nb-NO": $da07fe8ec87e6b68$exports,
  "nl-NL": $64b7e390f5791490$exports,
  "pl-PL": $2a03621e773f1678$exports,
  "pt-BR": $0a79c0aba9e5ecc6$exports,
  "pt-PT": $de7b4d0f7dc86fc8$exports,
  "ro-RO": $28ea7e849d77bd1c$exports,
  "ru-RU": $9a09321cf046b187$exports,
  "sk-SK": $5afe469a63fcac7b$exports,
  "sl-SI": $2956757ac31a7ce2$exports,
  "sr-SP": $cedee0e66b175529$exports,
  "sv-SE": $6db19998ba4427da$exports,
  "tr-TR": $166b7c9cc1adb1a1$exports,
  "uk-UA": $c7ab180b401e49ff$exports,
  "zh-CN": $1648ec00941567f3$exports,
  "zh-TW": $b26f22384b3c1526$exports
};

// node_modules/@react-aria/table/dist/TableKeyboardDelegate.mjs
var $0ba3c81c7f1caedd$export$da43f8f5cb04028d = class extends (0, $d1c300d9c497e402$export$de9feff04fda126e) {
  isCell(node) {
    return node.type === "cell" || node.type === "rowheader" || node.type === "column";
  }
  getKeyBelow(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem) return;
    if (startItem.type === "column") {
      let child = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(startItem, this.collection));
      if (child) return child.key;
      let firstKey = this.getFirstKey();
      if (firstKey == null) return;
      let firstItem = this.collection.getItem(firstKey);
      return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(firstItem, this.collection), startItem.index).key;
    }
    return super.getKeyBelow(key);
  }
  getKeyAbove(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem) return;
    if (startItem.type === "column") {
      let parent = this.collection.getItem(startItem.parentKey);
      if (parent && parent.type === "column") return parent.key;
      return;
    }
    let superKey = super.getKeyAbove(key);
    if (superKey != null && this.collection.getItem(superKey).type !== "headerrow") return superKey;
    if (this.isCell(startItem)) return this.collection.columns[startItem.index].key;
    return this.collection.columns[0].key;
  }
  findNextColumnKey(column) {
    let key = this.findNextKey(column.key, (item) => item.type === "column");
    if (key != null) return key;
    let row = this.collection.headerRows[column.level];
    for (let item of (0, $c5a24bc478652b5f$export$1005530eda016c13)(row, this.collection)) {
      if (item.type === "column") return item.key;
    }
  }
  findPreviousColumnKey(column) {
    let key = this.findPreviousKey(column.key, (item) => item.type === "column");
    if (key != null) return key;
    let row = this.collection.headerRows[column.level];
    let childNodes = [
      ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(row, this.collection)
    ];
    for (let i = childNodes.length - 1; i >= 0; i--) {
      let item = childNodes[i];
      if (item.type === "column") return item.key;
    }
  }
  getKeyRightOf(key) {
    let item = this.collection.getItem(key);
    if (!item) return;
    if (item.type === "column") return this.direction === "rtl" ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);
    return super.getKeyRightOf(key);
  }
  getKeyLeftOf(key) {
    let item = this.collection.getItem(key);
    if (!item) return;
    if (item.type === "column") return this.direction === "rtl" ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);
    return super.getKeyLeftOf(key);
  }
  getKeyForSearch(search, fromKey) {
    if (!this.collator) return null;
    let collection = this.collection;
    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
    if (key == null) return null;
    let startItem = collection.getItem(key);
    if (startItem.type === "cell") key = startItem.parentKey;
    let hasWrapped = false;
    while (key != null) {
      let item = collection.getItem(key);
      for (let cell of (0, $c5a24bc478652b5f$export$1005530eda016c13)(item, this.collection)) {
        let column = collection.columns[cell.index];
        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {
          let substring = cell.textValue.slice(0, search.length);
          if (this.collator.compare(substring, search) === 0) {
            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;
            return fromItem.type === "cell" ? cell.key : item.key;
          }
        }
      }
      key = this.getKeyBelow(key);
      if (key == null && !hasWrapped) {
        key = this.getFirstKey();
        hasWrapped = true;
      }
    }
    return null;
  }
};

// node_modules/@react-aria/table/dist/useTable.mjs
var import_react2 = __toESM(require_react(), 1);
function $parcel$interopDefault2(a) {
  return a && a.__esModule ? a.default : a;
}
function $6e31608fbba75bab$export$25bceaac3c7e4dc7(props, state, ref) {
  let { keyboardDelegate, isVirtualized, layoutDelegate, layout } = props;
  let collator2 = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let disabledBehavior = state.selectionManager.disabledBehavior;
  let delegate = (0, import_react2.useMemo)(() => keyboardDelegate || new (0, $0ba3c81c7f1caedd$export$da43f8f5cb04028d)({
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    disabledBehavior,
    ref,
    direction,
    collator: collator2,
    layoutDelegate,
    layout
  }), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    disabledBehavior,
    ref,
    direction,
    collator2,
    layoutDelegate,
    layout
  ]);
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $2140fb2337097f2d$export$552312adfd451dab).set(state, id);
  let { gridProps } = (0, $83c6e2eafa584c67$export$f6b86a04e5d66d90)({
    ...props,
    id,
    keyboardDelegate: delegate
  }, state, ref);
  if (isVirtualized) gridProps["aria-rowcount"] = state.collection.size + state.collection.headerRows.length;
  if ((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state) gridProps.role = "treegrid";
  let { column, direction: sortDirection } = state.sortDescriptor || {};
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($7476b46781682bf5$exports)), "@react-aria/table");
  let sortDescription = (0, import_react2.useMemo)(() => {
    var _state_collection_columns_find;
    let columnName = (_state_collection_columns_find = state.collection.columns.find((c3) => c3.key === column)) === null || _state_collection_columns_find === void 0 ? void 0 : _state_collection_columns_find.textValue;
    return sortDirection && column ? stringFormatter.format(`${sortDirection}Sort`, {
      columnName
    }) : void 0;
  }, [
    sortDirection,
    column,
    state.collection.columns
  ]);
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(sortDescription);
  (0, $4f58c5f72bcf79f7$export$496315a1608d9602)(() => {
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(sortDescription, "assertive", 500);
  }, [
    sortDescription
  ]);
  return {
    gridProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(gridProps, descriptionProps, {
      // merge sort description with long press information
      "aria-describedby": [
        descriptionProps["aria-describedby"],
        gridProps["aria-describedby"]
      ].filter(Boolean).join(" ")
    })
  };
}

// node_modules/@react-aria/table/dist/useTableColumnHeader.mjs
var import_react3 = __toESM(require_react(), 1);
function $parcel$interopDefault3(a) {
  return a && a.__esModule ? a.default : a;
}
function $f329116d8ad0aba0$export$9514819a8c81e960(props, state, ref) {
  var _state_sortDescriptor, _state_sortDescriptor1;
  let { node } = props;
  let allowsSorting = node.props.allowsSorting;
  let { gridCellProps } = (0, $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c)({
    ...props,
    focusMode: "child"
  }, state, ref);
  let isSelectionCellDisabled = node.props.isSelectionCell && state.selectionManager.selectionMode === "single";
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled: !allowsSorting || isSelectionCellDisabled,
    onPress() {
      state.sort(node.key);
    },
    ref
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)({}, ref);
  let ariaSort = null;
  let isSortedColumn = ((_state_sortDescriptor = state.sortDescriptor) === null || _state_sortDescriptor === void 0 ? void 0 : _state_sortDescriptor.column) === node.key;
  let sortDirection = (_state_sortDescriptor1 = state.sortDescriptor) === null || _state_sortDescriptor1 === void 0 ? void 0 : _state_sortDescriptor1.direction;
  if (node.props.allowsSorting && !(0, $c87311424ea30a05$export$a11b0059900ceec8)()) ariaSort = isSortedColumn ? sortDirection : "none";
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($7476b46781682bf5$exports)), "@react-aria/table");
  let sortDescription;
  if (allowsSorting) {
    sortDescription = `${stringFormatter.format("sortable")}`;
    if (isSortedColumn && sortDirection && (0, $c87311424ea30a05$export$a11b0059900ceec8)()) sortDescription = `${sortDescription}, ${stringFormatter.format(sortDirection)}`;
  }
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(sortDescription);
  let shouldDisableFocus = state.collection.size === 0;
  (0, import_react3.useEffect)(() => {
    if (shouldDisableFocus && state.selectionManager.focusedKey === node.key) state.selectionManager.setFocusedKey(null);
  }, [
    shouldDisableFocus,
    state.selectionManager,
    node.key
  ]);
  return {
    columnHeaderProps: {
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
        gridCellProps,
        pressProps,
        focusableProps,
        descriptionProps,
        // If the table is empty, make all column headers untabbable
        shouldDisableFocus && {
          tabIndex: -1
        }
      ),
      role: "columnheader",
      id: (0, $2140fb2337097f2d$export$37cd4213f2ad742e)(state, node.key),
      "aria-colspan": node.colspan && node.colspan > 1 ? node.colspan : null,
      "aria-sort": ariaSort
    }
  };
}

// node_modules/@react-aria/table/dist/useTableRow.mjs
var $b2db214c022798eb$var$EXPANSION_KEYS = {
  expand: {
    ltr: "ArrowRight",
    rtl: "ArrowLeft"
  },
  "collapse": {
    ltr: "ArrowLeft",
    rtl: "ArrowRight"
  }
};
function $b2db214c022798eb$export$7f2f6ae19e707aa5(props, state, ref) {
  let { node, isVirtualized } = props;
  let { rowProps, ...states } = (0, $4159a7a9cbb0cc18$export$96357d5a73f686fa)(props, state, ref);
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  if (isVirtualized && !((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state)) rowProps["aria-rowindex"] = node.index + 1 + state.collection.headerRows.length;
  else delete rowProps["aria-rowindex"];
  let treeGridRowProps = {};
  if ((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state) {
    let treeNode = state.keyMap.get(node.key);
    if (treeNode != null) {
      var _treeNode_props, _treeNode_props_children, _treeNode_props1;
      let hasChildRows = ((_treeNode_props = treeNode.props) === null || _treeNode_props === void 0 ? void 0 : _treeNode_props.UNSTABLE_childItems) || ((_treeNode_props1 = treeNode.props) === null || _treeNode_props1 === void 0 ? void 0 : (_treeNode_props_children = _treeNode_props1.children) === null || _treeNode_props_children === void 0 ? void 0 : _treeNode_props_children.length) > state.userColumnCount;
      treeGridRowProps = {
        onKeyDown: (e2) => {
          if (e2.key === $b2db214c022798eb$var$EXPANSION_KEYS["expand"][direction] && state.selectionManager.focusedKey === treeNode.key && hasChildRows && state.expandedKeys !== "all" && !state.expandedKeys.has(treeNode.key)) {
            state.toggleKey(treeNode.key);
            e2.stopPropagation();
          } else if (e2.key === $b2db214c022798eb$var$EXPANSION_KEYS["collapse"][direction] && state.selectionManager.focusedKey === treeNode.key && hasChildRows && (state.expandedKeys === "all" || state.expandedKeys.has(treeNode.key))) {
            state.toggleKey(treeNode.key);
            e2.stopPropagation();
          }
        },
        "aria-expanded": hasChildRows ? state.expandedKeys === "all" || state.expandedKeys.has(node.key) : void 0,
        "aria-level": treeNode.level,
        "aria-posinset": treeNode.indexOfType + 1,
        "aria-setsize": treeNode.level > 1 ? (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(state.keyMap.get(treeNode === null || treeNode === void 0 ? void 0 : treeNode.parentKey).childNodes).indexOfType + 1 : (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(state.keyMap.get(state.collection.body.key).childNodes).indexOfType + 1
      };
    }
  }
  let syntheticLinkProps = (0, $ea8dcbcb9ea1b556$export$bdc77b0c0a3a85d6)(node.props);
  let linkProps = states.hasAction ? syntheticLinkProps : {};
  return {
    rowProps: {
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(rowProps, treeGridRowProps, linkProps),
      "aria-labelledby": (0, $2140fb2337097f2d$export$85069b70317f543)(state, node.key)
    },
    ...states
  };
}

// node_modules/@react-aria/table/dist/useTableHeaderRow.mjs
function $f917ee10f4c32dab$export$1b95a7d2d517b841(props, state, ref) {
  let { node, isVirtualized } = props;
  let rowProps = {
    role: "row"
  };
  if (isVirtualized && !((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state)) rowProps["aria-rowindex"] = node.index + 1;
  return {
    rowProps
  };
}

// node_modules/@react-aria/table/dist/useTableCell.mjs
function $7713593715703b24$export$49571c903d73624c(props, state, ref) {
  let { gridCellProps, isPressed } = (0, $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c)(props, state, ref);
  let columnKey = props.node.column.key;
  if (state.collection.rowHeaderColumnKeys.has(columnKey)) {
    gridCellProps.role = "rowheader";
    gridCellProps.id = (0, $2140fb2337097f2d$export$19baff3266315d44)(state, props.node.parentKey, columnKey);
  }
  return {
    gridCellProps,
    isPressed
  };
}

// node_modules/@react-aria/table/dist/useTableSelectionCheckbox.mjs
function $parcel$interopDefault4(a) {
  return a && a.__esModule ? a.default : a;
}
function $2a795c53a101c542$export$16ea7f650bd7c1bb(props, state) {
  let { key } = props;
  const { checkboxProps } = (0, $7cb39d07f245a780$export$70e2eed1a92976ad)(props, state);
  return {
    checkboxProps: {
      ...checkboxProps,
      "aria-labelledby": `${checkboxProps.id} ${(0, $2140fb2337097f2d$export$85069b70317f543)(state, key)}`
    }
  };
}
function $2a795c53a101c542$export$1003db6a7e384b99(state) {
  let { isEmpty, isSelectAll, selectionMode } = state.selectionManager;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault4($7476b46781682bf5$exports)), "@react-aria/table");
  return {
    checkboxProps: {
      "aria-label": stringFormatter.format(selectionMode === "single" ? "select" : "selectAll"),
      isSelected: isSelectAll,
      isDisabled: selectionMode !== "multiple" || state.collection.size === 0,
      isIndeterminate: !isEmpty && !isSelectAll,
      onChange: () => state.selectionManager.toggleSelectAll()
    }
  };
}

// node_modules/@react-aria/table/dist/useTableColumnResize.mjs
var import_react4 = __toESM(require_react(), 1);
function $parcel$interopDefault5(a) {
  return a && a.__esModule ? a.default : a;
}
function $e91ef4e5004e3774$export$52994e973806c219(props, state, ref) {
  let { column: item, triggerRef, isDisabled, onResizeStart, onResize, onResizeEnd, "aria-label": ariaLabel } = props;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault5($7476b46781682bf5$exports)), "@react-aria/table");
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let isResizing = state.resizingColumn === item.key;
  let isResizingRef = (0, import_react4.useRef)(isResizing);
  let lastSize = (0, import_react4.useRef)(null);
  let wasFocusedOnResizeStart = (0, import_react4.useRef)(false);
  let editModeEnabled = state.tableState.isKeyboardNavigationDisabled;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)({
    onKeyDown: (e2) => {
      if (editModeEnabled) {
        if (e2.key === "Escape" || e2.key === "Enter" || e2.key === " " || e2.key === "Tab") {
          e2.preventDefault();
          endResize(item);
        }
      } else {
        e2.continuePropagation();
        if (e2.key === "Enter") startResize(item);
      }
    }
  });
  let startResize = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((item2) => {
    if (!isResizingRef.current) {
      lastSize.current = state.updateResizedColumns(item2.key, state.getColumnWidth(item2.key));
      state.startResize(item2.key);
      state.tableState.setKeyboardNavigationDisabled(true);
      onResizeStart === null || onResizeStart === void 0 ? void 0 : onResizeStart(lastSize.current);
    }
    isResizingRef.current = true;
  });
  let resize = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((item2, newWidth) => {
    let sizes = state.updateResizedColumns(item2.key, newWidth);
    onResize === null || onResize === void 0 ? void 0 : onResize(sizes);
    lastSize.current = sizes;
  });
  let endResize = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((item2) => {
    if (isResizingRef.current) {
      if (lastSize.current == null) lastSize.current = state.updateResizedColumns(item2.key, state.getColumnWidth(item2.key));
      state.endResize();
      state.tableState.setKeyboardNavigationDisabled(false);
      onResizeEnd === null || onResizeEnd === void 0 ? void 0 : onResizeEnd(lastSize.current);
      isResizingRef.current = false;
      if ((triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) && !wasFocusedOnResizeStart.current)
        (0, $6a99195332edec8b$export$80f3e147d781571c)(triggerRef.current);
    }
    lastSize.current = null;
  });
  const columnResizeWidthRef = (0, import_react4.useRef)(0);
  const { moveProps } = (0, $e8a7022cf87cba2a$export$36da96379f79f245)({
    onMoveStart() {
      columnResizeWidthRef.current = state.getColumnWidth(item.key);
      startResize(item);
    },
    onMove(e2) {
      let { deltaX, deltaY, pointerType } = e2;
      if (direction === "rtl") deltaX *= -1;
      if (pointerType === "keyboard") {
        if (deltaY !== 0 && deltaX === 0) deltaX = deltaY * -1;
        deltaX *= 10;
      }
      if (deltaX !== 0) {
        columnResizeWidthRef.current += deltaX;
        resize(item, columnResizeWidthRef.current);
      }
    },
    onMoveEnd(e2) {
      let { pointerType } = e2;
      columnResizeWidthRef.current = 0;
      if (pointerType === "mouse" || pointerType === "touch" && wasFocusedOnResizeStart.current) endResize(item);
    }
  });
  let onKeyDown = (0, import_react4.useCallback)((e2) => {
    if (editModeEnabled) moveProps.onKeyDown(e2);
  }, [
    editModeEnabled,
    moveProps
  ]);
  let min = Math.floor(state.getColumnMinWidth(item.key));
  let max = Math.floor(state.getColumnMaxWidth(item.key));
  if (max === Infinity) max = Number.MAX_SAFE_INTEGER;
  let value = Math.floor(state.getColumnWidth(item.key));
  let modality = (0, $507fabe10e71c6fb$export$98e20ec92f614cfe)();
  if (modality === "virtual" && typeof window !== "undefined" && "ontouchstart" in window) modality = "touch";
  let description = (triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) == null && (modality === "keyboard" || modality === "virtual") && !isResizing ? stringFormatter.format("resizerDescription") : void 0;
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(description);
  let ariaProps = {
    "aria-label": ariaLabel,
    "aria-orientation": "horizontal",
    "aria-labelledby": `${id} ${(0, $2140fb2337097f2d$export$37cd4213f2ad742e)(state.tableState, item.key)}`,
    "aria-valuetext": stringFormatter.format("columnSize", {
      value
    }),
    "type": "range",
    min,
    max,
    value,
    ...descriptionProps
  };
  const focusInput = (0, import_react4.useCallback)(() => {
    if (ref.current) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
  }, [
    ref
  ]);
  let resizingColumn = state.resizingColumn;
  let prevResizingColumn = (0, import_react4.useRef)(null);
  (0, import_react4.useEffect)(() => {
    if (prevResizingColumn.current !== resizingColumn && resizingColumn != null && resizingColumn === item.key) {
      wasFocusedOnResizeStart.current = document.activeElement === ref.current;
      startResize(item);
      let timeout = setTimeout(() => focusInput(), 0);
      let VOTimeout = setTimeout(focusInput, 400);
      return () => {
        clearTimeout(timeout);
        clearTimeout(VOTimeout);
      };
    }
    prevResizingColumn.current = resizingColumn;
  }, [
    resizingColumn,
    item,
    focusInput,
    ref,
    startResize
  ]);
  let onChange = (e2) => {
    let currentWidth = state.getColumnWidth(item.key);
    let nextValue = parseFloat(e2.target.value);
    if (nextValue > currentWidth) nextValue = currentWidth + 10;
    else nextValue = currentWidth - 10;
    resize(item, nextValue);
  };
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPressStart: (e2) => {
      if (e2.ctrlKey || e2.altKey || e2.metaKey || e2.shiftKey || e2.pointerType === "keyboard") return;
      if (e2.pointerType === "virtual" && state.resizingColumn != null) {
        endResize(item);
        return;
      }
      focusInput();
      if (e2.pointerType !== "virtual") startResize(item);
    },
    onPress: (e2) => {
      if ((e2.pointerType === "touch" && wasFocusedOnResizeStart.current || e2.pointerType === "mouse") && state.resizingColumn != null) endResize(item);
    }
  });
  let { visuallyHiddenProps } = (0, $5c3e21d68f1c4674$export$a966af930f325cab)();
  return {
    resizerProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(keyboardProps, {
      ...moveProps,
      onKeyDown
    }, pressProps, {
      style: {
        touchAction: "none"
      }
    }),
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(visuallyHiddenProps, {
      id,
      onBlur: () => {
        endResize(item);
      },
      onChange,
      disabled: isDisabled
    }, ariaProps),
    isResizing
  };
}

// node_modules/@react-aria/table/dist/import.mjs
function $0047e6c294ea075f$export$6fb1613bd7b28198() {
  return (0, $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf)();
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-arrowUpIcon.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var arrowUpIcon = (0, import_jsx_runtime10.jsx)("path", {
  d: "m5 12 7-7 7 7M12 19V5"
});

// node_modules/@keystar/ui/dist/keystar-ui-table.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var import_react_dom = __toESM(require_react_dom());
var TableContext = (0, import_react5.createContext)(null);
function useTableContext() {
  const context = (0, import_react5.useContext)(TableContext);
  if (context === null) {
    throw new Error("TableContext not found");
  }
  return context;
}
var VirtualizerContext = (0, import_react5.createContext)(null);
function useVirtualizerContext() {
  const context = (0, import_react5.useContext)(VirtualizerContext);
  if (context === null) {
    throw new Error("VirtualizerContext not found");
  }
  return context;
}
var TableRowContext = (0, import_react5.createContext)(null);
function useTableRowContext() {
  const context = (0, import_react5.useContext)(TableRowContext);
  if (context === null) {
    throw new Error("TableRowContext not found");
  }
  return context;
}
var tableViewClassList = new ClassList("TableView", ["cell", "cell-wrapper", "row", "body", "header"]);
var SortIndicator = () => {
  const $ = c2(2);
  const labelHeight = tokenSchema.typography.text.regular.capheight;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      alignItems: "center",
      display: "flex",
      flexShrink: 0,
      gridArea: "sort-indicator",
      height: labelHeight,
      justifyContent: "center",
      marginInline: tokenSchema.size.space.small,
      opacity: 0,
      position: "relative",
      transition: transition(["opacity", "transform"], {
        easing: "easeOut"
      }),
      width: labelHeight,
      svg: {
        position: "absolute"
      },
      '[aria-sort="ascending"] &, [aria-sort="descending"] &': {
        opacity: 1
      },
      '[aria-sort="descending"] &': {
        transform: "rotate(180deg)"
      }
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (0, import_jsx_runtime11.jsx)("span", {
      "aria-hidden": "true",
      className: t0,
      children: (0, import_jsx_runtime11.jsx)(Icon, {
        src: arrowUpIcon
      })
    });
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
};
var tableClassname = css({
  display: "flex",
  flexDirection: "column",
  isolation: "isolate",
  minHeight: 0,
  minWidth: 0,
  outline: "none",
  position: "relative",
  userSelect: "none"
});
var headerWrapperClassname = css({
  boxSizing: "content-box",
  // keep aligned with the border of the body
  borderLeft: `${tokenSchema.size.border.regular} solid transparent`,
  borderRight: `${tokenSchema.size.border.regular} solid transparent`
});
var headerClassname = classNames(tableViewClassList.element("header"), css({
  boxSizing: "border-box"
}));
var bodyClassname = classNames(tableViewClassList.element("body"), css({
  backgroundColor: tokenSchema.color.background.canvas,
  border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
  borderRadius: tokenSchema.size.radius.medium,
  /* Fix scrollbars on iOS with sticky row headers */
  transform: "translate3d(0, 0, 0)"
}));
var columnResizerClassname = css({
  blockSize: "100%",
  boxSizing: "border-box",
  display: "flex",
  flexShrink: 0,
  inlineSize: 21,
  insetInlineEnd: -10,
  justifyContent: "center",
  outline: 0,
  position: "absolute",
  userSelect: "none",
  "&::after": {
    backgroundColor: tokenSchema.color.border.neutral,
    blockSize: "100%",
    boxSizing: "border-box",
    content: '""',
    display: "block",
    inlineSize: 1
  }
});
var columnResizerPlaceholderClassname = css({
  blockSize: "100%",
  boxSizing: "border-box",
  flex: "0 0 auto",
  flexShrink: 0,
  inlineSize: 10,
  userSelect: "none"
});
var columnResizeIndicatorClassname = css({
  backgroundColor: tokenSchema.color.background.accentEmphasis,
  display: "none",
  flexShrink: 0,
  height: "100%",
  insetInlineEnd: 0,
  pointerEvents: "none",
  position: "absolute",
  top: 1,
  width: 2,
  zIndex: 3,
  "&[data-resizing=true]": {
    display: "block"
  }
});
var bodyResizeIndicatorClassname = css({
  backgroundColor: tokenSchema.color.background.accentEmphasis,
  display: "none",
  height: "100%",
  position: "absolute",
  top: 0,
  width: 2
});
var centeredWrapperClassname = css({
  alignItems: "center",
  display: "flex",
  height: "100%",
  justifyContent: "center",
  width: "100%"
});
var rowClassname = css({
  boxSizing: "border-box",
  display: "flex",
  position: "relative",
  outline: 0,
  // separators
  [`${tableViewClassList.selector("body")} &::after`]: {
    content: '""',
    boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.border.muted}`,
    position: "absolute",
    inset: 0,
    pointerEvents: "none",
    zIndex: 2
  },
  "&[data-flush-with-container-bottom]::after": {
    display: "none"
  },
  // selection
  '&[aria-selected="true"]::after': {
    boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.alias.backgroundSelectedHovered}`
  },
  '&[data-next-selected="true"]::after': {
    boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.alias.backgroundSelectedHovered}`
  },
  // prominence
  [`${tableViewClassList.selector("root")}:not([data-prominence="low"]) &`]: {
    "&:first-child": {
      borderStartStartRadius: `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`,
      borderStartEndRadius: `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`
    },
    "&:last-child": {
      borderEndStartRadius: `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`,
      borderEndEndRadius: `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`
    }
  },
  // focus indicator
  "&[data-focus-visible]": {
    "&::before": {
      backgroundColor: tokenSchema.color.background.accentEmphasis,
      borderRadius: tokenSchema.size.space.small,
      content: '""',
      insetInlineStart: tokenSchema.size.space.xsmall,
      marginBlock: tokenSchema.size.space.xsmall,
      marginInlineEnd: `calc(${tokenSchema.size.space.small} * -1)`,
      position: "sticky",
      width: tokenSchema.size.space.small,
      zIndex: 4
    }
  },
  // interactions
  [`&[data-hovered=true] ${tableViewClassList.selector("cell")}`]: {
    backgroundColor: tokenSchema.color.scale.slate2
  },
  [`&[data-pressed=true] ${tableViewClassList.selector("cell")}`]: {
    backgroundColor: tokenSchema.color.scale.slate3
    // backgroundColor: tokenSchema.color.alias.backgroundPressed,
  },
  [`&[data-disabled] ${tableViewClassList.selector("cell")}`]: {
    color: tokenSchema.color.alias.foregroundDisabled
  },
  // selected
  [`&[aria-selected="true"] ${tableViewClassList.selector("cell")}`]: {
    backgroundColor: tokenSchema.color.alias.backgroundSelected
  },
  [`&[aria-selected="true"][data-hovered=true] ${tableViewClassList.selector("cell")}`]: {
    backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
  }
});
var rowDragPreviewClassname = css({
  backgroundColor: tokenSchema.color.background.canvas,
  border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderSelected}`,
  borderRadius: tokenSchema.size.radius.small,
  paddingInline: tokenSchema.size.space.medium,
  position: "relative",
  outline: 0,
  width: tokenSchema.size.alias.singleLineWidth,
  // indicate that multiple items are being dragged by implying a stack
  "&[data-multi=true]::after": {
    backgroundColor: "inherit",
    border: "inherit",
    borderRadius: "inherit",
    content: '" "',
    display: "block",
    height: "100%",
    insetBlockStart: tokenSchema.size.space.small,
    insetInlineStart: tokenSchema.size.space.small,
    position: "absolute",
    width: "100%",
    zIndex: -1
  }
});
var commonCellStyles = css({
  boxSizing: "border-box",
  cursor: "default",
  display: "flex",
  height: "100%",
  justifyContent: "flex-start",
  minWidth: 0,
  outline: 0,
  paddingInline: tokenSchema.size.space.medium,
  position: "relative",
  textAlign: "start",
  // focus ring
  "&[data-focus=visible]": {
    borderRadius: tokenSchema.size.radius.small,
    inset: 0,
    outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`,
    outlineOffset: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`,
    position: "absolute"
  },
  // density
  paddingBlock: tokenSchema.size.space.regular,
  '&[data-density="compact"]': {
    paddingBlock: tokenSchema.size.space.small
  },
  '&[data-density="spacious"]': {
    paddingBlock: tokenSchema.size.space.medium
  },
  // alignment
  '&[data-align="end"]': {
    justifyContent: "flex-end",
    textAlign: "end"
  },
  '&[data-align="center"]': {
    justifyContent: "center",
    textAlign: "center"
  },
  // overflow mode
  '&[data-overflow-mode="truncate"]': {
    alignItems: "center"
  }
});
var cellWrapperClassname = css({
  [`${tableViewClassList.selector("body")} &`]: {
    backgroundColor: tokenSchema.color.background.canvas
  }
});
var cellClassname = classNames(tableViewClassList.element("cell"), commonCellStyles, css({
  color: tokenSchema.color.foreground.neutral
}));
css({
  // color: tokenSchema.color.foreground.neutral,
  // fontFamily: tokenSchema.typography.fontFamily.base,
  // fontSize: tokenSchema.typography.text.regular.size,
  minWidth: 0,
  flex: 1
});
var headerCellClassname = classNames(commonCellStyles, css({
  alignItems: "center",
  backgroundColor: tokenSchema.color.background.surface,
  color: tokenSchema.color.foreground.neutralSecondary,
  minWidth: 0,
  flex: 1,
  // SORTABLE
  ["&[aria-sort]"]: {
    display: "grid",
    gridTemplateAreas: '". sort-indicator"',
    '&[data-align="end"]': {
      gridTemplateAreas: '"sort-indicator ."'
    },
    "&[data-hovered=true]": {
      color: tokenSchema.color.foreground.neutralEmphasis
    }
  }
}));
var dragCellClassname = css({
  paddingInlineStart: tokenSchema.size.space.regular,
  paddingInlineEnd: 0
});
var checkboxCellClassname = css({
  paddingBlock: 0,
  paddingInlineEnd: tokenSchema.size.space.regular,
  label: {
    paddingInlineEnd: tokenSchema.size.space.regular,
    paddingBlock: tokenSchema.size.space.regular
  },
  '&[data-density="compact"]': {
    paddingBlock: 0,
    label: {
      paddingBlock: tokenSchema.size.space.small
    }
  },
  '&[data-density="spacious"]': {
    paddingBlock: 0,
    label: {
      paddingBlock: tokenSchema.size.space.medium
    }
  }
});
function DragPreview(props) {
  const $ = c2(13);
  const {
    itemText,
    itemCount,
    height,
    maxWidth
  } = props;
  const isDraggingMultiple = itemCount > 1;
  let t0;
  if ($[0] !== height || $[1] !== maxWidth) {
    t0 = {
      height,
      maxWidth
    };
    $[0] = height;
    $[1] = maxWidth;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] !== itemText) {
    t1 = (0, import_jsx_runtime11.jsx)(Text, {
      children: itemText
    });
    $[3] = itemText;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== isDraggingMultiple || $[6] !== itemCount) {
    t2 = isDraggingMultiple && (0, import_jsx_runtime11.jsx)(Flex, {
      alignItems: "center",
      backgroundColor: "accentEmphasis",
      borderRadius: "small",
      gridArea: "badge",
      justifyContent: "center",
      minWidth: "element.small",
      padding: "small",
      children: (0, import_jsx_runtime11.jsx)(Text, {
        align: "center",
        color: "inverse",
        size: "small",
        weight: "medium",
        children: itemCount
      })
    });
    $[5] = isDraggingMultiple;
    $[6] = itemCount;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  let t3;
  if ($[8] !== isDraggingMultiple || $[9] !== t0 || $[10] !== t1 || $[11] !== t2) {
    t3 = (0, import_jsx_runtime11.jsxs)(Flex, {
      alignItems: "center",
      justifyContent: "space-between",
      "data-multi": isDraggingMultiple,
      UNSAFE_className: rowDragPreviewClassname,
      UNSAFE_style: t0,
      children: [t1, t2]
    });
    $[8] = isDraggingMultiple;
    $[9] = t0;
    $[10] = t1;
    $[11] = t2;
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  return t3;
}
function InsertionIndicator(props) {
  var _Number, _rowProps$style, _Number2, _rowProps$style2;
  let {
    rowProps,
    target,
    visibleRect
  } = props;
  let {
    dropState,
    dragAndDropHooks
  } = useTableContext();
  let ref = (0, import_react5.useRef)(null);
  assert(!!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDropIndicator), "dragAndDropHooks.useDropIndicator is not defined.");
  assert(!!dropState, "dropState is not defined.");
  let {
    dropIndicatorProps
  } = dragAndDropHooks.useDropIndicator(props, dropState, ref);
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  let isDropTarget = dropState && dropState.isDropTarget(target);
  if (!isDropTarget && dropIndicatorProps["aria-hidden"]) {
    return null;
  }
  let rowTop = (_Number = Number(rowProps === null || rowProps === void 0 || (_rowProps$style = rowProps.style) === null || _rowProps$style === void 0 ? void 0 : _rowProps$style.top)) !== null && _Number !== void 0 ? _Number : 0;
  let rowHeight = (_Number2 = Number(rowProps === null || rowProps === void 0 || (_rowProps$style2 = rowProps.style) === null || _rowProps$style2 === void 0 ? void 0 : _rowProps$style2.height)) !== null && _Number2 !== void 0 ? _Number2 : 0;
  return (0, import_jsx_runtime11.jsx)("div", {
    style: {
      left: visibleRect.x,
      position: "absolute",
      top: rowTop + (target.dropPosition === "after" ? rowHeight : 0),
      width: visibleRect.width,
      zIndex: 4
    },
    role: "row",
    "aria-hidden": dropIndicatorProps["aria-hidden"],
    children: (0, import_jsx_runtime11.jsx)(InsertionIndicatorPrimitive, {
      role: "gridcell",
      isDropTarget,
      children: (0, import_jsx_runtime11.jsx)("div", {
        ...visuallyHiddenProps,
        role: "button",
        ...dropIndicatorProps,
        ref
      })
    })
  });
}
var localizedMessages = {
  "ar-AE": {
    "collapse": `طي`,
    "columnResizer": `أداة تغيير حجم العمود`,
    "drag": `سحب`,
    "expand": `مد`,
    "loading": `جارٍ التحميل...`,
    "loadingMore": `جارٍ تحميل المزيد...`,
    "resizeColumn": `تغيير حجم العمود`,
    "sortAscending": `فرز بترتيب تصاعدي`,
    "sortDescending": `فرز بترتيب تنازلي`
  },
  "bg-BG": {
    "collapse": `Свиване`,
    "columnResizer": `Преоразмеряване на колони`,
    "drag": `Плъзнете`,
    "expand": `Разширяване`,
    "loading": `Зареждане...`,
    "loadingMore": `Зареждане на още...`,
    "resizeColumn": `Преоразмеряване на колона`,
    "sortAscending": `Възходящо сортиране`,
    "sortDescending": `Низходящо сортиране `
  },
  "cs-CZ": {
    "collapse": `Zmenšit`,
    "columnResizer": `Změna velikosti sloupce`,
    "drag": `Přetáhnout`,
    "expand": `Roztáhnout`,
    "loading": `Načítání...`,
    "loadingMore": `Načítání dalších...`,
    "resizeColumn": `Změnit velikost sloupce`,
    "sortAscending": `Seřadit vzestupně`,
    "sortDescending": `Seřadit sestupně`
  },
  "da-DK": {
    "collapse": `Skjul`,
    "columnResizer": `Kolonneændring`,
    "drag": `Træk`,
    "expand": `Udvid`,
    "loading": `Indlæser ...`,
    "loadingMore": `Indlæser flere ...`,
    "resizeColumn": `Tilpas størrelse på kolonne`,
    "sortAscending": `Sorter stigende`,
    "sortDescending": `Sorter faldende`
  },
  "de-DE": {
    "collapse": `Reduzieren`,
    "columnResizer": `Spaltenanpassung`,
    "drag": `Ziehen`,
    "expand": `Erweitern`,
    "loading": `Laden...`,
    "loadingMore": `Mehr laden ...`,
    "resizeColumn": `Spaltengröße ändern`,
    "sortAscending": `Aufsteigend sortieren`,
    "sortDescending": `Absteigend sortieren`
  },
  "el-GR": {
    "collapse": `Σύμπτυξη`,
    "columnResizer": `Αλλαγή μεγέθους στήλης`,
    "drag": `Μεταφορά`,
    "expand": `Ανάπτυξη`,
    "loading": `Φόρτωση...`,
    "loadingMore": `Φόρτωση περισσότερων...`,
    "resizeColumn": `Αλλαγή μεγέθους στήλης`,
    "sortAscending": `Ταξινόμηση κατά αύξουσα σειρά`,
    "sortDescending": `Ταξινόμηση κατά φθίνουσα σειρά`
  },
  "en-US": {
    "loading": `Loading…`,
    "loadingMore": `Loading more…`,
    "sortAscending": `Sort Ascending`,
    "sortDescending": `Sort Descending`,
    "resizeColumn": `Resize column`,
    "columnResizer": `Column resizer`,
    "drag": `Drag`,
    "expand": `Expand`,
    "collapse": `Collapse`
  },
  "es-ES": {
    "collapse": `Contraer`,
    "columnResizer": `Redimensionador de columnas`,
    "drag": `Arrastrar`,
    "expand": `Ampliar`,
    "loading": `Cargando…`,
    "loadingMore": `Cargando más…`,
    "resizeColumn": `Cambiar el tamaño de la columna`,
    "sortAscending": `Orden de subida`,
    "sortDescending": `Orden de bajada`
  },
  "et-EE": {
    "collapse": `Ahenda`,
    "columnResizer": `Veeru suuruse muutja`,
    "drag": `Lohista`,
    "expand": `Laienda`,
    "loading": `Laadimine...`,
    "loadingMore": `Laadi rohkem...`,
    "resizeColumn": `Muuda veeru suurust`,
    "sortAscending": `Sordi kasvavalt`,
    "sortDescending": `Sordi kahanevalt`
  },
  "fi-FI": {
    "collapse": `Pienennä`,
    "columnResizer": `Sarakekoon muuttaja`,
    "drag": `Vedä`,
    "expand": `Laajenna`,
    "loading": `Ladataan…`,
    "loadingMore": `Ladataan lisää…`,
    "resizeColumn": `Muuta sarakkeen kokoa`,
    "sortAscending": `Lajittelujärjestys: nouseva`,
    "sortDescending": `Lajittelujärjestys: laskeva`
  },
  "fr-FR": {
    "collapse": `Réduire`,
    "columnResizer": `Redimensionnement de colonne`,
    "drag": `Faire glisser`,
    "expand": `Développer`,
    "loading": `Chargement...`,
    "loadingMore": `Chargement supplémentaire...`,
    "resizeColumn": `Redimensionner la colonne`,
    "sortAscending": `Trier par ordre croissant`,
    "sortDescending": `Trier par ordre décroissant`
  },
  "he-IL": {
    "collapse": `כווץ`,
    "columnResizer": `שינוי גודל עמודה`,
    "drag": `גרור`,
    "expand": `הרחב`,
    "loading": `טוען...`,
    "loadingMore": `טוען עוד...`,
    "resizeColumn": `שנה את גודל העמודה`,
    "sortAscending": `מיין בסדר עולה`,
    "sortDescending": `מיין בסדר יורד`
  },
  "hr-HR": {
    "collapse": `Sažmi`,
    "columnResizer": `Alat za promjenu veličine stupca`,
    "drag": `Povucite`,
    "expand": `Proširi`,
    "loading": `Učitavam...`,
    "loadingMore": `Učitavam još...`,
    "resizeColumn": `Promijeni veličinu stupca`,
    "sortAscending": `Sortiraj uzlazno`,
    "sortDescending": `Sortiraj silazno`
  },
  "hu-HU": {
    "collapse": `Összecsukás`,
    "columnResizer": `Oszlopátméretező`,
    "drag": `Húzás`,
    "expand": `Kibontás`,
    "loading": `Betöltés folyamatban…`,
    "loadingMore": `Továbbiak betöltése folyamatban…`,
    "resizeColumn": `Oszlop átméretezése`,
    "sortAscending": `Növekvő rendezés`,
    "sortDescending": `Csökkenő rendezés`
  },
  "it-IT": {
    "collapse": `Comprimi`,
    "columnResizer": `Ridimensionamento colonne`,
    "drag": `Trascina`,
    "expand": `Espandi`,
    "loading": `Caricamento...`,
    "loadingMore": `Caricamento altri...`,
    "resizeColumn": `Ridimensiona colonna`,
    "sortAscending": `Ordinamento crescente`,
    "sortDescending": `Ordinamento decrescente`
  },
  "ja-JP": {
    "collapse": `折りたたむ`,
    "columnResizer": `列リサイザー`,
    "drag": `ドラッグ`,
    "expand": `展開`,
    "loading": `読み込み中...`,
    "loadingMore": `さらに読み込み中...`,
    "resizeColumn": `列幅を変更`,
    "sortAscending": `昇順に並べ替え`,
    "sortDescending": `降順に並べ替え`
  },
  "ko-KR": {
    "collapse": `접기`,
    "columnResizer": `열 크기 조정기`,
    "drag": `드래그`,
    "expand": `펼치기`,
    "loading": `로드 중`,
    "loadingMore": `추가 로드 중`,
    "resizeColumn": `열 크기 조정`,
    "sortAscending": `오름차순 정렬`,
    "sortDescending": `내림차순 정렬`
  },
  "lt-LT": {
    "collapse": `Sutraukti`,
    "columnResizer": `Stulpelio dydžio keitiklis`,
    "drag": `Vilkti`,
    "expand": `Išskleisti`,
    "loading": `Įkeliama...`,
    "loadingMore": `Įkeliama daugiau...`,
    "resizeColumn": `Keisti stulpelio dydį`,
    "sortAscending": `Rikiuoti didėjimo tvarka`,
    "sortDescending": `Rikiuoti mažėjimo tvarka`
  },
  "lv-LV": {
    "collapse": `Sakļaut`,
    "columnResizer": `Kolonnas izmēru mainītājs`,
    "drag": `Vilkšana`,
    "expand": `Izvērst`,
    "loading": `Notiek ielāde...`,
    "loadingMore": `Tiek ielādēts vēl...`,
    "resizeColumn": `Mainīt kolonnas lielumu`,
    "sortAscending": `Kārtot augošā secībā`,
    "sortDescending": `Kārtot dilstošā secībā`
  },
  "nb-NO": {
    "collapse": `Skjul`,
    "columnResizer": `Størrelsesendring av kolonne`,
    "drag": `Dra`,
    "expand": `Utvid`,
    "loading": `Laster inn ...`,
    "loadingMore": `Laster inn flere ...`,
    "resizeColumn": `Endre størrelse på kolonne`,
    "sortAscending": `Sorter stigende`,
    "sortDescending": `Sorter synkende`
  },
  "nl-NL": {
    "collapse": `Samenvouwen`,
    "columnResizer": `Groottewijziging van kolom`,
    "drag": `Slepen`,
    "expand": `Uitvouwen`,
    "loading": `Laden...`,
    "loadingMore": `Meer laden...`,
    "resizeColumn": `Kolomgrootte wijzigen`,
    "sortAscending": `Oplopend sorteren`,
    "sortDescending": `Aflopend sorteren`
  },
  "pl-PL": {
    "collapse": `Zwiń`,
    "columnResizer": `Narzędzie zmiany rozmiaru kolumny`,
    "drag": `Przeciągnij`,
    "expand": `Rozwiń`,
    "loading": `Ładowanie...`,
    "loadingMore": `Wczytywanie większej liczby...`,
    "resizeColumn": `Zmień rozmiar kolumny`,
    "sortAscending": `Sortuj rosnąco`,
    "sortDescending": `Sortuj malejąco`
  },
  "pt-BR": {
    "collapse": `Recolher`,
    "columnResizer": `Redimensionamento de colunas`,
    "drag": `Arraste`,
    "expand": `Expandir`,
    "loading": `Carregando...`,
    "loadingMore": `Carregando mais...`,
    "resizeColumn": `Redimensionar coluna`,
    "sortAscending": `Ordenar por ordem crescente`,
    "sortDescending": `Ordenar por ordem decrescente`
  },
  "pt-PT": {
    "collapse": `Colapsar`,
    "columnResizer": `Redimensionador de coluna`,
    "drag": `Arrastar`,
    "expand": `Expandir`,
    "loading": `A carregar...`,
    "loadingMore": `A carregar mais...`,
    "resizeColumn": `Redimensionar coluna`,
    "sortAscending": `Ordenar por ordem ascendente`,
    "sortDescending": `Ordenar por ordem decrescente`
  },
  "ro-RO": {
    "collapse": `Restrângeți`,
    "columnResizer": `Instrument redimensionare coloane`,
    "drag": `Trageți`,
    "expand": `Extindeți`,
    "loading": `Se încarcă...`,
    "loadingMore": `Se încarcă mai multe...`,
    "resizeColumn": `Redimensionați coloana`,
    "sortAscending": `Sortați crescător`,
    "sortDescending": `Sortați descrescător`
  },
  "ru-RU": {
    "collapse": `Свернуть`,
    "columnResizer": `Средство изменения размера столбцов`,
    "drag": `Перетаскивание`,
    "expand": `Развернуть`,
    "loading": `Загрузка...`,
    "loadingMore": `Дополнительная загрузка...`,
    "resizeColumn": `Изменить размер столбца`,
    "sortAscending": `Сортировать по возрастанию`,
    "sortDescending": `Сортировать по убыванию`
  },
  "sk-SK": {
    "collapse": `Zbaliť`,
    "columnResizer": `Nástroj na zmenu veľkosti stĺpcov`,
    "drag": `Presunúť`,
    "expand": `Rozbaliť`,
    "loading": `Načítava sa...`,
    "loadingMore": `Načítava sa viac...`,
    "resizeColumn": `Zmeniť veľkosť stĺpca`,
    "sortAscending": `Zoradiť vzostupne`,
    "sortDescending": `Zoradiť zostupne`
  },
  "sl-SI": {
    "collapse": `Strni`,
    "columnResizer": `Prilagojevalnik velikosti stolpcev`,
    "drag": `Povleci`,
    "expand": `Razširi`,
    "loading": `Nalaganje...`,
    "loadingMore": `Nalaganje več vsebine...`,
    "resizeColumn": `Spremeni velikost stolpca`,
    "sortAscending": `Razvrsti naraščajoče`,
    "sortDescending": `Razvrsti padajoče`
  },
  "sr-SP": {
    "collapse": `Sažmi`,
    "columnResizer": `Alat za promenu veličine kolone`,
    "drag": `Prevuci`,
    "expand": `Proširi`,
    "loading": `Učitavam...`,
    "loadingMore": `Učitavam još...`,
    "resizeColumn": `Promeni veličinu kolone`,
    "sortAscending": `Sortiraj po rastućem redosledu`,
    "sortDescending": `Sortiraj po opadajućem redosledu`
  },
  "sv-SE": {
    "collapse": `Dölj`,
    "columnResizer": `Ändra storlek på kolumn`,
    "drag": `Dra`,
    "expand": `Expandera`,
    "loading": `Läser in...`,
    "loadingMore": `Läser in mer...`,
    "resizeColumn": `Ändra storlek på kolumn`,
    "sortAscending": `Sortera i stigande ordning`,
    "sortDescending": `Sortera i fallande ordning`
  },
  "tr-TR": {
    "collapse": `Daralt`,
    "columnResizer": `Yeniden sütun boyutlandırıcı`,
    "drag": `Sürükle`,
    "expand": `Genişlet`,
    "loading": `Yükleniyor...`,
    "loadingMore": `Daha fazla yükleniyor...`,
    "resizeColumn": `Sütunu yeniden boyutlandır`,
    "sortAscending": `Artan Sıralama`,
    "sortDescending": `Azalan Sıralama`
  },
  "uk-UA": {
    "collapse": `Згорнути`,
    "columnResizer": `Засіб змінення розміру стовпця`,
    "drag": `Перетягнути`,
    "expand": `Розгорнути`,
    "loading": `Завантаження…`,
    "loadingMore": `Завантаження інших об’єктів...`,
    "resizeColumn": `Змінити розмір стовпця`,
    "sortAscending": `Сортувати за зростанням`,
    "sortDescending": `Сортувати за спаданням`
  },
  "zh-CN": {
    "collapse": `折叠`,
    "columnResizer": `列尺寸调整器`,
    "drag": `拖动`,
    "expand": `扩展`,
    "loading": `正在加载...`,
    "loadingMore": `正在加载更多...`,
    "resizeColumn": `调整列大小`,
    "sortAscending": `升序排序`,
    "sortDescending": `降序排序`
  },
  "zh-TW": {
    "collapse": `收合`,
    "columnResizer": `欄大小調整器`,
    "drag": `拖曳`,
    "expand": `展開`,
    "loading": `正在載入`,
    "loadingMore": `正在載入更多…`,
    "resizeColumn": `調整欄大小`,
    "sortAscending": `升序排序`,
    "sortDescending": `降序排序`
  }
};
var CURSORS = {
  ew: "col-resize",
  w: "w-resize",
  e: "e-resize"
};
var ResizeStateContext = (0, import_react5.createContext)(null);
function useResizeStateContext() {
  const context = (0, import_react5.useContext)(ResizeStateContext);
  if (context === null) {
    throw new Error("ResizeStateContext not found");
  }
  return context;
}
function Resizer(props, forwardedRef) {
  const $ = c2(29);
  const {
    column,
    showResizer
  } = props;
  const {
    isEmpty,
    onFocusedResizer
  } = useTableContext();
  const layout = (0, import_react5.useContext)(ResizeStateContext);
  useVirtualizerContext();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const [isPointerDown, setIsPointerDown] = (0, import_react5.useState)(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      const setDown = (e2) => {
        if (e2.pointerType === "mouse") {
          setIsPointerDown(true);
        }
      };
      const setUp = (e_0) => {
        if (e_0.pointerType === "mouse") {
          setIsPointerDown(false);
        }
      };
      document.addEventListener("pointerdown", setDown, {
        capture: true
      });
      document.addEventListener("pointerup", setUp, {
        capture: true
      });
      return () => {
        document.removeEventListener("pointerdown", setDown, {
          capture: true
        });
        document.removeEventListener("pointerup", setUp, {
          capture: true
        });
      };
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  (0, import_react5.useEffect)(t0, t1);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let t2;
  if ($[2] !== stringFormatter || $[3] !== isEmpty || $[4] !== props) {
    t2 = $3ef42575df84b30b$export$9d1611c77c2fe928(props, {
      "aria-label": stringFormatter.format("columnResizer"),
      isDisabled: isEmpty
    });
    $[2] = stringFormatter;
    $[3] = isEmpty;
    $[4] = props;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const {
    inputProps,
    resizerProps
  } = $e91ef4e5004e3774$export$52994e973806c219(t2, layout, domRef);
  const isEResizable = layout.getColumnMinWidth(column.key) >= layout.getColumnWidth(column.key);
  const isWResizable = layout.getColumnMaxWidth(column.key) <= layout.getColumnWidth(column.key);
  const isResizing = layout.resizingColumn === column.key;
  let cursor;
  if (isEResizable) {
    cursor = direction === "rtl" ? CURSORS.w : CURSORS.e;
  } else {
    if (isWResizable) {
      cursor = direction === "rtl" ? CURSORS.e : CURSORS.w;
    } else {
      cursor = CURSORS.ew;
    }
  }
  const t3 = showResizer ? void 0 : "none";
  let t4;
  if ($[6] !== resizerProps.style || $[7] !== t3 || $[8] !== cursor) {
    t4 = {
      ...resizerProps.style,
      height: "100%",
      display: t3,
      cursor
    };
    $[6] = resizerProps.style;
    $[7] = t3;
    $[8] = cursor;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  const style = t4;
  let t5;
  if ($[10] !== onFocusedResizer || $[11] !== inputProps) {
    t5 = $3ef42575df84b30b$export$9d1611c77c2fe928(inputProps, {
      onFocus: onFocusedResizer
    });
    $[10] = onFocusedResizer;
    $[11] = inputProps;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== domRef || $[14] !== t5) {
    t6 = (0, import_jsx_runtime11.jsx)("input", {
      ref: domRef,
      ...t5
    });
    $[13] = domRef;
    $[14] = t5;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  let t7;
  if ($[16] !== resizerProps || $[17] !== style || $[18] !== t6) {
    t7 = (0, import_jsx_runtime11.jsx)($907718708eab68af$export$1a38b4ad7f578e1d, {
      within: true,
      focusRingClass: "focus-ring",
      children: (0, import_jsx_runtime11.jsx)("div", {
        ...resizerProps,
        role: "presentation",
        style,
        className: columnResizerClassname,
        children: t6
      })
    });
    $[16] = resizerProps;
    $[17] = style;
    $[18] = t6;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  let t8;
  if ($[20] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime11.jsx)("div", {
      "aria-hidden": true,
      role: "presentation",
      className: columnResizerPlaceholderClassname
    });
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  const t9 = isResizing && isPointerDown;
  let t10;
  if ($[21] !== cursor) {
    t10 = (0, import_jsx_runtime11.jsx)("div", {
      style: {
        bottom: 0,
        cursor,
        left: 0,
        position: "fixed",
        right: 0,
        top: 0
      }
    });
    $[21] = cursor;
    $[22] = t10;
  } else {
    t10 = $[22];
  }
  let t11;
  if ($[23] !== t9 || $[24] !== t10) {
    t11 = (0, import_jsx_runtime11.jsx)(CursorOverlay, {
      show: t9,
      children: t10
    });
    $[23] = t9;
    $[24] = t10;
    $[25] = t11;
  } else {
    t11 = $[25];
  }
  let t12;
  if ($[26] !== t7 || $[27] !== t11) {
    t12 = (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, {
      children: [t7, t8, t11]
    });
    $[26] = t7;
    $[27] = t11;
    $[28] = t12;
  } else {
    t12 = $[28];
  }
  return t12;
}
function CursorOverlay(props) {
  const $ = c2(4);
  const {
    show,
    children
  } = props;
  const {
    getContainer
  } = $96b38030c423d352$export$574e9b0fb070c3b0();
  let t0;
  if ($[0] !== show || $[1] !== getContainer || $[2] !== children) {
    var _getContainer;
    t0 = show ? import_react_dom.default.createPortal(children, (_getContainer = getContainer === null || getContainer === void 0 ? void 0 : getContainer()) !== null && _getContainer !== void 0 ? _getContainer : document.body) : null;
    $[0] = show;
    $[1] = getContainer;
    $[2] = children;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}
var _Resizer = import_react5.default.forwardRef(Resizer);
var TableViewLayout = class extends $a152112e902709bf$export$62444c3c724b1b20 {
  constructor() {
    super(...arguments);
    __publicField(this, "isLoading", false);
  }
  buildCollection() {
    let loadingState = this.collection.body.props.loadingState;
    this.isLoading = loadingState === "loading" || loadingState === "loadingMore";
    return super.buildCollection();
  }
  buildColumn(node, x2, y) {
    let res = super.buildColumn(node, x2, y);
    res.layoutInfo.allowOverflow = true;
    return res;
  }
  buildBody() {
    let node = super.buildBody(0);
    let {
      children,
      layoutInfo
    } = node;
    let width = node.layoutInfo.rect.width;
    if (this.isLoading) {
      let rect = new $60423f92c7f9ad87$export$c79fc6492f3af13d(40, (children === null || children === void 0 ? void 0 : children.length) === 0 ? 40 : layoutInfo.rect.maxY, (width || this.virtualizer.visibleRect.width) - 80, (children === null || children === void 0 ? void 0 : children.length) === 0 ? this.virtualizer.visibleRect.height - 80 : 60);
      let loader2 = new $d7fd61009c21d0bb$export$7e0eeb9da702a085("loader", "loader", rect);
      loader2.parentKey = layoutInfo.key;
      loader2.isSticky = (children === null || children === void 0 ? void 0 : children.length) === 0;
      let node2 = {
        layoutInfo: loader2,
        validRect: loader2.rect
      };
      children === null || children === void 0 || children.push(node2);
      this.layoutNodes.set(loader2.key, node2);
      layoutInfo.rect.height = loader2.rect.maxY;
      width = Math.max(width, rect.width);
    } else if ((children === null || children === void 0 ? void 0 : children.length) === 0) {
      let rect = new $60423f92c7f9ad87$export$c79fc6492f3af13d(40, 40, this.virtualizer.visibleRect.width - 80, this.virtualizer.visibleRect.height - 80);
      let empty2 = new $d7fd61009c21d0bb$export$7e0eeb9da702a085("empty", "empty", rect);
      empty2.parentKey = layoutInfo.key;
      empty2.isSticky = true;
      let node2 = {
        layoutInfo: empty2,
        validRect: empty2.rect
      };
      children.push(node2);
      layoutInfo.rect.height = empty2.rect.maxY;
      width = Math.max(width, rect.width);
    }
    return node;
  }
  buildRow(node, x2, y) {
    let res = super.buildRow(node, x2, y);
    res.layoutInfo.rect.height += 1;
    return res;
  }
  buildCell(node, x2, y) {
    var _node$column;
    let res = super.buildCell(node, x2, y);
    if ((_node$column = node.column) !== null && _node$column !== void 0 && _node$column.props.hideHeader) {
      res.layoutInfo.allowOverflow = true;
    }
    return res;
  }
  getEstimatedRowHeight() {
    return super.getEstimatedRowHeight() + 1;
  }
  isStickyColumn(node) {
    var _node$props, _node$props2;
    return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.isDragButtonCell) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.isSelectionCell);
  }
  getDropTargetFromPoint(x2, y, isValidDropTarget) {
    var _this$virtualizer$lay;
    let headerRowHeight = (_this$virtualizer$lay = this.virtualizer.layout.getVisibleLayoutInfos(new $60423f92c7f9ad87$export$c79fc6492f3af13d(x2, y, 1, 1)).find((info) => info.type === "headerrow")) === null || _this$virtualizer$lay === void 0 ? void 0 : _this$virtualizer$lay.rect.height;
    if (headerRowHeight) {
      y -= headerRowHeight;
    }
    return super.getDropTargetFromPoint(x2, y, isValidDropTarget);
  }
};
var DEFAULT_HEADER_HEIGHT = 36;
var DEFAULT_HIDE_HEADER_CELL_WIDTH = 36;
var SELECTION_CELL_DEFAULT_WIDTH = 36;
var DRAG_BUTTON_CELL_DEFAULT_WIDTH = 20;
var ROW_HEIGHTS = {
  compact: 28,
  regular: 36,
  spacious: 44
};
function TableView(props) {
  var _dropState, _droppableCollection, _dragAndDropHooks$isV, _props$onResize, _dragAndDropHooks$isV2, _dragAndDropHooks$isV3;
  let {
    density = "regular",
    prominence = "default",
    dragAndDropHooks,
    onAction,
    onResizeEnd: propsOnResizeEnd,
    onResizeStart: propsOnResizeStart,
    overflowMode = "truncate"
  } = props;
  let isTableDraggable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollectionState);
  let isTableDroppable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollectionState);
  let dragHooksProvided = (0, import_react5.useRef)(isTableDraggable);
  let dropHooksProvided = (0, import_react5.useRef)(isTableDroppable);
  let state = $4a0dd036d492cee4$export$907bcc6c48325fd6({
    ...props,
    showSelectionCheckboxes: true,
    showDragButtons: isTableDraggable,
    selectionBehavior: "toggle"
  });
  (0, import_react5.useEffect)(() => {
    if (dragHooksProvided.current !== isTableDraggable) {
      console.warn("Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
    }
    if (dropHooksProvided.current !== isTableDroppable) {
      console.warn("Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
    }
    if ("expandedKeys" in state && (isTableDraggable || isTableDroppable)) {
      console.warn("Drag and drop is not yet fully supported with expandable rows and may produce unexpected results.");
    }
  }, [isTableDraggable, isTableDroppable, state]);
  let [isInResizeMode, setIsInResizeMode] = (0, import_react5.useState)(false);
  let [, setIsResizing] = (0, import_react5.useState)(false);
  let domRef = (0, import_react5.useRef)(null);
  let headerRef = (0, import_react5.useRef)(null);
  let bodyRef = (0, import_react5.useRef)(null);
  let styleProps = useStyleProps(props);
  let layout = (0, import_react5.useMemo)(() => new TableViewLayout({
    // If props.overflowMode is wrap, then use estimated heights based on scale, otherwise use fixed heights.
    rowHeight: props.overflowMode === "wrap" ? void 0 : ROW_HEIGHTS[density],
    estimatedRowHeight: props.overflowMode === "wrap" ? ROW_HEIGHTS[density] : void 0,
    headingHeight: props.overflowMode === "wrap" ? void 0 : DEFAULT_HEADER_HEIGHT,
    estimatedHeadingHeight: props.overflowMode === "wrap" ? DEFAULT_HEADER_HEIGHT : void 0
  }), [props.overflowMode, density]);
  let dragState = void 0;
  let preview = (0, import_react5.useRef)(null);
  if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollection && dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollectionState) {
    dragState = dragAndDropHooks.useDraggableCollectionState({
      collection: state.collection,
      selectionManager: state.selectionManager,
      preview
    });
    dragAndDropHooks.useDraggableCollection({}, dragState, domRef);
  }
  let DragPreview$1 = dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.DragPreview;
  let dropState = void 0;
  let droppableCollection = void 0;
  let isRootDropTarget = false;
  if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollection && dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollectionState) {
    dropState = dragAndDropHooks.useDroppableCollectionState({
      collection: state.collection,
      selectionManager: state.selectionManager
    });
    droppableCollection = dragAndDropHooks.useDroppableCollection({
      keyboardDelegate: new $2a25aae57d74318e$export$a05409b8bb224a5a({
        collection: state.collection,
        disabledKeys: state.selectionManager.disabledKeys,
        ref: domRef,
        layoutDelegate: layout
      }),
      dropTargetDelegate: layout
    }, dropState, domRef);
    isRootDropTarget = dropState.isDropTarget({
      type: "root"
    });
  }
  let {
    gridProps
  } = $6e31608fbba75bab$export$25bceaac3c7e4dc7({
    ...props,
    isVirtualized: true,
    layoutDelegate: layout,
    onRowAction: onAction !== null && onAction !== void 0 ? onAction : props.onRowAction,
    scrollRef: bodyRef
  }, state, domRef);
  let [headerMenuOpen, setHeaderMenuOpen] = (0, import_react5.useState)(false);
  let [headerRowHovered, setHeaderRowHovered] = (0, import_react5.useState)(false);
  let renderWrapper = (0, import_react5.useCallback)((parent, reusableView, children, renderChildren2) => {
    if (reusableView.viewType === "rowgroup") {
      return (0, import_jsx_runtime11.jsx)(TableBody, {
        layoutInfo: reusableView.layoutInfo,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
        role: "presentation",
        children: renderChildren2(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "header") {
      return (0, import_jsx_runtime11.jsx)(TableHead, {
        layoutInfo: reusableView.layoutInfo,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
        children: renderChildren2(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "row") {
      return (0, import_jsx_runtime11.jsx)(TableRow, {
        item: reusableView.content,
        layoutInfo: reusableView.layoutInfo,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
        children: renderChildren2(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "headerrow") {
      return (0, import_jsx_runtime11.jsx)(TableHeaderRow, {
        onHoverChange: setHeaderRowHovered,
        // @ts-expect-error
        layoutInfo: reusableView.layoutInfo,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
        item: reusableView.content,
        children: renderChildren2(children)
      }, reusableView.key);
    }
    return (0, import_jsx_runtime11.jsx)(TableCellWrapper, {
      // @ts-expect-error
      layoutInfo: reusableView.layoutInfo,
      virtualizer: reusableView.virtualizer,
      parent,
      children: reusableView.rendered
    }, reusableView.key);
  }, []);
  let renderView = (0, import_react5.useCallback)((type3, item) => {
    switch (type3) {
      case "header":
      case "rowgroup":
      case "section":
      case "row":
      case "headerrow":
        return null;
      case "cell": {
        if (item.props.isSelectionCell) {
          return (0, import_jsx_runtime11.jsx)(TableCheckboxCell, {
            cell: item
          });
        }
        if (item.props.isDragButtonCell) {
          return (0, import_jsx_runtime11.jsx)(TableDragCell, {
            cell: item
          });
        }
        return (0, import_jsx_runtime11.jsx)(TableCell, {
          cell: item
        });
      }
      case "placeholder":
        return (0, import_jsx_runtime11.jsx)("div", {
          role: "gridcell",
          "aria-colindex": item.index && item.index + 1,
          "aria-colspan": item.colspan && item.colspan > 1 ? item.colspan : void 0
        });
      case "column":
        if (item.props.isSelectionCell) {
          return (0, import_jsx_runtime11.jsx)(TableSelectAllCell, {
            column: item
          });
        }
        if (item.props.isDragButtonCell) {
          return (0, import_jsx_runtime11.jsx)(TableDragHeaderCell, {
            column: item
          });
        }
        if (item.props.hideHeader) {
          return (0, import_jsx_runtime11.jsxs)(_TooltipTrigger, {
            placement: "top",
            trigger: "focus",
            children: [(0, import_jsx_runtime11.jsx)(TableColumnHeader, {
              column: item
            }), (0, import_jsx_runtime11.jsx)(Tooltip, {
              children: item.rendered
            })]
          });
        }
        if (item.props.allowsResizing && !!item.nextKey) {
          return (0, import_jsx_runtime11.jsx)(ResizableTableColumnHeader, {
            column: item
          });
        }
        return (0, import_jsx_runtime11.jsx)(TableColumnHeader, {
          column: item
        });
      case "loader":
        return (0, import_jsx_runtime11.jsx)(LoadingState, {});
      case "empty": {
        return (0, import_jsx_runtime11.jsx)(EmptyState, {});
      }
      default: {
        return null;
      }
    }
  }, []);
  let [isVerticalScrollbarVisible, setVerticalScollbarVisible] = (0, import_react5.useState)(false);
  let [isHorizontalScrollbarVisible, setHorizontalScollbarVisible] = (0, import_react5.useState)(false);
  let viewport = (0, import_react5.useRef)({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  let onVisibleRectChange = (0, import_react5.useCallback)((rect) => {
    if (viewport.current.width === rect.width && viewport.current.height === rect.height) {
      return;
    }
    viewport.current = rect;
    if (bodyRef.current) {
      setVerticalScollbarVisible(bodyRef.current.clientWidth + 2 < bodyRef.current.offsetWidth);
      setHorizontalScollbarVisible(bodyRef.current.clientHeight + 2 < bodyRef.current.offsetHeight);
    }
  }, []);
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let isEmpty = state.collection.size === 0;
  let onFocusedResizer = () => {
    if (bodyRef.current && headerRef.current) {
      bodyRef.current.scrollLeft = headerRef.current.scrollLeft;
    }
  };
  let onResizeStart = (0, import_react5.useCallback)((widths) => {
    setIsResizing(true);
    propsOnResizeStart === null || propsOnResizeStart === void 0 || propsOnResizeStart(widths);
  }, [setIsResizing, propsOnResizeStart]);
  let onResizeEnd = (0, import_react5.useCallback)((widths_0) => {
    setIsInResizeMode(false);
    setIsResizing(false);
    propsOnResizeEnd === null || propsOnResizeEnd === void 0 || propsOnResizeEnd(widths_0);
  }, [propsOnResizeEnd, setIsInResizeMode, setIsResizing]);
  let focusedKey = state.selectionManager.focusedKey;
  let dropTargetKey = null;
  if (((_dropState = dropState) === null || _dropState === void 0 || (_dropState = _dropState.target) === null || _dropState === void 0 ? void 0 : _dropState.type) === "item") {
    dropTargetKey = dropState.target.key;
    if (dropState.target.dropPosition === "before" && dropTargetKey !== state.collection.getFirstKey()) {
      dropTargetKey = state.collection.getKeyBefore(dropTargetKey);
    }
  }
  let persistedKeys = (0, import_react5.useMemo)(() => {
    return new Set([focusedKey, dropTargetKey].filter((k2) => k2 !== null));
  }, [focusedKey, dropTargetKey]);
  let mergedProps = $3ef42575df84b30b$export$9d1611c77c2fe928(isTableDroppable ? (_droppableCollection = droppableCollection) === null || _droppableCollection === void 0 ? void 0 : _droppableCollection.collectionProps : {}, gridProps, focusProps);
  if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && (_dragAndDropHooks$isV = dragAndDropHooks.isVirtualDragging) !== null && _dragAndDropHooks$isV !== void 0 && _dragAndDropHooks$isV.call(dragAndDropHooks)) {
    delete mergedProps.tabIndex;
  }
  let cosmeticConfig = {
    density,
    overflowMode,
    prominence
  };
  return (0, import_jsx_runtime11.jsxs)(TableContext.Provider, {
    value: {
      cosmeticConfig,
      dragAndDropHooks,
      dragState,
      dropState,
      headerMenuOpen,
      headerRowHovered,
      isEmpty,
      isInResizeMode,
      isTableDraggable,
      isTableDroppable,
      layout,
      onFocusedResizer,
      onResize: (_props$onResize = props.onResize) !== null && _props$onResize !== void 0 ? _props$onResize : () => {
      },
      onResizeEnd,
      onResizeStart,
      renderEmptyState: props.renderEmptyState,
      setHeaderMenuOpen,
      setIsInResizeMode,
      state
    },
    children: [(0, import_jsx_runtime11.jsx)(TableVirtualizer, {
      ...mergedProps,
      ...styleProps,
      ...toDataAttributes({
        ...cosmeticConfig,
        scrollbar: isVerticalScrollbarVisible && isHorizontalScrollbarVisible ? "both" : isVerticalScrollbarVisible ? "vertical" : isHorizontalScrollbarVisible ? "horizontal" : void 0
      }),
      className: classNames(tableClassname, styleProps.className),
      tableState: state,
      cosmeticConfig,
      layout,
      collection: state.collection,
      persistedKeys,
      renderView,
      renderWrapper,
      onVisibleRectChange,
      domRef,
      headerRef,
      bodyRef,
      isFocusVisible,
      isVirtualDragging: (_dragAndDropHooks$isV2 = dragAndDropHooks === null || dragAndDropHooks === void 0 || (_dragAndDropHooks$isV3 = dragAndDropHooks.isVirtualDragging) === null || _dragAndDropHooks$isV3 === void 0 ? void 0 : _dragAndDropHooks$isV3.call(dragAndDropHooks)) !== null && _dragAndDropHooks$isV2 !== void 0 ? _dragAndDropHooks$isV2 : false,
      isRootDropTarget
    }), DragPreview$1 && isTableDraggable && (0, import_jsx_runtime11.jsx)(DragPreview$1, {
      ref: preview,
      children: () => {
        var _dragState, _dragState$draggingKe, _dragState2, _bodyRef$current, _state$collection$get, _state$collection, _dragState3;
        if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.renderPreview && (_dragState = dragState) !== null && _dragState !== void 0 && _dragState.draggingKeys) {
          return dragAndDropHooks.renderPreview(dragState.draggingKeys, dragState.draggedKey);
        }
        let itemCount = (_dragState$draggingKe = (_dragState2 = dragState) === null || _dragState2 === void 0 ? void 0 : _dragState2.draggingKeys.size) !== null && _dragState$draggingKe !== void 0 ? _dragState$draggingKe : 0;
        let maxWidth = bodyRef === null || bodyRef === void 0 || (_bodyRef$current = bodyRef.current) === null || _bodyRef$current === void 0 ? void 0 : _bodyRef$current.getBoundingClientRect().width;
        let height = ROW_HEIGHTS[density];
        let itemText = (_state$collection$get = (_state$collection = state.collection).getTextValue) === null || _state$collection$get === void 0 ? void 0 : _state$collection$get.call(_state$collection, (_dragState3 = dragState) === null || _dragState3 === void 0 ? void 0 : _dragState3.draggedKey);
        return (0, import_jsx_runtime11.jsx)(DragPreview, {
          itemText,
          itemCount,
          height,
          maxWidth
        });
      }
    })]
  });
}
function TableVirtualizer(props) {
  var _layout$getLayoutInfo;
  let {
    cosmeticConfig,
    tableState,
    layout,
    collection,
    persistedKeys,
    renderView,
    renderWrapper,
    domRef,
    bodyRef,
    headerRef,
    onVisibleRectChange: onVisibleRectChangeProp,
    isFocusVisible,
    isVirtualDragging,
    isRootDropTarget,
    ...otherProps
  } = props;
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let loadingState = collection.body.props.loadingState;
  let isLoading = loadingState === "loading" || loadingState === "loadingMore";
  let onLoadMore = collection.body.props.onLoadMore;
  let [tableWidth, setTableWidth] = (0, import_react5.useState)(0);
  const slots = (0, import_react5.useMemo)(() => {
    return {
      text: {
        truncate: cosmeticConfig.overflowMode === "truncate"
      }
    };
  }, [cosmeticConfig.overflowMode]);
  const getDefaultWidth = (0, import_react5.useCallback)(({
    props: {
      hideHeader,
      isSelectionCell,
      showDivider,
      isDragButtonCell
    }
  }) => {
    if (hideHeader) {
      let width = DEFAULT_HIDE_HEADER_CELL_WIDTH;
      return showDivider ? width + 1 : width;
    } else if (isSelectionCell) {
      return SELECTION_CELL_DEFAULT_WIDTH;
    } else if (isDragButtonCell) {
      return DRAG_BUTTON_CELL_DEFAULT_WIDTH;
    }
  }, []);
  const getDefaultMinWidth = (0, import_react5.useCallback)(({
    props: {
      hideHeader: hideHeader_0,
      isSelectionCell: isSelectionCell_0,
      showDivider: showDivider_0,
      isDragButtonCell: isDragButtonCell_0
    }
  }) => {
    if (hideHeader_0) {
      let width_0 = DEFAULT_HIDE_HEADER_CELL_WIDTH;
      return showDivider_0 ? width_0 + 1 : width_0;
    } else if (isSelectionCell_0) {
      return SELECTION_CELL_DEFAULT_WIDTH;
    } else if (isDragButtonCell_0) {
      return DRAG_BUTTON_CELL_DEFAULT_WIDTH;
    }
    return 75;
  }, []);
  let columnResizeState = $292bc4e09cd0eb62$export$cb895dcf85db1319({
    tableWidth,
    getDefaultWidth,
    getDefaultMinWidth
  }, tableState);
  let state = $fc0b13b484ac1194$export$1505db82fe357e65({
    layout,
    collection,
    renderView,
    onVisibleRectChange(rect) {
      if (bodyRef.current) {
        bodyRef.current.scrollTop = rect.y;
        $ce415dc67314b753$export$ed5fd5ffe5ab0ac(bodyRef.current, direction, rect.x);
      }
    },
    persistedKeys,
    layoutOptions: (0, import_react5.useMemo)(() => ({
      columnWidths: columnResizeState.columnWidths
    }), [columnResizeState.columnWidths])
  });
  $26f7f3da73fcd9d6$export$7717c92ee915373e({
    isLoading,
    onLoadMore,
    scrollOffset: 1
  }, bodyRef);
  let onVisibleRectChange = (0, import_react5.useCallback)((rect_0) => {
    state.setVisibleRect(rect_0);
  }, [state]);
  let onVisibleRectChangeMemo = (0, import_react5.useCallback)((rect_1) => {
    setTableWidth(rect_1.width);
    onVisibleRectChange(rect_1);
    onVisibleRectChangeProp(rect_1);
  }, [onVisibleRectChange, onVisibleRectChangeProp]);
  (0, import_react5.useEffect)(() => {
    if ($507fabe10e71c6fb$export$630ff653c5ada6a9() === "keyboard" && bodyRef.current && domRef.current && headerRef.current && headerRef.current.contains(document.activeElement) && document.activeElement instanceof HTMLElement) {
      $2f04cbc44ee30ce0$export$53a0910f038337bd(headerRef.current, document.activeElement);
      $2f04cbc44ee30ce0$export$c826860796309d1b(document.activeElement, {
        containingElement: domRef.current
      });
      bodyRef.current.scrollLeft = headerRef.current.scrollLeft;
    }
  }, [state.contentSize, headerRef, bodyRef, domRef]);
  let headerHeight = ((_layout$getLayoutInfo = layout.getLayoutInfo("header")) === null || _layout$getLayoutInfo === void 0 ? void 0 : _layout$getLayoutInfo.rect.height) || 0;
  let onScroll = (0, import_react5.useCallback)(() => {
    if (bodyRef.current && headerRef.current) {
      headerRef.current.scrollLeft = bodyRef.current.scrollLeft;
    }
  }, [bodyRef, headerRef]);
  let resizerPosition = columnResizeState.resizingColumn != null ? layout.getLayoutInfo(columnResizeState.resizingColumn).rect.maxX - 2 : 0;
  let resizingColumnWidth = columnResizeState.resizingColumn != null ? columnResizeState.getColumnWidth(columnResizeState.resizingColumn) : 0;
  let resizingColumn = (0, import_react5.useMemo)(() => ({
    width: resizingColumnWidth,
    key: columnResizeState.resizingColumn
  }), [resizingColumnWidth, columnResizeState.resizingColumn]);
  if (isVirtualDragging) {
    delete otherProps.tabIndex;
  }
  let firstColumn = collection.columns[0];
  let scrollPadding = 0;
  if (firstColumn.props.isSelectionCell || firstColumn.props.isDragButtonCell) {
    scrollPadding = columnResizeState.getColumnWidth(firstColumn.key);
  }
  let visibleViews = renderChildren(null, state.visibleViews, renderWrapper);
  return (0, import_jsx_runtime11.jsx)(VirtualizerContext.Provider, {
    value: resizingColumn,
    children: (0, import_jsx_runtime11.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
      children: (0, import_jsx_runtime11.jsxs)("div", {
        ...otherProps,
        ref: domRef,
        children: [(0, import_jsx_runtime11.jsx)("div", {
          role: "presentation",
          className: headerWrapperClassname,
          style: {
            height: headerHeight,
            overflow: "hidden",
            position: "relative",
            willChange: state.isScrolling ? "scroll-position" : void 0,
            scrollPaddingInlineStart: scrollPadding
          },
          ref: headerRef,
          children: (0, import_jsx_runtime11.jsx)(ResizeStateContext.Provider, {
            value: columnResizeState,
            children: visibleViews[0]
          })
        }), (0, import_jsx_runtime11.jsx)(SlotProvider, {
          slots,
          children: (0, import_jsx_runtime11.jsxs)($44a6ee657928b002$export$5665e3d6be6adea, {
            "data-focus": isFocusVisible ? "visible" : void 0,
            className: bodyClassname,
            role: "rowgroup",
            tabIndex: isVirtualDragging ? void 0 : -1,
            style: {
              flex: 1,
              scrollPaddingInlineStart: scrollPadding
            },
            innerStyle: {
              overflow: "visible"
            },
            ref: bodyRef,
            contentSize: state.contentSize,
            onVisibleRectChange: onVisibleRectChangeMemo,
            onScrollStart: state.startScrolling,
            onScrollEnd: state.endScrolling,
            onScroll,
            children: [visibleViews[1], (0, import_jsx_runtime11.jsx)("div", {
              className: bodyResizeIndicatorClassname,
              style: {
                [direction === "ltr" ? "left" : "right"]: `${resizerPosition}px`,
                height: `${Math.max(state.virtualizer.contentSize.height, state.virtualizer.visibleRect.height)}px`,
                display: columnResizeState.resizingColumn ? "block" : "none"
              }
            })]
          })
        })]
      })
    })
  });
}
function renderChildren(parent, views, renderWrapper) {
  return views.map((view) => {
    return renderWrapper(parent, view, view.children ? Array.from(view.children) : [], (childViews) => renderChildren(view, childViews, renderWrapper));
  });
}
function useStyle(layoutInfo, parent) {
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let style = $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, direction, parent);
  if (style.overflow === "hidden") {
    style.overflow = "visible";
  }
  return style;
}
function TableHead({
  children,
  layoutInfo,
  parent,
  ...otherProps
}) {
  let {
    rowGroupProps
  } = $0047e6c294ea075f$export$6fb1613bd7b28198();
  let style = useStyle(layoutInfo, parent);
  return (0, import_jsx_runtime11.jsx)("div", {
    ...rowGroupProps,
    ...otherProps,
    className: headerClassname,
    style,
    children
  });
}
function TableDragHeaderCell(props) {
  let {
    column
  } = props;
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = $f329116d8ad0aba0$export$9514819a8c81e960({
    node: column,
    isVirtualized: true
  }, state, ref);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  return (0, import_jsx_runtime11.jsx)(FocusRing, {
    children: (0, import_jsx_runtime11.jsx)("div", {
      ...columnHeaderProps,
      ref,
      className: headerCellClassname,
      style: {
        padding: 0,
        height: "inherit"
      },
      children: (0, import_jsx_runtime11.jsx)($5c3e21d68f1c4674$export$439d29a4e110a164, {
        children: stringFormatter.format("drag")
      })
    })
  });
}
function TableBody({
  children,
  layoutInfo,
  parent,
  ...otherProps
}) {
  let {
    rowGroupProps
  } = $0047e6c294ea075f$export$6fb1613bd7b28198();
  let style = useStyle(layoutInfo, parent);
  return (0, import_jsx_runtime11.jsx)("div", {
    ...rowGroupProps,
    ...otherProps,
    style,
    children
  });
}
function TableHeaderRow(props) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    hoverProps
  } = $6179b936705e76d3$export$ae780daf29e6d456(props);
  let {
    rowProps
  } = $f917ee10f4c32dab$export$1b95a7d2d517b841({
    node: props.item,
    isVirtualized: true
  }, state, ref);
  return (0, import_jsx_runtime11.jsx)("div", {
    className: rowClassname,
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(rowProps, hoverProps),
    ref,
    children: props.children
  });
}
function TableColumnHeader(props) {
  let {
    column
  } = props;
  let columnProps = column.props;
  let ref = (0, import_react5.useRef)(null);
  let {
    cosmeticConfig,
    isEmpty,
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = $f329116d8ad0aba0$export$9514819a8c81e960({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    ...props,
    isDisabled: isEmpty || !columnProps.allowsSorting
  });
  let slots = (0, import_react5.useMemo)(() => {
    return {
      text: {
        color: "inherit",
        weight: "medium",
        truncate: true
      }
    };
  }, []);
  return (0, import_jsx_runtime11.jsx)(FocusRing, {
    children: (0, import_jsx_runtime11.jsxs)("div", {
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(columnHeaderProps, hoverProps),
      ...toDataAttributes({
        align: columnProps.align,
        isHovered,
        overflowMode: "truncate",
        prominence: cosmeticConfig.prominence
      }, {
        omitFalsyValues: true,
        trimBooleanKeys: true
      }),
      className: headerCellClassname,
      ref,
      children: [(0, import_jsx_runtime11.jsx)(SlotProvider, {
        slots,
        children: columnProps.hideHeader ? (0, import_jsx_runtime11.jsx)($5c3e21d68f1c4674$export$439d29a4e110a164, {
          children: column.rendered
        }) : isReactText(column.rendered) ? (0, import_jsx_runtime11.jsx)(Text, {
          children: column.rendered
        }) : column.rendered
      }), columnProps.allowsSorting && (0, import_jsx_runtime11.jsx)(SortIndicator, {})]
    })
  });
}
function ResizableTableColumnHeader(props) {
  var _state$sortDescriptor, _state$sortDescriptor2;
  let {
    column
  } = props;
  let ref = (0, import_react5.useRef)(null);
  let triggerRef = (0, import_react5.useRef)(null);
  let resizingRef = (0, import_react5.useRef)(null);
  let {
    state,
    onResizeStart,
    onResize,
    onResizeEnd,
    headerRowHovered,
    isEmpty
  } = useTableContext();
  let columnResizeState = useResizeStateContext();
  let {
    pressProps,
    isPressed
  } = $f6c31cce2adf654f$export$45712eceda6fad21({
    isDisabled: isEmpty
  });
  let {
    columnHeaderProps
  } = $f329116d8ad0aba0$export$9514819a8c81e960({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    ...props,
    isDisabled: isEmpty
  });
  let slots = (0, import_react5.useMemo)(() => {
    return {
      text: {
        color: "inherit",
        weight: "medium",
        truncate: true
      }
    };
  }, []);
  let resizingColumn = columnResizeState.resizingColumn;
  let showResizer = !isEmpty && (headerRowHovered && $507fabe10e71c6fb$export$630ff653c5ada6a9() !== "keyboard" || resizingColumn != null);
  let alignment = "start";
  if (column.props.align === "center" || column.colspan && column.colspan > 1) {
    alignment = "center";
  } else if (column.props.align === "end") {
    alignment = "end";
  }
  return (0, import_jsx_runtime11.jsx)(FocusRing, {
    children: (0, import_jsx_runtime11.jsxs)("div", {
      ...toDataAttributes({
        align: alignment,
        sortable: column.props.allowsSorting,
        resizable: column.props.allowsResizing,
        interaction: isPressed ? "press" : isHovered ? "hover" : void 0,
        sort: ((_state$sortDescriptor = state.sortDescriptor) === null || _state$sortDescriptor === void 0 ? void 0 : _state$sortDescriptor.column) === column.key ? (_state$sortDescriptor2 = state.sortDescriptor) === null || _state$sortDescriptor2 === void 0 ? void 0 : _state$sortDescriptor2.direction : void 0
      }, {
        omitFalsyValues: true,
        trimBooleanKeys: true
      }),
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(columnHeaderProps, pressProps, hoverProps),
      ref,
      className: headerCellClassname,
      children: [(0, import_jsx_runtime11.jsx)(SlotProvider, {
        slots,
        children: column.props.hideHeader ? (0, import_jsx_runtime11.jsx)($5c3e21d68f1c4674$export$439d29a4e110a164, {
          children: column.rendered
        }) : isReactText(column.rendered) ? (0, import_jsx_runtime11.jsx)(Text, {
          children: column.rendered
        }) : column.rendered
      }), column.props.allowsSorting && (0, import_jsx_runtime11.jsx)(SortIndicator, {}), (0, import_jsx_runtime11.jsx)(_Resizer, {
        ref: resizingRef,
        column,
        showResizer,
        onResizeStart,
        onResize,
        onResizeEnd,
        triggerRef
      }), (0, import_jsx_runtime11.jsx)("div", {
        "aria-hidden": true,
        "data-visible": resizingColumn != null,
        "data-resizing": resizingColumn === column.key,
        className: columnResizeIndicatorClassname
      })]
    })
  });
}
function TableRow(props) {
  var _state$collection$row, _draggableItem, _draggableItem2, _dragAndDropHooks$isV4, _droppableItem, _droppableItem2, _layout$virtualizer2, _dropIndicator, _dropIndicator2, _layout$virtualizer3;
  let {
    item,
    children,
    layoutInfo,
    parent,
    ...otherProps
  } = props;
  let ref = (0, import_react5.useRef)(null);
  let {
    state,
    layout,
    dragAndDropHooks,
    isTableDraggable,
    isTableDroppable,
    dragState,
    dropState
  } = useTableContext();
  let {
    rowProps,
    hasAction,
    allowsSelection
  } = $b2db214c022798eb$export$7f2f6ae19e707aa5({
    node: item,
    isVirtualized: true,
    shouldSelectOnPressUp: isTableDraggable
  }, state, ref);
  let isSelected = state.selectionManager.isSelected(item.key);
  let isDisabled = state.selectionManager.isDisabled(item.key);
  let isInteractive = !isDisabled && (hasAction || allowsSelection || isTableDraggable);
  let isDroppable = isTableDroppable && !isDisabled;
  let {
    pressProps,
    isPressed
  } = $f6c31cce2adf654f$export$45712eceda6fad21({
    isDisabled: !isInteractive
  });
  let {
    isFocusVisible: isFocusVisibleWithin,
    focusProps: focusWithinProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    within: true
  });
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled: !isInteractive
  });
  let isFirstRow = ((_state$collection$row = state.collection.rows.find((row) => row.level === 1)) === null || _state$collection$row === void 0 ? void 0 : _state$collection$row.key) === item.key;
  let isLastRow = item.nextKey == null;
  let isFlushWithContainerBottom = false;
  if (isLastRow) {
    var _layout$getContentSiz, _layout$virtualizer;
    if (((_layout$getContentSiz = layout.getContentSize()) === null || _layout$getContentSiz === void 0 ? void 0 : _layout$getContentSiz.height) >= ((_layout$virtualizer = layout.virtualizer) === null || _layout$virtualizer === void 0 ? void 0 : _layout$virtualizer.visibleRect.height)) {
      isFlushWithContainerBottom = true;
    }
  }
  let draggableItem = null;
  if (isTableDraggable) {
    assert(!!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableItem));
    assert(!!dragState);
    draggableItem = dragAndDropHooks.useDraggableItem({
      key: item.key,
      hasDragButton: true
    }, dragState);
    if (isDisabled) {
      draggableItem = null;
    }
  }
  let droppableItem = null;
  let isDropTarget = false;
  let dropIndicator = null;
  let dropIndicatorRef = (0, import_react5.useRef)(null);
  if (isTableDroppable) {
    assert(!!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableItem));
    assert(!!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDropIndicator));
    assert(!!dropState);
    let target = {
      type: "item",
      key: item.key,
      dropPosition: "on"
    };
    isDropTarget = dropState.isDropTarget(target);
    droppableItem = dragAndDropHooks.useDroppableItem({
      target
    }, dropState, dropIndicatorRef);
    dropIndicator = dragAndDropHooks.useDropIndicator({
      target
    }, dropState, dropIndicatorRef);
  }
  let dragButtonRef = (0, import_react5.useRef)(null);
  let {
    buttonProps: dragButtonProps
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    ...(_draggableItem = draggableItem) === null || _draggableItem === void 0 ? void 0 : _draggableItem.dragButtonProps,
    elementType: "div"
  }, dragButtonRef);
  let style = useStyle(layoutInfo, parent);
  let mergedRowProps = $3ef42575df84b30b$export$9d1611c77c2fe928(rowProps, otherProps, {
    style
  }, focusWithinProps, focusProps, hoverProps, pressProps, (_draggableItem2 = draggableItem) === null || _draggableItem2 === void 0 ? void 0 : _draggableItem2.dragProps);
  if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && (_dragAndDropHooks$isV4 = dragAndDropHooks.isVirtualDragging) !== null && _dragAndDropHooks$isV4 !== void 0 && _dragAndDropHooks$isV4.call(dragAndDropHooks)) {
    delete mergedRowProps.tabIndex;
  }
  let dropProps = isDroppable ? (_droppableItem = droppableItem) === null || _droppableItem === void 0 ? void 0 : _droppableItem.dropProps : {
    "aria-hidden": (_droppableItem2 = droppableItem) === null || _droppableItem2 === void 0 ? void 0 : _droppableItem2.dropProps["aria-hidden"]
  };
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  return (0, import_jsx_runtime11.jsxs)(TableRowContext.Provider, {
    value: {
      dragButtonProps,
      dragButtonRef,
      isHovered,
      isFocusVisibleWithin
    },
    children: [isTableDroppable && isFirstRow && (0, import_jsx_runtime11.jsx)(InsertionIndicator, {
      rowProps: mergedRowProps,
      visibleRect: (_layout$virtualizer2 = layout.virtualizer) === null || _layout$virtualizer2 === void 0 ? void 0 : _layout$virtualizer2.visibleRect,
      target: {
        key: item.key,
        type: "item",
        dropPosition: "before"
      }
    }, `${item.key}-before`), isTableDroppable && !((_dropIndicator = dropIndicator) !== null && _dropIndicator !== void 0 && _dropIndicator.isHidden) && (0, import_jsx_runtime11.jsx)("div", {
      role: "row",
      ...visuallyHiddenProps,
      children: (0, import_jsx_runtime11.jsx)("div", {
        role: "gridcell",
        children: (0, import_jsx_runtime11.jsx)("div", {
          role: "button",
          ...(_dropIndicator2 = dropIndicator) === null || _dropIndicator2 === void 0 ? void 0 : _dropIndicator2.dropIndicatorProps,
          ref: dropIndicatorRef
        })
      })
    }), (0, import_jsx_runtime11.jsx)("div", {
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(mergedRowProps, dropProps),
      ...toDataAttributes({
        isDisabled,
        isDropTarget,
        isFocusVisible,
        isFocusVisibleWithin,
        isFlushWithContainerBottom,
        isFirstRow,
        isLastRow,
        isHovered,
        isPressed,
        isSelected,
        isNextSelected: item.nextKey && state.selectionManager.isSelected(item.nextKey)
      }, {
        omitFalsyValues: true,
        trimBooleanKeys: true
      }),
      ref,
      className: rowClassname,
      children
    }), isTableDroppable && (0, import_jsx_runtime11.jsx)(InsertionIndicator, {
      rowProps: mergedRowProps,
      visibleRect: (_layout$virtualizer3 = layout.virtualizer) === null || _layout$virtualizer3 === void 0 ? void 0 : _layout$virtualizer3.visibleRect,
      target: {
        key: item.key,
        type: "item",
        dropPosition: "after"
      }
    }, `${item.key}-after`)]
  });
}
function TableDragCell(props) {
  let {
    cell
  } = props;
  let ref = (0, import_react5.useRef)(null);
  let {
    cosmeticConfig,
    state,
    isTableDraggable
  } = useTableContext();
  let isDisabled = cell.parentKey && state.selectionManager.isDisabled(cell.parentKey);
  let {
    gridCellProps
  } = $7713593715703b24$export$49571c903d73624c({
    node: cell,
    isVirtualized: true
  }, state, ref);
  return (0, import_jsx_runtime11.jsx)(FocusRing, {
    children: (0, import_jsx_runtime11.jsx)("div", {
      ...gridCellProps,
      ...toDataAttributes({
        ...cosmeticConfig,
        isDisabled
      }, {
        omitFalsyValues: true,
        trimBooleanKeys: true
      }),
      ref,
      className: classNames(cellClassname, dragCellClassname),
      children: isTableDraggable && !isDisabled && (0, import_jsx_runtime11.jsx)(DragButton, {})
    })
  });
}
function DragButton() {
  let {
    dragButtonProps,
    dragButtonRef,
    isFocusVisibleWithin,
    isHovered
  } = useTableRowContext();
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  return (0, import_jsx_runtime11.jsx)(FocusRing, {
    children: (0, import_jsx_runtime11.jsx)("div", {
      ...dragButtonProps,
      className: css({
        borderRadius: tokenSchema.size.radius.xsmall,
        display: "flex",
        justifyContent: "center",
        outline: 0,
        padding: 0,
        height: tokenSchema.size.icon.regular,
        width: 10,
        // magic number specific to this icon. minimizing space taken by drag handle
        "&[data-focus=visible]": {
          outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`
        }
      }),
      style: !isFocusVisibleWithin && !isHovered ? visuallyHiddenProps.style : {},
      ref: dragButtonRef,
      draggable: "true",
      children: (0, import_jsx_runtime11.jsx)(Icon, {
        src: gripVerticalIcon,
        color: "neutral"
      })
    })
  });
}
function TableCell({
  cell
}) {
  var _cell$column, _cell$column2, _cell$column3, _cell$column4;
  let {
    cosmeticConfig,
    state
  } = useTableContext();
  let ref = (0, import_react5.useRef)(null);
  let {
    gridCellProps
  } = $7713593715703b24$export$49571c903d73624c({
    node: cell,
    isVirtualized: true
  }, state, ref);
  let {
    id,
    ...otherGridCellProps
  } = gridCellProps;
  return (0, import_jsx_runtime11.jsx)(FocusRing, {
    children: (0, import_jsx_runtime11.jsx)("div", {
      ...otherGridCellProps,
      ...toDataAttributes({
        ...cosmeticConfig,
        align: (_cell$column = cell.column) === null || _cell$column === void 0 ? void 0 : _cell$column.props.align,
        hideHeader: (_cell$column2 = cell.column) === null || _cell$column2 === void 0 ? void 0 : _cell$column2.props.hideHeader,
        showDivider: ((_cell$column3 = cell.column) === null || _cell$column3 === void 0 ? void 0 : _cell$column3.props.showDivider) && ((_cell$column4 = cell.column) === null || _cell$column4 === void 0 ? void 0 : _cell$column4.nextKey) !== null
      }),
      "aria-labelledby": id,
      ref,
      className: cellClassname,
      children: typeof cell.rendered === "boolean" || cell.rendered == null ? null : (0, import_jsx_runtime11.jsx)(CellContents, {
        id,
        children: isReactText(cell.rendered) ? (0, import_jsx_runtime11.jsx)(Text, {
          children: cell.rendered
        }) : cell.rendered
      })
    })
  });
}
function CellContents(props) {
  const {
    children,
    ...attributes
  } = props;
  const slots = (0, import_react5.useMemo)(() => ({
    text: {
      color: "inherit"
    }
  }), []);
  const element = import_react5.Children.only(children);
  return (0, import_jsx_runtime11.jsx)(SlotProvider, {
    slots,
    children: (0, import_react5.cloneElement)(element, $3ef42575df84b30b$export$9d1611c77c2fe928(element.props, attributes))
  });
}
function TableCellWrapper(props) {
  let {
    layoutInfo,
    virtualizer,
    parent,
    children
  } = props;
  let {
    isTableDroppable,
    dropState
  } = useTableContext();
  let isDropTarget = false;
  let isRootDroptarget = false;
  if (isTableDroppable) {
    assert(!!dropState);
    let key = parent.content.key;
    if (key) {
      isDropTarget = dropState.isDropTarget({
        type: "item",
        dropPosition: "on",
        key
      });
    }
    isRootDroptarget = dropState.isDropTarget({
      type: "root"
    });
  }
  return (0, import_jsx_runtime11.jsx)($ccf8a0a04e4175ae$export$6796df8ba7398521, {
    layoutInfo,
    virtualizer,
    parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
    className: cellWrapperClassname,
    "data-droptarget": isDropTarget || isRootDroptarget,
    children
  });
}
function TableCheckboxCell({
  cell
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    cosmeticConfig,
    state
  } = useTableContext();
  let isSelectionDisabled = state.disabledKeys.has(cell.parentKey);
  let isDisabled = state.selectionManager.isDisabled(cell.parentKey);
  let {
    gridCellProps
  } = $7713593715703b24$export$49571c903d73624c({
    node: cell,
    isVirtualized: true
  }, state, ref);
  let {
    checkboxProps
  } = $2a795c53a101c542$export$16ea7f650bd7c1bb({
    key: cell.parentKey
  }, state);
  return (0, import_jsx_runtime11.jsx)("div", {
    ...toDataAttributes({
      ...cosmeticConfig,
      isDisabled
    }, {
      trimBooleanKeys: true,
      omitFalsyValues: true
    }),
    className: classNames(cellClassname, checkboxCellClassname),
    ref,
    ...gridCellProps,
    children: (0, import_jsx_runtime11.jsx)(Checkbox, {
      ...checkboxProps,
      isDisabled: isSelectionDisabled
    })
  });
}
function TableSelectAllCell({
  column
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = $f329116d8ad0aba0$export$9514819a8c81e960({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    checkboxProps
  } = $2a795c53a101c542$export$1003db6a7e384b99(state);
  return (0, import_jsx_runtime11.jsx)("div", {
    className: classNames(cellClassname, checkboxCellClassname, headerCellClassname),
    ref,
    ...columnHeaderProps,
    children: state.selectionManager.selectionMode === "single" ? (0, import_jsx_runtime11.jsx)($5c3e21d68f1c4674$export$439d29a4e110a164, {
      children: checkboxProps["aria-label"]
    }) : (0, import_jsx_runtime11.jsx)(Checkbox, {
      ...checkboxProps
    })
  });
}
function LoadingState() {
  let {
    state
  } = useTableContext();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  return (0, import_jsx_runtime11.jsx)(CenteredWrapper, {
    children: (0, import_jsx_runtime11.jsx)(ProgressCircle, {
      isIndeterminate: true,
      "aria-label": state.collection.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
    })
  });
}
function EmptyState() {
  let {
    renderEmptyState
  } = useTableContext();
  let emptyState = renderEmptyState ? renderEmptyState() : null;
  if (emptyState == null) {
    return null;
  }
  return (0, import_jsx_runtime11.jsx)(CenteredWrapper, {
    children: emptyState
  });
}
function CenteredWrapper({
  children
}) {
  let {
    state
  } = useTableContext();
  let rowProps = {
    "aria-rowindex": state.collection.headerRows.length + state.collection.size + 1
  };
  return (0, import_jsx_runtime11.jsx)("div", {
    role: "row",
    ...rowProps,
    className: centeredWrapperClassname,
    children: (0, import_jsx_runtime11.jsx)("div", {
      role: "rowheader",
      "aria-colspan": state.collection.columns.length,
      children
    })
  });
}
var VoussoirColumn = $1cd244557c2f97d5$export$816b5d811295e6bc;

// node_modules/@keystatic/core/dist/keystatic-core-ui.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var import_sanitize_url = __toESM(require_dist2());
var import_slugify = __toESM(require_slugify());

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string2, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string2;
  }
  return result;
}
function isNegativeZero(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string2, max) {
  return common.repeat(" ", max - string2.length) + string2;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map4) {
  var result = {};
  if (map4 !== null) {
    Object.keys(map4).forEach(function(style) {
      map4[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type2 = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type3) {
    if (type3.multi) {
      result.multi[type3.kind].push(type3);
      result.multi["fallback"].push(type3);
    } else {
      result[type3.kind][type3.tag] = result["fallback"][type3.tag] = type3;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type2) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type2)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type2)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type2("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type2("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map3 = new type2("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map3
  ]
});
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object3) {
  return object3 === null;
}
var _null = new type2("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object3) {
  return Object.prototype.toString.call(object3) === "[object Boolean]";
}
var bool = new type2("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object3) {
      return object3 ? "true" : "false";
    },
    uppercase: function(object3) {
      return object3 ? "TRUE" : "FALSE";
    },
    camelcase: function(object3) {
      return object3 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c3) {
  return 48 <= c3 && c3 <= 57 || 65 <= c3 && c3 <= 70 || 97 <= c3 && c3 <= 102;
}
function isOctCode(c3) {
  return 48 <= c3 && c3 <= 55;
}
function isDecCode(c3) {
  return 48 <= c3 && c3 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object3) {
  return Object.prototype.toString.call(object3) === "[object Number]" && (object3 % 1 === 0 && !common.isNegativeZero(object3));
}
var int = new type2("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object3, style) {
  var res;
  if (isNaN(object3)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object3) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object3) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object3)) {
    return "-0.0";
  }
  res = object3.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object3) {
  return Object.prototype.toString.call(object3) === "[object Number]" && (object3 % 1 !== 0 || common.isNegativeZero(object3));
}
var float = new type2("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date2;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date2 = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date2.setTime(date2.getTime() - delta);
  return date2;
}
function representYamlTimestamp(object3) {
  return object3.toISOString();
}
var timestamp = new type2("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge2 = new type2("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map4.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map4 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map4.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object3) {
  var result = "", bits = 0, idx, tail, max = object3.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map4[bits >> 18 & 63];
      result += map4[bits >> 12 & 63];
      result += map4[bits >> 6 & 63];
      result += map4[bits & 63];
    }
    bits = (bits << 8) + object3[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map4[bits >> 18 & 63];
    result += map4[bits >> 12 & 63];
    result += map4[bits >> 6 & 63];
    result += map4[bits & 63];
  } else if (tail === 2) {
    result += map4[bits >> 10 & 63];
    result += map4[bits >> 4 & 63];
    result += map4[bits << 2 & 63];
    result += map4[64];
  } else if (tail === 1) {
    result += map4[bits >> 2 & 63];
    result += map4[bits << 4 & 63];
    result += map4[64];
    result += map4[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type2("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object3 = data;
  for (index = 0, length = object3.length; index < length; index += 1) {
    pair = object3[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type2("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object3 = data;
  result = new Array(object3.length);
  for (index = 0, length = object3.length; index < length; index += 1) {
    pair = object3[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object3 = data;
  result = new Array(object3.length);
  for (index = 0, length = object3.length; index < length; index += 1) {
    pair = object3[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type2("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object3 = data;
  for (key in object3) {
    if (_hasOwnProperty$2.call(object3, key)) {
      if (object3[key] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type2("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge2
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c3) {
  return c3 === 10 || c3 === 13;
}
function is_WHITE_SPACE(c3) {
  return c3 === 9 || c3 === 32;
}
function is_WS_OR_EOL(c3) {
  return c3 === 9 || c3 === 32 || c3 === 10 || c3 === 13;
}
function is_FLOW_INDICATOR(c3) {
  return c3 === 44 || c3 === 91 || c3 === 93 || c3 === 123 || c3 === 125;
}
function fromHexCode(c3) {
  var lc;
  if (48 <= c3 && c3 <= 57) {
    return c3 - 48;
  }
  lc = c3 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c3) {
  if (c3 === 120) {
    return 2;
  }
  if (c3 === 117) {
    return 4;
  }
  if (c3 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c3) {
  if (48 <= c3 && c3 <= 57) {
    return c3 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c3) {
  return c3 === 48 ? "\0" : c3 === 97 ? "\x07" : c3 === 98 ? "\b" : c3 === 116 ? "	" : c3 === 9 ? "	" : c3 === 110 ? "\n" : c3 === 118 ? "\v" : c3 === 102 ? "\f" : c3 === 114 ? "\r" : c3 === 101 ? "\x1B" : c3 === 32 ? " " : c3 === 34 ? '"' : c3 === 47 ? "/" : c3 === 92 ? "\\" : c3 === 78 ? "" : c3 === 95 ? " " : c3 === 76 ? "\u2028" : c3 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c3) {
  if (c3 <= 65535) {
    return String.fromCharCode(c3);
  }
  return String.fromCharCode(
    (c3 - 65536 >> 10) + 55296,
    (c3 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type3, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type3 = state.implicitTypes[typeIndex];
      if (type3.resolve(state.result)) {
        state.result = type3.construct(state.result);
        state.tag = type3.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type3 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type3 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type3 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type3) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type3.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type3.kind + '", not "' + state.kind + '"');
    }
    if (!type3.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type3.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map4) {
  var result, keys, index, length, tag, style, type3;
  if (map4 === null) return {};
  result = {};
  keys = Object.keys(map4);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map4[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type3 = schema2.compiledTypeMap["fallback"][tag];
    if (type3 && _hasOwnProperty.call(type3.styleAliases, style)) {
      style = type3.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string2, handle, length;
  string2 = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string2.length) + string2;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string2, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
  while (position < length) {
    next = string2.indexOf("\n", position);
    if (next === -1) {
      line = string2.slice(position);
      position = length;
    } else {
      line = string2.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type3;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type3 = state.implicitTypes[index];
    if (type3.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c3) {
  return c3 === CHAR_SPACE || c3 === CHAR_TAB;
}
function isPrintable(c3) {
  return 32 <= c3 && c3 <= 126 || 161 <= c3 && c3 <= 55295 && c3 !== 8232 && c3 !== 8233 || 57344 <= c3 && c3 <= 65533 && c3 !== CHAR_BOM || 65536 <= c3 && c3 <= 1114111;
}
function isNsCharOrWhitespace(c3) {
  return isPrintable(c3) && c3 !== CHAR_BOM && c3 !== CHAR_CARRIAGE_RETURN && c3 !== CHAR_LINE_FEED;
}
function isPlainSafe(c3, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c3);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c3);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c3 !== CHAR_COMMA && c3 !== CHAR_LEFT_SQUARE_BRACKET && c3 !== CHAR_RIGHT_SQUARE_BRACKET && c3 !== CHAR_LEFT_CURLY_BRACKET && c3 !== CHAR_RIGHT_CURLY_BRACKET) && c3 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c3 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c3) {
  return isPrintable(c3) && c3 !== CHAR_BOM && !isWhitespace(c3) && c3 !== CHAR_MINUS && c3 !== CHAR_QUESTION && c3 !== CHAR_COLON && c3 !== CHAR_COMMA && c3 !== CHAR_LEFT_SQUARE_BRACKET && c3 !== CHAR_RIGHT_SQUARE_BRACKET && c3 !== CHAR_LEFT_CURLY_BRACKET && c3 !== CHAR_RIGHT_CURLY_BRACKET && c3 !== CHAR_SHARP && c3 !== CHAR_AMPERSAND && c3 !== CHAR_ASTERISK && c3 !== CHAR_EXCLAMATION && c3 !== CHAR_VERTICAL_LINE && c3 !== CHAR_EQUALS && c3 !== CHAR_GREATER_THAN && c3 !== CHAR_SINGLE_QUOTE && c3 !== CHAR_DOUBLE_QUOTE && c3 !== CHAR_PERCENT && c3 !== CHAR_COMMERCIAL_AT && c3 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c3) {
  return !isWhitespace(c3) && c3 !== CHAR_COLON;
}
function codePointAt(string2, pos) {
  var first = string2.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
    second = string2.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string2) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string2);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string2, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string2, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string2)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string2)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string2, level, iskey, inblock) {
  state.dump = function() {
    if (string2.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string3) {
      return testImplicitResolving(state, string3);
    }
    switch (chooseScalarStyle(
      string2,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string2;
      case STYLE_SINGLE:
        return "'" + string2.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string2) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string2, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
  var clip = string2[string2.length - 1] === "\n";
  var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string2) {
  return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
}
function foldString(string2, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string2.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string2.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string2.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string2)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string2) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string2.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string2, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string2[i];
      if (char >= 65536) result += string2[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object3) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object3.length; index < length; index += 1) {
    value = object3[index];
    if (state.replacer) {
      value = state.replacer.call(object3, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object3, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object3.length; index < length; index += 1) {
    value = object3[index];
    if (state.replacer) {
      value = state.replacer.call(object3, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object3) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object3), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object3[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object3, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object3, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object3), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object3[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object3, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object3, explicit) {
  var _result, typeList, index, length, type3, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type3 = typeList[index];
    if ((type3.instanceOf || type3.predicate) && (!type3.instanceOf || typeof object3 === "object" && object3 instanceof type3.instanceOf) && (!type3.predicate || type3.predicate(object3))) {
      if (explicit) {
        if (type3.multi && type3.representName) {
          state.tag = type3.representName(object3);
        } else {
          state.tag = type3.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type3.represent) {
        style = state.styleMap[type3.tag] || type3.defaultStyle;
        if (_toString.call(type3.represent) === "[object Function]") {
          _result = type3.represent(object3, style);
        } else if (_hasOwnProperty.call(type3.represent, style)) {
          _result = type3.represent[style](object3, style);
        } else {
          throw new exception("!<" + type3.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object3, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object3;
  if (!detectType(state, object3, false)) {
    detectType(state, object3, true);
  }
  var type3 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type3 === "[object Object]" || type3 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object3);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type3 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type3 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type3 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type3 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type3);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object3, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object3, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object3, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object3 !== null && typeof object3 === "object") {
    index = objects.indexOf(object3);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object3);
      if (Array.isArray(object3)) {
        for (index = 0, length = object3.length; index < length; index += 1) {
          inspectNode(object3[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object3);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object3[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// node_modules/@keystatic/core/dist/required-files-bd819871.js
var textDecoder = new TextDecoder();
var textEncoder = new TextEncoder();
function splitFrontmatter(data) {
  const str2 = textDecoder.decode(data);
  const match = str2.match(/^---(?:\r?\n([^]*?))?\r?\n---\r?\n?/);
  if (match) {
    var _match$;
    const encoded = textEncoder.encode(match[0]);
    return {
      frontmatter: (_match$ = match[1]) !== null && _match$ !== void 0 ? _match$ : "",
      content: data.slice(encoded.byteLength)
    };
  }
  return null;
}
function loadDataFile(data, formatInfo, requireFrontmatter = false) {
  const parse = formatInfo.data === "json" ? JSON.parse : load;
  if (!formatInfo.contentField) {
    const dataFile = textDecoder.decode(data);
    return {
      loaded: parse(dataFile)
    };
  }
  const res = splitFrontmatter(data);
  if (requireFrontmatter && !res) {
    throw new Error("Frontmatter not found");
  }
  return {
    loaded: res === null ? {} : parse(res.frontmatter),
    extraFakeFile: {
      path: `${formatInfo.contentField.path.join("/")}${formatInfo.contentField.contentExtension}`,
      contents: res === null ? data : res.content
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-historyIcon.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var historyIcon = (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, {
  children: [(0, import_jsx_runtime12.jsx)("path", {
    d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
  }), (0, import_jsx_runtime12.jsx)("path", {
    d: "M3 3v5h5M12 7v5l4 2"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-notice.js
var import_react6 = __toESM(require_react());
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var noticeClassList = new ClassList("Notice", ["heading"]);
var toneToIcon = {
  caution: alertTriangleIcon,
  critical: alertTriangleIcon,
  neutral: infoIcon,
  positive: checkCircle2Icon
};
var toneToRole = {
  caution: "alert",
  critical: "alert",
  neutral: "status",
  positive: "status"
};
function Notice(props) {
  const $ = c2(42);
  let t0;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      tone: t0,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = otherProps;
    $[3] = children;
  } else {
    t0 = $[1];
    otherProps = $[2];
    children = $[3];
  }
  const tone = t0 === void 0 ? "neutral" : t0;
  const ref = (0, import_react6.useRef)(null);
  const styleProps = useStyleProps(otherProps);
  let t1;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = noticeClassList.element("heading");
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const headingClassName = t1;
  const headingId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  const contentId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let t2;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = noticeClassList.selector("heading");
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const hasHeading = useHasChild(t2, ref);
  const coercedTone = tone === "neutral" ? "accent" : tone;
  const icon = toneToIcon[tone];
  let t3;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = css({
      display: "grid",
      gap: tokenSchema.size.space.large
    });
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const contentStyles = t3;
  let t4;
  const t5 = hasHeading ? "content" : "heading-start / heading-start / content-end / content-end";
  const t6 = hasHeading ? "regular" : void 0;
  let t7;
  if ($[7] !== t5 || $[8] !== contentId || $[9] !== t6) {
    t7 = {
      elementType: "div",
      gridArea: t5,
      id: contentId,
      paddingY: t6,
      UNSAFE_className: contentStyles
    };
    $[7] = t5;
    $[8] = contentId;
    $[9] = t6;
    $[10] = t7;
  } else {
    t7 = $[10];
  }
  let t8;
  if ($[11] !== headingId) {
    t8 = {
      elementType: "div",
      gridArea: "heading",
      id: headingId,
      UNSAFE_className: headingClassName,
      size: "small"
    };
    $[11] = headingId;
    $[12] = t8;
  } else {
    t8 = $[12];
  }
  let t9;
  if ($[13] !== coercedTone) {
    t9 = {
      color: coercedTone,
      weight: "medium"
    };
    $[13] = coercedTone;
    $[14] = t9;
  } else {
    t9 = $[14];
  }
  let t10;
  if ($[15] !== t7 || $[16] !== t8 || $[17] !== t9) {
    t10 = {
      content: t7,
      heading: t8,
      text: t9
    };
    $[15] = t7;
    $[16] = t8;
    $[17] = t9;
    $[18] = t10;
  } else {
    t10 = $[18];
  }
  t4 = t10;
  const slots = t4;
  const t11 = toneToRole[tone];
  let t12;
  if ($[19] !== otherProps) {
    t12 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
    $[19] = otherProps;
    $[20] = t12;
  } else {
    t12 = $[20];
  }
  let t13;
  if ($[21] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = ["icon heading", "icon content"];
    $[21] = t13;
  } else {
    t13 = $[21];
  }
  let t14;
  if ($[22] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = ["icon.medium", "auto"];
    $[22] = t14;
  } else {
    t14 = $[22];
  }
  let t15;
  if ($[23] !== icon || $[24] !== coercedTone) {
    t15 = (0, import_jsx_runtime13.jsx)(Icon, {
      src: icon,
      size: "medium",
      color: coercedTone,
      gridArea: "icon",
      alignSelf: "start"
    });
    $[23] = icon;
    $[24] = coercedTone;
    $[25] = t15;
  } else {
    t15 = $[25];
  }
  let t16;
  if ($[26] !== children) {
    t16 = isReactText(children) ? (0, import_jsx_runtime13.jsx)(Content, {
      children: (0, import_jsx_runtime13.jsx)(Text, {
        children
      })
    }) : children;
    $[26] = children;
    $[27] = t16;
  } else {
    t16 = $[27];
  }
  let t17;
  if ($[28] !== slots || $[29] !== t16) {
    t17 = (0, import_jsx_runtime13.jsx)(SlotProvider, {
      slots,
      children: t16
    });
    $[28] = slots;
    $[29] = t16;
    $[30] = t17;
  } else {
    t17 = $[30];
  }
  let t18;
  if ($[31] !== headingId || $[32] !== contentId || $[33] !== t11 || $[34] !== ref || $[35] !== styleProps.className || $[36] !== styleProps.style || $[37] !== t12 || $[38] !== coercedTone || $[39] !== t15 || $[40] !== t17) {
    t18 = (0, import_jsx_runtime13.jsxs)(Grid, {
      "aria-live": "polite",
      "aria-labelledby": headingId,
      "aria-describedby": contentId,
      role: t11,
      ref,
      tabIndex: 0,
      UNSAFE_className: styleProps.className,
      UNSAFE_style: styleProps.style,
      ...t12,
      backgroundColor: coercedTone,
      border: coercedTone,
      borderRadius: "medium",
      minWidth: 0,
      padding: "medium",
      width: "100%",
      alignItems: "center",
      areas: t13,
      columnGap: "medium",
      columns: t14,
      rows: `${minmax("icon.medium", "auto")} auto`,
      children: [t15, t17]
    });
    $[31] = headingId;
    $[32] = contentId;
    $[33] = t11;
    $[34] = ref;
    $[35] = styleProps.className;
    $[36] = styleProps.style;
    $[37] = t12;
    $[38] = coercedTone;
    $[39] = t15;
    $[40] = t17;
    $[41] = t18;
  } else {
    t18 = $[41];
  }
  return t18;
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-copyPlusIcon.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var copyPlusIcon = (0, import_jsx_runtime14.jsxs)(import_jsx_runtime14.Fragment, {
  children: [(0, import_jsx_runtime14.jsx)("path", {
    d: "M15 12v6M12 15h6"
  }), (0, import_jsx_runtime14.jsx)("rect", {
    width: 14,
    height: 14,
    x: 8,
    y: 8,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime14.jsx)("path", {
    d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-clipboardCopyIcon.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var clipboardCopyIcon = (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, {
  children: [(0, import_jsx_runtime15.jsx)("rect", {
    width: 8,
    height: 4,
    x: 8,
    y: 2,
    rx: 1,
    ry: 1
  }), (0, import_jsx_runtime15.jsx)("path", {
    d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M16 4h2a2 2 0 0 1 2 2v4M21 14H11"
  }), (0, import_jsx_runtime15.jsx)("path", {
    d: "m15 10-4 4 4 4"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-clipboardPasteIcon.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var clipboardPasteIcon = (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, {
  children: [(0, import_jsx_runtime16.jsx)("path", {
    d: "M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"
  }), (0, import_jsx_runtime16.jsx)("path", {
    d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2m-9 6h10"
  }), (0, import_jsx_runtime16.jsx)("path", {
    d: "m17 10 4 4-4 4"
  })]
});

// node_modules/@react-aria/breadcrumbs/dist/useBreadcrumbItem.mjs
function $dafd15390222438a$export$452b38fce62c9384(props, ref) {
  let { isCurrent, isDisabled, "aria-current": ariaCurrent, elementType = "a", ...otherProps } = props;
  let { linkProps } = (0, $298d61e98472621b$export$dcf14c9974fe2767)({
    isDisabled: isDisabled || isCurrent,
    elementType,
    ...otherProps
  }, ref);
  let isHeading = /^h[1-6]$/.test(elementType);
  let itemProps = {};
  if (!isHeading) itemProps = linkProps;
  if (isCurrent) {
    itemProps["aria-current"] = ariaCurrent || "page";
    itemProps.tabIndex = props.autoFocus ? -1 : void 0;
  }
  return {
    itemProps: {
      "aria-disabled": isDisabled,
      ...itemProps
    }
  };
}

// node_modules/@react-aria/breadcrumbs/dist/ar-AE.mjs
var $b91590b2dc47de39$exports = {};
$b91590b2dc47de39$exports = {
  "breadcrumbs": `عناصر الواجهة`
};

// node_modules/@react-aria/breadcrumbs/dist/bg-BG.mjs
var $55b0693b2cf3fe91$exports = {};
$55b0693b2cf3fe91$exports = {
  "breadcrumbs": `Трохи хляб`
};

// node_modules/@react-aria/breadcrumbs/dist/cs-CZ.mjs
var $6ec1ed7729e948cc$exports = {};
$6ec1ed7729e948cc$exports = {
  "breadcrumbs": `Popis cesty`
};

// node_modules/@react-aria/breadcrumbs/dist/da-DK.mjs
var $5a41bb2baa6861e4$exports = {};
$5a41bb2baa6861e4$exports = {
  "breadcrumbs": `Brødkrummer`
};

// node_modules/@react-aria/breadcrumbs/dist/de-DE.mjs
var $f28bbea439e87eca$exports = {};
$f28bbea439e87eca$exports = {
  "breadcrumbs": `Breadcrumbs`
};

// node_modules/@react-aria/breadcrumbs/dist/el-GR.mjs
var $b3eca51cb720961a$exports = {};
$b3eca51cb720961a$exports = {
  "breadcrumbs": `Πλοηγήσεις breadcrumb`
};

// node_modules/@react-aria/breadcrumbs/dist/en-US.mjs
var $0b39b205118db415$exports = {};
$0b39b205118db415$exports = {
  "breadcrumbs": `Breadcrumbs`
};

// node_modules/@react-aria/breadcrumbs/dist/es-ES.mjs
var $f467c0ee7bfb0950$exports = {};
$f467c0ee7bfb0950$exports = {
  "breadcrumbs": `Migas de pan`
};

// node_modules/@react-aria/breadcrumbs/dist/et-EE.mjs
var $ab711d2ffb4cdf3d$exports = {};
$ab711d2ffb4cdf3d$exports = {
  "breadcrumbs": `Lingiread`
};

// node_modules/@react-aria/breadcrumbs/dist/fi-FI.mjs
var $b63105d663e6f9d5$exports = {};
$b63105d663e6f9d5$exports = {
  "breadcrumbs": `Navigointilinkit`
};

// node_modules/@react-aria/breadcrumbs/dist/fr-FR.mjs
var $9d2ed7be7fcdc2a1$exports = {};
$9d2ed7be7fcdc2a1$exports = {
  "breadcrumbs": `Chemin de navigation`
};

// node_modules/@react-aria/breadcrumbs/dist/he-IL.mjs
var $c5704294d85c7b5d$exports = {};
$c5704294d85c7b5d$exports = {
  "breadcrumbs": `שבילי ניווט`
};

// node_modules/@react-aria/breadcrumbs/dist/hr-HR.mjs
var $20c975671d6bbc63$exports = {};
$20c975671d6bbc63$exports = {
  "breadcrumbs": `Navigacijski putovi`
};

// node_modules/@react-aria/breadcrumbs/dist/hu-HU.mjs
var $2569ca3917233115$exports = {};
$2569ca3917233115$exports = {
  "breadcrumbs": `Morzsamenü`
};

// node_modules/@react-aria/breadcrumbs/dist/it-IT.mjs
var $caa152f7f8e96c85$exports = {};
$caa152f7f8e96c85$exports = {
  "breadcrumbs": `Breadcrumb`
};

// node_modules/@react-aria/breadcrumbs/dist/ja-JP.mjs
var $cbc6af0cc98fad10$exports = {};
$cbc6af0cc98fad10$exports = {
  "breadcrumbs": `パンくずリスト`
};

// node_modules/@react-aria/breadcrumbs/dist/ko-KR.mjs
var $ad9be5d332b4d607$exports = {};
$ad9be5d332b4d607$exports = {
  "breadcrumbs": `탐색 표시`
};

// node_modules/@react-aria/breadcrumbs/dist/lt-LT.mjs
var $659de19a00ff9617$exports = {};
$659de19a00ff9617$exports = {
  "breadcrumbs": `Naršymo kelias`
};

// node_modules/@react-aria/breadcrumbs/dist/lv-LV.mjs
var $173e9fb4d14fe309$exports = {};
$173e9fb4d14fe309$exports = {
  "breadcrumbs": `Atpakaļceļi`
};

// node_modules/@react-aria/breadcrumbs/dist/nb-NO.mjs
var $d8e2640a066567a9$exports = {};
$d8e2640a066567a9$exports = {
  "breadcrumbs": `Navigasjonsstier`
};

// node_modules/@react-aria/breadcrumbs/dist/nl-NL.mjs
var $d71fd764236c0d12$exports = {};
$d71fd764236c0d12$exports = {
  "breadcrumbs": `Broodkruimels`
};

// node_modules/@react-aria/breadcrumbs/dist/pl-PL.mjs
var $f4ad3faf9f4aaec6$exports = {};
$f4ad3faf9f4aaec6$exports = {
  "breadcrumbs": `Struktura nawigacyjna`
};

// node_modules/@react-aria/breadcrumbs/dist/pt-BR.mjs
var $9703be9d55d8e9c2$exports = {};
$9703be9d55d8e9c2$exports = {
  "breadcrumbs": `Caminho detalhado`
};

// node_modules/@react-aria/breadcrumbs/dist/pt-PT.mjs
var $7e23baec8a14f309$exports = {};
$7e23baec8a14f309$exports = {
  "breadcrumbs": `Categorias`
};

// node_modules/@react-aria/breadcrumbs/dist/ro-RO.mjs
var $568f95594049d56e$exports = {};
$568f95594049d56e$exports = {
  "breadcrumbs": `Miez de pâine`
};

// node_modules/@react-aria/breadcrumbs/dist/ru-RU.mjs
var $625df06cecc70764$exports = {};
$625df06cecc70764$exports = {
  "breadcrumbs": `Навигация`
};

// node_modules/@react-aria/breadcrumbs/dist/sk-SK.mjs
var $b5a67525f3a2f594$exports = {};
$b5a67525f3a2f594$exports = {
  "breadcrumbs": `Navigačné prvky Breadcrumbs`
};

// node_modules/@react-aria/breadcrumbs/dist/sl-SI.mjs
var $16125922964febca$exports = {};
$16125922964febca$exports = {
  "breadcrumbs": `Drobtine`
};

// node_modules/@react-aria/breadcrumbs/dist/sr-SP.mjs
var $de104bf355206bcf$exports = {};
$de104bf355206bcf$exports = {
  "breadcrumbs": `Putanje navigacije`
};

// node_modules/@react-aria/breadcrumbs/dist/sv-SE.mjs
var $d5ab76bcbadc9c07$exports = {};
$d5ab76bcbadc9c07$exports = {
  "breadcrumbs": `Sökvägar`
};

// node_modules/@react-aria/breadcrumbs/dist/tr-TR.mjs
var $a6a1af5968159b55$exports = {};
$a6a1af5968159b55$exports = {
  "breadcrumbs": `İçerik haritaları`
};

// node_modules/@react-aria/breadcrumbs/dist/uk-UA.mjs
var $5204a30f0d17ffec$exports = {};
$5204a30f0d17ffec$exports = {
  "breadcrumbs": `Навігаційна стежка`
};

// node_modules/@react-aria/breadcrumbs/dist/zh-CN.mjs
var $8d15e736e12d3dfd$exports = {};
$8d15e736e12d3dfd$exports = {
  "breadcrumbs": `导航栏`
};

// node_modules/@react-aria/breadcrumbs/dist/zh-TW.mjs
var $f8c49dd804b75140$exports = {};
$f8c49dd804b75140$exports = {
  "breadcrumbs": `導覽列`
};

// node_modules/@react-aria/breadcrumbs/dist/intlStrings.mjs
var $8229b34715874f89$exports = {};
$8229b34715874f89$exports = {
  "ar-AE": $b91590b2dc47de39$exports,
  "bg-BG": $55b0693b2cf3fe91$exports,
  "cs-CZ": $6ec1ed7729e948cc$exports,
  "da-DK": $5a41bb2baa6861e4$exports,
  "de-DE": $f28bbea439e87eca$exports,
  "el-GR": $b3eca51cb720961a$exports,
  "en-US": $0b39b205118db415$exports,
  "es-ES": $f467c0ee7bfb0950$exports,
  "et-EE": $ab711d2ffb4cdf3d$exports,
  "fi-FI": $b63105d663e6f9d5$exports,
  "fr-FR": $9d2ed7be7fcdc2a1$exports,
  "he-IL": $c5704294d85c7b5d$exports,
  "hr-HR": $20c975671d6bbc63$exports,
  "hu-HU": $2569ca3917233115$exports,
  "it-IT": $caa152f7f8e96c85$exports,
  "ja-JP": $cbc6af0cc98fad10$exports,
  "ko-KR": $ad9be5d332b4d607$exports,
  "lt-LT": $659de19a00ff9617$exports,
  "lv-LV": $173e9fb4d14fe309$exports,
  "nb-NO": $d8e2640a066567a9$exports,
  "nl-NL": $d71fd764236c0d12$exports,
  "pl-PL": $f4ad3faf9f4aaec6$exports,
  "pt-BR": $9703be9d55d8e9c2$exports,
  "pt-PT": $7e23baec8a14f309$exports,
  "ro-RO": $568f95594049d56e$exports,
  "ru-RU": $625df06cecc70764$exports,
  "sk-SK": $b5a67525f3a2f594$exports,
  "sl-SI": $16125922964febca$exports,
  "sr-SP": $de104bf355206bcf$exports,
  "sv-SE": $d5ab76bcbadc9c07$exports,
  "tr-TR": $a6a1af5968159b55$exports,
  "uk-UA": $5204a30f0d17ffec$exports,
  "zh-CN": $8d15e736e12d3dfd$exports,
  "zh-TW": $f8c49dd804b75140$exports
};

// node_modules/@react-aria/breadcrumbs/dist/useBreadcrumbs.mjs
function $parcel$interopDefault6(a) {
  return a && a.__esModule ? a.default : a;
}
function $848231d7a2b3998e$export$8cefe241bd876ca0(props) {
  let { "aria-label": ariaLabel, ...otherProps } = props;
  let strings2 = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault6($8229b34715874f89$exports)), "@react-aria/breadcrumbs");
  return {
    navProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(otherProps, {
        labelable: true
      }),
      "aria-label": ariaLabel || strings2.format("breadcrumbs")
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-breadcrumbs.js
var import_react7 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-folderClosedIcon.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var folderClosedIcon = (0, import_jsx_runtime17.jsx)("path", {
  d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2ZM2 10h20"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-folderOpenIcon.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var folderOpenIcon = (0, import_jsx_runtime18.jsx)("path", {
  d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"
});

// node_modules/@keystar/ui/dist/keystar-ui-breadcrumbs.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var breadcrumbsClassList = new ClassList("Breadcrumbs", ["item", "link", "list", "separator"]);
function BreadcrumbItem(props) {
  const $ = c2(26);
  const {
    children,
    isCurrent,
    isDisabled,
    isMenu,
    size: t0
  } = props;
  const size = t0 === void 0 ? "regular" : t0;
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const ref = (0, import_react7.useRef)(null);
  const ElementType = props.href ? "a" : "span";
  let t1;
  if ($[0] !== props || $[1] !== ElementType) {
    t1 = {
      ...props,
      elementType: ElementType
    };
    $[0] = props;
    $[1] = ElementType;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let {
    itemProps
  } = $dafd15390222438a$export$452b38fce62c9384(t1, ref);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(props);
  let t2;
  t2 = direction === "rtl" ? chevronLeftIcon : chevronRightIcon;
  const icon = t2;
  if (isMenu) {
    let t32;
    if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = {};
      $[3] = t32;
    } else {
      t32 = $[3];
    }
    itemProps = t32;
  }
  let t3;
  if ($[4] !== itemProps || $[5] !== hoverProps) {
    t3 = $3ef42575df84b30b$export$9d1611c77c2fe928(itemProps, hoverProps);
    $[4] = itemProps;
    $[5] = hoverProps;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const t4 = size !== "regular" ? size : void 0;
  const t5 = isHovered ? "hover" : void 0;
  let t6;
  if ($[7] !== t4 || $[8] !== t5) {
    t6 = toDataAttributes({
      size: t4,
      interaction: t5
    });
    $[7] = t4;
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== isHovered) {
    t7 = classNames(breadcrumbsClassList.element("link"), css({
      color: tokenSchema.color.foreground.neutral,
      cursor: "default",
      fontSize: tokenSchema.typography.text.regular.size,
      fontFamily: tokenSchema.typography.fontFamily.base,
      fontWeight: tokenSchema.typography.fontWeight.medium,
      outline: 0,
      MozOsxFontSmoothing: "auto",
      WebkitFontSmoothing: "auto",
      "&[data-size=small]": {
        fontSize: tokenSchema.typography.text.small.size
      },
      "&[data-size=medium]": {
        fontSize: tokenSchema.typography.text.medium.size
      },
      "&[data-size=large]": {
        fontSize: tokenSchema.typography.text.large.size
      },
      "&:not([aria-current=page])": {
        "&:not([aria-disabled=true])": {
          cursor: "pointer"
        },
        "&[data-interaction=hover]": {
          color: tokenSchema.color.foreground.neutralEmphasis,
          textDecoration: "underline"
        },
        "&[data-focus=visible]": {
          color: tokenSchema.color.foreground.neutralEmphasis,
          textDecoration: "underline",
          textDecorationStyle: "double"
        },
        "&[aria-disabled=true]": {
          color: tokenSchema.color.alias.foregroundDisabled
        }
      },
      "&[aria-current=page]": {
        color: tokenSchema.color.foreground.neutralEmphasis,
        fontWeight: tokenSchema.typography.fontWeight.semibold,
        overflow: "hidden",
        textOverflow: "ellipsis"
      }
    }), {
      "is-hovered": isHovered
    });
    $[10] = isHovered;
    $[11] = t7;
  } else {
    t7 = $[11];
  }
  let t8;
  if ($[12] !== ElementType || $[13] !== t3 || $[14] !== t6 || $[15] !== ref || $[16] !== t7 || $[17] !== children) {
    t8 = (0, import_jsx_runtime19.jsx)(FocusRing, {
      children: (0, import_jsx_runtime19.jsx)(ElementType, {
        ...t3,
        ...t6,
        ref,
        className: t7,
        children
      })
    });
    $[12] = ElementType;
    $[13] = t3;
    $[14] = t6;
    $[15] = ref;
    $[16] = t7;
    $[17] = children;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] !== isCurrent || $[20] !== isDisabled || $[21] !== icon) {
    t9 = !isCurrent && (0, import_jsx_runtime19.jsx)(Icon, {
      src: icon,
      color: isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary",
      marginX: "small",
      UNSAFE_className: breadcrumbsClassList.element("separator")
    });
    $[19] = isCurrent;
    $[20] = isDisabled;
    $[21] = icon;
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== t8 || $[24] !== t9) {
    t10 = (0, import_jsx_runtime19.jsxs)(import_react7.Fragment, {
      children: [t8, t9]
    });
    $[23] = t8;
    $[24] = t9;
    $[25] = t10;
  } else {
    t10 = $[25];
  }
  return t10;
}
var MIN_VISIBLE_ITEMS = 1;
var MAX_VISIBLE_ITEMS = 4;
function Breadcrumbs(props, ref) {
  props = useProviderProps(props);
  let {
    children,
    showRoot,
    size = "regular",
    isDisabled,
    onAction,
    ...otherProps
  } = props;
  let childArray = [];
  import_react7.Children.forEach(children, (child) => {
    if ((0, import_react7.isValidElement)(child)) {
      childArray.push(child);
    }
  });
  let domRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let listRef = (0, import_react7.useRef)(null);
  let [menuIsOpen, setMenuOpen] = (0, import_react7.useState)(false);
  let [visibleItems, setVisibleItems] = $1dbecbe27a04f9af$export$14d238f342723f25(childArray.length);
  let {
    navProps
  } = $848231d7a2b3998e$export$8cefe241bd876ca0(props);
  let styleProps = useStyleProps(otherProps);
  let updateOverflow = (0, import_react7.useCallback)(() => {
    let computeVisibleItems = (visibleItems_0) => {
      let currListRef = listRef.current;
      if (!currListRef) {
        return visibleItems_0;
      }
      let listItems = Array.from(currListRef.children);
      if (listItems.length <= 0) {
        return visibleItems_0;
      }
      let containerWidth = currListRef.offsetWidth;
      let isShowingMenu = childArray.length > visibleItems_0;
      let calculatedWidth = 0;
      let newVisibleItems = 0;
      let maxVisibleItems = MAX_VISIBLE_ITEMS;
      if (showRoot) {
        calculatedWidth += listItems.shift().offsetWidth;
        newVisibleItems++;
      }
      if (isShowingMenu) {
        calculatedWidth += listItems.shift().offsetWidth;
        maxVisibleItems--;
      }
      if (showRoot && calculatedWidth >= containerWidth) {
        newVisibleItems--;
      }
      if (listItems.length > 0) {
        let last = listItems.pop();
        last.style.overflow = "visible";
        calculatedWidth += last.offsetWidth;
        if (calculatedWidth < containerWidth) {
          newVisibleItems++;
        }
        last.style.overflow = "";
      }
      for (let breadcrumb of listItems.reverse()) {
        calculatedWidth += breadcrumb.offsetWidth;
        if (calculatedWidth < containerWidth) {
          newVisibleItems++;
        }
      }
      return Math.max(MIN_VISIBLE_ITEMS, Math.min(maxVisibleItems, newVisibleItems));
    };
    setVisibleItems(function* () {
      yield childArray.length;
      let newVisibleItems_0 = computeVisibleItems(childArray.length);
      yield newVisibleItems_0;
      if (newVisibleItems_0 < childArray.length && newVisibleItems_0 > 1) {
        yield computeVisibleItems(newVisibleItems_0);
      }
    });
  }, [childArray.length, setVisibleItems, showRoot]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: domRef,
    onResize: updateOverflow
  });
  let lastChildren = (0, import_react7.useRef)(null);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (children !== lastChildren.current) {
      lastChildren.current = children;
      updateOverflow();
    }
  });
  let contents = childArray;
  if (childArray.length > visibleItems) {
    var _selectedItem$key;
    let selectedItem = childArray[childArray.length - 1];
    let selectedKey = (_selectedItem$key = selectedItem.key) !== null && _selectedItem$key !== void 0 ? _selectedItem$key : childArray.length - 1;
    let onMenuAction = (key) => {
      if (key !== selectedKey && onAction) {
        onAction(key);
      }
    };
    let menuItem = (0, import_jsx_runtime19.jsx)(BreadcrumbItem, {
      isMenu: true,
      children: (0, import_jsx_runtime19.jsxs)(MenuTrigger, {
        onOpenChange: setMenuOpen,
        children: [(0, import_jsx_runtime19.jsx)(ActionButton, {
          "aria-label": "…",
          prominence: "low",
          isDisabled,
          children: (0, import_jsx_runtime19.jsx)(Icon, {
            src: menuIsOpen ? folderOpenIcon : folderClosedIcon
          })
        }), (0, import_jsx_runtime19.jsx)(_Menu, {
          selectionMode: "single",
          selectedKeys: [selectedKey],
          onAction: onMenuAction,
          children: childArray
        })]
      })
    }, "menu");
    contents = [menuItem];
    let breadcrumbs = [...childArray];
    let endItems = visibleItems;
    if (showRoot && visibleItems > 1) {
      let rootItem = breadcrumbs.shift();
      if (rootItem) {
        contents.unshift(rootItem);
      }
      endItems--;
    }
    contents.push(...breadcrumbs.slice(-endItems));
  }
  let lastIndex = contents.length - 1;
  let breadcrumbItems = contents.map((child_0, index) => {
    var _child_0$key;
    let isCurrent = index === lastIndex;
    let key_0 = (_child_0$key = child_0.key) !== null && _child_0$key !== void 0 ? _child_0$key : index;
    let onPress = () => {
      if (onAction) {
        onAction(key_0);
      }
    };
    return (0, import_jsx_runtime19.jsx)("li", {
      className: classNames(breadcrumbsClassList.element("item"), css({
        alignItems: "center",
        display: "inline-flex",
        whiteSpace: "nowrap",
        "&:last-child": {
          overflow: "hidden"
        }
      })),
      children: (0, import_react7.createElement)(BreadcrumbItem, {
        ...child_0.props,
        isCurrent,
        isDisabled,
        key: key_0,
        onPress,
        size
      }, child_0.props.children)
    }, index);
  });
  return (0, import_jsx_runtime19.jsx)("nav", {
    ...navProps,
    ...styleProps,
    ref: domRef,
    className: classNames(breadcrumbsClassList.element("root"), styleProps.className),
    children: (0, import_jsx_runtime19.jsx)("ul", {
      ref: listRef,
      className: classNames(breadcrumbsClassList.element("list"), css({
        display: "flex",
        height: tokenSchema.size.element.regular,
        justifyContent: "flex-start"
      })),
      children: breadcrumbItems
    })
  });
}
var _Breadcrumbs = (0, import_react7.forwardRef)(Breadcrumbs);

// node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs
var h = "\nhttps://bit.ly/2XbVrpR#";
var m = /* @__PURE__ */ new Set();
var g = [];
var popDebugNode = () => g.pop();
var pushDebugNode = (e2, r3) => {
  var t = "";
  if (r3.kind === e.INLINE_FRAGMENT) {
    t = e2 ? `Inline Fragment on "${e2}"` : "Inline Fragment";
  } else if (r3.kind === e.OPERATION_DEFINITION) {
    t = `${r3.name ? `"${r3.name.value}"` : "Unnamed"} ${r3.operation}`;
  } else if (r3.kind === e.FRAGMENT_DEFINITION) {
    t = `"${r3.name.value}" Fragment`;
  }
  if (t) {
    g.push(t);
  }
};
var getDebugOutput = () => g.length ? "\n(Caused At: " + g.join(", ") + ")" : "";
function invariant(e2, r3, t) {
  if (!e2) {
    var a = r3 || "Minfied Error #" + t + "\n";
    if (true) {
      a += getDebugOutput();
    }
    var i = new Error(a + h + t);
    i.name = "Graphcache Error";
    throw i;
  }
}
function warn(e2, r3, t) {
  if (!m.has(e2)) {
    if (t) {
      t("warn", e2 + getDebugOutput() + h + r3);
    } else {
      console.warn(e2 + getDebugOutput() + h + r3);
    }
    m.add(e2);
  }
}
var _ = {};
var getDirectives = (e2) => e2._directives || _;
var getName = (e2) => e2.name.value;
var getFragmentTypeName = (e2) => e2.typeCondition.name.value;
var getFieldAlias = (e2) => e2.alias ? e2.alias.value : e2.name.value;
var N = [];
var getSelectionSet = (e2) => e2.selectionSet ? e2.selectionSet.selections : N;
var getTypeCondition = (e2) => e2.typeCondition ? e2.typeCondition.name.value : null;
var getFieldArguments = (e2, r3) => {
  var t = null;
  if (e2.arguments) {
    for (var a = 0, i = e2.arguments.length; a < i; a++) {
      var n = e2.arguments[a];
      var s = valueFromASTUntyped(n.value, r3);
      if (null != s) {
        if (!t) {
          t = {};
        }
        t[getName(n)] = s;
      }
    }
  }
  return t;
};
var filterVariables = (e2, r3) => {
  if (!r3 || !e2.variableDefinitions) {
    return;
  }
  var t = {};
  for (var a = 0, i = e2.variableDefinitions.length; a < i; a++) {
    var n = getName(e2.variableDefinitions[a].variable);
    t[n] = r3[n];
  }
  return t;
};
var normalizeVariables = (e2, r3) => {
  var t = {};
  if (!r3) {
    return t;
  }
  if (e2.variableDefinitions) {
    for (var a = 0, i = e2.variableDefinitions.length; a < i; a++) {
      var n = e2.variableDefinitions[a];
      var s = getName(n.variable);
      t[s] = void 0 === r3[s] && n.defaultValue ? valueFromASTUntyped(n.defaultValue, r3) : r3[s];
    }
  }
  for (var l in r3) {
    if (!(l in t)) {
      t[l] = r3[l];
    }
  }
  return t;
};
function getMainOperation(e2) {
  for (var r3 = 0; r3 < e2.definitions.length; r3++) {
    if (e2.definitions[r3].kind === e.OPERATION_DEFINITION) {
      return e2.definitions[r3];
    }
  }
  invariant(false, true ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
}
var getFragments = (e2) => {
  var r3 = {};
  for (var t = 0; t < e2.definitions.length; t++) {
    var a = e2.definitions[t];
    if (a.kind === e.FRAGMENT_DEFINITION) {
      r3[getName(a)] = a;
    }
  }
  return r3;
};
var shouldInclude = (e2, r3) => {
  var t = getDirectives(e2);
  if (t.include || t.skip) {
    for (var a in t) {
      var i = t[a];
      if (i && ("include" === a || "skip" === a) && i.arguments && i.arguments[0] && "if" === getName(i.arguments[0])) {
        var n = valueFromASTUntyped(i.arguments[0].value, r3);
        return "include" === a ? !!n : !n;
      }
    }
  }
  return true;
};
var isDeferred = (e2, r3) => {
  var { defer: t } = getDirectives(e2);
  if (t) {
    for (var a of t.arguments || []) {
      if ("if" === getName(a)) {
        return !!valueFromASTUntyped(a.value, r3);
      }
    }
    return true;
  }
  return false;
};
var isOptional = (e2) => {
  var { optional: r3, required: t } = getDirectives(e2);
  if (t) {
    return false;
  }
  if (r3) {
    return true;
  }
  return;
};
var k = "__";
var isFieldNullable = (e2, r3, t, a) => {
  var i = getField(e2, r3, t, a);
  return !!i && "NON_NULL" !== i.type.kind;
};
var isListNullable = (e2, r3, t, a) => {
  var i = getField(e2, r3, t, a);
  if (!i) {
    return false;
  }
  var n = "NON_NULL" === i.type.kind ? i.type.ofType : i.type;
  return "LIST" === n.kind && "NON_NULL" !== n.ofType.kind;
};
var isFieldAvailableOnType = (e2, r3, t, a) => 0 === t.indexOf(k) || 0 === r3.indexOf(k) || !!getField(e2, r3, t, a);
var isInterfaceOfType = (e2, r3, t) => {
  if (!t) {
    return false;
  }
  var a = getTypeCondition(r3);
  if (!a || t === a) {
    return true;
  } else if (e2.types.has(a) && "OBJECT" === e2.types.get(a).kind) {
    return a === t;
  }
  !function expectAbstractType(e3, r4) {
    invariant(e3.types.has(r4) && ("INTERFACE" === e3.types.get(r4).kind || "UNION" === e3.types.get(r4).kind), true ? "Invalid Abstract type: The type `" + r4 + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5);
  }(e2, a);
  expectObjectType(e2, t);
  return e2.isSubType(a, t);
};
var getField = (e2, r3, t, a) => {
  if (0 === t.indexOf(k) || 0 === r3.indexOf(k)) {
    return;
  }
  expectObjectType(e2, r3);
  var i = e2.types.get(r3).fields()[t];
  if (true) {
    if (!i) {
      warn("Invalid field: The field `" + t + "` does not exist on `" + r3 + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4, a);
    }
  }
  return i;
};
function expectObjectType(e2, r3) {
  invariant(e2.types.has(r3) && "OBJECT" === e2.types.get(r3).kind, true ? "Invalid Object type: The type `" + r3 + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}
function warnAboutResolver(e2, r3) {
  warn(`Invalid resolver: \`${e2}\` is not in the defined schema, but the \`resolvers\` option is referencing it.`, 23, r3);
}
function warnAboutAbstractResolver(e2, r3, t) {
  warn(`Invalid resolver: \`${e2}\` does not match to a concrete type in the schema, but the \`resolvers\` option is referencing it. Implement the resolver for the types that ${"UNION" === r3 ? "make up the union" : "implement the interface"} instead.`, 26, t);
}
var keyOfField = (r3, t) => t ? `${r3}(${stringifyVariables(t)})` : r3;
var joinKeys = (e2, r3) => `${e2}.${r3}`;
var fieldInfoOfKey = (e2) => {
  var r3 = e2.indexOf("(");
  if (r3 > -1) {
    return {
      fieldKey: e2,
      fieldName: e2.slice(0, r3),
      arguments: JSON.parse(e2.slice(r3 + 1, -1))
    };
  } else {
    return {
      fieldKey: e2,
      fieldName: e2,
      arguments: null
    };
  }
};
var deserializeKeyInfo = (e2) => {
  var r3 = e2.indexOf(".");
  return {
    entityKey: e2.slice(0, r3).replace(/%2e/g, "."),
    fieldKey: e2.slice(r3 + 1)
  };
};
var E = null;
var O = null;
var w = null;
var b = null;
var D = null;
var x = null;
var V = false;
var I = false;
function makeData(e2, r3) {
  var t;
  if (e2) {
    if (E.has(e2)) {
      return e2;
    }
    t = O.get(e2);
  }
  if (null == t) {
    t = r3 ? [] : {};
  }
  if (e2) {
    O.set(e2, t);
  }
  E.add(t);
  return t;
}
var ownsData = (e2) => !!e2 && E.has(e2);
var initDataState = (e2, r3, t, a, i) => {
  E = /* @__PURE__ */ new WeakSet();
  O = /* @__PURE__ */ new WeakMap();
  D = e2;
  w = r3;
  x = /* @__PURE__ */ new Set();
  I = !!a;
  V = !!i;
  if (true) {
    g.length = 0;
  }
  if (!t) {
    b = null;
  } else if ("read" === D) {
    b = t;
  } else if (a || r3.hydrating || r3.optimisticOrder.length > 1) {
    if (!a && !r3.commutativeKeys.has(t)) {
      reserveLayer(r3, t);
    } else if (a) {
      if (-1 !== r3.optimisticOrder.indexOf(t) && !r3.commutativeKeys.has(t)) {
        r3.optimisticOrder.splice(r3.optimisticOrder.indexOf(t), 1);
      }
      r3.commutativeKeys.delete(t);
    }
    b = t;
    createLayer(r3, t);
  } else {
    b = null;
    deleteLayer(r3, t);
  }
};
var clearDataState = () => {
  if (true) {
    getCurrentDependencies();
  }
  var e2 = w;
  var r3 = b;
  I = false;
  b = null;
  if (!e2.hydrating && r3 && e2.optimisticOrder.indexOf(r3) > -1) {
    var t = e2.optimisticOrder.length;
    while (--t >= 0 && e2.dirtyKeys.has(e2.optimisticOrder[t]) && e2.commutativeKeys.has(e2.optimisticOrder[t])) {
      squashLayer(e2.optimisticOrder[t]);
    }
  }
  E = null;
  O = null;
  D = null;
  w = null;
  x = null;
  if (true) {
    g.length = 0;
  }
  if (true) {
    if (!e2.defer && (e2.storage || !e2.optimisticOrder.length)) {
      e2.defer = true;
      setTimeout(() => {
        initDataState("read", e2, null);
        gc();
        persistData();
        clearDataState();
        e2.defer = false;
      });
    }
  }
};
var noopDataState = (e2, r3, t) => {
  if (r3 && !t) {
    e2.deferredKeys.delete(r3);
  }
  initDataState("write", e2, r3, t);
  clearDataState();
};
var getCurrentDependencies = () => {
  invariant(null !== x, true ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return x;
};
var q = /* @__PURE__ */ new Set();
var setNode = (e2, r3, t, a) => {
  if (true) {
    invariant("read" !== D, true ? "Invalid Cache write: You may not write to the cache during cache reads.  Accesses to `cache.writeFragment`, `cache.updateQuery`, and `cache.link` may  not be made inside `resolvers` for instance." : "", 27);
  }
  var i = b ? e2.optimistic.get(b) : e2.base;
  var n = i.get(r3);
  if (void 0 === n) {
    i.set(r3, n = /* @__PURE__ */ Object.create(null));
  }
  if (void 0 === a && !b) {
    delete n[t];
  } else {
    n[t] = a;
  }
};
var getNode = (e2, r3, t) => {
  var a;
  var i = !I && "read" === D && b && w.commutativeKeys.has(b);
  for (var n = 0, o = w.optimisticOrder.length; n < o; n++) {
    var s = w.optimisticOrder[n];
    var l = e2.optimistic.get(s);
    i = i && s !== b;
    if (l && (!i || !w.commutativeKeys.has(s)) && (!I || "write" === D || w.commutativeKeys.has(s)) && void 0 !== (a = l.get(r3)) && t in a) {
      return a[t];
    }
  }
  return void 0 !== (a = e2.base.get(r3)) ? a[t] : void 0;
};
function getRefCount(e2) {
  return w.refCount.get(e2) || 0;
}
var updateRCForLink = (e2, r3) => {
  if (Array.isArray(e2)) {
    for (var t = 0, a = e2.length; t < a; t++) {
      updateRCForLink(e2[t], r3);
    }
  } else if ("string" == typeof e2) {
    ((e3, r4) => {
      var t2 = getRefCount(e3);
      var a2 = t2 + r4 > 0 ? t2 + r4 : 0;
      w.refCount.set(e3, a2);
      if (!a2) {
        w.gc.add(e3);
      } else if (!t2 && a2) {
        w.gc.delete(e3);
      }
    })(e2, r3);
  }
};
var extractNodeFields = (e2, r3, t) => {
  if (void 0 !== t) {
    for (var a in t) {
      if (!r3.has(a)) {
        e2.push(fieldInfoOfKey(a));
        r3.add(a);
      }
    }
  }
};
var extractNodeMapFields = (e2, r3, t, a) => {
  extractNodeFields(e2, r3, a.base.get(t));
  for (var i = 0, n = w.optimisticOrder.length; i < n; i++) {
    var o = a.optimistic.get(w.optimisticOrder[i]);
    if (void 0 !== o) {
      extractNodeFields(e2, r3, o.get(t));
    }
  }
};
var gc = () => {
  if (w.optimisticOrder.length) {
    return;
  }
  for (var e2 of w.gc.keys()) {
    w.gc.delete(e2);
    if (getRefCount(e2) > 0) {
      continue;
    }
    var r3 = w.records.base.get(e2);
    w.refCount.delete(e2);
    w.records.base.delete(e2);
    var t = r3 && r3.__typename;
    if (t) {
      var a = w.types.get(t);
      if (a) {
        a.delete(e2);
      }
    }
    var i = w.links.base.get(e2);
    if (i) {
      w.links.base.delete(e2);
      for (var n in i) {
        updateRCForLink(i[n], -1);
      }
    }
  }
};
var updateDependencies = (e2, r3) => {
  if (e2 !== w.queryRootKey) {
    x.add(e2);
  } else if (void 0 !== r3 && "__typename" !== r3) {
    x.add(joinKeys(e2, r3));
  }
};
var updatePersist = (e2, r3) => {
  if (!I && w.storage) {
    w.persist.add(((e3, r4) => `${e3.replace(/\./g, "%2e")}.${r4}`)(e2, r3));
  }
};
var readRecord = (e2, r3) => {
  if ("read" === D) {
    updateDependencies(e2, r3);
  }
  return getNode(w.records, e2, r3);
};
var readLink = (e2, r3) => {
  if ("read" === D) {
    updateDependencies(e2, r3);
  }
  return getNode(w.links, e2, r3);
};
var writeConcreteType = (e2, r3) => {
  var t = w.abstractToConcreteMap.get(e2);
  if (!t) {
    var a = /* @__PURE__ */ new Set();
    a.add(r3);
    w.abstractToConcreteMap.set(e2, a);
  } else {
    t.add(r3);
  }
};
var writeRecord = (e2, r3, t) => {
  if (!isEqualLinkOrScalar(getNode(w.records, e2, r3), t)) {
    updateDependencies(e2, r3);
    updatePersist(e2, r3);
  }
  setNode(w.records, e2, r3, t);
};
var hasField = (e2, r3) => void 0 !== readRecord(e2, r3) || void 0 !== readLink(e2, r3);
var writeLink = (e2, r3, t) => {
  var a = b ? w.links.optimistic.get(b) : w.links.base;
  if (!b) {
    var i = a && a.get(e2);
    updateRCForLink(i && i[r3], -1);
    updateRCForLink(t, 1);
  }
  if (!isEqualLinkOrScalar(getNode(w.links, e2, r3), t)) {
    updateDependencies(e2, r3);
    updatePersist(e2, r3);
  }
  setNode(w.links, e2, r3, t);
};
var reserveLayer = (e2, r3, t) => {
  var a = e2.optimisticOrder.indexOf(r3);
  if (a > -1) {
    e2.optimisticOrder.splice(a, 1);
  }
  if (t) {
    e2.deferredKeys.add(r3);
    for (a = a > -1 ? a : 0; a < e2.optimisticOrder.length && !e2.deferredKeys.has(e2.optimisticOrder[a]) && (!e2.dirtyKeys.has(e2.optimisticOrder[a]) || !e2.commutativeKeys.has(e2.optimisticOrder[a])); a++) {
    }
  } else {
    e2.deferredKeys.delete(r3);
    if (a > -1 && !e2.commutativeKeys.has(r3)) {
      clearLayer(e2, r3);
    }
    a = 0;
  }
  e2.optimisticOrder.splice(a, 0, r3);
  e2.commutativeKeys.add(r3);
};
var createLayer = (e2, r3) => {
  if (-1 === e2.optimisticOrder.indexOf(r3)) {
    e2.optimisticOrder.unshift(r3);
  }
  if (!e2.dirtyKeys.has(r3)) {
    e2.dirtyKeys.add(r3);
    e2.links.optimistic.set(r3, /* @__PURE__ */ new Map());
    e2.records.optimistic.set(r3, /* @__PURE__ */ new Map());
  }
};
var clearLayer = (e2, r3) => {
  if (e2.dirtyKeys.has(r3)) {
    e2.dirtyKeys.delete(r3);
    e2.records.optimistic.delete(r3);
    e2.links.optimistic.delete(r3);
    e2.deferredKeys.delete(r3);
  }
};
var deleteLayer = (e2, r3) => {
  var t = e2.optimisticOrder.indexOf(r3);
  if (t > -1) {
    e2.optimisticOrder.splice(t, 1);
    e2.commutativeKeys.delete(r3);
  }
  clearLayer(e2, r3);
};
var squashLayer = (e2) => {
  var r3 = x;
  x = /* @__PURE__ */ new Set();
  D = "write";
  var t = w.links.optimistic.get(e2);
  if (t) {
    for (var a of t.entries()) {
      var i = a[0];
      var n = a[1];
      for (var o in n) {
        writeLink(i, o, n[o]);
      }
    }
  }
  var s = w.records.optimistic.get(e2);
  if (s) {
    for (var l of s.entries()) {
      var v = l[0];
      var d2 = l[1];
      for (var c3 in d2) {
        writeRecord(v, c3, d2[c3]);
      }
    }
  }
  x = r3;
  deleteLayer(w, e2);
};
var inspectFields = (e2) => {
  var { links: r3, records: t } = w;
  var a = [];
  var i = /* @__PURE__ */ new Set();
  updateDependencies(e2);
  extractNodeMapFields(a, i, e2, r3);
  extractNodeMapFields(a, i, e2, t);
  return a;
};
var persistData = () => {
  if (w.storage) {
    I = true;
    D = "read";
    var r3 = {};
    for (var t of w.persist.keys()) {
      var { entityKey: a, fieldKey: i } = deserializeKeyInfo(t);
      var n = void 0;
      if (void 0 !== (n = readLink(a, i))) {
        r3[t] = `:${stringifyVariables(n)}`;
      } else if (void 0 !== (n = readRecord(a, i))) {
        r3[t] = stringifyVariables(n);
      } else {
        r3[t] = void 0;
      }
    }
    I = false;
    w.storage.writeData(r3);
    w.persist.clear();
  }
};
function isEqualLinkOrScalar(e2, r3) {
  if (typeof e2 != typeof r3) {
    return false;
  }
  if (e2 !== r3) {
    return false;
  }
  if (Array.isArray(e2) && Array.isArray(r3)) {
    if (e2.length !== r3.length) {
      return false;
    }
    return !e2.some((e3, t) => e3 !== r3[t]);
  }
  return true;
}
var S = null;
var A = false;
var T = void 0;
var getFieldError = (e2) => e2.__internal.path.length > 0 && e2.__internal.errorMap ? e2.__internal.errorMap[e2.__internal.path.join(".")] : void 0;
var makeContext = (e2, r3, t, a, i, n) => {
  var o = {
    store: e2,
    variables: r3,
    fragments: t,
    parent: {
      __typename: a
    },
    parentTypeName: a,
    parentKey: i,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: false,
    hasNext: false,
    optimistic: I,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (n && n.graphQLErrors) {
    for (var s = 0; s < n.graphQLErrors.length; s++) {
      var l = n.graphQLErrors[s];
      if (l.path && l.path.length) {
        if (!o.__internal.errorMap) {
          o.__internal.errorMap = /* @__PURE__ */ Object.create(null);
        }
        o.__internal.errorMap[l.path.join(".")] = l;
      }
    }
  }
  return o;
};
var updateContext = (e2, r3, t, a, i, n) => {
  S = e2;
  e2.parent = r3;
  e2.parentTypeName = t;
  e2.parentKey = a;
  e2.parentFieldKey = i;
  e2.fieldName = n;
  e2.error = getFieldError(e2);
};
var isFragmentHeuristicallyMatching = (e2, r3, t, a, i) => {
  if (!r3) {
    return false;
  }
  var o = getTypeCondition(e2);
  if (!o || r3 === o) {
    return true;
  }
  warn("Heuristic Fragment Matching: A fragment is trying to match against the `" + r3 + "` type, but the type condition is `" + o + "`. Since GraphQL allows for interfaces `" + o + "` may be an interface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16, i);
  return !getSelectionSet(e2).some((e3) => {
    if (e3.kind !== e.FIELD) {
      return false;
    }
    var r4 = keyOfField(getName(e3), getFieldArguments(e3, a));
    return !hasField(t, r4);
  });
};
var SelectionIterator = class {
  constructor(e2, r3, t, a, i, n) {
    this.typename = e2;
    this.entityKey = r3;
    this.ctx = n;
    this.stack = [{
      selectionSet: i,
      index: 0,
      defer: t,
      optional: a
    }];
  }
  next() {
    while (this.stack.length > 0) {
      var e2 = this.stack[this.stack.length - 1];
      while (e2.index < e2.selectionSet.length) {
        var r3 = e2.selectionSet[e2.index++];
        if (!shouldInclude(r3, this.ctx.variables)) {
        } else if (r3.kind !== e.FIELD) {
          var t = r3.kind !== e.INLINE_FRAGMENT ? this.ctx.fragments[getName(r3)] : r3;
          if (t) {
            var a = !t.typeCondition || (this.ctx.store.schema ? isInterfaceOfType(this.ctx.store.schema, t, this.typename) : "read" === D && isFragmentMatching(t.typeCondition.name.value, this.typename) || isFragmentHeuristicallyMatching(t, this.typename, this.entityKey, this.ctx.variables, this.ctx.store.logger));
            if (a || "write" === D && !this.ctx.store.schema) {
              if (true) {
                pushDebugNode(this.typename, t);
              }
              var i = isOptional(r3);
              if (a && t.typeCondition && this.typename !== t.typeCondition.name.value) {
                writeConcreteType(t.typeCondition.name.value, this.typename);
              }
              this.stack.push(e2 = {
                selectionSet: getSelectionSet(t),
                index: 0,
                defer: e2.defer || isDeferred(r3, this.ctx.variables),
                optional: void 0 !== i ? i : e2.optional
              });
            }
          }
        } else if ("write" === D || !r3._generated) {
          A = e2.defer;
          T = e2.optional;
          return r3;
        }
      }
      this.stack.pop();
      if (true) {
        popDebugNode();
      }
    }
    return;
  }
};
var isFragmentMatching = (e2, r3) => {
  if (!r3) {
    return false;
  }
  if (e2 === r3) {
    return true;
  }
  var t = !((e3) => w.types.has(e3))(e2);
  if (!t) {
    return false;
  }
  var a = ((e3) => w.abstractToConcreteMap.get(e3) || q)(e2);
  return a.size && a.has(r3);
};
var ensureData = (e2) => null == e2 ? null : e2;
var ensureLink = (e2, r3) => {
  if (!r3) {
    return r3 || null;
  } else if (Array.isArray(r3)) {
    var t = new Array(r3.length);
    for (var a = 0, i = t.length; a < i; a++) {
      t[a] = ensureLink(e2, r3[a]);
    }
    return t;
  }
  var n = e2.keyOfEntity(r3);
  if (true) {
    if (!n && r3 && "object" == typeof r3) {
      warn("Can't generate a key for link(...) item.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + r3.__typename + "`.", 12, e2.logger);
    }
  }
  return n;
};
var _query = (e2, t, a, i) => {
  var n = formatDocument(t.query);
  var o = getMainOperation(n);
  var s = e2.rootFields[o.operation];
  var l = getSelectionSet(o);
  var v = makeContext(e2, normalizeVariables(o, t.variables), getFragments(n), s, s, i);
  if (true) {
    pushDebugNode(s, o);
  }
  var d2 = s !== v.store.rootFields.query ? readRoot(v, s, l, a || makeData()) : readSelection(v, s, l, a || makeData());
  if (true) {
    popDebugNode();
    getCurrentDependencies();
  }
  return {
    dependencies: x,
    partial: v.partial || !d2,
    hasNext: v.hasNext,
    data: d2 || null
  };
};
var readRoot = (e2, r3, t, a) => {
  if ("string" != typeof (e2.store.rootNames[r3] ? r3 : a.__typename)) {
    return a;
  }
  var i = new SelectionIterator(r3, r3, false, void 0, t, e2);
  var n;
  var o = V;
  var s = makeData(a);
  while (n = i.next()) {
    var l = getFieldAlias(n);
    var v = a[l];
    e2.__internal.path.push(l);
    var d2 = void 0;
    if (n.selectionSet && null !== v) {
      d2 = readRootField(e2, getSelectionSet(n), ensureData(v));
    } else {
      d2 = v;
    }
    o = o || d2 !== v;
    if (void 0 !== d2) {
      s[l] = d2;
    }
    e2.__internal.path.pop();
  }
  return o ? s : a;
};
var readRootField = (e2, r3, t) => {
  if (Array.isArray(t)) {
    var a = new Array(t.length);
    var i = V;
    for (var n = 0, o = t.length; n < o; n++) {
      e2.__internal.path.push(n);
      a[n] = readRootField(e2, r3, t[n]);
      i = i || a[n] !== t[n];
      e2.__internal.path.pop();
    }
    return i ? a : t;
  } else if (null === t) {
    return null;
  }
  var s = e2.store.keyOfEntity(t);
  if (null !== s) {
    return readSelection(e2, s, r3, t) || null;
  } else {
    return readRoot(e2, t.__typename, r3, t);
  }
};
function getFieldResolver(e2, r3, t, a) {
  var i = a.store.resolvers[r3];
  var n = i && i[t];
  var o;
  for (var s in e2) {
    var l = e2[s];
    if (l && "include" !== s && "skip" !== s && a.store.directives[s]) {
      o = a.store.directives[s](getFieldArguments(l, a.variables));
      if (false) {
        return o;
      }
      break;
    }
  }
  if (true) {
    if (n && o) {
      warn(`A resolver and directive is being used at "${r3}.${t}" simultaneously. Only the directive will apply.`, 28, a.store.logger);
    }
  }
  return o || n;
}
var readSelection = (e2, r3, t, a, i) => {
  var { store: n } = e2;
  var o = r3 === n.rootFields.query;
  var s = i && n.keyOfEntity(i) || r3;
  if (true) {
    if (!o && e2.store.rootNames[s]) {
      warn("Invalid root traversal: A selection was being read on `" + s + "` which is an uncached root type.\nThe `" + e2.store.rootFields.mutation + "` and `" + e2.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25, n.logger);
    }
  }
  var l = !o ? readRecord(s, "__typename") || i && i.__typename : r3;
  if ("string" != typeof l) {
    return;
  } else if (i && l !== i.__typename) {
    warn("Invalid resolver data: The resolver at `" + s + "` returned an invalid typename that could not be reconciled with the cache.", 8, n.logger);
    return;
  }
  var v = new SelectionIterator(l, s, false, void 0, t, e2);
  var d2 = false;
  var c3 = false;
  var u = V;
  var p2;
  var f2 = e2.partial;
  var y = makeData(a);
  while (void 0 !== (p2 = v.next())) {
    var h2 = getName(p2);
    var m2 = getFieldArguments(p2, e2.variables);
    var g2 = getFieldAlias(p2);
    var _2 = getDirectives(p2);
    var N2 = getFieldResolver(_2, l, h2, e2);
    var k2 = keyOfField(h2, m2);
    var E2 = joinKeys(s, k2);
    var O2 = readRecord(s, k2);
    var w2 = i ? i[h2] : void 0;
    if (n.schema && l) {
      isFieldAvailableOnType(n.schema, l, h2, e2.store.logger);
    }
    e2.__internal.path.push(g2);
    var b2 = void 0;
    if ("__typename" === h2) {
      b2 = l;
    } else if (void 0 !== w2 && void 0 === p2.selectionSet) {
      b2 = w2;
    } else if ("read" === D && N2) {
      var x2 = y;
      if (void 0 === p2.selectionSet && void 0 !== O2) {
        x2 = {
          ...y,
          [g2]: O2,
          [h2]: O2
        };
      }
      updateContext(e2, x2, l, s, k2, h2);
      b2 = N2(x2, m2 || {}, n, e2);
      if (p2.selectionSet) {
        b2 = resolveResolverResult(e2, l, h2, E2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : a[g2], b2, ownsData(a));
      }
      if (n.schema && null === b2 && !isFieldNullable(n.schema, l, h2, e2.store.logger)) {
        return;
      }
    } else if (!p2.selectionSet) {
      b2 = O2;
    } else if (void 0 !== w2) {
      b2 = resolveResolverResult(e2, l, h2, E2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : a[g2], w2, ownsData(a));
    } else {
      var I2 = readLink(s, k2);
      if (void 0 !== I2) {
        b2 = resolveLink(e2, I2, l, h2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : a[g2], ownsData(a));
      } else if ("object" == typeof O2 && null !== O2) {
        b2 = O2;
      }
    }
    if (!A && void 0 === b2 && (_2.optional || T && !_2.required || getFieldError(e2) || !_2.required && n.schema && isFieldNullable(n.schema, l, h2, e2.store.logger))) {
      e2.partial = true;
      b2 = null;
    } else if (null === b2 && (_2.required || false === T)) {
      if (e2.store.logger && true && "read" === D) {
        e2.store.logger("debug", `Got value "null" for required field "${h2}"${m2 ? ` with args ${JSON.stringify(m2)}` : ""} on entity "${s}"`);
      }
      b2 = void 0;
    } else {
      d2 = d2 || "__typename" !== h2;
    }
    e2.__internal.path.pop();
    u = u || b2 !== a[g2];
    if (void 0 !== b2) {
      y[g2] = b2;
    } else if (A) {
      c3 = true;
    } else {
      if (e2.store.logger && true && "read" === D) {
        e2.store.logger("debug", `No value for field "${h2}"${m2 ? ` with args ${JSON.stringify(m2)}` : ""} on entity "${s}"`);
      }
      e2.partial = f2;
      return;
    }
  }
  e2.partial = e2.partial || f2;
  e2.hasNext = e2.hasNext || c3;
  return o && e2.partial && !d2 ? void 0 : u ? y : a;
};
var resolveResolverResult = (e2, r3, t, a, i, n, o, s) => {
  if (Array.isArray(o)) {
    var { store: l } = e2;
    var v = l.schema ? isListNullable(l.schema, r3, t, e2.store.logger) : false;
    var d2 = e2.partial;
    var c3 = makeData(n, true);
    var u = V || !Array.isArray(n) || o.length !== n.length;
    for (var p2 = 0, f2 = o.length; p2 < f2; p2++) {
      e2.__internal.path.push(p2);
      var y = resolveResolverResult(e2, r3, t, joinKeys(a, `${p2}`), i, null != n ? n[p2] : void 0, o[p2], s);
      e2.__internal.path.pop();
      if (void 0 === y && !v) {
        e2.partial = d2;
        return;
      } else {
        e2.partial = e2.partial || void 0 === y && v;
        c3[p2] = null != y ? y : null;
        u = u || c3[p2] !== n[p2];
      }
    }
    return u ? c3 : n;
  } else if (null == o) {
    return o;
  } else if (s && null === n) {
    return null;
  } else if (isDataOrKey(o)) {
    var h2 = n || makeData(n);
    return "string" == typeof o ? readSelection(e2, o, i, h2) : readSelection(e2, a, i, h2, o);
  } else {
    warn("Invalid resolver value: The field at `" + a + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9, e2.store.logger);
    return;
  }
};
var resolveLink = (e2, r3, t, a, i, n, o) => {
  if (Array.isArray(r3)) {
    var { store: s } = e2;
    var l = s.schema ? isListNullable(s.schema, t, a, e2.store.logger) : false;
    var v = makeData(n, true);
    var d2 = e2.partial;
    var c3 = V || !Array.isArray(n) || r3.length !== n.length;
    for (var u = 0, p2 = r3.length; u < p2; u++) {
      e2.__internal.path.push(u);
      var f2 = resolveLink(e2, r3[u], t, a, i, null != n ? n[u] : void 0, o);
      e2.__internal.path.pop();
      if (void 0 === f2 && !l) {
        e2.partial = d2;
        return;
      } else {
        e2.partial = e2.partial || void 0 === f2 && l;
        v[u] = f2 || null;
        c3 = c3 || v[u] !== n[u];
      }
    }
    return c3 ? v : n;
  } else if (null === r3 || null === n && o) {
    return null;
  }
  return readSelection(e2, r3, i, n || makeData(n));
};
var isDataOrKey = (e2) => "string" == typeof e2 || "object" == typeof e2 && "string" == typeof e2.__typename;
var invalidateEntity = (e2, r3, t) => {
  var a = r3 ? [{
    fieldKey: keyOfField(r3, t)
  }] : inspectFields(e2);
  for (var i = 0, n = a.length; i < n; i++) {
    var { fieldKey: o } = a[i];
    if (void 0 !== readLink(e2, o)) {
      writeLink(e2, o, void 0);
    } else {
      writeRecord(e2, o, void 0);
    }
  }
};
var invalidateType = (e2, r3) => {
  var t = ((e3) => w.types.get(e3) || q)(e2);
  for (var a of t) {
    if (r3.includes(a)) {
      continue;
    }
    invalidateEntity(a);
  }
};
var _write = (e2, t, a, i) => {
  if (true) {
    getCurrentDependencies();
  }
  var n = formatDocument(t.query);
  var o = getMainOperation(n);
  var s = {
    data: a || makeData(),
    dependencies: x
  };
  var l = e2.rootFields[o.operation];
  var v = makeContext(e2, normalizeVariables(o, t.variables), getFragments(n), l, l, i);
  if (true) {
    pushDebugNode(l, o);
  }
  writeSelection(v, l, getSelectionSet(o), s.data);
  if (true) {
    popDebugNode();
  }
  return s;
};
var writeSelection = (e2, r3, t, a) => {
  var i = e2.store.rootNames[r3] || "query";
  var n = !!e2.store.rootNames[r3];
  var o = n ? r3 : a.__typename;
  if (!o && r3 && e2.optimistic) {
    o = readRecord(r3, "__typename");
  }
  if (!o) {
    warn("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14, e2.store.logger);
    return;
  } else if (!n && r3) {
    writeRecord(r3, "__typename", o);
    ((e3, r4) => {
      var t2 = w.types.get(e3);
      if (!t2) {
        var a2 = /* @__PURE__ */ new Set();
        a2.add(r4);
        w.types.set(e3, a2);
      } else {
        t2.add(r4);
      }
    })(o, r3);
  }
  var s = e2.store.updates[o];
  var l = new SelectionIterator(o, r3 || o, false, void 0, t, e2);
  var v;
  while (v = l.next()) {
    var d2 = getName(v);
    var c3 = getFieldArguments(v, e2.variables);
    var u = keyOfField(d2, c3);
    var p2 = getFieldAlias(v);
    var f2 = a[e2.optimistic ? d2 : p2];
    if ("__typename" === d2 || void 0 === f2 && (A || e2.optimistic && "query" === i)) {
      continue;
    }
    if (true) {
      if (e2.store.schema && o && "__typename" !== d2) {
        isFieldAvailableOnType(e2.store.schema, o, d2, e2.store.logger);
      }
    }
    e2.__internal.path.push(p2);
    var y = void 0;
    if (e2.optimistic && "mutation" === i) {
      if (!(y = e2.store.optimisticMutations[d2])) {
        continue;
      }
    } else if (e2.optimistic && "function" == typeof f2) {
      y = f2;
    }
    if (y) {
      updateContext(e2, a, o, r3 || o, u, d2);
      f2 = ensureData(y(c3 || {}, e2.store, e2));
    }
    if (void 0 === f2) {
      if (true) {
        if (!r3 || !hasField(r3, u) || e2.optimistic && !readRecord(r3, "__typename")) {
          warn("Invalid undefined: The field at `" + u + "` is `undefined`, but the GraphQL query expects a " + (void 0 === v.selectionSet ? "scalar (number, boolean, etc)" : "selection set") + " for this field.", 13, e2.store.logger);
        }
      }
      continue;
    }
    if (v.selectionSet) {
      if (r3 && "query" === i) {
        var h2 = joinKeys(r3, u);
        var m2 = writeField(e2, getSelectionSet(v), ensureData(f2), h2, e2.optimistic ? readLink(r3 || o, u) : void 0);
        writeLink(r3 || o, u, m2);
      } else {
        writeField(e2, getSelectionSet(v), ensureData(f2));
      }
    } else if (r3 && "query" === i) {
      writeRecord(r3 || o, u, null !== f2 || !getFieldError(e2) ? f2 : void 0);
    }
    var g2 = s && s[d2];
    if (g2) {
      updateContext(e2, a, o, r3 || o, u, d2);
      a[d2] = f2;
      g2(a, c3 || {}, e2.store, e2);
    } else if (o === e2.store.rootFields.mutation && !e2.optimistic) {
      if (f2 && Array.isArray(f2)) {
        var _2 = f2.map((r4) => e2.store.keyOfEntity(r4) || "");
        for (var N2 = 0, k2 = f2.length; N2 < k2; N2++) {
          var E2 = _2[N2];
          if (E2 && f2[N2].__typename) {
            var O2 = readRecord(E2, "__typename");
            var b2 = getRefCount(E2);
            if (O2 && !b2) {
              invalidateType(f2[N2].__typename, _2);
            }
          }
        }
      } else if (f2 && "object" == typeof f2) {
        var D2 = e2.store.keyOfEntity(f2);
        if (D2) {
          var x2 = readRecord(D2, "__typename");
          var V2 = getRefCount(D2);
          if ((!x2 || !V2) && f2.__typename) {
            invalidateType(f2.__typename, [D2]);
          }
        }
      }
    }
    e2.__internal.path.pop();
  }
};
var M = /^__|PageInfo|(Connection|Edge)$/;
var writeField = (e2, r3, t, a, i) => {
  if (Array.isArray(t)) {
    var n = new Array(t.length);
    for (var o = 0, s = t.length; o < s; o++) {
      e2.__internal.path.push(o);
      var l = a ? joinKeys(a, `${o}`) : void 0;
      var v = writeField(e2, r3, t[o], l, null != i ? i[o] : void 0);
      n[o] = v;
      e2.__internal.path.pop();
    }
    return n;
  } else if (null === t) {
    return getFieldError(e2) ? void 0 : null;
  }
  var d2 = e2.store.keyOfEntity(t) || ("string" == typeof i ? i : null);
  var c3 = t.__typename;
  if (true) {
    if (a && !e2.store.keys[t.__typename] && null === d2 && "string" == typeof c3 && !M.test(c3)) {
      warn("Invalid key: The GraphQL query at the field at `" + a + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + c3 + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + c3 + "` that always returns null.", 15, e2.store.logger);
    }
  }
  var u = d2 || a;
  writeSelection(e2, u, r3, t);
  return u || null;
};
var Store = class {
  constructor(e2) {
    if (!e2) {
      e2 = {};
    }
    this.logger = e2.logger;
    this.resolvers = e2.resolvers || {};
    this.directives = e2.directives || {};
    this.optimisticMutations = e2.optimistic || {};
    this.keys = e2.keys || {};
    this.globalIDs = Array.isArray(e2.globalIDs) ? new Set(e2.globalIDs) : !!e2.globalIDs;
    var r3 = "Query";
    var t = "Mutation";
    var a = "Subscription";
    if (e2.schema) {
      var i = (({ __schema: e3 }) => {
        var r4 = /* @__PURE__ */ new Map();
        var buildNameMap = (e4) => {
          var r5;
          return () => {
            if (!r5) {
              r5 = {};
              for (var t3 = 0; t3 < e4.length; t3++) {
                r5[e4[t3].name] = e4[t3];
              }
            }
            return r5;
          };
        };
        var buildType = (e4) => {
          switch (e4.kind) {
            case "OBJECT":
            case "INTERFACE":
              return {
                name: e4.name,
                kind: e4.kind,
                interfaces: buildNameMap(e4.interfaces || []),
                fields: buildNameMap(e4.fields.map((e5) => ({
                  name: e5.name,
                  type: e5.type,
                  args: buildNameMap(e5.args)
                })))
              };
            case "UNION":
              return {
                name: e4.name,
                kind: e4.kind,
                types: buildNameMap(e4.possibleTypes || [])
              };
          }
        };
        var t2 = {
          query: e3.queryType ? e3.queryType.name : null,
          mutation: e3.mutationType ? e3.mutationType.name : null,
          subscription: e3.subscriptionType ? e3.subscriptionType.name : null,
          types: void 0,
          isSubType(e4, t3) {
            var a3 = r4.get(e4);
            var i3 = r4.get(t3);
            if (!a3 || !i3) {
              return false;
            } else if ("UNION" === a3.kind) {
              return !!a3.types()[t3];
            } else if ("OBJECT" !== a3.kind && "OBJECT" === i3.kind) {
              return !!i3.interfaces()[e4];
            } else {
              return e4 === t3;
            }
          }
        };
        if (e3.types) {
          t2.types = r4;
          for (var a2 = 0; a2 < e3.types.length; a2++) {
            var i2 = e3.types[a2];
            if (i2 && i2.name) {
              var n2 = buildType(i2);
              if (n2) {
                r4.set(i2.name, n2);
              }
            }
          }
        }
        return t2;
      })(e2.schema);
      r3 = i.query || r3;
      t = i.mutation || t;
      a = i.subscription || a;
      if (i.types) {
        this.schema = i;
      }
    }
    this.updates = e2.updates || {};
    this.rootFields = {
      query: r3,
      mutation: t,
      subscription: a
    };
    this.rootNames = {
      [r3]: "query",
      [t]: "mutation",
      [a]: "subscription"
    };
    this.data = (n = r3, {
      hydrating: false,
      defer: false,
      gc: /* @__PURE__ */ new Set(),
      types: /* @__PURE__ */ new Map(),
      persist: /* @__PURE__ */ new Set(),
      queryRootKey: n,
      refCount: /* @__PURE__ */ new Map(),
      links: {
        optimistic: /* @__PURE__ */ new Map(),
        base: /* @__PURE__ */ new Map()
      },
      abstractToConcreteMap: /* @__PURE__ */ new Map(),
      records: {
        optimistic: /* @__PURE__ */ new Map(),
        base: /* @__PURE__ */ new Map()
      },
      deferredKeys: /* @__PURE__ */ new Set(),
      commutativeKeys: /* @__PURE__ */ new Set(),
      dirtyKeys: /* @__PURE__ */ new Set(),
      optimisticOrder: [],
      storage: null
    });
    var n;
    if (this.schema && true) {
      !function expectValidKeyingConfig(e3, r4, t2) {
        if (true) {
          for (var a2 in r4) {
            if (true) {
              if (!e3.types.has(a2)) {
                warn("Invalid Object type: The type `" + a2 + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20, t2);
              }
            }
          }
        }
      }(this.schema, this.keys, this.logger);
      !function expectValidUpdatesConfig(e3, r4, t2) {
        if (false) {
          return;
        }
        for (var a2 in r4) {
          if (!r4[a2]) {
            continue;
          } else if (!e3.types.has(a2)) {
            var i2 = "";
            if ("Mutation" === a2 && e3.mutation && "Mutation" !== e3.mutation) {
              i2 += "\nMaybe your config should reference `" + e3.mutation + "`?";
            } else if ("Subscription" === a2 && e3.subscription && "Subscription" !== e3.subscription) {
              i2 += "\nMaybe your config should reference `" + e3.subscription + "`?";
            }
            return true ? warn("Invalid updates type: The type `" + a2 + "` is not an object in the defined schema, but the `updates` config is referencing it." + i2, 21, t2) : void 0;
          }
          var n2 = e3.types.get(a2).fields();
          for (var o in r4[a2]) {
            if (true) {
              if (!n2[o]) {
                warn("Invalid updates field: `" + o + "` on `" + a2 + "` is not in the defined schema, but the `updates` config is referencing it.", 22, t2);
              }
            }
          }
        }
      }(this.schema, this.updates, this.logger);
      !function expectValidResolversConfig(e3, r4, t2) {
        if (false) {
          return;
        }
        for (var a2 in r4) {
          if ("Query" === a2) {
            if (e3.query) {
              var i2 = e3.types.get(e3.query).fields();
              for (var n2 in r4.Query || {}) {
                if (!i2[n2]) {
                  warnAboutResolver("Query." + n2, t2);
                }
              }
            } else {
              warnAboutResolver("Query", t2);
            }
          } else if (!e3.types.has(a2)) {
            warnAboutResolver(a2, t2);
          } else if ("INTERFACE" === e3.types.get(a2).kind || "UNION" === e3.types.get(a2).kind) {
            warnAboutAbstractResolver(a2, e3.types.get(a2).kind, t2);
          } else {
            var o = e3.types.get(a2).fields();
            for (var s in r4[a2] || {}) {
              if (!o[s]) {
                warnAboutResolver(a2 + "." + s, t2);
              }
            }
          }
        }
      }(this.schema, this.resolvers, this.logger);
      !function expectValidOptimisticMutationsConfig(e3, r4, t2) {
        if (false) {
          return;
        }
        if (e3.mutation) {
          var a2 = e3.types.get(e3.mutation).fields();
          for (var i2 in r4) {
            if (true) {
              if (!a2[i2]) {
                warn(`Invalid optimistic mutation field: \`${i2}\` is not a mutation field in the defined schema, but the \`optimistic\` option is referencing it.`, 24, t2);
              }
            }
          }
        }
      }(this.schema, this.optimisticMutations, this.logger);
    }
  }
  keyOfField(e2, r3) {
    return keyOfField(e2, r3);
  }
  keyOfEntity(e2) {
    if (S && e2 === S.parent) {
      return S.parentKey;
    } else if (null == e2 || "string" == typeof e2) {
      return e2 || null;
    } else if (!e2.__typename) {
      return null;
    } else if (this.rootNames[e2.__typename]) {
      return e2.__typename;
    }
    var r3 = null;
    if (this.keys[e2.__typename]) {
      r3 = this.keys[e2.__typename](e2) || null;
    } else if (null != e2.id) {
      r3 = `${e2.id}`;
    } else if (null != e2._id) {
      r3 = `${e2._id}`;
    }
    var t = e2.__typename;
    return true === this.globalIDs || this.globalIDs && this.globalIDs.has(t) || !r3 ? r3 : `${t}:${r3}`;
  }
  resolve(e2, r3, t) {
    var a = this.keyOfEntity(e2);
    if (a) {
      var i = keyOfField(r3, t);
      var n = readRecord(a, i);
      if (void 0 !== n) {
        return n;
      }
      var o = readLink(a, i);
      if (void 0 !== o) {
        o = ensureLink(this, o);
      }
      return o;
    }
  }
  invalidate(e2, r3, t) {
    var a = this.keyOfEntity(e2);
    if (e2 && "string" == typeof e2 && !r3 && !t && !this.resolve(e2, "__typename")) {
      invalidateType(e2, []);
    } else {
      invariant(a, true ? "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + ("object" == typeof e2 ? e2.__typename : e2 + "`.") : "", 19);
      invalidateEntity(a, r3, t);
    }
  }
  inspectFields(e2) {
    var r3 = this.keyOfEntity(e2);
    return r3 ? inspectFields(r3) : [];
  }
  updateQuery(e2, r3) {
    var a = createRequest(e2.query, e2.variables);
    var i = r3(this.readQuery(a));
    if (null !== i) {
      _write(this, a, i, void 0);
    }
  }
  readQuery(e2) {
    var r3 = createRequest(e2.query, e2.variables);
    return _query(this, r3, void 0, void 0).data;
  }
  readFragment(e2, t, a, i) {
    return ((e3, r3, t2, a2, i2) => {
      var n = getFragments(r3);
      var o;
      if (i2) {
        if (!(o = n[i2])) {
          warn("readFragment(...) was called with a fragment name that does not exist.\nYou provided " + i2 + " but could only find " + Object.keys(n).join(", ") + ".", 6, e3.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        warn("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6, e3.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      if ("string" != typeof t2 && !t2.__typename) {
        t2.__typename = s;
      }
      var l = e3.keyOfEntity(t2);
      if (!l) {
        warn("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 7, e3.logger);
        return null;
      }
      if (true) {
        pushDebugNode(s, o);
      }
      var v = makeContext(e3, a2 || {}, n, s, l, void 0);
      var d2 = readSelection(v, l, getSelectionSet(o), makeData()) || null;
      if (true) {
        popDebugNode();
      }
      return d2;
    })(this, formatDocument(e2), t, a, i);
  }
  writeFragment(e2, t, a, i) {
    ((e3, r3, t2, a2, i2) => {
      var n = getFragments(r3);
      var o;
      if (i2) {
        if (!(o = n[i2])) {
          warn("writeFragment(...) was called with a fragment name that does not exist.\nYou provided " + i2 + " but could only find " + Object.keys(n).join(", ") + ".", 11, e3.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        warn("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11, e3.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      var l = {
        __typename: s,
        ...t2
      };
      var v = e3.keyOfEntity(l);
      if (!v) {
        return true ? warn("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 12, e3.logger) : void 0;
      }
      if (true) {
        pushDebugNode(s, o);
      }
      var d2 = makeContext(e3, a2 || {}, n, s, v, void 0);
      writeSelection(d2, v, getSelectionSet(o), l);
      if (true) {
        popDebugNode();
      }
    })(this, formatDocument(e2), t, a, i);
  }
  link(e2, r3, ...t) {
    var a = 2 === t.length ? t[0] : null;
    var i = 2 === t.length ? t[1] : t[0];
    var n = this.keyOfEntity(e2);
    if (n) {
      writeLink(n, keyOfField(r3, a), ensureLink(this, i));
    }
  }
};
var addMetadata = (e2, r3) => makeOperation(e2.kind, e2, {
  ...e2.context,
  meta: {
    ...e2.context.meta,
    ...r3
  }
});
var toRequestPolicy = (e2, r3) => makeOperation(e2.kind, e2, {
  ...e2.context,
  requestPolicy: r3
});
var cacheExchange = (e2) => ({ forward: t, client: i, dispatchDebug: n }) => {
  var o = new Store(e2);
  if (e2 && e2.storage) {
    o.data.hydrating = true;
    e2.storage.readData().then((r3) => {
      ((e3, r4, t2) => {
        initDataState("write", e3, null);
        for (var a in t2) {
          var i2 = t2[a];
          if (void 0 !== i2) {
            var { entityKey: n2, fieldKey: o2 } = deserializeKeyInfo(a);
            if (":" === i2[0]) {
              if (void 0 === readLink(n2, o2)) {
                writeLink(n2, o2, JSON.parse(i2.slice(1)));
              }
            } else if (void 0 === readRecord(n2, o2)) {
              writeRecord(n2, o2, JSON.parse(i2));
            }
          }
        }
        e3.storage = r4;
        e3.hydrating = false;
        clearDataState();
      })(o.data, e2.storage, r3);
      if (e2.storage.onCacheHydrated) {
        e2.storage.onCacheHydrated();
      }
    });
  }
  var f2 = /* @__PURE__ */ new Map();
  var y = [];
  var h2 = /* @__PURE__ */ new Map();
  var m2 = /* @__PURE__ */ new Map();
  var g2 = /* @__PURE__ */ new Set();
  var _2 = /* @__PURE__ */ new Set();
  var N2 = /* @__PURE__ */ new Map();
  var k2 = /* @__PURE__ */ new Set();
  var E2 = /* @__PURE__ */ new Set();
  var isBlockedByOptimisticUpdate = (e3) => {
    for (var r3 of e3.values()) {
      if (g2.has(r3)) {
        return true;
      }
    }
    return false;
  };
  var collectPendingOperations = (e3, r3) => {
    if (r3) {
      for (var t2 of r3.values()) {
        var a = N2.get(t2);
        if (a) {
          for (var i2 of a.values()) {
            e3.add(i2);
          }
        }
      }
    }
  };
  var executePendingOperations = (e3, r3, t2) => {
    for (var a of r3.values()) {
      if (a !== e3.key) {
        var n2 = h2.get(a);
        if (n2) {
          if ("query" === e3.kind) {
            E2.add(a);
          }
          var o2 = "cache-first";
          if (_2.has(a)) {
            _2.delete(a);
            o2 = "cache-and-network";
          }
          i.reexecuteOperation(toRequestPolicy(n2, o2));
        }
      }
    }
    if (!t2) {
      var s = k2;
      k2 = E2;
      if ("query" === e3.kind) {
        k2.add(e3.key);
      }
      (E2 = s).clear();
    }
  };
  var prepareForwardedOperation = (e3) => {
    var t2 = false;
    if ("query" === e3.kind) {
      reserveLayer(o.data, e3.key);
      h2.set(e3.key, e3);
    } else if ("teardown" === e3.kind) {
      h2.delete(e3.key);
      m2.delete(e3.key);
      k2.delete(e3.key);
      noopDataState(o.data, e3.key);
      return e3;
    } else if ("mutation" === e3.kind && "network-only" !== e3.context.requestPolicy) {
      h2.set(e3.key, e3);
      initDataState("write", o.data, e3.key, true, false);
      var { dependencies: i2 } = _write(o, e3, void 0, void 0);
      clearDataState();
      if (i2.size) {
        for (var n2 of i2.values()) {
          g2.add(n2);
        }
        f2.set(e3.key, i2);
        var s = /* @__PURE__ */ new Set();
        collectPendingOperations(s, i2);
        executePendingOperations(e3, s, true);
        t2 = true;
      }
    }
    return makeOperation(e3.kind, {
      key: e3.key,
      query: formatDocument(e3.query),
      variables: e3.variables ? filterVariables(getMainOperation(e3.query), e3.variables) : e3.variables
    }, {
      ...e3.context,
      optimistic: t2
    });
  };
  var updateDependencies2 = (e3, r3) => {
    for (var t2 of r3.values()) {
      var a = N2.get(t2);
      if (!a) {
        N2.set(t2, a = /* @__PURE__ */ new Set());
      }
      a.add(e3.key);
    }
  };
  var operationResultFromCache = (e3) => {
    initDataState("read", o.data, void 0, false, false);
    var r3 = _query(o, e3, m2.get(e3.key), void 0);
    clearDataState();
    var t2 = r3.data ? !r3.partial && !r3.hasNext ? "hit" : "partial" : "miss";
    m2.set(e3.key, r3.data);
    h2.set(e3.key, e3);
    updateDependencies2(e3, r3.dependencies);
    return {
      outcome: t2,
      operation: e3,
      data: r3.data,
      dependencies: r3.dependencies,
      hasNext: r3.hasNext
    };
  };
  var updateCacheWithResult = (e3, r3) => {
    var t2 = h2.get(e3.operation.key) || e3.operation;
    if ("mutation" === t2.kind) {
      var a = f2.get(t2.key);
      collectPendingOperations(r3, a);
      f2.delete(t2.key);
    }
    if ("subscription" === t2.kind || e3.hasNext) {
      reserveLayer(o.data, t2.key, true);
    }
    var i2;
    var n2 = e3.data;
    if (n2) {
      initDataState("write", o.data, t2.key, false, false);
      var s = _write(o, t2, n2, e3.error).dependencies;
      clearDataState();
      collectPendingOperations(r3, s);
      var l = "query" === t2.kind ? m2.get(t2.key) : null;
      initDataState("read", o.data, t2.key, false, l !== n2);
      var v = _query(o, t2, l || n2, e3.error);
      clearDataState();
      n2 = v.data;
      if ("query" === t2.kind) {
        collectPendingOperations(r3, i2 = v.dependencies);
        m2.set(t2.key, n2);
      }
    } else {
      noopDataState(o.data, t2.key);
    }
    if (i2) {
      updateDependencies2(e3.operation, i2);
    }
    return {
      operation: t2,
      data: n2,
      error: e3.error,
      extensions: e3.extensions,
      hasNext: e3.hasNext,
      stale: e3.stale
    };
  };
  return (e3) => {
    var r3 = share(map2(operationResultFromCache)(filter((e4) => "query" === e4.kind && "network-only" !== e4.context.requestPolicy)(e3)));
    var a = filter((e4) => "query" !== e4.kind || "network-only" === e4.context.requestPolicy)(e3);
    var m3 = map2((e4) => {
      n({
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache",
        operation: e4.operation,
        source: "cacheExchange"
      });
      return true ? addMetadata(e4.operation, {
        cacheOutcome: "miss"
      }) : e4.operation;
    })(filter((e4) => "miss" === e4.outcome && "cache-only" !== e4.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e4.dependencies) && !k2.has(e4.operation.key))(r3));
    var N3 = map2((e4) => {
      var { requestPolicy: r4 } = e4.operation.context;
      var t2 = "cache-only" !== r4 && (e4.hasNext || "cache-and-network" === r4 || "cache-first" === r4 && "partial" === e4.outcome && !k2.has(e4.operation.key));
      var a2 = "cache-only" !== r4 && (t2 || "partial" === e4.outcome && k2.has(e4.operation.key) && ((s = o.data).commutativeKeys.has(l = e4.operation.key) || s.optimisticOrder.indexOf(l) > -1));
      var s, l;
      var v = {
        operation: true ? addMetadata(e4.operation, {
          cacheOutcome: e4.outcome
        }) : e4.operation,
        data: e4.data,
        error: e4.error,
        extensions: e4.extensions,
        stale: a2 && !e4.hasNext,
        hasNext: t2 && e4.hasNext
      };
      if (!t2) {
      } else if (!isBlockedByOptimisticUpdate(e4.dependencies)) {
        i.reexecuteOperation(toRequestPolicy(h2.get(e4.operation.key) || e4.operation, "network-only"));
      } else if ("cache-and-network" === r4) {
        _2.add(e4.operation.key);
      }
      n({
        type: "cacheHit",
        message: "A requested operation was found and returned from the cache.",
        operation: e4.operation,
        data: {
          value: v
        },
        source: "cacheExchange"
      });
      return v;
    })(filter((e4) => "miss" !== e4.outcome || "cache-only" === e4.operation.context.requestPolicy)(r3));
    var E3 = t(map2(prepareForwardedOperation)(merge([a, m3])));
    var O2 = map2((e4) => {
      var r4 = /* @__PURE__ */ new Set();
      var t2 = updateCacheWithResult(e4, r4);
      executePendingOperations(e4.operation, r4, false);
      return t2;
    })(filter((e4) => !f2.has(e4.operation.key))(E3));
    var w2 = mergeMap((e4) => {
      if (y.push(e4) < f2.size) {
        return empty;
      }
      for (var r4 = 0; r4 < y.length; r4++) {
        reserveLayer(o.data, y[r4].operation.key);
      }
      g2.clear();
      var t2 = [];
      var a2 = /* @__PURE__ */ new Set();
      var i2;
      while (i2 = y.shift()) {
        t2.push(updateCacheWithResult(i2, a2));
      }
      executePendingOperations(e4.operation, a2, false);
      return r(t2);
    })(filter((e4) => f2.has(e4.operation.key))(E3));
    return merge([O2, w2, N3]);
  };
};

// node_modules/@urql/exchange-auth/dist/urql-exchange-auth.mjs
var addAuthAttemptToOperation = (t, e2) => makeOperation(t.kind, t, {
  ...t.context,
  authAttempt: e2
});
function authExchange(s) {
  return ({ client: f2, forward: d2 }) => {
    var l = /* @__PURE__ */ new Set();
    var p2 = makeSubject();
    var x2 = makeSubject();
    var A2 = /* @__PURE__ */ new Map();
    function flushQueue() {
      v = void 0;
      var t = A2;
      A2 = /* @__PURE__ */ new Map();
      t.forEach(p2.next);
    }
    function errorQueue(t) {
      v = void 0;
      var e2 = A2;
      A2 = /* @__PURE__ */ new Map();
      e2.forEach((e3) => {
        x2.next(makeErrorResult(e3, t));
      });
    }
    var v;
    var w2 = null;
    return (t) => {
      function initAuth() {
        v = Promise.resolve().then(() => s({
          mutate(t2, n, r3) {
            var u = f2.createRequestOperation("mutation", createRequest(t2, n), r3);
            return toPromise(take(1)(filter((t3) => t3.operation.key === u.key && u.context._instance === t3.operation.context._instance)(onStart(() => {
              var t3 = addAuthToOperation(u);
              l.add(t3.context._instance);
              p2.next(t3);
            })(E2))));
          },
          appendHeaders(t2, e2) {
            var n = "function" == typeof t2.context.fetchOptions ? t2.context.fetchOptions() : t2.context.fetchOptions || {};
            return makeOperation(t2.kind, t2, {
              ...t2.context,
              fetchOptions: {
                ...n,
                headers: {
                  ...n.headers,
                  ...e2
                }
              }
            });
          }
        })).then((t2) => {
          if (t2) {
            w2 = t2;
          }
          flushQueue();
        }).catch((t2) => {
          if (true) {
            console.warn("authExchange()’s initialization function has failed, which is unexpected.\nIf your initialization function is expected to throw/reject, catch this error and handle it explicitly.\nUnless this error is handled it’ll be passed onto any `OperationResult` instantly and authExchange() will block further operations and retry.", t2);
          }
          errorQueue(t2);
        });
      }
      initAuth();
      function refreshAuth(t2) {
        A2.set(t2.key, addAuthAttemptToOperation(t2, true));
        if (w2 && !v) {
          v = w2.refreshAuth().then(flushQueue).catch(errorQueue);
        }
      }
      function addAuthToOperation(t2) {
        return w2 ? w2.addAuthToOperation(t2) : t2;
      }
      var h2 = filter(Boolean)(map2((t2) => {
        if ("teardown" === t2.kind) {
          A2.delete(t2.key);
          return t2;
        } else if (t2.context._instance && l.has(t2.context._instance)) {
          return t2;
        } else if (t2.context.authAttempt) {
          return addAuthToOperation(t2);
        } else if (v || !w2) {
          if (!v) {
            initAuth();
          }
          if (!A2.has(t2.key)) {
            A2.set(t2.key, addAuthAttemptToOperation(t2, false));
          }
          return null;
        } else if (function willAuthError(t3) {
          return !t3.context.authAttempt && w2 && w2.willAuthError && w2.willAuthError(t3);
        }(t2)) {
          refreshAuth(t2);
          return null;
        }
        return addAuthToOperation(addAuthAttemptToOperation(t2, false));
      })(merge([p2.source, t])));
      var E2 = d2(h2);
      return merge([x2.source, filter((t2) => {
        if (!l.has(t2.operation.context._instance) && t2.error && function didAuthError(t3) {
          return w2 && w2.didAuthError && w2.didAuthError(t3.error, t3.operation);
        }(t2) && !t2.operation.context.authAttempt) {
          refreshAuth(t2.operation);
          return false;
        }
        if (l.has(t2.operation.context._instance)) {
          l.delete(t2.operation.context._instance);
        }
        return true;
      })(E2)]);
    };
  };
}

// node_modules/@urql/exchange-persisted/dist/urql-exchange-persisted.mjs
var d = "undefined" != typeof window ? window.crypto : "undefined" != typeof self ? self.crypto : null;
var p;
var hash = async (e2) => {
  if (d && d.subtle) {
    var r3 = await d.subtle.digest({
      name: "SHA-256"
    }, new TextEncoder().encode(e2));
    return new Uint8Array(r3).reduce((e3, r4) => e3 + r4.toString(16).padStart(2, "0"), "");
  } else if (await (async () => {
    if (!p) {
      try {
        p = new Function("require", 'return require("crypto")')(__require);
      } catch (e3) {
        try {
          p = new Function('return import("crypto")')();
        } catch (e4) {
        }
      }
    }
    return p;
  })()) {
    return (await p).createHash("sha256").update(e2).digest("hex");
  }
  if (true) {
    console.warn("[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\nThis is an unexpected error. Please report it by filing a GitHub Issue.");
  }
  return "";
};
var persistedExchange = (d2) => ({ forward: p2 }) => {
  if (!d2) {
    d2 = {};
  }
  var c3 = d2.preferGetForPersistedQueries;
  var y = !!d2.enforcePersistedQueries;
  var f2 = d2.generateHash || hash;
  var h2 = !!d2.enableForMutation;
  var l = !!d2.enableForSubscriptions;
  var x2 = true;
  var operationFilter = (e2) => x2 && !e2.context.persistAttempt && (h2 && "mutation" === e2.kind || l && "subscription" === e2.kind || "query" === e2.kind);
  return (d3) => {
    var h3 = makeSubject();
    var l2 = filter((e2) => !operationFilter(e2))(d3);
    var v = mergeMap((e2) => {
      var t = (async (e3) => {
        var r3 = makeOperation(e3.kind, e3, {
          ...e3.context,
          persistAttempt: true
        });
        var t2 = await f2(stringifyDocument(e3.query), e3.query);
        if (t2) {
          r3.extensions = {
            ...r3.extensions,
            persistedQuery: {
              version: 1,
              sha256Hash: t2
            }
          };
          if ("query" === r3.kind && c3) {
            r3.context.preferGetMethod = c3;
          }
        }
        return r3;
      })(e2);
      return takeUntil(filter((r3) => "teardown" === r3.kind && r3.key === e2.key)(d3))(fromPromise(t));
    })(filter(operationFilter)(d3));
    return filter((e2) => !!e2)(map2((e2) => {
      if (!y && e2.operation.extensions && e2.operation.extensions.persistedQuery) {
        if (e2.error && e2.error.graphQLErrors.some((e3) => "PersistedQueryNotSupported" === e3.message)) {
          x2 = false;
          var r3 = makeOperation(e2.operation.kind, e2.operation);
          if (r3.extensions) {
            delete r3.extensions.persistedQuery;
          }
          h3.next(r3);
          return null;
        } else if (e2.error && ((e3) => e3.graphQLErrors.some((e4) => "PersistedQueryNotFound" === e4.message))(e2.error)) {
          if (e2.operation.extensions.persistedQuery.miss) {
            if (true) {
              console.warn("persistedExchange()’s results include two misses for the same operation.\nThis is not expected as it means a persisted error has been delivered for a non-persisted query!\nAnother exchange with a cache may be delivering an outdated result. For example, a server-side ssrExchange() may be caching an errored result.\nTry moving the persistedExchange() in past these exchanges, for example in front of your fetchExchange.");
            }
            return e2;
          }
          var t = makeOperation(e2.operation.kind, e2.operation);
          t.extensions = {
            ...t.extensions,
            persistedQuery: {
              ...(t.extensions || {}).persistedQuery,
              miss: true
            }
          };
          h3.next(t);
          return null;
        }
      }
      return e2;
    })(p2(merge([v, l2, h3.source]))));
  };
};

// node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache-extras.mjs
var r2 = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: false,
  hasPreviousPage: false
};
var ensureKey = (e2) => "string" == typeof e2 ? e2 : null;
var concatEdges = (e2, r3, a) => {
  var n = /* @__PURE__ */ new Set();
  for (var t = 0, s = r3.length; t < s; t++) {
    var o = e2.resolve(r3[t], "node");
    if ("string" == typeof o) {
      n.add(o);
    }
  }
  var f2 = r3.slice();
  for (var i = 0, v = a.length; i < v; i++) {
    var l = a[i];
    var u = e2.resolve(l, "node");
    if ("string" == typeof u && !n.has(u)) {
      n.add(u);
      f2.push(l);
    }
  }
  return f2;
};
var concatNodes = (e2, r3) => {
  var a = /* @__PURE__ */ new Set();
  for (var n = 0, t = e2.length; n < t; n++) {
    var s = e2[n];
    if ("string" == typeof s) {
      a.add(s);
    }
  }
  var o = e2.slice();
  for (var f2 = 0, i = r3.length; f2 < i; f2++) {
    var v = r3[f2];
    if ("string" == typeof v && !a.has(v)) {
      a.add(v);
      o.push(v);
    }
  }
  return o;
};
var compareArgs = (r3, a) => {
  for (var n in a) {
    if ("first" === n || "last" === n || "after" === n || "before" === n) {
      continue;
    } else if (!(n in r3)) {
      return false;
    }
    var t = r3[n];
    var s = a[n];
    if (typeof t != typeof s || "object" != typeof t ? t !== s : stringifyVariables(t) !== stringifyVariables(s)) {
      return false;
    }
  }
  for (var o in r3) {
    if ("first" === o || "last" === o || "after" === o || "before" === o) {
      continue;
    }
    if (!(o in a)) {
      return false;
    }
  }
  return true;
};
var getPage = (e2, a, n) => {
  var t = ensureKey(e2.resolve(a, n));
  if (!t) {
    return null;
  }
  var s = e2.resolve(t, "__typename");
  var o = e2.resolve(t, "edges") || [];
  var f2 = e2.resolve(t, "nodes") || [];
  if ("string" != typeof s) {
    return null;
  }
  var i = {
    __typename: s,
    edges: o,
    nodes: f2,
    pageInfo: r2
  };
  var v = e2.resolve(t, "pageInfo");
  if ("string" == typeof v) {
    var l = ensureKey(e2.resolve(v, "__typename"));
    var u = ensureKey(e2.resolve(v, "endCursor"));
    var g2 = ensureKey(e2.resolve(v, "startCursor"));
    var p2 = e2.resolve(v, "hasNextPage");
    var d2 = e2.resolve(v, "hasPreviousPage");
    var y = i.pageInfo = {
      __typename: "string" == typeof l ? l : "PageInfo",
      hasNextPage: "boolean" == typeof p2 ? p2 : !!u,
      hasPreviousPage: "boolean" == typeof d2 ? d2 : !!g2,
      endCursor: u,
      startCursor: g2
    };
    if (null === y.endCursor) {
      var m2 = o[o.length - 1];
      if (m2) {
        var h2 = e2.resolve(m2, "cursor");
        y.endCursor = ensureKey(h2);
      }
    }
    if (null === y.startCursor) {
      var _2 = o[0];
      if (_2) {
        var c3 = e2.resolve(_2, "cursor");
        y.startCursor = ensureKey(c3);
      }
    }
  }
  return i;
};
var relayPagination = (e2 = {}) => {
  var a = e2.mergeMode || "inwards";
  return (e3, n, t, s) => {
    var { parentKey: o, fieldName: f2 } = s;
    var i = t.inspectFields(o).filter((e4) => e4.fieldName === f2);
    var v = i.length;
    if (0 === v) {
      return;
    }
    var l = null;
    var u = [];
    var g2 = [];
    var p2 = [];
    var d2 = [];
    var y = {
      ...r2
    };
    for (var m2 = 0; m2 < v; m2++) {
      var { fieldKey: h2, arguments: _2 } = i[m2];
      if (null === _2 || !compareArgs(n, _2)) {
        continue;
      }
      var c3 = getPage(t, o, h2);
      if (null === c3) {
        continue;
      }
      if (0 === c3.nodes.length && 0 === c3.edges.length && l) {
        continue;
      }
      if ("inwards" === a && "number" == typeof _2.last && "number" == typeof _2.first) {
        var P = c3.edges.slice(0, _2.first + 1);
        var C = c3.edges.slice(-_2.last);
        var I2 = c3.nodes.slice(0, _2.first + 1);
        var b2 = c3.nodes.slice(-_2.last);
        u = concatEdges(t, u, P);
        g2 = concatEdges(t, C, g2);
        p2 = concatNodes(p2, I2);
        d2 = concatNodes(b2, d2);
        y = c3.pageInfo;
      } else if (_2.after) {
        u = concatEdges(t, u, c3.edges);
        p2 = concatNodes(p2, c3.nodes);
        y.endCursor = c3.pageInfo.endCursor;
        y.hasNextPage = c3.pageInfo.hasNextPage;
      } else if (_2.before) {
        g2 = concatEdges(t, c3.edges, g2);
        d2 = concatNodes(c3.nodes, d2);
        y.startCursor = c3.pageInfo.startCursor;
        y.hasPreviousPage = c3.pageInfo.hasPreviousPage;
      } else if ("number" == typeof _2.last) {
        g2 = concatEdges(t, c3.edges, g2);
        d2 = concatNodes(c3.nodes, d2);
        y = c3.pageInfo;
      } else {
        u = concatEdges(t, u, c3.edges);
        p2 = concatNodes(p2, c3.nodes);
        y = c3.pageInfo;
      }
      if (c3.pageInfo.__typename !== y.__typename) {
        y.__typename = c3.pageInfo.__typename;
      }
      if (l !== c3.__typename) {
        l = c3.__typename;
      }
    }
    if ("string" != typeof l) {
      return;
    }
    if (!!!ensureKey(t.resolve(o, f2, n))) {
      if (!s.store.schema) {
        return;
      } else {
        s.partial = true;
      }
    }
    return {
      __typename: l,
      edges: "inwards" === a ? concatEdges(t, u, g2) : concatEdges(t, g2, u),
      nodes: "inwards" === a ? concatNodes(p2, d2) : concatNodes(d2, p2),
      pageInfo: {
        __typename: y.__typename,
        endCursor: y.endCursor,
        startCursor: y.startCursor,
        hasNextPage: y.hasNextPage,
        hasPreviousPage: y.hasPreviousPage
      }
    };
  };
};

// node_modules/@keystatic/core/dist/keystatic-core-ui.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_react_dom2 = __toESM(require_react_dom());
var import_escape_string_regexp = __toESM(require_escape_string_regexp());
var import_cookie = __toESM(require_dist());
var collator = new Intl.Collator(void 0, {
  sensitivity: "base"
});
function sortBy(direction, valueA, valueB) {
  const modifier = direction === "ascending" ? 1 : -1;
  if (valueA == null) return 1;
  if (valueB == null) return -1;
  if (typeof valueA === "string" && typeof valueB === "string") {
    return collator.compare(valueA, valueB) * modifier;
  }
  return compare(valueA, valueB) * modifier;
}
function compare(a, b2) {
  if (a < b2) return -1;
  if (a > b2) return 1;
  return 0;
}
function EmptyState2(props) {
  const $ = c(5);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      mobile: "medium",
      tablet: "xlarge",
      desktop: "xxlarge"
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = "children" in props ? props.children : (0, import_jsx_runtime20.jsxs)(import_jsx_runtime20.Fragment, {
      children: [props.icon && (0, import_jsx_runtime20.jsx)(Icon, {
        src: props.icon,
        size: "large",
        color: "neutralEmphasis"
      }), props.title && (0, import_jsx_runtime20.jsx)(Heading, {
        align: "center",
        size: "medium",
        children: props.title
      }), props.message && (0, import_jsx_runtime20.jsx)(Text, {
        align: "center",
        children: props.message
      }), props.actions]
    });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t1) {
    t2 = (0, import_jsx_runtime20.jsx)(Flex, {
      alignItems: "center",
      direction: "column",
      gap: "large",
      justifyContent: "center",
      minHeight: "scale.3000",
      paddingX: t0,
      children: t1
    });
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}
var NotFoundError = class extends Error {
  constructor() {
    super("Not found");
    this.name = "NotFoundError";
  }
};
function isNotFoundError(err) {
  return typeof err === "object" && err !== null && err instanceof NotFoundError;
}
function notFound() {
  throw new NotFoundError();
}
var NotFoundErrorBoundaryInner = class extends import_react8.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      notFound: false,
      lastHref: props.href
    };
  }
  static getDerivedStateFromError(err) {
    if (isNotFoundError(err)) {
      return {
        notFound: true
      };
    }
    throw err;
  }
  static getDerivedStateFromProps(props, state) {
    if (props.href !== state.lastHref && state.notFound) {
      return {
        notFound: false,
        lastHref: props.href
      };
    }
    return {
      notFound: state.notFound,
      lastHref: props.href
    };
  }
  render() {
    if (this.state.notFound) return this.props.fallback;
    return this.props.children;
  }
};
function NotFoundBoundary(props) {
  const $ = c(3);
  const router = useRouter();
  let t0;
  if ($[0] !== props || $[1] !== router.href) {
    t0 = (0, import_jsx_runtime20.jsx)(NotFoundErrorBoundaryInner, {
      ...props,
      href: router.href
    });
    $[0] = props;
    $[1] = router.href;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
var _onGet;
var TrackedMap = class extends Map {
  constructor(onGet, entries) {
    super(entries);
    __privateAdd(this, _onGet);
    __privateSet(this, _onGet, onGet);
  }
  get(key) {
    __privateGet(this, _onGet).call(this, key);
    return super.get(key);
  }
};
_onGet = new WeakMap();
function parseEntry(args, files) {
  const dataFilepath = getEntryDataFilepath(args.dirpath, args.format);
  const data = files.get(dataFilepath);
  if (!data) {
    throw new Error(`Could not find data file at ${dataFilepath}`);
  }
  const {
    loaded,
    extraFakeFile
  } = loadDataFile(data, args.format, args.requireFrontmatter);
  const filesWithFakeFile = new Map(files);
  if (extraFakeFile) {
    filesWithFakeFile.set(`${args.dirpath}/${extraFakeFile.path}`, extraFakeFile.contents);
  }
  const usedFiles = /* @__PURE__ */ new Set([dataFilepath]);
  const rootSchema = object2(args.schema);
  let initialState;
  const getFile = (filepath) => {
    usedFiles.add(filepath);
    return filesWithFakeFile.get(filepath);
  };
  const getFilesForAssetsOrContentField = (rootPath, schema2) => {
    const otherFiles = new TrackedMap((key) => {
      usedFiles.add(`${rootPath}/${key}`);
    });
    const otherDirectories = /* @__PURE__ */ new Map();
    for (const [filename] of filesWithFakeFile) {
      if (filename.startsWith(rootPath + "/")) {
        const relativePath = filename.slice(rootPath.length + 1);
        otherFiles.set(relativePath, filesWithFakeFile.get(filename));
      }
    }
    for (const dir of (_schema$directories = schema2.directories) !== null && _schema$directories !== void 0 ? _schema$directories : []) {
      var _schema$directories, _args$slug, _args$slug2;
      const dirFiles = new TrackedMap((relativePath) => usedFiles.add(start + relativePath));
      const start = `${dir}${((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.slug) === void 0 ? "" : `/${(_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.slug}`}/`;
      for (const [filename, val] of filesWithFakeFile) {
        if (filename.startsWith(start)) {
          const relativePath = filename.slice(start.length);
          dirFiles.set(relativePath, val);
        }
      }
      if (dirFiles.size) {
        otherDirectories.set(dir, dirFiles);
      }
    }
    return {
      other: otherFiles,
      external: otherDirectories
    };
  };
  try {
    initialState = parseProps(rootSchema, loaded, [], [], (schema2, value, path, pathWithArrayFieldSlugs) => {
      var _args$slug3;
      if (path.length === 1 && path[0] === ((_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.field)) {
        if (schema2.formKind !== "slug") {
          throw new Error(`slugField is not a slug field`);
        }
        return schema2.parse(value, {
          slug: args.slug.slug
        });
      }
      if (schema2.formKind === "asset") {
        var _args$slug4, _args$slug5, _args$slug6;
        const suggestedFilenamePrefix = pathWithArrayFieldSlugs.join("/");
        const filepath = schema2.filename(value, {
          suggestedFilenamePrefix,
          slug: (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.slug
        });
        const asset = filepath ? getFile(`${schema2.directory ? `${schema2.directory}${((_args$slug5 = args.slug) === null || _args$slug5 === void 0 ? void 0 : _args$slug5.slug) === void 0 ? "" : `/${args.slug.slug}`}` : args.dirpath}/${filepath}`) : void 0;
        return schema2.parse(value, {
          asset,
          slug: (_args$slug6 = args.slug) === null || _args$slug6 === void 0 ? void 0 : _args$slug6.slug
        });
      }
      if (schema2.formKind === "content" || schema2.formKind === "assets") {
        const rootPath = `${args.dirpath}/${pathWithArrayFieldSlugs.join("/")}`;
        const {
          external,
          other
        } = getFilesForAssetsOrContentField(rootPath, schema2);
        if (schema2.formKind === "content") {
          var _args$slug7;
          const mainFilepath = rootPath + schema2.contentExtension;
          const mainContents = getFile(mainFilepath);
          return schema2.parse(value, {
            content: mainContents,
            other,
            external,
            slug: (_args$slug7 = args.slug) === null || _args$slug7 === void 0 ? void 0 : _args$slug7.slug
          });
        }
        if (schema2.formKind === "assets") {
          var _args$slug8;
          return schema2.parse(value, {
            other,
            external,
            slug: (_args$slug8 = args.slug) === null || _args$slug8 === void 0 ? void 0 : _args$slug8.slug
          });
        }
      }
      return schema2.parse(value, void 0);
    }, false);
  } catch (err) {
    throw toFormattedFormDataError(err);
  }
  if (extraFakeFile) {
    usedFiles.delete(`${args.dirpath}/${extraFakeFile.path}`);
  }
  return {
    initialState,
    initialFiles: [...usedFiles]
  };
}
function getAllFilesInTree(tree) {
  return [...tree.values()].flatMap((val) => val.children ? getAllFilesInTree(val.children) : [val.entry]);
}
function useItemData(args) {
  var _args$slug10;
  const {
    current: currentBranch
  } = useTree();
  const baseCommit = useBaseCommit();
  const repoInfo = useRepoInfo();
  const rootTree = currentBranch.kind === "loaded" ? currentBranch.data.tree : void 0;
  const locationsForTreeKey = (0, import_react8.useMemo)(() => {
    var _args$slug9;
    return getDirectoriesForTreeKey(object2(args.schema), args.dirpath, (_args$slug9 = args.slug) === null || _args$slug9 === void 0 ? void 0 : _args$slug9.slug, args.format);
  }, [args.dirpath, args.format, args.schema, (_args$slug10 = args.slug) === null || _args$slug10 === void 0 ? void 0 : _args$slug10.slug]);
  const localTreeKey = (0, import_react8.useMemo)(() => getTreeKey(locationsForTreeKey, rootTree !== null && rootTree !== void 0 ? rootTree : /* @__PURE__ */ new Map()), [locationsForTreeKey, rootTree]);
  const tree = (0, import_react8.useMemo)(() => {
    return rootTree !== null && rootTree !== void 0 ? rootTree : /* @__PURE__ */ new Map();
  }, [localTreeKey, locationsForTreeKey]);
  const hasLoaded = currentBranch.kind === "loaded";
  return useData((0, import_react8.useCallback)(() => {
    var _getTreeNodeAtPath;
    if (!hasLoaded) return LOADING;
    const dataFilepathSha = (_getTreeNodeAtPath = getTreeNodeAtPath(tree, getEntryDataFilepath(args.dirpath, args.format))) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
    if (dataFilepathSha === void 0) {
      return "not-found";
    }
    const _args = {
      dirpath: args.dirpath,
      format: args.format,
      schema: args.schema,
      slug: args.slug
    };
    const allBlobs = locationsForTreeKey.flatMap((dir) => {
      const node = getTreeNodeAtPath(tree, dir);
      if (!node) return [];
      return node.children ? getAllFilesInTree(node.children) : [node.entry];
    }).map((entry) => {
      const blob = fetchBlob(args.config, entry.sha, entry.path, baseCommit, repoInfo);
      if (blob instanceof Uint8Array) {
        return [entry.path, blob];
      }
      return blob.then((blob_0) => [entry.path, blob_0]);
    });
    if (allBlobs.every((x2) => Array.isArray(x2))) {
      const {
        initialFiles,
        initialState
      } = parseEntry(_args, new Map(allBlobs));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    }
    return Promise.all(allBlobs).then(async (data) => {
      const {
        initialState: initialState_0,
        initialFiles: initialFiles_0
      } = parseEntry(_args, new Map(data));
      return {
        initialState: initialState_0,
        initialFiles: initialFiles_0,
        localTreeKey
      };
    });
  }, [hasLoaded, tree, args.dirpath, args.format, args.config, args.schema, args.slug, locationsForTreeKey, baseCommit, repoInfo, localTreeKey]));
}
var blobCache = new LRUCache({
  max: 200
});
async function hydrateBlobCache(contents) {
  const sha = await blobSha(contents);
  blobCache.set(sha, contents);
  await setBlobToPersistedCache(sha, contents);
  return sha;
}
async function fetchGitHubBlob(config, oid, filepath, commitSha, repoInfo) {
  if ((repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.isPrivate) === false) {
    var _getPathPrefix;
    return fetch(`https://raw.githubusercontent.com/${serializeRepoConfig(repoInfo)}/${commitSha}/${(_getPathPrefix = getPathPrefix(config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${filepath}`);
  }
  const auth = await getAuth(config);
  return fetch(config.storage.kind === "github" ? `https://api.github.com/repos/${serializeRepoConfig(config.storage.repo)}/git/blobs/${oid}` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/blob/${oid}`, {
    headers: {
      Authorization: `Bearer ${auth.accessToken}`,
      Accept: "application/vnd.github.raw",
      ...config.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
    }
  });
}
function fetchBlob(config, oid, filepath, commitSha, repoInfo) {
  if (blobCache.has(oid)) return blobCache.get(oid);
  const promise = (async () => {
    const isLocal = config.storage.kind === "local";
    if (!isLocal) {
      const stored = await getBlobFromPersistedCache(oid);
      if (stored) {
        blobCache.set(oid, stored);
        return stored;
      }
    }
    return (isLocal ? fetch(`/api/keystatic/blob/${oid}/${filepath}`, {
      headers: {
        "no-cors": "1"
      }
    }) : fetchGitHubBlob(config, oid, filepath, commitSha, repoInfo)).then(async (x2) => {
      if (!x2.ok) {
        throw new Error(`Could not fetch blob ${oid} (${filepath}): ${x2.status}
${await x2.text()}`);
      }
      return x2.arrayBuffer();
    }).then((x2) => {
      const array = new Uint8Array(x2);
      blobCache.set(oid, array);
      if (config.storage.kind !== "local") {
        setBlobToPersistedCache(oid, array);
      }
      return array;
    }).catch((err) => {
      blobCache.delete(oid);
      throw err;
    });
  })();
  blobCache.set(oid, promise);
  return promise;
}
function CollectionPage(props) {
  var _config$collections;
  const $ = c(15);
  const {
    collection,
    config
  } = props;
  const collectionConfig = (_config$collections = config.collections) === null || _config$collections === void 0 ? void 0 : _config$collections[collection];
  if (!collectionConfig) {
    notFound();
  }
  const router = useRouter();
  let t0;
  if ($[0] !== router.search) {
    var _URLSearchParams$get;
    t0 = (_URLSearchParams$get = new URLSearchParams(router.search).get("search")) !== null && _URLSearchParams$get !== void 0 ? _URLSearchParams$get : "";
    $[0] = router.search;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const [searchTerm, setSearchTerm] = (0, import_react8.useState)(t0);
  let t1;
  if ($[2] !== router) {
    t1 = (value) => {
      setSearchTerm(value);
      const params = new URLSearchParams(router.search);
      if (value) {
        params.set("search", value);
      } else {
        params.delete("search");
      }
      router.replace(router.pathname + "?" + params.toString());
    };
    $[2] = router;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const setSearchTermFromForm = t1;
  const debouncedSearchTerm = useDebouncedValue(searchTerm, 300);
  const t2 = `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`;
  let t3;
  if ($[4] !== collectionConfig.label || $[5] !== t2 || $[6] !== searchTerm || $[7] !== setSearchTermFromForm) {
    t3 = (0, import_jsx_runtime20.jsx)(CollectionPageHeader, {
      collectionLabel: collectionConfig.label,
      createHref: t2,
      searchTerm,
      onSearchTermChange: setSearchTermFromForm
    });
    $[4] = collectionConfig.label;
    $[5] = t2;
    $[6] = searchTerm;
    $[7] = setSearchTermFromForm;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== debouncedSearchTerm || $[10] !== props) {
    t4 = (0, import_jsx_runtime20.jsx)(CollectionPageContent, {
      searchTerm: debouncedSearchTerm,
      ...props
    });
    $[9] = debouncedSearchTerm;
    $[10] = props;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] !== t3 || $[13] !== t4) {
    t5 = (0, import_jsx_runtime20.jsxs)(PageRoot, {
      containerWidth: "none",
      children: [t3, t4]
    });
    $[12] = t3;
    $[13] = t4;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  return t5;
}
function CollectionPageHeader(props) {
  const $ = c(50);
  const {
    collectionLabel,
    createHref
  } = props;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(strings);
  const isAboveMobile = useMediaQuery(breakpointQueries$1.above.mobile);
  const [searchVisible, setSearchVisible] = (0, import_react8.useState)(isAboveMobile);
  const searchRef = (0, import_react8.useRef)(null);
  let t0;
  let t1;
  if ($[0] !== isAboveMobile) {
    t0 = () => {
      setSearchVisible(isAboveMobile);
    };
    t1 = [isAboveMobile];
    $[0] = isAboveMobile;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  (0, import_react8.useEffect)(t0, t1);
  let t2;
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      const listener = (event) => {
        if (document.activeElement === searchRef.current) {
          return;
        }
        if ((0, import_is_hotkey.isHotkey)("mod+f", event)) {
          var _searchRef$current;
          event.preventDefault();
          (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 || _searchRef$current.select();
        }
      };
      document.addEventListener("keydown", listener);
      return () => document.removeEventListener("keydown", listener);
    };
    t3 = [];
    $[3] = t2;
    $[4] = t3;
  } else {
    t2 = $[3];
    t3 = $[4];
  }
  (0, import_react8.useEffect)(t2, t3);
  let t4;
  if ($[5] !== collectionLabel) {
    t4 = (0, import_jsx_runtime20.jsx)(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      flex: true,
      minWidth: 0,
      children: collectionLabel
    });
    $[5] = collectionLabel;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const t5 = searchVisible ? "block" : "none";
  let t6;
  if ($[7] !== t5) {
    t6 = {
      display: t5
    };
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  if ($[9] !== stringFormatter) {
    t7 = stringFormatter.format("search");
    $[9] = stringFormatter;
    $[10] = t7;
  } else {
    t7 = $[10];
  }
  let t8;
  if ($[11] !== props || $[12] !== isAboveMobile) {
    t8 = () => {
      props.onSearchTermChange("");
      if (!isAboveMobile) {
        setTimeout(() => {
          setSearchVisible(false);
        }, 250);
      }
    };
    $[11] = props;
    $[12] = isAboveMobile;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  let t9;
  if ($[14] !== isAboveMobile || $[15] !== props.searchTerm) {
    t9 = () => {
      if (!isAboveMobile && props.searchTerm === "") {
        setSearchVisible(false);
      }
    };
    $[14] = isAboveMobile;
    $[15] = props.searchTerm;
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  let t10;
  if ($[17] !== stringFormatter) {
    t10 = stringFormatter.format("search");
    $[17] = stringFormatter;
    $[18] = t10;
  } else {
    t10 = $[18];
  }
  let t11;
  if ($[19] !== searchRef || $[20] !== t7 || $[21] !== props.onSearchTermChange || $[22] !== props.searchTerm || $[23] !== t8 || $[24] !== t9 || $[25] !== t10) {
    t11 = (0, import_jsx_runtime20.jsx)(SearchField, {
      ref: searchRef,
      "aria-label": t7,
      onChange: props.onSearchTermChange,
      onClear: t8,
      onBlur: t9,
      placeholder: t10,
      value: props.searchTerm,
      width: "scale.2400"
    });
    $[19] = searchRef;
    $[20] = t7;
    $[21] = props.onSearchTermChange;
    $[22] = props.searchTerm;
    $[23] = t8;
    $[24] = t9;
    $[25] = t10;
    $[26] = t11;
  } else {
    t11 = $[26];
  }
  let t12;
  if ($[27] !== t6 || $[28] !== t11) {
    t12 = (0, import_jsx_runtime20.jsx)("div", {
      role: "search",
      style: t6,
      children: t11
    });
    $[27] = t6;
    $[28] = t11;
    $[29] = t12;
  } else {
    t12 = $[29];
  }
  let t13;
  if ($[30] !== searchVisible) {
    t13 = searchVisible || {
      above: "mobile"
    };
    $[30] = searchVisible;
    $[31] = t13;
  } else {
    t13 = $[31];
  }
  let t14;
  if ($[32] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = () => {
      setSearchVisible(true);
      const tempInput = document.createElement("input");
      tempInput.style.position = "absolute";
      tempInput.style.opacity = "0";
      document.body.appendChild(tempInput);
      tempInput.focus();
      setTimeout(() => {
        var _searchRef$current2;
        (_searchRef$current2 = searchRef.current) === null || _searchRef$current2 === void 0 || _searchRef$current2.focus();
        tempInput.remove();
      }, 0);
    };
    $[32] = t14;
  } else {
    t14 = $[32];
  }
  let t15;
  if ($[33] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = (0, import_jsx_runtime20.jsx)(Icon, {
      src: searchIcon
    });
    $[33] = t15;
  } else {
    t15 = $[33];
  }
  let t16;
  if ($[34] !== t13 || $[35] !== t14) {
    t16 = (0, import_jsx_runtime20.jsx)(ActionButton, {
      "aria-label": "show search",
      isHidden: t13,
      onPress: t14,
      children: t15
    });
    $[34] = t13;
    $[35] = t14;
    $[36] = t16;
  } else {
    t16 = $[36];
  }
  let t17;
  if ($[37] !== searchVisible) {
    t17 = searchVisible ? {
      below: "tablet"
    } : void 0;
    $[37] = searchVisible;
    $[38] = t17;
  } else {
    t17 = $[38];
  }
  let t18;
  if ($[39] !== stringFormatter) {
    t18 = stringFormatter.format("add");
    $[39] = stringFormatter;
    $[40] = t18;
  } else {
    t18 = $[40];
  }
  let t19;
  if ($[41] !== createHref || $[42] !== t17 || $[43] !== t18) {
    t19 = (0, import_jsx_runtime20.jsx)(Button, {
      marginStart: "auto",
      prominence: "high",
      href: createHref,
      isHidden: t17,
      children: t18
    });
    $[41] = createHref;
    $[42] = t17;
    $[43] = t18;
    $[44] = t19;
  } else {
    t19 = $[44];
  }
  let t20;
  if ($[45] !== t4 || $[46] !== t12 || $[47] !== t16 || $[48] !== t19) {
    t20 = (0, import_jsx_runtime20.jsxs)(PageHeader, {
      children: [t4, t12, t16, t19]
    });
    $[45] = t4;
    $[46] = t12;
    $[47] = t16;
    $[48] = t19;
    $[49] = t20;
  } else {
    t20 = $[49];
  }
  return t20;
}
function CollectionPageContent(props) {
  const $ = c(11);
  const trees = useTree();
  const tree = trees.merged.kind === "loaded" ? trees.merged.data.current.entries.get(getCollectionPath(props.config, props.collection)) : null;
  if (trees.merged.kind === "error") {
    let t02;
    if ($[0] !== props.basePath) {
      t02 = (0, import_jsx_runtime20.jsx)(Button, {
        tone: "accent",
        href: props.basePath,
        children: "Dashboard"
      });
      $[0] = props.basePath;
      $[1] = t02;
    } else {
      t02 = $[1];
    }
    let t1;
    if ($[2] !== trees.merged.error.message || $[3] !== t02) {
      t1 = (0, import_jsx_runtime20.jsx)(EmptyState2, {
        icon: alertCircleIcon,
        title: "Unable to load collection",
        message: trees.merged.error.message,
        actions: t02
      });
      $[2] = trees.merged.error.message;
      $[3] = t02;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    return t1;
  }
  if (trees.merged.kind === "loading") {
    let t02;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t02 = (0, import_jsx_runtime20.jsx)(EmptyState2, {
        children: (0, import_jsx_runtime20.jsx)(ProgressCircle, {
          "aria-label": "Loading Entries",
          isIndeterminate: true,
          size: "large"
        })
      });
      $[5] = t02;
    } else {
      t02 = $[5];
    }
    return t02;
  }
  if (!tree) {
    const t02 = `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`;
    let t1;
    if ($[6] !== t02) {
      t1 = (0, import_jsx_runtime20.jsx)(EmptyState2, {
        icon: listXIcon,
        title: "Empty collection",
        message: (0, import_jsx_runtime20.jsxs)(import_jsx_runtime20.Fragment, {
          children: ["There aren't any entries yet.", " ", (0, import_jsx_runtime20.jsx)(TextLink, {
            href: t02,
            children: "Create the first entry"
          }), " ", "to see it here."]
        })
      });
      $[6] = t02;
      $[7] = t1;
    } else {
      t1 = $[7];
    }
    return t1;
  }
  let t0;
  if ($[8] !== props || $[9] !== trees.merged.data) {
    t0 = (0, import_jsx_runtime20.jsx)(CollectionTable, {
      ...props,
      trees: trees.merged.data
    });
    $[8] = props;
    $[9] = trees.merged.data;
    $[10] = t0;
  } else {
    t0 = $[10];
  }
  return t0;
}
var SLUG = "@@slug";
var STATUS = "@@status";
function CollectionTable(props) {
  let {
    searchTerm
  } = props;
  const repoInfo = useRepoInfo();
  const currentBranch = useCurrentBranch();
  let isLocalMode = isLocalConfig(props.config);
  let router = useRouter();
  let [sortDescriptor, setSortDescriptor] = (0, import_react8.useState)({
    column: SLUG,
    direction: "ascending"
  });
  let hideStatusColumn = isLocalMode || currentBranch === (repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.defaultBranch);
  const baseCommit = useBaseCommit();
  const collection = props.config.collections[props.collection];
  const entriesWithStatus = (0, import_react8.useMemo)(() => {
    const defaultEntries = new Map(getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.default.tree).map((x2) => [x2.slug, x2.key]));
    return getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.current.tree).map((entry) => {
      return {
        name: entry.slug,
        status: defaultEntries.has(entry.slug) ? defaultEntries.get(entry.slug) === entry.key ? "Unchanged" : "Changed" : "Added",
        sha: entry.sha
      };
    });
  }, [props.collection, props.config, props.trees]);
  const mainFiles = useData((0, import_react8.useCallback)(async () => {
    var _collection$columns;
    if (!((_collection$columns = collection.columns) !== null && _collection$columns !== void 0 && _collection$columns.length)) return void 0;
    const formatInfo = getCollectionFormat(props.config, props.collection);
    const entries = await Promise.all(entriesWithStatus.map(async (entry_0) => {
      return [entry_0.name, await fetchBlob(props.config, entry_0.sha, getEntryDataFilepath(getCollectionItemPath(props.config, props.collection, entry_0.name), formatInfo), baseCommit, repoInfo)];
    }));
    const glob = getSlugGlobForCollection(props.config, props.collection);
    const rootSchema = {
      kind: "object",
      fields: collection.schema
    };
    const parsedEntries = /* @__PURE__ */ new Map();
    for (const [slug, dataFile] of entries) {
      try {
        const {
          loaded
        } = loadDataFile(dataFile, formatInfo);
        const validated = parseProps(rootSchema, loaded, [], [], (schema2, value, path) => {
          if (schema2.formKind === "asset") {
            return schema2.reader.parse(value);
          }
          if (schema2.formKind === "content" || schema2.formKind === "assets") {
            return;
          }
          if (path.length === 1 && slug !== void 0) {
            if (path[0] === collection.slugField) {
              if (schema2.formKind !== "slug") {
                throw new Error(`Slug field ${collection.slugField} is not a slug field`);
              }
              return schema2.reader.parseWithSlug(value, {
                slug,
                glob
              });
            }
          }
          return schema2.reader.parse(value);
        }, true);
        parsedEntries.set(slug, validated);
      } catch {
      }
    }
    return parsedEntries;
  }, [collection, props.config, props.collection, entriesWithStatus, baseCommit, repoInfo]));
  const entriesWithData = (0, import_react8.useMemo)(() => {
    if (mainFiles.kind !== "loaded" || !mainFiles.data) {
      return entriesWithStatus;
    }
    const {
      data
    } = mainFiles;
    return entriesWithStatus.map((entry_1) => {
      return {
        ...entry_1,
        data: data.get(entry_1.name)
      };
    });
  }, [entriesWithStatus, mainFiles]);
  const filteredItems = (0, import_react8.useMemo)(() => {
    return entriesWithData.filter((item) => item.name.toLowerCase().includes(searchTerm.toLowerCase()));
  }, [entriesWithData, searchTerm]);
  const sortedItems = (0, import_react8.useMemo)(() => {
    return [...filteredItems].sort((a, b2) => {
      const readCol = (row, other) => {
        var _other;
        if (sortDescriptor.column === SLUG) {
          var _collection$parseSlug, _collection$parseSlug2;
          return (_collection$parseSlug = (_collection$parseSlug2 = collection.parseSlugForSort) === null || _collection$parseSlug2 === void 0 ? void 0 : _collection$parseSlug2.call(collection, row.name)) !== null && _collection$parseSlug !== void 0 ? _collection$parseSlug : row.name;
        }
        if (sortDescriptor.column === STATUS) {
          return row.status;
        }
        return (_other = other === null || other === void 0 ? void 0 : other[sortDescriptor.column]) !== null && _other !== void 0 ? _other : row.name;
      };
      const other_0 = mainFiles.kind === "loaded" ? mainFiles.data : void 0;
      return sortBy(sortDescriptor.direction, readCol(a, other_0 === null || other_0 === void 0 ? void 0 : other_0.get(a.name)), readCol(b2, other_0 === null || other_0 === void 0 ? void 0 : other_0.get(b2.name)));
    });
  }, [collection, filteredItems, mainFiles, sortDescriptor.column, sortDescriptor.direction]);
  const columns = (0, import_react8.useMemo)(() => {
    var _collection$columns2;
    if ((_collection$columns2 = collection.columns) !== null && _collection$columns2 !== void 0 && _collection$columns2.length) {
      return [...hideStatusColumn ? [] : [{
        name: "Status",
        key: STATUS,
        minWidth: 32,
        width: 32
      }], {
        name: "Slug",
        key: SLUG
      }, ...collection.columns.map((column) => {
        const schema_0 = collection.schema[column];
        return {
          name: "label" in schema_0 && schema_0.label || column,
          key: column
        };
      })];
    }
    return hideStatusColumn ? [{
      name: "Name",
      key: SLUG
    }] : [{
      name: "Status",
      key: STATUS,
      minWidth: 32,
      width: 32
    }, {
      name: "Name",
      key: SLUG
    }];
  }, [collection, hideStatusColumn]);
  return (0, import_jsx_runtime20.jsxs)(TableView, {
    "aria-labelledby": "page-title",
    selectionMode: "none",
    onSortChange: setSortDescriptor,
    sortDescriptor,
    density: "spacious",
    overflowMode: "truncate",
    prominence: "low",
    onAction: (key) => {
      router.push(getItemPath(props.basePath, props.collection, key));
    },
    renderEmptyState: () => (0, import_jsx_runtime20.jsx)(EmptyState2, {
      icon: searchXIcon,
      title: "No results",
      message: `No items matching "${searchTerm}" were found.`
    }),
    flex: true,
    marginTop: {
      tablet: "large"
    },
    marginBottom: {
      mobile: "regular",
      tablet: "xlarge"
    },
    UNSAFE_className: css({
      marginInline: tokenSchema.size.space.regular,
      [breakpointQueries$1.above.mobile]: {
        marginInline: `calc(${tokenSchema.size.space.xlarge} - ${tokenSchema.size.space.medium})`
      },
      [breakpointQueries$1.above.tablet]: {
        marginInline: `calc(${tokenSchema.size.space.xxlarge} - ${tokenSchema.size.space.medium})`
      },
      "[role=rowheader]": {
        cursor: "pointer"
      }
    }),
    children: [(0, import_jsx_runtime20.jsx)($312ae3b56a94a86e$export$f850895b287ef28e, {
      columns,
      children: ({
        name,
        key: key_0,
        ...options
      }) => key_0 === STATUS ? (0, import_jsx_runtime20.jsx)(VoussoirColumn, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: (0, import_jsx_runtime20.jsx)(Icon, {
          "aria-label": "Status",
          src: diffIcon
        })
      }, key_0) : (0, import_jsx_runtime20.jsx)(VoussoirColumn, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: name
      }, key_0)
    }), (0, import_jsx_runtime20.jsx)($4ae5314bf50db1a3$export$76ccd210b9029917, {
      items: sortedItems,
      children: (item_0) => {
        var _collection$columns3;
        const statusCell = (0, import_jsx_runtime20.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
          textValue: item_0.status,
          children: item_0.status === "Added" ? (0, import_jsx_runtime20.jsx)(Icon, {
            color: "positive",
            src: plusSquareIcon
          }) : item_0.status === "Changed" ? (0, import_jsx_runtime20.jsx)(Icon, {
            color: "accent",
            src: dotSquareIcon
          }) : null
        }, STATUS + item_0.name);
        const nameCell = (0, import_jsx_runtime20.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
          textValue: item_0.name,
          children: (0, import_jsx_runtime20.jsx)(Text, {
            weight: "medium",
            children: item_0.name
          })
        }, SLUG + item_0.name);
        if ((_collection$columns3 = collection.columns) !== null && _collection$columns3 !== void 0 && _collection$columns3.length) {
          return (0, import_jsx_runtime20.jsx)($70d70eb16ea48428$export$b59bdbef9ce70de2, {
            children: [...hideStatusColumn ? [] : [statusCell], nameCell, ...collection.columns.map((column_0) => {
              var _item_0$data;
              let val;
              val = (_item_0$data = item_0.data) === null || _item_0$data === void 0 ? void 0 : _item_0$data[column_0];
              if (val == null) {
                val = void 0;
              } else {
                val = val + "";
              }
              return (0, import_jsx_runtime20.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
                textValue: val,
                children: (0, import_jsx_runtime20.jsx)(Text, {
                  weight: "medium",
                  children: val
                })
              }, column_0 + item_0.name);
            })]
          }, item_0.name);
        }
        return hideStatusColumn ? (0, import_jsx_runtime20.jsx)($70d70eb16ea48428$export$b59bdbef9ce70de2, {
          children: nameCell
        }, item_0.name) : (0, import_jsx_runtime20.jsxs)($70d70eb16ea48428$export$b59bdbef9ce70de2, {
          children: [statusCell, nameCell]
        }, item_0.name);
      }
    })]
  });
}
function getItemPath(basePath, collection, key) {
  return `${basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(key)}`;
}
function useDebouncedValue(value, t0) {
  const $ = c(4);
  const delay = t0 === void 0 ? 300 : t0;
  const [debouncedValue, setDebouncedValue] = (0, import_react8.useState)(value);
  let t1;
  let t2;
  if ($[0] !== value || $[1] !== delay) {
    t1 = () => {
      const timer = setTimeout(() => setDebouncedValue(value), delay);
      return () => {
        clearTimeout(timer);
      };
    };
    t2 = [value, delay];
    $[0] = value;
    $[1] = delay;
    $[2] = t1;
    $[3] = t2;
  } else {
    t1 = $[2];
    t2 = $[3];
  }
  (0, import_react8.useEffect)(t1, t2);
  return debouncedValue;
}
function getYjsValFromParsedValue(schema2, value) {
  if (schema2.kind === "form") {
    if (schema2.formKind === "content" && schema2.collaboration) {
      return schema2.collaboration.toYjs(value);
    }
    return value;
  }
  if (schema2.kind === "child") {
    return null;
  }
  if (schema2.kind === "object") {
    return new YMap(Object.entries(schema2.fields).map(([key, val]) => [key, getYjsValFromParsedValue(val, value[key])]));
  }
  if (schema2.kind === "array") {
    const arr = new YArray();
    arr.push(value.map((val) => getYjsValFromParsedValue(schema2.element, val)));
    return arr;
  }
  if (schema2.kind === "conditional") {
    const discriminant = value.discriminant;
    return new YMap([["discriminant", discriminant], ["value", getYjsValFromParsedValue(schema2.values[discriminant + ""], value.value)]]);
  }
  assertNever(schema2);
}
function yjsToVal(schema2, awareness, yjsValue) {
  if (schema2.kind === "form") {
    if (schema2.formKind === "content" && schema2.collaboration) {
      return schema2.collaboration.fromYjs(yjsValue, awareness);
    }
    return yjsValue;
  }
  if (schema2.kind === "child") {
    return null;
  }
  if (schema2.kind === "object") {
    return Object.fromEntries(Object.entries(schema2.fields).map(([key, val]) => [key, yjsToVal(val, awareness, yjsValue.get(key))]));
  }
  if (schema2.kind === "array") {
    const yArr = yjsValue;
    if (!yArr) {
      debugger;
    }
    const val = yArr.map((val2) => yjsToVal(schema2.element, awareness, val2));
    setKeysForArrayValue(val, getKeysForArrayValue(yArr));
    return val;
  }
  if (schema2.kind === "conditional") {
    const yjsMap = yjsValue;
    return {
      discriminant: yjsToVal(schema2.discriminant, awareness, yjsMap.get("discriminant")),
      value: yjsToVal(schema2.values[yjsMap.get("discriminant") + ""], awareness, yjsMap.get("value"))
    };
  }
}
function parsedValToYjs(schema2, value) {
  if (schema2.kind === "form" || schema2.kind === "child") {
    return value;
  }
  if (schema2.kind === "object") {
    return new YMap(Object.entries(schema2.fields).map(([key, val]) => [key, parsedValToYjs(val, value[key])]));
  }
  if (schema2.kind === "array") {
    const arr = new YArray();
    arr.push(value.map((val) => parsedValToYjs(schema2.element, val)));
    return arr;
  }
  if (schema2.kind === "conditional") {
    const discriminant = value.discriminant;
    return new YMap([["discriminant", discriminant], ["value", parsedValToYjs(schema2.values[discriminant.toString()], value.value)]]);
  }
}
var AppSlugContext = (0, import_react8.createContext)(void 0);
var AppSlugProvider = AppSlugContext.Provider;
function InstallGitHubApp(props) {
  const $ = c(18);
  const router = useRouter();
  const appSlugFromContext = (0, import_react8.useContext)(AppSlugContext);
  let t0;
  if ($[0] !== router.href || $[1] !== appSlugFromContext) {
    var _URL$searchParams$get;
    t0 = (_URL$searchParams$get = new URL(router.href, "https://example.com").searchParams.get("slug")) !== null && _URL$searchParams$get !== void 0 ? _URL$searchParams$get : appSlugFromContext === null || appSlugFromContext === void 0 ? void 0 : appSlugFromContext.value;
    $[0] = router.href;
    $[1] = appSlugFromContext;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const appSlug = t0;
  let t1;
  if ($[3] !== props.config.storage.repo) {
    t1 = parseRepoConfig(props.config.storage.repo);
    $[3] = props.config.storage.repo;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const parsedRepo = t1;
  let t2;
  if ($[5] !== parsedRepo.name) {
    t2 = (0, import_jsx_runtime20.jsx)(TextField, {
      label: "Repo Name",
      width: "100%",
      isReadOnly: true,
      value: parsedRepo.name
    });
    $[5] = parsedRepo.name;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== parsedRepo.name) {
    t3 = (0, import_jsx_runtime20.jsx)(ActionButton, {
      onPress: () => {
        navigator.clipboard.writeText(parsedRepo.name);
      },
      children: "Copy Repo Name"
    });
    $[7] = parsedRepo.name;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== t2 || $[10] !== t3) {
    t4 = (0, import_jsx_runtime20.jsxs)(Flex, {
      alignItems: "end",
      gap: "regular",
      children: [t2, t3]
    });
    $[9] = t2;
    $[10] = t3;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] !== appSlug || $[13] !== appSlugFromContext) {
    t5 = appSlug ? (0, import_jsx_runtime20.jsx)(Button, {
      prominence: "high",
      href: `https://github.com/apps/${appSlug}/installations/new`,
      children: "Install GitHub App"
    }) : (0, import_jsx_runtime20.jsx)(Notice, {
      tone: "caution",
      children: appSlugFromContext ? (0, import_jsx_runtime20.jsxs)(Text, {
        children: ["The ", (0, import_jsx_runtime20.jsx)("code", {
          children: appSlugFromContext.envName
        }), " environment variable wasn't provided so we can't link to the GitHub app installation page. You should find the App on GitHub and add the repo yourself."]
      }) : (0, import_jsx_runtime20.jsx)(Text, {
        children: "Find the App on GitHub and add the repo."
      })
    });
    $[12] = appSlug;
    $[13] = appSlugFromContext;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  let t6;
  if ($[15] !== t4 || $[16] !== t5) {
    t6 = (0, import_jsx_runtime20.jsxs)(Flex, {
      direction: "column",
      gap: "regular",
      children: [t4, t5]
    });
    $[15] = t4;
    $[16] = t5;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  return t6;
}
function ForkRepoDialog(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(strings);
  const client = useClient();
  const [state, setState] = (0, import_react8.useState)({
    kind: "idle"
  });
  (0, import_react8.useEffect)(() => {
    const listener = async (event) => {
      if (event.key === "ks-refetch-installations" && event.newValue === "true") {
        localStorage.removeItem("ks-refetch-installations");
        try {
          var _res$data;
          const auth = await getAuth(props.config);
          if (!auth) throw new Error("Unauthorized");
          const res = await client.query(GitHubAppShellQuery, parseRepoConfig(props.config.storage.repo)).toPromise();
          if ((_res$data = res.data) !== null && _res$data !== void 0 && (_res$data = _res$data.repository) !== null && _res$data !== void 0 && (_res$data = _res$data.forks.nodes) !== null && _res$data !== void 0 && _res$data.some((x2) => (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "ADMIN" || (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "WRITE" || (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "MAINTAIN")) {
            await new Promise((resolve) => setTimeout(resolve, 100));
            props.onCreate();
          }
        } catch (err) {
          setState({
            kind: "error",
            error: err
          });
        }
      }
    };
    addEventListener("storage", listener);
    return () => removeEventListener("storage", listener);
  }, [client, props]);
  const appSlug = (0, import_react8.useContext)(AppSlugContext);
  return (0, import_jsx_runtime20.jsxs)(Dialog, {
    size: "small",
    isDismissable: true,
    onDismiss: () => {
      props.onDismiss();
    },
    children: [(0, import_jsx_runtime20.jsx)(Heading, {
      children: "Fork Repo"
    }), state.kind === "error" ? (0, import_jsx_runtime20.jsxs)(import_jsx_runtime20.Fragment, {
      children: [(0, import_jsx_runtime20.jsx)(Content, {
        children: (0, import_jsx_runtime20.jsx)(Notice, {
          tone: "critical",
          children: state.error.message
        })
      }), (0, import_jsx_runtime20.jsx)(ButtonGroup, {
        children: (0, import_jsx_runtime20.jsx)(Button, {
          onPress: props.onDismiss,
          children: stringFormatter.format("cancel")
        })
      })]
    }) : (0, import_jsx_runtime20.jsx)(import_jsx_runtime20.Fragment, {
      children: (0, import_jsx_runtime20.jsx)(Content, {
        children: (0, import_jsx_runtime20.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          marginBottom: "large",
          children: [(0, import_jsx_runtime20.jsx)(Text, {
            children: "You don't have permission to write to this repo so to save your changes, you need to fork the repo."
          }), (0, import_jsx_runtime20.jsxs)(Text, {
            children: ["To start,", " ", (0, import_jsx_runtime20.jsx)(TextLink, {
              href: `https://github.com/${serializeRepoConfig(props.config.storage.repo)}/fork`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "fork the repo on GitHub"
            }), ". Then, come back to this page and", " ", (0, import_jsx_runtime20.jsx)(TextLink, {
              href: `https://github.com/apps/${appSlug === null || appSlug === void 0 ? void 0 : appSlug.value}/installations/new?state=close`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "install the Keystatic GitHub App on your fork."
            })]
          })]
        })
      })
    })]
  });
}
var HeaderBreadcrumbs = (0, import_react8.memo)((props) => {
  const $ = c(5);
  let t0;
  if ($[0] !== props.items) {
    let t12;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t12 = (item) => (0, import_jsx_runtime20.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        href: item.href,
        children: item.label
      }, item.key);
      $[2] = t12;
    } else {
      t12 = $[2];
    }
    t0 = props.items.map(t12);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[3] !== t0) {
    t1 = (0, import_jsx_runtime20.jsx)(_Breadcrumbs, {
      flex: true,
      size: "medium",
      minWidth: "alias.singleLineWidth",
      children: t0
    });
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
});
function useSlugFieldInfo(collection, slugToExclude) {
  const $ = c(10);
  const config = useConfig();
  const allSlugs = useSlugsInCollection(collection);
  let t0;
  let slugs;
  if ($[0] !== allSlugs || $[1] !== slugToExclude) {
    slugs = new Set(allSlugs);
    if (slugToExclude) {
      slugs.delete(slugToExclude);
    }
    $[0] = allSlugs;
    $[1] = slugToExclude;
    $[2] = slugs;
  } else {
    slugs = $[2];
  }
  const collectionConfig = config.collections[collection];
  let t1;
  if ($[3] !== config || $[4] !== collection) {
    t1 = getSlugGlobForCollection(config, collection);
    $[3] = config;
    $[4] = collection;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== collectionConfig.slugField || $[7] !== slugs || $[8] !== t1) {
    t2 = {
      field: collectionConfig.slugField,
      slugs,
      glob: t1
    };
    $[6] = collectionConfig.slugField;
    $[7] = slugs;
    $[8] = t1;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  t0 = t2;
  return t0;
}
function PresenceAvatars() {
  const $ = c(7);
  const cloudInfo = useCloudInfo();
  const awarenessStates = useAwarenessStates();
  const router = useRouter();
  if (!cloudInfo) {
    return null;
  }
  let t0;
  if ($[0] !== awarenessStates) {
    t0 = awarenessStates.values();
    $[0] = awarenessStates;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = [...t0];
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== router.href || $[5] !== t1) {
    t2 = (0, import_jsx_runtime20.jsx)(HStack, {
      children: t1.map((val) => {
        if (!val.user || router.href !== `/keystatic/branch/${val.branch}/${val.location}`) {
          return null;
        }
        return (0, import_jsx_runtime20.jsx)(Avatar, {
          src: val.user.avatarUrl,
          name: val.user.name
        });
      })
    });
    $[4] = router.href;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
injectGlobal({
  body: {
    overflow: "hidden"
  }
});
function createUrqlClient(config) {
  const repo = config.storage.kind === "github" ? parseRepoConfig(config.storage.repo) : {
    owner: "repo-owner",
    name: "repo-name"
  };
  return Q({
    url: config.storage.kind === "github" ? "https://api.github.com/graphql" : `${KEYSTATIC_CLOUD_API_URL}/v1/github/graphql`,
    requestPolicy: "cache-and-network",
    exchanges: [authExchange(async (utils) => {
      let authState = await getAuth(config);
      return {
        addAuthToOperation(operation) {
          authState = getSyncAuth(config);
          if (!authState) {
            return operation;
          }
          return utils.appendHeaders(operation, {
            Authorization: `Bearer ${authState.accessToken}`,
            ...config.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
          });
        },
        didAuthError() {
          return false;
        },
        willAuthError(operation) {
          var _operation$query$defi;
          authState = getSyncAuth(config);
          if (operation.query.definitions[0].kind === "OperationDefinition" && (_operation$query$defi = operation.query.definitions[0].name) !== null && _operation$query$defi !== void 0 && _operation$query$defi.value.includes("AppShell") && !authState) {
            if (config.storage.kind === "github") {
              window.location.href = "/api/keystatic/github/login";
            } else {
              redirectToCloudAuth("", config);
            }
            return true;
          }
          if (!authState) {
            return true;
          }
          return false;
        },
        async refreshAuth() {
          authState = await getAuth(config);
        }
      };
    }), cacheExchange({
      resolvers: {
        Repository: {
          refs: relayPagination()
        }
      },
      updates: {
        Mutation: {
          createRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, (data) => {
              var _data$repository;
              if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && (_data$repository = _data$repository.refs) !== null && _data$repository !== void 0 && _data$repository.nodes && result.createRef && typeof result.createRef === "object" && "ref" in result.createRef) {
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: [...data.repository.refs.nodes, result.createRef.ref]
                    }
                  }
                };
              }
              return data;
            });
          },
          deleteRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, (data) => {
              var _data$repository2;
              if (data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && (_data$repository2 = _data$repository2.refs) !== null && _data$repository2 !== void 0 && _data$repository2.nodes && result.deleteRef && typeof result.deleteRef === "object" && "__typename" in result.deleteRef && typeof args.input === "object" && args.input !== null && "refId" in args.input && typeof args.input.refId === "string") {
                const refId = args.input.refId;
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: data.repository.refs.nodes.filter((x2) => (x2 === null || x2 === void 0 ? void 0 : x2.id) !== refId)
                    }
                  }
                };
              }
              return data;
            });
          }
        }
      }
    }), ...config.storage.kind === "github" ? [] : [persistedExchange({
      enableForMutation: true,
      enforcePersistedQueries: true
    })], fetchExchange]
  });
}
function Provider(t0) {
  const $ = c(19);
  const {
    children,
    config
  } = t0;
  const themeContext = useTheme();
  const {
    push: navigate
  } = useRouter();
  let t1;
  let t2;
  if ($[0] !== navigate) {
    t2 = {
      navigate
    };
    $[0] = navigate;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const keystarRouter = t1;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime20.jsx)("meta", {
      name: "viewport",
      content: "width=device-width, initial-scale=1"
    });
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  const t4 = config.locale || "en-US";
  let t5;
  let t6;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime20.jsx)(ClientSideOnlyDocumentElement, {
      bodyBackground: "surface"
    });
    t6 = (0, import_jsx_runtime20.jsx)("link", {
      href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap",
      rel: "stylesheet"
    });
    $[3] = t5;
    $[4] = t6;
  } else {
    t5 = $[3];
    t6 = $[4];
  }
  let t7;
  let t8;
  if ($[5] !== config) {
    t8 = createUrqlClient(config);
    $[5] = config;
    $[6] = t8;
  } else {
    t8 = $[6];
  }
  t7 = t8;
  let t9;
  if ($[7] !== t7 || $[8] !== children) {
    t9 = (0, import_jsx_runtime20.jsx)(f, {
      value: t7,
      children
    });
    $[7] = t7;
    $[8] = children;
    $[9] = t9;
  } else {
    t9 = $[9];
  }
  let t10;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = (0, import_jsx_runtime20.jsx)(Toaster, {});
    $[10] = t10;
  } else {
    t10 = $[10];
  }
  let t11;
  if ($[11] !== t4 || $[12] !== themeContext.theme || $[13] !== keystarRouter || $[14] !== t9) {
    t11 = (0, import_jsx_runtime20.jsxs)(KeystarProvider, {
      locale: t4,
      colorScheme: themeContext.theme,
      router: keystarRouter,
      children: [t5, t6, t9, t10]
    });
    $[11] = t4;
    $[12] = themeContext.theme;
    $[13] = keystarRouter;
    $[14] = t9;
    $[15] = t11;
  } else {
    t11 = $[15];
  }
  let t12;
  if ($[16] !== themeContext || $[17] !== t11) {
    t12 = (0, import_jsx_runtime20.jsxs)(ThemeProvider, {
      value: themeContext,
      children: [t3, t11]
    });
    $[16] = themeContext;
    $[17] = t11;
    $[18] = t12;
  } else {
    t12 = $[18];
  }
  return t12;
}
var textEncoder2 = new TextEncoder();
var frontmatterSplit = textEncoder2.encode("---\n");
function combineFrontmatterAndContents(frontmatter, contents) {
  const array = new Uint8Array(frontmatter.byteLength + contents.byteLength + frontmatterSplit.byteLength * 2);
  array.set(frontmatterSplit);
  array.set(frontmatter, frontmatterSplit.byteLength);
  array.set(frontmatterSplit, frontmatterSplit.byteLength + frontmatter.byteLength);
  array.set(contents, frontmatterSplit.byteLength * 2 + frontmatter.byteLength);
  return array;
}
function serializeEntryToFiles(args) {
  var _args$slug, _args$slug2;
  let {
    value: stateWithExtraFilesRemoved,
    extraFiles
  } = serializeProps$1(args.state, object2(args.schema), (_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field, (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.value, true);
  const dataFormat = args.format.data;
  let dataContent = textEncoder2.encode(dataFormat === "json" ? JSON.stringify(stateWithExtraFilesRemoved, null, 2) + "\n" : dump(stateWithExtraFilesRemoved));
  if (args.format.contentField) {
    const filename = `${args.format.contentField.path.join("/")}${args.format.contentField.contentExtension}`;
    let contents;
    extraFiles = extraFiles.filter((x2) => {
      if (x2.path !== filename) return true;
      contents = x2.contents;
      return false;
    });
    assert(contents !== void 0, "Expected content field to be present");
    dataContent = combineFrontmatterAndContents(dataContent, contents);
  }
  return [{
    path: getEntryDataFilepath(args.basePath, args.format),
    contents: dataContent
  }, ...extraFiles.map((file) => ({
    path: `${file.parent ? args.slug ? `${file.parent}/${args.slug.value}` : file.parent : args.basePath}/${file.path}`,
    contents: file.contents
  }))];
}
function useUpsertItem(args) {
  const [state, setState] = (0, import_react8.useState)({
    kind: "idle"
  });
  const baseCommit = useBaseCommit();
  const currentBranch = useCurrentBranch();
  const setTreeSha = useSetTreeSha();
  const [, mutate] = useMutation(createCommitMutation);
  const repoInfo = useRepoInfo();
  const appSlug = (0, import_react8.useContext)(AppSlugContext);
  const unscopedTreeData = useCurrentUnscopedTree();
  return [state, async (override) => {
    try {
      var _getPathPrefix, _args$initialFiles;
      const unscopedTree = unscopedTreeData.kind === "loaded" ? unscopedTreeData.data.tree : void 0;
      if (!unscopedTree) return false;
      if (args.config.storage.kind === "github" && repoInfo && !repoInfo.hasWritePermission && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: "needs-fork"
        });
        return false;
      }
      setState({
        kind: "loading"
      });
      const pathPrefix = (_getPathPrefix = getPathPrefix(args.config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : "";
      let additions = serializeEntryToFiles({
        basePath: args.basePath,
        schema: args.schema,
        format: args.format,
        state: args.state,
        slug: args.slug
      }).map((addition) => ({
        ...addition,
        path: pathPrefix + addition.path
      }));
      const additionPathToSha = new Map(await Promise.all(additions.map(async (addition_0) => [addition_0.path, await hydrateBlobCache(addition_0.contents)])));
      const filesToDelete = new Set((_args$initialFiles = args.initialFiles) === null || _args$initialFiles === void 0 ? void 0 : _args$initialFiles.map((x2) => pathPrefix + x2));
      for (const file of additions) {
        filesToDelete.delete(file.path);
      }
      additions = additions.filter((addition_1) => {
        const sha = additionPathToSha.get(addition_1.path);
        const existing = getTreeNodeAtPath(unscopedTree, addition_1.path);
        return (existing === null || existing === void 0 ? void 0 : existing.entry.sha) !== sha;
      });
      const deletions = [...filesToDelete].map((path) => ({
        path
      }));
      const updatedTree = await updateTreeWithChanges(unscopedTree, {
        additions,
        deletions: [...filesToDelete]
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.config.storage.kind === "github" || args.config.storage.kind === "cloud") {
        var _override$branch, _override$sha, _result$error, _result$error2, _result$data;
        if (!repoInfo) {
          throw new Error("Repo info not loaded");
        }
        const branch = {
          branchName: (_override$branch = override === null || override === void 0 ? void 0 : override.branch) !== null && _override$branch !== void 0 ? _override$branch : currentBranch,
          repositoryNameWithOwner: `${repoInfo.owner}/${repoInfo.name}`
        };
        const runMutation = (expectedHeadOid) => mutate({
          input: {
            branch,
            expectedHeadOid,
            message: {
              headline: `Update ${args.basePath}`
            },
            fileChanges: {
              additions: additions.map((addition_2) => ({
                ...addition_2,
                contents: base64Encode(addition_2.contents)
              })),
              deletions
            }
          }
        });
        let result = await runMutation((_override$sha = override === null || override === void 0 ? void 0 : override.sha) !== null && _override$sha !== void 0 ? _override$sha : baseCommit);
        const gqlError = (_result$error = result.error) === null || _result$error === void 0 || (_result$error = _result$error.graphQLErrors[0]) === null || _result$error === void 0 ? void 0 : _result$error.originalError;
        if (gqlError && "type" in gqlError) {
          if (gqlError.type === "BRANCH_PROTECTION_RULE_VIOLATION") {
            setState({
              kind: "needs-new-branch",
              reason: "Changes must be made via pull request to this branch. Create a new branch to save changes."
            });
            return false;
          }
          if (gqlError.type === "STALE_DATA") {
            var _refData$data, _args$slug3;
            const refData = await createUrqlClient(args.config).query(FetchRef, {
              owner: repoInfo.owner,
              name: repoInfo.name,
              ref: `refs/heads/${currentBranch}`
            }).toPromise();
            if (!((_refData$data = refData.data) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.repository) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.ref) !== null && _refData$data !== void 0 && _refData$data.target)) {
              throw new Error("Branch not found");
            }
            const tree = scopeEntriesWithPathPrefix(await fetchGitHubTreeData(refData.data.repository.ref.target.oid, args.config), args.config);
            const treeKey = getTreeKey(getDirectoriesForTreeKey(object2(args.schema), args.basePath, (_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.value, args.format), tree.tree);
            if (treeKey === args.currentLocalTreeKey) {
              result = await runMutation(refData.data.repository.ref.target.oid);
            } else {
              setState({
                kind: "needs-new-branch",
                reason: "This entry has been updated since it was opened. Create a new branch to save changes."
              });
              return false;
            }
          }
        }
        if ((_result$error2 = result.error) !== null && _result$error2 !== void 0 && _result$error2.graphQLErrors.some((err_0) => "type" in err_0 && err_0.type === "FORBIDDEN" && err_0.message === "Resource not accessible by integration")) {
          throw new Error(`The GitHub App is unable to commit to the repository. Please ensure that the Keystatic GitHub App is installed in the GitHub repository ${repoInfo.owner}/${repoInfo.name}`);
        }
        if (result.error) {
          throw result.error;
        }
        const target = (_result$data = result.data) === null || _result$data === void 0 || (_result$data = _result$data.createCommitOnBranch) === null || _result$data === void 0 || (_result$data = _result$data.ref) === null || _result$data === void 0 ? void 0 : _result$data.target;
        if (target) {
          setState({
            kind: "updated"
          });
          return true;
        }
        throw new Error("Failed to update");
      } else {
        const res = await fetch("/api/keystatic/update", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "no-cors": "1"
          },
          body: JSON.stringify({
            additions: additions.map((addition_3) => ({
              ...addition_3,
              contents: base64Encode(addition_3.contents)
            })),
            deletions
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree: tree_0
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree_0));
        setState({
          kind: "updated"
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: "error",
        error: err
      });
      return false;
    }
  }, () => {
    setState({
      kind: "idle"
    });
  }];
}
var createCommitMutation = lib_default`
  mutation CreateCommit($input: CreateCommitOnBranchInput!) {
    createCommitOnBranch(input: $input) {
      ref {
        id
        target {
          id
          oid
          ... on Commit {
            tree {
              id
              oid
            }
          }
        }
      }
    }
  }
`;
function useDeleteItem(args) {
  const [state, setState] = (0, import_react8.useState)({
    kind: "idle"
  });
  const baseCommit = useBaseCommit();
  const currentBranch = useCurrentBranch();
  const [, mutate] = useMutation(createCommitMutation);
  const setTreeSha = useSetTreeSha();
  const repoInfo = useRepoInfo();
  const appSlug = (0, import_react8.useContext)(AppSlugContext);
  const unscopedTreeData = useCurrentUnscopedTree();
  return [state, async () => {
    try {
      const unscopedTree = unscopedTreeData.kind === "loaded" ? unscopedTreeData.data.tree : void 0;
      if (!unscopedTree) return false;
      if (args.storage.kind === "github" && repoInfo && !repoInfo.hasWritePermission && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: "needs-fork"
        });
        return false;
      }
      setState({
        kind: "loading"
      });
      const deletions = args.initialFiles.map((x2) => {
        var _getPathPrefix2;
        return ((_getPathPrefix2 = getPathPrefix(args.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : "") + x2;
      });
      const updatedTree = await updateTreeWithChanges(unscopedTree, {
        additions: [],
        deletions
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.storage.kind === "github" || args.storage.kind === "cloud") {
        if (!repoInfo) {
          throw new Error("Repo info not loaded");
        }
        const {
          error
        } = await mutate({
          input: {
            branch: {
              repositoryNameWithOwner: `${repoInfo.owner}/${repoInfo.name}`,
              branchName: currentBranch
            },
            message: {
              headline: `Delete ${args.basePath}`
            },
            expectedHeadOid: baseCommit,
            fileChanges: {
              deletions: deletions.map((path) => ({
                path
              }))
            }
          }
        });
        if (error !== null && error !== void 0 && error.graphQLErrors.some((err_0) => "type" in err_0 && err_0.type === "FORBIDDEN" && err_0.message === "Resource not accessible by integration")) {
          throw new Error(`The GitHub App is unable to commit to the repository. Please ensure that the Keystatic GitHub App is installed in the GitHub repository ${repoInfo.owner}/${repoInfo.name}`);
        }
        if (error) {
          throw error;
        }
        setState({
          kind: "updated"
        });
        return true;
      } else {
        const res = await fetch("/api/keystatic/update", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "no-cors": "1"
          },
          body: JSON.stringify({
            additions: [],
            deletions: deletions.map((path_0) => ({
              path: path_0
            }))
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: "updated"
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: "error",
        error: err
      });
    }
  }, () => {
    setState({
      kind: "idle"
    });
  }];
}
var FetchRef = lib_default`
  query FetchRef($owner: String!, $name: String!, $ref: String!) {
    repository(owner: $owner, name: $name) {
      id
      ref(qualifiedName: $ref) {
        id
        target {
          id
          oid
        }
      }
    }
  }
`;
function useHasChanged(args) {
  const $ = c(9);
  let t0;
  if ($[0] !== args.slugField || $[1] !== args.schema) {
    t0 = async (state) => {
      const slug = args.slugField ? getSlugFromState({
        schema: args.schema.fields,
        slugField: args.slugField
      }, state) : void 0;
      const serializedState = serializeProps$1(state, args.schema, args.slugField, slug, true);
      return {
        slug,
        value: serializedState.value,
        extraFiles: Object.fromEntries(await Promise.all(serializedState.extraFiles.map(async (val) => [JSON.stringify([val.path, val.parent]), await blobSha(val.contents)])))
      };
    };
    $[0] = args.slugField;
    $[1] = args.schema;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const serialize = t0;
  let t1;
  if ($[3] !== args.initialState || $[4] !== serialize) {
    t1 = () => args.initialState === null ? null : serialize(args.initialState);
    $[3] = args.initialState;
    $[4] = serialize;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const initialFilesForUpdate = useData(t1);
  let t2;
  if ($[6] !== serialize || $[7] !== args.state) {
    t2 = () => serialize(args.state);
    $[6] = serialize;
    $[7] = args.state;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const filesForUpdate = useData(t2);
  let t3;
  bb0: {
    if (initialFilesForUpdate.kind === "loaded" && filesForUpdate.kind === "loaded") {
      const a = initialFilesForUpdate.data;
      const b2 = filesForUpdate.data;
      t3 = !(0, import_fast_deep_equal.default)(a, b2);
      break bb0;
    }
    t3 = "unknown";
  }
  const hasChangedState = t3;
  const [hasChanged, setHasChanged] = (0, import_react8.useState)(false);
  if (typeof hasChangedState === "boolean" && hasChangedState !== hasChanged) {
    setHasChanged(hasChangedState);
  }
  return hasChanged;
}
function useYJsValue(schema2, type3) {
  const $ = c(14);
  const yjsInfo = useYjs();
  let t0;
  let lastVal;
  if ($[0] !== schema2 || $[1] !== yjsInfo.awareness || $[2] !== type3) {
    lastVal = yjsToVal(schema2, yjsInfo.awareness, type3);
    $[0] = schema2;
    $[1] = yjsInfo.awareness;
    $[2] = type3;
    $[3] = lastVal;
  } else {
    lastVal = $[3];
  }
  const t1 = lastVal;
  let t2;
  if ($[4] !== t1) {
    t2 = () => lastVal;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const t3 = lastVal;
  let t4;
  if ($[6] !== t3 || $[7] !== schema2 || $[8] !== yjsInfo.awareness || $[9] !== type3) {
    t4 = (cb) => {
      const handler = () => {
        lastVal = yjsToVal(schema2, yjsInfo.awareness, type3);
        cb();
      };
      type3.observeDeep(handler);
      return () => {
        type3.unobserveDeep(handler);
      };
    };
    $[6] = t3;
    $[7] = schema2;
    $[8] = yjsInfo.awareness;
    $[9] = type3;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== t2 || $[12] !== t4) {
    t5 = {
      getSnapshot: t2,
      subscribe: t4
    };
    $[11] = t2;
    $[12] = t4;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  t0 = t5;
  const thing = t0;
  return (0, import_react8.useSyncExternalStore)(thing.subscribe, thing.getSnapshot, thing.getSnapshot);
}
function castToMemoizedInfoForSchema(val) {
  return val;
}
function getOrInsert(map4, key, val) {
  if (!map4.has(key)) {
    map4.set(key, val(key));
  }
  return map4.get(key);
}
function findSingleReorderedElement(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) return;
  const sortedOldKeys = [...oldKeys].sort();
  const sortedNewKeys = [...newKeys].sort();
  if (sortedOldKeys.join() !== sortedNewKeys.join()) return;
  let reorderedKey;
  for (let i = 0; i < oldKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      if (reorderedKey === newKeys[i]) continue;
      if (reorderedKey !== void 0) return;
      reorderedKey = oldKeys[i];
    }
  }
  return reorderedKey;
}
function createGetPreviewPropsFromY(rootSchema, yMap, awareness) {
  const memoizedInfoForSchema = castToMemoizedInfoForSchema({
    form(schema2, onChange) {
      return onChange;
    },
    array(schema2, onChange) {
      return {
        rawOnChange: onChange,
        inner: /* @__PURE__ */ new Map(),
        onChange(updater) {
          const yArr = onChange.yjs();
          const oldVal = yjsToVal(schema2, awareness, yArr);
          const oldKeys = getKeysForArrayValue(yArr);
          const uniqueKeys = /* @__PURE__ */ new Set();
          for (const x2 of updater) {
            if (x2.key !== void 0) {
              if (uniqueKeys.has(x2.key)) {
                throw new Error("Array elements must have unique keys");
              }
              uniqueKeys.add(x2.key);
            }
          }
          const newKeys = updater.map((x2) => {
            if (x2.key !== void 0) return x2.key;
            let elementKey = getNewArrayElementKey();
            while (uniqueKeys.has(elementKey)) {
              elementKey = getNewArrayElementKey();
            }
            uniqueKeys.add(elementKey);
            return elementKey;
          });
          setKeysForArrayValue(yArr, newKeys);
          const reorderedKey = findSingleReorderedElement(oldKeys, newKeys);
          if (reorderedKey !== void 0) {
            const oldIndex = oldKeys.indexOf(reorderedKey);
            const newIndex = newKeys.indexOf(reorderedKey);
            let val = yArr.get(oldIndex);
            if (val instanceof AbstractType) {
              val = val.clone();
            }
            yArr.delete(oldIndex);
            yArr.insert(newIndex, [val]);
            for (const [idx, {
              value
            }] of updater.entries()) {
              const oldIndex2 = oldKeys.indexOf(newKeys[idx]);
              const newVal = updateValue(schema2.element, oldVal[oldIndex2], value);
              if (newVal !== oldVal) {
                yArr.delete(oldIndex2);
                yArr.insert(idx, [parsedValToYjs(schema2.element, newVal)]);
              }
            }
            return;
          }
          const oldKeysJoined = oldKeys.join();
          const newKeysJoined = newKeys.slice(0, oldKeys.length).join();
          if (oldKeysJoined === newKeysJoined) {
            for (const [idx, {
              value
            }] of updater.entries()) {
              const oldIndex = oldKeys.indexOf(newKeys[idx]);
              const newVal = updateValue(schema2.element, oldVal[oldIndex], value);
              if (newVal !== oldVal) {
                yArr.delete(oldIndex);
                yArr.insert(idx, [parsedValToYjs(schema2.element, newVal)]);
              }
            }
            const valsToInsert = [];
            for (const {
              value
            } of updater.slice(oldKeys.length)) {
              valsToInsert.push(parsedValToYjs(schema2.element, getInitialPropsValueFromInitializer(schema2.element, value)));
            }
            if (valsToInsert.length) {
              yArr.insert(oldKeys.length, valsToInsert);
            }
            return;
          }
          const newVals = updater.map((x2, i) => {
            const key = newKeys[i];
            const oldIndex = oldKeys.indexOf(key);
            if (oldIndex !== -1) {
              const oldElement = yArr.get(oldIndex);
              if (x2.value === void 0) {
                if (oldElement instanceof AbstractType) {
                  return oldElement.clone();
                }
                return oldElement;
              }
              const newVal = updateValue(schema2.element, oldVal[oldIndex], x2.value);
              return parsedValToYjs(schema2.element, newVal);
            }
            return parsedValToYjs(schema2.element, getInitialPropsValueFromInitializer(schema2.element, x2.value));
          });
          yArr.delete(0, yArr.length);
          yArr.insert(0, newVals);
        }
      };
    },
    conditional(schema2, stateUpdater) {
      return {
        onChange: (discriminant, value) => {
          stateUpdater.yjs().set("discriminant", discriminant);
          if (value !== void 0) {
            const old = yjsToVal(schema2, awareness, stateUpdater.yjs().get("value"));
            stateUpdater.yjs().set("value", parsedValToYjs(schema2, updateValue(schema2.values[discriminant.toString()], old, value)));
          }
        },
        onChangeForValue: Object.assign((cb) => {
          const old = yjsToVal(schema2, awareness, stateUpdater.yjs().get("value"));
          stateUpdater.yjs().set("value", parsedValToYjs(schema2, cb(old)));
        }, {
          yjs() {
            return stateUpdater.yjs().get("value");
          }
        })
      };
    },
    object(schema2, stateUpdater) {
      return {
        onChange: (updater) => {
          for (const [key, val] of Object.entries(updater)) {
            const oldVal = yjsToVal(schema2.fields[key], awareness, stateUpdater.yjs().get(key));
            stateUpdater.yjs().set(key, parsedValToYjs(schema2.fields[key], updateValue(schema2.fields[key], oldVal, val)));
          }
        },
        innerOnChanges: Object.fromEntries(Object.entries(schema2.fields).map(([key, val]) => {
          let func = Object.assign((newVal) => {
            stateUpdater.yjs().set(key, parsedValToYjs(val, newVal));
          }, {
            yjs() {
              return stateUpdater.yjs().get(key);
            }
          });
          return [key, func];
        }))
      };
    }
  });
  const previewPropsFactories = {
    form(schema2, value, onChange) {
      return {
        value,
        onChange,
        schema: schema2
      };
    },
    object(schema2, value, memoized, path, getInnerProp) {
      const fields = {};
      for (const key of Object.keys(schema2.fields)) {
        fields[key] = getInnerProp(schema2.fields[key], value[key], memoized.innerOnChanges[key], key);
      }
      const previewProps = {
        fields,
        onChange: memoized.onChange,
        schema: schema2
      };
      return previewProps;
    },
    array(schema2, value, memoized, path, getInnerProp) {
      const arrayValue = value;
      const keys = getKeysForArrayValue(arrayValue);
      const unusedKeys = new Set(getKeysForArrayValue(value));
      const props = {
        elements: arrayValue.map((val, i) => {
          const key = keys[i];
          unusedKeys.delete(key);
          const element = getOrInsert(memoized.inner, key, () => {
            const onChange = Object.assign((val2) => {
              const yArr = memoized.rawOnChange.yjs();
              const keys2 = getKeysForArrayValue(yArr);
              const index = keys2.indexOf(key);
              const newVal = val2(yjsToVal(schema2, awareness, yArr.get(index)));
              yArr.delete(index);
              yArr.insert(index, [parsedValToYjs(schema2.element, newVal)]);
            }, {
              yjs() {
                const keys2 = getKeysForArrayValue(memoized.rawOnChange.yjs());
                const i2 = keys2.indexOf(key);
                return memoized.rawOnChange.yjs().get(i2);
              }
            });
            const element2 = getInnerProp(schema2.element, val, onChange, key);
            return {
              element: element2,
              elementWithKey: {
                ...element2,
                key
              },
              onChange
            };
          });
          const currentInnerProp = getInnerProp(schema2.element, val, element.onChange, key);
          if (element.element !== currentInnerProp) {
            element.element = currentInnerProp;
            element.elementWithKey = {
              ...currentInnerProp,
              key
            };
          }
          return element.elementWithKey;
        }),
        schema: schema2,
        onChange: memoized.onChange
      };
      for (const key of unusedKeys) {
        memoized.inner.delete(key);
      }
      return props;
    },
    conditional(schema2, value, memoized, path, getInnerProp) {
      const props = {
        discriminant: value.discriminant,
        onChange: memoized.onChange,
        value: getInnerProp(schema2.values[value.discriminant.toString()], value.value, memoized.onChangeForValue, "value"),
        schema: schema2
      };
      return props;
    }
  };
  function getPreviewPropsForProp(schema2, value, memoedThing, path, getInnerProp) {
    return previewPropsFactories[schema2.kind](schema2, value, memoedThing, path, getInnerProp);
  }
  function getInitialMemoState(schema2, value, stateUpdater, path) {
    const innerState = /* @__PURE__ */ new Map();
    const memoizedInfo = memoizedInfoForSchema[schema2.kind](schema2, stateUpdater);
    const state = {
      value,
      inner: innerState,
      props: getPreviewPropsForProp(schema2, value, memoizedInfo, path, (schema3, value2, onChange, key) => {
        const state2 = getInitialMemoState(schema3, value2, onChange, path.concat(key));
        innerState.set(key, state2);
        return state2.props;
      }),
      schema: schema2,
      cached: memoizedInfo
    };
    return state;
  }
  function getUpToDateProps(schema2, value, stateUpdater, memoState2, path) {
    if (memoState2.schema !== schema2) {
      Object.assign(memoState2, getInitialMemoState(schema2, value, stateUpdater, path));
      return memoState2.props;
    }
    if (memoState2.value === value) {
      return memoState2.props;
    }
    memoState2.value = value;
    const unusedKeys = new Set(memoState2.inner.keys());
    memoState2.props = getPreviewPropsForProp(schema2, value, memoState2.cached, path, (schema3, value2, onChange, innerMemoStateKey) => {
      unusedKeys.delete(innerMemoStateKey);
      if (!memoState2.inner.has(innerMemoStateKey)) {
        const innerState = getInitialMemoState(schema3, value2, onChange, path.concat(innerMemoStateKey));
        memoState2.inner.set(innerMemoStateKey, innerState);
        return innerState.props;
      }
      return getUpToDateProps(schema3, value2, onChange, memoState2.inner.get(innerMemoStateKey), path.concat(innerMemoStateKey));
    });
    for (const key of unusedKeys) {
      memoState2.inner.delete(key);
    }
    return memoState2.props;
  }
  let memoState;
  const rootUpdater = Object.assign((cb) => {
    const newValue = cb(memoState.value);
    const innerYMap = parsedValToYjs(rootSchema, newValue);
    for (const [key, val] of innerYMap.entries()) {
      innerYMap.delete(key);
      yMap.set(key, val);
    }
  }, {
    yjs() {
      return yMap;
    }
  });
  return (value) => {
    if (memoState === void 0) {
      memoState = getInitialMemoState(rootSchema, value, rootUpdater, []);
      return memoState.props;
    }
    return getUpToDateProps(rootSchema, value, rootUpdater, memoState, []);
  };
}
function usePreviewProps(schema2, setState, state) {
  return (0, import_react8.useMemo)(() => createGetPreviewProps(schema2, setState, () => void 0), [schema2, setState])(state);
}
function usePreviewPropsFromY(schema2, map4, state) {
  const yjsInfo = useYjs();
  return (0, import_react8.useMemo)(() => createGetPreviewPropsFromY(schema2, map4, yjsInfo.awareness), [map4, schema2, yjsInfo.awareness])(state);
}
function useCollection(collection) {
  const $ = c(5);
  const config = useConfig();
  const collectionConfig = config.collections[collection];
  let t0;
  let t1;
  if ($[0] !== collectionConfig.schema) {
    t1 = {
      kind: "object",
      fields: collectionConfig.schema
    };
    $[0] = collectionConfig.schema;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const schema2 = t0;
  let t2;
  if ($[2] !== schema2 || $[3] !== collectionConfig) {
    t2 = {
      schema: schema2,
      collectionConfig
    };
    $[2] = schema2;
    $[3] = collectionConfig;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}
function useSingleton(singleton) {
  const $ = c(5);
  const config = useConfig();
  const singletonConfig = config.singletons[singleton];
  let t0;
  let t1;
  if ($[0] !== singletonConfig.schema) {
    t1 = {
      kind: "object",
      fields: singletonConfig.schema
    };
    $[0] = singletonConfig.schema;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const schema2 = t0;
  let t2;
  if ($[2] !== schema2 || $[3] !== singletonConfig) {
    t2 = {
      schema: schema2,
      singletonConfig
    };
    $[2] = schema2;
    $[3] = singletonConfig;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}
var ErrorBoundary = class extends import_react8.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: null
    };
  }
  static getDerivedStateFromError(err) {
    if (isNotFoundError(err)) {
      throw err;
    }
    return {
      message: String(err)
    };
  }
  render() {
    if (this.state.message) {
      return typeof this.props.fallback === "function" ? this.props.fallback(this.state.message) : this.props.fallback;
    }
    return this.props.children;
  }
};
var keystaticEntryAttributeSchema = type({
  slug: optional(string()),
  files: record(string(), coerce(instance(Uint8Array), string(), (value) => base64UrlDecode(value)))
});
var textDecoder2 = new TextDecoder();
function parseEntryFromHtml(html, format, schema2, slugField) {
  const parsedHtml = new DOMParser().parseFromString(html, "text/html");
  const pre = parsedHtml.querySelector("pre");
  if (!(pre !== null && pre !== void 0 && pre.dataset.keystaticEntry)) {
    return;
  }
  try {
    var _entryInfo$slug, _entryInfo$slug2;
    const parsed = JSON.parse(pre.dataset.keystaticEntry);
    const entryInfo = keystaticEntryAttributeSchema.create(parsed);
    const files = new Map(Object.entries(entryInfo.files));
    return parseEntry({
      dirpath: (_entryInfo$slug = entryInfo.slug) !== null && _entryInfo$slug !== void 0 ? _entryInfo$slug : "entry",
      format,
      schema: schema2,
      slug: slugField ? {
        field: slugField,
        slug: (_entryInfo$slug2 = entryInfo.slug) !== null && _entryInfo$slug2 !== void 0 ? _entryInfo$slug2 : ""
      } : void 0,
      requireFrontmatter: true
    }, files).initialState;
  } catch {
  }
}
function parseEntryFromPlaintext(bytes, format, schema2, slugInfo) {
  try {
    var _slugInfo$slug;
    const dirpath = (_slugInfo$slug = slugInfo === null || slugInfo === void 0 ? void 0 : slugInfo.slug) !== null && _slugInfo$slug !== void 0 ? _slugInfo$slug : "entry";
    return parseEntry({
      dirpath,
      format,
      schema: schema2,
      slug: slugInfo,
      requireFrontmatter: true
    }, /* @__PURE__ */ new Map([[getEntryDataFilepath(dirpath, format), bytes]])).initialState;
  } catch {
  }
}
async function getPastedEntry(format, schema2, slugInfo) {
  let clipboardItems;
  try {
    clipboardItems = await navigator.clipboard.read();
  } catch (err) {
    if (err instanceof DOMException && err.name === "NotAllowedError") {
      toastQueue.critical("Failed to paste because clipboard access was denied", {
        timeout: 5e3
      });
      return;
    }
    toastQueue.critical("Failed to read clipboard", {
      timeout: 5e3
    });
    return;
  }
  for (const item of clipboardItems) {
    if (item.types.includes("text/html")) {
      const html = await item.getType("text/html");
      const text = await html.text();
      const entry = parseEntryFromHtml(text, format, schema2, slugInfo === null || slugInfo === void 0 ? void 0 : slugInfo.field);
      if (entry) {
        return entry;
      }
    }
    if (item.types.includes("text/plain")) {
      const plain = await item.getType("text/plain");
      const text = await plain.arrayBuffer();
      const entry = parseEntryFromPlaintext(new Uint8Array(text), format, schema2, slugInfo);
      if (entry) {
        return entry;
      }
    }
  }
  toastQueue.critical("Entry not found in clipboard", {
    timeout: 5e3
  });
}
function serializeEntryForClipboard(state, format, schema2, slug) {
  var _slug$value;
  const basePath = (_slug$value = slug === null || slug === void 0 ? void 0 : slug.value) !== null && _slug$value !== void 0 ? _slug$value : "entry";
  const files = serializeEntryToFiles({
    basePath,
    format,
    schema: schema2,
    slug,
    state
  });
  const element = document.createElement("pre");
  element.dataset.keystaticEntry = JSON.stringify({
    slug: slug === null || slug === void 0 ? void 0 : slug.value,
    files: Object.fromEntries(files.map((f2) => [f2.path, base64UrlEncode(f2.contents)]))
  });
  const mainEntryFilepath = getEntryDataFilepath(basePath, format);
  const mainFile = files.find((f2) => f2.path === mainEntryFilepath);
  if (!mainFile) {
    throw new Error("No main entry file found");
  }
  const plain = textDecoder2.decode(mainFile.contents);
  element.textContent = plain;
  return {
    html: element.outerHTML,
    plain
  };
}
function copyEntryToClipboard(state, format, schema2, slug) {
  const out = serializeEntryForClipboard(state, format, schema2, slug);
  navigator.clipboard.write([new ClipboardItem({
    "text/plain": new Blob([out.plain], {
      type: "text/plain"
    }),
    "text/html": new Blob([out.html], {
      type: "text/html"
    })
  })]);
}
var storedValSchema$2 = type({
  version: literal(1),
  savedAt: date(),
  slug: string(),
  beforeTreeKey: string(),
  files: map(string(), instance(Uint8Array))
});
function ItemPageInner(props) {
  var _getPathPrefix, _getPathPrefix2;
  const $ = c(115);
  const {
    collection,
    config,
    itemSlug,
    updateResult,
    onUpdate: parentOnUpdate
  } = props;
  const {
    collectionConfig,
    schema: schema2
  } = useCollection(collection);
  const router = useRouter();
  const baseCommit = useBaseCommit();
  let t0;
  if ($[0] !== config || $[1] !== collection || $[2] !== itemSlug) {
    t0 = getCollectionItemPath(config, collection, itemSlug);
    $[0] = config;
    $[1] = collection;
    $[2] = itemSlug;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  const currentBasePath = t0;
  let t1;
  if ($[4] !== config || $[5] !== collection) {
    t1 = getCollectionFormat(config, collection);
    $[4] = config;
    $[5] = collection;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  const formatInfo = t1;
  const currentBranch = useCurrentBranch();
  const repoInfo = useRepoInfo();
  const [forceValidation, setForceValidation] = (0, import_react8.useState)(false);
  let t2;
  if ($[7] !== collectionConfig.previewUrl || $[8] !== props || $[9] !== currentBranch) {
    t2 = collectionConfig.previewUrl ? collectionConfig.previewUrl.replace("{slug}", props.itemSlug).replace("{branch}", currentBranch) : void 0;
    $[7] = collectionConfig.previewUrl;
    $[8] = props;
    $[9] = currentBranch;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const previewHref = t2;
  const {
    push,
    replace
  } = router;
  const slugInfo = useSlugFieldInfo(collection, itemSlug);
  let t3;
  if ($[11] !== props.initialFiles || $[12] !== config.storage || $[13] !== currentBasePath) {
    t3 = {
      initialFiles: props.initialFiles,
      storage: config.storage,
      basePath: currentBasePath
    };
    $[11] = props.initialFiles;
    $[12] = config.storage;
    $[13] = currentBasePath;
    $[14] = t3;
  } else {
    t3 = $[14];
  }
  const [deleteResult, deleteItem, resetDeleteItem] = useDeleteItem(t3);
  let t4;
  if ($[15] !== deleteItem || $[16] !== push || $[17] !== props.basePath || $[18] !== collection) {
    t4 = async () => {
      if (await deleteItem()) {
        push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
      }
    };
    $[15] = deleteItem;
    $[16] = push;
    $[17] = props.basePath;
    $[18] = collection;
    $[19] = t4;
  } else {
    t4 = $[19];
  }
  const onDelete = useEventCallback(t4);
  let t5;
  if ($[20] !== push || $[21] !== props.basePath || $[22] !== collection || $[23] !== itemSlug) {
    t5 = () => {
      push(`${props.basePath}/collection/${encodeURIComponent(collection)}/create?duplicate=${itemSlug}`);
    };
    $[20] = push;
    $[21] = props.basePath;
    $[22] = collection;
    $[23] = itemSlug;
    $[24] = t5;
  } else {
    t5 = $[24];
  }
  const onDuplicate = t5;
  const isSavingDisabled = updateResult.kind === "loading" || !props.hasChanged;
  let t6;
  if ($[25] !== isSavingDisabled || $[26] !== schema2 || $[27] !== props.state || $[28] !== props.basePath || $[29] !== slugInfo || $[30] !== collectionConfig || $[31] !== parentOnUpdate || $[32] !== itemSlug || $[33] !== replace || $[34] !== collection) {
    t6 = async () => {
      if (isSavingDisabled) {
        return false;
      }
      if (!clientSideValidateProp(schema2, props.state, slugInfo)) {
        setForceValidation(true);
        return false;
      }
      const slug = getSlugFromState(collectionConfig, props.state);
      const hasUpdated = await parentOnUpdate();
      if (hasUpdated && slug !== itemSlug) {
        replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug)}`);
      }
      return hasUpdated;
    };
    $[25] = isSavingDisabled;
    $[26] = schema2;
    $[27] = props.state;
    $[28] = props.basePath;
    $[29] = slugInfo;
    $[30] = collectionConfig;
    $[31] = parentOnUpdate;
    $[32] = itemSlug;
    $[33] = replace;
    $[34] = collection;
    $[35] = t6;
  } else {
    t6 = $[35];
  }
  const onUpdate = useEventCallback(t6);
  let t7;
  if ($[36] !== props.state || $[37] !== formatInfo || $[38] !== collectionConfig) {
    t7 = () => {
      copyEntryToClipboard(props.state, formatInfo, collectionConfig.schema, {
        field: collectionConfig.slugField,
        value: getSlugFromState(collectionConfig, props.state)
      });
    };
    $[36] = props.state;
    $[37] = formatInfo;
    $[38] = collectionConfig;
    $[39] = t7;
  } else {
    t7 = $[39];
  }
  const onCopy = useEventCallback(t7);
  let t8;
  if ($[40] !== formatInfo || $[41] !== collectionConfig || $[42] !== props.state || $[43] !== props.previewProps) {
    t8 = async () => {
      const entry = await getPastedEntry(formatInfo, collectionConfig.schema, {
        field: collectionConfig.slugField,
        slug: getSlugFromState(collectionConfig, props.state)
      });
      if (entry) {
        setValueToPreviewProps(entry, props.previewProps);
        toastQueue.positive("Entry pasted", {
          shouldCloseOnAction: true,
          actionLabel: "Undo",
          onAction: () => {
            setValueToPreviewProps(props.state, props.previewProps);
          }
        });
      }
    };
    $[40] = formatInfo;
    $[41] = collectionConfig;
    $[42] = props.state;
    $[43] = props.previewProps;
    $[44] = t8;
  } else {
    t8 = $[44];
  }
  const onPaste = useEventCallback(t8);
  const viewHref = config.storage.kind !== "local" && repoInfo ? `${getRepoUrl(repoInfo)}${formatInfo.dataLocation === "index" ? `/tree/${currentBranch}/${(_getPathPrefix = getPathPrefix(config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${currentBasePath}` : `/blob/${currentBranch}/${(_getPathPrefix2 = getPathPrefix(config.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : ""}${currentBasePath}${getDataFileExtension(formatInfo)}`}` : void 0;
  let t9;
  let t10;
  if ($[45] !== updateResult.kind || $[46] !== onUpdate) {
    t9 = () => {
      const listener = (event) => {
        if (updateResult.kind === "loading") {
          return;
        }
        if ((0, import_is_hotkey.isHotkey)("mod+s", event)) {
          event.preventDefault();
          onUpdate();
        }
      };
      document.addEventListener("keydown", listener);
      return () => document.removeEventListener("keydown", listener);
    };
    t10 = [updateResult.kind, onUpdate];
    $[45] = updateResult.kind;
    $[46] = onUpdate;
    $[47] = t9;
    $[48] = t10;
  } else {
    t9 = $[47];
    t10 = $[48];
  }
  (0, import_react8.useEffect)(t9, t10);
  const t11 = updateResult.kind === "loading";
  let t12;
  if ($[49] !== t11 || $[50] !== props.hasChanged || $[51] !== props.onReset || $[52] !== onDelete || $[53] !== onDuplicate || $[54] !== onCopy || $[55] !== onPaste || $[56] !== viewHref || $[57] !== previewHref) {
    t12 = (0, import_jsx_runtime20.jsx)(HeaderActions, {
      formID: "item-edit-form",
      isLoading: t11,
      hasChanged: props.hasChanged,
      onDelete,
      onDuplicate,
      onCopy,
      onPaste,
      onReset: props.onReset,
      viewHref,
      previewHref
    });
    $[49] = t11;
    $[50] = props.hasChanged;
    $[51] = props.onReset;
    $[52] = onDelete;
    $[53] = onDuplicate;
    $[54] = onCopy;
    $[55] = onPaste;
    $[56] = viewHref;
    $[57] = previewHref;
    $[58] = t12;
  } else {
    t12 = $[58];
  }
  let t13;
  if ($[59] !== updateResult) {
    t13 = updateResult.kind === "error" && (0, import_jsx_runtime20.jsx)(Notice, {
      tone: "critical",
      children: updateResult.error.message
    });
    $[59] = updateResult;
    $[60] = t13;
  } else {
    t13 = $[60];
  }
  let t14;
  if ($[61] !== deleteResult) {
    t14 = deleteResult.kind === "error" && (0, import_jsx_runtime20.jsx)(Notice, {
      tone: "critical",
      children: deleteResult.error.message
    });
    $[61] = deleteResult;
    $[62] = t14;
  } else {
    t14 = $[62];
  }
  let t15;
  if ($[63] !== onUpdate) {
    t15 = (event_0) => {
      if (event_0.target !== event_0.currentTarget) {
        return;
      }
      event_0.preventDefault();
      onUpdate();
    };
    $[63] = onUpdate;
    $[64] = t15;
  } else {
    t15 = $[64];
  }
  const t16 = props.previewProps;
  let t17;
  if ($[65] !== t16 || $[66] !== forceValidation || $[67] !== collectionConfig.entryLayout || $[68] !== formatInfo || $[69] !== slugInfo) {
    t17 = (0, import_jsx_runtime20.jsx)(FormForEntry, {
      previewProps: t16,
      forceValidation,
      entryLayout: collectionConfig.entryLayout,
      formatInfo,
      slugField: slugInfo
    });
    $[65] = t16;
    $[66] = forceValidation;
    $[67] = collectionConfig.entryLayout;
    $[68] = formatInfo;
    $[69] = slugInfo;
    $[70] = t17;
  } else {
    t17 = $[70];
  }
  let t18;
  if ($[71] !== t15 || $[72] !== t17) {
    t18 = (0, import_jsx_runtime20.jsx)(Box, {
      id: "item-edit-form",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      elementType: "form",
      onSubmit: t15,
      children: t17
    });
    $[71] = t15;
    $[72] = t17;
    $[73] = t18;
  } else {
    t18 = $[73];
  }
  let t19;
  if ($[74] !== updateResult || $[75] !== collection || $[76] !== router || $[77] !== itemSlug || $[78] !== collectionConfig || $[79] !== props || $[80] !== parentOnUpdate || $[81] !== baseCommit) {
    t19 = updateResult.kind === "needs-new-branch" && (0, import_jsx_runtime20.jsx)(CreateBranchDuringUpdateDialog, {
      branchOid: baseCommit,
      onCreate: async (newBranch) => {
        const itemBasePath = `/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(collection)}/item/`;
        router.push(itemBasePath + encodeURIComponent(itemSlug));
        const slug_0 = getSlugFromState(collectionConfig, props.state);
        const hasUpdated_0 = await parentOnUpdate({
          branch: newBranch,
          sha: baseCommit
        });
        if (hasUpdated_0 && slug_0 !== itemSlug) {
          router.replace(itemBasePath + encodeURIComponent(slug_0));
        }
      },
      reason: updateResult.reason,
      onDismiss: props.onResetUpdateItem
    });
    $[74] = updateResult;
    $[75] = collection;
    $[76] = router;
    $[77] = itemSlug;
    $[78] = collectionConfig;
    $[79] = props;
    $[80] = parentOnUpdate;
    $[81] = baseCommit;
    $[82] = t19;
  } else {
    t19 = $[82];
  }
  let t20;
  if ($[83] !== props.onResetUpdateItem || $[84] !== t19) {
    t20 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: props.onResetUpdateItem,
      children: t19
    });
    $[83] = props.onResetUpdateItem;
    $[84] = t19;
    $[85] = t20;
  } else {
    t20 = $[85];
  }
  let t21;
  if ($[86] !== updateResult.kind || $[87] !== props || $[88] !== collectionConfig || $[89] !== itemSlug || $[90] !== router || $[91] !== collection) {
    t21 = updateResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime20.jsx)(ForkRepoDialog, {
      onCreate: async () => {
        const slug_1 = getSlugFromState(collectionConfig, props.state);
        const hasUpdated_1 = await props.onUpdate();
        if (hasUpdated_1 && slug_1 !== itemSlug) {
          router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug_1)}`);
        }
      },
      onDismiss: props.onResetUpdateItem,
      config: props.config
    });
    $[86] = updateResult.kind;
    $[87] = props;
    $[88] = collectionConfig;
    $[89] = itemSlug;
    $[90] = router;
    $[91] = collection;
    $[92] = t21;
  } else {
    t21 = $[92];
  }
  let t22;
  if ($[93] !== props.onResetUpdateItem || $[94] !== t21) {
    t22 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: props.onResetUpdateItem,
      children: t21
    });
    $[93] = props.onResetUpdateItem;
    $[94] = t21;
    $[95] = t22;
  } else {
    t22 = $[95];
  }
  let t23;
  if ($[96] !== deleteResult.kind || $[97] !== props || $[98] !== deleteItem || $[99] !== router || $[100] !== collection || $[101] !== resetDeleteItem) {
    t23 = deleteResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime20.jsx)(ForkRepoDialog, {
      onCreate: async () => {
        await deleteItem();
        router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
      },
      onDismiss: resetDeleteItem,
      config: props.config
    });
    $[96] = deleteResult.kind;
    $[97] = props;
    $[98] = deleteItem;
    $[99] = router;
    $[100] = collection;
    $[101] = resetDeleteItem;
    $[102] = t23;
  } else {
    t23 = $[102];
  }
  let t24;
  if ($[103] !== resetDeleteItem || $[104] !== t23) {
    t24 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: resetDeleteItem,
      children: t23
    });
    $[103] = resetDeleteItem;
    $[104] = t23;
    $[105] = t24;
  } else {
    t24 = $[105];
  }
  let t25;
  if ($[106] !== t12 || $[107] !== props || $[108] !== t13 || $[109] !== t14 || $[110] !== t18 || $[111] !== t20 || $[112] !== t22 || $[113] !== t24) {
    t25 = (0, import_jsx_runtime20.jsx)(import_jsx_runtime20.Fragment, {
      children: (0, import_jsx_runtime20.jsxs)(ItemPageShell, {
        headerActions: t12,
        ...props,
        children: [t13, t14, t18, t20, t22, t24]
      })
    });
    $[106] = t12;
    $[107] = props;
    $[108] = t13;
    $[109] = t14;
    $[110] = t18;
    $[111] = t20;
    $[112] = t22;
    $[113] = t24;
    $[114] = t25;
  } else {
    t25 = $[114];
  }
  return t25;
}
function LocalItemPage(props) {
  var _draft$state;
  const $ = c(64);
  const {
    collection,
    config,
    initialFiles,
    initialState,
    localTreeKey,
    draft
  } = props;
  const {
    collectionConfig,
    schema: schema2
  } = useCollection(collection);
  const t0 = (_draft$state = draft === null || draft === void 0 ? void 0 : draft.state) !== null && _draft$state !== void 0 ? _draft$state : initialState;
  let t1;
  if ($[0] !== t0 || $[1] !== localTreeKey) {
    t1 = {
      state: t0,
      localTreeKey
    };
    $[0] = t0;
    $[1] = localTreeKey;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const [t2, setState] = (0, import_react8.useState)(t1);
  const {
    state,
    localTreeKey: localTreeKeyInState
  } = t2;
  useShowRestoredDraftMessage(draft, state, localTreeKey);
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      state: initialState,
      localTreeKey
    });
  }
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (stateUpdater) => {
      setState((state_0) => ({
        localTreeKey: state_0.localTreeKey,
        state: stateUpdater(state_0.state)
      }));
    };
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const onPreviewPropsChange = t3;
  const previewProps = usePreviewProps(schema2, onPreviewPropsChange, state);
  let t4;
  if ($[4] !== initialState || $[5] !== schema2 || $[6] !== state || $[7] !== collectionConfig.slugField) {
    t4 = {
      initialState,
      schema: schema2,
      state,
      slugField: collectionConfig.slugField
    };
    $[4] = initialState;
    $[5] = schema2;
    $[6] = state;
    $[7] = collectionConfig.slugField;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const hasChanged = useHasChanged(t4);
  let t5;
  let slug;
  let formatInfo;
  if ($[9] !== collectionConfig || $[10] !== state || $[11] !== config || $[12] !== collection) {
    slug = getSlugFromState(collectionConfig, state);
    let t62;
    if ($[16] !== config || $[17] !== collection) {
      t62 = getCollectionFormat(config, collection);
      $[16] = config;
      $[17] = collection;
      $[18] = t62;
    } else {
      t62 = $[18];
    }
    formatInfo = t62;
    t5 = getCollectionItemPath(config, collection, slug);
    $[9] = collectionConfig;
    $[10] = state;
    $[11] = config;
    $[12] = collection;
    $[13] = t5;
    $[14] = slug;
    $[15] = formatInfo;
  } else {
    t5 = $[13];
    slug = $[14];
    formatInfo = $[15];
  }
  const futureBasePath = t5;
  let t6;
  if ($[19] !== collectionConfig.slugField || $[20] !== slug) {
    t6 = {
      field: collectionConfig.slugField,
      value: slug
    };
    $[19] = collectionConfig.slugField;
    $[20] = slug;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  let t7;
  if ($[22] !== state || $[23] !== initialFiles || $[24] !== config || $[25] !== collectionConfig.schema || $[26] !== futureBasePath || $[27] !== formatInfo || $[28] !== localTreeKey || $[29] !== t6) {
    t7 = {
      state,
      initialFiles,
      config,
      schema: collectionConfig.schema,
      basePath: futureBasePath,
      format: formatInfo,
      currentLocalTreeKey: localTreeKey,
      slug: t6
    };
    $[22] = state;
    $[23] = initialFiles;
    $[24] = config;
    $[25] = collectionConfig.schema;
    $[26] = futureBasePath;
    $[27] = formatInfo;
    $[28] = localTreeKey;
    $[29] = t6;
    $[30] = t7;
  } else {
    t7 = $[30];
  }
  const [updateResult, _update, resetUpdateItem] = useUpsertItem(t7);
  let t8;
  if ($[31] !== collection || $[32] !== props.itemSlug || $[33] !== hasChanged || $[34] !== futureBasePath || $[35] !== config || $[36] !== collectionConfig.schema || $[37] !== collectionConfig.slugField || $[38] !== slug || $[39] !== state || $[40] !== localTreeKey) {
    t8 = () => {
      const key = ["collection", collection, props.itemSlug];
      if (hasChanged) {
        const serialized = serializeEntryToFiles({
          basePath: futureBasePath,
          format: getCollectionFormat(config, collection),
          schema: collectionConfig.schema,
          slug: {
            field: collectionConfig.slugField,
            value: slug
          },
          state
        });
        const files = new Map(serialized.map((x2) => [x2.path, x2.contents]));
        const data = {
          beforeTreeKey: localTreeKey,
          slug,
          files,
          savedAt: /* @__PURE__ */ new Date(),
          version: 1
        };
        setDraft(key, data);
      } else {
        delDraft(key);
      }
    };
    $[31] = collection;
    $[32] = props.itemSlug;
    $[33] = hasChanged;
    $[34] = futureBasePath;
    $[35] = config;
    $[36] = collectionConfig.schema;
    $[37] = collectionConfig.slugField;
    $[38] = slug;
    $[39] = state;
    $[40] = localTreeKey;
    $[41] = t8;
  } else {
    t8 = $[41];
  }
  let t9;
  if ($[42] !== collection || $[43] !== collectionConfig || $[44] !== config || $[45] !== futureBasePath || $[46] !== localTreeKey || $[47] !== props.itemSlug || $[48] !== slug || $[49] !== state || $[50] !== hasChanged) {
    t9 = [collection, collectionConfig, config, futureBasePath, localTreeKey, props.itemSlug, slug, state, hasChanged];
    $[42] = collection;
    $[43] = collectionConfig;
    $[44] = config;
    $[45] = futureBasePath;
    $[46] = localTreeKey;
    $[47] = props.itemSlug;
    $[48] = slug;
    $[49] = state;
    $[50] = hasChanged;
    $[51] = t9;
  } else {
    t9 = $[51];
  }
  (0, import_react8.useEffect)(t8, t9);
  const update = useEventCallback(_update);
  let t10;
  if ($[52] !== initialState || $[53] !== localTreeKey) {
    t10 = () => {
      setState({
        state: initialState,
        localTreeKey
      });
    };
    $[52] = initialState;
    $[53] = localTreeKey;
    $[54] = t10;
  } else {
    t10 = $[54];
  }
  const onReset = t10;
  let t11;
  if ($[55] !== props || $[56] !== update || $[57] !== onReset || $[58] !== updateResult || $[59] !== resetUpdateItem || $[60] !== previewProps || $[61] !== state || $[62] !== hasChanged) {
    t11 = (0, import_jsx_runtime20.jsx)(ItemPageInner, {
      ...props,
      onUpdate: update,
      onReset,
      updateResult,
      onResetUpdateItem: resetUpdateItem,
      previewProps,
      state,
      hasChanged
    });
    $[55] = props;
    $[56] = update;
    $[57] = onReset;
    $[58] = updateResult;
    $[59] = resetUpdateItem;
    $[60] = previewProps;
    $[61] = state;
    $[62] = hasChanged;
    $[63] = t11;
  } else {
    t11 = $[63];
  }
  return t11;
}
function CollabItemPage(props) {
  const $ = c(33);
  const {
    collection,
    config,
    initialFiles,
    initialState,
    localTreeKey
  } = props;
  const {
    collectionConfig,
    schema: schema2
  } = useCollection(collection);
  const state = useYJsValue(schema2, props.map);
  const previewProps = usePreviewPropsFromY(schema2, props.map, state);
  const slug = getSlugFromState(collectionConfig, state);
  let t0;
  if ($[0] !== props.config || $[1] !== props.collection) {
    t0 = getCollectionFormat(props.config, props.collection);
    $[0] = props.config;
    $[1] = props.collection;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const formatInfo = t0;
  let t1;
  if ($[3] !== initialState || $[4] !== schema2 || $[5] !== state || $[6] !== collectionConfig.slugField) {
    t1 = {
      initialState,
      schema: schema2,
      state,
      slugField: collectionConfig.slugField
    };
    $[3] = initialState;
    $[4] = schema2;
    $[5] = state;
    $[6] = collectionConfig.slugField;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const hasChanged = useHasChanged(t1);
  const futureBasePath = getCollectionItemPath(config, collection, slug);
  let t2;
  if ($[8] !== collectionConfig.slugField || $[9] !== slug) {
    t2 = {
      field: collectionConfig.slugField,
      value: slug
    };
    $[8] = collectionConfig.slugField;
    $[9] = slug;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  let t3;
  if ($[11] !== state || $[12] !== initialFiles || $[13] !== config || $[14] !== collectionConfig.schema || $[15] !== futureBasePath || $[16] !== formatInfo || $[17] !== localTreeKey || $[18] !== t2) {
    t3 = {
      state,
      initialFiles,
      config,
      schema: collectionConfig.schema,
      basePath: futureBasePath,
      format: formatInfo,
      currentLocalTreeKey: localTreeKey,
      slug: t2
    };
    $[11] = state;
    $[12] = initialFiles;
    $[13] = config;
    $[14] = collectionConfig.schema;
    $[15] = futureBasePath;
    $[16] = formatInfo;
    $[17] = localTreeKey;
    $[18] = t2;
    $[19] = t3;
  } else {
    t3 = $[19];
  }
  const [updateResult, _update, resetUpdateItem] = useUpsertItem(t3);
  const update = useEventCallback(_update);
  let t4;
  if ($[20] !== props.map || $[21] !== props.initialState || $[22] !== collectionConfig.schema) {
    t4 = () => {
      var _props$map$doc;
      (_props$map$doc = props.map.doc) === null || _props$map$doc === void 0 || _props$map$doc.transact(() => {
        for (const [key, value] of Object.entries(collectionConfig.schema)) {
          const val = getYjsValFromParsedValue(value, props.initialState[key]);
          props.map.set(key, val);
        }
      });
    };
    $[20] = props.map;
    $[21] = props.initialState;
    $[22] = collectionConfig.schema;
    $[23] = t4;
  } else {
    t4 = $[23];
  }
  const onReset = t4;
  let t5;
  if ($[24] !== props || $[25] !== update || $[26] !== onReset || $[27] !== updateResult || $[28] !== resetUpdateItem || $[29] !== previewProps || $[30] !== state || $[31] !== hasChanged) {
    t5 = (0, import_jsx_runtime20.jsx)(ItemPageInner, {
      ...props,
      onUpdate: update,
      onReset,
      updateResult,
      onResetUpdateItem: resetUpdateItem,
      previewProps,
      state,
      hasChanged
    });
    $[24] = props;
    $[25] = update;
    $[26] = onReset;
    $[27] = updateResult;
    $[28] = resetUpdateItem;
    $[29] = previewProps;
    $[30] = state;
    $[31] = hasChanged;
    $[32] = t5;
  } else {
    t5 = $[32];
  }
  return t5;
}
function HeaderActions(props) {
  const $ = c(55);
  const {
    formID,
    hasChanged,
    isLoading,
    onDelete,
    onDuplicate,
    onReset,
    onCopy,
    onPaste,
    previewHref,
    viewHref
  } = props;
  const isBelowDesktop = useMediaQuery(breakpointQueries$1.below.desktop);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(strings);
  const [deleteAlertIsOpen, setDeleteAlertOpen] = (0, import_react8.useState)(false);
  const [duplicateAlertIsOpen, setDuplicateAlertOpen] = (0, import_react8.useState)(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      key: "reset",
      label: "Reset changes",
      icon: historyIcon
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = {
      key: "delete",
      label: "Delete entry…",
      icon: trash2Icon
    };
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      key: "copy",
      label: "Copy entry",
      icon: clipboardCopyIcon
    };
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  let t4;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      key: "paste",
      label: "Paste entry",
      icon: clipboardPasteIcon
    };
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      key: "duplicate",
      label: "Duplicate entry…",
      icon: copyPlusIcon
    };
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  let items;
  if ($[5] !== previewHref || $[6] !== viewHref) {
    items = [t1, t2, t3, t4, t5];
    if (previewHref) {
      let t62;
      if ($[8] !== previewHref) {
        t62 = {
          key: "preview",
          label: "Preview",
          icon: externalLinkIcon,
          href: previewHref,
          target: "_blank",
          rel: "noopener noreferrer"
        };
        $[8] = previewHref;
        $[9] = t62;
      } else {
        t62 = $[9];
      }
      items.push(t62);
    }
    if (viewHref) {
      let t62;
      if ($[10] !== viewHref) {
        t62 = {
          key: "view",
          label: "View on GitHub",
          icon: githubIcon,
          href: viewHref,
          target: "_blank",
          rel: "noopener noreferrer"
        };
        $[10] = viewHref;
        $[11] = t62;
      } else {
        t62 = $[11];
      }
      items.push(t62);
    }
    $[5] = previewHref;
    $[6] = viewHref;
    $[7] = items;
  } else {
    items = $[7];
  }
  t0 = items;
  const menuActions2 = t0;
  let t6;
  bb0: {
    if (isLoading) {
      let t72;
      if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
        t72 = (0, import_jsx_runtime20.jsx)(ProgressCircle, {
          "aria-label": "Saving changes",
          isIndeterminate: true,
          size: "small",
          alignSelf: "center"
        });
        $[12] = t72;
      } else {
        t72 = $[12];
      }
      t6 = t72;
      break bb0;
    }
    if (hasChanged) {
      let t72;
      if ($[13] !== isBelowDesktop) {
        t72 = isBelowDesktop ? (0, import_jsx_runtime20.jsx)(Box, {
          backgroundColor: "pendingEmphasis",
          height: "scale.75",
          width: "scale.75",
          borderRadius: "full",
          children: (0, import_jsx_runtime20.jsx)(Text, {
            visuallyHidden: true,
            children: "Unsaved"
          })
        }) : (0, import_jsx_runtime20.jsx)(Badge, {
          tone: "pending",
          children: "Unsaved"
        });
        $[13] = isBelowDesktop;
        $[14] = t72;
      } else {
        t72 = $[14];
      }
      t6 = t72;
      break bb0;
    }
    t6 = null;
  }
  const indicatorElement = t6;
  let t7;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = {
      mobile: "small",
      tablet: "regular"
    };
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  let t8;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime20.jsx)(PresenceAvatars, {});
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  const t9 = isBelowDesktop ? "element.regular" : void 0;
  let t10;
  if ($[17] !== hasChanged) {
    t10 = hasChanged ? [] : ["reset"];
    $[17] = hasChanged;
    $[18] = t10;
  } else {
    t10 = $[18];
  }
  let t11;
  if ($[19] !== onReset || $[20] !== onCopy || $[21] !== onPaste || $[22] !== hasChanged || $[23] !== onDuplicate) {
    t11 = (key) => {
      bb28: switch (key) {
        case "reset": {
          onReset();
          break bb28;
        }
        case "delete": {
          setDeleteAlertOpen(true);
          break bb28;
        }
        case "copy": {
          onCopy();
          break bb28;
        }
        case "paste": {
          onPaste();
          break bb28;
        }
        case "duplicate": {
          if (hasChanged) {
            setDuplicateAlertOpen(true);
          } else {
            onDuplicate();
          }
        }
      }
    };
    $[19] = onReset;
    $[20] = onCopy;
    $[21] = onPaste;
    $[22] = hasChanged;
    $[23] = onDuplicate;
    $[24] = t11;
  } else {
    t11 = $[24];
  }
  let t12;
  if ($[25] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = (item) => (0, import_jsx_runtime20.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      textValue: item.label,
      href: item.href,
      target: item.target,
      rel: item.rel,
      children: [(0, import_jsx_runtime20.jsx)(Icon, {
        src: item.icon
      }), (0, import_jsx_runtime20.jsx)(Text, {
        children: item.label
      })]
    }, item.key);
    $[25] = t12;
  } else {
    t12 = $[25];
  }
  let t13;
  if ($[26] !== t9 || $[27] !== menuActions2 || $[28] !== t10 || $[29] !== t11) {
    t13 = (0, import_jsx_runtime20.jsx)(_ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: t9,
      items: menuActions2,
      disabledKeys: t10,
      onAction: t11,
      children: t12
    });
    $[26] = t9;
    $[27] = menuActions2;
    $[28] = t10;
    $[29] = t11;
    $[30] = t13;
  } else {
    t13 = $[30];
  }
  let t14;
  if ($[31] !== stringFormatter) {
    t14 = stringFormatter.format("save");
    $[31] = stringFormatter;
    $[32] = t14;
  } else {
    t14 = $[32];
  }
  let t15;
  if ($[33] !== formID || $[34] !== isLoading || $[35] !== t14) {
    t15 = (0, import_jsx_runtime20.jsx)(Button, {
      form: formID,
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      children: t14
    });
    $[33] = formID;
    $[34] = isLoading;
    $[35] = t14;
    $[36] = t15;
  } else {
    t15 = $[36];
  }
  let t16;
  if ($[37] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = () => setDeleteAlertOpen(false);
    $[37] = t16;
  } else {
    t16 = $[37];
  }
  let t17;
  if ($[38] !== deleteAlertIsOpen || $[39] !== onDelete) {
    t17 = deleteAlertIsOpen && (0, import_jsx_runtime20.jsx)(AlertDialog, {
      title: "Delete entry",
      tone: "critical",
      cancelLabel: "Cancel",
      primaryActionLabel: "Yes, delete",
      autoFocusButton: "cancel",
      onPrimaryAction: onDelete,
      children: "Are you sure? This action cannot be undone."
    });
    $[38] = deleteAlertIsOpen;
    $[39] = onDelete;
    $[40] = t17;
  } else {
    t17 = $[40];
  }
  let t18;
  if ($[41] !== t17) {
    t18 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: t16,
      children: t17
    });
    $[41] = t17;
    $[42] = t18;
  } else {
    t18 = $[42];
  }
  let t19;
  if ($[43] === Symbol.for("react.memo_cache_sentinel")) {
    t19 = () => setDuplicateAlertOpen(false);
    $[43] = t19;
  } else {
    t19 = $[43];
  }
  let t20;
  if ($[44] !== duplicateAlertIsOpen || $[45] !== onDuplicate) {
    t20 = duplicateAlertIsOpen && (0, import_jsx_runtime20.jsx)(AlertDialog, {
      title: "Save and duplicate entry",
      tone: "neutral",
      cancelLabel: "Cancel",
      primaryActionLabel: "Save and duplicate",
      autoFocusButton: "primary",
      onPrimaryAction: onDuplicate,
      children: "You have unsaved changes. Save this entry to duplicate it."
    });
    $[44] = duplicateAlertIsOpen;
    $[45] = onDuplicate;
    $[46] = t20;
  } else {
    t20 = $[46];
  }
  let t21;
  if ($[47] !== t20) {
    t21 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: t19,
      children: t20
    });
    $[47] = t20;
    $[48] = t21;
  } else {
    t21 = $[48];
  }
  let t22;
  if ($[49] !== indicatorElement || $[50] !== t13 || $[51] !== t15 || $[52] !== t18 || $[53] !== t21) {
    t22 = (0, import_jsx_runtime20.jsxs)(Flex, {
      alignItems: "center",
      gap: t7,
      children: [t8, indicatorElement, t13, t15, t18, t21]
    });
    $[49] = indicatorElement;
    $[50] = t13;
    $[51] = t15;
    $[52] = t18;
    $[53] = t21;
    $[54] = t22;
  } else {
    t22 = $[54];
  }
  return t22;
}
function CreateBranchDuringUpdateDialog(props) {
  var _data$createRef;
  const $ = c(41);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(strings);
  const repoInfo = useRepoInfo();
  const [branchName, setBranchName] = (0, import_react8.useState)("");
  const [t0, createBranch] = useCreateBranchMutation();
  const {
    error,
    fetching,
    data
  } = t0;
  const isLoading = fetching || !!(data !== null && data !== void 0 && (_data$createRef = data.createRef) !== null && _data$createRef !== void 0 && _data$createRef.__typename);
  const config = useConfig();
  let t1;
  if ($[0] !== config) {
    t1 = getBranchPrefix(config);
    $[0] = config;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const branchPrefix = t1;
  let t2;
  if ($[2] !== branchPrefix) {
    t2 = branchPrefix ? {
      UNSAFE_className: css({
        "& input": {
          paddingInlineStart: tokenSchema.size.space.xsmall
        }
      }),
      startElement: (0, import_jsx_runtime20.jsx)(Flex, {
        alignItems: "center",
        paddingStart: "regular",
        justifyContent: "center",
        pointerEvents: "none",
        children: (0, import_jsx_runtime20.jsx)(Text, {
          color: "neutralSecondary",
          children: branchPrefix
        })
      })
    } : {};
    $[2] = branchPrefix;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const propsForBranchPrefix = t2;
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      display: "contents"
    };
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== branchPrefix || $[6] !== branchName || $[7] !== createBranch || $[8] !== props || $[9] !== repoInfo) {
    t4 = async (event) => {
      var _result$data;
      if (event.target !== event.currentTarget) {
        return;
      }
      event.preventDefault();
      const fullBranchName = (branchPrefix !== null && branchPrefix !== void 0 ? branchPrefix : "") + branchName;
      const name = `refs/heads/${fullBranchName}`;
      const result = await createBranch({
        input: {
          name,
          oid: props.branchOid,
          repositoryId: repoInfo.id
        }
      });
      if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
        props.onCreate(fullBranchName);
      }
    };
    $[5] = branchPrefix;
    $[6] = branchName;
    $[7] = createBranch;
    $[8] = props;
    $[9] = repoInfo;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== stringFormatter) {
    t5 = stringFormatter.format("newBranch");
    $[11] = stringFormatter;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== t5) {
    t6 = (0, import_jsx_runtime20.jsx)(Heading, {
      children: t5
    });
    $[13] = t5;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  let t7;
  if ($[15] !== error) {
    t7 = prettyErrorForCreateBranchMutation(error);
    $[15] = error;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  let t8;
  if ($[17] !== branchName || $[18] !== props.reason || $[19] !== t7 || $[20] !== propsForBranchPrefix) {
    t8 = (0, import_jsx_runtime20.jsx)(Content, {
      children: (0, import_jsx_runtime20.jsx)(Flex, {
        gap: "large",
        direction: "column",
        children: (0, import_jsx_runtime20.jsx)(TextField, {
          value: branchName,
          onChange: setBranchName,
          label: "Branch name",
          description: props.reason,
          autoFocus: true,
          errorMessage: t7,
          ...propsForBranchPrefix
        })
      })
    });
    $[17] = branchName;
    $[18] = props.reason;
    $[19] = t7;
    $[20] = propsForBranchPrefix;
    $[21] = t8;
  } else {
    t8 = $[21];
  }
  let t9;
  if ($[22] !== isLoading) {
    t9 = isLoading && (0, import_jsx_runtime20.jsx)(ProgressCircle, {
      isIndeterminate: true,
      size: "small",
      "aria-label": "Creating Branch"
    });
    $[22] = isLoading;
    $[23] = t9;
  } else {
    t9 = $[23];
  }
  let t10;
  if ($[24] !== stringFormatter) {
    t10 = stringFormatter.format("cancel");
    $[24] = stringFormatter;
    $[25] = t10;
  } else {
    t10 = $[25];
  }
  let t11;
  if ($[26] !== isLoading || $[27] !== props.onDismiss || $[28] !== t10) {
    t11 = (0, import_jsx_runtime20.jsx)(Button, {
      isDisabled: isLoading,
      onPress: props.onDismiss,
      children: t10
    });
    $[26] = isLoading;
    $[27] = props.onDismiss;
    $[28] = t10;
    $[29] = t11;
  } else {
    t11 = $[29];
  }
  let t12;
  if ($[30] !== isLoading) {
    t12 = (0, import_jsx_runtime20.jsx)(Button, {
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      children: "Create branch and save"
    });
    $[30] = isLoading;
    $[31] = t12;
  } else {
    t12 = $[31];
  }
  let t13;
  if ($[32] !== t9 || $[33] !== t11 || $[34] !== t12) {
    t13 = (0, import_jsx_runtime20.jsxs)(ButtonGroup, {
      children: [t9, t11, t12]
    });
    $[32] = t9;
    $[33] = t11;
    $[34] = t12;
    $[35] = t13;
  } else {
    t13 = $[35];
  }
  let t14;
  if ($[36] !== t4 || $[37] !== t6 || $[38] !== t8 || $[39] !== t13) {
    t14 = (0, import_jsx_runtime20.jsx)(Dialog, {
      children: (0, import_jsx_runtime20.jsxs)("form", {
        style: t3,
        onSubmit: t4,
        children: [t6, t8, t13]
      })
    });
    $[36] = t4;
    $[37] = t6;
    $[38] = t8;
    $[39] = t13;
    $[40] = t14;
  } else {
    t14 = $[40];
  }
  return t14;
}
function ItemPageOuterWrapper(props) {
  var _props$config$collect;
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig) notFound();
  const format = (0, import_react8.useMemo)(() => getCollectionFormat(props.config, props.collection), [props.config, props.collection]);
  const slugInfo = (0, import_react8.useMemo)(() => {
    return {
      slug: props.itemSlug,
      field: collectionConfig.slugField
    };
  }, [collectionConfig.slugField, props.itemSlug]);
  const draftData = useData((0, import_react8.useCallback)(async () => {
    try {
      const raw = await getDraft(["collection", props.collection, props.itemSlug]);
      if (!raw) throw new Error("No draft found");
      const stored = storedValSchema$2.create(raw);
      const parsed = parseEntry({
        dirpath: getCollectionItemPath(props.config, props.collection, stored.slug),
        format: getCollectionFormat(props.config, props.collection),
        schema: collectionConfig.schema,
        slug: {
          field: collectionConfig.slugField,
          slug: stored.slug
        }
      }, stored.files);
      return {
        state: parsed.initialState,
        savedAt: stored.savedAt,
        treeKey: stored.beforeTreeKey
      };
    } catch {
    }
  }, [collectionConfig, props.collection, props.config, props.itemSlug]));
  const itemData = useItemData({
    config: props.config,
    dirpath: getCollectionItemPath(props.config, props.collection, props.itemSlug),
    schema: collectionConfig.schema,
    format,
    slug: slugInfo
  });
  const currentBranch = useCurrentBranch();
  const key = `${currentBranch}/${props.collection}/item/${props.itemSlug}`;
  const yjsInfo = useYjsIfAvailable();
  const isItemDataLoading = itemData.kind !== "loaded";
  const isItemNotFound = !isItemDataLoading && itemData.data === "not-found";
  const mapData = useData((0, import_react8.useCallback)(() => {
    if (!yjsInfo) return;
    if (yjsInfo === "loading") return LOADING;
    if (isItemDataLoading) return LOADING;
    if (isItemNotFound) return;
    return (async () => {
      await yjsInfo.doc.whenSynced;
      let doc = yjsInfo.data.get(key);
      if (doc instanceof Doc) {
        const promise = doc.whenLoaded;
        doc.load();
        await promise;
      } else {
        doc = new Doc();
        yjsInfo.data.set(key, doc);
      }
      const data = doc.getMap("data");
      return data;
    })();
  }, [isItemDataLoading, isItemNotFound, key, yjsInfo]));
  return (0, import_jsx_runtime20.jsx)(NotFoundBoundary, {
    fallback: (0, import_jsx_runtime20.jsx)(ItemPageShell, {
      ...props,
      children: (0, import_jsx_runtime20.jsx)(PageBody, {
        children: (0, import_jsx_runtime20.jsx)(Notice, {
          tone: "caution",
          children: "Entry not found."
        })
      })
    }),
    children: (0, import_jsx_runtime20.jsx)(ErrorBoundary, {
      fallback: (message) => (0, import_jsx_runtime20.jsx)(ItemPageShell, {
        ...props,
        children: (0, import_jsx_runtime20.jsx)(PageBody, {
          children: (0, import_jsx_runtime20.jsx)(Notice, {
            tone: "critical",
            children: message
          })
        })
      }),
      children: (0, import_jsx_runtime20.jsx)(import_react8.Suspense, {
        fallback: (0, import_jsx_runtime20.jsx)(ItemPageShell, {
          ...props,
          children: (0, import_jsx_runtime20.jsx)(Flex, {
            alignItems: "center",
            justifyContent: "center",
            minHeight: "scale.3000",
            children: (0, import_jsx_runtime20.jsx)(ProgressCircle, {
              "aria-label": "Loading Item",
              isIndeterminate: true,
              size: "large"
            })
          })
        }),
        children: (0, import_jsx_runtime20.jsx)(ItemPageWrapper, {
          mapData,
          draftData,
          itemData,
          ...props
        })
      })
    })
  });
}
function ItemPageWrapper(props) {
  const collectionConfig = getCollection(props.config, props.collection);
  const deferredDraftData = (0, import_react8.useDeferredValue)(props.draftData);
  const itemData = suspendOnData(props.itemData);
  if (itemData === "not-found") notFound();
  const mapData = suspendOnData(props.mapData);
  (0, import_react8.useMemo)(() => {
    var _mapData$doc;
    if (!mapData || mapData.size) {
      return;
    }
    const {
      initialState
    } = itemData;
    (_mapData$doc = mapData.doc) === null || _mapData$doc === void 0 || _mapData$doc.transact(() => {
      for (const [key, value] of Object.entries(collectionConfig.schema)) {
        const val = getYjsValFromParsedValue(value, initialState[key]);
        mapData.set(key, val);
      }
    });
  }, [collectionConfig.schema, itemData, mapData]);
  const loadedDraft = suspendOnData(deferredDraftData);
  if (mapData) {
    return (0, import_jsx_runtime20.jsx)(CollabItemPage, {
      collection: props.collection,
      basePath: props.basePath,
      config: props.config,
      itemSlug: props.itemSlug,
      initialState: itemData.initialState,
      initialFiles: itemData.initialFiles,
      localTreeKey: itemData.localTreeKey,
      map: mapData
    });
  }
  return (0, import_jsx_runtime20.jsx)(LocalItemPage, {
    collection: props.collection,
    basePath: props.basePath,
    config: props.config,
    itemSlug: props.itemSlug,
    initialState: itemData.initialState,
    initialFiles: itemData.initialFiles,
    draft: loadedDraft,
    localTreeKey: itemData.localTreeKey
  });
}
function ItemPageShell(props) {
  const $ = c(17);
  let breadcrumbItems;
  let T0;
  let t0;
  if ($[0] !== props.config || $[1] !== props.collection || $[2] !== props.basePath || $[3] !== props.itemSlug) {
    const collectionConfig = getCollection(props.config, props.collection);
    const collectionHref = `${props.basePath}/collection/${props.collection}`;
    breadcrumbItems = [{
      key: "collection",
      label: collectionConfig.label,
      href: collectionHref
    }, {
      key: "item",
      label: props.itemSlug
    }];
    T0 = PageRoot;
    t0 = containerWidthForEntryLayout(collectionConfig);
    $[0] = props.config;
    $[1] = props.collection;
    $[2] = props.basePath;
    $[3] = props.itemSlug;
    $[4] = breadcrumbItems;
    $[5] = T0;
    $[6] = t0;
  } else {
    breadcrumbItems = $[4];
    T0 = $[5];
    t0 = $[6];
  }
  let t1;
  if ($[7] !== breadcrumbItems) {
    t1 = (0, import_jsx_runtime20.jsx)(HeaderBreadcrumbs, {
      items: breadcrumbItems
    });
    $[7] = breadcrumbItems;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  let t2;
  if ($[9] !== t1 || $[10] !== props.headerActions) {
    t2 = (0, import_jsx_runtime20.jsxs)(PageHeader, {
      children: [t1, props.headerActions]
    });
    $[9] = t1;
    $[10] = props.headerActions;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  let t3;
  if ($[12] !== T0 || $[13] !== t0 || $[14] !== t2 || $[15] !== props.children) {
    t3 = (0, import_jsx_runtime20.jsxs)(T0, {
      containerWidth: t0,
      children: [t2, props.children]
    });
    $[12] = T0;
    $[13] = t0;
    $[14] = t2;
    $[15] = props.children;
    $[16] = t3;
  } else {
    t3 = $[16];
  }
  return t3;
}
function useDuplicateSlug(duplicateInitalState, collectionConfig) {
  return (0, import_react8.useMemo)(() => {
    if (duplicateInitalState) {
      const {
        slugField
      } = collectionConfig;
      const defaultSlugVal = duplicateInitalState[collectionConfig.slugField];
      const slugFieldSchema = collectionConfig.schema[collectionConfig.slugField];
      if (slugFieldSchema.kind === "form" && slugFieldSchema.formKind === "slug") {
        try {
          const serialized = slugFieldSchema.serializeWithSlug(defaultSlugVal);
          const slugFieldValue = slugFieldSchema.parse(serialized.value, {
            slug: serialized.slug ? `${serialized.slug}-copy` : ""
          });
          return {
            ...duplicateInitalState,
            [slugField]: slugFieldValue
          };
        } catch {
        }
      }
      return {
        ...duplicateInitalState,
        [slugField]: defaultSlugVal
      };
    }
  }, [collectionConfig, duplicateInitalState]);
}
function CreateItemWrapper(props) {
  var _props$config$collect;
  const $ = c(53);
  const router = useRouter();
  let t0;
  let t1;
  if ($[0] !== router.href) {
    const url = new URL(router.href, "http://localhost");
    t1 = url.searchParams.get("duplicate");
    $[0] = router.href;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const duplicateSlug = t0;
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig) {
    notFound();
  }
  let t2;
  let t3;
  if ($[2] !== props.config || $[3] !== props.collection) {
    t3 = getCollectionFormat(props.config, props.collection);
    $[2] = props.config;
    $[3] = props.collection;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  t2 = t3;
  const format = t2;
  let t4;
  if ($[5] !== props.collection || $[6] !== props.config || $[7] !== duplicateSlug || $[8] !== format || $[9] !== collectionConfig.schema || $[10] !== collectionConfig.slugField) {
    t4 = async () => {
      const raw = await getDraft(["collection-create", props.collection, ...duplicateSlug ? [duplicateSlug] : []]);
      if (!raw) {
        throw new Error("No draft found");
      }
      const stored = storedValSchema$1.create(raw);
      const parsed = parseEntry({
        dirpath: getCollectionItemPath(props.config, props.collection, stored.slug),
        format,
        schema: collectionConfig.schema,
        slug: {
          field: collectionConfig.slugField,
          slug: stored.slug
        }
      }, stored.files);
      return {
        state: parsed.initialState,
        savedAt: stored.savedAt
      };
    };
    $[5] = props.collection;
    $[6] = props.config;
    $[7] = duplicateSlug;
    $[8] = format;
    $[9] = collectionConfig.schema;
    $[10] = collectionConfig.slugField;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  const draftData = useData(t4);
  let t5;
  bb0: {
    if (duplicateSlug) {
      let t62;
      if ($[12] !== collectionConfig.slugField || $[13] !== duplicateSlug) {
        t62 = {
          field: collectionConfig.slugField,
          slug: duplicateSlug
        };
        $[12] = collectionConfig.slugField;
        $[13] = duplicateSlug;
        $[14] = t62;
      } else {
        t62 = $[14];
      }
      t5 = t62;
      break bb0;
    }
    if (collectionConfig.template) {
      let t62;
      if ($[15] !== collectionConfig.slugField) {
        t62 = {
          field: collectionConfig.slugField,
          slug: ""
        };
        $[15] = collectionConfig.slugField;
        $[16] = t62;
      } else {
        t62 = $[16];
      }
      t5 = t62;
      break bb0;
    }
    t5 = void 0;
  }
  const slug = t5;
  const isFromTemplate = !!duplicateSlug || !!collectionConfig.template;
  let t6;
  if ($[17] !== collectionConfig.template || $[18] !== duplicateSlug || $[19] !== props) {
    t6 = collectionConfig.template && !duplicateSlug ? collectionConfig.template : getCollectionItemPath(props.config, props.collection, duplicateSlug !== null && duplicateSlug !== void 0 ? duplicateSlug : "");
    $[17] = collectionConfig.template;
    $[18] = duplicateSlug;
    $[19] = props;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  let t7;
  if ($[21] !== props.config || $[22] !== t6 || $[23] !== collectionConfig.schema || $[24] !== format || $[25] !== slug) {
    t7 = {
      config: props.config,
      dirpath: t6,
      schema: collectionConfig.schema,
      format,
      slug
    };
    $[21] = props.config;
    $[22] = t6;
    $[23] = collectionConfig.schema;
    $[24] = format;
    $[25] = slug;
    $[26] = t7;
  } else {
    t7 = $[26];
  }
  const itemData = useItemData(t7);
  const duplicateInitalState = isFromTemplate && itemData.kind === "loaded" && itemData.data !== "not-found" ? itemData.data.initialState : void 0;
  const duplicateInitalStateWithUpdatedSlug = useDuplicateSlug(duplicateInitalState, collectionConfig);
  const currentBranch = useCurrentBranch();
  const yjsInfo = useYjsIfAvailable();
  const key = `${currentBranch}/${props.collection}/create${duplicateSlug !== null && duplicateSlug !== void 0 && duplicateSlug.length ? `?duplicate=${duplicateSlug}` : ""}`;
  let t8;
  if ($[27] !== yjsInfo || $[28] !== isFromTemplate || $[29] !== duplicateInitalState || $[30] !== key || $[31] !== collectionConfig.schema) {
    t8 = async () => {
      if (!yjsInfo) {
        return;
      }
      if (yjsInfo === "loading") {
        return LOADING;
      }
      await yjsInfo.doc.whenSynced;
      if (isFromTemplate && !duplicateInitalState) {
        return LOADING;
      }
      let doc = yjsInfo.data.get(key);
      if (doc instanceof Doc) {
        const promise = doc.whenLoaded;
        doc.load();
        await promise;
      } else {
        doc = new Doc();
        yjsInfo.data.set(key, doc);
      }
      const data = doc.getMap("data");
      if (!data.size) {
        doc.transact(() => {
          for (const [key_0, value] of Object.entries(collectionConfig.schema)) {
            var _duplicateInitalState;
            const val = getYjsValFromParsedValue(value, (_duplicateInitalState = duplicateInitalState === null || duplicateInitalState === void 0 ? void 0 : duplicateInitalState[key_0]) !== null && _duplicateInitalState !== void 0 ? _duplicateInitalState : getInitialPropsValue(value));
            data.set(key_0, val);
          }
        });
      }
      return data;
    };
    $[27] = yjsInfo;
    $[28] = isFromTemplate;
    $[29] = duplicateInitalState;
    $[30] = key;
    $[31] = collectionConfig.schema;
    $[32] = t8;
  } else {
    t8 = $[32];
  }
  const mapData = useData(t8);
  if (isFromTemplate && itemData.kind === "error") {
    let t92;
    if ($[33] !== itemData.error.message) {
      t92 = (0, import_jsx_runtime20.jsx)(PageBody, {
        children: (0, import_jsx_runtime20.jsx)(Notice, {
          tone: "critical",
          children: itemData.error.message
        })
      });
      $[33] = itemData.error.message;
      $[34] = t92;
    } else {
      t92 = $[34];
    }
    return t92;
  }
  if (mapData.kind === "error") {
    console.log(mapData.error);
    let t92;
    if ($[35] !== mapData.error.message) {
      t92 = (0, import_jsx_runtime20.jsx)(PageBody, {
        children: (0, import_jsx_runtime20.jsx)(Notice, {
          tone: "critical",
          children: mapData.error.message
        })
      });
      $[35] = mapData.error.message;
      $[36] = t92;
    } else {
      t92 = $[36];
    }
    return t92;
  }
  if (isFromTemplate && itemData.kind === "loading" || draftData.kind === "loading" || mapData.kind === "loading") {
    let t92;
    if ($[37] === Symbol.for("react.memo_cache_sentinel")) {
      t92 = (0, import_jsx_runtime20.jsx)(Flex, {
        alignItems: "center",
        justifyContent: "center",
        minHeight: "scale.3000",
        children: (0, import_jsx_runtime20.jsx)(ProgressCircle, {
          "aria-label": "Loading Item",
          isIndeterminate: true,
          size: "large"
        })
      });
      $[37] = t92;
    } else {
      t92 = $[37];
    }
    return t92;
  }
  if (isFromTemplate && itemData.kind === "loaded" && itemData.data === "not-found") {
    let t92;
    if ($[38] === Symbol.for("react.memo_cache_sentinel")) {
      t92 = (0, import_jsx_runtime20.jsx)(PageBody, {
        children: (0, import_jsx_runtime20.jsx)(Notice, {
          tone: "caution",
          children: "Entry not found."
        })
      });
      $[38] = t92;
    } else {
      t92 = $[38];
    }
    return t92;
  }
  if (!mapData.data) {
    const t92 = draftData.kind === "loaded" ? draftData.data : void 0;
    let t10;
    if ($[39] !== props.collection || $[40] !== props.config || $[41] !== props.basePath || $[42] !== t92 || $[43] !== duplicateSlug || $[44] !== duplicateInitalStateWithUpdatedSlug) {
      t10 = (0, import_jsx_runtime20.jsx)(CreateItemLocal, {
        collection: props.collection,
        config: props.config,
        basePath: props.basePath,
        draft: t92,
        duplicateSlug,
        initialState: duplicateInitalStateWithUpdatedSlug
      });
      $[39] = props.collection;
      $[40] = props.config;
      $[41] = props.basePath;
      $[42] = t92;
      $[43] = duplicateSlug;
      $[44] = duplicateInitalStateWithUpdatedSlug;
      $[45] = t10;
    } else {
      t10 = $[45];
    }
    return t10;
  }
  let t9;
  if ($[46] !== props.collection || $[47] !== props.config || $[48] !== props.basePath || $[49] !== duplicateSlug || $[50] !== duplicateInitalStateWithUpdatedSlug || $[51] !== mapData.data) {
    t9 = (0, import_jsx_runtime20.jsx)(CreateItemCollab, {
      collection: props.collection,
      config: props.config,
      basePath: props.basePath,
      duplicateSlug,
      initialState: duplicateInitalStateWithUpdatedSlug,
      map: mapData.data
    });
    $[46] = props.collection;
    $[47] = props.config;
    $[48] = props.basePath;
    $[49] = duplicateSlug;
    $[50] = duplicateInitalStateWithUpdatedSlug;
    $[51] = mapData.data;
    $[52] = t9;
  } else {
    t9 = $[52];
  }
  return t9;
}
var storedValSchema$1 = type({
  version: literal(1),
  savedAt: date(),
  slug: string(),
  files: map(string(), instance(Uint8Array))
});
function CreateItemLocal(props) {
  var _props$draft$state, _props$draft;
  const $ = c(61);
  const {
    collectionConfig,
    schema: schema2
  } = useCollection(props.collection);
  let t0;
  let t1;
  if ($[0] !== props.initialState || $[1] !== schema2) {
    var _props$initialState;
    t1 = (_props$initialState = props.initialState) !== null && _props$initialState !== void 0 ? _props$initialState : getInitialPropsValue(schema2);
    $[0] = props.initialState;
    $[1] = schema2;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  t0 = t1;
  const initialState = t0;
  const [state, setState] = (0, import_react8.useState)((_props$draft$state = (_props$draft = props.draft) === null || _props$draft === void 0 ? void 0 : _props$draft.state) !== null && _props$draft$state !== void 0 ? _props$draft$state : initialState);
  const previewProps = usePreviewProps(schema2, setState, state);
  useShowRestoredDraftMessage(props.draft, state, void 0);
  let t2;
  let slug;
  let formatInfo;
  if ($[3] !== collectionConfig || $[4] !== state || $[5] !== props.config || $[6] !== props.collection) {
    slug = getSlugFromState(collectionConfig, state);
    let t32;
    if ($[10] !== props.config || $[11] !== props.collection) {
      t32 = getCollectionFormat(props.config, props.collection);
      $[10] = props.config;
      $[11] = props.collection;
      $[12] = t32;
    } else {
      t32 = $[12];
    }
    formatInfo = t32;
    t2 = getCollectionItemPath(props.config, props.collection, slug);
    $[3] = collectionConfig;
    $[4] = state;
    $[5] = props.config;
    $[6] = props.collection;
    $[7] = t2;
    $[8] = slug;
    $[9] = formatInfo;
  } else {
    t2 = $[7];
    slug = $[8];
    formatInfo = $[9];
  }
  const basePath = t2;
  let t3;
  if ($[13] !== collectionConfig.slugField || $[14] !== slug) {
    t3 = {
      field: collectionConfig.slugField,
      value: slug
    };
    $[13] = collectionConfig.slugField;
    $[14] = slug;
    $[15] = t3;
  } else {
    t3 = $[15];
  }
  let t4;
  if ($[16] !== state || $[17] !== basePath || $[18] !== props.config || $[19] !== collectionConfig.schema || $[20] !== formatInfo || $[21] !== t3) {
    t4 = {
      state,
      basePath,
      initialFiles: void 0,
      config: props.config,
      schema: collectionConfig.schema,
      format: formatInfo,
      currentLocalTreeKey: void 0,
      slug: t3
    };
    $[16] = state;
    $[17] = basePath;
    $[18] = props.config;
    $[19] = collectionConfig.schema;
    $[20] = formatInfo;
    $[21] = t3;
    $[22] = t4;
  } else {
    t4 = $[22];
  }
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem(t4);
  const createItem = useEventCallback(_createItem);
  let t5;
  if ($[23] !== initialState || $[24] !== schema2 || $[25] !== state || $[26] !== collectionConfig.slugField) {
    t5 = {
      initialState,
      schema: schema2,
      state,
      slugField: collectionConfig.slugField
    };
    $[23] = initialState;
    $[24] = schema2;
    $[25] = state;
    $[26] = collectionConfig.slugField;
    $[27] = t5;
  } else {
    t5 = $[27];
  }
  const hasChanged = useHasChanged(t5);
  const hasCreated = createResult.kind === "updated" || createResult.kind === "loading";
  let t6;
  if ($[28] !== props.collection || $[29] !== props.duplicateSlug || $[30] !== hasChanged || $[31] !== hasCreated || $[32] !== basePath || $[33] !== formatInfo || $[34] !== collectionConfig.schema || $[35] !== collectionConfig.slugField || $[36] !== slug || $[37] !== state) {
    t6 = () => {
      const key = ["collection-create", props.collection, ...props.duplicateSlug ? [props.duplicateSlug] : []];
      if (hasChanged && !hasCreated) {
        const serialized = serializeEntryToFiles({
          basePath,
          format: formatInfo,
          schema: collectionConfig.schema,
          slug: {
            field: collectionConfig.slugField,
            value: slug
          },
          state
        });
        const files = new Map(serialized.map((x2) => [x2.path, x2.contents]));
        const data = {
          slug,
          files,
          savedAt: /* @__PURE__ */ new Date(),
          version: 1
        };
        setDraft(key, data);
      } else {
        delDraft(key);
      }
    };
    $[28] = props.collection;
    $[29] = props.duplicateSlug;
    $[30] = hasChanged;
    $[31] = hasCreated;
    $[32] = basePath;
    $[33] = formatInfo;
    $[34] = collectionConfig.schema;
    $[35] = collectionConfig.slugField;
    $[36] = slug;
    $[37] = state;
    $[38] = t6;
  } else {
    t6 = $[38];
  }
  let t7;
  if ($[39] !== collectionConfig || $[40] !== slug || $[41] !== state || $[42] !== hasChanged || $[43] !== props.duplicateSlug || $[44] !== props.collection || $[45] !== basePath || $[46] !== formatInfo || $[47] !== hasCreated) {
    t7 = [collectionConfig, slug, state, hasChanged, props.duplicateSlug, props.collection, basePath, formatInfo, hasCreated];
    $[39] = collectionConfig;
    $[40] = slug;
    $[41] = state;
    $[42] = hasChanged;
    $[43] = props.duplicateSlug;
    $[44] = props.collection;
    $[45] = basePath;
    $[46] = formatInfo;
    $[47] = hasCreated;
    $[48] = t7;
  } else {
    t7 = $[48];
  }
  (0, import_react8.useEffect)(t6, t7);
  let t8;
  if ($[49] !== initialState) {
    t8 = () => {
      setState(initialState);
    };
    $[49] = initialState;
    $[50] = t8;
  } else {
    t8 = $[50];
  }
  let t9;
  if ($[51] !== props.basePath || $[52] !== props.collection || $[53] !== createResult || $[54] !== createItem || $[55] !== resetCreateItemState || $[56] !== state || $[57] !== slug || $[58] !== previewProps || $[59] !== t8) {
    t9 = (0, import_jsx_runtime20.jsx)(CreateItemInner, {
      basePath: props.basePath,
      collection: props.collection,
      createResult,
      createItem,
      resetCreateItemState,
      state,
      slug,
      previewProps,
      onReset: t8
    });
    $[51] = props.basePath;
    $[52] = props.collection;
    $[53] = createResult;
    $[54] = createItem;
    $[55] = resetCreateItemState;
    $[56] = state;
    $[57] = slug;
    $[58] = previewProps;
    $[59] = t8;
    $[60] = t9;
  } else {
    t9 = $[60];
  }
  return t9;
}
function CreateItemCollab(props) {
  const $ = c(34);
  const {
    collectionConfig,
    schema: schema2
  } = useCollection(props.collection);
  const state = useYJsValue(schema2, props.map);
  const previewProps = usePreviewPropsFromY(schema2, props.map, state);
  let t0;
  let slug;
  let formatInfo;
  if ($[0] !== collectionConfig || $[1] !== state || $[2] !== props.config || $[3] !== props.collection) {
    slug = getSlugFromState(collectionConfig, state);
    let t12;
    if ($[7] !== props.config || $[8] !== props.collection) {
      t12 = getCollectionFormat(props.config, props.collection);
      $[7] = props.config;
      $[8] = props.collection;
      $[9] = t12;
    } else {
      t12 = $[9];
    }
    formatInfo = t12;
    t0 = getCollectionItemPath(props.config, props.collection, slug);
    $[0] = collectionConfig;
    $[1] = state;
    $[2] = props.config;
    $[3] = props.collection;
    $[4] = t0;
    $[5] = slug;
    $[6] = formatInfo;
  } else {
    t0 = $[4];
    slug = $[5];
    formatInfo = $[6];
  }
  const basePath = t0;
  let t1;
  if ($[10] !== collectionConfig.slugField || $[11] !== slug) {
    t1 = {
      field: collectionConfig.slugField,
      value: slug
    };
    $[10] = collectionConfig.slugField;
    $[11] = slug;
    $[12] = t1;
  } else {
    t1 = $[12];
  }
  let t2;
  if ($[13] !== state || $[14] !== basePath || $[15] !== props.config || $[16] !== collectionConfig.schema || $[17] !== formatInfo || $[18] !== t1) {
    t2 = {
      state,
      basePath,
      initialFiles: void 0,
      config: props.config,
      schema: collectionConfig.schema,
      format: formatInfo,
      currentLocalTreeKey: void 0,
      slug: t1
    };
    $[13] = state;
    $[14] = basePath;
    $[15] = props.config;
    $[16] = collectionConfig.schema;
    $[17] = formatInfo;
    $[18] = t1;
    $[19] = t2;
  } else {
    t2 = $[19];
  }
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem(t2);
  const createItem = useEventCallback(_createItem);
  let t3;
  if ($[20] !== props.map || $[21] !== props.initialState || $[22] !== collectionConfig.schema) {
    t3 = () => {
      var _props$map$doc;
      (_props$map$doc = props.map.doc) === null || _props$map$doc === void 0 || _props$map$doc.transact(() => {
        for (const [key, value] of Object.entries(collectionConfig.schema)) {
          var _props$initialState$k, _props$initialState2;
          const val = getYjsValFromParsedValue(value, (_props$initialState$k = (_props$initialState2 = props.initialState) === null || _props$initialState2 === void 0 ? void 0 : _props$initialState2[key]) !== null && _props$initialState$k !== void 0 ? _props$initialState$k : getInitialPropsValue(value));
          props.map.set(key, val);
        }
      });
    };
    $[20] = props.map;
    $[21] = props.initialState;
    $[22] = collectionConfig.schema;
    $[23] = t3;
  } else {
    t3 = $[23];
  }
  let t4;
  if ($[24] !== props.basePath || $[25] !== props.collection || $[26] !== createResult || $[27] !== createItem || $[28] !== resetCreateItemState || $[29] !== state || $[30] !== slug || $[31] !== previewProps || $[32] !== t3) {
    t4 = (0, import_jsx_runtime20.jsx)(CreateItemInner, {
      basePath: props.basePath,
      collection: props.collection,
      createResult,
      createItem,
      resetCreateItemState,
      state,
      slug,
      previewProps,
      onReset: t3
    });
    $[24] = props.basePath;
    $[25] = props.collection;
    $[26] = createResult;
    $[27] = createItem;
    $[28] = resetCreateItemState;
    $[29] = state;
    $[30] = slug;
    $[31] = previewProps;
    $[32] = t3;
    $[33] = t4;
  } else {
    t4 = $[33];
  }
  return t4;
}
function CreateItemInner(props) {
  const $ = c(96);
  const {
    onReset
  } = props;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(strings);
  const router = useRouter();
  const config = useConfig();
  const {
    collectionConfig,
    schema: schema2
  } = useCollection(props.collection);
  const [forceValidation, setForceValidation] = (0, import_react8.useState)(false);
  let t0;
  if ($[0] !== config || $[1] !== props.collection) {
    t0 = getCollectionFormat(config, props.collection);
    $[0] = config;
    $[1] = props.collection;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const formatInfo = t0;
  const baseCommit = useBaseCommit();
  const collectionPath = `${props.basePath}/collection/${encodeURIComponent(props.collection)}`;
  const {
    createResult
  } = props;
  const currentSlug = createResult.kind === "updated" || createResult.kind === "loading" ? props.slug : void 0;
  const slugInfo = useSlugFieldInfo(props.collection, currentSlug);
  let t1;
  if ($[3] !== createResult.kind || $[4] !== schema2 || $[5] !== props || $[6] !== slugInfo || $[7] !== collectionConfig || $[8] !== router || $[9] !== collectionPath) {
    t1 = async () => {
      if (createResult.kind === "loading") {
        return;
      }
      if (!clientSideValidateProp(schema2, props.state, slugInfo)) {
        setForceValidation(true);
        return;
      }
      if (await props.createItem()) {
        const slug = getSlugFromState(collectionConfig, props.state);
        router.push(`${collectionPath}/item/${encodeURIComponent(slug)}`);
        toastQueue.positive("Entry created", {
          timeout: 5e3
        });
      }
    };
    $[3] = createResult.kind;
    $[4] = schema2;
    $[5] = props;
    $[6] = slugInfo;
    $[7] = collectionConfig;
    $[8] = router;
    $[9] = collectionPath;
    $[10] = t1;
  } else {
    t1 = $[10];
  }
  const onCreate = t1;
  let t2;
  if ($[11] !== props.state || $[12] !== formatInfo || $[13] !== collectionConfig) {
    t2 = () => {
      copyEntryToClipboard(props.state, formatInfo, collectionConfig.schema, {
        field: collectionConfig.slugField,
        value: getSlugFromState(collectionConfig, props.state)
      });
    };
    $[11] = props.state;
    $[12] = formatInfo;
    $[13] = collectionConfig;
    $[14] = t2;
  } else {
    t2 = $[14];
  }
  const onCopy = t2;
  let t3;
  if ($[15] !== formatInfo || $[16] !== collectionConfig || $[17] !== props.state || $[18] !== props.previewProps) {
    t3 = async () => {
      const entry = await getPastedEntry(formatInfo, collectionConfig.schema, {
        field: collectionConfig.slugField,
        slug: getSlugFromState(collectionConfig, props.state)
      });
      if (entry) {
        setValueToPreviewProps(entry, props.previewProps);
        toastQueue.positive("Entry pasted", {
          shouldCloseOnAction: true,
          actionLabel: "Undo",
          onAction: () => {
            setValueToPreviewProps(props.state, props.previewProps);
          }
        });
      }
    };
    $[15] = formatInfo;
    $[16] = collectionConfig;
    $[17] = props.state;
    $[18] = props.previewProps;
    $[19] = t3;
  } else {
    t3 = $[19];
  }
  const onPaste = t3;
  const isLoading = createResult.kind === "loading" || createResult.kind === "updated";
  let t4;
  let t5;
  if ($[20] !== collectionConfig.label || $[21] !== collectionPath) {
    t5 = {
      key: "collection",
      label: collectionConfig.label,
      href: collectionPath
    };
    $[20] = collectionConfig.label;
    $[21] = collectionPath;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  let t6;
  if ($[23] !== stringFormatter) {
    t6 = stringFormatter.format("add");
    $[23] = stringFormatter;
    $[24] = t6;
  } else {
    t6 = $[24];
  }
  let t7;
  if ($[25] !== t6) {
    t7 = {
      key: "current",
      label: t6
    };
    $[25] = t6;
    $[26] = t7;
  } else {
    t7 = $[26];
  }
  let t8;
  if ($[27] !== t5 || $[28] !== t7) {
    t8 = [t5, t7];
    $[27] = t5;
    $[28] = t7;
    $[29] = t8;
  } else {
    t8 = $[29];
  }
  t4 = t8;
  const breadcrumbItems = t4;
  const isBelowDesktop = useMediaQuery(breakpointQueries$1.below.desktop);
  let t9;
  if ($[30] !== collectionConfig) {
    t9 = containerWidthForEntryLayout(collectionConfig);
    $[30] = collectionConfig;
    $[31] = t9;
  } else {
    t9 = $[31];
  }
  let t10;
  if ($[32] !== breadcrumbItems) {
    t10 = (0, import_jsx_runtime20.jsx)(HeaderBreadcrumbs, {
      items: breadcrumbItems
    });
    $[32] = breadcrumbItems;
    $[33] = t10;
  } else {
    t10 = $[33];
  }
  let t11;
  if ($[34] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = (0, import_jsx_runtime20.jsx)(PresenceAvatars, {});
    $[34] = t11;
  } else {
    t11 = $[34];
  }
  let t12;
  if ($[35] !== isLoading) {
    t12 = isLoading && (0, import_jsx_runtime20.jsx)(ProgressCircle, {
      "aria-label": "Creating entry",
      isIndeterminate: true,
      size: "small"
    });
    $[35] = isLoading;
    $[36] = t12;
  } else {
    t12 = $[36];
  }
  const t13 = isBelowDesktop ? "element.regular" : void 0;
  let t14;
  if ($[37] !== onReset || $[38] !== onCopy || $[39] !== onPaste) {
    t14 = (key) => {
      bb38: switch (key) {
        case "reset": {
          onReset();
          setForceValidation(false);
          break bb38;
        }
        case "copy": {
          onCopy();
          break bb38;
        }
        case "paste": {
          onPaste();
        }
      }
    };
    $[37] = onReset;
    $[38] = onCopy;
    $[39] = onPaste;
    $[40] = t14;
  } else {
    t14 = $[40];
  }
  let t15;
  if ($[41] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = (item) => (0, import_jsx_runtime20.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      textValue: item.label,
      children: [(0, import_jsx_runtime20.jsx)(Icon, {
        src: item.icon
      }), (0, import_jsx_runtime20.jsx)(Text, {
        children: item.label
      })]
    }, item.key);
    $[41] = t15;
  } else {
    t15 = $[41];
  }
  let t16;
  if ($[42] !== t13 || $[43] !== t14) {
    t16 = (0, import_jsx_runtime20.jsx)(_ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: t13,
      items: menuActions,
      onAction: t14,
      children: t15
    });
    $[42] = t13;
    $[43] = t14;
    $[44] = t16;
  } else {
    t16 = $[44];
  }
  let t17;
  if ($[45] !== stringFormatter) {
    t17 = stringFormatter.format("create");
    $[45] = stringFormatter;
    $[46] = t17;
  } else {
    t17 = $[46];
  }
  let t18;
  if ($[47] !== isLoading || $[48] !== t17) {
    t18 = (0, import_jsx_runtime20.jsx)(Button, {
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      form: "item-create-form",
      marginStart: "auto",
      children: t17
    });
    $[47] = isLoading;
    $[48] = t17;
    $[49] = t18;
  } else {
    t18 = $[49];
  }
  let t19;
  if ($[50] !== t10 || $[51] !== t12 || $[52] !== t16 || $[53] !== t18) {
    t19 = (0, import_jsx_runtime20.jsxs)(PageHeader, {
      children: [t10, t11, t12, t16, t18]
    });
    $[50] = t10;
    $[51] = t12;
    $[52] = t16;
    $[53] = t18;
    $[54] = t19;
  } else {
    t19 = $[54];
  }
  let t20;
  if ($[55] !== onCreate) {
    t20 = (event) => {
      if (event.target !== event.currentTarget) {
        return;
      }
      event.preventDefault();
      onCreate();
    };
    $[55] = onCreate;
    $[56] = t20;
  } else {
    t20 = $[56];
  }
  let t21;
  if ($[57] !== createResult) {
    t21 = createResult.kind === "error" && (0, import_jsx_runtime20.jsx)(Notice, {
      tone: "critical",
      children: createResult.error.message
    });
    $[57] = createResult;
    $[58] = t21;
  } else {
    t21 = $[58];
  }
  let t22;
  if ($[59] !== props.previewProps || $[60] !== forceValidation || $[61] !== collectionConfig.entryLayout || $[62] !== formatInfo || $[63] !== slugInfo) {
    t22 = (0, import_jsx_runtime20.jsx)(FormForEntry, {
      previewProps: props.previewProps,
      forceValidation,
      entryLayout: collectionConfig.entryLayout,
      formatInfo,
      slugField: slugInfo
    });
    $[59] = props.previewProps;
    $[60] = forceValidation;
    $[61] = collectionConfig.entryLayout;
    $[62] = formatInfo;
    $[63] = slugInfo;
    $[64] = t22;
  } else {
    t22 = $[64];
  }
  let t23;
  if ($[65] !== t20 || $[66] !== t21 || $[67] !== t22) {
    t23 = (0, import_jsx_runtime20.jsxs)(Flex, {
      id: "item-create-form",
      elementType: "form",
      onSubmit: t20,
      direction: "column",
      gap: "xxlarge",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children: [t21, t22]
    });
    $[65] = t20;
    $[66] = t21;
    $[67] = t22;
    $[68] = t23;
  } else {
    t23 = $[68];
  }
  let t24;
  if ($[69] !== t9 || $[70] !== t19 || $[71] !== t23) {
    t24 = (0, import_jsx_runtime20.jsxs)(PageRoot, {
      containerWidth: t9,
      children: [t19, t23]
    });
    $[69] = t9;
    $[70] = t19;
    $[71] = t23;
    $[72] = t24;
  } else {
    t24 = $[72];
  }
  let t25;
  if ($[73] !== createResult || $[74] !== router || $[75] !== props || $[76] !== baseCommit || $[77] !== collectionConfig) {
    t25 = createResult.kind === "needs-new-branch" && (0, import_jsx_runtime20.jsx)(CreateBranchDuringUpdateDialog, {
      branchOid: baseCommit,
      onCreate: async (newBranch) => {
        router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/create`);
        if (await props.createItem({
          branch: newBranch,
          sha: baseCommit
        })) {
          const slug_0 = getSlugFromState(collectionConfig, props.state);
          router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/item/${encodeURIComponent(slug_0)}`);
        }
      },
      reason: createResult.reason,
      onDismiss: props.resetCreateItemState
    });
    $[73] = createResult;
    $[74] = router;
    $[75] = props;
    $[76] = baseCommit;
    $[77] = collectionConfig;
    $[78] = t25;
  } else {
    t25 = $[78];
  }
  let t26;
  if ($[79] !== props.resetCreateItemState || $[80] !== t25) {
    t26 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: props.resetCreateItemState,
      children: t25
    });
    $[79] = props.resetCreateItemState;
    $[80] = t25;
    $[81] = t26;
  } else {
    t26 = $[81];
  }
  let t27;
  if ($[82] !== createResult.kind || $[83] !== config || $[84] !== props || $[85] !== collectionConfig || $[86] !== router || $[87] !== collectionPath) {
    t27 = createResult.kind === "needs-fork" && isGitHubConfig(config) && (0, import_jsx_runtime20.jsx)(ForkRepoDialog, {
      onCreate: async () => {
        if (await props.createItem()) {
          const slug_1 = getSlugFromState(collectionConfig, props.state);
          router.push(`${collectionPath}/item/${encodeURIComponent(slug_1)}`);
        }
      },
      onDismiss: props.resetCreateItemState,
      config
    });
    $[82] = createResult.kind;
    $[83] = config;
    $[84] = props;
    $[85] = collectionConfig;
    $[86] = router;
    $[87] = collectionPath;
    $[88] = t27;
  } else {
    t27 = $[88];
  }
  let t28;
  if ($[89] !== props.resetCreateItemState || $[90] !== t27) {
    t28 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: props.resetCreateItemState,
      children: t27
    });
    $[89] = props.resetCreateItemState;
    $[90] = t27;
    $[91] = t28;
  } else {
    t28 = $[91];
  }
  let t29;
  if ($[92] !== t24 || $[93] !== t26 || $[94] !== t28) {
    t29 = (0, import_jsx_runtime20.jsxs)(import_jsx_runtime20.Fragment, {
      children: [t24, t26, t28]
    });
    $[92] = t24;
    $[93] = t26;
    $[94] = t28;
    $[95] = t29;
  } else {
    t29 = $[95];
  }
  return t29;
}
var menuActions = [{
  key: "reset",
  label: "Reset",
  icon: historyIcon
}, {
  key: "copy",
  label: "Copy entry",
  icon: clipboardCopyIcon
}, {
  key: "paste",
  label: "Paste entry",
  icon: clipboardPasteIcon
}];
var DashboardSection = (t0) => {
  const $ = c(5);
  const {
    children,
    title
  } = t0;
  let t1;
  if ($[0] !== title) {
    t1 = (0, import_jsx_runtime20.jsx)(Text, {
      casing: "uppercase",
      color: "neutralTertiary",
      size: "small",
      weight: "bold",
      elementType: "h2",
      children: title
    });
    $[0] = title;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== t1 || $[3] !== children) {
    t2 = (0, import_jsx_runtime20.jsxs)(Flex, {
      elementType: "section",
      direction: "column",
      gap: "medium",
      children: [t1, children]
    });
    $[2] = t1;
    $[3] = children;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
};
var FILL_COLS = "fill";
var DashboardGrid = (props) => {
  return (0, import_jsx_runtime20.jsx)("div", {
    className: css({
      display: "grid",
      gap: tokenSchema.size.space.large,
      gridAutoRows: tokenSchema.size.element.xlarge,
      gridTemplateColumns: `[${FILL_COLS}-start] 1fr [${FILL_COLS}-end]`,
      [containerQueries.above.mobile]: {
        gridTemplateColumns: `[${FILL_COLS}-start] 1fr 1fr [${FILL_COLS}-end]`
      },
      [containerQueries.above.tablet]: {
        gridTemplateColumns: `[${FILL_COLS}-start] 1fr 1fr 1fr [${FILL_COLS}-end]`
      }
    }),
    ...props
  });
};
var DashboardCard = (props) => {
  const $ = c(12);
  const ref = (0, import_react8.useRef)(null);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, ref);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = classNames(css({
      color: tokenSchema.color.foreground.neutral,
      outline: "none",
      "&:hover": {
        color: tokenSchema.color.foreground.neutralEmphasis,
        "::before": {
          backgroundColor: tokenSchema.color.alias.backgroundIdle,
          borderColor: tokenSchema.color.border.neutral
        }
      },
      "&:active": {
        "::before": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          borderColor: tokenSchema.color.alias.borderHovered
        }
      },
      "&:focus-visible::before": {
        outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`,
        outlineOffset: tokenSchema.size.alias.focusRingGap
      },
      "::before": {
        border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`,
        borderRadius: tokenSchema.size.radius.medium,
        content: '""',
        position: "absolute",
        inset: 0,
        transition: transition(["background-color", "border-color"])
      }
    }));
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== ref || $[2] !== props.href || $[3] !== props.label || $[4] !== linkProps) {
    t1 = (0, import_jsx_runtime20.jsx)(Heading, {
      elementType: "h3",
      size: "small",
      truncate: true,
      children: (0, import_jsx_runtime20.jsx)("a", {
        ref,
        href: props.href,
        ...linkProps,
        className: t0,
        children: props.label
      })
    });
    $[1] = ref;
    $[2] = props.href;
    $[3] = props.label;
    $[4] = linkProps;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== t1 || $[7] !== props.children) {
    t2 = (0, import_jsx_runtime20.jsxs)(Flex, {
      direction: "column",
      gap: "medium",
      flex: true,
      children: [t1, props.children]
    });
    $[6] = t1;
    $[7] = props.children;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== t2 || $[10] !== props.endElement) {
    t3 = (0, import_jsx_runtime20.jsxs)(Flex, {
      alignItems: "center",
      backgroundColor: "canvas",
      padding: "large",
      position: "relative",
      children: [t2, props.endElement]
    });
    $[9] = t2;
    $[10] = props.endElement;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
};
function useLocalizedString() {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(strings);
  return stringFormatter;
}
function BranchSection() {
  const $ = c(30);
  const repoInfo = useRepoInfo();
  const currentBranch = useCurrentBranch();
  const router = useRouter();
  const localizedString = useLocalizedString();
  const prNumber = useAssociatedPullRequest();
  let t0;
  if ($[0] !== repoInfo) {
    t0 = repoInfo && getRepoUrl(repoInfo);
    $[0] = repoInfo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const repoURL = t0;
  const isDefaultBranch = currentBranch === (repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.defaultBranch);
  let t1;
  if ($[2] !== localizedString) {
    t1 = localizedString.format("currentBranch");
    $[2] = localizedString;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime20.jsx)(Icon, {
      src: gitBranchIcon,
      color: "neutralTertiary"
    });
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== currentBranch) {
    t3 = (0, import_jsx_runtime20.jsxs)(Flex, {
      alignItems: "center",
      gap: "regular",
      border: "muted",
      borderRadius: "medium",
      backgroundColor: "canvas",
      padding: "large",
      children: [t2, (0, import_jsx_runtime20.jsx)(Text, {
        size: "medium",
        weight: "semibold",
        children: currentBranch
      })]
    });
    $[5] = currentBranch;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  let t4;
  if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (0, import_jsx_runtime20.jsx)(Icon, {
      src: gitBranchPlusIcon
    });
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== localizedString) {
    t5 = localizedString.format("newBranch");
    $[8] = localizedString;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== t5) {
    t6 = (0, import_jsx_runtime20.jsxs)(ActionButton, {
      children: [t4, (0, import_jsx_runtime20.jsx)(Text, {
        children: t5
      })]
    });
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== router) {
    t7 = (close) => (0, import_jsx_runtime20.jsx)(CreateBranchDialog, {
      onDismiss: close,
      onCreate: (branchName) => {
        close();
        router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(branchName)));
      }
    });
    $[12] = router;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  let t8;
  if ($[14] !== t6 || $[15] !== t7) {
    t8 = (0, import_jsx_runtime20.jsxs)(_DialogTrigger, {
      children: [t6, t7]
    });
    $[14] = t6;
    $[15] = t7;
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  let t9;
  if ($[17] !== isDefaultBranch || $[18] !== prNumber || $[19] !== repoURL || $[20] !== currentBranch || $[21] !== localizedString) {
    t9 = !isDefaultBranch && prNumber !== void 0 && (prNumber === false ? (0, import_jsx_runtime20.jsxs)(ActionButton, {
      href: `${repoURL}/pull/new/${currentBranch}`,
      target: "_blank",
      children: [(0, import_jsx_runtime20.jsx)(Icon, {
        src: gitPullRequestIcon
      }), (0, import_jsx_runtime20.jsx)(Text, {
        children: localizedString.format("createPullRequest")
      })]
    }) : (0, import_jsx_runtime20.jsxs)(ActionButton, {
      href: `${repoURL}/pull/${prNumber}`,
      target: "_blank",
      children: [(0, import_jsx_runtime20.jsx)(Icon, {
        src: gitPullRequestIcon
      }), (0, import_jsx_runtime20.jsxs)(Text, {
        children: ["Pull request #", prNumber]
      })]
    }));
    $[17] = isDefaultBranch;
    $[18] = prNumber;
    $[19] = repoURL;
    $[20] = currentBranch;
    $[21] = localizedString;
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== t8 || $[24] !== t9) {
    t10 = (0, import_jsx_runtime20.jsxs)(Flex, {
      gap: "regular",
      wrap: true,
      children: [t8, t9]
    });
    $[23] = t8;
    $[24] = t9;
    $[25] = t10;
  } else {
    t10 = $[25];
  }
  let t11;
  if ($[26] !== t1 || $[27] !== t3 || $[28] !== t10) {
    t11 = (0, import_jsx_runtime20.jsxs)(DashboardSection, {
      title: t1,
      children: [t3, t10]
    });
    $[26] = t1;
    $[27] = t3;
    $[28] = t10;
    $[29] = t11;
  } else {
    t11 = $[29];
  }
  return t11;
}
function DashboardCards() {
  const $ = c(9);
  const navItems = useNavItems();
  let t0;
  if ($[0] !== navItems) {
    let t12;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t12 = (item) => "children" in item;
      $[2] = t12;
    } else {
      t12 = $[2];
    }
    t0 = navItems.some(t12);
    $[0] = navItems;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const hasSections = t0;
  let t1;
  if ($[3] !== navItems) {
    let t22;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t22 = (item_0) => renderItemOrGroup(item_0);
      $[5] = t22;
    } else {
      t22 = $[5];
    }
    t1 = navItems.map(t22);
    $[3] = navItems;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const items = t1;
  let t2;
  if ($[6] !== hasSections || $[7] !== items) {
    t2 = hasSections ? (0, import_jsx_runtime20.jsx)(import_jsx_runtime20.Fragment, {
      children: items
    }) : (0, import_jsx_runtime20.jsx)(DashboardSection, {
      title: "Content",
      children: (0, import_jsx_runtime20.jsx)(DashboardGrid, {
        children: items
      })
    });
    $[6] = hasSections;
    $[7] = items;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  return t2;
}
var dividerCount = 0;
function renderItemOrGroup(itemOrGroup) {
  if (itemOrGroup.isDivider) {
    return (0, import_jsx_runtime20.jsx)(Flex, {
      gridColumn: FILL_COLS,
      children: (0, import_jsx_runtime20.jsx)(Divider, {
        alignSelf: "center",
        size: "medium",
        width: "alias.singleLineWidth"
      })
    }, dividerCount++);
  }
  if (itemOrGroup.children) {
    return (0, import_jsx_runtime20.jsx)(DashboardSection, {
      title: itemOrGroup.title,
      children: (0, import_jsx_runtime20.jsx)(DashboardGrid, {
        children: itemOrGroup.children.map((child) => renderItemOrGroup(child))
      })
    }, itemOrGroup.title);
  }
  let changeElement = (() => {
    if (!itemOrGroup.changed) {
      return void 0;
    }
    return typeof itemOrGroup.changed === "number" ? (0, import_jsx_runtime20.jsx)(Badge, {
      tone: "accent",
      marginStart: "auto",
      children: pluralize(itemOrGroup.changed, {
        singular: "change",
        plural: "changes"
      })
    }) : (0, import_jsx_runtime20.jsx)(Badge, {
      tone: "accent",
      children: "Changed"
    });
  })();
  let endElement = (() => {
    if (typeof itemOrGroup.entryCount !== "number") {
      return changeElement;
    }
    return (0, import_jsx_runtime20.jsxs)(Flex, {
      gap: "medium",
      alignItems: "center",
      children: [changeElement, (0, import_jsx_runtime20.jsx)(ActionButton, {
        "aria-label": "Add",
        href: `${itemOrGroup.href}/create`,
        children: (0, import_jsx_runtime20.jsx)(Icon, {
          src: plusIcon
        })
      })]
    });
  })();
  return (0, import_jsx_runtime20.jsx)(DashboardCard, {
    label: itemOrGroup.label,
    href: itemOrGroup.href,
    endElement,
    children: typeof itemOrGroup.entryCount === "number" ? (0, import_jsx_runtime20.jsx)(Text, {
      color: "neutralSecondary",
      children: pluralize(itemOrGroup.entryCount, {
        singular: "entry",
        plural: "entries"
      })
    }) : null
  }, itemOrGroup.key);
}
function DashboardPage(props) {
  const $ = c(19);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(strings);
  const viewer = useViewer();
  const cloudInfo = useCloudInfo();
  let t0;
  if ($[0] !== viewer || $[1] !== cloudInfo) {
    var _viewer$name;
    t0 = viewer ? {
      name: (_viewer$name = viewer.name) !== null && _viewer$name !== void 0 ? _viewer$name : viewer.login,
      avatarUrl: viewer.avatarUrl
    } : cloudInfo === null || cloudInfo === void 0 ? void 0 : cloudInfo.user;
    $[0] = viewer;
    $[1] = cloudInfo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const user = t0;
  let t1;
  if ($[3] !== stringFormatter) {
    t1 = stringFormatter.format("dashboard");
    $[3] = stringFormatter;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = (0, import_jsx_runtime20.jsx)(PageHeader, {
      children: (0, import_jsx_runtime20.jsx)(Heading, {
        elementType: "h1",
        id: "page-title",
        size: "small",
        children: t1
      })
    });
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== user || $[8] !== cloudInfo) {
    t3 = user && (0, import_jsx_runtime20.jsx)(UserInfo, {
      user,
      manageAccount: !!cloudInfo
    });
    $[7] = user;
    $[8] = cloudInfo;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== props.config) {
    t4 = !isLocalConfig(props.config) && (0, import_jsx_runtime20.jsx)(BranchSection, {});
    $[10] = props.config;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime20.jsx)(DashboardCards, {});
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== t3 || $[14] !== t4) {
    t6 = (0, import_jsx_runtime20.jsx)(PageBody, {
      isScrollable: true,
      children: (0, import_jsx_runtime20.jsxs)(Flex, {
        direction: "column",
        gap: "xxlarge",
        children: [t3, t4, t5]
      })
    });
    $[13] = t3;
    $[14] = t4;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  let t7;
  if ($[16] !== t2 || $[17] !== t6) {
    t7 = (0, import_jsx_runtime20.jsxs)(PageRoot, {
      containerWidth: "large",
      children: [t2, t6]
    });
    $[16] = t2;
    $[17] = t6;
    $[18] = t7;
  } else {
    t7 = $[18];
  }
  return t7;
}
function UserInfo(t0) {
  const $ = c(15);
  const {
    user,
    manageAccount
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      below: "tablet"
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== user.avatarUrl || $[2] !== user.name) {
    t2 = (0, import_jsx_runtime20.jsx)(Avatar, {
      src: user.avatarUrl,
      name: user.name,
      size: "large"
    });
    $[1] = user.avatarUrl;
    $[2] = user.name;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      fontWeight: tokenSchema.typography.fontWeight.bold
    };
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== user.name) {
    t4 = (0, import_jsx_runtime20.jsxs)(Heading, {
      size: "medium",
      elementType: "p",
      UNSAFE_style: t3,
      children: ["Hello, ", user.name, "!"]
    });
    $[5] = user.name;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== manageAccount) {
    t5 = manageAccount && (0, import_jsx_runtime20.jsx)(TextLink, {
      href: "https://keystatic.cloud/account",
      children: "Manage Account"
    });
    $[7] = manageAccount;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== t4 || $[10] !== t5) {
    t6 = (0, import_jsx_runtime20.jsxs)(VStack, {
      gap: "medium",
      children: [t4, t5]
    });
    $[9] = t4;
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== t2 || $[13] !== t6) {
    t7 = (0, import_jsx_runtime20.jsxs)(Flex, {
      alignItems: "center",
      gap: "medium",
      isHidden: t1,
      children: [t2, t6]
    });
    $[12] = t2;
    $[13] = t6;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  return t7;
}
var MainPanelLayout = (props) => {
  const $ = c(13);
  const isBelowDesktop = useMediaQuery(breakpointQueries$1.below.desktop);
  const sidebarState = useSidebar();
  const ref = (0, import_react8.useRef)(null);
  const context = useContentPanelState(ref);
  const t0 = isBelowDesktop || !sidebarState.isOpen;
  let t1;
  if ($[0] !== isBelowDesktop) {
    t1 = isBelowDesktop ? (0, import_jsx_runtime20.jsx)(SidebarDialog, {}) : (0, import_jsx_runtime20.jsx)(SplitPanePrimary, {
      children: (0, import_jsx_runtime20.jsx)(SidebarPanel, {})
    });
    $[0] = isBelowDesktop;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== ref || $[3] !== props.children) {
    t2 = (0, import_jsx_runtime20.jsx)(SplitPaneSecondary, {
      ref,
      children: props.children
    });
    $[2] = ref;
    $[3] = props.children;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== t0 || $[6] !== sidebarState.toggle || $[7] !== t1 || $[8] !== t2) {
    t3 = (0, import_jsx_runtime20.jsxs)(SplitView, {
      autoSaveId: "keystatic-app-split-view",
      isCollapsed: t0,
      onCollapseChange: sidebarState.toggle,
      defaultSize: 260,
      minSize: 180,
      maxSize: 400,
      height: "100vh",
      children: [t1, t2]
    });
    $[5] = t0;
    $[6] = sidebarState.toggle;
    $[7] = t1;
    $[8] = t2;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== context || $[11] !== t3) {
    t4 = (0, import_jsx_runtime20.jsx)(ContentPanelProvider, {
      value: context,
      children: t3
    });
    $[10] = context;
    $[11] = t3;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  return t4;
};
function BranchNotFound(props) {
  var _appShellDataContext$;
  const $ = c(2);
  const branches = useBranches();
  const currentBranch = useCurrentBranch();
  const appShellDataContext = (0, import_react8.useContext)(GitHubAppShellDataContext);
  if ((appShellDataContext === null || appShellDataContext === void 0 || (_appShellDataContext$ = appShellDataContext.data) === null || _appShellDataContext$ === void 0 || (_appShellDataContext$ = _appShellDataContext$.repository) === null || _appShellDataContext$ === void 0 || (_appShellDataContext$ = _appShellDataContext$.refs) === null || _appShellDataContext$ === void 0 ? void 0 : _appShellDataContext$.pageInfo.hasNextPage) === false && !branches.has(currentBranch)) {
    const t0 = `The branch ${currentBranch} does not exist in this repository.`;
    let t1;
    if ($[0] !== t0) {
      t1 = (0, import_jsx_runtime20.jsx)(EmptyState2, {
        icon: alertCircleIcon,
        title: "Branch not found",
        message: t0
      });
      $[0] = t0;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    return t1;
  }
  return props.children;
}
var AppShell = (props) => {
  const $ = c(19);
  let t0;
  if ($[0] !== props.children) {
    t0 = (0, import_jsx_runtime20.jsx)(AppShellErrorContext.Consumer, {
      children: (error) => error && !(error !== null && error !== void 0 && error.graphQLErrors.some((err) => {
        var _err$originalError;
        return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === "NOT_FOUND";
      })) ? (0, import_jsx_runtime20.jsx)(EmptyState2, {
        icon: alertCircleIcon,
        title: "Failed to load shell",
        message: error.message
      }) : props.children
    });
    $[0] = props.children;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const content = t0;
  let t1;
  if ($[2] !== props.basePath) {
    t1 = {
      basePath: props.basePath
    };
    $[2] = props.basePath;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== content) {
    t2 = (0, import_jsx_runtime20.jsx)(SidebarProvider, {
      children: (0, import_jsx_runtime20.jsx)(MainPanelLayout, {
        children: (0, import_jsx_runtime20.jsx)(BranchNotFound, {
          children: content
        })
      })
    });
    $[4] = content;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== t1 || $[7] !== t2) {
    t3 = (0, import_jsx_runtime20.jsx)(AppStateContext.Provider, {
      value: t1,
      children: t2
    });
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== props.config || $[10] !== t3) {
    t4 = (0, import_jsx_runtime20.jsx)(ConfigContext.Provider, {
      value: props.config,
      children: t3
    });
    $[9] = props.config;
    $[10] = t3;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  const inner = t4;
  if (isGitHubConfig(props.config) || props.config.storage.kind === "cloud") {
    let t5;
    if ($[12] !== props.currentBranch || $[13] !== props.config || $[14] !== inner) {
      t5 = (0, import_jsx_runtime20.jsx)(GitHubAppShellProvider, {
        currentBranch: props.currentBranch,
        config: props.config,
        children: inner
      });
      $[12] = props.currentBranch;
      $[13] = props.config;
      $[14] = inner;
      $[15] = t5;
    } else {
      t5 = $[15];
    }
    return t5;
  }
  if (isLocalConfig(props.config)) {
    let t5;
    if ($[16] !== props.config || $[17] !== inner) {
      t5 = (0, import_jsx_runtime20.jsx)(LocalAppShellProvider, {
        config: props.config,
        children: inner
      });
      $[16] = props.config;
      $[17] = inner;
      $[18] = t5;
    } else {
      t5 = $[18];
    }
    return t5;
  }
  return null;
};
function SingletonPageInner(props) {
  const $ = c(96);
  const isBelowDesktop = useMediaQuery(breakpointQueries$1.below.desktop);
  const repoInfo = useRepoInfo();
  const currentBranch = useCurrentBranch();
  const [forceValidation, setForceValidation] = (0, import_react8.useState)(false);
  const {
    schema: schema2,
    singletonConfig
  } = useSingleton(props.singleton);
  const router = useRouter();
  let t0;
  bb0: {
    if (!singletonConfig.previewUrl) {
      t0 = void 0;
      break bb0;
    }
    let t110;
    if ($[0] !== singletonConfig.previewUrl || $[1] !== currentBranch) {
      t110 = singletonConfig.previewUrl.replace("{branch}", currentBranch);
      $[0] = singletonConfig.previewUrl;
      $[1] = currentBranch;
      $[2] = t110;
    } else {
      t110 = $[2];
    }
    t0 = t110;
  }
  const previewHref = t0;
  let t1;
  if ($[3] !== props.config) {
    t1 = isGitHubConfig(props.config) || isCloudConfig(props.config);
    $[3] = props.config;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const isGitHub = t1;
  let t2;
  let formatInfo;
  if ($[5] !== props.config || $[6] !== props.singleton || $[7] !== props.initialState || $[8] !== isGitHub || $[9] !== repoInfo || $[10] !== currentBranch) {
    var _getPathPrefix, _getPathPrefix2;
    formatInfo = getSingletonFormat(props.config, props.singleton);
    const singletonExists = !!props.initialState;
    const singletonPath = getSingletonPath(props.config, props.singleton);
    t2 = isGitHub && singletonExists && repoInfo ? `${getRepoUrl(repoInfo)}${formatInfo.dataLocation === "index" ? `/tree/${currentBranch}/${(_getPathPrefix = getPathPrefix(props.config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${singletonPath}` : `/blob/${(_getPathPrefix2 = getPathPrefix(props.config.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : ""}${currentBranch}/${singletonPath}${getDataFileExtension(formatInfo)}`}` : void 0;
    $[5] = props.config;
    $[6] = props.singleton;
    $[7] = props.initialState;
    $[8] = isGitHub;
    $[9] = repoInfo;
    $[10] = currentBranch;
    $[11] = t2;
    $[12] = formatInfo;
  } else {
    t2 = $[11];
    formatInfo = $[12];
  }
  const viewHref = t2;
  let t3;
  let t4;
  if ($[13] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      key: "reset",
      label: "Reset",
      icon: historyIcon
    };
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      key: "copy",
      label: "Copy entry",
      icon: clipboardCopyIcon
    };
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  let t6;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = {
      key: "paste",
      label: "Paste entry",
      icon: clipboardPasteIcon
    };
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  let actions;
  if ($[16] !== previewHref || $[17] !== viewHref) {
    actions = [t4, t5, t6];
    if (previewHref) {
      let t72;
      if ($[19] !== previewHref) {
        t72 = {
          key: "preview",
          label: "Preview",
          icon: externalLinkIcon,
          href: previewHref,
          target: "_blank",
          rel: "noopener noreferrer"
        };
        $[19] = previewHref;
        $[20] = t72;
      } else {
        t72 = $[20];
      }
      actions.push(t72);
    }
    if (viewHref) {
      let t72;
      if ($[21] !== viewHref) {
        t72 = {
          key: "view",
          label: "View on GitHub",
          icon: githubIcon,
          href: viewHref,
          target: "_blank",
          rel: "noopener noreferrer"
        };
        $[21] = viewHref;
        $[22] = t72;
      } else {
        t72 = $[22];
      }
      actions.push(t72);
    }
    $[16] = previewHref;
    $[17] = viewHref;
    $[18] = actions;
  } else {
    actions = $[18];
  }
  t3 = actions;
  const menuActions2 = t3;
  const baseCommit = useBaseCommit();
  const isCreating = props.initialState === null;
  let t7;
  if ($[23] !== props || $[24] !== schema2) {
    t7 = async () => {
      if (props.updateResult.kind === "loading" || !props.hasChanged) {
        return;
      }
      if (!clientSideValidateProp(schema2, props.state, void 0)) {
        setForceValidation(true);
        return;
      }
      await props.onUpdate();
    };
    $[23] = props;
    $[24] = schema2;
    $[25] = t7;
  } else {
    t7 = $[25];
  }
  const onCreate = t7;
  let t8;
  if ($[26] !== props.state || $[27] !== formatInfo || $[28] !== singletonConfig.schema) {
    t8 = () => {
      copyEntryToClipboard(props.state, formatInfo, singletonConfig.schema, void 0);
    };
    $[26] = props.state;
    $[27] = formatInfo;
    $[28] = singletonConfig.schema;
    $[29] = t8;
  } else {
    t8 = $[29];
  }
  const onCopy = t8;
  let t9;
  if ($[30] !== formatInfo || $[31] !== singletonConfig.schema || $[32] !== props.previewProps || $[33] !== props.state) {
    t9 = async () => {
      const entry = await getPastedEntry(formatInfo, singletonConfig.schema, void 0);
      if (entry) {
        setValueToPreviewProps(entry, props.previewProps);
        toastQueue.positive("Entry pasted", {
          shouldCloseOnAction: true,
          actionLabel: "Undo",
          onAction: () => {
            setValueToPreviewProps(props.state, props.previewProps);
          }
        });
      }
    };
    $[30] = formatInfo;
    $[31] = singletonConfig.schema;
    $[32] = props.previewProps;
    $[33] = props.state;
    $[34] = t9;
  } else {
    t9 = $[34];
  }
  const onPaste = t9;
  let t10;
  if ($[35] !== singletonConfig) {
    t10 = containerWidthForEntryLayout(singletonConfig);
    $[35] = singletonConfig;
    $[36] = t10;
  } else {
    t10 = $[36];
  }
  let t11;
  if ($[37] !== singletonConfig.label) {
    t11 = (0, import_jsx_runtime20.jsx)(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      children: singletonConfig.label
    });
    $[37] = singletonConfig.label;
    $[38] = t11;
  } else {
    t11 = $[38];
  }
  let t12;
  if ($[39] !== props || $[40] !== singletonConfig) {
    t12 = props.updateResult.kind === "loading" ? (0, import_jsx_runtime20.jsx)(ProgressCircle, {
      "aria-label": `Updating ${singletonConfig.label}`,
      isIndeterminate: true,
      size: "small",
      alignSelf: "center"
    }) : props.hasChanged && (0, import_jsx_runtime20.jsx)(Badge, {
      tone: "pending",
      children: "Unsaved"
    });
    $[39] = props;
    $[40] = singletonConfig;
    $[41] = t12;
  } else {
    t12 = $[41];
  }
  let t13;
  if ($[42] !== t11 || $[43] !== t12) {
    t13 = (0, import_jsx_runtime20.jsxs)(Flex, {
      flex: true,
      alignItems: "center",
      gap: "regular",
      children: [t11, t12]
    });
    $[42] = t11;
    $[43] = t12;
    $[44] = t13;
  } else {
    t13 = $[44];
  }
  let t14;
  if ($[45] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = (0, import_jsx_runtime20.jsx)(PresenceAvatars, {});
    $[45] = t14;
  } else {
    t14 = $[45];
  }
  const t15 = isBelowDesktop ? "element.regular" : void 0;
  let t16;
  if ($[46] !== props.hasChanged) {
    t16 = props.hasChanged ? [] : ["reset"];
    $[46] = props.hasChanged;
    $[47] = t16;
  } else {
    t16 = $[47];
  }
  let t17;
  if ($[48] !== props || $[49] !== onCopy || $[50] !== onPaste) {
    t17 = (key) => {
      bb73: switch (key) {
        case "reset": {
          props.onReset();
          break bb73;
        }
        case "copy": {
          onCopy();
          break bb73;
        }
        case "paste": {
          onPaste();
        }
      }
    };
    $[48] = props;
    $[49] = onCopy;
    $[50] = onPaste;
    $[51] = t17;
  } else {
    t17 = $[51];
  }
  let t18;
  if ($[52] === Symbol.for("react.memo_cache_sentinel")) {
    t18 = (item) => (0, import_jsx_runtime20.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      textValue: item.label,
      href: item.href,
      target: item.target,
      rel: item.rel,
      children: [(0, import_jsx_runtime20.jsx)(Icon, {
        src: item.icon
      }), (0, import_jsx_runtime20.jsx)(Text, {
        children: item.label
      })]
    }, item.key);
    $[52] = t18;
  } else {
    t18 = $[52];
  }
  let t19;
  if ($[53] !== t15 || $[54] !== menuActions2 || $[55] !== t16 || $[56] !== t17) {
    t19 = (0, import_jsx_runtime20.jsx)(_ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: t15,
      items: menuActions2,
      disabledKeys: t16,
      onAction: t17,
      children: t18
    });
    $[53] = t15;
    $[54] = menuActions2;
    $[55] = t16;
    $[56] = t17;
    $[57] = t19;
  } else {
    t19 = $[57];
  }
  const t20 = props.updateResult.kind === "loading";
  const t21 = isCreating ? "Create" : "Save";
  let t22;
  if ($[58] !== t20 || $[59] !== t21) {
    t22 = (0, import_jsx_runtime20.jsx)(Button, {
      form: "singleton-form",
      isDisabled: t20,
      prominence: "high",
      type: "submit",
      children: t21
    });
    $[58] = t20;
    $[59] = t21;
    $[60] = t22;
  } else {
    t22 = $[60];
  }
  let t23;
  if ($[61] !== t13 || $[62] !== t19 || $[63] !== t22) {
    t23 = (0, import_jsx_runtime20.jsxs)(PageHeader, {
      children: [t13, t14, t19, t22]
    });
    $[61] = t13;
    $[62] = t19;
    $[63] = t22;
    $[64] = t23;
  } else {
    t23 = $[64];
  }
  let t24;
  if ($[65] !== onCreate) {
    t24 = (event) => {
      if (event.target !== event.currentTarget) {
        return;
      }
      event.preventDefault();
      onCreate();
    };
    $[65] = onCreate;
    $[66] = t24;
  } else {
    t24 = $[66];
  }
  let t25;
  if ($[67] !== props.updateResult) {
    t25 = props.updateResult.kind === "error" && (0, import_jsx_runtime20.jsx)(Notice, {
      tone: "critical",
      children: props.updateResult.error.message
    });
    $[67] = props.updateResult;
    $[68] = t25;
  } else {
    t25 = $[68];
  }
  const t26 = props.previewProps;
  let t27;
  if ($[69] !== t26 || $[70] !== forceValidation || $[71] !== singletonConfig.entryLayout || $[72] !== formatInfo) {
    t27 = (0, import_jsx_runtime20.jsx)(FormForEntry, {
      previewProps: t26,
      forceValidation,
      entryLayout: singletonConfig.entryLayout,
      formatInfo,
      slugField: void 0
    });
    $[69] = t26;
    $[70] = forceValidation;
    $[71] = singletonConfig.entryLayout;
    $[72] = formatInfo;
    $[73] = t27;
  } else {
    t27 = $[73];
  }
  let t28;
  if ($[74] !== props || $[75] !== router || $[76] !== baseCommit) {
    t28 = props.updateResult.kind === "needs-new-branch" && (0, import_jsx_runtime20.jsx)(CreateBranchDuringUpdateDialog, {
      branchOid: baseCommit,
      onCreate: async (newBranch) => {
        router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/singleton/${encodeURIComponent(props.singleton)}`);
        props.onUpdate({
          branch: newBranch,
          sha: baseCommit
        });
      },
      reason: props.updateResult.reason,
      onDismiss: props.onResetUpdateItem
    });
    $[74] = props;
    $[75] = router;
    $[76] = baseCommit;
    $[77] = t28;
  } else {
    t28 = $[77];
  }
  let t29;
  if ($[78] !== props.onResetUpdateItem || $[79] !== t28) {
    t29 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: props.onResetUpdateItem,
      children: t28
    });
    $[78] = props.onResetUpdateItem;
    $[79] = t28;
    $[80] = t29;
  } else {
    t29 = $[80];
  }
  let t30;
  if ($[81] !== props) {
    t30 = props.updateResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime20.jsx)(ForkRepoDialog, {
      onCreate: async () => {
        props.onUpdate();
      },
      onDismiss: props.onResetUpdateItem,
      config: props.config
    });
    $[81] = props;
    $[82] = t30;
  } else {
    t30 = $[82];
  }
  let t31;
  if ($[83] !== props.onResetUpdateItem || $[84] !== t30) {
    t31 = (0, import_jsx_runtime20.jsx)(DialogContainer, {
      onDismiss: props.onResetUpdateItem,
      children: t30
    });
    $[83] = props.onResetUpdateItem;
    $[84] = t30;
    $[85] = t31;
  } else {
    t31 = $[85];
  }
  let t32;
  if ($[86] !== t24 || $[87] !== t25 || $[88] !== t27 || $[89] !== t29 || $[90] !== t31) {
    t32 = (0, import_jsx_runtime20.jsxs)(Flex, {
      elementType: "form",
      id: "singleton-form",
      onSubmit: t24,
      direction: "column",
      gap: "xxlarge",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children: [t25, t27, t29, t31]
    });
    $[86] = t24;
    $[87] = t25;
    $[88] = t27;
    $[89] = t29;
    $[90] = t31;
    $[91] = t32;
  } else {
    t32 = $[91];
  }
  let t33;
  if ($[92] !== t10 || $[93] !== t23 || $[94] !== t32) {
    t33 = (0, import_jsx_runtime20.jsxs)(PageRoot, {
      containerWidth: t10,
      children: [t23, t32]
    });
    $[92] = t10;
    $[93] = t23;
    $[94] = t32;
    $[95] = t33;
  } else {
    t33 = $[95];
  }
  return t33;
}
function LocalSingletonPage(props) {
  const $ = c(49);
  const {
    singleton,
    initialFiles,
    initialState,
    localTreeKey,
    config,
    draft
  } = props;
  const {
    schema: schema2,
    singletonConfig
  } = useSingleton(props.singleton);
  let t0;
  if ($[0] !== config || $[1] !== singleton) {
    t0 = getSingletonPath(config, singleton);
    $[0] = config;
    $[1] = singleton;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const singletonPath = t0;
  let t1;
  if ($[3] !== localTreeKey || $[4] !== draft || $[5] !== initialState || $[6] !== schema2) {
    t1 = () => {
      var _draft$state;
      return {
        localTreeKey,
        state: (_draft$state = draft === null || draft === void 0 ? void 0 : draft.state) !== null && _draft$state !== void 0 ? _draft$state : initialState === null ? getInitialPropsValue(schema2) : initialState
      };
    };
    $[3] = localTreeKey;
    $[4] = draft;
    $[5] = initialState;
    $[6] = schema2;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const [t2, setState] = (0, import_react8.useState)(t1);
  const {
    state,
    localTreeKey: localTreeKeyInState
  } = t2;
  useShowRestoredDraftMessage(draft, state, localTreeKey);
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      localTreeKey,
      state: initialState === null ? getInitialPropsValue(schema2) : initialState
    });
  }
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema: schema2,
    slugField: void 0
  }) || isCreating;
  let t3;
  if ($[8] !== singleton || $[9] !== hasChanged || $[10] !== singletonPath || $[11] !== config || $[12] !== singletonConfig.schema || $[13] !== state || $[14] !== localTreeKey) {
    t3 = () => {
      const key = ["singleton", singleton];
      if (hasChanged) {
        const serialized = serializeEntryToFiles({
          basePath: singletonPath,
          format: getSingletonFormat(config, singleton),
          schema: singletonConfig.schema,
          slug: void 0,
          state
        });
        const files = new Map(serialized.map((x2) => [x2.path, x2.contents]));
        const data = {
          beforeTreeKey: localTreeKey,
          files,
          savedAt: /* @__PURE__ */ new Date(),
          version: 1
        };
        setDraft(key, data);
      } else {
        delDraft(key);
      }
    };
    $[8] = singleton;
    $[9] = hasChanged;
    $[10] = singletonPath;
    $[11] = config;
    $[12] = singletonConfig.schema;
    $[13] = state;
    $[14] = localTreeKey;
    $[15] = t3;
  } else {
    t3 = $[15];
  }
  let t4;
  if ($[16] !== config || $[17] !== localTreeKey || $[18] !== state || $[19] !== hasChanged || $[20] !== singleton || $[21] !== singletonPath || $[22] !== singletonConfig) {
    t4 = [config, localTreeKey, state, hasChanged, singleton, singletonPath, singletonConfig];
    $[16] = config;
    $[17] = localTreeKey;
    $[18] = state;
    $[19] = hasChanged;
    $[20] = singleton;
    $[21] = singletonPath;
    $[22] = singletonConfig;
    $[23] = t4;
  } else {
    t4 = $[23];
  }
  (0, import_react8.useEffect)(t3, t4);
  let t5;
  if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (cb) => {
      setState((state_0) => ({
        localTreeKey: state_0.localTreeKey,
        state: cb(state_0.state)
      }));
    };
    $[24] = t5;
  } else {
    t5 = $[24];
  }
  const onPreviewPropsChange = t5;
  const previewProps = usePreviewProps(schema2, onPreviewPropsChange, state);
  let t6;
  if ($[25] !== config || $[26] !== singleton) {
    t6 = getSingletonFormat(config, singleton);
    $[25] = config;
    $[26] = singleton;
    $[27] = t6;
  } else {
    t6 = $[27];
  }
  const formatInfo = t6;
  let t7;
  if ($[28] !== state || $[29] !== initialFiles || $[30] !== config || $[31] !== singletonConfig.schema || $[32] !== singletonPath || $[33] !== formatInfo || $[34] !== localTreeKey) {
    t7 = {
      state,
      initialFiles,
      config,
      schema: singletonConfig.schema,
      basePath: singletonPath,
      format: formatInfo,
      currentLocalTreeKey: localTreeKey,
      slug: void 0
    };
    $[28] = state;
    $[29] = initialFiles;
    $[30] = config;
    $[31] = singletonConfig.schema;
    $[32] = singletonPath;
    $[33] = formatInfo;
    $[34] = localTreeKey;
    $[35] = t7;
  } else {
    t7 = $[35];
  }
  const [updateResult, _update, resetUpdateItem] = useUpsertItem(t7);
  const update = useEventCallback(_update);
  let t8;
  if ($[36] !== localTreeKey || $[37] !== initialState || $[38] !== schema2) {
    t8 = () => setState({
      localTreeKey,
      state: initialState === null ? getInitialPropsValue(schema2) : initialState
    });
    $[36] = localTreeKey;
    $[37] = initialState;
    $[38] = schema2;
    $[39] = t8;
  } else {
    t8 = $[39];
  }
  const onReset = t8;
  let t9;
  if ($[40] !== props || $[41] !== hasChanged || $[42] !== onReset || $[43] !== update || $[44] !== resetUpdateItem || $[45] !== updateResult || $[46] !== state || $[47] !== previewProps) {
    t9 = (0, import_jsx_runtime20.jsx)(SingletonPageInner, {
      ...props,
      hasChanged,
      onReset,
      onUpdate: update,
      onResetUpdateItem: resetUpdateItem,
      updateResult,
      state,
      previewProps
    });
    $[40] = props;
    $[41] = hasChanged;
    $[42] = onReset;
    $[43] = update;
    $[44] = resetUpdateItem;
    $[45] = updateResult;
    $[46] = state;
    $[47] = previewProps;
    $[48] = t9;
  } else {
    t9 = $[48];
  }
  return t9;
}
function CollabSingletonPage(props) {
  const $ = c(27);
  const {
    singleton,
    initialFiles,
    initialState,
    localTreeKey,
    config
  } = props;
  const {
    schema: schema2,
    singletonConfig
  } = useSingleton(props.singleton);
  let t0;
  if ($[0] !== config || $[1] !== singleton) {
    t0 = getSingletonPath(config, singleton);
    $[0] = config;
    $[1] = singleton;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const singletonPath = t0;
  const state = useYJsValue(schema2, props.map);
  const previewProps = usePreviewPropsFromY(schema2, props.map, state);
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema: schema2,
    slugField: void 0
  }) || isCreating;
  let t1;
  if ($[3] !== config || $[4] !== singleton) {
    t1 = getSingletonFormat(config, singleton);
    $[3] = config;
    $[4] = singleton;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const formatInfo = t1;
  let t2;
  if ($[6] !== state || $[7] !== initialFiles || $[8] !== config || $[9] !== singletonConfig.schema || $[10] !== singletonPath || $[11] !== formatInfo || $[12] !== localTreeKey) {
    t2 = {
      state,
      initialFiles,
      config,
      schema: singletonConfig.schema,
      basePath: singletonPath,
      format: formatInfo,
      currentLocalTreeKey: localTreeKey,
      slug: void 0
    };
    $[6] = state;
    $[7] = initialFiles;
    $[8] = config;
    $[9] = singletonConfig.schema;
    $[10] = singletonPath;
    $[11] = formatInfo;
    $[12] = localTreeKey;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  const [updateResult, _update, resetUpdateItem] = useUpsertItem(t2);
  const update = useEventCallback(_update);
  let t3;
  if ($[14] !== props.map || $[15] !== props.initialState || $[16] !== singletonConfig.schema) {
    t3 = () => {
      props.map.doc.transact(() => {
        for (const [key, value] of Object.entries(singletonConfig.schema)) {
          var _props$initialState$k, _props$initialState;
          const val = getYjsValFromParsedValue(value, (_props$initialState$k = (_props$initialState = props.initialState) === null || _props$initialState === void 0 ? void 0 : _props$initialState[key]) !== null && _props$initialState$k !== void 0 ? _props$initialState$k : getInitialPropsValue(value));
          props.map.set(key, val);
        }
      });
    };
    $[14] = props.map;
    $[15] = props.initialState;
    $[16] = singletonConfig.schema;
    $[17] = t3;
  } else {
    t3 = $[17];
  }
  const onReset = t3;
  let t4;
  if ($[18] !== props || $[19] !== hasChanged || $[20] !== onReset || $[21] !== update || $[22] !== resetUpdateItem || $[23] !== updateResult || $[24] !== state || $[25] !== previewProps) {
    t4 = (0, import_jsx_runtime20.jsx)(SingletonPageInner, {
      ...props,
      hasChanged,
      onReset,
      onUpdate: update,
      onResetUpdateItem: resetUpdateItem,
      updateResult,
      state,
      previewProps
    });
    $[18] = props;
    $[19] = hasChanged;
    $[20] = onReset;
    $[21] = update;
    $[22] = resetUpdateItem;
    $[23] = updateResult;
    $[24] = state;
    $[25] = previewProps;
    $[26] = t4;
  } else {
    t4 = $[26];
  }
  return t4;
}
var storedValSchema = type({
  version: literal(1),
  savedAt: date(),
  beforeTreeKey: optional(string()),
  files: map(string(), instance(Uint8Array))
});
function SingletonPageWrapper(props) {
  var _props$config$singlet;
  const $ = c(55);
  const singletonConfig = (_props$config$singlet = props.config.singletons) === null || _props$config$singlet === void 0 ? void 0 : _props$config$singlet[props.singleton];
  if (!singletonConfig) {
    notFound();
  }
  let t0;
  if ($[0] !== singletonConfig.label) {
    t0 = (0, import_jsx_runtime20.jsx)(PageHeader, {
      children: (0, import_jsx_runtime20.jsx)(Heading, {
        elementType: "h1",
        id: "page-title",
        size: "small",
        children: singletonConfig.label
      })
    });
    $[0] = singletonConfig.label;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const header = t0;
  let t1;
  let t2;
  if ($[2] !== props.config || $[3] !== props.singleton) {
    t2 = getSingletonFormat(props.config, props.singleton);
    $[2] = props.config;
    $[3] = props.singleton;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  t1 = t2;
  const format = t1;
  let t3;
  if ($[5] !== props.config || $[6] !== props.singleton) {
    t3 = getSingletonPath(props.config, props.singleton);
    $[5] = props.config;
    $[6] = props.singleton;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  const dirpath = t3;
  let t4;
  if ($[8] !== props.singleton || $[9] !== dirpath || $[10] !== format || $[11] !== singletonConfig.schema) {
    t4 = async () => {
      const raw = await getDraft(["singleton", props.singleton]);
      if (!raw) {
        throw new Error("No draft found");
      }
      const stored = storedValSchema.create(raw);
      const parsed = parseEntry({
        dirpath,
        format,
        schema: singletonConfig.schema,
        slug: void 0
      }, stored.files);
      return {
        state: parsed.initialState,
        savedAt: stored.savedAt,
        treeKey: stored.beforeTreeKey
      };
    };
    $[8] = props.singleton;
    $[9] = dirpath;
    $[10] = format;
    $[11] = singletonConfig.schema;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  const draftData = useData(t4);
  let t5;
  if ($[13] !== props.config || $[14] !== dirpath || $[15] !== singletonConfig.schema || $[16] !== format) {
    t5 = {
      config: props.config,
      dirpath,
      schema: singletonConfig.schema,
      format,
      slug: void 0
    };
    $[13] = props.config;
    $[14] = dirpath;
    $[15] = singletonConfig.schema;
    $[16] = format;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  const itemData = useItemData(t5);
  const currentBranch = useCurrentBranch();
  const key = `${currentBranch}/${props.singleton}`;
  const yjsInfo = useYjsIfAvailable();
  const isItemDataLoading = itemData.kind === "loading";
  let t6;
  if ($[18] !== yjsInfo || $[19] !== isItemDataLoading || $[20] !== key) {
    t6 = async () => {
      if (!yjsInfo) {
        return;
      }
      if (yjsInfo === "loading") {
        return LOADING;
      }
      await yjsInfo.doc.whenSynced;
      if (isItemDataLoading) {
        return LOADING;
      }
      let doc = yjsInfo.data.get(key);
      if (doc instanceof Doc) {
        const promise = doc.whenLoaded;
        doc.load();
        await promise;
      } else {
        doc = new Doc();
        yjsInfo.data.set(key, doc);
      }
      return doc.getMap("data");
    };
    $[18] = yjsInfo;
    $[19] = isItemDataLoading;
    $[20] = key;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  const mapData = useData(t6);
  bb0: {
    if (mapData.kind !== "loaded" || itemData.kind !== "loaded" || !mapData.data || mapData.data.size) {
      break bb0;
    }
    const data = mapData.data;
    data.doc.transact(() => {
      for (const [key_0, value] of Object.entries(singletonConfig.schema)) {
        const val = getYjsValFromParsedValue(value, itemData.data === "not-found" ? getInitialPropsValue(value) : itemData.data.initialState[key_0]);
        data.set(key_0, val);
      }
    });
  }
  if (itemData.kind === "error") {
    let t82;
    if ($[22] !== itemData.error.message) {
      t82 = (0, import_jsx_runtime20.jsx)(PageBody, {
        children: (0, import_jsx_runtime20.jsx)(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: itemData.error.message
        })
      });
      $[22] = itemData.error.message;
      $[23] = t82;
    } else {
      t82 = $[23];
    }
    let t92;
    if ($[24] !== header || $[25] !== t82) {
      t92 = (0, import_jsx_runtime20.jsxs)(PageRoot, {
        children: [header, t82]
      });
      $[24] = header;
      $[25] = t82;
      $[26] = t92;
    } else {
      t92 = $[26];
    }
    return t92;
  }
  if (mapData.kind === "error") {
    let t82;
    if ($[27] !== mapData.error.message) {
      t82 = (0, import_jsx_runtime20.jsx)(PageBody, {
        children: (0, import_jsx_runtime20.jsx)(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: mapData.error.message
        })
      });
      $[27] = mapData.error.message;
      $[28] = t82;
    } else {
      t82 = $[28];
    }
    let t92;
    if ($[29] !== header || $[30] !== t82) {
      t92 = (0, import_jsx_runtime20.jsxs)(PageRoot, {
        children: [header, t82]
      });
      $[29] = header;
      $[30] = t82;
      $[31] = t92;
    } else {
      t92 = $[31];
    }
    return t92;
  }
  if (itemData.kind === "loading" || draftData.kind === "loading" || mapData.kind === "loading") {
    const t82 = `Loading ${singletonConfig.label}`;
    let t92;
    if ($[32] !== t82) {
      t92 = (0, import_jsx_runtime20.jsx)(PageBody, {
        children: (0, import_jsx_runtime20.jsx)(Flex, {
          alignItems: "center",
          justifyContent: "center",
          minHeight: "scale.3000",
          children: (0, import_jsx_runtime20.jsx)(ProgressCircle, {
            "aria-label": t82,
            isIndeterminate: true,
            size: "large"
          })
        })
      });
      $[32] = t82;
      $[33] = t92;
    } else {
      t92 = $[33];
    }
    let t102;
    if ($[34] !== header || $[35] !== t92) {
      t102 = (0, import_jsx_runtime20.jsxs)(PageRoot, {
        children: [header, t92]
      });
      $[34] = header;
      $[35] = t92;
      $[36] = t102;
    } else {
      t102 = $[36];
    }
    return t102;
  }
  if (mapData.data) {
    const t82 = itemData.data === "not-found" ? null : itemData.data.initialState;
    let t92;
    if ($[37] !== itemData.data) {
      t92 = itemData.data === "not-found" ? [] : itemData.data.initialFiles;
      $[37] = itemData.data;
      $[38] = t92;
    } else {
      t92 = $[38];
    }
    const t102 = itemData.data === "not-found" ? void 0 : itemData.data.localTreeKey;
    let t112;
    if ($[39] !== props.singleton || $[40] !== props.config || $[41] !== t82 || $[42] !== t92 || $[43] !== t102 || $[44] !== mapData.data) {
      t112 = (0, import_jsx_runtime20.jsx)(CollabSingletonPage, {
        singleton: props.singleton,
        config: props.config,
        initialState: t82,
        initialFiles: t92,
        localTreeKey: t102,
        map: mapData.data
      });
      $[39] = props.singleton;
      $[40] = props.config;
      $[41] = t82;
      $[42] = t92;
      $[43] = t102;
      $[44] = mapData.data;
      $[45] = t112;
    } else {
      t112 = $[45];
    }
    return t112;
  }
  const t8 = itemData.data === "not-found" ? null : itemData.data.initialState;
  let t9;
  if ($[46] !== itemData.data) {
    t9 = itemData.data === "not-found" ? [] : itemData.data.initialFiles;
    $[46] = itemData.data;
    $[47] = t9;
  } else {
    t9 = $[47];
  }
  const t10 = itemData.data === "not-found" ? void 0 : itemData.data.localTreeKey;
  const t11 = draftData.kind === "loaded" ? draftData.data : void 0;
  let t12;
  if ($[48] !== props.singleton || $[49] !== props.config || $[50] !== t8 || $[51] !== t9 || $[52] !== t10 || $[53] !== t11) {
    t12 = (0, import_jsx_runtime20.jsx)(LocalSingletonPage, {
      singleton: props.singleton,
      config: props.config,
      initialState: t8,
      initialFiles: t9,
      localTreeKey: t10,
      draft: t11
    });
    $[48] = props.singleton;
    $[49] = props.config;
    $[50] = t8;
    $[51] = t9;
    $[52] = t10;
    $[53] = t11;
    $[54] = t12;
  } else {
    t12 = $[54];
  }
  return t12;
}
function CreatedGitHubApp(props) {
  const $ = c(11);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (0, import_jsx_runtime20.jsx)(Heading, {
      children: "You've installed Keystatic! 🎉"
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (0, import_jsx_runtime20.jsx)(Text, {
      children: "To start using Keystatic, you need to install the GitHub app you've created."
    });
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== props.config.storage.repo) {
    t2 = serializeRepoConfig(props.config.storage.repo);
    $[2] = props.config.storage.repo;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t2) {
    t3 = (0, import_jsx_runtime20.jsxs)(Text, {
      children: ["Make sure to add the App to the", " ", (0, import_jsx_runtime20.jsx)("code", {
        children: t2
      }), " ", "repository."]
    });
    $[4] = t2;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== props.config) {
    t4 = (0, import_jsx_runtime20.jsx)(InstallGitHubApp, {
      config: props.config
    });
    $[6] = props.config;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t3 || $[9] !== t4) {
    t5 = (0, import_jsx_runtime20.jsx)(Flex, {
      alignItems: "center",
      justifyContent: "center",
      margin: "xxlarge",
      children: (0, import_jsx_runtime20.jsxs)(Flex, {
        backgroundColor: "surface",
        padding: "large",
        border: "color.alias.borderIdle",
        borderRadius: "medium",
        direction: "column",
        justifyContent: "center",
        gap: "xlarge",
        maxWidth: "scale.4600",
        children: [t0, t1, t3, t4]
      })
    });
    $[8] = t3;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}
function KeystaticSetup(props) {
  const $ = c(22);
  const [deployedURL, setDeployedURL] = (0, import_react8.useState)("");
  const [organization, setOrganization] = (0, import_react8.useState)("");
  const t0 = `https://github.com${organization ? `/organizations/${organization}` : ""}/settings/apps/new`;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (0, import_jsx_runtime20.jsx)(Flex, {
      justifyContent: "center",
      children: (0, import_jsx_runtime20.jsx)(Heading, {
        children: "Keystatic Setup"
      })
    });
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime20.jsx)(Text, {
      children: "Keystatic doesn't have the required config."
    });
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime20.jsx)(Text, {
      children: "If you've already created your GitHub app, make sure to add the following environment variables:"
    });
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  let t4;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (0, import_jsx_runtime20.jsxs)(Box, {
      elementType: "ul",
      children: [(0, import_jsx_runtime20.jsx)("li", {
        children: (0, import_jsx_runtime20.jsx)("code", {
          children: "KEYSTATIC_GITHUB_CLIENT_ID"
        })
      }), (0, import_jsx_runtime20.jsx)("li", {
        children: (0, import_jsx_runtime20.jsx)("code", {
          children: "KEYSTATIC_GITHUB_CLIENT_SECRET"
        })
      }), (0, import_jsx_runtime20.jsx)("li", {
        children: (0, import_jsx_runtime20.jsx)("code", {
          children: "KEYSTATIC_SECRET"
        })
      })]
    });
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime20.jsx)(Text, {
      children: "If you haven't created your GitHub app for Keystatic, you can create one below."
    });
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  let t6;
  if ($[5] !== deployedURL) {
    t6 = (0, import_jsx_runtime20.jsx)(TextField, {
      label: "Deployed App URL",
      description: "This should the root of your domain. If you're not sure where Keystatic will be deployed, leave this blank and you can update the GitHub app later.",
      value: deployedURL,
      onChange: setDeployedURL
    });
    $[5] = deployedURL;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  let t7;
  if ($[7] !== organization) {
    t7 = (0, import_jsx_runtime20.jsx)(TextField, {
      label: "GitHub organization (if any)",
      description: "You must be an owner or GitHub App manager in the organization to create the GitHub App. Leave this blank to create the app in your personal account.",
      value: organization,
      onChange: setOrganization
    });
    $[7] = organization;
    $[8] = t7;
  } else {
    t7 = $[8];
  }
  let t8;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime20.jsxs)(Text, {
      children: ["After visiting GitHub to create the GitHub app, you'll be redirected back here and secrets generated from GitHub will be written to your", " ", (0, import_jsx_runtime20.jsx)("code", {
        children: ".env"
      }), " file."]
    });
    $[9] = t8;
  } else {
    t8 = $[9];
  }
  let t9;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = css({
      display: "none"
    });
    $[10] = t9;
  } else {
    t9 = $[10];
  }
  let t10;
  if ($[11] !== props.config.storage.repo || $[12] !== deployedURL) {
    t10 = JSON.stringify({
      name: `${parseRepoConfig(props.config.storage.repo).owner} Keystatic`,
      url: deployedURL ? `${deployedURL}/keystatic` : `${window.location.origin}/keystatic`,
      public: true,
      redirect_url: `${window.location.origin}/api/keystatic/github/created-app`,
      callback_urls: [`${window.location.origin}/api/keystatic/github/oauth/callback`, `http://127.0.0.1/api/keystatic/github/oauth/callback`, ...deployedURL ? [`${deployedURL}/api/keystatic/github/oauth/callback`] : []],
      request_oauth_on_install: true,
      default_permissions: {
        contents: "write",
        metadata: "read",
        pull_requests: "read"
      }
    });
    $[11] = props.config.storage.repo;
    $[12] = deployedURL;
    $[13] = t10;
  } else {
    t10 = $[13];
  }
  let t11;
  if ($[14] !== t10) {
    t11 = (0, import_jsx_runtime20.jsx)("input", {
      type: "text",
      name: "manifest",
      className: t9,
      value: t10
    });
    $[14] = t10;
    $[15] = t11;
  } else {
    t11 = $[15];
  }
  let t12;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = (0, import_jsx_runtime20.jsx)(Button, {
      prominence: "high",
      type: "submit",
      children: "Create GitHub App"
    });
    $[16] = t12;
  } else {
    t12 = $[16];
  }
  let t13;
  if ($[17] !== t0 || $[18] !== t6 || $[19] !== t7 || $[20] !== t11) {
    t13 = (0, import_jsx_runtime20.jsx)(Flex, {
      alignItems: "center",
      justifyContent: "center",
      margin: "xxlarge",
      children: (0, import_jsx_runtime20.jsxs)(Flex, {
        backgroundColor: "surface",
        padding: "large",
        border: "color.alias.borderIdle",
        borderRadius: "medium",
        direction: "column",
        justifyContent: "center",
        gap: "xlarge",
        maxWidth: "scale.4600",
        elementType: "form",
        action: t0,
        method: "post",
        children: [t1, t2, t3, t4, t5, t6, t7, t8, t11, t12]
      })
    });
    $[17] = t0;
    $[18] = t6;
    $[19] = t7;
    $[20] = t11;
    $[21] = t13;
  } else {
    t13 = $[21];
  }
  return t13;
}
function RepoNotFound(props) {
  const $ = c(11);
  let t0;
  if ($[0] !== props.config.storage.repo) {
    t0 = serializeRepoConfig(props.config.storage.repo);
    $[0] = props.config.storage.repo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const repo = t0;
  let t1;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (0, import_jsx_runtime20.jsx)(Flex, {
      justifyContent: "center",
      children: (0, import_jsx_runtime20.jsx)(Heading, {
        children: "Repo not found"
      })
    });
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const t2 = `https://github.com/${repo}`;
  let t3;
  if ($[3] !== t2 || $[4] !== repo) {
    t3 = (0, import_jsx_runtime20.jsxs)(Text, {
      children: ["Keystatic is configured for the", " ", (0, import_jsx_runtime20.jsx)("a", {
        href: t2,
        children: repo
      }), " GitHub repo but Keystatic isn't able to access this repo. This is either because you don't have access to this repo or you haven't added the GitHub app to it."]
    });
    $[3] = t2;
    $[4] = repo;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== props.config) {
    t4 = (0, import_jsx_runtime20.jsx)(InstallGitHubApp, {
      config: props.config
    });
    $[6] = props.config;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t3 || $[9] !== t4) {
    t5 = (0, import_jsx_runtime20.jsx)(Flex, {
      alignItems: "center",
      justifyContent: "center",
      margin: "xxlarge",
      children: (0, import_jsx_runtime20.jsxs)(Flex, {
        backgroundColor: "surface",
        padding: "large",
        border: "color.alias.borderIdle",
        borderRadius: "medium",
        direction: "column",
        justifyContent: "center",
        gap: "xlarge",
        maxWidth: "scale.4600",
        children: [t1, t3, t4]
      })
    });
    $[8] = t3;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}
var storedStateSchema = object({
  state: string(),
  from: string(),
  code_verifier: string()
});
var tokenResponseSchema = type({
  access_token: string(),
  token_type: string(),
  expires_in: number()
});
function KeystaticCloudAuthCallback({
  config
}) {
  var _config$cloud2;
  const router = useRouter();
  const url = new URL(window.location.href);
  const code = url.searchParams.get("code");
  const state = url.searchParams.get("state");
  const storedState_0 = (0, import_react8.useMemo)(() => {
    const _storedState = localStorage.getItem("keystatic-cloud-state");
    const storedState = (() => {
      try {
        return storedStateSchema.create(JSON.parse(_storedState || ""));
      } catch {
        return null;
      }
    })();
    return storedState;
  }, []);
  const [error, setError] = (0, import_react8.useState)(null);
  (0, import_react8.useEffect)(() => {
    var _config$cloud;
    if (code && state && storedState_0 && (_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
      const {
        project
      } = config.cloud;
      (async () => {
        const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/oauth/token`, {
          method: "POST",
          body: new URLSearchParams({
            code,
            client_id: project,
            redirect_uri: `${window.location.origin}/keystatic/cloud/oauth/callback`,
            code_verifier: storedState_0.code_verifier,
            grant_type: "authorization_code"
          }).toString(),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            ...KEYSTATIC_CLOUD_HEADERS
          }
        });
        if (!res.ok) {
          throw new Error(`Bad response: ${res.status} ${res.statusText}

${await res.text()}`);
        }
        const data = await res.json();
        const parsed = tokenResponseSchema.create(data);
        localStorage.setItem("keystatic-cloud-access-token", JSON.stringify({
          token: parsed.access_token,
          project,
          validUntil: Date.now() + parsed.expires_in * 1e3
        }));
        router.push(`/keystatic/${storedState_0.from}`);
      })().catch((error_0) => {
        setError(error_0);
      });
    }
  }, [code, state, router, storedState_0, config]);
  if (!((_config$cloud2 = config.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project)) {
    return (0, import_jsx_runtime20.jsx)(Text, {
      children: "Missing Keystatic Cloud config"
    });
  }
  if (!code || !state) {
    return (0, import_jsx_runtime20.jsx)(Text, {
      children: "Missing code or state"
    });
  }
  if (!storedState_0 || state !== storedState_0.state) {
    return (0, import_jsx_runtime20.jsx)(Text, {
      children: "Invalid state"
    });
  }
  if (error) {
    return (0, import_jsx_runtime20.jsx)(Text, {
      children: error.message
    });
  }
  return (0, import_jsx_runtime20.jsx)(Flex, {
    justifyContent: "center",
    alignItems: "center",
    height: "100vh",
    children: (0, import_jsx_runtime20.jsx)(ProgressCircle, {
      size: "large",
      isIndeterminate: true,
      "aria-label": "Authenticating"
    })
  });
}
function parseParamsWithoutBranch(params) {
  if (params.length === 0) {
    return {};
  }
  if (params.length === 2 && params[0] === "singleton") {
    return {
      singleton: params[1]
    };
  }
  if (params.length < 2 || params[0] !== "collection") return null;
  const collection = params[1];
  if (params.length === 2) {
    return {
      collection
    };
  }
  if (params.length === 3 && params[2] === "create") {
    return {
      collection,
      kind: "create"
    };
  }
  if (params.length === 4 && params[2] === "item") {
    const slug = params[3];
    return {
      collection,
      kind: "edit",
      slug
    };
  }
  return null;
}
function RedirectToBranch(props) {
  const $ = c(6);
  const {
    push
  } = useRouter();
  const {
    data,
    error
  } = (0, import_react8.useContext)(GitHubAppShellDataContext);
  let t0;
  let t1;
  if ($[0] !== error || $[1] !== props.config || $[2] !== data || $[3] !== push) {
    t0 = () => {
      var _error$response, _data$repository, _data$repository2, _error$graphQLErrors, _error$graphQLErrors2;
      if ((error === null || error === void 0 || (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
        if (props.config.storage.kind === "github") {
          window.location.href = "/api/keystatic/github/login";
        } else {
          redirectToCloudAuth("", props.config);
        }
      }
      if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && _data$repository.defaultBranchRef) {
        push(`/keystatic/branch/${encodeURIComponent(data.repository.defaultBranchRef.name)}`);
      }
      if (props.config.storage.kind === "github" && !(data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && _data$repository2.id) && (error === null || error === void 0 || (_error$graphQLErrors = error.graphQLErrors) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors[0]) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors.originalError) === null || _error$graphQLErrors === void 0 ? void 0 : _error$graphQLErrors.type) === "NOT_FOUND" || (error === null || error === void 0 || (_error$graphQLErrors2 = error.graphQLErrors) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2[0]) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2.originalError) === null || _error$graphQLErrors2 === void 0 ? void 0 : _error$graphQLErrors2.type) === "FORBIDDEN") {
        window.location.href = "/api/keystatic/github/repo-not-found";
      }
    };
    t1 = [data, error, push, props.config];
    $[0] = error;
    $[1] = props.config;
    $[2] = data;
    $[3] = push;
    $[4] = t0;
    $[5] = t1;
  } else {
    t0 = $[4];
    t1 = $[5];
  }
  (0, import_react8.useEffect)(t0, t1);
  return null;
}
function PageInner(t0) {
  var _config$cloud;
  const $ = c(37);
  const {
    config
  } = t0;
  const {
    params
  } = useRouter();
  let branch = null;
  let parsedParams;
  let basePath;
  if (params.join("/") === "cloud/oauth/callback") {
    let t12;
    if ($[0] !== config) {
      t12 = (0, import_jsx_runtime20.jsx)(KeystaticCloudAuthCallback, {
        config
      });
      $[0] = config;
      $[1] = t12;
    } else {
      t12 = $[1];
    }
    return t12;
  }
  let t1;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (x2) => x2;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let wrapper = t1;
  if (isCloudConfig(config) || isLocalConfig(config) && (_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
    let t22;
    if ($[3] !== config) {
      t22 = (element) => (0, import_jsx_runtime20.jsx)(CloudInfoProvider, {
        config,
        children: element
      });
      $[3] = config;
      $[4] = t22;
    } else {
      t22 = $[4];
    }
    wrapper = t22;
  }
  if (isGitHubConfig(config) || isCloudConfig(config)) {
    const origWrapper = wrapper;
    let t22;
    if ($[5] !== config || $[6] !== origWrapper) {
      t22 = (element_0) => (0, import_jsx_runtime20.jsx)(AuthWrapper, {
        config,
        children: (0, import_jsx_runtime20.jsx)(GitHubAppShellDataProvider, {
          config,
          children: origWrapper(element_0)
        })
      });
      $[5] = config;
      $[6] = origWrapper;
      $[7] = t22;
    } else {
      t22 = $[7];
    }
    wrapper = t22;
    if (params.length === 0) {
      let t33;
      if ($[8] !== config) {
        t33 = (0, import_jsx_runtime20.jsx)(RedirectToBranch, {
          config
        });
        $[8] = config;
        $[9] = t33;
      } else {
        t33 = $[9];
      }
      let t42;
      if ($[10] !== wrapper || $[11] !== t33) {
        t42 = wrapper(t33);
        $[10] = wrapper;
        $[11] = t33;
        $[12] = t42;
      } else {
        t42 = $[12];
      }
      return t42;
    }
    if (params.length === 1 && isGitHubConfig(config)) {
      if (params[0] === "setup") {
        let t33;
        if ($[13] !== config) {
          t33 = (0, import_jsx_runtime20.jsx)(KeystaticSetup, {
            config
          });
          $[13] = config;
          $[14] = t33;
        } else {
          t33 = $[14];
        }
        return t33;
      }
      if (params[0] === "repo-not-found") {
        let t33;
        if ($[15] !== config) {
          t33 = (0, import_jsx_runtime20.jsx)(RepoNotFound, {
            config
          });
          $[15] = config;
          $[16] = t33;
        } else {
          t33 = $[16];
        }
        return t33;
      }
      if (params[0] === "created-github-app") {
        let t33;
        if ($[17] !== config) {
          t33 = (0, import_jsx_runtime20.jsx)(CreatedGitHubApp, {
            config
          });
          $[17] = config;
          $[18] = t33;
        } else {
          t33 = $[18];
        }
        return t33;
      }
    }
    if (params[0] !== "branch" || params.length < 2) {
      let t33;
      if ($[19] === Symbol.for("react.memo_cache_sentinel")) {
        t33 = (0, import_jsx_runtime20.jsx)(Text, {
          children: "Not found"
        });
        $[19] = t33;
      } else {
        t33 = $[19];
      }
      return t33;
    }
    branch = params[1];
    basePath = `/keystatic/branch/${encodeURIComponent(branch)}`;
    let t32;
    if ($[20] !== params) {
      t32 = parseParamsWithoutBranch(params.slice(2));
      $[20] = params;
      $[21] = t32;
    } else {
      t32 = $[21];
    }
    parsedParams = t32;
  } else {
    let t22;
    if ($[22] !== params) {
      t22 = parseParamsWithoutBranch(params);
      $[22] = params;
      $[23] = t22;
    } else {
      t22 = $[23];
    }
    parsedParams = t22;
    basePath = "/keystatic";
  }
  const t2 = branch || "";
  let t3;
  if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime20.jsx)(PageRoot, {
      children: (0, import_jsx_runtime20.jsx)(PageBody, {
        children: (0, import_jsx_runtime20.jsx)(EmptyState2, {
          icon: fileX2Icon,
          title: "Not found",
          message: "This page could not be found."
        })
      })
    });
    $[24] = t3;
  } else {
    t3 = $[24];
  }
  let t4;
  if ($[25] !== parsedParams || $[26] !== config || $[27] !== basePath) {
    t4 = (0, import_jsx_runtime20.jsx)(NotFoundBoundary, {
      fallback: t3,
      children: parsedParams === null ? (0, import_jsx_runtime20.jsx)(AlwaysNotFound, {}) : parsedParams.collection ? parsedParams.kind === "create" ? (0, import_jsx_runtime20.jsx)(CreateItemWrapper, {
        collection: parsedParams.collection,
        config,
        basePath
      }, parsedParams.collection) : parsedParams.kind === "edit" ? (0, import_jsx_runtime20.jsx)(ItemPageOuterWrapper, {
        collection: parsedParams.collection,
        basePath,
        config,
        itemSlug: parsedParams.slug
      }, parsedParams.collection) : (0, import_jsx_runtime20.jsx)(CollectionPage, {
        basePath,
        collection: parsedParams.collection,
        config
      }, parsedParams.collection) : parsedParams.singleton ? (0, import_jsx_runtime20.jsx)(SingletonPageWrapper, {
        config,
        singleton: parsedParams.singleton
      }, parsedParams.singleton) : (0, import_jsx_runtime20.jsx)(DashboardPage, {
        config,
        basePath
      })
    });
    $[25] = parsedParams;
    $[26] = config;
    $[27] = basePath;
    $[28] = t4;
  } else {
    t4 = $[28];
  }
  let t5;
  if ($[29] !== config || $[30] !== t2 || $[31] !== basePath || $[32] !== t4) {
    t5 = (0, import_jsx_runtime20.jsx)(AppShell, {
      config,
      currentBranch: t2,
      basePath,
      children: t4
    });
    $[29] = config;
    $[30] = t2;
    $[31] = basePath;
    $[32] = t4;
    $[33] = t5;
  } else {
    t5 = $[33];
  }
  let t6;
  if ($[34] !== wrapper || $[35] !== t5) {
    t6 = wrapper(t5);
    $[34] = wrapper;
    $[35] = t5;
    $[36] = t6;
  } else {
    t6 = $[36];
  }
  return t6;
}
function AlwaysNotFound() {
  notFound();
}
function AuthWrapper(props) {
  const $ = c(13);
  const [state, setState] = (0, import_react8.useState)("unknown");
  const router = useRouter();
  let t0;
  let t1;
  if ($[0] !== props.config) {
    t0 = () => {
      getAuth(props.config).then((auth) => {
        if (auth) {
          setState("valid");
          return;
        }
        setState("explicit-auth");
      });
    };
    t1 = [props.config];
    $[0] = props.config;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  (0, import_react8.useEffect)(t0, t1);
  if (state === "valid") {
    return props.children;
  }
  if (state === "explicit-auth") {
    if (props.config.storage.kind === "github") {
      const t2 = `/api/keystatic/github/login${router.params.length ? `?${new URLSearchParams({
        from: router.params.map(encodeURIComponent).join("/")
      })}` : ""}`;
      let t3;
      if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = (0, import_jsx_runtime20.jsx)(Icon, {
          src: githubIcon
        });
        $[3] = t3;
      } else {
        t3 = $[3];
      }
      let t4;
      if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
        t4 = (0, import_jsx_runtime20.jsx)(Text, {
          children: "Log in with GitHub"
        });
        $[4] = t4;
      } else {
        t4 = $[4];
      }
      let t5;
      if ($[5] !== t2) {
        t5 = (0, import_jsx_runtime20.jsx)(Flex, {
          justifyContent: "center",
          alignItems: "center",
          height: "100vh",
          children: (0, import_jsx_runtime20.jsxs)(Button, {
            href: t2,
            target: "_top",
            children: [t3, t4]
          })
        });
        $[5] = t2;
        $[6] = t5;
      } else {
        t5 = $[6];
      }
      return t5;
    }
    if (props.config.storage.kind === "cloud") {
      let t2;
      if ($[7] !== router.params || $[8] !== props.config) {
        t2 = () => {
          redirectToCloudAuth(router.params.map(encodeURIComponent).join("/"), props.config);
        };
        $[7] = router.params;
        $[8] = props.config;
        $[9] = t2;
      } else {
        t2 = $[9];
      }
      let t3;
      if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = (0, import_jsx_runtime20.jsx)(Text, {
          children: "Log in with Keystatic Cloud"
        });
        $[10] = t3;
      } else {
        t3 = $[10];
      }
      let t4;
      if ($[11] !== t2) {
        t4 = (0, import_jsx_runtime20.jsx)(Flex, {
          justifyContent: "center",
          alignItems: "center",
          height: "100vh",
          children: (0, import_jsx_runtime20.jsx)(Button, {
            onPress: t2,
            children: t3
          })
        });
        $[11] = t2;
        $[12] = t4;
      } else {
        t4 = $[12];
      }
      return t4;
    }
  }
  return null;
}
function RedirectToLoopback(props) {
  const $ = c(2);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      if (window.location.hostname === "localhost") {
        window.location.href = window.location.href.replace("localhost", "127.0.0.1");
      }
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  (0, import_react8.useEffect)(t0, t1);
  if (window.location.hostname === "localhost") {
    return null;
  }
  return props.children;
}
function Keystatic(props) {
  const $ = c(8);
  if (props.config.storage.kind === "github") {
    assertValidRepoConfig(props.config.storage.repo);
  }
  let t0;
  if ($[0] !== props.config) {
    t0 = (0, import_jsx_runtime20.jsx)(PageInner, {
      config: props.config
    });
    $[0] = props.config;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== props.config || $[3] !== t0) {
    t1 = (0, import_jsx_runtime20.jsx)(RouterProvider, {
      children: (0, import_jsx_runtime20.jsx)(Provider, {
        config: props.config,
        children: t0
      })
    });
    $[2] = props.config;
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== props.appSlug || $[6] !== t1) {
    t2 = (0, import_jsx_runtime20.jsx)(ClientOnly, {
      children: (0, import_jsx_runtime20.jsx)(RedirectToLoopback, {
        children: (0, import_jsx_runtime20.jsx)(AppSlugProvider, {
          value: props.appSlug,
          children: t1
        })
      })
    });
    $[5] = props.appSlug;
    $[6] = t1;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}
function ClientOnly(props) {
  const $ = c(2);
  const [mounted, setMounted] = (0, import_react8.useState)(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setMounted(true);
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  (0, import_react8.useEffect)(t0, t1);
  if (!mounted) {
    return null;
  }
  return props.children;
}

export {
  Keystatic
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=chunk-ALD25RHO.js.map
