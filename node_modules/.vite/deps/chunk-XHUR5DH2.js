import {
  array,
  base64UrlEncode,
  boolean,
  bytesToHex,
  coerce,
  date,
  number,
  object,
  optional,
  require_dist,
  string,
  type
} from "./chunk-OORZSDVZ.js";
import {
  require_jsx_runtime
} from "./chunk-QRIEPQWS.js";
import {
  require_react_dom
} from "./chunk-XQLYTHWV.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/direction/index.js
var require_direction = __commonJS({
  "node_modules/direction/index.js"(exports, module) {
    "use strict";
    module.exports = direction;
    var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
    var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
    var rtl = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    var ltr = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    function direction(value2) {
      value2 = String(value2 || "");
      if (rtl.test(value2)) {
        return "rtl";
      }
      if (ltr.test(value2)) {
        return "ltr";
      }
      return "neutral";
    }
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject2(value2) {
      var type3 = typeof value2;
      return value2 != null && (type3 == "object" || type3 == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module) {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    module.exports = baseTrim;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value2) {
      var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag = value2[symToStringTag];
      try {
        value2[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e4) {
      }
      var result = nativeObjectToString.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag] = tag;
        } else {
          delete value2[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value2) {
      return nativeObjectToString.call(value2);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value2) {
      if (value2 == null) {
        return value2 === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike2(value2) {
      return value2 != null && typeof value2 == "object";
    }
    module.exports = isObjectLike2;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike2(value2) && baseGetTag(value2) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject2 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value2) {
      if (typeof value2 == "number") {
        return value2;
      }
      if (isSymbol(value2)) {
        return NAN;
      }
      if (isObject2(value2)) {
        var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
        value2 = isObject2(other) ? other + "" : other;
      }
      if (typeof value2 != "string") {
        return value2 === 0 ? value2 : +value2;
      }
      value2 = baseTrim(value2);
      var isBinary = reIsBinary.test(value2);
      return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
    }
    module.exports = toNumber;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module) {
    var isObject2 = require_isObject();
    var now = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args2 = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args2);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush2() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time2 = now(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush2;
      return debounced;
    }
    module.exports = debounce2;
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports, module) {
    var debounce2 = require_debounce();
    var isObject2 = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject2(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module.exports = throttle2;
  }
});

// node_modules/slate-react/node_modules/is-hotkey/lib/index.js
var require_lib = __commonJS({
  "node_modules/slate-react/node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f6 = 1; f6 < 20; f6++) {
      CODES["f" + f6] = 111 + f6;
    }
    var f6;
    function isHotkey(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array2 = hotkey.map(function(string2) {
        return parseHotkey(string2, options);
      });
      var check = function check2(e4) {
        return array2.some(function(object3) {
          return compareHotkey(object3, e4);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey(hotkey, event);
    }
    function isKeyHotkey2(hotkey, event) {
      return isHotkey(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values = hotkey.split("+");
      var length4 = values.length;
      for (var k2 in MODIFIERS) {
        ret[MODIFIERS[k2]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value2 = _step.value;
          var optional2 = value2.endsWith("?") && value2.length > 1;
          if (optional2) {
            value2 = value2.slice(0, -1);
          }
          var name = toKeyName(value2);
          var modifier = MODIFIERS[name];
          if (length4 === 1 || !modifier) {
            if (byKey) {
              ret.key = name;
            } else {
              ret.which = toKeyCode(value2);
            }
          }
          if (modifier) {
            ret[modifier] = optional2 ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object3, event) {
      for (var key in object3) {
        var expected = object3[key];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name) {
      name = toKeyName(name);
      var code = CODES[name] || name.toUpperCase().charCodeAt(0);
      return code;
    }
    function toKeyName(name) {
      name = name.toLowerCase();
      name = ALIASES[name] || name;
      return name;
    }
    exports.default = isHotkey;
    exports.isHotkey = isHotkey;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey2;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React8 = require_react();
        var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error2(format) {
          {
            {
              for (var _len2 = arguments.length, args2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args2[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args2);
            }
          }
        }
        function printWarning(level, format, args2) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args2 = args2.concat([stack]);
            }
            var argsWithFormat = args2.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x3, y3) {
          return x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState12 = React8.useState, useEffect9 = React8.useEffect, useLayoutEffect4 = React8.useLayoutEffect, useDebugValue = React8.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore4(subscribe5, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React8.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error2("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value2 = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value2, cachedValue)) {
                error2("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState12({
            inst: {
              value: value2,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect4(function() {
            inst.value = value2;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe5, value2, getSnapshot]);
          useEffect9(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe5(handleStoreChange);
          }, [subscribe5]);
          useDebugValue(value2);
          return value2;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error3) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe5, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore4;
        var useSyncExternalStore$2 = React8.useSyncExternalStore !== void 0 ? React8.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@keystatic/core/dist/react-compiler-runtime-0011f46e.js
var import_react = __toESM(require_react(), 1);
var $empty = Symbol.for("react.memo_cache_sentinel");
function c(size3) {
  return (0, import_react.useState)(() => {
    const $ = new Array(size3);
    for (let ii = 0; ii < size3; ii++) {
      $[ii] = $empty;
    }
    $[$empty] = true;
    return $;
  })[0];
}

// node_modules/@react-aria/utils/dist/useLayoutEffect.mjs
var import_react2 = __toESM(require_react(), 1);
var $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? (0, import_react2.default).useLayoutEffect : () => {
};

// node_modules/@react-aria/utils/dist/useEffectEvent.mjs
var import_react3 = __toESM(require_react(), 1);
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn2) {
  const ref = (0, import_react3.useRef)(null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    ref.current = fn2;
  }, [
    fn2
  ]);
  return (0, import_react3.useCallback)((...args2) => {
    const f6 = ref.current;
    return f6 === null || f6 === void 0 ? void 0 : f6(...args2);
  }, []);
}

// node_modules/@react-aria/utils/dist/useValueEffect.mjs
var import_react4 = __toESM(require_react(), 1);
function $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {
  let [value2, setValue] = (0, import_react4.useState)(defaultValue);
  let effect = (0, import_react4.useRef)(null);
  let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    if (!effect.current) return;
    let newValue = effect.current.next();
    if (newValue.done) {
      effect.current = null;
      return;
    }
    if (value2 === newValue.value) nextRef();
    else setValue(newValue.value);
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (effect.current) nextRef();
  });
  let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn2) => {
    effect.current = fn2(value2);
    nextRef();
  });
  return [
    value2,
    queue
  ];
}

// node_modules/@react-aria/utils/dist/useId.mjs
var import_react6 = __toESM(require_react(), 1);

// node_modules/@react-aria/ssr/dist/SSRProvider.mjs
var import_react5 = __toESM(require_react(), 1);
var $b5e257d569688ac6$var$defaultContext = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
};
var $b5e257d569688ac6$var$SSRContext = (0, import_react5.default).createContext($b5e257d569688ac6$var$defaultContext);
var $b5e257d569688ac6$var$IsSSRContext = (0, import_react5.default).createContext(false);
var $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $b5e257d569688ac6$var$componentIds = /* @__PURE__ */ new WeakMap();
function $b5e257d569688ac6$var$useCounter(isDisabled = false) {
  let ctx = (0, import_react5.useContext)($b5e257d569688ac6$var$SSRContext);
  let ref = (0, import_react5.useRef)(null);
  if (ref.current === null && !isDisabled) {
    var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, import_react5.default).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
    if (currentOwner) {
      let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);
      if (prevComponentValue == null)
        $b5e257d569688ac6$var$componentIds.set(currentOwner, {
          id: ctx.current,
          state: currentOwner.memoizedState
        });
      else if (currentOwner.memoizedState !== prevComponentValue.state) {
        ctx.current = prevComponentValue.id;
        $b5e257d569688ac6$var$componentIds.delete(currentOwner);
      }
    }
    ref.current = ++ctx.current;
  }
  return ref.current;
}
function $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {
  let ctx = (0, import_react5.useContext)($b5e257d569688ac6$var$SSRContext);
  if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);
  let prefix4 = ctx === $b5e257d569688ac6$var$defaultContext && false ? "react-aria" : `react-aria${ctx.prefix}`;
  return defaultId || `${prefix4}-${counter}`;
}
function $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {
  let id2 = (0, import_react5.default).useId();
  let [didSSR] = (0, import_react5.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());
  let prefix4 = didSSR || false ? "react-aria" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;
  return defaultId || `${prefix4}-${id2}`;
}
var $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, import_react5.default)["useId"] === "function" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;
function $b5e257d569688ac6$var$getSnapshot() {
  return false;
}
function $b5e257d569688ac6$var$getServerSnapshot() {
  return true;
}
function $b5e257d569688ac6$var$subscribe(onStoreChange) {
  return () => {
  };
}
function $b5e257d569688ac6$export$535bd6ca7f90a273() {
  if (typeof (0, import_react5.default)["useSyncExternalStore"] === "function") return (0, import_react5.default)["useSyncExternalStore"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);
  return (0, import_react5.useContext)($b5e257d569688ac6$var$IsSSRContext);
}

// node_modules/@react-aria/utils/dist/useId.mjs
var $bdb11010cef70236$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $bdb11010cef70236$var$idsUpdaterMap = /* @__PURE__ */ new Map();
function $bdb11010cef70236$export$f680877a34711e37(defaultId) {
  let [value2, setValue] = (0, import_react6.useState)(defaultId);
  let nextId = (0, import_react6.useRef)(null);
  let res = (0, $b5e257d569688ac6$export$619500959fc48b26)(value2);
  let updateValue = (0, import_react6.useCallback)((val) => {
    nextId.current = val;
  }, []);
  if ($bdb11010cef70236$var$canUseDOM) {
    if ($bdb11010cef70236$var$idsUpdaterMap.has(res) && !$bdb11010cef70236$var$idsUpdaterMap.get(res).includes(updateValue)) $bdb11010cef70236$var$idsUpdaterMap.set(res, [
      ...$bdb11010cef70236$var$idsUpdaterMap.get(res),
      updateValue
    ]);
    else $bdb11010cef70236$var$idsUpdaterMap.set(res, [
      updateValue
    ]);
  }
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let r6 = res;
    return () => {
      $bdb11010cef70236$var$idsUpdaterMap.delete(r6);
    };
  }, [
    res
  ]);
  (0, import_react6.useEffect)(() => {
    let newId = nextId.current;
    if (newId) {
      nextId.current = null;
      setValue(newId);
    }
  });
  return res;
}
function $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {
  if (idA === idB) return idA;
  let setIdsA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);
  if (setIdsA) {
    setIdsA.forEach((fn2) => fn2(idB));
    return idB;
  }
  let setIdsB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);
  if (setIdsB) {
    setIdsB.forEach((fn2) => fn2(idA));
    return idA;
  }
  return idB;
}
function $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {
  let id2 = $bdb11010cef70236$export$f680877a34711e37();
  let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id2);
  let updateId = (0, import_react6.useCallback)(() => {
    setResolvedId(function* () {
      yield id2;
      yield document.getElementById(id2) ? id2 : void 0;
    });
  }, [
    id2,
    setResolvedId
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [
    id2,
    updateId,
    ...depArray
  ]);
  return resolvedId;
}

// node_modules/@react-aria/utils/dist/chain.mjs
function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks2) {
  return (...args2) => {
    for (let callback of callbacks2) if (typeof callback === "function") callback(...args2);
  };
}

// node_modules/@react-aria/utils/dist/domHelpers.mjs
var $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
var $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {
  if (el && "window" in el && el.window === el) return el;
  const doc2 = $431fbd86ca7dc216$export$b204af158042fbac(el);
  return doc2.defaultView || window;
};

// node_modules/clsx/dist/clsx.mjs
function r(e4) {
  var t4, f6, n5 = "";
  if ("string" == typeof e4 || "number" == typeof e4) n5 += e4;
  else if ("object" == typeof e4) if (Array.isArray(e4)) {
    var o3 = e4.length;
    for (t4 = 0; t4 < o3; t4++) e4[t4] && (f6 = r(e4[t4])) && (n5 && (n5 += " "), n5 += f6);
  } else for (f6 in e4) e4[f6] && (n5 && (n5 += " "), n5 += f6);
  return n5;
}
function clsx() {
  for (var e4, t4, f6 = 0, n5 = "", o3 = arguments.length; f6 < o3; f6++) (e4 = arguments[f6]) && (t4 = r(e4)) && (n5 && (n5 += " "), n5 += t4);
  return n5;
}
var clsx_default = clsx;

// node_modules/@react-aria/utils/dist/mergeProps.mjs
function $3ef42575df84b30b$export$9d1611c77c2fe928(...args2) {
  let result = {
    ...args2[0]
  };
  for (let i4 = 1; i4 < args2.length; i4++) {
    let props = args2[i4];
    for (let key in props) {
      let a3 = result[key];
      let b2 = props[key];
      if (typeof a3 === "function" && typeof b2 === "function" && // This is a lot faster than a regex.
      key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */
      65 && key.charCodeAt(2) <= /* 'Z' */
      90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a3, b2);
      else if ((key === "className" || key === "UNSAFE_className") && typeof a3 === "string" && typeof b2 === "string") result[key] = (0, clsx_default)(a3, b2);
      else if (key === "id" && a3 && b2) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a3, b2);
      else result[key] = b2 !== void 0 ? b2 : a3;
    }
  }
  return result;
}

// node_modules/@react-aria/utils/dist/mergeRefs.mjs
function $5dc95899b306f630$export$c9058316764c140e(...refs) {
  if (refs.length === 1 && refs[0]) return refs[0];
  return (value2) => {
    for (let ref of refs) {
      if (typeof ref === "function") ref(value2);
      else if (ref != null) ref.current = value2;
    }
  };
}

// node_modules/@react-aria/utils/dist/filterDOMProps.mjs
var $65484d02dcb7eb3e$var$DOMPropNames = /* @__PURE__ */ new Set([
  "id"
]);
var $65484d02dcb7eb3e$var$labelablePropNames = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]);
var $65484d02dcb7eb3e$var$linkPropNames = /* @__PURE__ */ new Set([
  "href",
  "hrefLang",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]);
var $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;
function $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {
  let { labelable, isLink, propNames } = opts;
  let filteredProps = {};
  for (const prop in props) if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];
  return filteredProps;
}

// node_modules/@react-aria/utils/dist/focusWithoutScrolling.mjs
function $7215afc6de606d6b$export$de79e2c695e052f3(element2) {
  if ($7215afc6de606d6b$var$supportsPreventScroll()) element2.focus({
    preventScroll: true
  });
  else {
    let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element2);
    element2.focus();
    $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);
  }
}
var $7215afc6de606d6b$var$supportsPreventScrollCached = null;
function $7215afc6de606d6b$var$supportsPreventScroll() {
  if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {
    $7215afc6de606d6b$var$supportsPreventScrollCached = false;
    try {
      let focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          $7215afc6de606d6b$var$supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch (e4) {
    }
  }
  return $7215afc6de606d6b$var$supportsPreventScrollCached;
}
function $7215afc6de606d6b$var$getScrollableElements(element2) {
  let parent = element2.parentNode;
  let scrollableElements = [];
  let rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
      element: parent,
      scrollTop: parent.scrollTop,
      scrollLeft: parent.scrollLeft
    });
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
    element: rootScrollingElement,
    scrollTop: rootScrollingElement.scrollTop,
    scrollLeft: rootScrollingElement.scrollLeft
  });
  return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {
  for (let { element: element2, scrollTop, scrollLeft } of scrollableElements) {
    element2.scrollTop = scrollTop;
    element2.scrollLeft = scrollLeft;
  }
}

// node_modules/@react-aria/utils/dist/platform.mjs
function $c87311424ea30a05$var$testUserAgent(re) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null) return false;
  return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn2) {
  let res = null;
  return () => {
    if (res == null) res = fn2();
    return res;
  };
}
var $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
var $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
});
var $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
});
var $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
});
var $c87311424ea30a05$export$e1865c3bedcd822b = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
});
var $c87311424ea30a05$export$78551043582a6a98 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
});
var $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
});
var $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
var $c87311424ea30a05$export$b7d78993b74f766d = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
});

// node_modules/@react-aria/utils/dist/openLink.mjs
var import_react7 = __toESM(require_react(), 1);
var $ea8dcbcb9ea1b556$var$RouterContext = (0, import_react7.createContext)({
  isNative: true,
  open: $ea8dcbcb9ea1b556$var$openSyntheticLink,
  useHref: (href) => href
});
function $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {
  let { children, navigate, useHref } = props;
  let ctx = (0, import_react7.useMemo)(() => ({
    isNative: false,
    open: (target, modifiers, href, routerOptions) => {
      $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link) => {
        if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers)) navigate(href, routerOptions);
        else $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers);
      });
    },
    useHref: useHref || ((href) => href)
  }), [
    navigate,
    useHref
  ]);
  return (0, import_react7.default).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {
    value: ctx
  }, children);
}
function $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {
  return (0, import_react7.useContext)($ea8dcbcb9ea1b556$var$RouterContext);
}
function $ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers) {
  let target = link.getAttribute("target");
  return (!target || target === "_self") && link.origin === location.origin && !link.hasAttribute("download") && !modifiers.metaKey && // open in new tab (mac)
  !modifiers.ctrlKey && // open in new tab (windows)
  !modifiers.altKey && // download
  !modifiers.shiftKey;
}
function $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {
  var _window_event_type, _window_event;
  let { metaKey, ctrlKey, altKey, shiftKey } = modifiers;
  if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
    if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) metaKey = true;
    else ctrlKey = true;
  }
  let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey,
    ctrlKey,
    altKey,
    shiftKey
  }) : new MouseEvent("click", {
    metaKey,
    ctrlKey,
    altKey,
    shiftKey,
    bubbles: true,
    cancelable: true
  });
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;
  (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);
  target.dispatchEvent(event);
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
}
$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
function $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {
  if (target instanceof HTMLAnchorElement) open(target);
  else if (target.hasAttribute("data-href")) {
    let link = document.createElement("a");
    link.href = target.getAttribute("data-href");
    if (target.hasAttribute("data-target")) link.target = target.getAttribute("data-target");
    if (target.hasAttribute("data-rel")) link.rel = target.getAttribute("data-rel");
    if (target.hasAttribute("data-download")) link.download = target.getAttribute("data-download");
    if (target.hasAttribute("data-ping")) link.ping = target.getAttribute("data-ping");
    if (target.hasAttribute("data-referrer-policy")) link.referrerPolicy = target.getAttribute("data-referrer-policy");
    target.appendChild(link);
    open(link);
    target.removeChild(link);
  }
}
function $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {
  $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link) => $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers));
}
function $ea8dcbcb9ea1b556$export$bdc77b0c0a3a85d6(props) {
  let router = $ea8dcbcb9ea1b556$export$9a302a45f65d0572();
  var _props_href;
  const href = router.useHref((_props_href = props.href) !== null && _props_href !== void 0 ? _props_href : "");
  return {
    "data-href": props.href ? href : void 0,
    "data-target": props.target,
    "data-rel": props.rel,
    "data-download": props.download,
    "data-ping": props.ping,
    "data-referrer-policy": props.referrerPolicy
  };
}
function $ea8dcbcb9ea1b556$export$7e924b3091a3bd18(props) {
  let router = $ea8dcbcb9ea1b556$export$9a302a45f65d0572();
  var _props_href;
  const href = router.useHref((_props_href = props === null || props === void 0 ? void 0 : props.href) !== null && _props_href !== void 0 ? _props_href : "");
  return {
    href: (props === null || props === void 0 ? void 0 : props.href) ? href : void 0,
    target: props === null || props === void 0 ? void 0 : props.target,
    rel: props === null || props === void 0 ? void 0 : props.rel,
    download: props === null || props === void 0 ? void 0 : props.download,
    ping: props === null || props === void 0 ? void 0 : props.ping,
    referrerPolicy: props === null || props === void 0 ? void 0 : props.referrerPolicy
  };
}

// node_modules/@react-aria/utils/dist/runAfterTransition.mjs
var $bbed8b41f857bcc0$var$transitionsByElement = /* @__PURE__ */ new Map();
var $bbed8b41f857bcc0$var$transitionCallbacks = /* @__PURE__ */ new Set();
function $bbed8b41f857bcc0$var$setupGlobalEvents() {
  if (typeof window === "undefined") return;
  function isTransitionEvent(event) {
    return "propertyName" in event;
  }
  let onTransitionStart = (e4) => {
    if (!isTransitionEvent(e4) || !e4.target) return;
    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e4.target);
    if (!transitions) {
      transitions = /* @__PURE__ */ new Set();
      $bbed8b41f857bcc0$var$transitionsByElement.set(e4.target, transitions);
      e4.target.addEventListener("transitioncancel", onTransitionEnd, {
        once: true
      });
    }
    transitions.add(e4.propertyName);
  };
  let onTransitionEnd = (e4) => {
    if (!isTransitionEvent(e4) || !e4.target) return;
    let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e4.target);
    if (!properties) return;
    properties.delete(e4.propertyName);
    if (properties.size === 0) {
      e4.target.removeEventListener("transitioncancel", onTransitionEnd);
      $bbed8b41f857bcc0$var$transitionsByElement.delete(e4.target);
    }
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {
      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks) cb();
      $bbed8b41f857bcc0$var$transitionCallbacks.clear();
    }
  };
  document.body.addEventListener("transitionrun", onTransitionStart);
  document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading") $bbed8b41f857bcc0$var$setupGlobalEvents();
  else document.addEventListener("DOMContentLoaded", $bbed8b41f857bcc0$var$setupGlobalEvents);
}
function $bbed8b41f857bcc0$export$24490316f764c430(fn2) {
  requestAnimationFrame(() => {
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn2();
    else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn2);
  });
}

// node_modules/@react-aria/utils/dist/useDrag1D.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/@react-aria/utils/dist/useGlobalListeners.mjs
var import_react9 = __toESM(require_react(), 1);
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = (0, import_react9.useRef)(/* @__PURE__ */ new Map());
  let addGlobalListener = (0, import_react9.useCallback)((eventTarget, type3, listener, options) => {
    let fn2 = (options === null || options === void 0 ? void 0 : options.once) ? (...args2) => {
      globalListeners.current.delete(listener);
      listener(...args2);
    } : listener;
    globalListeners.current.set(listener, {
      type: type3,
      eventTarget,
      fn: fn2,
      options
    });
    eventTarget.addEventListener(type3, listener, options);
  }, []);
  let removeGlobalListener = (0, import_react9.useCallback)((eventTarget, type3, listener, options) => {
    var _globalListeners_current_get;
    let fn2 = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type3, fn2, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = (0, import_react9.useCallback)(() => {
    globalListeners.current.forEach((value2, key) => {
      removeGlobalListener(value2.eventTarget, value2.type, key, value2.options);
    });
  }, [
    removeGlobalListener
  ]);
  (0, import_react9.useEffect)(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}

// node_modules/@react-aria/utils/dist/useLabels.mjs
function $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {
  let { id: id2, "aria-label": label, "aria-labelledby": labelledBy } = props;
  id2 = (0, $bdb11010cef70236$export$f680877a34711e37)(id2);
  if (labelledBy && label) {
    let ids = /* @__PURE__ */ new Set([
      id2,
      ...labelledBy.trim().split(/\s+/)
    ]);
    labelledBy = [
      ...ids
    ].join(" ");
  } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
  if (!label && !labelledBy && defaultLabel) label = defaultLabel;
  return {
    id: id2,
    "aria-label": label,
    "aria-labelledby": labelledBy
  };
}

// node_modules/@react-aria/utils/dist/useObjectRef.mjs
var import_react10 = __toESM(require_react(), 1);
function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {
  const objRef = (0, import_react10.useRef)(null);
  return (0, import_react10.useMemo)(() => ({
    get current() {
      return objRef.current;
    },
    set current(value2) {
      objRef.current = value2;
      if (typeof forwardedRef === "function") forwardedRef(value2);
      else if (forwardedRef) forwardedRef.current = value2;
    }
  }), [
    forwardedRef
  ]);
}

// node_modules/@react-aria/utils/dist/useUpdateEffect.mjs
var import_react11 = __toESM(require_react(), 1);
function $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {
  const isInitialMount = (0, import_react11.useRef)(true);
  const lastDeps = (0, import_react11.useRef)(null);
  (0, import_react11.useEffect)(() => {
    isInitialMount.current = true;
    return () => {
      isInitialMount.current = false;
    };
  }, []);
  (0, import_react11.useEffect)(() => {
    if (isInitialMount.current) isInitialMount.current = false;
    else if (!lastDeps.current || dependencies.some((dep, i4) => !Object.is(dep, lastDeps[i4]))) effect();
    lastDeps.current = dependencies;
  }, dependencies);
}

// node_modules/@react-aria/utils/dist/useResizeObserver.mjs
var import_react12 = __toESM(require_react(), 1);
function $9daab02d461809db$var$hasResizeObserver() {
  return typeof window.ResizeObserver !== "undefined";
}
function $9daab02d461809db$export$683480f191c0e3ea(options) {
  const { ref, box, onResize } = options;
  (0, import_react12.useEffect)(() => {
    let element2 = ref === null || ref === void 0 ? void 0 : ref.current;
    if (!element2) return;
    if (!$9daab02d461809db$var$hasResizeObserver()) {
      window.addEventListener("resize", onResize, false);
      return () => {
        window.removeEventListener("resize", onResize, false);
      };
    } else {
      const resizeObserverInstance = new window.ResizeObserver((entries2) => {
        if (!entries2.length) return;
        onResize();
      });
      resizeObserverInstance.observe(element2, {
        box
      });
      return () => {
        if (element2) resizeObserverInstance.unobserve(element2);
      };
    }
  }, [
    onResize,
    ref,
    box
  ]);
}

// node_modules/@react-aria/utils/dist/useSyncRef.mjs
function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (context && context.ref && ref) {
      context.ref.current = ref.current;
      return () => {
        if (context.ref) context.ref.current = null;
      };
    }
  });
}

// node_modules/@react-aria/utils/dist/isScrollable.mjs
function $cc38e7bd3fc7b213$export$2bb74740c4e19def(node2, checkForOverflow) {
  let style = window.getComputedStyle(node2);
  let isScrollable = /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
  if (isScrollable && checkForOverflow) isScrollable = node2.scrollHeight !== node2.clientHeight || node2.scrollWidth !== node2.clientWidth;
  return isScrollable;
}

// node_modules/@react-aria/utils/dist/getScrollParent.mjs
function $62d8ded9296f3872$export$cfa2225e87938781(node2, checkForOverflow) {
  let scrollableNode = node2;
  if ((0, $cc38e7bd3fc7b213$export$2bb74740c4e19def)(scrollableNode, checkForOverflow)) scrollableNode = scrollableNode.parentElement;
  while (scrollableNode && !(0, $cc38e7bd3fc7b213$export$2bb74740c4e19def)(scrollableNode, checkForOverflow)) scrollableNode = scrollableNode.parentElement;
  return scrollableNode || document.scrollingElement || document.documentElement;
}

// node_modules/@react-aria/utils/dist/getScrollParents.mjs
function $a40c673dc9f6d9c7$export$94ed1c92c7beeb22(node2, checkForOverflow) {
  const scrollParents = [];
  while (node2 && node2 !== document.documentElement) {
    if ((0, $cc38e7bd3fc7b213$export$2bb74740c4e19def)(node2, checkForOverflow)) scrollParents.push(node2);
    node2 = node2.parentElement;
  }
  return scrollParents;
}

// node_modules/@react-aria/utils/dist/useViewportSize.mjs
var import_react13 = __toESM(require_react(), 1);
var $5df64b3807dc15ee$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $5df64b3807dc15ee$export$d699905dd57c73ca() {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let [size3, setSize] = (0, import_react13.useState)(() => isSSR ? {
    width: 0,
    height: 0
  } : $5df64b3807dc15ee$var$getViewportSize());
  (0, import_react13.useEffect)(() => {
    let onResize = () => {
      setSize((size4) => {
        let newSize = $5df64b3807dc15ee$var$getViewportSize();
        if (newSize.width === size4.width && newSize.height === size4.height) return size4;
        return newSize;
      });
    };
    if (!$5df64b3807dc15ee$var$visualViewport) window.addEventListener("resize", onResize);
    else $5df64b3807dc15ee$var$visualViewport.addEventListener("resize", onResize);
    return () => {
      if (!$5df64b3807dc15ee$var$visualViewport) window.removeEventListener("resize", onResize);
      else $5df64b3807dc15ee$var$visualViewport.removeEventListener("resize", onResize);
    };
  }, []);
  return size3;
}
function $5df64b3807dc15ee$var$getViewportSize() {
  return {
    width: $5df64b3807dc15ee$var$visualViewport && ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,
    height: $5df64b3807dc15ee$var$visualViewport && ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight
  };
}

// node_modules/@react-aria/utils/dist/useDescription.mjs
var import_react14 = __toESM(require_react(), 1);
var $ef06256079686ba0$var$descriptionId = 0;
var $ef06256079686ba0$var$descriptionNodes = /* @__PURE__ */ new Map();
function $ef06256079686ba0$export$f8aeda7b10753fa1(description) {
  let [id2, setId] = (0, import_react14.useState)();
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (!description) return;
    let desc = $ef06256079686ba0$var$descriptionNodes.get(description);
    if (!desc) {
      let id3 = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;
      setId(id3);
      let node2 = document.createElement("div");
      node2.id = id3;
      node2.style.display = "none";
      node2.textContent = description;
      document.body.appendChild(node2);
      desc = {
        refCount: 0,
        element: node2
      };
      $ef06256079686ba0$var$descriptionNodes.set(description, desc);
    } else setId(desc.element.id);
    desc.refCount++;
    return () => {
      if (desc && --desc.refCount === 0) {
        desc.element.remove();
        $ef06256079686ba0$var$descriptionNodes.delete(description);
      }
    };
  }, [
    description
  ]);
  return {
    "aria-describedby": description ? id2 : void 0
  };
}

// node_modules/@react-aria/utils/dist/useEvent.mjs
var import_react15 = __toESM(require_react(), 1);
function $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {
  let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);
  let isDisabled = handler == null;
  (0, import_react15.useEffect)(() => {
    if (isDisabled || !ref.current) return;
    let element2 = ref.current;
    element2.addEventListener(event, handleEvent, options);
    return () => {
      element2.removeEventListener(event, handleEvent, options);
    };
  }, [
    ref,
    event,
    options,
    isDisabled,
    handleEvent
  ]);
}

// node_modules/@react-aria/utils/dist/scrollIntoView.mjs
function $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element2) {
  let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element2, "left");
  let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element2, "top");
  let width = element2.offsetWidth;
  let height = element2.offsetHeight;
  let x3 = scrollView.scrollLeft;
  let y3 = scrollView.scrollTop;
  let { borderTopWidth, borderLeftWidth } = getComputedStyle(scrollView);
  let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
  let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
  let maxX = borderAdjustedX + scrollView.clientWidth;
  let maxY = borderAdjustedY + scrollView.clientHeight;
  if (offsetX <= x3) x3 = offsetX - parseInt(borderLeftWidth, 10);
  else if (offsetX + width > maxX) x3 += offsetX + width - maxX;
  if (offsetY <= borderAdjustedY) y3 = offsetY - parseInt(borderTopWidth, 10);
  else if (offsetY + height > maxY) y3 += offsetY + height - maxY;
  scrollView.scrollLeft = x3;
  scrollView.scrollTop = y3;
}
function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {
  const prop = axis === "left" ? "offsetLeft" : "offsetTop";
  let sum = 0;
  while (child.offsetParent) {
    sum += child[prop];
    if (child.offsetParent === ancestor) break;
    else if (child.offsetParent.contains(ancestor)) {
      sum -= ancestor[prop];
      break;
    }
    child = child.offsetParent;
  }
  return sum;
}
function $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {
  if (document.contains(targetElement)) {
    let root = document.scrollingElement || document.documentElement;
    let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
    if (!isScrollPrevented) {
      var _targetElement_scrollIntoView;
      let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();
      targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
        block: "nearest"
      });
      let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();
      if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
        var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;
        opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
          block: "center",
          inline: "center"
        });
        (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
          block: "nearest"
        });
      }
    } else {
      let scrollParents = (0, $a40c673dc9f6d9c7$export$94ed1c92c7beeb22)(targetElement);
      for (let scrollParent of scrollParents) $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);
    }
  }
}

// node_modules/@react-aria/utils/dist/isVirtualEvent.mjs
function $6a7db85432448f7f$export$60278871457622de(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
function $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {
  return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}

// node_modules/@react-aria/utils/dist/useDeepMemo.mjs
var import_react16 = __toESM(require_react(), 1);

// node_modules/@react-aria/utils/dist/useFormReset.mjs
var import_react17 = __toESM(require_react(), 1);
function $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {
  let resetValue = (0, import_react17.useRef)(initialValue);
  let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    if (onReset) onReset(resetValue.current);
  });
  (0, import_react17.useEffect)(() => {
    var _ref_current;
    let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;
    form === null || form === void 0 ? void 0 : form.addEventListener("reset", handleReset);
    return () => {
      form === null || form === void 0 ? void 0 : form.removeEventListener("reset", handleReset);
    };
  }, [
    ref,
    handleReset
  ]);
}

// node_modules/@react-aria/utils/dist/useLoadMore.mjs
var import_react18 = __toESM(require_react(), 1);
function $26f7f3da73fcd9d6$export$7717c92ee915373e(props, ref) {
  let { isLoading, onLoadMore, scrollOffset = 1, items } = props;
  let isLoadingRef = (0, import_react18.useRef)(isLoading);
  let prevProps = (0, import_react18.useRef)(props);
  let onScroll = (0, import_react18.useCallback)(() => {
    if (ref.current && !isLoadingRef.current && onLoadMore) {
      let shouldLoadMore = ref.current.scrollHeight - ref.current.scrollTop - ref.current.clientHeight < ref.current.clientHeight * scrollOffset;
      if (shouldLoadMore) {
        isLoadingRef.current = true;
        onLoadMore();
      }
    }
  }, [
    onLoadMore,
    ref,
    scrollOffset
  ]);
  let lastItems = (0, import_react18.useRef)(items);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (props !== prevProps.current) {
      isLoadingRef.current = isLoading;
      prevProps.current = props;
    }
    let shouldLoadMore = (ref === null || ref === void 0 ? void 0 : ref.current) && !isLoadingRef.current && onLoadMore && (!items || items !== lastItems.current) && ref.current.clientHeight === ref.current.scrollHeight;
    if (shouldLoadMore) {
      isLoadingRef.current = true;
      onLoadMore === null || onLoadMore === void 0 ? void 0 : onLoadMore();
    }
    lastItems.current = items;
  }, [
    isLoading,
    onLoadMore,
    props,
    ref,
    items
  ]);
  (0, $e9faafb641e167db$export$90fc3a17d93f704c)(ref, "scroll", onScroll);
}

// node_modules/@react-stately/utils/dist/useControlledState.mjs
var import_react19 = __toESM(require_react(), 1);
function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value2, defaultValue, onChange2) {
  let [stateValue, setStateValue] = (0, import_react19.useState)(value2 || defaultValue);
  let isControlledRef = (0, import_react19.useRef)(value2 !== void 0);
  let isControlled = value2 !== void 0;
  (0, import_react19.useEffect)(() => {
    let wasControlled = isControlledRef.current;
    if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`);
    isControlledRef.current = isControlled;
  }, [
    isControlled
  ]);
  let currentValue = isControlled ? value2 : stateValue;
  let setValue = (0, import_react19.useCallback)((value3, ...args2) => {
    let onChangeCaller = (value4, ...onChangeArgs) => {
      if (onChange2) {
        if (!Object.is(currentValue, value4)) onChange2(value4, ...onChangeArgs);
      }
      if (!isControlled)
        currentValue = value4;
    };
    if (typeof value3 === "function") {
      console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320");
      let updateFunction = (oldValue, ...functionArgs) => {
        let interceptedValue = value3(isControlled ? currentValue : oldValue, ...functionArgs);
        onChangeCaller(interceptedValue, ...args2);
        if (!isControlled) return interceptedValue;
        return oldValue;
      };
      setStateValue(updateFunction);
    } else {
      if (!isControlled) setStateValue(value3);
      onChangeCaller(value3, ...args2);
    }
  }, [
    isControlled,
    currentValue,
    onChange2
  ]);
  return [
    currentValue,
    setValue
  ];
}

// node_modules/@react-stately/utils/dist/number.mjs
function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, min2 = -Infinity, max2 = Infinity) {
  let newValue = Math.min(Math.max(value2, min2), max2);
  return newValue;
}
function $9446cca9a3875146$export$e1a7b8e69ef6c52f(value2, step) {
  let roundedValue = value2;
  let stepString = step.toString();
  let pointIndex = stepString.indexOf(".");
  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;
  if (precision > 0) {
    let pow = Math.pow(10, precision);
    roundedValue = Math.round(roundedValue * pow) / pow;
  }
  return roundedValue;
}
function $9446cca9a3875146$export$cb6e0bb50bc19463(value2, min2, max2, step) {
  min2 = Number(min2);
  max2 = Number(max2);
  let remainder = (value2 - (isNaN(min2) ? 0 : min2)) % step;
  let snappedValue = $9446cca9a3875146$export$e1a7b8e69ef6c52f(Math.abs(remainder) * 2 >= step ? value2 + Math.sign(remainder) * (step - Math.abs(remainder)) : value2 - remainder, step);
  if (!isNaN(min2)) {
    if (snappedValue < min2) snappedValue = min2;
    else if (!isNaN(max2) && snappedValue > max2) snappedValue = min2 + Math.floor($9446cca9a3875146$export$e1a7b8e69ef6c52f((max2 - min2) / step, step)) * step;
  } else if (!isNaN(max2) && snappedValue > max2) snappedValue = Math.floor($9446cca9a3875146$export$e1a7b8e69ef6c52f(max2 / step, step)) * step;
  snappedValue = $9446cca9a3875146$export$e1a7b8e69ef6c52f(snappedValue, step);
  return snappedValue;
}

// node_modules/@react-aria/i18n/dist/utils.mjs
var $148a7a147e38ea7f$var$RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Arab",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var $148a7a147e38ea7f$var$RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function $148a7a147e38ea7f$export$702d680b21cbd764(localeString) {
  if (Intl.Locale) {
    let locale = new Intl.Locale(localeString).maximize();
    let textInfo = typeof locale.getTextInfo === "function" ? locale.getTextInfo() : locale.textInfo;
    if (textInfo) return textInfo.direction === "rtl";
    if (locale.script) return $148a7a147e38ea7f$var$RTL_SCRIPTS.has(locale.script);
  }
  let lang = localeString.split("-")[0];
  return $148a7a147e38ea7f$var$RTL_LANGS.has(lang);
}

// node_modules/@react-aria/i18n/dist/useDefaultLocale.mjs
var import_react20 = __toESM(require_react(), 1);
var $1e5a04cdaf7d1af8$var$localeSymbol = Symbol.for("react-aria.i18n.locale");
function $1e5a04cdaf7d1af8$export$f09106e7c6677ec5() {
  let locale = typeof window !== "undefined" && window[$1e5a04cdaf7d1af8$var$localeSymbol] || typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([
      locale
    ]);
  } catch (_err) {
    locale = "en-US";
  }
  return {
    locale,
    direction: (0, $148a7a147e38ea7f$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
  };
}
var $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();
var $1e5a04cdaf7d1af8$var$listeners = /* @__PURE__ */ new Set();
function $1e5a04cdaf7d1af8$var$updateLocale() {
  $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();
  for (let listener of $1e5a04cdaf7d1af8$var$listeners) listener($1e5a04cdaf7d1af8$var$currentLocale);
}
function $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a() {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let [defaultLocale, setDefaultLocale] = (0, import_react20.useState)($1e5a04cdaf7d1af8$var$currentLocale);
  (0, import_react20.useEffect)(() => {
    if ($1e5a04cdaf7d1af8$var$listeners.size === 0) window.addEventListener("languagechange", $1e5a04cdaf7d1af8$var$updateLocale);
    $1e5a04cdaf7d1af8$var$listeners.add(setDefaultLocale);
    return () => {
      $1e5a04cdaf7d1af8$var$listeners.delete(setDefaultLocale);
      if ($1e5a04cdaf7d1af8$var$listeners.size === 0) window.removeEventListener("languagechange", $1e5a04cdaf7d1af8$var$updateLocale);
    };
  }, []);
  if (isSSR) return {
    locale: "en-US",
    direction: "ltr"
  };
  return defaultLocale;
}

// node_modules/@react-aria/i18n/dist/context.mjs
var import_react21 = __toESM(require_react(), 1);
var $18f2051aff69b9bf$var$I18nContext = (0, import_react21.default).createContext(null);
function $18f2051aff69b9bf$export$a54013f0d02a8f82(props) {
  let { locale, children } = props;
  let defaultLocale = (0, $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a)();
  let value2 = (0, import_react21.default).useMemo(() => {
    if (!locale) return defaultLocale;
    return {
      locale,
      direction: (0, $148a7a147e38ea7f$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
    };
  }, [
    defaultLocale,
    locale
  ]);
  return (0, import_react21.default).createElement($18f2051aff69b9bf$var$I18nContext.Provider, {
    value: value2
  }, children);
}
function $18f2051aff69b9bf$export$43bb16f9c6d9e3f7() {
  let defaultLocale = (0, $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a)();
  let context = (0, import_react21.useContext)($18f2051aff69b9bf$var$I18nContext);
  return context || defaultLocale;
}

// node_modules/@internationalized/string/dist/LocalizedStringDictionary.mjs
var $5b160d28a433310d$var$localeSymbol = Symbol.for("react-aria.i18n.locale");
var $5b160d28a433310d$var$stringsSymbol = Symbol.for("react-aria.i18n.strings");
var $5b160d28a433310d$var$cachedGlobalStrings = void 0;
var $5b160d28a433310d$export$c17fa47878dc55b6 = class _$5b160d28a433310d$export$c17fa47878dc55b6 {
  /** Returns a localized string for the given key and locale. */
  getStringForLocale(key, locale) {
    let strings = this.getStringsForLocale(locale);
    let string2 = strings[key];
    if (!string2) throw new Error(`Could not find intl message ${key} in ${locale} locale`);
    return string2;
  }
  /** Returns all localized strings for the given locale. */
  getStringsForLocale(locale) {
    let strings = this.strings[locale];
    if (!strings) {
      strings = $5b160d28a433310d$var$getStringsForLocale(locale, this.strings, this.defaultLocale);
      this.strings[locale] = strings;
    }
    return strings;
  }
  static getGlobalDictionaryForPackage(packageName) {
    if (typeof window === "undefined") return null;
    let locale = window[$5b160d28a433310d$var$localeSymbol];
    if ($5b160d28a433310d$var$cachedGlobalStrings === void 0) {
      let globalStrings = window[$5b160d28a433310d$var$stringsSymbol];
      if (!globalStrings) return null;
      $5b160d28a433310d$var$cachedGlobalStrings = {};
      for (let pkg in globalStrings) $5b160d28a433310d$var$cachedGlobalStrings[pkg] = new _$5b160d28a433310d$export$c17fa47878dc55b6({
        [locale]: globalStrings[pkg]
      }, locale);
    }
    let dictionary = $5b160d28a433310d$var$cachedGlobalStrings === null || $5b160d28a433310d$var$cachedGlobalStrings === void 0 ? void 0 : $5b160d28a433310d$var$cachedGlobalStrings[packageName];
    if (!dictionary) throw new Error(`Strings for package "${packageName}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);
    return dictionary;
  }
  constructor(messages, defaultLocale = "en-US") {
    this.strings = Object.fromEntries(Object.entries(messages).filter(([, v6]) => v6));
    this.defaultLocale = defaultLocale;
  }
};
function $5b160d28a433310d$var$getStringsForLocale(locale, strings, defaultLocale = "en-US") {
  if (strings[locale]) return strings[locale];
  let language = $5b160d28a433310d$var$getLanguage(locale);
  if (strings[language]) return strings[language];
  for (let key in strings) {
    if (key.startsWith(language + "-")) return strings[key];
  }
  return strings[defaultLocale];
}
function $5b160d28a433310d$var$getLanguage(locale) {
  if (Intl.Locale)
    return new Intl.Locale(locale).language;
  return locale.split("-")[0];
}

// node_modules/@internationalized/string/dist/LocalizedStringFormatter.mjs
var $6db58dc88e78b024$var$pluralRulesCache = /* @__PURE__ */ new Map();
var $6db58dc88e78b024$var$numberFormatCache = /* @__PURE__ */ new Map();
var $6db58dc88e78b024$export$2f817fcdc4b89ae0 = class {
  /** Formats a localized string for the given key with the provided variables. */
  format(key, variables) {
    let message = this.strings.getStringForLocale(key, this.locale);
    return typeof message === "function" ? message(variables, this) : message;
  }
  plural(count, options, type3 = "cardinal") {
    let opt = options["=" + count];
    if (opt) return typeof opt === "function" ? opt() : opt;
    let key = this.locale + ":" + type3;
    let pluralRules = $6db58dc88e78b024$var$pluralRulesCache.get(key);
    if (!pluralRules) {
      pluralRules = new Intl.PluralRules(this.locale, {
        type: type3
      });
      $6db58dc88e78b024$var$pluralRulesCache.set(key, pluralRules);
    }
    let selected = pluralRules.select(count);
    opt = options[selected] || options.other;
    return typeof opt === "function" ? opt() : opt;
  }
  number(value2) {
    let numberFormat = $6db58dc88e78b024$var$numberFormatCache.get(this.locale);
    if (!numberFormat) {
      numberFormat = new Intl.NumberFormat(this.locale);
      $6db58dc88e78b024$var$numberFormatCache.set(this.locale, numberFormat);
    }
    return numberFormat.format(value2);
  }
  select(options, value2) {
    let opt = options[value2] || options.other;
    return typeof opt === "function" ? opt() : opt;
  }
  constructor(locale, strings) {
    this.locale = locale;
    this.strings = strings;
  }
};

// node_modules/@react-aria/i18n/dist/useLocalizedStringFormatter.mjs
var import_react22 = __toESM(require_react(), 1);
var $fca6afa0e843324b$var$cache = /* @__PURE__ */ new WeakMap();
function $fca6afa0e843324b$var$getCachedDictionary(strings) {
  let dictionary = $fca6afa0e843324b$var$cache.get(strings);
  if (!dictionary) {
    dictionary = new (0, $5b160d28a433310d$export$c17fa47878dc55b6)(strings);
    $fca6afa0e843324b$var$cache.set(strings, dictionary);
  }
  return dictionary;
}
function $fca6afa0e843324b$export$87b761675e8eaa10(strings, packageName) {
  return packageName && (0, $5b160d28a433310d$export$c17fa47878dc55b6).getGlobalDictionaryForPackage(packageName) || $fca6afa0e843324b$var$getCachedDictionary(strings);
}
function $fca6afa0e843324b$export$f12b703ca79dfbb1(strings, packageName) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let dictionary = $fca6afa0e843324b$export$87b761675e8eaa10(strings, packageName);
  return (0, import_react22.useMemo)(() => new (0, $6db58dc88e78b024$export$2f817fcdc4b89ae0)(locale, dictionary), [
    locale,
    dictionary
  ]);
}

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d5, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b3) {
    d6.__proto__ = b3;
  } || function(d6, b3) {
    for (var p4 in b3) if (Object.prototype.hasOwnProperty.call(b3, p4)) d6[p4] = b3[p4];
  };
  return extendStatics(d5, b2);
};
function __extends(d5, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d5, b2);
  function __() {
    this.constructor = d5;
  }
  d5.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t4) {
    for (var s4, i4 = 1, n5 = arguments.length; i4 < n5; i4++) {
      s4 = arguments[i4];
      for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4)) t4[p4] = s4[p4];
    }
    return t4;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e4) {
  var t4 = {};
  for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4) && e4.indexOf(p4) < 0)
    t4[p4] = s4[p4];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p4 = Object.getOwnPropertySymbols(s4); i4 < p4.length; i4++) {
      if (e4.indexOf(p4[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p4[i4]))
        t4[p4[i4]] = s4[p4[i4]];
    }
  return t4;
}
function __spreadArray(to, from4, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l6 = from4.length, ar; i4 < l6; i4++) {
    if (ar || !(i4 in from4)) {
      if (!ar) ar = Array.prototype.slice.call(from4, 0, i4);
      ar[i4] = from4[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from4));
}

// node_modules/@formatjs/fast-memoize/lib/index.js
function memoize(fn2, options) {
  var cache3 = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn2, {
    cache: cache3,
    serializer
  });
}
function isPrimitive(value2) {
  return value2 == null || typeof value2 === "number" || typeof value2 === "boolean";
}
function monadic(fn2, cache3, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache3.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.call(this, arg);
    cache3.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn2, cache3, serializer) {
  var args2 = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args2);
  var computedValue = cache3.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.apply(this, args2);
    cache3.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn2, context, strategy, cache3, serialize2) {
  return strategy.bind(context, fn2, cache3, serialize2);
}
function strategyDefault(fn2, options) {
  var strategy = fn2.length === 1 ? monadic : variadic;
  return assemble(fn2, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn2, options) {
  return assemble(fn2, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn2, options) {
  return assemble(fn2, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value2) {
  this.cache[key] = value2;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};

// node_modules/@formatjs/icu-messageformat-parser/lib/error.js
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));

// node_modules/@formatjs/icu-messageformat-parser/lib/types.js
var TYPE;
(function(TYPE3) {
  TYPE3[TYPE3["literal"] = 0] = "literal";
  TYPE3[TYPE3["argument"] = 1] = "argument";
  TYPE3[TYPE3["number"] = 2] = "number";
  TYPE3[TYPE3["date"] = 3] = "date";
  TYPE3[TYPE3["time"] = 4] = "time";
  TYPE3[TYPE3["select"] = 5] = "select";
  TYPE3[TYPE3["plural"] = 6] = "plural";
  TYPE3[TYPE3["pound"] = 7] = "pound";
  TYPE3[TYPE3["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}

// node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

// node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match2) {
    var len = match2.length;
    switch (match2[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}

// node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

// node_modules/@formatjs/icu-skeleton-parser/lib/number.js
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x3) {
    return x3.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a5 = 0, options_1 = options; _a5 < options_1.length; _a5++) {
      var option = options_1[_a5];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g22) {
    if (typeof g22 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g22 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g22 === "string" ? g22.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token2 = tokens_1[_i];
    switch (token2.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token2.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token2.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token2.options.reduce(function(all2, opt2) {
          return __assign(__assign({}, all2), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token2.options.reduce(function(all2, opt2) {
          return __assign(__assign({}, all2), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token2.options[0]);
        continue;
      case "rounding-mode-floor":
        result.roundingMode = "floor";
        continue;
      case "rounding-mode-ceiling":
        result.roundingMode = "ceil";
        continue;
      case "rounding-mode-down":
        result.roundingMode = "trunc";
        continue;
      case "rounding-mode-up":
        result.roundingMode = "expand";
        continue;
      case "rounding-mode-half-even":
        result.roundingMode = "halfEven";
        continue;
      case "rounding-mode-half-down":
        result.roundingMode = "halfTrunc";
        continue;
      case "rounding-mode-half-up":
        result.roundingMode = "halfExpand";
        continue;
      case "integer-width":
        if (token2.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token2.options[0].replace(INTEGER_WIDTH_REGEX, function(_2, g1, g22, g32, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g22.length;
          } else if (g32 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token2.stem)) {
      result.minimumIntegerDigits = token2.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token2.stem)) {
      if (token2.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token2.stem.replace(FRACTION_PRECISION_REGEX, function(_2, g1, g22, g32, g4, g5) {
        if (g22 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g32 && g32[0] === "#") {
          result.maximumFractionDigits = g32.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token2.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token2.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token2.stem));
      continue;
    }
    var signOpts = parseSign(token2.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token2.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}

// node_modules/@formatjs/icu-messageformat-parser/lib/time-data.generated.js
var timeData = {
  "001": [
    "H",
    "h"
  ],
  "419": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "AC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AD": [
    "H",
    "hB"
  ],
  "AE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "AF": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "AG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AL": [
    "h",
    "H",
    "hB"
  ],
  "AM": [
    "H",
    "hB"
  ],
  "AO": [
    "H",
    "hB"
  ],
  "AR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "AS": [
    "h",
    "H"
  ],
  "AT": [
    "H",
    "hB"
  ],
  "AU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AW": [
    "H",
    "hB"
  ],
  "AX": [
    "H"
  ],
  "AZ": [
    "H",
    "hB",
    "h"
  ],
  "BA": [
    "H",
    "hB",
    "h"
  ],
  "BB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BD": [
    "h",
    "hB",
    "H"
  ],
  "BE": [
    "H",
    "hB"
  ],
  "BF": [
    "H",
    "hB"
  ],
  "BG": [
    "H",
    "hB",
    "h"
  ],
  "BH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "BI": [
    "H",
    "h"
  ],
  "BJ": [
    "H",
    "hB"
  ],
  "BL": [
    "H",
    "hB"
  ],
  "BM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BN": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "BO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "BQ": [
    "H"
  ],
  "BR": [
    "H",
    "hB"
  ],
  "BS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BT": [
    "h",
    "H"
  ],
  "BW": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BY": [
    "H",
    "h"
  ],
  "BZ": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CA": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "CC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CD": [
    "hB",
    "H"
  ],
  "CF": [
    "H",
    "h",
    "hB"
  ],
  "CG": [
    "H",
    "hB"
  ],
  "CH": [
    "H",
    "hB",
    "h"
  ],
  "CI": [
    "H",
    "hB"
  ],
  "CK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CL": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CM": [
    "H",
    "h",
    "hB"
  ],
  "CN": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "CO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CP": [
    "H"
  ],
  "CR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CU": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CV": [
    "H",
    "hB"
  ],
  "CW": [
    "H",
    "hB"
  ],
  "CX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CY": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "CZ": [
    "H"
  ],
  "DE": [
    "H",
    "hB"
  ],
  "DG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "DJ": [
    "h",
    "H"
  ],
  "DK": [
    "H"
  ],
  "DM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "DO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "DZ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "EC": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "EE": [
    "H",
    "hB"
  ],
  "EG": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ER": [
    "h",
    "H"
  ],
  "ES": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "ET": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "FI": [
    "H"
  ],
  "FJ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "FM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FO": [
    "H",
    "h"
  ],
  "FR": [
    "H",
    "hB"
  ],
  "GA": [
    "H",
    "hB"
  ],
  "GB": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GD": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GE": [
    "H",
    "hB",
    "h"
  ],
  "GF": [
    "H",
    "hB"
  ],
  "GG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GH": [
    "h",
    "H"
  ],
  "GI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GL": [
    "H",
    "h"
  ],
  "GM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GN": [
    "H",
    "hB"
  ],
  "GP": [
    "H",
    "hB"
  ],
  "GQ": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "GR": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "GT": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "GU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GW": [
    "H",
    "hB"
  ],
  "GY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "HK": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "HN": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "HR": [
    "H",
    "hB"
  ],
  "HU": [
    "H",
    "h"
  ],
  "IC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ID": [
    "H"
  ],
  "IE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IL": [
    "H",
    "hB"
  ],
  "IM": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IN": [
    "h",
    "H"
  ],
  "IO": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IQ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "IR": [
    "hB",
    "H"
  ],
  "IS": [
    "H"
  ],
  "IT": [
    "H",
    "hB"
  ],
  "JE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "JM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "JO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "JP": [
    "H",
    "K",
    "h"
  ],
  "KE": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "KG": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KH": [
    "hB",
    "h",
    "H",
    "hb"
  ],
  "KI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KM": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KN": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KP": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KW": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "KY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KZ": [
    "H",
    "hB"
  ],
  "LA": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "LB": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LI": [
    "H",
    "hB",
    "h"
  ],
  "LK": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "LR": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LS": [
    "h",
    "H"
  ],
  "LT": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "LU": [
    "H",
    "h",
    "hB"
  ],
  "LV": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "LY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MC": [
    "H",
    "hB"
  ],
  "MD": [
    "H",
    "hB"
  ],
  "ME": [
    "H",
    "hB",
    "h"
  ],
  "MF": [
    "H",
    "hB"
  ],
  "MG": [
    "H",
    "h"
  ],
  "MH": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ML": [
    "H"
  ],
  "MM": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "MN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MP": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MQ": [
    "H",
    "hB"
  ],
  "MR": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MS": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MT": [
    "H",
    "h"
  ],
  "MU": [
    "H",
    "h"
  ],
  "MV": [
    "H",
    "h"
  ],
  "MW": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MX": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "MY": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "MZ": [
    "H",
    "hB"
  ],
  "NA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NC": [
    "H",
    "hB"
  ],
  "NE": [
    "H"
  ],
  "NF": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NI": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NL": [
    "H",
    "hB"
  ],
  "NO": [
    "H",
    "h"
  ],
  "NP": [
    "H",
    "h",
    "hB"
  ],
  "NR": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NU": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "OM": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PF": [
    "H",
    "h",
    "hB"
  ],
  "PG": [
    "h",
    "H"
  ],
  "PH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PK": [
    "h",
    "hB",
    "H"
  ],
  "PL": [
    "H",
    "h"
  ],
  "PM": [
    "H",
    "hB"
  ],
  "PN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "PR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PS": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PT": [
    "H",
    "hB"
  ],
  "PW": [
    "h",
    "H"
  ],
  "PY": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "QA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "RE": [
    "H",
    "hB"
  ],
  "RO": [
    "H",
    "hB"
  ],
  "RS": [
    "H",
    "hB",
    "h"
  ],
  "RU": [
    "H"
  ],
  "RW": [
    "H",
    "h"
  ],
  "SA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SC": [
    "H",
    "h",
    "hB"
  ],
  "SD": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SE": [
    "H"
  ],
  "SG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SH": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SI": [
    "H",
    "hB"
  ],
  "SJ": [
    "H"
  ],
  "SK": [
    "H"
  ],
  "SL": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SM": [
    "H",
    "h",
    "hB"
  ],
  "SN": [
    "H",
    "h",
    "hB"
  ],
  "SO": [
    "h",
    "H"
  ],
  "SR": [
    "H",
    "hB"
  ],
  "SS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ST": [
    "H",
    "hB"
  ],
  "SV": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "SX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "TC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TD": [
    "h",
    "H",
    "hB"
  ],
  "TF": [
    "H",
    "h",
    "hB"
  ],
  "TG": [
    "H",
    "hB"
  ],
  "TH": [
    "H",
    "h"
  ],
  "TJ": [
    "H",
    "h"
  ],
  "TL": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "TM": [
    "H",
    "h"
  ],
  "TN": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "TO": [
    "h",
    "H"
  ],
  "TR": [
    "H",
    "hB"
  ],
  "TT": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TW": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "TZ": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UA": [
    "H",
    "hB",
    "h"
  ],
  "UG": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "US": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "UY": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "UZ": [
    "H",
    "hB",
    "h"
  ],
  "VA": [
    "H",
    "h",
    "hB"
  ],
  "VC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "VG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VN": [
    "H",
    "h"
  ],
  "VU": [
    "h",
    "H"
  ],
  "WF": [
    "H",
    "hB"
  ],
  "WS": [
    "h",
    "H"
  ],
  "XK": [
    "H",
    "hB",
    "h"
  ],
  "YE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "YT": [
    "H",
    "hB"
  ],
  "ZA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ZM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ZW": [
    "H",
    "h"
  ],
  "af-ZA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ar-001": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ca-ES": [
    "H",
    "h",
    "hB"
  ],
  "en-001": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "es-BR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-ES": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-GQ": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "fr-CA": [
    "H",
    "h",
    "hB"
  ],
  "gl-ES": [
    "H",
    "h",
    "hB"
  ],
  "gu-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "hi-IN": [
    "hB",
    "h",
    "H"
  ],
  "it-CH": [
    "H",
    "h",
    "hB"
  ],
  "it-IT": [
    "H",
    "h",
    "hB"
  ],
  "kn-IN": [
    "hB",
    "h",
    "H"
  ],
  "ml-IN": [
    "hB",
    "h",
    "H"
  ],
  "mr-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "pa-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "ta-IN": [
    "hB",
    "h",
    "hb",
    "H"
  ],
  "te-IN": [
    "hB",
    "h",
    "H"
  ],
  "zu-ZA": [
    "H",
    "hB",
    "hb",
    "h"
  ]
};

// node_modules/@formatjs/icu-messageformat-parser/lib/date-time-pattern-generator.js
function getBestPattern(skeleton, locale) {
  var skeletonCopy = "";
  for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
    var patternChar = skeleton.charAt(patternPos);
    if (patternChar === "j") {
      var extraLength = 0;
      while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
        extraLength++;
        patternPos++;
      }
      var hourLen = 1 + (extraLength & 1);
      var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
      var dayPeriodChar = "a";
      var hourChar = getDefaultHourSymbolFromLocale(locale);
      if (hourChar == "H" || hourChar == "k") {
        dayPeriodLen = 0;
      }
      while (dayPeriodLen-- > 0) {
        skeletonCopy += dayPeriodChar;
      }
      while (hourLen-- > 0) {
        skeletonCopy = hourChar + skeletonCopy;
      }
    } else if (patternChar === "J") {
      skeletonCopy += "H";
    } else {
      skeletonCopy += patternChar;
    }
  }
  return skeletonCopy;
}
function getDefaultHourSymbolFromLocale(locale) {
  var hourCycle = locale.hourCycle;
  if (hourCycle === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  locale.hourCycles && // @ts-ignore
  locale.hourCycles.length) {
    hourCycle = locale.hourCycles[0];
  }
  if (hourCycle) {
    switch (hourCycle) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  }
  var languageTag = locale.language;
  var regionTag;
  if (languageTag !== "root") {
    regionTag = locale.maximize().region;
  }
  var hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData["".concat(languageTag, "-001")] || timeData["001"];
  return hourCycles[0];
}

// node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start2, end) {
  return { start: start2, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith && "_a".startsWith("a", 1);
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n5) {
  return typeof n5 === "number" && isFinite(n5) && Math.floor(n5) === n5 && Math.abs(n5) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_2) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var re;
var startsWith = hasNativeStartsWith ? (
  // Native
  function startsWith2(s4, search, position2) {
    return s4.startsWith(search, position2);
  }
) : (
  // For IE11
  function startsWith3(s4, search, position2) {
    return s4.slice(position2, position2 + search.length) === search;
  }
);
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function fromCodePoint2() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    var elements = "";
    var length4 = codePoints.length;
    var i4 = 0;
    var code;
    while (length4 > i4) {
      code = codePoints[i4++];
      if (code > 1114111)
        throw RangeError(code + " is not a valid code point");
      elements += code < 65536 ? String.fromCharCode(code) : String.fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
    }
    return elements;
  }
);
var fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function fromEntries2(entries2) {
      var obj = {};
      for (var _i = 0, entries_1 = entries2; _i < entries_1.length; _i++) {
        var _a5 = entries_1[_i], k2 = _a5[0], v6 = _a5[1];
        obj[k2] = v6;
      }
      return obj;
    }
  )
);
var codePointAt = hasNativeCodePointAt ? (
  // Native
  function codePointAt2(s4, index2) {
    return s4.codePointAt(index2);
  }
) : (
  // IE 11
  function codePointAt3(s4, index2) {
    var size3 = s4.length;
    if (index2 < 0 || index2 >= size3) {
      return void 0;
    }
    var first = s4.charCodeAt(index2);
    var second;
    return first < 55296 || first > 56319 || index2 + 1 === size3 || (second = s4.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
  }
);
var trimStart = hasTrimStart ? (
  // Native
  function trimStart2(s4) {
    return s4.trimStart();
  }
) : (
  // Ponyfill
  function trimStart3(s4) {
    return s4.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
);
var trimEnd = hasTrimEnd ? (
  // Native
  function trimEnd2(s4) {
    return s4.trimEnd();
  }
) : (
  // Ponyfill
  function trimEnd3(s4) {
    return s4.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(s4, flag) {
  return new RegExp(s4, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s4, index2) {
    var _a5;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index2;
    var match2 = IDENTIFIER_PREFIX_RE_1.exec(s4);
    return (_a5 = match2[1]) !== null && _a5 !== void 0 ? _a5 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s4, index2) {
    var match2 = [];
    while (true) {
      var c6 = codePointAt(s4, index2);
      if (c6 === void 0 || _isWhiteSpace(c6) || _isPatternSyntax(c6)) {
        break;
      }
      match2.push(c6);
      index2 += c6 >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match2);
  };
}
var IDENTIFIER_PREFIX_RE_1;
var Parser = (
  /** @class */
  function() {
    function Parser3(message, options) {
      if (options === void 0) {
        options = {};
      }
      this.message = message;
      this.position = { offset: 0, line: 1, column: 1 };
      this.ignoreTag = !!options.ignoreTag;
      this.locale = options.locale;
      this.requiresOtherClause = !!options.requiresOtherClause;
      this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser3.prototype.parse = function() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    };
    Parser3.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
      var elements = [];
      while (!this.isEOF()) {
        var char2 = this.char();
        if (char2 === 123) {
          var result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char2 === 125 && nestingLevel > 0) {
          break;
        } else if (char2 === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          var position2 = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position2, this.clonePosition())
          });
        } else if (char2 === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char2 === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          var result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          var result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return { val: elements, err: null };
    };
    Parser3.prototype.parseTag = function(nestingLevel, parentArgType) {
      var startPosition = this.clonePosition();
      this.bump();
      var tagName = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(tagName, "/>"),
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        var children = childrenResult.val;
        var endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          var closingTagNameStartPosition = this.clonePosition();
          var closingTagName = this.parseTagName();
          if (tagName !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName,
              children,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    };
    Parser3.prototype.parseTagName = function() {
      var startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    };
    Parser3.prototype.parseLiteral = function(nestingLevel, parentArgType) {
      var start2 = this.clonePosition();
      var value2 = "";
      while (true) {
        var parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value2 += parseQuoteResult;
          continue;
        }
        var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value2 += parseUnquotedResult;
          continue;
        }
        var parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value2 += parseLeftAngleResult;
          continue;
        }
        break;
      }
      var location2 = createLocation(start2, this.clonePosition());
      return {
        val: { type: TYPE.literal, value: value2, location: location2 },
        err: null
      };
    };
    Parser3.prototype.tryParseLeftAngleBracket = function() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    };
    Parser3.prototype.tryParseQuote = function(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      var codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch);
        }
        this.bump();
      }
      return fromCodePoint.apply(void 0, codePoints);
    };
    Parser3.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      var ch = this.char();
      if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return fromCodePoint(ch);
      }
    };
    Parser3.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
      var openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      var value2 = this.parseIdentifierIfPossible().value;
      if (!value2) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value: value2,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value2, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    };
    Parser3.prototype.parseIdentifierIfPossible = function() {
      var startingPosition = this.clonePosition();
      var startOffset = this.offset();
      var value2 = matchIdentifierAtIndex(this.message, startOffset);
      var endOffset = startOffset + value2.length;
      this.bumpTo(endOffset);
      var endPosition = this.clonePosition();
      var location2 = createLocation(startingPosition, endPosition);
      return { value: value2, location: location2 };
    };
    Parser3.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value2, openingBracePosition) {
      var _a5;
      var typeStartPosition = this.clonePosition();
      var argType = this.parseIdentifierIfPossible().value;
      var typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var styleStartPosition = this.clonePosition();
            var result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            var style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = { style, styleLocation };
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_1 = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
            var skeleton = trimStart(styleAndLocation.style.slice(2));
            if (argType === "number") {
              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: { type: TYPE.number, value: value2, location: location_1, style: result.val },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
              }
              var dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              var style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              var type3 = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: { type: type3, value: value2, location: location_1, style },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value: value2,
              location: location_1,
              style: (_a5 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a5 !== void 0 ? _a5 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var typeEndPosition_1 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
          }
          this.bumpSpace();
          var identifierAndLocation = this.parseIdentifierIfPossible();
          var pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_2 = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value: value2,
                options: fromEntries(optionsResult.val),
                location: location_2
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value: value2,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location: location_2
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    };
    Parser3.prototype.tryParseArgumentClose = function(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return { val: true, err: null };
    };
    Parser3.prototype.parseSimpleArgStyleIfPossible = function() {
      var nestedBraces = 0;
      var startPosition = this.clonePosition();
      while (!this.isEOF()) {
        var ch = this.char();
        switch (ch) {
          case 39: {
            this.bump();
            var apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    };
    Parser3.prototype.parseNumberSkeletonFromString = function(skeleton, location2) {
      var tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e4) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location2);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location: location2,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    };
    Parser3.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      var _a5;
      var hasOtherClause = false;
      var options = [];
      var parsedSelectors = /* @__PURE__ */ new Set();
      var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
      while (true) {
        if (selector.length === 0) {
          var startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        var openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options.push([
          selector,
          {
            value: fragmentResult.val,
            location: createLocation(openingBracePosition, this.clonePosition())
          }
        ]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        _a5 = this.parseIdentifierIfPossible(), selector = _a5.value, selectorLocation = _a5.location;
      }
      if (options.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return { val: options, err: null };
    };
    Parser3.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
      var sign = 1;
      var startingPosition = this.clonePosition();
      if (this.bumpIf("+")) {
      } else if (this.bumpIf("-")) {
        sign = -1;
      }
      var hasDigits = false;
      var decimal = 0;
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch >= 48 && ch <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch - 48);
          this.bump();
        } else {
          break;
        }
      }
      var location2 = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location2);
      }
      decimal *= sign;
      if (!isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location2);
      }
      return { val: decimal, err: null };
    };
    Parser3.prototype.offset = function() {
      return this.position.offset;
    };
    Parser3.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    };
    Parser3.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    };
    Parser3.prototype.char = function() {
      var offset = this.position.offset;
      if (offset >= this.message.length) {
        throw Error("out of bound");
      }
      var code = codePointAt(this.message, offset);
      if (code === void 0) {
        throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
      }
      return code;
    };
    Parser3.prototype.error = function(kind, location2) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location: location2
        }
      };
    };
    Parser3.prototype.bump = function() {
      if (this.isEOF()) {
        return;
      }
      var code = this.char();
      if (code === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code < 65536 ? 1 : 2;
      }
    };
    Parser3.prototype.bumpIf = function(prefix4) {
      if (startsWith(this.message, prefix4, this.offset())) {
        for (var i4 = 0; i4 < prefix4.length; i4++) {
          this.bump();
        }
        return true;
      }
      return false;
    };
    Parser3.prototype.bumpUntil = function(pattern) {
      var currentOffset = this.offset();
      var index2 = this.message.indexOf(pattern, currentOffset);
      if (index2 >= 0) {
        this.bumpTo(index2);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    };
    Parser3.prototype.bumpTo = function(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        var offset = this.offset();
        if (offset === targetOffset) {
          break;
        }
        if (offset > targetOffset) {
          throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    };
    Parser3.prototype.bumpSpace = function() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    };
    Parser3.prototype.peek = function() {
      if (this.isEOF()) {
        return null;
      }
      var code = this.char();
      var offset = this.offset();
      var nextCode = this.message.charCodeAt(offset + (code >= 65536 ? 2 : 1));
      return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser3;
  }()
);
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c6) {
  return c6 === 45 || c6 === 46 || c6 >= 48 && c6 <= 57 || c6 === 95 || c6 >= 97 && c6 <= 122 || c6 >= 65 && c6 <= 90 || c6 == 183 || c6 >= 192 && c6 <= 214 || c6 >= 216 && c6 <= 246 || c6 >= 248 && c6 <= 893 || c6 >= 895 && c6 <= 8191 || c6 >= 8204 && c6 <= 8205 || c6 >= 8255 && c6 <= 8256 || c6 >= 8304 && c6 <= 8591 || c6 >= 11264 && c6 <= 12271 || c6 >= 12289 && c6 <= 55295 || c6 >= 63744 && c6 <= 64975 || c6 >= 65008 && c6 <= 65533 || c6 >= 65536 && c6 <= 983039;
}
function _isWhiteSpace(c6) {
  return c6 >= 9 && c6 <= 13 || c6 === 32 || c6 === 133 || c6 >= 8206 && c6 <= 8207 || c6 === 8232 || c6 === 8233;
}
function _isPatternSyntax(c6) {
  return c6 >= 33 && c6 <= 35 || c6 === 36 || c6 >= 37 && c6 <= 39 || c6 === 40 || c6 === 41 || c6 === 42 || c6 === 43 || c6 === 44 || c6 === 45 || c6 >= 46 && c6 <= 47 || c6 >= 58 && c6 <= 59 || c6 >= 60 && c6 <= 62 || c6 >= 63 && c6 <= 64 || c6 === 91 || c6 === 92 || c6 === 93 || c6 === 94 || c6 === 96 || c6 === 123 || c6 === 124 || c6 === 125 || c6 === 126 || c6 === 161 || c6 >= 162 && c6 <= 165 || c6 === 166 || c6 === 167 || c6 === 169 || c6 === 171 || c6 === 172 || c6 === 174 || c6 === 176 || c6 === 177 || c6 === 182 || c6 === 187 || c6 === 191 || c6 === 215 || c6 === 247 || c6 >= 8208 && c6 <= 8213 || c6 >= 8214 && c6 <= 8215 || c6 === 8216 || c6 === 8217 || c6 === 8218 || c6 >= 8219 && c6 <= 8220 || c6 === 8221 || c6 === 8222 || c6 === 8223 || c6 >= 8224 && c6 <= 8231 || c6 >= 8240 && c6 <= 8248 || c6 === 8249 || c6 === 8250 || c6 >= 8251 && c6 <= 8254 || c6 >= 8257 && c6 <= 8259 || c6 === 8260 || c6 === 8261 || c6 === 8262 || c6 >= 8263 && c6 <= 8273 || c6 === 8274 || c6 === 8275 || c6 >= 8277 && c6 <= 8286 || c6 >= 8592 && c6 <= 8596 || c6 >= 8597 && c6 <= 8601 || c6 >= 8602 && c6 <= 8603 || c6 >= 8604 && c6 <= 8607 || c6 === 8608 || c6 >= 8609 && c6 <= 8610 || c6 === 8611 || c6 >= 8612 && c6 <= 8613 || c6 === 8614 || c6 >= 8615 && c6 <= 8621 || c6 === 8622 || c6 >= 8623 && c6 <= 8653 || c6 >= 8654 && c6 <= 8655 || c6 >= 8656 && c6 <= 8657 || c6 === 8658 || c6 === 8659 || c6 === 8660 || c6 >= 8661 && c6 <= 8691 || c6 >= 8692 && c6 <= 8959 || c6 >= 8960 && c6 <= 8967 || c6 === 8968 || c6 === 8969 || c6 === 8970 || c6 === 8971 || c6 >= 8972 && c6 <= 8991 || c6 >= 8992 && c6 <= 8993 || c6 >= 8994 && c6 <= 9e3 || c6 === 9001 || c6 === 9002 || c6 >= 9003 && c6 <= 9083 || c6 === 9084 || c6 >= 9085 && c6 <= 9114 || c6 >= 9115 && c6 <= 9139 || c6 >= 9140 && c6 <= 9179 || c6 >= 9180 && c6 <= 9185 || c6 >= 9186 && c6 <= 9254 || c6 >= 9255 && c6 <= 9279 || c6 >= 9280 && c6 <= 9290 || c6 >= 9291 && c6 <= 9311 || c6 >= 9472 && c6 <= 9654 || c6 === 9655 || c6 >= 9656 && c6 <= 9664 || c6 === 9665 || c6 >= 9666 && c6 <= 9719 || c6 >= 9720 && c6 <= 9727 || c6 >= 9728 && c6 <= 9838 || c6 === 9839 || c6 >= 9840 && c6 <= 10087 || c6 === 10088 || c6 === 10089 || c6 === 10090 || c6 === 10091 || c6 === 10092 || c6 === 10093 || c6 === 10094 || c6 === 10095 || c6 === 10096 || c6 === 10097 || c6 === 10098 || c6 === 10099 || c6 === 10100 || c6 === 10101 || c6 >= 10132 && c6 <= 10175 || c6 >= 10176 && c6 <= 10180 || c6 === 10181 || c6 === 10182 || c6 >= 10183 && c6 <= 10213 || c6 === 10214 || c6 === 10215 || c6 === 10216 || c6 === 10217 || c6 === 10218 || c6 === 10219 || c6 === 10220 || c6 === 10221 || c6 === 10222 || c6 === 10223 || c6 >= 10224 && c6 <= 10239 || c6 >= 10240 && c6 <= 10495 || c6 >= 10496 && c6 <= 10626 || c6 === 10627 || c6 === 10628 || c6 === 10629 || c6 === 10630 || c6 === 10631 || c6 === 10632 || c6 === 10633 || c6 === 10634 || c6 === 10635 || c6 === 10636 || c6 === 10637 || c6 === 10638 || c6 === 10639 || c6 === 10640 || c6 === 10641 || c6 === 10642 || c6 === 10643 || c6 === 10644 || c6 === 10645 || c6 === 10646 || c6 === 10647 || c6 === 10648 || c6 >= 10649 && c6 <= 10711 || c6 === 10712 || c6 === 10713 || c6 === 10714 || c6 === 10715 || c6 >= 10716 && c6 <= 10747 || c6 === 10748 || c6 === 10749 || c6 >= 10750 && c6 <= 11007 || c6 >= 11008 && c6 <= 11055 || c6 >= 11056 && c6 <= 11076 || c6 >= 11077 && c6 <= 11078 || c6 >= 11079 && c6 <= 11084 || c6 >= 11085 && c6 <= 11123 || c6 >= 11124 && c6 <= 11125 || c6 >= 11126 && c6 <= 11157 || c6 === 11158 || c6 >= 11159 && c6 <= 11263 || c6 >= 11776 && c6 <= 11777 || c6 === 11778 || c6 === 11779 || c6 === 11780 || c6 === 11781 || c6 >= 11782 && c6 <= 11784 || c6 === 11785 || c6 === 11786 || c6 === 11787 || c6 === 11788 || c6 === 11789 || c6 >= 11790 && c6 <= 11798 || c6 === 11799 || c6 >= 11800 && c6 <= 11801 || c6 === 11802 || c6 === 11803 || c6 === 11804 || c6 === 11805 || c6 >= 11806 && c6 <= 11807 || c6 === 11808 || c6 === 11809 || c6 === 11810 || c6 === 11811 || c6 === 11812 || c6 === 11813 || c6 === 11814 || c6 === 11815 || c6 === 11816 || c6 === 11817 || c6 >= 11818 && c6 <= 11822 || c6 === 11823 || c6 >= 11824 && c6 <= 11833 || c6 >= 11834 && c6 <= 11835 || c6 >= 11836 && c6 <= 11839 || c6 === 11840 || c6 === 11841 || c6 === 11842 || c6 >= 11843 && c6 <= 11855 || c6 >= 11856 && c6 <= 11857 || c6 === 11858 || c6 >= 11859 && c6 <= 11903 || c6 >= 12289 && c6 <= 12291 || c6 === 12296 || c6 === 12297 || c6 === 12298 || c6 === 12299 || c6 === 12300 || c6 === 12301 || c6 === 12302 || c6 === 12303 || c6 === 12304 || c6 === 12305 || c6 >= 12306 && c6 <= 12307 || c6 === 12308 || c6 === 12309 || c6 === 12310 || c6 === 12311 || c6 === 12312 || c6 === 12313 || c6 === 12314 || c6 === 12315 || c6 === 12316 || c6 === 12317 || c6 >= 12318 && c6 <= 12319 || c6 === 12320 || c6 === 12336 || c6 === 64830 || c6 === 64831 || c6 >= 65093 && c6 <= 65094;
}

// node_modules/@formatjs/icu-messageformat-parser/lib/index.js
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k2 in el.options) {
        delete el.options[k2].location;
        pruneLocation(el.options[k2].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser(message, opts).parse();
  if (result.err) {
    var error2 = SyntaxError(ErrorKind[result.err.kind]);
    error2.location = result.err.location;
    error2.originalMessage = result.err.message;
    throw error2;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}

// node_modules/intl-messageformat/lib/src/error.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(_super) {
    __extends(FormatError2, _super);
    function FormatError2(msg2, code, originalMessage) {
      var _this = _super.call(this, msg2) || this;
      _this.code = code;
      _this.originalMessage = originalMessage;
      return _this;
    }
    FormatError2.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError2;
  }(Error)
);
var InvalidValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueError2, _super);
    function InvalidValueError2(variableId, value2, options, originalMessage) {
      return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value2, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError2;
  }(FormatError)
);
var InvalidValueTypeError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueTypeError2, _super);
    function InvalidValueTypeError2(value2, type3, originalMessage) {
      return _super.call(this, 'Value for "'.concat(value2, '" must be of type ').concat(type3), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError2;
  }(FormatError)
);
var MissingValueError = (
  /** @class */
  function(_super) {
    __extends(MissingValueError2, _super);
    function MissingValueError2(variableId, originalMessage) {
      return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError2;
  }(FormatError)
);

// node_modules/intl-messageformat/lib/src/formatters.js
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all2, part) {
    var lastPart = all2[all2.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all2.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all2;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value2 = values[varName];
    if (isArgumentElement(el)) {
      if (!value2 || typeof value2 === "string" || typeof value2 === "number") {
        value2 = typeof value2 === "string" || typeof value2 === "number" ? String(value2) : "";
      }
      result.push({
        type: typeof value2 === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value: value2
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value2 = value2 * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children = el.children, value_1 = el.value;
      var formatFn = values[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
      var chunks = formatFn(parts.map(function(p4) {
        return p4.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c6) {
        return {
          type: typeof c6 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c6
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value2] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value2, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value2)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value2 - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value2, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value2 - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}

// node_modules/intl-messageformat/lib/src/core.js
function mergeConfig(c1, c22) {
  if (!c22) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c22 || {}), Object.keys(c1).reduce(function(all2, k2) {
    all2[k2] = __assign(__assign({}, c1[k2]), c22[k2] || {});
    return all2;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all2, k2) {
    all2[k2] = mergeConfig(defaultConfig[k2], configs[k2]);
    return all2;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache(store2) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store2[key];
        },
        set: function(key, value2) {
          store2[key] = value2;
        }
      };
    }
  };
}
function createDefaultFormatters(cache3) {
  if (cache3 === void 0) {
    cache3 = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize(function() {
      var _a5;
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return new ((_a5 = Intl.NumberFormat).bind.apply(_a5, __spreadArray([void 0], args2, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      var _a5;
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return new ((_a5 = Intl.DateTimeFormat).bind.apply(_a5, __spreadArray([void 0], args2, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      var _a5;
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return new ((_a5 = Intl.PluralRules).bind.apply(_a5, __spreadArray([void 0], args2, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function IntlMessageFormat2(message, locales, overrideFormats, opts) {
      if (locales === void 0) {
        locales = IntlMessageFormat2.defaultLocale;
      }
      var _this = this;
      this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      };
      this.format = function(values) {
        var parts = _this.formatToParts(values);
        if (parts.length === 1) {
          return parts[0].value;
        }
        var result = parts.reduce(function(all2, part) {
          if (!all2.length || part.type !== PART_TYPE.literal || typeof all2[all2.length - 1] !== "string") {
            all2.push(part.value);
          } else {
            all2[all2.length - 1] += part.value;
          }
          return all2;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      };
      this.formatToParts = function(values) {
        return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
      };
      this.resolvedOptions = function() {
        var _a6;
        return {
          locale: ((_a6 = _this.resolvedLocale) === null || _a6 === void 0 ? void 0 : _a6.toString()) || Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
        };
      };
      this.getAst = function() {
        return _this.ast;
      };
      this.locales = locales;
      this.resolvedLocale = IntlMessageFormat2.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!IntlMessageFormat2.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        var _a5 = opts || {}, formatters = _a5.formatters, parseOpts = __rest(_a5, ["formatters"]);
        this.ast = IntlMessageFormat2.__parse(message, __assign(__assign({}, parseOpts), { locale: this.resolvedLocale }));
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
      get: function() {
        if (!IntlMessageFormat2.memoizedDefaultLocale) {
          IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
        }
        return IntlMessageFormat2.memoizedDefaultLocale;
      },
      enumerable: false,
      configurable: true
    });
    IntlMessageFormat2.memoizedDefaultLocale = null;
    IntlMessageFormat2.resolveLocale = function(locales) {
      if (typeof Intl.Locale === "undefined") {
        return;
      }
      var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
      if (supportedLocales.length > 0) {
        return new Intl.Locale(supportedLocales[0]);
      }
      return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
    };
    IntlMessageFormat2.__parse = parse;
    IntlMessageFormat2.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    return IntlMessageFormat2;
  }()
);

// node_modules/@react-aria/i18n/dist/useMessageFormatter.mjs
var import_react23 = __toESM(require_react(), 1);

// node_modules/@react-aria/i18n/dist/useListFormatter.mjs
var import_react24 = __toESM(require_react(), 1);

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value2) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value2);
}

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@react-aria/i18n/dist/useDateFormatter.mjs
var import_react25 = __toESM(require_react(), 1);

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch (e4) {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch (e4) {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value2) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value2);
    else res = this.numberFormatter.format(value2);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value2) {
    return this.numberFormatter.formatToParts(value2);
  }
  /** Formats a number range as a string. */
  formatRange(start2, end) {
    if (typeof this.numberFormatter.formatRange === "function")
      return this.numberFormatter.formatRange(start2, end);
    if (end < start2) throw new RangeError("End date must be >= start date");
    return `${this.format(start2)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start2, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function")
      return this.numberFormatter.formatRangeToParts(start2, end);
    if (end < start2) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start2);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p4) => ({
        ...p4,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p4) => ({
        ...p4,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).parse(value2);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value2, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).isValidPartialNumber(value2, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value2) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value2)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value2)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value2) {
    let fullySanitizedValue = this.sanitize(value2);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative2 = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index2 = fullySanitizedValue.indexOf(".");
      if (index2 === -1) index2 = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index2 - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index2 - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index2 - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index2 - 2)}.${fullySanitizedValue.slice(index2 - 2)}`;
      if (isNegative2 > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value2)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value2) {
    value2 = value2.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value2 = value2.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value2 = value2.replace(",", this.symbols.decimal);
        value2 = value2.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value2 = $6c7bd7858deea686$var$replaceAll(value2, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR") value2 = $6c7bd7858deea686$var$replaceAll(value2, ".", String.fromCharCode(8239));
    return value2;
  }
  isValidPartialNumber(value2, minValue = -Infinity, maxValue = Infinity) {
    value2 = this.sanitize(value2);
    if (this.symbols.minusSign && value2.startsWith(this.symbols.minusSign) && minValue < 0) value2 = value2.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value2.startsWith(this.symbols.plusSign) && maxValue > 0) value2 = value2.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value2.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value2.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value2 = $6c7bd7858deea686$var$replaceAll(value2, this.symbols.group, "");
    value2 = value2.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value2 = value2.replace(this.symbols.decimal, "");
    return value2.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n5) => symbolFormatter.formatToParts(n5));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p4) => p4.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p4) => p4.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p4) => p4.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group = (_allParts_find1 = allParts.find((p4) => p4.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p4) => !$6c7bd7858deea686$var$nonLiteralParts.has(p4.type)).map((p4) => $6c7bd7858deea686$var$escapeRegex(p4.value));
  let pluralPartsLiterals = pluralParts.flatMap((p4) => p4.filter((p5) => !$6c7bd7858deea686$var$nonLiteralParts.has(p5.type)).map((p5) => $6c7bd7858deea686$var$escapeRegex(p5.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a3, b2) => b2.length - a3.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d5, i4) => [
    d5,
    i4
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index2 = (d5) => String(indexes.get(d5));
  return {
    minusSign,
    plusSign,
    decimal,
    group,
    literals,
    numeral,
    index: index2
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find2, replace2) {
  if (str.replaceAll)
    return str.replaceAll(find2, replace2);
  return str.split(find2).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string2) {
  return string2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@react-aria/i18n/dist/useNumberFormatter.mjs
var import_react26 = __toESM(require_react(), 1);
function $a916eb452884faea$export$b7a616150fdb9f44(options = {}) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  return (0, import_react26.useMemo)(() => new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, options), [
    locale,
    options
  ]);
}

// node_modules/@react-aria/i18n/dist/useCollator.mjs
var $325a3faab7a68acd$var$cache = /* @__PURE__ */ new Map();
function $325a3faab7a68acd$export$a16aca283550c30d(options) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  if ($325a3faab7a68acd$var$cache.has(cacheKey)) return $325a3faab7a68acd$var$cache.get(cacheKey);
  let formatter = new Intl.Collator(locale, options);
  $325a3faab7a68acd$var$cache.set(cacheKey, formatter);
  return formatter;
}

// node_modules/@react-aria/i18n/dist/useFilter.mjs
var import_react27 = __toESM(require_react(), 1);
function $bb77f239b46e8c72$export$3274cf84b703fff(options) {
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    ...options
  });
  let startsWith4 = (0, import_react27.useCallback)((string2, substring) => {
    if (substring.length === 0) return true;
    string2 = string2.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.compare(string2.slice(0, substring.length), substring) === 0;
  }, [
    collator
  ]);
  let endsWith = (0, import_react27.useCallback)((string2, substring) => {
    if (substring.length === 0) return true;
    string2 = string2.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.compare(string2.slice(-substring.length), substring) === 0;
  }, [
    collator
  ]);
  let contains = (0, import_react27.useCallback)((string2, substring) => {
    if (substring.length === 0) return true;
    string2 = string2.normalize("NFC");
    substring = substring.normalize("NFC");
    let scan = 0;
    let sliceLen = substring.length;
    for (; scan + sliceLen <= string2.length; scan++) {
      let slice2 = string2.slice(scan, scan + sliceLen);
      if (collator.compare(substring, slice2) === 0) return true;
    }
    return false;
  }, [
    collator
  ]);
  return (0, import_react27.useMemo)(() => ({
    startsWith: startsWith4,
    endsWith,
    contains
  }), [
    startsWith4,
    endsWith,
    contains
  ]);
}

// node_modules/@react-aria/overlays/dist/calculatePosition.mjs
var $edcf132a9284368a$var$AXIS = {
  top: "top",
  bottom: "top",
  left: "left",
  right: "left"
};
var $edcf132a9284368a$var$FLIPPED_DIRECTION = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
var $edcf132a9284368a$var$CROSS_AXIS = {
  top: "left",
  left: "top"
};
var $edcf132a9284368a$var$AXIS_SIZE = {
  top: "height",
  left: "width"
};
var $edcf132a9284368a$var$TOTAL_SIZE = {
  width: "totalWidth",
  height: "totalHeight"
};
var $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE = {};
var $edcf132a9284368a$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $edcf132a9284368a$var$getContainerDimensions(containerNode) {
  let width = 0, height = 0, totalWidth = 0, totalHeight = 0, top = 0, left = 0;
  let scroll = {};
  let isPinchZoomedIn = ($edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.scale) > 1;
  if (containerNode.tagName === "BODY") {
    let documentElement = document.documentElement;
    totalWidth = documentElement.clientWidth;
    totalHeight = documentElement.clientHeight;
    var _visualViewport_width;
    width = (_visualViewport_width = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.width) !== null && _visualViewport_width !== void 0 ? _visualViewport_width : totalWidth;
    var _visualViewport_height;
    height = (_visualViewport_height = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : totalHeight;
    scroll.top = documentElement.scrollTop || containerNode.scrollTop;
    scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;
    if ($edcf132a9284368a$var$visualViewport) {
      top = $edcf132a9284368a$var$visualViewport.offsetTop;
      left = $edcf132a9284368a$var$visualViewport.offsetLeft;
    }
  } else {
    ({ width, height, top, left } = $edcf132a9284368a$var$getOffset(containerNode));
    scroll.top = containerNode.scrollTop;
    scroll.left = containerNode.scrollLeft;
    totalWidth = width;
    totalHeight = height;
  }
  if ((0, $c87311424ea30a05$export$78551043582a6a98)() && (containerNode.tagName === "BODY" || containerNode.tagName === "HTML") && isPinchZoomedIn) {
    scroll.top = 0;
    scroll.left = 0;
    top = $edcf132a9284368a$var$visualViewport.pageTop;
    left = $edcf132a9284368a$var$visualViewport.pageLeft;
  }
  return {
    width,
    height,
    totalWidth,
    totalHeight,
    scroll,
    top,
    left
  };
}
function $edcf132a9284368a$var$getScroll(node2) {
  return {
    top: node2.scrollTop,
    left: node2.scrollLeft,
    width: node2.scrollWidth,
    height: node2.scrollHeight
  };
}
function $edcf132a9284368a$var$getDelta(axis, offset, size3, boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary) {
  let containerScroll = containerDimensions.scroll[axis];
  let boundarySize = boundaryDimensions[$edcf132a9284368a$var$AXIS_SIZE[axis]];
  let boundaryStartEdge = boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] + padding;
  let boundaryEndEdge = boundarySize + boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] - padding;
  let startEdgeOffset = offset - containerScroll + containerOffsetWithBoundary[axis] - boundaryDimensions[$edcf132a9284368a$var$AXIS[axis]];
  let endEdgeOffset = offset - containerScroll + size3 + containerOffsetWithBoundary[axis] - boundaryDimensions[$edcf132a9284368a$var$AXIS[axis]];
  if (startEdgeOffset < boundaryStartEdge) return boundaryStartEdge - startEdgeOffset;
  else if (endEdgeOffset > boundaryEndEdge) return Math.max(boundaryEndEdge - endEdgeOffset, boundaryStartEdge - startEdgeOffset);
  else return 0;
}
function $edcf132a9284368a$var$getMargins(node2) {
  let style = window.getComputedStyle(node2);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}
function $edcf132a9284368a$var$parsePlacement(input) {
  if ($edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input]) return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];
  let [placement, crossPlacement] = input.split(" ");
  let axis = $edcf132a9284368a$var$AXIS[placement] || "right";
  let crossAxis = $edcf132a9284368a$var$CROSS_AXIS[axis];
  if (!$edcf132a9284368a$var$AXIS[crossPlacement]) crossPlacement = "center";
  let size3 = $edcf132a9284368a$var$AXIS_SIZE[axis];
  let crossSize = $edcf132a9284368a$var$AXIS_SIZE[crossAxis];
  $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input] = {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size: size3,
    crossSize
  };
  return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];
}
function $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset) {
  let { placement, crossPlacement, axis, crossAxis, size: size3, crossSize } = placementInfo;
  let position2 = {};
  position2[crossAxis] = childOffset[crossAxis];
  if (crossPlacement === "center")
    position2[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  else if (crossPlacement !== crossAxis)
    position2[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  position2[crossAxis] += crossOffset;
  const minPosition = childOffset[crossAxis] - overlaySize[crossSize] + arrowSize + arrowBoundaryOffset;
  const maxPosition = childOffset[crossAxis] + childOffset[crossSize] - arrowSize - arrowBoundaryOffset;
  position2[crossAxis] = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(position2[crossAxis], minPosition, maxPosition);
  if (placement === axis) {
    const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size3] : boundaryDimensions[$edcf132a9284368a$var$TOTAL_SIZE[size3]];
    position2[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);
  } else position2[axis] = Math.floor(childOffset[axis] + childOffset[size3] + offset);
  return position2;
}
function $edcf132a9284368a$var$getMaxHeight(position2, boundaryDimensions, containerOffsetWithBoundary, isContainerPositioned, margins, padding, overlayHeight, heightGrowthDirection) {
  const containerHeight = isContainerPositioned ? containerOffsetWithBoundary.height : boundaryDimensions[$edcf132a9284368a$var$TOTAL_SIZE.height];
  let overlayTop = position2.top != null ? containerOffsetWithBoundary.top + position2.top : containerOffsetWithBoundary.top + (containerHeight - position2.bottom - overlayHeight);
  let maxHeight = heightGrowthDirection !== "top" ? (
    // We want the distance between the top of the overlay to the bottom of the boundary
    Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - overlayTop - (margins.top + margins.bottom + padding))
  ) : Math.max(0, overlayTop + overlayHeight - (boundaryDimensions.top + boundaryDimensions.scroll.top) - (margins.top + margins.bottom + padding));
  return Math.min(boundaryDimensions.height - padding * 2, maxHeight);
}
function $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  let { placement, axis, size: size3 } = placementInfo;
  if (placement === axis) return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);
  return Math.max(0, boundaryDimensions[size3] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size3] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);
}
function $edcf132a9284368a$export$6839422d1f33cee9(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, userSetMaxHeight, arrowSize, arrowBoundaryOffset) {
  let placementInfo = $edcf132a9284368a$var$parsePlacement(placementInput);
  let { size: size3, crossAxis, crossSize, placement, crossPlacement } = placementInfo;
  let position2 = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
  let normalizedOffset = offset;
  let space3 = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo);
  if (flip && scrollSize[size3] > space3) {
    let flippedPlacementInfo = $edcf132a9284368a$var$parsePlacement(`${$edcf132a9284368a$var$FLIPPED_DIRECTION[placement]} ${crossPlacement}`);
    let flippedPosition = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
    let flippedSpace = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo);
    if (flippedSpace > space3) {
      placementInfo = flippedPlacementInfo;
      position2 = flippedPosition;
      normalizedOffset = offset;
    }
  }
  let heightGrowthDirection = "bottom";
  if (placementInfo.axis === "top") {
    if (placementInfo.placement === "top") heightGrowthDirection = "top";
    else if (placementInfo.placement === "bottom") heightGrowthDirection = "bottom";
  } else if (placementInfo.crossAxis === "top") {
    if (placementInfo.crossPlacement === "top") heightGrowthDirection = "bottom";
    else if (placementInfo.crossPlacement === "bottom") heightGrowthDirection = "top";
  }
  let delta = $edcf132a9284368a$var$getDelta(crossAxis, position2[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);
  position2[crossAxis] += delta;
  let maxHeight = $edcf132a9284368a$var$getMaxHeight(position2, boundaryDimensions, containerOffsetWithBoundary, isContainerPositioned, margins, padding, overlaySize.height, heightGrowthDirection);
  if (userSetMaxHeight && userSetMaxHeight < maxHeight) maxHeight = userSetMaxHeight;
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position2 = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
  delta = $edcf132a9284368a$var$getDelta(crossAxis, position2[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);
  position2[crossAxis] += delta;
  let arrowPosition = {};
  let preferredArrowPosition = childOffset[crossAxis] + 0.5 * childOffset[crossSize] - position2[crossAxis] - margins[$edcf132a9284368a$var$AXIS[crossAxis]];
  const arrowMinPosition = arrowSize / 2 + arrowBoundaryOffset;
  const overlayMargin = $edcf132a9284368a$var$AXIS[crossAxis] === "left" ? margins.left + margins.right : margins.top + margins.bottom;
  const arrowMaxPosition = overlaySize[crossSize] - overlayMargin - arrowSize / 2 - arrowBoundaryOffset;
  const arrowOverlappingChildMinEdge = childOffset[crossAxis] + arrowSize / 2 - (position2[crossAxis] + margins[$edcf132a9284368a$var$AXIS[crossAxis]]);
  const arrowOverlappingChildMaxEdge = childOffset[crossAxis] + childOffset[crossSize] - arrowSize / 2 - (position2[crossAxis] + margins[$edcf132a9284368a$var$AXIS[crossAxis]]);
  const arrowPositionOverlappingChild = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(preferredArrowPosition, arrowOverlappingChildMinEdge, arrowOverlappingChildMaxEdge);
  arrowPosition[crossAxis] = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(arrowPositionOverlappingChild, arrowMinPosition, arrowMaxPosition);
  return {
    position: position2,
    maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}
function $edcf132a9284368a$export$b3ceb0cbf1056d98(opts) {
  let { placement, targetNode, overlayNode, scrollNode, padding, shouldFlip, boundaryElement, offset, crossOffset, maxHeight, arrowSize = 0, arrowBoundaryOffset = 0 } = opts;
  let container = overlayNode instanceof HTMLElement ? $edcf132a9284368a$var$getContainingBlock(overlayNode) : document.documentElement;
  let isViewportContainer = container === document.documentElement;
  const containerPositionStyle = window.getComputedStyle(container).position;
  let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== "static";
  let childOffset = isViewportContainer ? $edcf132a9284368a$var$getOffset(targetNode) : $edcf132a9284368a$var$getPosition(targetNode, container);
  if (!isViewportContainer) {
    let { marginTop, marginLeft } = window.getComputedStyle(targetNode);
    childOffset.top += parseInt(marginTop, 10) || 0;
    childOffset.left += parseInt(marginLeft, 10) || 0;
  }
  let overlaySize = $edcf132a9284368a$var$getOffset(overlayNode);
  let margins = $edcf132a9284368a$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  let scrollSize = $edcf132a9284368a$var$getScroll(scrollNode);
  let boundaryDimensions = $edcf132a9284368a$var$getContainerDimensions(boundaryElement);
  let containerDimensions = $edcf132a9284368a$var$getContainerDimensions(container);
  let containerOffsetWithBoundary = boundaryElement.tagName === "BODY" ? $edcf132a9284368a$var$getOffset(container) : $edcf132a9284368a$var$getPosition(container, boundaryElement);
  if (container.tagName === "HTML" && boundaryElement.tagName === "BODY") {
    containerDimensions.scroll.top = 0;
    containerDimensions.scroll.left = 0;
  }
  return $edcf132a9284368a$export$6839422d1f33cee9(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, maxHeight, arrowSize, arrowBoundaryOffset);
}
function $edcf132a9284368a$var$getOffset(node2) {
  let { top, left, width, height } = node2.getBoundingClientRect();
  let { scrollTop, scrollLeft, clientTop, clientLeft } = document.documentElement;
  return {
    top: top + scrollTop - clientTop,
    left: left + scrollLeft - clientLeft,
    width,
    height
  };
}
function $edcf132a9284368a$var$getPosition(node2, parent) {
  let style = window.getComputedStyle(node2);
  let offset;
  if (style.position === "fixed") {
    let { top, left, width, height } = node2.getBoundingClientRect();
    offset = {
      top,
      left,
      width,
      height
    };
  } else {
    offset = $edcf132a9284368a$var$getOffset(node2);
    let parentOffset = $edcf132a9284368a$var$getOffset(parent);
    let parentStyle = window.getComputedStyle(parent);
    parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;
    parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;
    offset.top -= parentOffset.top;
    offset.left -= parentOffset.left;
  }
  offset.top -= parseInt(style.marginTop, 10) || 0;
  offset.left -= parseInt(style.marginLeft, 10) || 0;
  return offset;
}
function $edcf132a9284368a$var$getContainingBlock(node2) {
  let offsetParent = node2.offsetParent;
  if (offsetParent && offsetParent === document.body && window.getComputedStyle(offsetParent).position === "static" && !$edcf132a9284368a$var$isContainingBlock(offsetParent)) offsetParent = document.documentElement;
  if (offsetParent == null) {
    offsetParent = node2.parentElement;
    while (offsetParent && !$edcf132a9284368a$var$isContainingBlock(offsetParent)) offsetParent = offsetParent.parentElement;
  }
  return offsetParent || document.documentElement;
}
function $edcf132a9284368a$var$isContainingBlock(node2) {
  let style = window.getComputedStyle(node2);
  return style.transform !== "none" || /transform|perspective/.test(style.willChange) || style.filter !== "none" || style.contain === "paint" || // @ts-ignore
  "backdropFilter" in style && style.backdropFilter !== "none" || // @ts-ignore
  "WebkitBackdropFilter" in style && style.WebkitBackdropFilter !== "none";
}

// node_modules/@react-aria/overlays/dist/useCloseOnScroll.mjs
var import_react28 = __toESM(require_react(), 1);
var $dd149f63282afbbf$export$f6211563215e3b37 = /* @__PURE__ */ new WeakMap();
function $dd149f63282afbbf$export$18fc8428861184da(opts) {
  let { triggerRef, isOpen, onClose } = opts;
  (0, import_react28.useEffect)(() => {
    if (!isOpen || onClose === null) return;
    let onScroll = (e4) => {
      let target = e4.target;
      if (!triggerRef.current || target instanceof Node && !target.contains(triggerRef.current)) return;
      if (e4.target instanceof HTMLInputElement || e4.target instanceof HTMLTextAreaElement) return;
      let onCloseHandler = onClose || $dd149f63282afbbf$export$f6211563215e3b37.get(triggerRef.current);
      if (onCloseHandler) onCloseHandler();
    };
    window.addEventListener("scroll", onScroll, true);
    return () => {
      window.removeEventListener("scroll", onScroll, true);
    };
  }, [
    isOpen,
    onClose,
    triggerRef
  ]);
}

// node_modules/@react-aria/overlays/dist/useOverlayPosition.mjs
var import_react29 = __toESM(require_react(), 1);
var $2a41e45df1593e64$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $2a41e45df1593e64$export$d39e1813b3bdd0e1(props) {
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { arrowSize = 0, targetRef, overlayRef, scrollRef = overlayRef, placement = "bottom", containerPadding = 12, shouldFlip = true, boundaryElement = typeof document !== "undefined" ? document.body : null, offset = 0, crossOffset = 0, shouldUpdatePosition = true, isOpen = true, onClose, maxHeight, arrowBoundaryOffset = 0 } = props;
  let [position2, setPosition] = (0, import_react29.useState)({
    position: {},
    arrowOffsetLeft: void 0,
    arrowOffsetTop: void 0,
    maxHeight: void 0,
    placement: void 0
  });
  let deps = [
    shouldUpdatePosition,
    placement,
    overlayRef.current,
    targetRef.current,
    scrollRef.current,
    containerPadding,
    shouldFlip,
    boundaryElement,
    offset,
    crossOffset,
    isOpen,
    direction,
    maxHeight,
    arrowBoundaryOffset,
    arrowSize
  ];
  let lastScale = (0, import_react29.useRef)($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale);
  (0, import_react29.useEffect)(() => {
    if (isOpen) lastScale.current = $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale;
  }, [
    isOpen
  ]);
  let updatePosition = (0, import_react29.useCallback)(() => {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !boundaryElement) return;
    if (($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale) !== lastScale.current) return;
    let anchor = null;
    if (scrollRef.current && scrollRef.current.contains(document.activeElement)) {
      let anchorRect = document.activeElement.getBoundingClientRect();
      let scrollRect = scrollRef.current.getBoundingClientRect();
      anchor = {
        type: "top",
        offset: anchorRect.top - scrollRect.top
      };
      if (anchor.offset > scrollRect.height / 2) {
        anchor.type = "bottom";
        anchor.offset = anchorRect.bottom - scrollRect.bottom;
      }
    }
    let overlay = overlayRef.current;
    if (!maxHeight && overlayRef.current) {
      var _window_visualViewport;
      overlay.style.top = "0px";
      overlay.style.bottom = "";
      var _window_visualViewport_height;
      overlay.style.maxHeight = ((_window_visualViewport_height = (_window_visualViewport = window.visualViewport) === null || _window_visualViewport === void 0 ? void 0 : _window_visualViewport.height) !== null && _window_visualViewport_height !== void 0 ? _window_visualViewport_height : window.innerHeight) + "px";
    }
    let position3 = (0, $edcf132a9284368a$export$b3ceb0cbf1056d98)({
      placement: $2a41e45df1593e64$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current || overlayRef.current,
      padding: containerPadding,
      shouldFlip,
      boundaryElement,
      offset,
      crossOffset,
      maxHeight,
      arrowSize,
      arrowBoundaryOffset
    });
    overlay.style.top = "";
    overlay.style.bottom = "";
    overlay.style.left = "";
    overlay.style.right = "";
    Object.keys(position3.position).forEach((key) => overlay.style[key] = position3.position[key] + "px");
    overlay.style.maxHeight = position3.maxHeight != null ? position3.maxHeight + "px" : void 0;
    if (anchor) {
      let anchorRect = document.activeElement.getBoundingClientRect();
      let scrollRect = scrollRef.current.getBoundingClientRect();
      let newOffset = anchorRect[anchor.type] - scrollRect[anchor.type];
      scrollRef.current.scrollTop += newOffset - anchor.offset;
    }
    setPosition(position3);
  }, deps);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updatePosition, deps);
  $2a41e45df1593e64$var$useResize(updatePosition);
  (0, $9daab02d461809db$export$683480f191c0e3ea)({
    ref: overlayRef,
    onResize: updatePosition
  });
  (0, $9daab02d461809db$export$683480f191c0e3ea)({
    ref: targetRef,
    onResize: updatePosition
  });
  let isResizing = (0, import_react29.useRef)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let timeout2;
    let onResize = () => {
      isResizing.current = true;
      clearTimeout(timeout2);
      timeout2 = setTimeout(() => {
        isResizing.current = false;
      }, 500);
      updatePosition();
    };
    let onScroll = () => {
      if (isResizing.current) onResize();
    };
    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener("resize", onResize);
    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener("scroll", onScroll);
    return () => {
      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener("resize", onResize);
      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener("scroll", onScroll);
    };
  }, [
    updatePosition
  ]);
  let close = (0, import_react29.useCallback)(() => {
    if (!isResizing.current) onClose();
  }, [
    onClose,
    isResizing
  ]);
  (0, $dd149f63282afbbf$export$18fc8428861184da)({
    triggerRef: targetRef,
    isOpen,
    onClose: onClose && close
  });
  var _position_maxHeight;
  return {
    overlayProps: {
      style: {
        position: "absolute",
        zIndex: 1e5,
        ...position2.position,
        maxHeight: (_position_maxHeight = position2.maxHeight) !== null && _position_maxHeight !== void 0 ? _position_maxHeight : "100vh"
      }
    },
    placement: position2.placement,
    arrowProps: {
      "aria-hidden": "true",
      role: "presentation",
      style: {
        left: position2.arrowOffsetLeft,
        top: position2.arrowOffsetTop
      }
    },
    updatePosition
  };
}
function $2a41e45df1593e64$var$useResize(onResize) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    window.addEventListener("resize", onResize, false);
    return () => {
      window.removeEventListener("resize", onResize, false);
    };
  }, [
    onResize
  ]);
}
function $2a41e45df1593e64$var$translateRTL(position2, direction) {
  if (direction === "rtl") return position2.replace("start", "right").replace("end", "left");
  return position2.replace("start", "left").replace("end", "right");
}

// node_modules/@react-aria/interactions/dist/textSelection.mjs
var $14c0b72509d70225$var$state = "default";
var $14c0b72509d70225$var$savedUserSelect = "";
var $14c0b72509d70225$var$modifiedElementMap = /* @__PURE__ */ new WeakMap();
function $14c0b72509d70225$export$16a4697467175487(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) {
    if ($14c0b72509d70225$var$state === "default") {
      const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(target);
      $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;
      documentObject.documentElement.style.webkitUserSelect = "none";
    }
    $14c0b72509d70225$var$state = "disabled";
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
}
function $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) {
    if ($14c0b72509d70225$var$state !== "disabled") return;
    $14c0b72509d70225$var$state = "restoring";
    setTimeout(() => {
      (0, $bbed8b41f857bcc0$export$24490316f764c430)(() => {
        if ($14c0b72509d70225$var$state === "restoring") {
          const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(target);
          if (documentObject.documentElement.style.webkitUserSelect === "none") documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || "";
          $14c0b72509d70225$var$savedUserSelect = "";
          $14c0b72509d70225$var$state = "default";
        }
      });
    }, 300);
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {
      let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);
      if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
      if (target.getAttribute("style") === "") target.removeAttribute("style");
      $14c0b72509d70225$var$modifiedElementMap.delete(target);
    }
  }
}

// node_modules/@react-aria/interactions/dist/context.mjs
var import_react30 = __toESM(require_react(), 1);
var $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, import_react30.default).createContext({
  register: () => {
  }
});
$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = "PressResponderContext";

// node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js
function _class_apply_descriptor_get(receiver, descriptor) {
  if (descriptor.get) return descriptor.get.call(receiver);
  return descriptor.value;
}

// node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}

// node_modules/@swc/helpers/esm/_class_private_field_get.js
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}

// node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js
function _class_apply_descriptor_set(receiver, descriptor, value2) {
  if (descriptor.set) descriptor.set.call(receiver, value2);
  else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value2;
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_set.js
function _class_private_field_set(receiver, privateMap, value2) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  _class_apply_descriptor_set(receiver, descriptor, value2);
  return value2;
}

// node_modules/@react-aria/interactions/dist/usePress.mjs
var import_react31 = __toESM(require_react(), 1);
function $f6c31cce2adf654f$var$usePressResponderContext(props) {
  let context = (0, import_react31.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  if (context) {
    let { register, ...contextProps } = context;
    props = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(contextProps, props);
    register();
  }
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(context, props.ref);
  return props;
}
var $f6c31cce2adf654f$var$_shouldStopPropagation = /* @__PURE__ */ new WeakMap();
var $f6c31cce2adf654f$var$PressEvent = class {
  continuePropagation() {
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);
  }
  get shouldStopPropagation() {
    return (0, _class_private_field_get)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);
  }
  constructor(type3, pointerType, originalEvent, state) {
    (0, _class_private_field_init)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {
      writable: true,
      value: void 0
    });
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);
    var _state_target;
    let currentTarget = (_state_target = state === null || state === void 0 ? void 0 : state.target) !== null && _state_target !== void 0 ? _state_target : originalEvent.currentTarget;
    const rect = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.getBoundingClientRect();
    let x3, y3 = 0;
    let clientX, clientY = null;
    if (originalEvent.clientX != null && originalEvent.clientY != null) {
      clientX = originalEvent.clientX;
      clientY = originalEvent.clientY;
    }
    if (rect) {
      if (clientX != null && clientY != null) {
        x3 = clientX - rect.left;
        y3 = clientY - rect.top;
      } else {
        x3 = rect.width / 2;
        y3 = rect.height / 2;
      }
    }
    this.type = type3;
    this.pointerType = pointerType;
    this.target = originalEvent.currentTarget;
    this.shiftKey = originalEvent.shiftKey;
    this.metaKey = originalEvent.metaKey;
    this.ctrlKey = originalEvent.ctrlKey;
    this.altKey = originalEvent.altKey;
    this.x = x3;
    this.y = y3;
  }
};
var $f6c31cce2adf654f$var$LINK_CLICKED = Symbol("linkClicked");
function $f6c31cce2adf654f$export$45712eceda6fad21(props) {
  let {
    onPress,
    onPressChange,
    onPressStart,
    onPressEnd,
    onPressUp,
    isDisabled,
    isPressed: isPressedProp,
    preventFocusOnPress,
    shouldCancelOnPointerExit,
    allowTextSelectionOnPress,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _2,
    ...domProps
  } = $f6c31cce2adf654f$var$usePressResponderContext(props);
  let [isPressed, setPressed] = (0, import_react31.useState)(false);
  let ref = (0, import_react31.useRef)({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    ignoreClickAfterPress: false,
    didFirePressStart: false,
    isTriggeringEvent: false,
    activePointerId: null,
    target: null,
    isOverTarget: false,
    pointerType: null
  });
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let triggerPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled || state.didFirePressStart) return false;
    let shouldStopPropagation = true;
    state.isTriggeringEvent = true;
    if (onPressStart) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressstart", pointerType, originalEvent);
      onPressStart(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange) onPressChange(true);
    state.isTriggeringEvent = false;
    state.didFirePressStart = true;
    setPressed(true);
    return shouldStopPropagation;
  });
  let triggerPressEnd = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType, wasPressed = true) => {
    let state = ref.current;
    if (!state.didFirePressStart) return false;
    state.ignoreClickAfterPress = true;
    state.didFirePressStart = false;
    state.isTriggeringEvent = true;
    let shouldStopPropagation = true;
    if (onPressEnd) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressend", pointerType, originalEvent);
      onPressEnd(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange) onPressChange(false);
    setPressed(false);
    if (onPress && wasPressed && !isDisabled) {
      let event = new $f6c31cce2adf654f$var$PressEvent("press", pointerType, originalEvent);
      onPress(event);
      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);
    }
    state.isTriggeringEvent = false;
    return shouldStopPropagation;
  });
  let triggerPressUp = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled) return false;
    if (onPressUp) {
      state.isTriggeringEvent = true;
      let event = new $f6c31cce2adf654f$var$PressEvent("pressup", pointerType, originalEvent);
      onPressUp(event);
      state.isTriggeringEvent = false;
      return event.shouldStopPropagation;
    }
    return true;
  });
  let cancel = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    let state = ref.current;
    if (state.isPressed && state.target) {
      if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e4), state.pointerType, false);
      state.isPressed = false;
      state.isOverTarget = false;
      state.activePointerId = null;
      state.pointerType = null;
      removeAllGlobalListeners();
      if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
    }
  });
  let cancelOnPointerExit = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (shouldCancelOnPointerExit) cancel(e4);
  });
  let pressProps = (0, import_react31.useMemo)(() => {
    let state = ref.current;
    let pressProps2 = {
      onKeyDown(e4) {
        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e4.nativeEvent, e4.currentTarget) && e4.currentTarget.contains(e4.target)) {
          var _state_metaKeyEvents;
          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e4.target, e4.key)) e4.preventDefault();
          let shouldStopPropagation = true;
          if (!state.isPressed && !e4.repeat) {
            state.target = e4.currentTarget;
            state.isPressed = true;
            shouldStopPropagation = triggerPressStart(e4, "keyboard");
            let originalTarget = e4.currentTarget;
            let pressUp = (e5) => {
              if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e5, originalTarget) && !e5.repeat && originalTarget.contains(e5.target) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e5), "keyboard");
            };
            addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e4.currentTarget), "keyup", (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(pressUp, onKeyUp), true);
          }
          if (shouldStopPropagation) e4.stopPropagation();
          if (e4.metaKey && (0, $c87311424ea30a05$export$9ac100e40613ea10)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e4.key, e4.nativeEvent);
        } else if (e4.key === "Meta") state.metaKeyEvents = /* @__PURE__ */ new Map();
      },
      onClick(e4) {
        if (e4 && !e4.currentTarget.contains(e4.target)) return;
        if (e4 && e4.button === 0 && !state.isTriggeringEvent && !(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7).isOpening) {
          let shouldStopPropagation = true;
          if (isDisabled) e4.preventDefault();
          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === "virtual" || (0, $6a7db85432448f7f$export$60278871457622de)(e4.nativeEvent))) {
            if (!isDisabled && !preventFocusOnPress) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e4.currentTarget);
            let stopPressStart = triggerPressStart(e4, "virtual");
            let stopPressUp = triggerPressUp(e4, "virtual");
            let stopPressEnd = triggerPressEnd(e4, "virtual");
            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;
          }
          state.ignoreEmulatedMouseEvents = false;
          state.ignoreClickAfterPress = false;
          if (shouldStopPropagation) e4.stopPropagation();
        }
      }
    };
    let onKeyUp = (e4) => {
      var _state_metaKeyEvents;
      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e4, state.target)) {
        var _state_metaKeyEvents1;
        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e4.target, e4.key)) e4.preventDefault();
        let target = e4.target;
        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e4), "keyboard", state.target.contains(target));
        removeAllGlobalListeners();
        if (e4.key !== "Enter" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e4[$f6c31cce2adf654f$var$LINK_CLICKED]) {
          e4[$f6c31cce2adf654f$var$LINK_CLICKED] = true;
          (0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7)(state.target, e4, false);
        }
        state.isPressed = false;
        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e4.key);
      } else if (e4.key === "Meta" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {
        var _state_target;
        let events2 = state.metaKeyEvents;
        state.metaKeyEvents = void 0;
        for (let event of events2.values()) (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent("keyup", event));
      }
    };
    if (typeof PointerEvent !== "undefined") {
      pressProps2.onPointerDown = (e4) => {
        if (e4.button !== 0 || !e4.currentTarget.contains(e4.target)) return;
        if ((0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e4.nativeEvent)) {
          state.pointerType = "virtual";
          return;
        }
        if ($f6c31cce2adf654f$var$shouldPreventDefaultDown(e4.currentTarget)) e4.preventDefault();
        state.pointerType = e4.pointerType;
        let shouldStopPropagation = true;
        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e4.pointerId;
          state.target = e4.currentTarget;
          if (!isDisabled && !preventFocusOnPress) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e4.currentTarget);
          if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
          shouldStopPropagation = triggerPressStart(e4, state.pointerType);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e4.currentTarget), "pointermove", onPointerMove, false);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e4.currentTarget), "pointerup", onPointerUp, false);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e4.currentTarget), "pointercancel", onPointerCancel, false);
        }
        if (shouldStopPropagation) e4.stopPropagation();
      };
      pressProps2.onMouseDown = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        if (e4.button === 0) {
          if ($f6c31cce2adf654f$var$shouldPreventDefaultDown(e4.currentTarget)) e4.preventDefault();
          e4.stopPropagation();
        }
      };
      pressProps2.onPointerUp = (e4) => {
        if (!e4.currentTarget.contains(e4.target) || state.pointerType === "virtual") return;
        if (e4.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e4, e4.currentTarget)) triggerPressUp(e4, state.pointerType || e4.pointerType);
      };
      let onPointerMove = (e4) => {
        if (e4.pointerId !== state.activePointerId) return;
        if (state.target && $f6c31cce2adf654f$var$isOverTarget(e4, state.target)) {
          if (!state.isOverTarget && state.pointerType != null) {
            state.isOverTarget = true;
            triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e4), state.pointerType);
          }
        } else if (state.target && state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e4), state.pointerType, false);
          cancelOnPointerExit(e4);
        }
      };
      let onPointerUp = (e4) => {
        if (e4.pointerId === state.activePointerId && state.isPressed && e4.button === 0 && state.target) {
          if ($f6c31cce2adf654f$var$isOverTarget(e4, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e4), state.pointerType);
          else if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e4), state.pointerType, false);
          state.isPressed = false;
          state.isOverTarget = false;
          state.activePointerId = null;
          state.pointerType = null;
          removeAllGlobalListeners();
          if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
          if ("ontouchend" in state.target && e4.pointerType !== "mouse") addGlobalListener(state.target, "touchend", onTouchEnd, {
            once: true
          });
        }
      };
      let onTouchEnd = (e4) => {
        if ($f6c31cce2adf654f$var$shouldPreventDefaultUp(e4.currentTarget)) e4.preventDefault();
      };
      let onPointerCancel = (e4) => {
        cancel(e4);
      };
      pressProps2.onDragStart = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        cancel(e4);
      };
    } else {
      pressProps2.onMouseDown = (e4) => {
        if (e4.button !== 0 || !e4.currentTarget.contains(e4.target)) return;
        if ($f6c31cce2adf654f$var$shouldPreventDefaultDown(e4.currentTarget)) e4.preventDefault();
        if (state.ignoreEmulatedMouseEvents) {
          e4.stopPropagation();
          return;
        }
        state.isPressed = true;
        state.isOverTarget = true;
        state.target = e4.currentTarget;
        state.pointerType = (0, $6a7db85432448f7f$export$60278871457622de)(e4.nativeEvent) ? "virtual" : "mouse";
        if (!isDisabled && !preventFocusOnPress) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e4.currentTarget);
        let shouldStopPropagation = triggerPressStart(e4, state.pointerType);
        if (shouldStopPropagation) e4.stopPropagation();
        addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e4.currentTarget), "mouseup", onMouseUp, false);
      };
      pressProps2.onMouseEnter = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = true;
          shouldStopPropagation = triggerPressStart(e4, state.pointerType);
        }
        if (shouldStopPropagation) e4.stopPropagation();
      };
      pressProps2.onMouseLeave = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd(e4, state.pointerType, false);
          cancelOnPointerExit(e4);
        }
        if (shouldStopPropagation) e4.stopPropagation();
      };
      pressProps2.onMouseUp = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        if (!state.ignoreEmulatedMouseEvents && e4.button === 0) triggerPressUp(e4, state.pointerType || "mouse");
      };
      let onMouseUp = (e4) => {
        if (e4.button !== 0) return;
        state.isPressed = false;
        removeAllGlobalListeners();
        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
          return;
        }
        if (state.target && $f6c31cce2adf654f$var$isOverTarget(e4, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e4), state.pointerType);
        else if (state.target && state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e4), state.pointerType, false);
        state.isOverTarget = false;
      };
      pressProps2.onTouchStart = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e4.nativeEvent);
        if (!touch) return;
        state.activePointerId = touch.identifier;
        state.ignoreEmulatedMouseEvents = true;
        state.isOverTarget = true;
        state.isPressed = true;
        state.target = e4.currentTarget;
        state.pointerType = "touch";
        if (!isDisabled && !preventFocusOnPress) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e4.currentTarget);
        if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
        let shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e4), state.pointerType);
        if (shouldStopPropagation) e4.stopPropagation();
        addGlobalListener((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e4.currentTarget), "scroll", onScroll, true);
      };
      pressProps2.onTouchMove = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        if (!state.isPressed) {
          e4.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e4.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e4.currentTarget)) {
          if (!state.isOverTarget && state.pointerType != null) {
            state.isOverTarget = true;
            shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e4), state.pointerType);
          }
        } else if (state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e4), state.pointerType, false);
          cancelOnPointerExit($f6c31cce2adf654f$var$createTouchEvent(state.target, e4));
        }
        if (shouldStopPropagation) e4.stopPropagation();
      };
      pressProps2.onTouchEnd = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        if (!state.isPressed) {
          e4.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e4.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e4.currentTarget) && state.pointerType != null) {
          triggerPressUp($f6c31cce2adf654f$var$createTouchEvent(state.target, e4), state.pointerType);
          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e4), state.pointerType);
        } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e4), state.pointerType, false);
        if (shouldStopPropagation) e4.stopPropagation();
        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        state.ignoreEmulatedMouseEvents = true;
        if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
        removeAllGlobalListeners();
      };
      pressProps2.onTouchCancel = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        e4.stopPropagation();
        if (state.isPressed) cancel($f6c31cce2adf654f$var$createTouchEvent(state.target, e4));
      };
      let onScroll = (e4) => {
        if (state.isPressed && e4.target.contains(state.target)) cancel({
          currentTarget: state.target,
          shiftKey: false,
          ctrlKey: false,
          metaKey: false,
          altKey: false
        });
      };
      pressProps2.onDragStart = (e4) => {
        if (!e4.currentTarget.contains(e4.target)) return;
        cancel(e4);
      };
    }
    return pressProps2;
  }, [
    addGlobalListener,
    isDisabled,
    preventFocusOnPress,
    removeAllGlobalListeners,
    allowTextSelectionOnPress,
    cancel,
    cancelOnPointerExit,
    triggerPressEnd,
    triggerPressStart,
    triggerPressUp
  ]);
  (0, import_react31.useEffect)(() => {
    return () => {
      var _ref_current_target;
      if (!allowTextSelectionOnPress)
        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : void 0);
    };
  }, [
    allowTextSelectionOnPress
  ]);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, pressProps)
  };
}
function $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {
  const { key, code } = event;
  const element2 = currentTarget;
  const role = element2.getAttribute("role");
  return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element2 instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element2).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element2, key) || element2 instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element2).HTMLTextAreaElement || element2.isContentEditable) && // Links should only trigger with Enter key
  !((role === "link" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element2)) && key !== "Enter");
}
function $f6c31cce2adf654f$var$getTouchFromEvent(event) {
  const { targetTouches } = event;
  if (targetTouches.length > 0) return targetTouches[0];
  return null;
}
function $f6c31cce2adf654f$var$getTouchById(event, pointerId) {
  const changedTouches = event.changedTouches;
  for (let i4 = 0; i4 < changedTouches.length; i4++) {
    const touch = changedTouches[i4];
    if (touch.identifier === pointerId) return touch;
  }
  return null;
}
function $f6c31cce2adf654f$var$createTouchEvent(target, e4) {
  let clientX = 0;
  let clientY = 0;
  if (e4.targetTouches && e4.targetTouches.length === 1) {
    clientX = e4.targetTouches[0].clientX;
    clientY = e4.targetTouches[0].clientY;
  }
  return {
    currentTarget: target,
    shiftKey: e4.shiftKey,
    ctrlKey: e4.ctrlKey,
    metaKey: e4.metaKey,
    altKey: e4.altKey,
    clientX,
    clientY
  };
}
function $f6c31cce2adf654f$var$createEvent(target, e4) {
  let clientX = e4.clientX;
  let clientY = e4.clientY;
  return {
    currentTarget: target,
    shiftKey: e4.shiftKey,
    ctrlKey: e4.ctrlKey,
    metaKey: e4.metaKey,
    altKey: e4.altKey,
    clientX,
    clientY
  };
}
function $f6c31cce2adf654f$var$getPointClientRect(point) {
  let offsetX = 0;
  let offsetY = 0;
  if (point.width !== void 0) offsetX = point.width / 2;
  else if (point.radiusX !== void 0) offsetX = point.radiusX;
  if (point.height !== void 0) offsetY = point.height / 2;
  else if (point.radiusY !== void 0) offsetY = point.radiusY;
  return {
    top: point.clientY - offsetY,
    right: point.clientX + offsetX,
    bottom: point.clientY + offsetY,
    left: point.clientX - offsetX
  };
}
function $f6c31cce2adf654f$var$areRectanglesOverlapping(a3, b2) {
  if (a3.left > b2.right || b2.left > a3.right) return false;
  if (a3.top > b2.bottom || b2.top > a3.bottom) return false;
  return true;
}
function $f6c31cce2adf654f$var$isOverTarget(point, target) {
  let rect = target.getBoundingClientRect();
  let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);
  return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);
}
function $f6c31cce2adf654f$var$shouldPreventDefaultDown(target) {
  return !(target instanceof HTMLElement) || !target.hasAttribute("draggable");
}
function $f6c31cce2adf654f$var$shouldPreventDefaultUp(target) {
  if (target instanceof HTMLInputElement) return false;
  if (target instanceof HTMLButtonElement) return target.type !== "submit" && target.type !== "reset";
  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;
  return true;
}
function $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {
  if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);
  return $f6c31cce2adf654f$var$shouldPreventDefaultUp(target);
}
var $f6c31cce2adf654f$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $f6c31cce2adf654f$var$isValidInputKey(target, key) {
  return target.type === "checkbox" || target.type === "radio" ? key === " " : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);
}

// node_modules/@react-aria/interactions/dist/Pressable.mjs
var import_react32 = __toESM(require_react(), 1);
var $3b117e43dc0ca95d$export$27c701ed9e449e99 = (0, import_react32.default).forwardRef(({ children, ...props }, ref) => {
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    ...props,
    ref
  });
  let child = (0, import_react32.default).Children.only(children);
  return (0, import_react32.default).cloneElement(
    child,
    // @ts-ignore
    {
      ref,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(child.props, pressProps)
    }
  );
});

// node_modules/@react-aria/interactions/dist/PressResponder.mjs
var import_react33 = __toESM(require_react(), 1);
var $f1ab8c75478c6f73$export$3351871ee4b288b8 = (0, import_react33.default).forwardRef(({ children, ...props }, ref) => {
  let isRegistered = (0, import_react33.useRef)(false);
  let prevContext = (0, import_react33.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));
  let context = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(prevContext || {}, {
    ...props,
    ref,
    register() {
      isRegistered.current = true;
      if (prevContext) prevContext.register();
    }
  });
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(prevContext, ref);
  (0, import_react33.useEffect)(() => {
    if (!isRegistered.current) {
      console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
      isRegistered.current = true;
    }
  }, []);
  return (0, import_react33.default).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
    value: context
  }, children);
});
function $f1ab8c75478c6f73$export$cf75428e0b9ed1ea({ children }) {
  let context = (0, import_react33.useMemo)(() => ({
    register: () => {
    }
  }), []);
  return (0, import_react33.default).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
    value: context
  }, children);
}

// node_modules/@react-aria/interactions/dist/utils.mjs
var import_react34 = __toESM(require_react(), 1);
var $8a9cb279dc87e130$export$905e7fc544a71f36 = class {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = true;
    this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation();
    this.isPropagationStopped = () => true;
  }
  isPropagationStopped() {
    return false;
  }
  persist() {
  }
  constructor(type3, nativeEvent) {
    this.nativeEvent = nativeEvent;
    this.target = nativeEvent.target;
    this.currentTarget = nativeEvent.currentTarget;
    this.relatedTarget = nativeEvent.relatedTarget;
    this.bubbles = nativeEvent.bubbles;
    this.cancelable = nativeEvent.cancelable;
    this.defaultPrevented = nativeEvent.defaultPrevented;
    this.eventPhase = nativeEvent.eventPhase;
    this.isTrusted = nativeEvent.isTrusted;
    this.timeStamp = nativeEvent.timeStamp;
    this.type = type3;
  }
};
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = (0, import_react34.useRef)({
    isFocused: false,
    observer: null
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  let dispatchBlur = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e4);
  });
  return (0, import_react34.useCallback)((e4) => {
    if (e4.target instanceof HTMLButtonElement || e4.target instanceof HTMLInputElement || e4.target instanceof HTMLTextAreaElement || e4.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e4.target;
      let onBlurHandler = (e5) => {
        stateRef.current.isFocused = false;
        if (target.disabled)
          dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", e5));
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}

// node_modules/@react-aria/interactions/dist/useFocus.mjs
var import_react35 = __toESM(require_react(), 1);
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = (0, import_react35.useCallback)((e4) => {
    if (e4.target === e4.currentTarget) {
      if (onBlurProp) onBlurProp(e4);
      if (onFocusChange) onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  const onFocus = (0, import_react35.useCallback)((e4) => {
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(e4.target);
    if (e4.target === e4.currentTarget && ownerDocument.activeElement === e4.target) {
      if (onFocusProp) onFocusProp(e4);
      if (onFocusChange) onFocusChange(true);
      onSyntheticFocus(e4);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}

// node_modules/@react-aria/interactions/dist/useFocusVisible.mjs
var import_react36 = __toESM(require_react(), 1);
var $507fabe10e71c6fb$var$currentModality = null;
var $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
var $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
var $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
var $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
var $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e4) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e4);
}
function $507fabe10e71c6fb$var$isValidKey(e4) {
  return !(e4.metaKey || !(0, $c87311424ea30a05$export$9ac100e40613ea10)() && e4.altKey || e4.ctrlKey || e4.key === "Control" || e4.key === "Shift" || e4.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e4) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if ($507fabe10e71c6fb$var$isValidKey(e4)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e4);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e4) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  if (e4.type === "mousedown" || e4.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e4);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e4) {
  if ((0, $6a7db85432448f7f$export$60278871457622de)(e4)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e4) {
  if (e4.target === window || e4.target === document) return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e4);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element2) {
  if (typeof window === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element2))) return;
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element2);
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element2);
  let focus = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element2);
  }, {
    once: true
  });
  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus
  });
}
var $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element2, loadListener) => {
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element2);
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element2);
  if (loadListener) documentObject.removeEventListener("DOMContentLoaded", loadListener);
  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
  documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element2) {
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element2);
  let loadListener;
  if (documentObject.readyState !== "loading") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element2);
  else {
    loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element2);
    };
    documentObject.addEventListener("DOMContentLoaded", loadListener);
  }
  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element2, loadListener);
}
if (typeof document !== "undefined") $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
function $507fabe10e71c6fb$export$630ff653c5ada6a9() {
  return $507fabe10e71c6fb$var$currentModality;
}
function $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {
  $507fabe10e71c6fb$var$currentModality = modality;
  $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);
}
function $507fabe10e71c6fb$export$98e20ec92f614cfe() {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  let [modality, setModality] = (0, import_react36.useState)($507fabe10e71c6fb$var$currentModality);
  (0, import_react36.useEffect)(() => {
    let handler = () => {
      setModality($507fabe10e71c6fb$var$currentModality);
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, []);
  return (0, $b5e257d569688ac6$export$535bd6ca7f90a273)() ? null : modality;
}
var $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e4) {
  var _e_target;
  const IHTMLInputElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e4 === null || e4 === void 0 ? void 0 : e4.target).HTMLInputElement : HTMLInputElement;
  const IHTMLTextAreaElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e4 === null || e4 === void 0 ? void 0 : e4.target).HTMLTextAreaElement : HTMLTextAreaElement;
  const IHTMLElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e4 === null || e4 === void 0 ? void 0 : e4.target).HTMLElement : HTMLElement;
  const IKeyboardEvent = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e4 === null || e4 === void 0 ? void 0 : e4.target).KeyboardEvent : KeyboardEvent;
  isTextInput = isTextInput || (e4 === null || e4 === void 0 ? void 0 : e4.target) instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e4 === null || e4 === void 0 ? void 0 : (_e_target = e4.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e4 === null || e4 === void 0 ? void 0 : e4.target) instanceof IHTMLTextAreaElement || (e4 === null || e4 === void 0 ? void 0 : e4.target) instanceof IHTMLElement && (e4 === null || e4 === void 0 ? void 0 : e4.target.isContentEditable);
  return !(isTextInput && modality === "keyboard" && e4 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e4.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn2, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  (0, import_react36.useEffect)(() => {
    let handler = (modality, e4) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e4)) return;
      fn2($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}

// node_modules/@react-aria/interactions/dist/useFocusWithin.mjs
var import_react37 = __toESM(require_react(), 1);
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = (0, import_react37.useRef)({
    isFocusWithin: false
  });
  let onBlur = (0, import_react37.useCallback)((e4) => {
    if (state.current.isFocusWithin && !e4.currentTarget.contains(e4.relatedTarget)) {
      state.current.isFocusWithin = false;
      if (onBlurWithin) onBlurWithin(e4);
      if (onFocusWithinChange) onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state
  ]);
  let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  let onFocus = (0, import_react37.useCallback)((e4) => {
    if (!state.current.isFocusWithin && document.activeElement === e4.target) {
      if (onFocusWithin) onFocusWithin(e4);
      if (onFocusWithinChange) onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e4);
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus
  ]);
  if (isDisabled) return {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}

// node_modules/@react-aria/interactions/dist/useHover.mjs
var import_react38 = __toESM(require_react(), 1);
var $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
var $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e4) {
  if (e4.pointerType === "touch") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined") return;
  if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  else document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0) return;
    if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;
  let [isHovered, setHovered] = (0, import_react38.useState)(false);
  let state = (0, import_react38.useRef)({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  (0, import_react38.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { hoverProps, triggerHoverEnd } = (0, import_react38.useMemo)(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      if (onHoverStart) onHoverStart({
        type: "hoverstart",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered) return;
      state.isHovered = false;
      let target = event.currentTarget;
      if (onHoverEnd) onHoverEnd({
        type: "hoverend",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e4) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e4.pointerType === "mouse") return;
        triggerHoverStart(e4, e4.pointerType);
      };
      hoverProps2.onPointerLeave = (e4) => {
        if (!isDisabled && e4.currentTarget.contains(e4.target)) triggerHoverEnd2(e4, e4.pointerType);
      };
    } else {
      hoverProps2.onTouchStart = () => {
        state.ignoreEmulatedMouseEvents = true;
      };
      hoverProps2.onMouseEnter = (e4) => {
        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e4, "mouse");
        state.ignoreEmulatedMouseEvents = false;
      };
      hoverProps2.onMouseLeave = (e4) => {
        if (!isDisabled && e4.currentTarget.contains(e4.target)) triggerHoverEnd2(e4, "mouse");
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state
  ]);
  (0, import_react38.useEffect)(() => {
    if (isDisabled) triggerHoverEnd({
      currentTarget: state.target
    }, state.pointerType);
  }, [
    isDisabled
  ]);
  return {
    hoverProps,
    isHovered
  };
}

// node_modules/@react-aria/interactions/dist/useInteractOutside.mjs
var import_react39 = __toESM(require_react(), 1);
function $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {
  let { ref, onInteractOutside, isDisabled, onInteractOutsideStart } = props;
  let stateRef = (0, import_react39.useRef)({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  let onPointerDown = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e4, ref)) {
      if (onInteractOutsideStart) onInteractOutsideStart(e4);
      stateRef.current.isPointerDown = true;
    }
  });
  let triggerInteractOutside = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (onInteractOutside) onInteractOutside(e4);
  });
  (0, import_react39.useEffect)(() => {
    let state = stateRef.current;
    if (isDisabled) return;
    const element2 = ref.current;
    const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element2);
    if (typeof PointerEvent !== "undefined") {
      let onPointerUp = (e4) => {
        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e4, ref)) triggerInteractOutside(e4);
        state.isPointerDown = false;
      };
      documentObject.addEventListener("pointerdown", onPointerDown, true);
      documentObject.addEventListener("pointerup", onPointerUp, true);
      return () => {
        documentObject.removeEventListener("pointerdown", onPointerDown, true);
        documentObject.removeEventListener("pointerup", onPointerUp, true);
      };
    } else {
      let onMouseUp = (e4) => {
        if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
        else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e4, ref)) triggerInteractOutside(e4);
        state.isPointerDown = false;
      };
      let onTouchEnd = (e4) => {
        state.ignoreEmulatedMouseEvents = true;
        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e4, ref)) triggerInteractOutside(e4);
        state.isPointerDown = false;
      };
      documentObject.addEventListener("mousedown", onPointerDown, true);
      documentObject.addEventListener("mouseup", onMouseUp, true);
      documentObject.addEventListener("touchstart", onPointerDown, true);
      documentObject.addEventListener("touchend", onTouchEnd, true);
      return () => {
        documentObject.removeEventListener("mousedown", onPointerDown, true);
        documentObject.removeEventListener("mouseup", onMouseUp, true);
        documentObject.removeEventListener("touchstart", onPointerDown, true);
        documentObject.removeEventListener("touchend", onTouchEnd, true);
      };
    }
  }, [
    ref,
    isDisabled,
    onPointerDown,
    triggerInteractOutside
  ]);
}
function $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {
  if (event.button > 0) return false;
  if (event.target) {
    const ownerDocument = event.target.ownerDocument;
    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
    if (event.target.closest("[data-react-aria-top-layer]")) return false;
  }
  return ref.current && !ref.current.contains(event.target);
}

// node_modules/@react-aria/interactions/dist/createEventHandler.mjs
function $93925083ecbb358c$export$48d1ea6320830260(handler) {
  if (!handler) return void 0;
  let shouldStopPropagation = true;
  return (e4) => {
    let event = {
      ...e4,
      preventDefault() {
        e4.preventDefault();
      },
      isDefaultPrevented() {
        return e4.isDefaultPrevented();
      },
      stopPropagation() {
        console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
      },
      continuePropagation() {
        shouldStopPropagation = false;
      }
    };
    handler(event);
    if (shouldStopPropagation) e4.stopPropagation();
  };
}

// node_modules/@react-aria/interactions/dist/useKeyboard.mjs
function $46d819fcbaf35654$export$8f71654801c2f7cd(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),
      onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)
    }
  };
}

// node_modules/@react-aria/interactions/dist/useMove.mjs
var import_react40 = __toESM(require_react(), 1);
function $e8a7022cf87cba2a$export$36da96379f79f245(props) {
  let { onMoveStart, onMove, onMoveEnd } = props;
  let state = (0, import_react40.useRef)({
    didMove: false,
    lastPosition: null,
    id: null
  });
  let { addGlobalListener, removeGlobalListener } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let move = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType, deltaX, deltaY) => {
    if (deltaX === 0 && deltaY === 0) return;
    if (!state.current.didMove) {
      state.current.didMove = true;
      onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
        type: "movestart",
        pointerType,
        shiftKey: originalEvent.shiftKey,
        metaKey: originalEvent.metaKey,
        ctrlKey: originalEvent.ctrlKey,
        altKey: originalEvent.altKey
      });
    }
    onMove === null || onMove === void 0 ? void 0 : onMove({
      type: "move",
      pointerType,
      deltaX,
      deltaY,
      shiftKey: originalEvent.shiftKey,
      metaKey: originalEvent.metaKey,
      ctrlKey: originalEvent.ctrlKey,
      altKey: originalEvent.altKey
    });
  });
  let end = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)();
    if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
      type: "moveend",
      pointerType,
      shiftKey: originalEvent.shiftKey,
      metaKey: originalEvent.metaKey,
      ctrlKey: originalEvent.ctrlKey,
      altKey: originalEvent.altKey
    });
  });
  let moveProps = (0, import_react40.useMemo)(() => {
    let moveProps2 = {};
    let start2 = () => {
      (0, $14c0b72509d70225$export$16a4697467175487)();
      state.current.didMove = false;
    };
    if (typeof PointerEvent === "undefined") {
      let onMouseMove = (e4) => {
        if (e4.button === 0) {
          var _state_current_lastPosition, _state_current_lastPosition1;
          var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;
          move(e4, "mouse", e4.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e4.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));
          state.current.lastPosition = {
            pageX: e4.pageX,
            pageY: e4.pageY
          };
        }
      };
      let onMouseUp = (e4) => {
        if (e4.button === 0) {
          end(e4, "mouse");
          removeGlobalListener(window, "mousemove", onMouseMove, false);
          removeGlobalListener(window, "mouseup", onMouseUp, false);
        }
      };
      moveProps2.onMouseDown = (e4) => {
        if (e4.button === 0) {
          start2();
          e4.stopPropagation();
          e4.preventDefault();
          state.current.lastPosition = {
            pageX: e4.pageX,
            pageY: e4.pageY
          };
          addGlobalListener(window, "mousemove", onMouseMove, false);
          addGlobalListener(window, "mouseup", onMouseUp, false);
        }
      };
      let onTouchMove = (e4) => {
        let touch = [
          ...e4.changedTouches
        ].findIndex(({ identifier: identifier2 }) => identifier2 === state.current.id);
        if (touch >= 0) {
          var _state_current_lastPosition, _state_current_lastPosition1;
          let { pageX, pageY } = e4.changedTouches[touch];
          var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;
          move(e4, "touch", pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));
          state.current.lastPosition = {
            pageX,
            pageY
          };
        }
      };
      let onTouchEnd = (e4) => {
        let touch = [
          ...e4.changedTouches
        ].findIndex(({ identifier: identifier2 }) => identifier2 === state.current.id);
        if (touch >= 0) {
          end(e4, "touch");
          state.current.id = null;
          removeGlobalListener(window, "touchmove", onTouchMove);
          removeGlobalListener(window, "touchend", onTouchEnd);
          removeGlobalListener(window, "touchcancel", onTouchEnd);
        }
      };
      moveProps2.onTouchStart = (e4) => {
        if (e4.changedTouches.length === 0 || state.current.id != null) return;
        let { pageX, pageY, identifier: identifier2 } = e4.changedTouches[0];
        start2();
        e4.stopPropagation();
        e4.preventDefault();
        state.current.lastPosition = {
          pageX,
          pageY
        };
        state.current.id = identifier2;
        addGlobalListener(window, "touchmove", onTouchMove, false);
        addGlobalListener(window, "touchend", onTouchEnd, false);
        addGlobalListener(window, "touchcancel", onTouchEnd, false);
      };
    } else {
      let onPointerMove = (e4) => {
        if (e4.pointerId === state.current.id) {
          var _state_current_lastPosition, _state_current_lastPosition1;
          let pointerType = e4.pointerType || "mouse";
          var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;
          move(e4, pointerType, e4.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e4.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));
          state.current.lastPosition = {
            pageX: e4.pageX,
            pageY: e4.pageY
          };
        }
      };
      let onPointerUp = (e4) => {
        if (e4.pointerId === state.current.id) {
          let pointerType = e4.pointerType || "mouse";
          end(e4, pointerType);
          state.current.id = null;
          removeGlobalListener(window, "pointermove", onPointerMove, false);
          removeGlobalListener(window, "pointerup", onPointerUp, false);
          removeGlobalListener(window, "pointercancel", onPointerUp, false);
        }
      };
      moveProps2.onPointerDown = (e4) => {
        if (e4.button === 0 && state.current.id == null) {
          start2();
          e4.stopPropagation();
          e4.preventDefault();
          state.current.lastPosition = {
            pageX: e4.pageX,
            pageY: e4.pageY
          };
          state.current.id = e4.pointerId;
          addGlobalListener(window, "pointermove", onPointerMove, false);
          addGlobalListener(window, "pointerup", onPointerUp, false);
          addGlobalListener(window, "pointercancel", onPointerUp, false);
        }
      };
    }
    let triggerKeyboardMove = (e4, deltaX, deltaY) => {
      start2();
      move(e4, "keyboard", deltaX, deltaY);
      end(e4, "keyboard");
    };
    moveProps2.onKeyDown = (e4) => {
      switch (e4.key) {
        case "Left":
        case "ArrowLeft":
          e4.preventDefault();
          e4.stopPropagation();
          triggerKeyboardMove(e4, -1, 0);
          break;
        case "Right":
        case "ArrowRight":
          e4.preventDefault();
          e4.stopPropagation();
          triggerKeyboardMove(e4, 1, 0);
          break;
        case "Up":
        case "ArrowUp":
          e4.preventDefault();
          e4.stopPropagation();
          triggerKeyboardMove(e4, 0, -1);
          break;
        case "Down":
        case "ArrowDown":
          e4.preventDefault();
          e4.stopPropagation();
          triggerKeyboardMove(e4, 0, 1);
          break;
      }
    };
    return moveProps2;
  }, [
    state,
    addGlobalListener,
    removeGlobalListener,
    move,
    end
  ]);
  return {
    moveProps
  };
}

// node_modules/@react-aria/interactions/dist/useScrollWheel.mjs
var import_react41 = __toESM(require_react(), 1);
function $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {
  let { onScroll, isDisabled } = props;
  let onScrollHandler = (0, import_react41.useCallback)((e4) => {
    if (e4.ctrlKey) return;
    e4.preventDefault();
    e4.stopPropagation();
    if (onScroll) onScroll({
      deltaX: e4.deltaX,
      deltaY: e4.deltaY
    });
  }, [
    onScroll
  ]);
  (0, $e9faafb641e167db$export$90fc3a17d93f704c)(ref, "wheel", isDisabled ? void 0 : onScrollHandler);
}

// node_modules/@react-aria/interactions/dist/useLongPress.mjs
var import_react42 = __toESM(require_react(), 1);
var $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;
function $8a26561d2877236e$export$c24ed0104d07eab9(props) {
  let { isDisabled, onLongPressStart, onLongPressEnd, onLongPress, threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD, accessibilityDescription } = props;
  const timeRef = (0, import_react42.useRef)(void 0);
  let { addGlobalListener, removeGlobalListener } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled,
    onPressStart(e4) {
      e4.continuePropagation();
      if (e4.pointerType === "mouse" || e4.pointerType === "touch") {
        if (onLongPressStart) onLongPressStart({
          ...e4,
          type: "longpressstart"
        });
        timeRef.current = setTimeout(() => {
          e4.target.dispatchEvent(new PointerEvent("pointercancel", {
            bubbles: true
          }));
          if (onLongPress) onLongPress({
            ...e4,
            type: "longpress"
          });
          timeRef.current = void 0;
        }, threshold);
        if (e4.pointerType === "touch") {
          let onContextMenu = (e5) => {
            e5.preventDefault();
          };
          addGlobalListener(e4.target, "contextmenu", onContextMenu, {
            once: true
          });
          addGlobalListener(window, "pointerup", () => {
            setTimeout(() => {
              removeGlobalListener(e4.target, "contextmenu", onContextMenu);
            }, 30);
          }, {
            once: true
          });
        }
      }
    },
    onPressEnd(e4) {
      if (timeRef.current) clearTimeout(timeRef.current);
      if (onLongPressEnd && (e4.pointerType === "mouse" || e4.pointerType === "touch")) onLongPressEnd({
        ...e4,
        type: "longpressend"
      });
    }
  });
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(onLongPress && !isDisabled ? accessibilityDescription : void 0);
  return {
    longPressProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, descriptionProps)
  };
}

// node_modules/@react-aria/focus/dist/focusSafely.mjs
function $6a99195332edec8b$export$80f3e147d781571c(element2) {
  const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element2);
  if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "virtual") {
    let lastFocusedElement = ownerDocument.activeElement;
    (0, $bbed8b41f857bcc0$export$24490316f764c430)(() => {
      if (ownerDocument.activeElement === lastFocusedElement && element2.isConnected) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element2);
    });
  } else (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element2);
}

// node_modules/@react-aria/focus/dist/isElementVisible.mjs
function $645f2e67b85a24c9$var$isStyleVisible(element2) {
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element2);
  if (!(element2 instanceof windowObject.HTMLElement) && !(element2 instanceof windowObject.SVGElement)) return false;
  let { display, visibility } = element2.style;
  let isVisible2 = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
  if (isVisible2) {
    const { getComputedStyle: getComputedStyle2 } = element2.ownerDocument.defaultView;
    let { display: computedDisplay, visibility: computedVisibility } = getComputedStyle2(element2);
    isVisible2 = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
  }
  return isVisible2;
}
function $645f2e67b85a24c9$var$isAttributeVisible(element2, childElement) {
  return !element2.hasAttribute("hidden") && // Ignore HiddenSelect when tree walking.
  !element2.hasAttribute("data-react-aria-prevent-focus") && (element2.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element2.hasAttribute("open") : true);
}
function $645f2e67b85a24c9$export$e989c0fffaa6b27a(element2, childElement) {
  return element2.nodeName !== "#comment" && $645f2e67b85a24c9$var$isStyleVisible(element2) && $645f2e67b85a24c9$var$isAttributeVisible(element2, childElement) && (!element2.parentElement || $645f2e67b85a24c9$export$e989c0fffaa6b27a(element2.parentElement, element2));
}

// node_modules/@react-aria/focus/dist/FocusScope.mjs
var import_react43 = __toESM(require_react(), 1);
var $9bf71ea28793e738$var$FocusContext = (0, import_react43.default).createContext(null);
var $9bf71ea28793e738$var$RESTORE_FOCUS_EVENT = "react-aria-focus-scope-restore";
var $9bf71ea28793e738$var$activeScope = null;
function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
  let { children, contain, restoreFocus, autoFocus } = props;
  let startRef = (0, import_react43.useRef)(null);
  let endRef = (0, import_react43.useRef)(null);
  let scopeRef = (0, import_react43.useRef)([]);
  let { parentNode } = (0, import_react43.useContext)($9bf71ea28793e738$var$FocusContext) || {};
  let node2 = (0, import_react43.useMemo)(() => new $9bf71ea28793e738$var$TreeNode({
    scopeRef
  }), [
    scopeRef
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let parent = parentNode || $9bf71ea28793e738$export$d06fae2ee68b101e.root;
    if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, parent.scopeRef)) {
      let activeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
      if (activeNode) parent = activeNode;
    }
    parent.addChild(node2);
    $9bf71ea28793e738$export$d06fae2ee68b101e.addNode(node2);
  }, [
    node2,
    parentNode
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let node3 = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
    if (node3) node3.contain = !!contain;
  }, [
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    var _startRef_current;
    let node3 = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;
    let nodes = [];
    let stopPropagation = (e4) => e4.stopPropagation();
    while (node3 && node3 !== endRef.current) {
      nodes.push(node3);
      node3.addEventListener($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, stopPropagation);
      node3 = node3.nextSibling;
    }
    scopeRef.current = nodes;
    return () => {
      for (let node4 of nodes) node4.removeEventListener($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, stopPropagation);
    };
  }, [
    children
  ]);
  $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
  $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);
  $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);
  $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);
  (0, import_react43.useEffect)(() => {
    const activeElement = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0).activeElement;
    let scope = null;
    if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {
      for (let node3 of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse()) if (node3.scopeRef && $9bf71ea28793e738$var$isElementInScope(activeElement, node3.scopeRef.current)) scope = node3;
      if (scope === $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $9bf71ea28793e738$var$activeScope = scope.scopeRef;
    }
  }, [
    scopeRef
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      var _focusScopeTree_getTreeNode_parent, _focusScopeTree_getTreeNode;
      var _focusScopeTree_getTreeNode_parent_scopeRef;
      let parentScope = (_focusScopeTree_getTreeNode_parent_scopeRef = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : (_focusScopeTree_getTreeNode_parent = _focusScopeTree_getTreeNode.parent) === null || _focusScopeTree_getTreeNode_parent === void 0 ? void 0 : _focusScopeTree_getTreeNode_parent.scopeRef) !== null && _focusScopeTree_getTreeNode_parent_scopeRef !== void 0 ? _focusScopeTree_getTreeNode_parent_scopeRef : null;
      if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope))) $9bf71ea28793e738$var$activeScope = parentScope;
      $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
    };
  }, [
    scopeRef
  ]);
  let focusManager = (0, import_react43.useMemo)(() => $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef), []);
  let value2 = (0, import_react43.useMemo)(() => ({
    focusManager,
    parentNode: node2
  }), [
    node2,
    focusManager
  ]);
  return (0, import_react43.default).createElement($9bf71ea28793e738$var$FocusContext.Provider, {
    value: value2
  }, (0, import_react43.default).createElement("span", {
    "data-focus-scope-start": true,
    hidden: true,
    ref: startRef
  }), children, (0, import_react43.default).createElement("span", {
    "data-focus-scope-end": true,
    hidden: true,
    ref: endRef
  }));
}
function $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {
  return {
    focusNext(opts = {}) {
      let scope = scopeRef.current;
      let { from: from4, tabbable, wrap: wrap3, accept } = opts;
      let node2 = from4 || (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope[0]).activeElement;
      let sentinel = scope[0].previousElementSibling;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node2, scope) ? node2 : sentinel;
      let nextNode = walker.nextNode();
      if (!nextNode && wrap3) {
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
      }
      if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusPrevious(opts = {}) {
      let scope = scopeRef.current;
      let { from: from4, tabbable, wrap: wrap3, accept } = opts;
      let node2 = from4 || (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope[0]).activeElement;
      let sentinel = scope[scope.length - 1].nextElementSibling;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node2, scope) ? node2 : sentinel;
      let previousNode = walker.previousNode();
      if (!previousNode && wrap3) {
        walker.currentNode = sentinel;
        previousNode = walker.previousNode();
      }
      if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode;
    },
    focusFirst(opts = {}) {
      let scope = scopeRef.current;
      let { tabbable, accept } = opts;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = scope[0].previousElementSibling;
      let nextNode = walker.nextNode();
      if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusLast(opts = {}) {
      let scope = scopeRef.current;
      let { tabbable, accept } = opts;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = scope[scope.length - 1].nextElementSibling;
      let previousNode = walker.previousNode();
      if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode;
    }
  };
}
var $9bf71ea28793e738$var$focusableElements = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
];
var $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
var $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $9bf71ea28793e738$var$getScopeRoot(scope) {
  return scope[0].parentElement;
}
function $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {
  let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
  while (scope && scope.scopeRef !== scopeRef) {
    if (scope.contain) return false;
    scope = scope.parent;
  }
  return true;
}
function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
  let focusedNode = (0, import_react43.useRef)(void 0);
  let raf = (0, import_react43.useRef)(void 0);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let scope = scopeRef.current;
    if (!contain) {
      if (raf.current) {
        cancelAnimationFrame(raf.current);
        raf.current = void 0;
      }
      return;
    }
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope ? scope[0] : void 0);
    let onKeyDown = (e4) => {
      if (e4.key !== "Tab" || e4.altKey || e4.ctrlKey || e4.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef) || e4.isComposing) return;
      let focusedElement = ownerDocument.activeElement;
      let scope2 = scopeRef.current;
      if (!scope2 || !$9bf71ea28793e738$var$isElementInScope(focusedElement, scope2)) return;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope2);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable: true
      }, scope2);
      if (!focusedElement) return;
      walker.currentNode = focusedElement;
      let nextElement = e4.shiftKey ? walker.previousNode() : walker.nextNode();
      if (!nextElement) {
        walker.currentNode = e4.shiftKey ? scope2[scope2.length - 1].nextElementSibling : scope2[0].previousElementSibling;
        nextElement = e4.shiftKey ? walker.previousNode() : walker.nextNode();
      }
      e4.preventDefault();
      if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);
    };
    let onFocus = (e4) => {
      if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e4.target, scopeRef.current)) {
        $9bf71ea28793e738$var$activeScope = scopeRef;
        focusedNode.current = e4.target;
      } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e4.target, scopeRef)) {
        if (focusedNode.current) focusedNode.current.focus();
        else if ($9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);
      } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef)) focusedNode.current = e4.target;
    };
    let onBlur = (e4) => {
      if (raf.current) cancelAnimationFrame(raf.current);
      raf.current = requestAnimationFrame(() => {
        if (ownerDocument.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(ownerDocument.activeElement, scopeRef)) {
          $9bf71ea28793e738$var$activeScope = scopeRef;
          if (ownerDocument.body.contains(e4.target)) {
            var _focusedNode_current;
            focusedNode.current = e4.target;
            (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();
          } else if ($9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);
        }
      });
    };
    ownerDocument.addEventListener("keydown", onKeyDown, false);
    ownerDocument.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.addEventListener("focusin", onFocus, false));
    scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.addEventListener("focusout", onBlur, false));
    return () => {
      ownerDocument.removeEventListener("keydown", onKeyDown, false);
      ownerDocument.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.removeEventListener("focusin", onFocus, false));
      scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.removeEventListener("focusout", onBlur, false));
    };
  }, [
    scopeRef,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      if (raf.current) cancelAnimationFrame(raf.current);
    };
  }, [
    raf
  ]);
}
function $9bf71ea28793e738$var$isElementInAnyScope(element2) {
  return $9bf71ea28793e738$var$isElementInChildScope(element2);
}
function $9bf71ea28793e738$var$isElementInScope(element2, scope) {
  if (!element2) return false;
  if (!scope) return false;
  return scope.some((node2) => node2.contains(element2));
}
function $9bf71ea28793e738$var$isElementInChildScope(element2, scope = null) {
  if (element2 instanceof Element && element2.closest("[data-react-aria-top-layer]")) return true;
  for (let { scopeRef: s4 } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))) {
    if (s4 && $9bf71ea28793e738$var$isElementInScope(element2, s4.current)) return true;
  }
  return false;
}
function $9bf71ea28793e738$export$1258395f99bf9cbf(element2) {
  return $9bf71ea28793e738$var$isElementInChildScope(element2, $9bf71ea28793e738$var$activeScope);
}
function $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {
  var _focusScopeTree_getTreeNode;
  let parent = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
  while (parent) {
    if (parent.scopeRef === ancestor) return true;
    parent = parent.parent;
  }
  return false;
}
function $9bf71ea28793e738$var$focusElement(element2, scroll = false) {
  if (element2 != null && !scroll) try {
    (0, $6a99195332edec8b$export$80f3e147d781571c)(element2);
  } catch (err) {
  }
  else if (element2 != null) try {
    element2.focus();
  } catch (err) {
  }
}
function $9bf71ea28793e738$var$getFirstInScope(scope, tabbable = true) {
  let sentinel = scope[0].previousElementSibling;
  let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
  let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
    tabbable
  }, scope);
  walker.currentNode = sentinel;
  let nextNode = walker.nextNode();
  if (tabbable && !nextNode) {
    scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
    walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
      tabbable: false
    }, scope);
    walker.currentNode = sentinel;
    nextNode = walker.nextNode();
  }
  return nextNode;
}
function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
  $9bf71ea28793e738$var$focusElement($9bf71ea28793e738$var$getFirstInScope(scope, tabbable));
}
function $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {
  const autoFocusRef = (0, import_react43.default).useRef(autoFocus);
  (0, import_react43.useEffect)(() => {
    if (autoFocusRef.current) {
      $9bf71ea28793e738$var$activeScope = scopeRef;
      const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0);
      if (!$9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, $9bf71ea28793e738$var$activeScope.current) && scopeRef.current) $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);
    }
    autoFocusRef.current = false;
  }, [
    scopeRef
  ]);
}
function $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (restore || contain) return;
    let scope = scopeRef.current;
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope ? scope[0] : void 0);
    let onFocus = (e4) => {
      let target = e4.target;
      if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;
      else if (!$9bf71ea28793e738$var$isElementInAnyScope(target)) $9bf71ea28793e738$var$activeScope = null;
    };
    ownerDocument.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.addEventListener("focusin", onFocus, false));
    return () => {
      ownerDocument.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.removeEventListener("focusin", onFocus, false));
    };
  }, [
    scopeRef,
    restore,
    contain
  ]);
}
function $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {
  let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
  while (scope && scope.scopeRef !== scopeRef) {
    if (scope.nodeToRestore) return false;
    scope = scope.parent;
  }
  return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
  const nodeToRestoreRef = (0, import_react43.useRef)(typeof document !== "undefined" ? (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0).activeElement : null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let scope = scopeRef.current;
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scope ? scope[0] : void 0);
    if (!restoreFocus || contain) return;
    let onFocus = () => {
      if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;
    };
    ownerDocument.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.addEventListener("focusin", onFocus, false));
    return () => {
      ownerDocument.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.removeEventListener("focusin", onFocus, false));
    };
  }, [
    scopeRef,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0);
    if (!restoreFocus) return;
    let onKeyDown = (e4) => {
      if (e4.key !== "Tab" || e4.altKey || e4.ctrlKey || e4.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef) || e4.isComposing) return;
      let focusedElement = ownerDocument.activeElement;
      if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current)) return;
      let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
      if (!treeNode) return;
      let nodeToRestore = treeNode.nodeToRestore;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(ownerDocument.body, {
        tabbable: true
      });
      walker.currentNode = focusedElement;
      let nextElement = e4.shiftKey ? walker.previousNode() : walker.nextNode();
      if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {
        nodeToRestore = void 0;
        treeNode.nodeToRestore = void 0;
      }
      if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
        walker.currentNode = nodeToRestore;
        do
          nextElement = e4.shiftKey ? walker.previousNode() : walker.nextNode();
        while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current));
        e4.preventDefault();
        e4.stopPropagation();
        if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);
        else if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
        else $9bf71ea28793e738$var$focusElement(nodeToRestore, true);
      }
    };
    if (!contain) ownerDocument.addEventListener("keydown", onKeyDown, true);
    return () => {
      if (!contain) ownerDocument.removeEventListener("keydown", onKeyDown, true);
    };
  }, [
    scopeRef,
    restoreFocus,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(scopeRef.current ? scopeRef.current[0] : void 0);
    if (!restoreFocus) return;
    let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
    if (!treeNode) return;
    var _nodeToRestoreRef_current;
    treeNode.nodeToRestore = (_nodeToRestoreRef_current = nodeToRestoreRef.current) !== null && _nodeToRestoreRef_current !== void 0 ? _nodeToRestoreRef_current : void 0;
    return () => {
      let treeNode2 = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
      if (!treeNode2) return;
      let nodeToRestore = treeNode2.nodeToRestore;
      if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
      ($9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === ownerDocument.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {
        let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();
        requestAnimationFrame(() => {
          if (ownerDocument.activeElement === ownerDocument.body) {
            let treeNode3 = clonedTree.getTreeNode(scopeRef);
            while (treeNode3) {
              if (treeNode3.nodeToRestore && treeNode3.nodeToRestore.isConnected) {
                $9bf71ea28793e738$var$restoreFocusToElement(treeNode3.nodeToRestore);
                return;
              }
              treeNode3 = treeNode3.parent;
            }
            treeNode3 = clonedTree.getTreeNode(scopeRef);
            while (treeNode3) {
              if (treeNode3.scopeRef && treeNode3.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode3.scopeRef)) {
                let node2 = $9bf71ea28793e738$var$getFirstInScope(treeNode3.scopeRef.current, true);
                $9bf71ea28793e738$var$restoreFocusToElement(node2);
                return;
              }
              treeNode3 = treeNode3.parent;
            }
          }
        });
      }
    };
  }, [
    scopeRef,
    restoreFocus
  ]);
}
function $9bf71ea28793e738$var$restoreFocusToElement(node2) {
  if (node2.dispatchEvent(new CustomEvent($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, {
    bubbles: true,
    cancelable: true
  }))) $9bf71ea28793e738$var$focusElement(node2);
}
function $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {
  let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;
  let walker = (0, $431fbd86ca7dc216$export$b204af158042fbac)(root).createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node2) {
      var _opts_from;
      if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node2)) return NodeFilter.FILTER_REJECT;
      if (node2.matches(selector) && (0, $645f2e67b85a24c9$export$e989c0fffaa6b27a)(node2) && (!scope || $9bf71ea28793e738$var$isElementInScope(node2, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node2))) return NodeFilter.FILTER_ACCEPT;
      return NodeFilter.FILTER_SKIP;
    }
  });
  if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
  return walker;
}
function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
  return {
    focusNext(opts = {}) {
      let root = ref.current;
      if (!root) return null;
      let { from: from4, tabbable = defaultOptions.tabbable, wrap: wrap3 = defaultOptions.wrap, accept = defaultOptions.accept } = opts;
      let node2 = from4 || (0, $431fbd86ca7dc216$export$b204af158042fbac)(root).activeElement;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      if (root.contains(node2)) walker.currentNode = node2;
      let nextNode = walker.nextNode();
      if (!nextNode && wrap3) {
        walker.currentNode = root;
        nextNode = walker.nextNode();
      }
      if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusPrevious(opts = defaultOptions) {
      let root = ref.current;
      if (!root) return null;
      let { from: from4, tabbable = defaultOptions.tabbable, wrap: wrap3 = defaultOptions.wrap, accept = defaultOptions.accept } = opts;
      let node2 = from4 || (0, $431fbd86ca7dc216$export$b204af158042fbac)(root).activeElement;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      if (root.contains(node2)) walker.currentNode = node2;
      else {
        let next2 = $9bf71ea28793e738$var$last(walker);
        if (next2) $9bf71ea28793e738$var$focusElement(next2, true);
        return next2 !== null && next2 !== void 0 ? next2 : null;
      }
      let previousNode = walker.previousNode();
      if (!previousNode && wrap3) {
        walker.currentNode = root;
        let lastNode = $9bf71ea28793e738$var$last(walker);
        if (!lastNode)
          return null;
        previousNode = lastNode;
      }
      if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode !== null && previousNode !== void 0 ? previousNode : null;
    },
    focusFirst(opts = defaultOptions) {
      let root = ref.current;
      if (!root) return null;
      let { tabbable = defaultOptions.tabbable, accept = defaultOptions.accept } = opts;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      let nextNode = walker.nextNode();
      if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusLast(opts = defaultOptions) {
      let root = ref.current;
      if (!root) return null;
      let { tabbable = defaultOptions.tabbable, accept = defaultOptions.accept } = opts;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      let next2 = $9bf71ea28793e738$var$last(walker);
      if (next2) $9bf71ea28793e738$var$focusElement(next2, true);
      return next2 !== null && next2 !== void 0 ? next2 : null;
    }
  };
}
function $9bf71ea28793e738$var$last(walker) {
  let next2 = void 0;
  let last2;
  do {
    last2 = walker.lastChild();
    if (last2) next2 = last2;
  } while (last2);
  return next2;
}
var $9bf71ea28793e738$var$Tree = class _$9bf71ea28793e738$var$Tree {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(data) {
    return this.fastMap.get(data);
  }
  addTreeNode(scopeRef, parent, nodeToRestore) {
    let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
    if (!parentNode) return;
    let node2 = new $9bf71ea28793e738$var$TreeNode({
      scopeRef
    });
    parentNode.addChild(node2);
    node2.parent = parentNode;
    this.fastMap.set(scopeRef, node2);
    if (nodeToRestore) node2.nodeToRestore = nodeToRestore;
  }
  addNode(node2) {
    this.fastMap.set(node2.scopeRef, node2);
  }
  removeTreeNode(scopeRef) {
    if (scopeRef === null) return;
    let node2 = this.fastMap.get(scopeRef);
    if (!node2) return;
    let parentNode = node2.parent;
    for (let current of this.traverse()) if (current !== node2 && node2.nodeToRestore && current.nodeToRestore && node2.scopeRef && node2.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node2.scopeRef.current)) current.nodeToRestore = node2.nodeToRestore;
    let children = node2.children;
    if (parentNode) {
      parentNode.removeChild(node2);
      if (children.size > 0) children.forEach((child) => parentNode && parentNode.addChild(child));
    }
    this.fastMap.delete(node2.scopeRef);
  }
  // Pre Order Depth First
  *traverse(node2 = this.root) {
    if (node2.scopeRef != null) yield node2;
    if (node2.children.size > 0) for (let child of node2.children) yield* this.traverse(child);
  }
  clone() {
    var _node_parent;
    let newTree = new _$9bf71ea28793e738$var$Tree();
    var _node_parent_scopeRef;
    for (let node2 of this.traverse()) newTree.addTreeNode(node2.scopeRef, (_node_parent_scopeRef = (_node_parent = node2.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node2.nodeToRestore);
    return newTree;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map();
    this.root = new $9bf71ea28793e738$var$TreeNode({
      scopeRef: null
    });
    this.fastMap.set(null, this.root);
  }
};
var $9bf71ea28793e738$var$TreeNode = class {
  addChild(node2) {
    this.children.add(node2);
    node2.parent = this;
  }
  removeChild(node2) {
    this.children.delete(node2);
    node2.parent = void 0;
  }
  constructor(props) {
    this.children = /* @__PURE__ */ new Set();
    this.contain = false;
    this.scopeRef = props.scopeRef;
  }
};
var $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();

// node_modules/@react-aria/focus/dist/useFocusRing.mjs
var import_react44 = __toESM(require_react(), 1);
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = (0, import_react44.useRef)({
    isFocused: false,
    isFocusVisible: autoFocus || (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()
  });
  let [isFocused, setFocused] = (0, import_react44.useState)(false);
  let [isFocusVisibleState, setFocusVisible] = (0, import_react44.useState)(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = (0, import_react44.useCallback)(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = (0, import_react44.useCallback)((isFocused2) => {
    state.current.isFocused = isFocused2;
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  (0, $507fabe10e71c6fb$export$ec71b4b83ac08ec3)((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible;
    updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}

// node_modules/@react-aria/focus/dist/FocusRing.mjs
var import_react45 = __toESM(require_react(), 1);
function $907718708eab68af$export$1a38b4ad7f578e1d(props) {
  let { children, focusClass, focusRingClass } = props;
  let { isFocused, isFocusVisible, focusProps } = (0, $f7dceffc5ad7768b$export$4e328f61c538687f)(props);
  let child = (0, import_react45.default).Children.only(children);
  return (0, import_react45.default).cloneElement(child, (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(child.props, {
    ...focusProps,
    className: (0, clsx_default)({
      [focusClass || ""]: isFocused,
      [focusRingClass || ""]: isFocusVisible
    })
  }));
}

// node_modules/@react-aria/focus/dist/useFocusable.mjs
var import_react46 = __toESM(require_react(), 1);
var $e6afbd83fe6ebbd2$var$FocusableContext = (0, import_react46.default).createContext(null);
function $e6afbd83fe6ebbd2$var$useFocusableContext(ref) {
  let context = (0, import_react46.useContext)($e6afbd83fe6ebbd2$var$FocusableContext) || {};
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(context, ref);
  let { ref: _2, ...otherProps } = context;
  return otherProps;
}
function $e6afbd83fe6ebbd2$var$FocusableProvider(props, ref) {
  let { children, ...otherProps } = props;
  let objRef = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let context = {
    ...otherProps,
    ref: objRef
  };
  return (0, import_react46.default).createElement($e6afbd83fe6ebbd2$var$FocusableContext.Provider, {
    value: context
  }, children);
}
var $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 = (0, import_react46.default).forwardRef($e6afbd83fe6ebbd2$var$FocusableProvider);
function $e6afbd83fe6ebbd2$export$4c014de7c8940b4c(props, domRef) {
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)(props);
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)(props);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusProps, keyboardProps);
  let domProps = $e6afbd83fe6ebbd2$var$useFocusableContext(domRef);
  let interactionProps = props.isDisabled ? {} : domProps;
  let autoFocusRef = (0, import_react46.useRef)(props.autoFocus);
  (0, import_react46.useEffect)(() => {
    if (autoFocusRef.current && domRef.current) (0, $6a99195332edec8b$export$80f3e147d781571c)(domRef.current);
    autoFocusRef.current = false;
  }, [
    domRef
  ]);
  return {
    focusableProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)({
      ...interactions,
      tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : void 0
    }, interactionProps)
  };
}

// node_modules/@react-aria/focus/dist/useHasTabbableChild.mjs
var import_react47 = __toESM(require_react(), 1);
function $83013635b024ae3d$export$eac1895992b9f3d6(ref, options) {
  let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
  let [hasTabbableChild, setHasTabbableChild] = (0, import_react47.useState)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
      let update = () => {
        if (ref.current) {
          let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {
            tabbable: true
          });
          setHasTabbableChild(!!walker.nextNode());
        }
      };
      update();
      let observer = new MutationObserver(update);
      observer.observe(ref.current, {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: [
          "tabIndex",
          "disabled"
        ]
      });
      return () => {
        observer.disconnect();
      };
    }
  });
  return isDisabled ? false : hasTabbableChild;
}

// node_modules/@react-aria/overlays/dist/useOverlay.mjs
var import_react48 = __toESM(require_react(), 1);
var $a11501f3d1d39e6c$var$visibleOverlays = [];
function $a11501f3d1d39e6c$export$ea8f71083e90600f(props, ref) {
  let { onClose, shouldCloseOnBlur, isOpen, isDismissable = false, isKeyboardDismissDisabled = false, shouldCloseOnInteractOutside } = props;
  (0, import_react48.useEffect)(() => {
    if (isOpen) $a11501f3d1d39e6c$var$visibleOverlays.push(ref);
    return () => {
      let index2 = $a11501f3d1d39e6c$var$visibleOverlays.indexOf(ref);
      if (index2 >= 0) $a11501f3d1d39e6c$var$visibleOverlays.splice(index2, 1);
    };
  }, [
    isOpen,
    ref
  ]);
  let onHide = () => {
    if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref && onClose) onClose();
  };
  let onInteractOutsideStart = (e4) => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e4.target)) {
      if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {
        e4.stopPropagation();
        e4.preventDefault();
      }
    }
  };
  let onInteractOutside = (e4) => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e4.target)) {
      if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {
        e4.stopPropagation();
        e4.preventDefault();
      }
      onHide();
    }
  };
  let onKeyDown = (e4) => {
    if (e4.key === "Escape" && !isKeyboardDismissDisabled && !e4.nativeEvent.isComposing) {
      e4.stopPropagation();
      e4.preventDefault();
      onHide();
    }
  };
  (0, $e0b6e0b68ec7f50f$export$872b660ac5a1ff98)({
    ref,
    onInteractOutside: isDismissable && isOpen ? onInteractOutside : null,
    onInteractOutsideStart
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: (e4) => {
      if (!e4.relatedTarget || (0, $9bf71ea28793e738$export$1258395f99bf9cbf)(e4.relatedTarget)) return;
      if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e4.relatedTarget)) onClose();
    }
  });
  let onPointerDownUnderlay = (e4) => {
    if (e4.target === e4.currentTarget) e4.preventDefault();
  };
  return {
    overlayProps: {
      onKeyDown,
      ...focusWithinProps
    },
    underlayProps: {
      onPointerDown: onPointerDownUnderlay
    }
  };
}

// node_modules/@react-aria/overlays/dist/useOverlayTrigger.mjs
var import_react49 = __toESM(require_react(), 1);
function $628037886ba31236$export$f9d5c8beee7d008d(props, state, ref) {
  let { type: type3 } = props;
  let { isOpen } = state;
  (0, import_react49.useEffect)(() => {
    if (ref && ref.current) (0, $dd149f63282afbbf$export$f6211563215e3b37).set(ref.current, state.close);
  });
  let ariaHasPopup = void 0;
  if (type3 === "menu") ariaHasPopup = true;
  else if (type3 === "listbox") ariaHasPopup = "listbox";
  let overlayId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    triggerProps: {
      "aria-haspopup": ariaHasPopup,
      "aria-expanded": isOpen,
      "aria-controls": isOpen ? overlayId : null,
      onPress: state.toggle
    },
    overlayProps: {
      id: overlayId
    }
  };
}

// node_modules/@react-aria/overlays/dist/usePreventScroll.mjs
var $49c51c25361d4cd2$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
var $49c51c25361d4cd2$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
var $49c51c25361d4cd2$var$preventScrollCount = 0;
var $49c51c25361d4cd2$var$restore;
function $49c51c25361d4cd2$export$ee0f7cc6afcd1c18(options = {}) {
  let { isDisabled } = options;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (isDisabled) return;
    $49c51c25361d4cd2$var$preventScrollCount++;
    if ($49c51c25361d4cd2$var$preventScrollCount === 1) {
      if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollMobileSafari();
      else $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollStandard();
    }
    return () => {
      $49c51c25361d4cd2$var$preventScrollCount--;
      if ($49c51c25361d4cd2$var$preventScrollCount === 0) $49c51c25361d4cd2$var$restore();
    };
  }, [
    isDisabled
  ]);
}
function $49c51c25361d4cd2$var$preventScrollStandard() {
  return (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, "overflow", "hidden"));
}
function $49c51c25361d4cd2$var$preventScrollMobileSafari() {
  let scrollable;
  let restoreScrollableStyles;
  let onTouchStart = (e4) => {
    scrollable = (0, $62d8ded9296f3872$export$cfa2225e87938781)(e4.target, true);
    if (scrollable === document.documentElement && scrollable === document.body) return;
    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === "auto") restoreScrollableStyles = $49c51c25361d4cd2$var$setStyle(scrollable, "overscrollBehavior", "contain");
  };
  let onTouchMove = (e4) => {
    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {
      e4.preventDefault();
      return;
    }
    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) e4.preventDefault();
  };
  let onTouchEnd = (e4) => {
    let target = e4.target;
    if ($49c51c25361d4cd2$var$willOpenKeyboard(target) && target !== document.activeElement) {
      e4.preventDefault();
      setupStyles();
      target.style.transform = "translateY(-2000px)";
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = "";
      });
    }
    if (restoreScrollableStyles) restoreScrollableStyles();
  };
  let onFocus = (e4) => {
    let target = e4.target;
    if ($49c51c25361d4cd2$var$willOpenKeyboard(target)) {
      setupStyles();
      target.style.transform = "translateY(-2000px)";
      requestAnimationFrame(() => {
        target.style.transform = "";
        if ($49c51c25361d4cd2$var$visualViewport) {
          if ($49c51c25361d4cd2$var$visualViewport.height < window.innerHeight)
            requestAnimationFrame(() => {
              $49c51c25361d4cd2$var$scrollIntoView(target);
            });
          else
            $49c51c25361d4cd2$var$visualViewport.addEventListener("resize", () => $49c51c25361d4cd2$var$scrollIntoView(target), {
              once: true
            });
        }
      });
    }
  };
  let restoreStyles = null;
  let setupStyles = () => {
    if (restoreStyles) return;
    let onWindowScroll = () => {
      window.scrollTo(0, 0);
    };
    let scrollX = window.pageXOffset;
    let scrollY = window.pageYOffset;
    restoreStyles = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$addEvent(window, "scroll", onWindowScroll), $49c51c25361d4cd2$var$setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, "overflow", "hidden"), $49c51c25361d4cd2$var$setStyle(document.body, "marginTop", `-${scrollY}px`), () => {
      window.scrollTo(scrollX, scrollY);
    });
    window.scrollTo(0, 0);
  };
  let removeEvents = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$addEvent(document, "touchstart", onTouchStart, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "touchmove", onTouchMove, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "touchend", onTouchEnd, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "focus", onFocus, true));
  return () => {
    restoreScrollableStyles === null || restoreScrollableStyles === void 0 ? void 0 : restoreScrollableStyles();
    restoreStyles === null || restoreStyles === void 0 ? void 0 : restoreStyles();
    removeEvents();
  };
}
function $49c51c25361d4cd2$var$setStyle(element2, style, value2) {
  let cur = element2.style[style];
  element2.style[style] = value2;
  return () => {
    element2.style[style] = cur;
  };
}
function $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}
function $49c51c25361d4cd2$var$scrollIntoView(target) {
  let root = document.scrollingElement || document.documentElement;
  while (target && target !== root) {
    let scrollable = (0, $62d8ded9296f3872$export$cfa2225e87938781)(target);
    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {
      let scrollableTop = scrollable.getBoundingClientRect().top;
      let targetTop = target.getBoundingClientRect().top;
      if (targetTop > scrollableTop + target.clientHeight) scrollable.scrollTop += targetTop - scrollableTop;
    }
    target = scrollable.parentElement;
  }
}
function $49c51c25361d4cd2$var$willOpenKeyboard(target) {
  return target instanceof HTMLInputElement && !$49c51c25361d4cd2$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}

// node_modules/@react-aria/overlays/dist/useModal.mjs
var import_react50 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var $f57aed4a881a3485$var$Context = (0, import_react50.default).createContext(null);
function $f57aed4a881a3485$export$178405afcd8c5eb(props) {
  let { children } = props;
  let parent = (0, import_react50.useContext)($f57aed4a881a3485$var$Context);
  let [modalCount, setModalCount] = (0, import_react50.useState)(0);
  let context = (0, import_react50.useMemo)(() => ({
    parent,
    modalCount,
    addModal() {
      setModalCount((count) => count + 1);
      if (parent) parent.addModal();
    },
    removeModal() {
      setModalCount((count) => count - 1);
      if (parent) parent.removeModal();
    }
  }), [
    parent,
    modalCount
  ]);
  return (0, import_react50.default).createElement($f57aed4a881a3485$var$Context.Provider, {
    value: context
  }, children);
}
function $f57aed4a881a3485$export$d9aaed4c3ece1bc0() {
  let context = (0, import_react50.useContext)($f57aed4a881a3485$var$Context);
  return {
    modalProviderProps: {
      "aria-hidden": context && context.modalCount > 0 ? true : null
    }
  };
}

// node_modules/@react-aria/overlays/dist/ar-AE.mjs
var $773d5888b972f1cf$exports = {};
$773d5888b972f1cf$exports = {
  "dismiss": `تجاهل`
};

// node_modules/@react-aria/overlays/dist/bg-BG.mjs
var $d11f19852b941573$exports = {};
$d11f19852b941573$exports = {
  "dismiss": `Отхвърляне`
};

// node_modules/@react-aria/overlays/dist/cs-CZ.mjs
var $b983974c2ee1efb3$exports = {};
$b983974c2ee1efb3$exports = {
  "dismiss": `Odstranit`
};

// node_modules/@react-aria/overlays/dist/da-DK.mjs
var $5809cc9d4e92de73$exports = {};
$5809cc9d4e92de73$exports = {
  "dismiss": `Luk`
};

// node_modules/@react-aria/overlays/dist/de-DE.mjs
var $c68c2e4fc74398d1$exports = {};
$c68c2e4fc74398d1$exports = {
  "dismiss": `Schließen`
};

// node_modules/@react-aria/overlays/dist/el-GR.mjs
var $0898b4c153db2b77$exports = {};
$0898b4c153db2b77$exports = {
  "dismiss": `Απόρριψη`
};

// node_modules/@react-aria/overlays/dist/en-US.mjs
var $6d74810286a15183$exports = {};
$6d74810286a15183$exports = {
  "dismiss": `Dismiss`
};

// node_modules/@react-aria/overlays/dist/es-ES.mjs
var $309d73dc65f78055$exports = {};
$309d73dc65f78055$exports = {
  "dismiss": `Descartar`
};

// node_modules/@react-aria/overlays/dist/et-EE.mjs
var $44ad94f7205cf593$exports = {};
$44ad94f7205cf593$exports = {
  "dismiss": `Lõpeta`
};

// node_modules/@react-aria/overlays/dist/fi-FI.mjs
var $7c28f5687f0779a9$exports = {};
$7c28f5687f0779a9$exports = {
  "dismiss": `Hylkää`
};

// node_modules/@react-aria/overlays/dist/fr-FR.mjs
var $e6d75df4b68bd73a$exports = {};
$e6d75df4b68bd73a$exports = {
  "dismiss": `Rejeter`
};

// node_modules/@react-aria/overlays/dist/he-IL.mjs
var $87505c9dab186d0f$exports = {};
$87505c9dab186d0f$exports = {
  "dismiss": `התעלם`
};

// node_modules/@react-aria/overlays/dist/hr-HR.mjs
var $553439c3ffb3e492$exports = {};
$553439c3ffb3e492$exports = {
  "dismiss": `Odbaci`
};

// node_modules/@react-aria/overlays/dist/hu-HU.mjs
var $74cf411061b983a2$exports = {};
$74cf411061b983a2$exports = {
  "dismiss": `Elutasítás`
};

// node_modules/@react-aria/overlays/dist/it-IT.mjs
var $e933f298574dc435$exports = {};
$e933f298574dc435$exports = {
  "dismiss": `Ignora`
};

// node_modules/@react-aria/overlays/dist/ja-JP.mjs
var $ac91fc9fe02f71f6$exports = {};
$ac91fc9fe02f71f6$exports = {
  "dismiss": `閉じる`
};

// node_modules/@react-aria/overlays/dist/ko-KR.mjs
var $52b96f86422025af$exports = {};
$52b96f86422025af$exports = {
  "dismiss": `무시`
};

// node_modules/@react-aria/overlays/dist/lt-LT.mjs
var $c0d724c3e51dafa6$exports = {};
$c0d724c3e51dafa6$exports = {
  "dismiss": `Atmesti`
};

// node_modules/@react-aria/overlays/dist/lv-LV.mjs
var $c92899672a3fe72e$exports = {};
$c92899672a3fe72e$exports = {
  "dismiss": `Nerādīt`
};

// node_modules/@react-aria/overlays/dist/nb-NO.mjs
var $9f576b39d8e7a9d6$exports = {};
$9f576b39d8e7a9d6$exports = {
  "dismiss": `Lukk`
};

// node_modules/@react-aria/overlays/dist/nl-NL.mjs
var $9d025808aeec81a7$exports = {};
$9d025808aeec81a7$exports = {
  "dismiss": `Negeren`
};

// node_modules/@react-aria/overlays/dist/pl-PL.mjs
var $fce709921e2c0fa6$exports = {};
$fce709921e2c0fa6$exports = {
  "dismiss": `Zignoruj`
};

// node_modules/@react-aria/overlays/dist/pt-BR.mjs
var $2599cf0c4ab37f59$exports = {};
$2599cf0c4ab37f59$exports = {
  "dismiss": `Descartar`
};

// node_modules/@react-aria/overlays/dist/pt-PT.mjs
var $3c220ae7ef8a35fd$exports = {};
$3c220ae7ef8a35fd$exports = {
  "dismiss": `Dispensar`
};

// node_modules/@react-aria/overlays/dist/ro-RO.mjs
var $93562b5094072f54$exports = {};
$93562b5094072f54$exports = {
  "dismiss": `Revocare`
};

// node_modules/@react-aria/overlays/dist/ru-RU.mjs
var $cd9e2abd0d06c7b4$exports = {};
$cd9e2abd0d06c7b4$exports = {
  "dismiss": `Пропустить`
};

// node_modules/@react-aria/overlays/dist/sk-SK.mjs
var $45375701f409adf1$exports = {};
$45375701f409adf1$exports = {
  "dismiss": `Zrušiť`
};

// node_modules/@react-aria/overlays/dist/sl-SI.mjs
var $27fab53a576de9dd$exports = {};
$27fab53a576de9dd$exports = {
  "dismiss": `Opusti`
};

// node_modules/@react-aria/overlays/dist/sr-SP.mjs
var $4438748d9952e7c7$exports = {};
$4438748d9952e7c7$exports = {
  "dismiss": `Odbaci`
};

// node_modules/@react-aria/overlays/dist/sv-SE.mjs
var $0936d7347ef4da4c$exports = {};
$0936d7347ef4da4c$exports = {
  "dismiss": `Avvisa`
};

// node_modules/@react-aria/overlays/dist/tr-TR.mjs
var $29700c92185d38f8$exports = {};
$29700c92185d38f8$exports = {
  "dismiss": `Kapat`
};

// node_modules/@react-aria/overlays/dist/uk-UA.mjs
var $662ccaf2be4c25b3$exports = {};
$662ccaf2be4c25b3$exports = {
  "dismiss": `Скасувати`
};

// node_modules/@react-aria/overlays/dist/zh-CN.mjs
var $d80a27deda7cdb3c$exports = {};
$d80a27deda7cdb3c$exports = {
  "dismiss": `取消`
};

// node_modules/@react-aria/overlays/dist/zh-TW.mjs
var $2b2734393847c884$exports = {};
$2b2734393847c884$exports = {
  "dismiss": `關閉`
};

// node_modules/@react-aria/overlays/dist/intlStrings.mjs
var $a2f21f5f14f60553$exports = {};
$a2f21f5f14f60553$exports = {
  "ar-AE": $773d5888b972f1cf$exports,
  "bg-BG": $d11f19852b941573$exports,
  "cs-CZ": $b983974c2ee1efb3$exports,
  "da-DK": $5809cc9d4e92de73$exports,
  "de-DE": $c68c2e4fc74398d1$exports,
  "el-GR": $0898b4c153db2b77$exports,
  "en-US": $6d74810286a15183$exports,
  "es-ES": $309d73dc65f78055$exports,
  "et-EE": $44ad94f7205cf593$exports,
  "fi-FI": $7c28f5687f0779a9$exports,
  "fr-FR": $e6d75df4b68bd73a$exports,
  "he-IL": $87505c9dab186d0f$exports,
  "hr-HR": $553439c3ffb3e492$exports,
  "hu-HU": $74cf411061b983a2$exports,
  "it-IT": $e933f298574dc435$exports,
  "ja-JP": $ac91fc9fe02f71f6$exports,
  "ko-KR": $52b96f86422025af$exports,
  "lt-LT": $c0d724c3e51dafa6$exports,
  "lv-LV": $c92899672a3fe72e$exports,
  "nb-NO": $9f576b39d8e7a9d6$exports,
  "nl-NL": $9d025808aeec81a7$exports,
  "pl-PL": $fce709921e2c0fa6$exports,
  "pt-BR": $2599cf0c4ab37f59$exports,
  "pt-PT": $3c220ae7ef8a35fd$exports,
  "ro-RO": $93562b5094072f54$exports,
  "ru-RU": $cd9e2abd0d06c7b4$exports,
  "sk-SK": $45375701f409adf1$exports,
  "sl-SI": $27fab53a576de9dd$exports,
  "sr-SP": $4438748d9952e7c7$exports,
  "sv-SE": $0936d7347ef4da4c$exports,
  "tr-TR": $29700c92185d38f8$exports,
  "uk-UA": $662ccaf2be4c25b3$exports,
  "zh-CN": $d80a27deda7cdb3c$exports,
  "zh-TW": $2b2734393847c884$exports
};

// node_modules/@react-aria/overlays/dist/DismissButton.mjs
var import_react52 = __toESM(require_react(), 1);

// node_modules/@react-aria/visually-hidden/dist/VisuallyHidden.mjs
var import_react51 = __toESM(require_react(), 1);
var $5c3e21d68f1c4674$var$styles = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};
function $5c3e21d68f1c4674$export$a966af930f325cab(props = {}) {
  let { style, isFocusable } = props;
  let [isFocused, setFocused] = (0, import_react51.useState)(false);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !isFocusable,
    onFocusWithinChange: (val) => setFocused(val)
  });
  let combinedStyles = (0, import_react51.useMemo)(() => {
    if (isFocused) return style;
    else if (style) return {
      ...$5c3e21d68f1c4674$var$styles,
      ...style
    };
    else return $5c3e21d68f1c4674$var$styles;
  }, [
    isFocused
  ]);
  return {
    visuallyHiddenProps: {
      ...focusWithinProps,
      style: combinedStyles
    }
  };
}
function $5c3e21d68f1c4674$export$439d29a4e110a164(props) {
  let { children, elementType: Element4 = "div", isFocusable, style, ...otherProps } = props;
  let { visuallyHiddenProps } = $5c3e21d68f1c4674$export$a966af930f325cab(props);
  return (0, import_react51.default).createElement(Element4, (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(otherProps, visuallyHiddenProps), children);
}

// node_modules/@react-aria/overlays/dist/DismissButton.mjs
function $parcel$interopDefault(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
function $86ea4cb521eb2e37$export$2317d149ed6f78c4(props) {
  let { onDismiss, ...otherProps } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault($a2f21f5f14f60553$exports)), "@react-aria/overlays");
  let labels = (0, $313b98861ee5dd6c$export$d6875122194c7b44)(otherProps, stringFormatter.format("dismiss"));
  let onClick = () => {
    if (onDismiss) onDismiss();
  };
  return (0, import_react52.default).createElement((0, $5c3e21d68f1c4674$export$439d29a4e110a164), null, (0, import_react52.default).createElement("button", {
    ...labels,
    tabIndex: -1,
    onClick,
    style: {
      width: 1,
      height: 1
    }
  }));
}

// node_modules/@react-aria/overlays/dist/ariaHideOutside.mjs
var $5e3802645cc19319$var$refCountMap = /* @__PURE__ */ new WeakMap();
var $5e3802645cc19319$var$observerStack = [];
function $5e3802645cc19319$export$1c3ebcada18427bf(targets, root = document.body) {
  let visibleNodes = new Set(targets);
  let hiddenNodes = /* @__PURE__ */ new Set();
  let walk = (root2) => {
    for (let element2 of root2.querySelectorAll("[data-live-announcer], [data-react-aria-top-layer]")) visibleNodes.add(element2);
    let acceptNode = (node2) => {
      if (visibleNodes.has(node2) || hiddenNodes.has(node2.parentElement) && node2.parentElement.getAttribute("role") !== "row") return NodeFilter.FILTER_REJECT;
      for (let target of visibleNodes) {
        if (node2.contains(target)) return NodeFilter.FILTER_SKIP;
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    let walker = document.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT, {
      acceptNode
    });
    let acceptRoot = acceptNode(root2);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT) hide(root2);
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node2 = walker.nextNode();
      while (node2 != null) {
        hide(node2);
        node2 = walker.nextNode();
      }
    }
  };
  let hide = (node2) => {
    var _refCountMap_get;
    let refCount = (_refCountMap_get = $5e3802645cc19319$var$refCountMap.get(node2)) !== null && _refCountMap_get !== void 0 ? _refCountMap_get : 0;
    if (node2.getAttribute("aria-hidden") === "true" && refCount === 0) return;
    if (refCount === 0) node2.setAttribute("aria-hidden", "true");
    hiddenNodes.add(node2);
    $5e3802645cc19319$var$refCountMap.set(node2, refCount + 1);
  };
  if ($5e3802645cc19319$var$observerStack.length) $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].disconnect();
  walk(root);
  let observer = new MutationObserver((changes) => {
    for (let change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0) continue;
      if (![
        ...visibleNodes,
        ...hiddenNodes
      ].some((node2) => node2.contains(change.target))) {
        for (let node2 of change.removedNodes) if (node2 instanceof Element) {
          visibleNodes.delete(node2);
          hiddenNodes.delete(node2);
        }
        for (let node2 of change.addedNodes) {
          if ((node2 instanceof HTMLElement || node2 instanceof SVGElement) && (node2.dataset.liveAnnouncer === "true" || node2.dataset.reactAriaTopLayer === "true")) visibleNodes.add(node2);
          else if (node2 instanceof Element) walk(node2);
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  let observerWrapper = {
    observe() {
      observer.observe(root, {
        childList: true,
        subtree: true
      });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  $5e3802645cc19319$var$observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (let node2 of hiddenNodes) {
      let count = $5e3802645cc19319$var$refCountMap.get(node2);
      if (count === 1) {
        node2.removeAttribute("aria-hidden");
        $5e3802645cc19319$var$refCountMap.delete(node2);
      } else $5e3802645cc19319$var$refCountMap.set(node2, count - 1);
    }
    if (observerWrapper === $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1]) {
      $5e3802645cc19319$var$observerStack.pop();
      if ($5e3802645cc19319$var$observerStack.length) $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].observe();
    } else $5e3802645cc19319$var$observerStack.splice($5e3802645cc19319$var$observerStack.indexOf(observerWrapper), 1);
  };
}

// node_modules/@react-aria/overlays/dist/usePopover.mjs
function $f2f8a6077418541e$export$542a6fd13ac93354(props, state) {
  let { triggerRef, popoverRef, isNonModal, isKeyboardDismissDisabled, shouldCloseOnInteractOutside, ...otherProps } = props;
  let { overlayProps, underlayProps } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({
    isOpen: state.isOpen,
    onClose: state.close,
    shouldCloseOnBlur: true,
    isDismissable: !isNonModal,
    isKeyboardDismissDisabled,
    shouldCloseOnInteractOutside
  }, popoverRef);
  let { overlayProps: positionProps, arrowProps, placement } = (0, $2a41e45df1593e64$export$d39e1813b3bdd0e1)({
    ...otherProps,
    targetRef: triggerRef,
    overlayRef: popoverRef,
    isOpen: state.isOpen,
    onClose: isNonModal ? state.close : null
  });
  (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({
    isDisabled: isNonModal || !state.isOpen
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (state.isOpen && !isNonModal && popoverRef.current) return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
      popoverRef.current
    ]);
  }, [
    isNonModal,
    state.isOpen,
    popoverRef
  ]);
  return {
    popoverProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(overlayProps, positionProps),
    arrowProps,
    underlayProps,
    placement
  };
}

// node_modules/@react-aria/overlays/dist/PortalProvider.mjs
var import_react53 = __toESM(require_react(), 1);
var $96b38030c423d352$export$60d741e20e0aa309 = (0, import_react53.createContext)({});
function $96b38030c423d352$export$574e9b0fb070c3b0() {
  var _useContext;
  return (_useContext = (0, import_react53.useContext)($96b38030c423d352$export$60d741e20e0aa309)) !== null && _useContext !== void 0 ? _useContext : {};
}

// node_modules/@react-aria/overlays/dist/Overlay.mjs
var import_react54 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var $337b884510726a0d$export$a2200b96afd16271 = (0, import_react54.default).createContext(null);
function $337b884510726a0d$export$c6fdb837b070b4ff(props) {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let { portalContainer = isSSR ? null : document.body, isExiting } = props;
  let [contain, setContain] = (0, import_react54.useState)(false);
  let contextValue = (0, import_react54.useMemo)(() => ({
    contain,
    setContain
  }), [
    contain,
    setContain
  ]);
  let { getContainer } = (0, $96b38030c423d352$export$574e9b0fb070c3b0)();
  if (!props.portalContainer && getContainer) portalContainer = getContainer();
  if (!portalContainer) return null;
  let contents = props.children;
  if (!props.disableFocusManagement) contents = (0, import_react54.default).createElement((0, $9bf71ea28793e738$export$20e40289641fbbb6), {
    restoreFocus: true,
    contain: contain && !isExiting
  }, contents);
  contents = (0, import_react54.default).createElement($337b884510726a0d$export$a2200b96afd16271.Provider, {
    value: contextValue
  }, (0, import_react54.default).createElement((0, $f1ab8c75478c6f73$export$cf75428e0b9ed1ea), null, contents));
  return (0, import_react_dom2.default).createPortal(contents, portalContainer);
}
function $337b884510726a0d$export$14c98a7594375490() {
  let ctx = (0, import_react54.useContext)($337b884510726a0d$export$a2200b96afd16271);
  let setContain = ctx === null || ctx === void 0 ? void 0 : ctx.setContain;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    setContain === null || setContain === void 0 ? void 0 : setContain(true);
  }, [
    setContain
  ]);
}

// node_modules/@react-aria/overlays/dist/useModalOverlay.mjs
var import_react55 = __toESM(require_react(), 1);
function $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, ref) {
  let { overlayProps, underlayProps } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({
    ...props,
    isOpen: state.isOpen,
    onClose: state.close
  }, ref);
  (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({
    isDisabled: !state.isOpen
  });
  (0, $337b884510726a0d$export$14c98a7594375490)();
  (0, import_react55.useEffect)(() => {
    if (state.isOpen) return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
      ref.current
    ]);
  }, [
    state.isOpen,
    ref
  ]);
  return {
    modalProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(overlayProps),
    underlayProps
  };
}

// node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js
var isDevelopment = true;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i4 = 0; i4 < document.styleSheets.length; i4++) {
    if (document.styleSheets[i4].ownerNode === tag) {
      return document.styleSheets[i4];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate2(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet2 = sheetForTag(tag);
      try {
        sheet2.insertRule(rule, sheet2.cssRules.length);
      } catch (e4) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e4);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value2, length4) {
  return charat(value2, 0) ^ 45 ? (((length4 << 2 ^ charat(value2, 0)) << 2 ^ charat(value2, 1)) << 2 ^ charat(value2, 2)) << 2 ^ charat(value2, 3) : 0;
}
function trim(value2) {
  return value2.trim();
}
function match(value2, pattern) {
  return (value2 = pattern.exec(value2)) ? value2[0] : value2;
}
function replace(value2, pattern, replacement) {
  return value2.replace(pattern, replacement);
}
function indexof(value2, search) {
  return value2.indexOf(search);
}
function charat(value2, index2) {
  return value2.charCodeAt(index2) | 0;
}
function substr(value2, begin, end) {
  return value2.slice(begin, end);
}
function strlen(value2) {
  return value2.length;
}
function sizeof(value2) {
  return value2.length;
}
function append(value2, array2) {
  return array2.push(value2), value2;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value2, root, parent, type3, props, children, length4) {
  return { value: value2, root, parent, type: type3, props, children, line, column, length: length4, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type3) {
  switch (type3) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value2) {
  return line = column = 1, length = strlen(characters = value2), position = 0, [];
}
function dealloc(value2) {
  return characters = "", value2;
}
function delimit(type3) {
  return trim(slice(position - 1, delimiter(type3 === 91 ? type3 + 2 : type3 === 40 ? type3 + 1 : type3)));
}
function whitespace(type3) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type3) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type3) {
  while (next())
    switch (character) {
      case type3:
        return position;
      case 34:
      case 39:
        if (type3 !== 34 && type3 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type3 === 41)
          delimiter(type3);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type3, index2) {
  while (next())
    if (type3 + character === 47 + 10)
      break;
    else if (type3 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type3 === 47 ? type3 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}

// node_modules/stylis/src/Parser.js
function compile(value2) {
  return dealloc(parse2("", null, null, null, [""], value2 = alloc(value2), 0, [0], value2));
}
function parse2(value2, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length4 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type3 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type3;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length4 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length4)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length4 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length4 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index2, offset, rules, points, type3, props = [], children = [], length4), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse2(characters2, root, reference, reference, props, rulesets, length4, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse2(value2, reference, reference, rule && append(ruleset(value2, reference, reference, 0, 0, rules, points, type3, rules, props = [], length4), children), rules, children, length4, points, rule ? props : children);
                    break;
                  default:
                    parse2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type3 = characters2 = "", length4 = pseudo;
        break;
      case 58:
        length4 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length4 = strlen(type3 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value2, root, parent, index2, offset, rules, points, type3, props, children, length4) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size3 = sizeof(rule);
  for (var i4 = 0, j3 = 0, k2 = 0; i4 < index2; ++i4)
    for (var x3 = 0, y3 = substr(value2, post + 1, post = abs(j3 = points[i4])), z2 = value2; x3 < size3; ++x3)
      if (z2 = trim(j3 > 0 ? rule[x3] + " " + y3 : replace(y3, /&\f/g, rule[x3])))
        props[k2++] = z2;
  return node(value2, root, parent, offset === 0 ? RULESET : type3, props, children, length4);
}
function comment(value2, root, parent) {
  return node(value2, root, parent, COMMENT, from(char()), substr(value2, 2, -2), 0);
}
function declaration(value2, root, parent, length4) {
  return node(value2, root, parent, DECLARATION, substr(value2, 0, length4), substr(value2, length4 + 1, -1), length4);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length4 = sizeof(children);
  for (var i4 = 0; i4 < length4; i4++)
    output += callback(children[i4], i4, children, callback) || "";
  return output;
}
function stringify(element2, index2, children, callback) {
  switch (element2.type) {
    case LAYER:
      if (element2.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element2.return = element2.return || element2.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element2.return = element2.value + "{" + serialize(element2.children, callback) + "}";
    case RULESET:
      element2.value = element2.props.join(",");
  }
  return strlen(children = serialize(element2.children, callback)) ? element2.return = element2.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length4 = sizeof(collection);
  return function(element2, index2, children, callback) {
    var output = "";
    for (var i4 = 0; i4 < length4; i4++)
      output += collection[i4](element2, index2, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize2(fn2) {
  var cache3 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache3[arg] === void 0) cache3[arg] = fn2(arg);
    return cache3[arg];
  };
}

// node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value2, points) {
  return dealloc(toRules(alloc(value2), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element2) {
  if (element2.type !== "rule" || !element2.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element2.length < 1) {
    return;
  }
  var value2 = element2.value, parent = element2.parent;
  var isImplicitRule = element2.column === parent.column && element2.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element2.props.length === 1 && value2.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element2, true);
  var points = [];
  var rules = getRules(value2, points);
  var parentRules = parent.props;
  for (var i4 = 0, k2 = 0; i4 < rules.length; i4++) {
    for (var j3 = 0; j3 < parentRules.length; j3++, k2++) {
      element2.props[k2] = points[i4] ? rules[i4].replace(/&\f/g, parentRules[j3]) : parentRules[j3] + " " + rules[i4];
    }
  }
};
var removeLabel = function removeLabel2(element2) {
  if (element2.type === "decl") {
    var value2 = element2.value;
    if (
      // charcode for l
      value2.charCodeAt(0) === 108 && // charcode for b
      value2.charCodeAt(2) === 98
    ) {
      element2["return"] = "";
      element2.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element2) {
  return element2.type === "comm" && element2.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache3) {
  return function(element2, index2, children) {
    if (element2.type !== "rule" || cache3.compat) return;
    var unsafePseudoClasses = element2.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element2.parent;
      var commentContainer = isNested ? element2.parent.children : (
        // global rule at the root level
        children
      );
      for (var i4 = commentContainer.length - 1; i4 >= 0; i4--) {
        var node2 = commentContainer[i4];
        if (node2.line < element2.line) {
          break;
        }
        if (node2.column < element2.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element2) {
  return element2.type.charCodeAt(1) === 105 && element2.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index2, children) {
  for (var i4 = index2 - 1; i4 >= 0; i4--) {
    if (!isImportRule(children[i4])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element2) {
  element2.type = "";
  element2.value = "";
  element2["return"] = "";
  element2.children = "";
  element2.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element2, index2, children) {
  if (!isImportRule(element2)) {
    return;
  }
  if (element2.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element2);
  } else if (isPrependedWithRegularRules(index2, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element2);
  }
};
function prefix2(value2, length4) {
  switch (hash(value2, length4)) {
    case 5103:
      return WEBKIT + "print-" + value2 + value2;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value2 + value2;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value2 + MOZ + value2 + MS + value2 + value2;
    case 6828:
    case 4268:
      return WEBKIT + value2 + MS + value2 + value2;
    case 6165:
      return WEBKIT + value2 + MS + "flex-" + value2 + value2;
    case 5187:
      return WEBKIT + value2 + replace(value2, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value2;
    case 5443:
      return WEBKIT + value2 + MS + "flex-item-" + replace(value2, /flex-|-self/, "") + value2;
    case 4675:
      return WEBKIT + value2 + MS + "flex-line-pack" + replace(value2, /align-content|flex-|-self/, "") + value2;
    case 5548:
      return WEBKIT + value2 + MS + replace(value2, "shrink", "negative") + value2;
    case 5292:
      return WEBKIT + value2 + MS + replace(value2, "basis", "preferred-size") + value2;
    case 6060:
      return WEBKIT + "box-" + replace(value2, "-grow", "") + WEBKIT + value2 + MS + replace(value2, "grow", "positive") + value2;
    case 4554:
      return WEBKIT + replace(value2, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value2;
    case 6187:
      return replace(replace(replace(value2, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value2, "") + value2;
    case 5495:
    case 3959:
      return replace(value2, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value2, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value2 + value2;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value2, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value2;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value2) - 1 - length4 > 6) switch (charat(value2, length4 + 1)) {
        case 109:
          if (charat(value2, length4 + 4) !== 45) break;
        case 102:
          return replace(value2, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value2, length4 + 3) == 108 ? "$3" : "$2-$3")) + value2;
        case 115:
          return ~indexof(value2, "stretch") ? prefix2(replace(value2, "stretch", "fill-available"), length4) + value2 : value2;
      }
      break;
    case 4949:
      if (charat(value2, length4 + 1) !== 115) break;
    case 6444:
      switch (charat(value2, strlen(value2) - 3 - (~indexof(value2, "!important") && 10))) {
        case 107:
          return replace(value2, ":", ":" + WEBKIT) + value2;
        case 101:
          return replace(value2, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value2, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value2;
      }
      break;
    case 5936:
      switch (charat(value2, length4 + 11)) {
        case 114:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb") + value2;
        case 108:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb-rl") + value2;
        case 45:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "lr") + value2;
      }
      return WEBKIT + value2 + MS + value2 + value2;
  }
  return value2;
}
var prefixer = function prefixer2(element2, index2, children, callback) {
  if (element2.length > -1) {
    if (!element2["return"]) switch (element2.type) {
      case DECLARATION:
        element2["return"] = prefix2(element2.value, element2.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element2, {
          value: replace(element2.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element2.length) return combine(element2.props, function(value2) {
          switch (match(value2, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize([copy(element2, {
                props: [replace(value2, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize([copy(element2, {
                props: [replace(value2, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element2, {
                props: [replace(value2, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element2, {
                props: [replace(value2, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i4 = 1; i4 < attrib.length; i4++) {
          inserted[attrib[i4]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache3.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, function(element2) {
      if (!element2.root) {
        if (element2["return"]) {
          currentSheet.insert(element2["return"]);
        } else if (element2.value && element2.type !== COMMENT) {
          currentSheet.insert(element2.value + "{}");
        }
      }
    }];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet2, shouldCache) {
      currentSheet = sheet2;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet2.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache3.inserted[serialized.name] = true;
      }
    };
  }
  var cache3 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache3.sheet.hydrate(nodesToHydrate);
  return cache3;
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h3 = 0;
  var k2, i4 = 0, len = str.length;
  for (; len >= 4; ++i4, len -= 4) {
    k2 = str.charCodeAt(i4) & 255 | (str.charCodeAt(++i4) & 255) << 8 | (str.charCodeAt(++i4) & 255) << 16 | (str.charCodeAt(++i4) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h3 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h3 ^= (str.charCodeAt(i4 + 2) & 255) << 16;
    case 2:
      h3 ^= (str.charCodeAt(i4 + 1) & 255) << 8;
    case 1:
      h3 ^= str.charCodeAt(i4) & 255;
      h3 = /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  h3 ^= h3 >>> 13;
  h3 = /* Math.imul(h, m): */
  (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js
var isDevelopment2 = true;
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value2) {
  return value2 != null && typeof value2 !== "boolean";
};
var processStyleName = memoize2(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value2) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value2 === "string") {
        return value2.replace(animationRegex, function(match2, p1, p22) {
          cursor = {
            name: p1,
            styles: p22,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value2 === "number" && value2 !== 0) {
    return value2 + "px";
  }
  return value2;
};
{
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value2) {
    if (key === "content") {
      if (typeof value2 !== "string" || contentValues.indexOf(value2) === -1 && !contentValuePattern.test(value2) && (value2.charAt(0) !== value2.charAt(value2.length - 1) || value2.charAt(0) !== '"' && value2.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value2 + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value2);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    if (String(componentSelector) === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        if (serializedStyles.map !== void 0) {
          styles += serializedStyles.map;
        }
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(_match, _p1, p22) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p22.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\ncss`" + replaced + "`");
        }
      }
      break;
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i4 = 0; i4 < obj.length; i4++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i4]) + ";";
    }
  } else {
    for (var key in obj) {
      var value2 = obj[key];
      if (typeof value2 !== "object") {
        var asString = value2;
        if (registered != null && registered[asString] !== void 0) {
          string2 += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string2 += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value2) && typeof value2[0] === "string" && (registered == null || registered[value2[0]] === void 0)) {
          for (var _i = 0; _i < value2.length; _i++) {
            if (isProcessableValue(value2[_i])) {
              string2 += processStyleName(key) + ":" + processStyleValue(key, value2[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value2);
          switch (key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string2 += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var sourceMapPattern;
{
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
function serializeStyles(args2, registered, mergedProps) {
  if (args2.length === 1 && typeof args2[0] === "object" && args2[0] !== null && args2[0].styles !== void 0) {
    return args2[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args2[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    if (asTemplateStringsArr[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += asTemplateStringsArr[0];
  }
  for (var i4 = 1; i4 < args2.length; i4++) {
    styles += handleInterpolation(mergedProps, registered, args2[i4]);
    if (stringMode) {
      var templateStringsArr = strings;
      if (templateStringsArr[i4] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += templateStringsArr[i4];
    }
  }
  var sourceMap;
  {
    styles = styles.replace(sourceMapPattern, function(match3) {
      sourceMap = match3;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles) + identifierName;
  {
    var devStyles = {
      name,
      styles,
      map: sourceMap,
      next: cursor,
      toString: function toString2() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
    return devStyles;
  }
}

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache3, serialized, isStringTag) {
  var className = cache3.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache3.registered[className] === void 0
  ) {
    cache3.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache3, serialized, isStringTag) {
  registerStyles(cache3, serialized, isStringTag);
  var className = cache3.key + "-" + serialized.name;
  if (cache3.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache3.insert(serialized === current ? "." + className : "", current, cache3.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.development.esm.js
function insertWithoutScoping(cache3, serialized) {
  if (cache3.inserted[serialized.name] === void 0) {
    return cache3.insert("", serialized, cache3.sheet, true);
  }
}
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var createEmotion = function createEmotion2(options) {
  var cache3 = createCache(options);
  cache3.sheet.speedy = function(value2) {
    if (this.ctr !== 0) {
      throw new Error("speedy must be changed before any rules are inserted");
    }
    this.isSpeedy = value2;
  };
  cache3.compat = true;
  var css2 = function css3() {
    for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
      args2[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args2, cache3.registered, void 0);
    insertStyles(cache3, serialized, false);
    return cache3.key + "-" + serialized.name;
  };
  var keyframes2 = function keyframes3() {
    for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args2[_key2] = arguments[_key2];
    }
    var serialized = serializeStyles(args2, cache3.registered);
    var animation = "animation-" + serialized.name;
    insertWithoutScoping(cache3, {
      name: serialized.name,
      styles: "@keyframes " + animation + "{" + serialized.styles + "}"
    });
    return animation;
  };
  var injectGlobal2 = function injectGlobal3() {
    for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args2[_key3] = arguments[_key3];
    }
    var serialized = serializeStyles(args2, cache3.registered);
    insertWithoutScoping(cache3, serialized);
  };
  var cx2 = function cx3() {
    for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args2[_key4] = arguments[_key4];
    }
    return merge(cache3.registered, css2, classnames(args2));
  };
  return {
    css: css2,
    cx: cx2,
    injectGlobal: injectGlobal2,
    keyframes: keyframes2,
    hydrate: function hydrate2(ids) {
      ids.forEach(function(key) {
        cache3.inserted[key] = true;
      });
    },
    flush: function flush2() {
      cache3.registered = {};
      cache3.inserted = {};
      cache3.sheet.flush();
    },
    sheet: cache3.sheet,
    cache: cache3,
    getRegisteredStyles: getRegisteredStyles.bind(null, cache3.registered),
    merge: merge.bind(null, cache3.registered, css2)
  };
};
var classnames = function classnames2(args2) {
  var cls = "";
  for (var i4 = 0; i4 < args2.length; i4++) {
    var arg = args2[i4];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};

// node_modules/@emotion/css/dist/emotion-css.development.esm.js
var _createEmotion = createEmotion({
  key: "css"
});
var flush = _createEmotion.flush;
var hydrate = _createEmotion.hydrate;
var cx = _createEmotion.cx;
var merge2 = _createEmotion.merge;
var getRegisteredStyles2 = _createEmotion.getRegisteredStyles;
var injectGlobal = _createEmotion.injectGlobal;
var keyframes = _createEmotion.keyframes;
var css = _createEmotion.css;
var sheet = _createEmotion.sheet;
var cache = _createEmotion.cache;

// node_modules/emery/assertions/dist/emery-assertions.esm.js
function assert(condition) {
  var message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Assert failed";
  if (!condition) {
    throw new TypeError(message);
  }
}
function assertNever(arg) {
  throw new Error("Expected never to be called, but received: " + JSON.stringify(arg));
}
function warning(condition, message) {
  if (true) {
    if (condition) {
      return;
    }
    var text3 = "Warning: ".concat(message);
    if (typeof console !== "undefined") {
      console.warn(text3);
    }
    try {
      throw Error(text3);
    } catch (x3) {
    }
  }
}

// node_modules/emery/guards/dist/emery-guards.esm.js
function isNumber(value2) {
  return typeof value2 === "number" && !isNaN(value2);
}
function isString(value2) {
  return typeof value2 === "string";
}
function isNullish(value2) {
  return value2 === null || value2 === void 0;
}
function isDefined(value2) {
  return !isNullish(value2);
}

// node_modules/emery/dist/number-556a10ae.esm.js
function negate(predicate) {
  return function(value2) {
    return !predicate(value2);
  };
}
var isFinite2 = Number.isFinite;
var isInfinite = negate(isFinite2);
var isInteger = Number.isInteger;
var isFloat = negate(isInteger);

// node_modules/emery/dist/object-d266a626.esm.js
function typedEntries(value2) {
  return Object.entries(value2);
}
function typedKeys(value2) {
  return Object.keys(value2);
}

// node_modules/@keystar/ui/dist/keystar-ui-primitives.js
var TOKEN_PREFIX = "kui";
var THEME_DEFAULT = `${TOKEN_PREFIX}-theme`;
var SCHEME_AUTO = `${TOKEN_PREFIX}-scheme--auto`;
var SCHEME_LIGHT = `${TOKEN_PREFIX}-scheme--light`;
var SCHEME_DARK = `${TOKEN_PREFIX}-scheme--dark`;

// node_modules/@keystar/ui/dist/react-compiler-runtime-19061925.js
var import_react56 = __toESM(require_react(), 1);
var $empty2 = Symbol.for("react.memo_cache_sentinel");
function c2(size3) {
  return (0, import_react56.useState)(() => {
    const $ = new Array(size3);
    for (let ii = 0; ii < size3; ii++) {
      $[ii] = $empty2;
    }
    $[$empty2] = true;
    return $;
  })[0];
}

// node_modules/@keystar/ui/dist/keystar-ui-style.js
var import_react57 = __toESM(require_react());

// node_modules/facepaint/dist/index.es.js
var index = function(breakpoints2) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, literal = _ref.literal, overlap = _ref.overlap;
  var mq = literal ? breakpoints2 : ["&"].concat(breakpoints2);
  function flatten(obj) {
    if (typeof obj !== "object" || obj == null) {
      return [];
    }
    if (Array.isArray(obj)) {
      return obj.map(flatten);
    }
    var slots = {};
    var objects = {};
    var props = {};
    Object.keys(obj).forEach(function(key) {
      var item = obj[key];
      if (!Array.isArray(item) && literal) item = [item];
      if ((literal || Array.isArray(item)) && key.charCodeAt(0) !== 38) {
        var prior = void 0;
        item.forEach(function(v6, index2) {
          if (overlap && prior === v6) {
            return;
          }
          if (v6 == null) {
            return;
          }
          prior = v6;
          if (index2 === 0 && !literal) {
            props[key] = v6;
          } else if (slots[mq[index2]] === void 0) {
            var _slots$mq$index;
            slots[mq[index2]] = (_slots$mq$index = {}, _slots$mq$index[key] = v6, _slots$mq$index);
          } else {
            slots[mq[index2]][key] = v6;
          }
        });
      } else if (typeof item === "object") {
        objects[key] = flatten(item);
      } else {
        props[key] = item;
      }
    });
    mq.forEach(function(el) {
      if (slots[el]) {
        props[el] = slots[el];
      }
    });
    Object.assign(props, objects);
    return props;
  }
  return function() {
    for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }
    return values.map(flatten);
  };
};
var index_es_default = index;

// node_modules/@keystar/ui/dist/keystar-ui-style.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var tokenSchema = {
  animation: {
    duration: {
      short: "var(--kui-animation-duration-short)",
      regular: "var(--kui-animation-duration-regular)",
      long: "var(--kui-animation-duration-long)",
      xlong: "var(--kui-animation-duration-xlong)"
    },
    easing: {
      easeInOut: "var(--kui-animation-easing-ease-in-out)",
      easeIn: "var(--kui-animation-easing-ease-in)",
      easeOut: "var(--kui-animation-easing-ease-out)"
    }
  },
  size: {
    alias: {
      focusRing: "var(--kui-size-alias-focus-ring)",
      focusRingGap: "var(--kui-size-alias-focus-ring-gap)",
      singleLineHeight: "var(--kui-size-alias-single-line-height)",
      singleLineWidth: "var(--kui-size-alias-single-line-width)"
    },
    element: {
      xsmall: "var(--kui-size-element-xsmall)",
      small: "var(--kui-size-element-small)",
      regular: "var(--kui-size-element-regular)",
      medium: "var(--kui-size-element-medium)",
      large: "var(--kui-size-element-large)",
      xlarge: "var(--kui-size-element-xlarge)"
    },
    icon: {
      small: "var(--kui-size-icon-small)",
      regular: "var(--kui-size-icon-regular)",
      medium: "var(--kui-size-icon-medium)",
      large: "var(--kui-size-icon-large)"
    },
    container: {
      xsmall: "var(--kui-size-container-xsmall)",
      small: "var(--kui-size-container-small)",
      medium: "var(--kui-size-container-medium)",
      large: "var(--kui-size-container-large)",
      xlarge: "var(--kui-size-container-xlarge)"
    },
    dialog: {
      xsmall: "var(--kui-size-dialog-xsmall)",
      small: "var(--kui-size-dialog-small)",
      medium: "var(--kui-size-dialog-medium)",
      large: "var(--kui-size-dialog-large)"
    },
    border: {
      regular: "var(--kui-size-border-regular)",
      medium: "var(--kui-size-border-medium)",
      large: "var(--kui-size-border-large)"
    },
    radius: {
      full: "var(--kui-size-radius-full)",
      xsmall: "var(--kui-size-radius-xsmall)",
      small: "var(--kui-size-radius-small)",
      regular: "var(--kui-size-radius-regular)",
      medium: "var(--kui-size-radius-medium)",
      large: "var(--kui-size-radius-large)",
      xlarge: "var(--kui-size-radius-xlarge)"
    },
    shadow: {
      small: "var(--kui-size-shadow-small)",
      medium: "var(--kui-size-shadow-medium)",
      large: "var(--kui-size-shadow-large)"
    },
    space: {
      xsmall: "var(--kui-size-space-xsmall)",
      small: "var(--kui-size-space-small)",
      regular: "var(--kui-size-space-regular)",
      medium: "var(--kui-size-space-medium)",
      large: "var(--kui-size-space-large)",
      xlarge: "var(--kui-size-space-xlarge)",
      xxlarge: "var(--kui-size-space-xxlarge)"
    },
    scale: {
      "0": "var(--kui-size-scale-0)",
      "10": "var(--kui-size-scale-10)",
      "25": "var(--kui-size-scale-25)",
      "40": "var(--kui-size-scale-40)",
      "50": "var(--kui-size-scale-50)",
      "65": "var(--kui-size-scale-65)",
      "75": "var(--kui-size-scale-75)",
      "85": "var(--kui-size-scale-85)",
      "100": "var(--kui-size-scale-100)",
      "115": "var(--kui-size-scale-115)",
      "125": "var(--kui-size-scale-125)",
      "130": "var(--kui-size-scale-130)",
      "150": "var(--kui-size-scale-150)",
      "160": "var(--kui-size-scale-160)",
      "175": "var(--kui-size-scale-175)",
      "200": "var(--kui-size-scale-200)",
      "225": "var(--kui-size-scale-225)",
      "250": "var(--kui-size-scale-250)",
      "275": "var(--kui-size-scale-275)",
      "300": "var(--kui-size-scale-300)",
      "325": "var(--kui-size-scale-325)",
      "350": "var(--kui-size-scale-350)",
      "400": "var(--kui-size-scale-400)",
      "450": "var(--kui-size-scale-450)",
      "500": "var(--kui-size-scale-500)",
      "550": "var(--kui-size-scale-550)",
      "600": "var(--kui-size-scale-600)",
      "675": "var(--kui-size-scale-675)",
      "700": "var(--kui-size-scale-700)",
      "800": "var(--kui-size-scale-800)",
      "900": "var(--kui-size-scale-900)",
      "1000": "var(--kui-size-scale-1000)",
      "1200": "var(--kui-size-scale-1200)",
      "1250": "var(--kui-size-scale-1250)",
      "1600": "var(--kui-size-scale-1600)",
      "1700": "var(--kui-size-scale-1700)",
      "2000": "var(--kui-size-scale-2000)",
      "2400": "var(--kui-size-scale-2400)",
      "3000": "var(--kui-size-scale-3000)",
      "3400": "var(--kui-size-scale-3400)",
      "3600": "var(--kui-size-scale-3600)",
      "4600": "var(--kui-size-scale-4600)",
      "5000": "var(--kui-size-scale-5000)",
      "6000": "var(--kui-size-scale-6000)"
    }
  },
  typography: {
    fontFamily: {
      base: "var(--kui-typography-font-family-base)",
      code: "var(--kui-typography-font-family-code)"
    },
    fontWeight: {
      regular: "var(--kui-typography-font-weight-regular)",
      medium: "var(--kui-typography-font-weight-medium)",
      semibold: "var(--kui-typography-font-weight-semibold)",
      bold: "var(--kui-typography-font-weight-bold)"
    },
    lineheight: {
      large: "var(--kui-typography-lineheight-large)",
      medium: "var(--kui-typography-lineheight-medium)",
      small: "var(--kui-typography-lineheight-small)"
    },
    text: {
      small: {
        size: "var(--kui-typography-text-small-size)",
        lineheight: "var(--kui-typography-text-small-lineheight)",
        baselineTrim: "var(--kui-typography-text-small-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-small-capheight-trim)",
        capheight: "var(--kui-typography-text-small-capheight)"
      },
      regular: {
        size: "var(--kui-typography-text-regular-size)",
        lineheight: "var(--kui-typography-text-regular-lineheight)",
        baselineTrim: "var(--kui-typography-text-regular-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-regular-capheight-trim)",
        capheight: "var(--kui-typography-text-regular-capheight)"
      },
      medium: {
        size: "var(--kui-typography-text-medium-size)",
        lineheight: "var(--kui-typography-text-medium-lineheight)",
        baselineTrim: "var(--kui-typography-text-medium-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-medium-capheight-trim)",
        capheight: "var(--kui-typography-text-medium-capheight)"
      },
      large: {
        size: "var(--kui-typography-text-large-size)",
        lineheight: "var(--kui-typography-text-large-lineheight)",
        baselineTrim: "var(--kui-typography-text-large-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-large-capheight-trim)",
        capheight: "var(--kui-typography-text-large-capheight)"
      }
    },
    heading: {
      small: {
        size: "var(--kui-typography-heading-small-size)",
        lineheight: "var(--kui-typography-heading-small-lineheight)",
        baselineTrim: "var(--kui-typography-heading-small-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-small-capheight-trim)",
        capheight: "var(--kui-typography-heading-small-capheight)"
      },
      regular: {
        size: "var(--kui-typography-heading-regular-size)",
        lineheight: "var(--kui-typography-heading-regular-lineheight)",
        baselineTrim: "var(--kui-typography-heading-regular-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-regular-capheight-trim)",
        capheight: "var(--kui-typography-heading-regular-capheight)"
      },
      medium: {
        size: "var(--kui-typography-heading-medium-size)",
        lineheight: "var(--kui-typography-heading-medium-lineheight)",
        baselineTrim: "var(--kui-typography-heading-medium-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-medium-capheight-trim)",
        capheight: "var(--kui-typography-heading-medium-capheight)"
      },
      large: {
        size: "var(--kui-typography-heading-large-size)",
        lineheight: "var(--kui-typography-heading-large-lineheight)",
        baselineTrim: "var(--kui-typography-heading-large-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-large-capheight-trim)",
        capheight: "var(--kui-typography-heading-large-capheight)"
      }
    }
  },
  color: {
    alias: {
      blanket: "var(--kui-color-alias-blanket)",
      backgroundIdle: "var(--kui-color-alias-background-idle)",
      backgroundDisabled: "var(--kui-color-alias-background-disabled)",
      backgroundHovered: "var(--kui-color-alias-background-hovered)",
      backgroundFocused: "var(--kui-color-alias-background-focused)",
      backgroundPressed: "var(--kui-color-alias-background-pressed)",
      backgroundSelected: "var(--kui-color-alias-background-selected)",
      backgroundSelectedHovered: "var(--kui-color-alias-background-selected-hovered)",
      focusRing: "var(--kui-color-alias-focus-ring)",
      borderIdle: "var(--kui-color-alias-border-idle)",
      borderHovered: "var(--kui-color-alias-border-hovered)",
      borderPressed: "var(--kui-color-alias-border-pressed)",
      borderFocused: "var(--kui-color-alias-border-focused)",
      borderDisabled: "var(--kui-color-alias-border-disabled)",
      borderSelected: "var(--kui-color-alias-border-selected)",
      borderInvalid: "var(--kui-color-alias-border-invalid)",
      foregroundIdle: "var(--kui-color-alias-foreground-idle)",
      foregroundHovered: "var(--kui-color-alias-foreground-hovered)",
      foregroundPressed: "var(--kui-color-alias-foreground-pressed)",
      foregroundFocused: "var(--kui-color-alias-foreground-focused)",
      foregroundDisabled: "var(--kui-color-alias-foreground-disabled)",
      foregroundSelected: "var(--kui-color-alias-foreground-selected)"
    },
    background: {
      canvas: "var(--kui-color-background-canvas)",
      surface: "var(--kui-color-background-surface)",
      surfaceSecondary: "var(--kui-color-background-surface-secondary)",
      surfaceTertiary: "var(--kui-color-background-surface-tertiary)",
      inverse: "var(--kui-color-background-inverse)",
      accent: "var(--kui-color-background-accent)",
      accentEmphasis: "var(--kui-color-background-accent-emphasis)",
      positive: "var(--kui-color-background-positive)",
      positiveEmphasis: "var(--kui-color-background-positive-emphasis)",
      caution: "var(--kui-color-background-caution)",
      cautionEmphasis: "var(--kui-color-background-caution-emphasis)",
      critical: "var(--kui-color-background-critical)",
      criticalEmphasis: "var(--kui-color-background-critical-emphasis)",
      pending: "var(--kui-color-background-pending)",
      pendingEmphasis: "var(--kui-color-background-pending-emphasis)",
      highlight: "var(--kui-color-background-highlight)",
      highlightEmphasis: "var(--kui-color-background-highlight-emphasis)"
    },
    border: {
      muted: "var(--kui-color-border-muted)",
      neutral: "var(--kui-color-border-neutral)",
      emphasis: "var(--kui-color-border-emphasis)",
      accent: "var(--kui-color-border-accent)",
      positive: "var(--kui-color-border-positive)",
      caution: "var(--kui-color-border-caution)",
      critical: "var(--kui-color-border-critical)",
      pending: "var(--kui-color-border-pending)",
      highlight: "var(--kui-color-border-highlight)"
    },
    foreground: {
      neutral: "var(--kui-color-foreground-neutral)",
      neutralEmphasis: "var(--kui-color-foreground-neutral-emphasis)",
      neutralSecondary: "var(--kui-color-foreground-neutral-secondary)",
      neutralTertiary: "var(--kui-color-foreground-neutral-tertiary)",
      onEmphasis: "var(--kui-color-foreground-on-emphasis)",
      inverse: "var(--kui-color-foreground-inverse)",
      inverseSecondary: "var(--kui-color-foreground-inverse-secondary)",
      accent: "var(--kui-color-foreground-accent)",
      positive: "var(--kui-color-foreground-positive)",
      caution: "var(--kui-color-foreground-caution)",
      critical: "var(--kui-color-foreground-critical)",
      pending: "var(--kui-color-foreground-pending)",
      highlight: "var(--kui-color-foreground-highlight)"
    },
    shadow: {
      muted: "var(--kui-color-shadow-muted)",
      regular: "var(--kui-color-shadow-regular)",
      emphasis: "var(--kui-color-shadow-emphasis)"
    },
    scale: {
      black: "var(--kui-color-scale-black)",
      white: "var(--kui-color-scale-white)",
      amber1: "var(--kui-color-scale-amber1)",
      amber2: "var(--kui-color-scale-amber2)",
      amber3: "var(--kui-color-scale-amber3)",
      amber4: "var(--kui-color-scale-amber4)",
      amber5: "var(--kui-color-scale-amber5)",
      amber6: "var(--kui-color-scale-amber6)",
      amber7: "var(--kui-color-scale-amber7)",
      amber8: "var(--kui-color-scale-amber8)",
      amber9: "var(--kui-color-scale-amber9)",
      amber10: "var(--kui-color-scale-amber10)",
      amber11: "var(--kui-color-scale-amber11)",
      green1: "var(--kui-color-scale-green1)",
      green2: "var(--kui-color-scale-green2)",
      green3: "var(--kui-color-scale-green3)",
      green4: "var(--kui-color-scale-green4)",
      green5: "var(--kui-color-scale-green5)",
      green6: "var(--kui-color-scale-green6)",
      green7: "var(--kui-color-scale-green7)",
      green8: "var(--kui-color-scale-green8)",
      green9: "var(--kui-color-scale-green9)",
      green10: "var(--kui-color-scale-green10)",
      green11: "var(--kui-color-scale-green11)",
      indigo1: "var(--kui-color-scale-indigo1)",
      indigo2: "var(--kui-color-scale-indigo2)",
      indigo3: "var(--kui-color-scale-indigo3)",
      indigo4: "var(--kui-color-scale-indigo4)",
      indigo5: "var(--kui-color-scale-indigo5)",
      indigo6: "var(--kui-color-scale-indigo6)",
      indigo7: "var(--kui-color-scale-indigo7)",
      indigo8: "var(--kui-color-scale-indigo8)",
      indigo9: "var(--kui-color-scale-indigo9)",
      indigo10: "var(--kui-color-scale-indigo10)",
      indigo11: "var(--kui-color-scale-indigo11)",
      pink1: "var(--kui-color-scale-pink1)",
      pink2: "var(--kui-color-scale-pink2)",
      pink3: "var(--kui-color-scale-pink3)",
      pink4: "var(--kui-color-scale-pink4)",
      pink5: "var(--kui-color-scale-pink5)",
      pink6: "var(--kui-color-scale-pink6)",
      pink7: "var(--kui-color-scale-pink7)",
      pink8: "var(--kui-color-scale-pink8)",
      pink9: "var(--kui-color-scale-pink9)",
      pink10: "var(--kui-color-scale-pink10)",
      pink11: "var(--kui-color-scale-pink11)",
      purple1: "var(--kui-color-scale-purple1)",
      purple2: "var(--kui-color-scale-purple2)",
      purple3: "var(--kui-color-scale-purple3)",
      purple4: "var(--kui-color-scale-purple4)",
      purple5: "var(--kui-color-scale-purple5)",
      purple6: "var(--kui-color-scale-purple6)",
      purple7: "var(--kui-color-scale-purple7)",
      purple8: "var(--kui-color-scale-purple8)",
      purple9: "var(--kui-color-scale-purple9)",
      purple10: "var(--kui-color-scale-purple10)",
      purple11: "var(--kui-color-scale-purple11)",
      red1: "var(--kui-color-scale-red1)",
      red2: "var(--kui-color-scale-red2)",
      red3: "var(--kui-color-scale-red3)",
      red4: "var(--kui-color-scale-red4)",
      red5: "var(--kui-color-scale-red5)",
      red6: "var(--kui-color-scale-red6)",
      red7: "var(--kui-color-scale-red7)",
      red8: "var(--kui-color-scale-red8)",
      red9: "var(--kui-color-scale-red9)",
      red10: "var(--kui-color-scale-red10)",
      red11: "var(--kui-color-scale-red11)",
      slate1: "var(--kui-color-scale-slate1)",
      slate2: "var(--kui-color-scale-slate2)",
      slate3: "var(--kui-color-scale-slate3)",
      slate4: "var(--kui-color-scale-slate4)",
      slate5: "var(--kui-color-scale-slate5)",
      slate6: "var(--kui-color-scale-slate6)",
      slate7: "var(--kui-color-scale-slate7)",
      slate8: "var(--kui-color-scale-slate8)",
      slate9: "var(--kui-color-scale-slate9)",
      slate10: "var(--kui-color-scale-slate10)",
      slate11: "var(--kui-color-scale-slate11)"
    }
  }
};
function transition(prop, options = {}) {
  let {
    delay = 0,
    duration = "short",
    easing = "easeInOut"
  } = options;
  let easingValue = easing === "linear" ? "linear" : tokenSchema.animation.easing[easing];
  let durationValue = resolveDuration(duration);
  if (Array.isArray(prop)) {
    return prop.map((p4) => transition(p4, options)).join(", ");
  }
  return `${prop} ${durationValue} ${easingValue}` + (delay ? ` ${resolveDuration(delay)}` : "");
}
function resolveDuration(duration) {
  return isNumber(duration) ? `${duration}ms` : tokenSchema.animation.duration[duration];
}
var classNamePrefix = TOKEN_PREFIX;
var resetClassName = voussoirClassName("reset");
function voussoirClassName(className) {
  return `${classNamePrefix}:${className}`;
}
function classNames(...inputs) {
  let resolved = cx(inputs);
  if (resolved.includes(resetClassName)) {
    return resolved;
  }
  return cx(resetClassName, resolved);
}
var _componentName, _root, _elements;
var ClassList = class {
  constructor(componentName, elements = []) {
    /** The component name for this class list. */
    __privateAdd(this, _componentName);
    /** The root class name. */
    __privateAdd(this, _root);
    /** The list of element class names. */
    __privateAdd(this, _elements);
    __privateSet(this, _componentName, componentName);
    __privateSet(this, _root, voussoirClassName(componentName));
    __privateSet(this, _elements, new Map(elements.map((element2) => [element2, `${__privateGet(this, _root)}-${element2}`])));
  }
  element(name) {
    if (name === "root") {
      return __privateGet(this, _root);
    }
    let className = __privateGet(this, _elements).get(name);
    assert(!!className, `Element "${name}" not found in "${__privateGet(this, _componentName)}" class list. All elements must be defined when the ClassList is instantiated.`);
    return className;
  }
  selector(element2, combinator) {
    let className = this.element(element2);
    if (!combinator) {
      return safeClassName(className);
    }
    return combinators[combinator] + safeClassName(className);
  }
};
_componentName = new WeakMap();
_root = new WeakMap();
_elements = new WeakMap();
function safeClassName(className) {
  return `.${className.replace(/:/g, "\\:")}`;
}
var combinators = {
  descendant: "& ",
  child: "& > ",
  sibling: "& ~ ",
  "adjacent-sibling": "& + "
};
var breakpoints = {
  mobile: 0,
  tablet: 740,
  desktop: 992,
  wide: 1200
};
var mediaAbove = (bp) => `@media (min-width: ${bp}px)`;
var mediaBelow = (bp) => `@media (max-width: ${bp - 1}px)`;
var containerAbove = (bp) => `@container (min-width: ${bp}px)`;
var containerBelow = (bp) => `@container (max-width: ${bp - 1}px)`;
var breakpointQueries$1 = {
  above: {
    mobile: mediaAbove(breakpoints.tablet),
    tablet: mediaAbove(breakpoints.desktop),
    desktop: mediaAbove(breakpoints.wide)
  },
  below: {
    tablet: mediaBelow(breakpoints.tablet),
    desktop: mediaBelow(breakpoints.desktop),
    wide: mediaBelow(breakpoints.wide)
  }
};
var containerQueries = {
  above: {
    mobile: containerAbove(breakpoints.tablet),
    tablet: containerAbove(breakpoints.desktop),
    desktop: containerAbove(breakpoints.wide)
  },
  below: {
    tablet: containerBelow(breakpoints.tablet),
    desktop: containerBelow(breakpoints.desktop),
    wide: containerBelow(breakpoints.wide)
  }
};
var breakpointNames = typedKeys(breakpoints);
var {
  mobile: _mobile$1,
  ...breakpointsWithoutMobile$1
} = breakpoints;
var mediaQueries = Object.values(breakpointsWithoutMobile$1).map(mediaAbove);
var mapToMediaQueries = index_es_default(mediaQueries);
function mapResponsiveValue(propResolver, value2) {
  if (value2 == null) {
    return null;
  }
  if (typeof value2 === "object" && !Array.isArray(value2)) {
    return objectToArray(propResolver, value2);
  }
  return propResolver(value2);
}
function objectToArray(propResolver, value2) {
  const valueArray = [];
  for (let i4 = 0; i4 < breakpointNames.length; i4++) {
    const key = breakpointNames[i4];
    valueArray.push(value2[key] != null ? propResolver(value2[key]) : null);
  }
  return valueArray;
}
function getResponsiveProp(prop, matchedBreakpoints) {
  if (typeof prop === "object" && prop !== null) {
    for (let i4 = 0; i4 < matchedBreakpoints.length; i4++) {
      let value2 = prop[matchedBreakpoints[i4]];
      if (value2 != null) {
        return value2;
      }
    }
    return prop.mobile;
  }
  return prop;
}
function getResponsiveRange(range, matchedBreakpoints) {
  if (typeof range === "boolean") {
    return range;
  }
  if (!("above" in range) && !("below" in range)) {
    return getResponsiveProp(range, matchedBreakpoints);
  }
  const startIndex = "above" in range ? breakpointNames.indexOf(range.above) + 1 : 0;
  const endIndex = "below" in range ? breakpointNames.indexOf(range.below) - 1 : breakpointNames.length - 1;
  const prop = Object.fromEntries(breakpointNames.map((key, index2) => {
    return [key, index2 >= startIndex && index2 <= endIndex];
  }));
  return getResponsiveProp(prop, matchedBreakpoints);
}
var BreakpointContext = import_react57.default.createContext(["mobile"]);
function BreakpointProvider(props) {
  const $ = c2(3);
  const {
    children,
    value: value2
  } = props;
  let t0;
  if ($[0] !== value2 || $[1] !== children) {
    t0 = (0, import_jsx_runtime.jsx)(BreakpointContext.Provider, {
      value: value2,
      children
    });
    $[0] = value2;
    $[1] = children;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
function useBreakpoint() {
  return (0, import_react57.useContext)(BreakpointContext);
}
var {
  mobile: _mobile,
  ...breakpointsWithoutMobile
} = breakpoints;
var breakpointEntries = typedEntries(breakpointsWithoutMobile).sort(([, valueA], [, valueB]) => valueB - valueA);
var breakpointQueries = breakpointEntries.map(([, value2]) => `(min-width: ${value2}px)`);
function useMatchedBreakpoints() {
  const $ = c2(4);
  const supportsMatchMedia = typeof window !== "undefined" && typeof window.matchMedia === "function";
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      const matched = [];
      for (const i4 in breakpointQueries) {
        const query = breakpointQueries[i4];
        if (window.matchMedia(query).matches) {
          matched.push(breakpointEntries[i4][0]);
        }
      }
      matched.push("mobile");
      return matched;
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const getMatchedBreakpoints = t0;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => supportsMatchMedia ? getMatchedBreakpoints() : ["mobile"];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const [breakpoint, setBreakpoint] = (0, import_react57.useState)(t1);
  let t22;
  let t32;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = () => {
      if (!supportsMatchMedia) {
        return;
      }
      const onResize = () => {
        const matched_0 = getMatchedBreakpoints();
        setBreakpoint((prevMatched) => {
          if (prevMatched.length !== matched_0.length || prevMatched.some((breakpoint_0, idx) => breakpoint_0 !== matched_0[idx])) {
            return matched_0;
          }
          return prevMatched;
        });
      };
      onResize();
      window.addEventListener("resize", onResize);
      return () => {
        window.removeEventListener("resize", onResize);
      };
    };
    t32 = [supportsMatchMedia];
    $[2] = t22;
    $[3] = t32;
  } else {
    t22 = $[2];
    t32 = $[3];
  }
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(t22, t32);
  return breakpoint;
}
function useResponsiveRange() {
  const $ = c2(2);
  const matchedBreakpoints = useBreakpoint();
  let t0;
  if ($[0] !== matchedBreakpoints) {
    t0 = function responsiveRange(range) {
      return getResponsiveRange(range, matchedBreakpoints);
    };
    $[0] = matchedBreakpoints;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function get(val, path) {
  for (const part of path.split(".")) {
    if (typeof val !== "object" || val === null || !Object.prototype.hasOwnProperty.call(val, part)) {
      return;
    }
    val = val[part];
  }
  return val;
}
function maybeTokenByKey(path, keyOrValue) {
  var _get;
  if (typeof keyOrValue !== "string") {
    return keyOrValue;
  }
  path = keyOrValue.includes(".") ? keyOrValue : `${path}.${keyOrValue}`;
  return (_get = get(tokenSchema, path)) !== null && _get !== void 0 ? _get : keyOrValue;
}
function resolvePropWithPath(prop, path) {
  const resolver = (value2) => maybeTokenByKey(path, value2);
  return [prop, resolver];
}
var identity = (value2) => value2;
function resolveProp(prop, fn2 = identity) {
  return [prop, fn2];
}
function border(prop) {
  const resolver = (value2) => {
    const color = maybeTokenByKey("color.border", value2);
    return `${tokenSchema.size.border.regular} solid ${color}`;
  };
  return [prop, resolver];
}
function isDimensionKey(value2) {
  let [prop, key] = value2.split(".");
  if (!prop || !key) {
    return false;
  }
  return !!tokenSchema.size[prop][key];
}
function sizeResolver(value2) {
  if (typeof value2 === "number") {
    if (value2 === 0) {
      return `${value2}px`;
    }
    assertNever(value2);
  }
  if (isDimensionKey(value2)) {
    let [prop, key] = value2.split(".");
    return tokenSchema.size[prop][key];
  }
  if (value2 === "auto" || value2 === "inherit" || value2 === "100%" || value2 === "100vh" || value2 === "100vw") {
    return value2;
  }
  assertNever(value2);
}
function size(cssProp) {
  return [cssProp, sizeResolver];
}
function space(prop) {
  return resolvePropWithPath(prop, "size.space");
}
function radius(prop) {
  return resolvePropWithPath(prop, "size.radius");
}
var defaultStyleProps = {
  // color
  backgroundColor: resolvePropWithPath("backgroundColor", "color.background"),
  boxShadow: ["boxShadow", boxShadowResolver],
  // dimension
  height: size("height"),
  maxHeight: size("maxHeight"),
  minHeight: size("minHeight"),
  maxWidth: size("maxWidth"),
  minWidth: size("minWidth"),
  width: size("width"),
  // space
  margin: space("margin"),
  marginStart: space("marginInlineStart"),
  marginEnd: space("marginInlineEnd"),
  marginTop: space("marginBlockStart"),
  marginBottom: space("marginBlockEnd"),
  marginX: space("marginInline"),
  marginY: space("marginBlock"),
  padding: space("padding"),
  paddingStart: space("paddingInlineStart"),
  paddingEnd: space("paddingInlineEnd"),
  paddingTop: space("paddingBlockStart"),
  paddingBottom: space("paddingBlockEnd"),
  paddingX: space("paddingInline"),
  paddingY: space("paddingBlock"),
  // border
  border: border("border"),
  borderStart: border("borderInlineStart"),
  borderEnd: border("borderInlineEnd"),
  borderTop: border("borderTop"),
  borderBottom: border("borderBottom"),
  borderColor: resolvePropWithPath("borderColor", "color.border"),
  borderStartColor: resolvePropWithPath("borderInlineStartColor", "color.border"),
  borderEndColor: resolvePropWithPath("borderInlineEndColor", "color.border"),
  borderTopColor: resolvePropWithPath("borderTopColor", "color.border"),
  borderBottomColor: resolvePropWithPath("borderBottomColor", "color.border"),
  borderStyle: resolveProp("borderStyle"),
  borderStartStyle: resolveProp("borderInlineStartStyle"),
  borderEndStyle: resolveProp("borderInlineEndStyle"),
  borderTopStyle: resolveProp("borderTopStyle"),
  borderBottomStyle: resolveProp("borderBottomStyle"),
  borderWidth: resolvePropWithPath("borderWidth", "size.border"),
  borderStartWidth: resolvePropWithPath("borderInlineStartWidth", "size.border"),
  borderEndWidth: resolvePropWithPath("borderInlineEndWidth", "size.border"),
  borderTopWidth: resolvePropWithPath("borderTopWidth", "size.border"),
  borderBottomWidth: resolvePropWithPath("borderBottomWidth", "size.border"),
  borderRadius: radius("borderRadius"),
  borderTopStartRadius: radius("borderStartStartRadius"),
  borderTopEndRadius: radius("borderStartEndRadius"),
  borderBottomStartRadius: radius("borderEndStartRadius"),
  borderBottomEndRadius: radius("borderEndEndRadius"),
  borderTopRadius: radius(["borderStartStartRadius", "borderStartEndRadius"]),
  borderBottomRadius: radius(["borderEndStartRadius", "borderEndEndRadius"]),
  borderStartRadius: radius(["borderStartStartRadius", "borderEndStartRadius"]),
  borderEndRadius: radius(["borderEndEndRadius", "borderStartEndRadius"]),
  // position
  inset: space("inset"),
  insetBottom: space("insetBlockEnd"),
  insetEnd: space("insetInlineEnd"),
  insetStart: space("insetInlineStart"),
  insetTop: space("insetBlockStart"),
  insetX: space("insetInline"),
  insetY: space("insetBlock"),
  position: resolveProp("position"),
  zIndex: resolveProp("zIndex"),
  // flex child
  order: resolveProp("order"),
  alignSelf: resolveProp("alignSelf"),
  flex: resolveProp("flex", flexResolver),
  flexBasis: size("flexBasis"),
  flexGrow: resolveProp("flexGrow", flexResolver),
  flexShrink: resolveProp("flexShrink", flexResolver),
  justifySelf: resolveProp("justifySelf"),
  // grid child
  gridArea: resolveProp("gridArea"),
  gridColumn: resolveProp("gridColumn"),
  gridColumnEnd: resolveProp("gridColumnEnd"),
  gridColumnStart: resolveProp("gridColumnStart"),
  gridRow: resolveProp("gridRow"),
  gridRowEnd: resolveProp("gridRowEnd"),
  gridRowStart: resolveProp("gridRowStart"),
  // misc. non-theme related
  cursor: resolveProp("cursor"),
  opacity: resolveProp("opacity"),
  pointerEvents: resolveProp("pointerEvents"),
  overflow: resolveProp("overflow"),
  userSelect: resolveProp("userSelect")
};
function flexResolver(value2) {
  if (typeof value2 === "boolean") {
    return value2 ? "1" : void 0;
  }
  return "" + value2;
}
function boxShadowResolver(value2) {
  const sizeToColorKey = {
    small: "muted",
    medium: "regular",
    large: "emphasis"
  };
  const [sizeKey, maybeColorKey] = value2.split(" ");
  const color = maybeTokenByKey("color.shadow", maybeColorKey !== null && maybeColorKey !== void 0 ? maybeColorKey : sizeToColorKey[sizeKey]);
  const size3 = maybeTokenByKey("size.shadow", sizeKey);
  return `${size3} ${color}`;
}
var defaultStyleKeys = Object.keys(defaultStyleProps);
function filterStyleProps(props, otherPropNames = []) {
  let filteredProps = {};
  let omit = /* @__PURE__ */ new Set(["isHidden", "UNSAFE_className", "UNSAFE_style", ...defaultStyleKeys, ...otherPropNames]);
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && !omit.has(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
}
function onlyStyleProps(props) {
  let filteredProps = {};
  let include = /* @__PURE__ */ new Set(["isHidden", "UNSAFE_className", "UNSAFE_style", ...defaultStyleKeys]);
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && include.has(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
}
function toDataAttributes(data, options = {}) {
  let dataAttributes = {};
  for (let key in data) {
    let prop = key;
    let value2 = data[key];
    if (value2 == null || options.omitFalsyValues && (value2 === false || value2 === "")) {
      continue;
    }
    if (options.trimBooleanKeys && key.startsWith("is")) {
      prop = prop.charAt(2).toLowerCase() + prop.slice(3);
    }
    prop = prop.replace(/[A-Z]/g, (char2) => `-${char2.toLowerCase()}`);
    dataAttributes[`data-${prop}`] = value2;
  }
  return dataAttributes;
}
function FocusRing(props) {
  const $ = c2(6);
  const {
    children
  } = props;
  const {
    isFocused,
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f(props);
  let t0;
  if ($[0] !== children || $[1] !== isFocusVisible || $[2] !== props || $[3] !== isFocused || $[4] !== focusProps) {
    const child = import_react57.Children.only(children);
    t0 = (0, import_react57.cloneElement)(child, $3ef42575df84b30b$export$9d1611c77c2fe928(child.props, {
      ...focusProps,
      ...toDataAttributes({
        focus: isFocusVisible ? "visible" : props.within ? "within" : isFocused || void 0
      })
    }));
    $[0] = children;
    $[1] = isFocusVisible;
    $[2] = props;
    $[3] = isFocused;
    $[4] = focusProps;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  return t0;
}
function useIsMobileDevice() {
  const isSSR = $b5e257d569688ac6$export$535bd6ca7f90a273();
  if (isSSR || typeof window === "undefined") {
    return false;
  }
  return window.screen.width <= breakpoints.tablet;
}
function useMediaQuery(_query) {
  const $ = c2(7);
  let t0;
  if ($[0] !== _query) {
    t0 = normalizeQuery(_query);
    $[0] = _query;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const query = t0;
  const supportsMatchMedia = typeof window !== "undefined" && typeof window.matchMedia === "function";
  let t1;
  if ($[2] !== query) {
    t1 = () => supportsMatchMedia ? window.matchMedia(query).matches : false;
    $[2] = query;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const [matches, setMatches] = (0, import_react57.useState)(t1);
  let t22;
  let t32;
  if ($[4] !== query) {
    t22 = () => {
      if (!supportsMatchMedia) {
        return;
      }
      const mediaQueryList = window.matchMedia(query);
      const supportsEventListener = typeof mediaQueryList.addEventListener === "function";
      const onChange2 = (evt) => {
        setMatches(evt.matches);
      };
      if (supportsEventListener) {
        mediaQueryList.addEventListener("change", onChange2);
      } else {
        mediaQueryList.addListener(onChange2);
      }
      return () => {
        if (supportsEventListener) {
          mediaQueryList.removeEventListener("change", onChange2);
        } else {
          mediaQueryList.removeListener(onChange2);
        }
      };
    };
    t32 = [supportsMatchMedia, query];
    $[4] = query;
    $[5] = t22;
    $[6] = t32;
  } else {
    t22 = $[5];
    t32 = $[6];
  }
  (0, import_react57.useEffect)(t22, t32);
  const isSSR = $b5e257d569688ac6$export$535bd6ca7f90a273();
  return isSSR ? false : matches;
}
function normalizeQuery(query) {
  return query.replace(/^@media( ?)/m, "");
}
function convertStyleProps(props, propResolvers) {
  let style = {};
  for (let key in props) {
    let styleProp = propResolvers[key];
    if (!styleProp || props[key] == null) {
      continue;
    }
    let [name, convert] = styleProp;
    let value2 = mapResponsiveValue(convert, props[key]);
    if (Array.isArray(name)) {
      for (let k2 of name) {
        style[k2] = value2;
      }
    } else {
      style[name] = value2;
    }
  }
  return style;
}
function useStyleProps(props, customResolvers = {}) {
  let propResolvers = {
    ...defaultStyleProps,
    ...customResolvers
  };
  let {
    isHidden: isHidden2,
    UNSAFE_className,
    UNSAFE_style,
    ...otherProps
  } = props;
  let convertedProps = convertStyleProps(props, propResolvers);
  let resolvedStyles = mapToMediaQueries(convertedProps);
  warning(
    // @ts-ignore
    !otherProps.className,
    "The className prop is unsafe and is unsupported. Please use style props, or UNSAFE_className if you absolutely must do something custom. Note that this may break in future versions due to DOM structure changes."
  );
  warning(
    // @ts-ignore
    !otherProps.style,
    "The style prop is unsafe and is unsupported. Please use style props, or UNSAFE_style if you absolutely must do something custom. Note that this may break in future versions due to DOM structure changes."
  );
  let hiddenStyles = [];
  if (isHidden2) {
    if (isHidden2 === true) {
      hiddenStyles.push({
        display: "none"
      });
    } else {
      const styles = {};
      if ("above" in isHidden2) {
        styles[breakpointQueries$1.above[isHidden2.above]] = {
          display: "none"
        };
      }
      if ("below" in isHidden2) {
        styles[breakpointQueries$1.below[isHidden2.below]] = {
          display: "none"
        };
      }
      hiddenStyles.push(styles);
    }
  }
  return {
    className: classNames(
      css(resolvedStyles),
      UNSAFE_className,
      css(hiddenStyles)
      // must be last
    ),
    style: UNSAFE_style
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-core.js
var import_react59 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-utils-ts.js
var import_react58 = __toESM(require_react());
function forwardRefWithAs(render) {
  return (0, import_react58.forwardRef)(render);
}

// node_modules/@keystar/ui/dist/keystar-ui-core.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var Context = (0, import_react59.createContext)(null);
Context.displayName = "KeystarProviderContext";
function useProvider() {
  const context = (0, import_react59.useContext)(Context);
  if (!context) {
    throw new Error("Attempt to access context outside of KeystarProvider.");
  }
  return context;
}
function useProviderProps(props) {
  const $ = c2(5);
  const context = useProvider();
  if (!context) {
    return props;
  }
  let t0;
  if ($[0] !== context.isDisabled || $[1] !== context.isRequired || $[2] !== context.isReadOnly || $[3] !== props) {
    t0 = Object.assign({}, {
      isDisabled: context.isDisabled,
      isRequired: context.isRequired,
      isReadOnly: context.isReadOnly
    }, props);
    $[0] = context.isDisabled;
    $[1] = context.isRequired;
    $[2] = context.isReadOnly;
    $[3] = props;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
}
var cssCustomProperties = `
/**
 * Do not edit directly
 * Generated on Fri, 03 Nov 2023 05:52:12 GMT
 */

.kui-scheme--auto,
.kui-scheme--light {
  color-scheme: light;

  --kui-color-scale-slate11: #2c2c2c;
  --kui-color-scale-slate10: #4b4b4b;
  --kui-color-scale-slate9: #6e6e6e;
  --kui-color-scale-slate8: #8e8e8e;
  --kui-color-scale-slate7: #b3b3b3;
  --kui-color-scale-slate6: #cacaca;
  --kui-color-scale-slate5: #e1e1e1;
  --kui-color-scale-slate4: #eaeaea;
  --kui-color-scale-slate3: #f5f5f5;
  --kui-color-scale-slate2: #fafafa;
  --kui-color-scale-slate1: #ffffff;
  --kui-color-scale-red11: #cd2b31;
  --kui-color-scale-red10: #dc3d43;
  --kui-color-scale-red9: #e5484d;
  --kui-color-scale-red8: #eb9091;
  --kui-color-scale-red7: #f3aeaf;
  --kui-color-scale-red6: #f9c6c6;
  --kui-color-scale-red5: #fdd8d8;
  --kui-color-scale-red4: #ffe5e5;
  --kui-color-scale-red3: #ffefef;
  --kui-color-scale-red2: #fff8f8;
  --kui-color-scale-red1: #fffcfc;
  --kui-color-scale-purple11: #793aaf;
  --kui-color-scale-purple10: #8445bc;
  --kui-color-scale-purple9: #8e4ec6;
  --kui-color-scale-purple8: #be93e4;
  --kui-color-scale-purple7: #d3b4ed;
  --kui-color-scale-purple6: #e3ccf4;
  --kui-color-scale-purple5: #eddbf9;
  --kui-color-scale-purple4: #f3e7fc;
  --kui-color-scale-purple3: #f9f1fe;
  --kui-color-scale-purple2: #fdfaff;
  --kui-color-scale-purple1: #fefcfe;
  --kui-color-scale-pink11: #cd1d8d;
  --kui-color-scale-pink10: #d23197;
  --kui-color-scale-pink9: #d6409f;
  --kui-color-scale-pink8: #e38ec3;
  --kui-color-scale-pink7: #ecadd4;
  --kui-color-scale-pink6: #f3c6e2;
  --kui-color-scale-pink5: #f9d8ec;
  --kui-color-scale-pink4: #fce5f3;
  --kui-color-scale-pink3: #feeef8;
  --kui-color-scale-pink2: #fff7fc;
  --kui-color-scale-pink1: #fffcfe;
  --kui-color-scale-indigo11: #3451b2;
  --kui-color-scale-indigo10: #3a5ccc;
  --kui-color-scale-indigo9: #3e63dd;
  --kui-color-scale-indigo8: #8da4ef;
  --kui-color-scale-indigo7: #aec0f5;
  --kui-color-scale-indigo6: #c6d4f9;
  --kui-color-scale-indigo5: #d9e2fc;
  --kui-color-scale-indigo4: #e6edfe;
  --kui-color-scale-indigo3: #f0f4ff;
  --kui-color-scale-indigo2: #f8faff;
  --kui-color-scale-indigo1: #fdfdfe;
  --kui-color-scale-green11: #18794e;
  --kui-color-scale-green10: #299764;
  --kui-color-scale-green9: #30a46c;
  --kui-color-scale-green8: #5bb98c;
  --kui-color-scale-green7: #92ceac;
  --kui-color-scale-green6: #b4dfc4;
  --kui-color-scale-green5: #ccebd7;
  --kui-color-scale-green4: #ddf3e4;
  --kui-color-scale-green3: #e9f9ee;
  --kui-color-scale-green2: #f2fcf5;
  --kui-color-scale-green1: #fbfefc;
  --kui-color-scale-amber11: #ad5700;
  --kui-color-scale-amber10: #ffa01c;
  --kui-color-scale-amber9: #ffb224;
  --kui-color-scale-amber8: #ee9d2b;
  --kui-color-scale-amber7: #f3ba63;
  --kui-color-scale-amber6: #ffd386;
  --kui-color-scale-amber5: #ffe3a2;
  --kui-color-scale-amber4: #ffecbc;
  --kui-color-scale-amber3: #fff4d5;
  --kui-color-scale-amber2: #fff9ed;
  --kui-color-scale-amber1: #fefdfb;
  --kui-color-scale-white: #ffffff;
  --kui-color-scale-black: #000000;
  --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
  --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
  --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
  --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
  --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
  --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
  --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
  --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
  --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
  --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
  --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
  --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
  --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 3%);
  --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
  --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 15%);
  --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 5%);
  --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
  --kui-color-foreground-pending: var(--kui-color-scale-purple11);
  --kui-color-foreground-critical: var(--kui-color-scale-red11);
  --kui-color-foreground-caution: var(--kui-color-scale-amber11);
  --kui-color-foreground-positive: var(--kui-color-scale-green11);
  --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
  --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
  --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
  --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
  --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
  --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
  --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
  --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
  --kui-color-border-highlight: var(--kui-color-scale-pink6);
  --kui-color-border-pending: var(--kui-color-scale-purple6);
  --kui-color-border-critical: var(--kui-color-scale-red6);
  --kui-color-border-caution: var(--kui-color-scale-amber6);
  --kui-color-border-positive: var(--kui-color-scale-green6);
  --kui-color-border-accent: var(--kui-color-scale-indigo6);
  --kui-color-border-emphasis: var(--kui-color-scale-slate6);
  --kui-color-border-neutral: var(--kui-color-scale-slate5);
  --kui-color-border-muted: var(--kui-color-scale-slate4);
  --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
  --kui-color-background-highlight: var(--kui-color-scale-pink3);
  --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
  --kui-color-background-pending: var(--kui-color-scale-purple3);
  --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
  --kui-color-background-critical: var(--kui-color-scale-red3);
  --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
  --kui-color-background-caution: var(--kui-color-scale-amber3);
  --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
  --kui-color-background-positive: var(--kui-color-scale-green3);
  --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
  --kui-color-background-accent: var(--kui-color-scale-indigo3);
  --kui-color-background-inverse: var(--kui-color-scale-slate10);
  --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
  --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
  --kui-color-background-surface: var(--kui-color-scale-slate2);
  --kui-color-background-canvas: var(--kui-color-scale-slate1);
}
.kui-scheme--dark {
  color-scheme: dark;

  --kui-color-scale-slate11: #e3e3e3;
  --kui-color-scale-slate10: #b9b9b9;
  --kui-color-scale-slate9: #909090;
  --kui-color-scale-slate8: #6e6e6e;
  --kui-color-scale-slate7: #5a5a5a;
  --kui-color-scale-slate6: #4a4a4a;
  --kui-color-scale-slate5: #3e3e3e;
  --kui-color-scale-slate4: #323232;
  --kui-color-scale-slate3: #2f2f2f;
  --kui-color-scale-slate2: #252525;
  --kui-color-scale-slate1: #1f1f1f;
  --kui-color-scale-red11: #ff6369;
  --kui-color-scale-red10: #f2555a;
  --kui-color-scale-red9: #e5484d;
  --kui-color-scale-red8: #aa2429;
  --kui-color-scale-red7: #822025;
  --kui-color-scale-red6: #671e22;
  --kui-color-scale-red5: #541b1f;
  --kui-color-scale-red4: #481a1d;
  --kui-color-scale-red3: #3c181a;
  --kui-color-scale-red2: #291415;
  --kui-color-scale-red1: #1f1315;
  --kui-color-scale-purple11: #bf7af0;
  --kui-color-scale-purple10: #9d5bd2;
  --kui-color-scale-purple9: #8e4ec6;
  --kui-color-scale-purple8: #7938b2;
  --kui-color-scale-purple7: #5f2d84;
  --kui-color-scale-purple6: #4e2667;
  --kui-color-scale-purple5: #432155;
  --kui-color-scale-purple4: #3a1e48;
  --kui-color-scale-purple3: #301a3a;
  --kui-color-scale-purple2: #221527;
  --kui-color-scale-purple1: #1b141d;
  --kui-color-scale-pink11: #f65cb6;
  --kui-color-scale-pink10: #e34ba9;
  --kui-color-scale-pink9: #d6409f;
  --kui-color-scale-pink8: #a71873;
  --kui-color-scale-pink7: #7a1d5a;
  --kui-color-scale-pink6: #601d48;
  --kui-color-scale-pink5: #501b3f;
  --kui-color-scale-pink4: #451a37;
  --kui-color-scale-pink3: #3a182f;
  --kui-color-scale-pink2: #271421;
  --kui-color-scale-pink1: #1f121b;
  --kui-color-scale-indigo11: #849dff;
  --kui-color-scale-indigo10: #5373e7;
  --kui-color-scale-indigo9: #3e63dd;
  --kui-color-scale-indigo8: #2f4eb2;
  --kui-color-scale-indigo7: #273e89;
  --kui-color-scale-indigo6: #22346e;
  --kui-color-scale-indigo5: #1f2c5c;
  --kui-color-scale-indigo4: #1c274f;
  --kui-color-scale-indigo3: #192140;
  --kui-color-scale-indigo2: #15192d;
  --kui-color-scale-indigo1: #131620;
  --kui-color-scale-green11: #4cc38a;
  --kui-color-scale-green10: #3cb179;
  --kui-color-scale-green9: #30a46c;
  --kui-color-scale-green8: #236e4a;
  --kui-color-scale-green7: #1b543a;
  --kui-color-scale-green6: #164430;
  --kui-color-scale-green5: #133929;
  --kui-color-scale-green4: #113123;
  --kui-color-scale-green3: #0f291e;
  --kui-color-scale-green2: #0c1f17;
  --kui-color-scale-green1: #0d1912;
  --kui-color-scale-amber11: #f1a10d;
  --kui-color-scale-amber10: #ffcb47;
  --kui-color-scale-amber9: #ffb224;
  --kui-color-scale-amber8: #824e00;
  --kui-color-scale-amber7: #693f05;
  --kui-color-scale-amber6: #573300;
  --kui-color-scale-amber5: #4a2900;
  --kui-color-scale-amber4: #3f2200;
  --kui-color-scale-amber3: #341c00;
  --kui-color-scale-amber2: #271700;
  --kui-color-scale-amber1: #1f1300;
  --kui-color-scale-white: #ffffff;
  --kui-color-scale-black: #000000;
  --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
  --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
  --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
  --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
  --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
  --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
  --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
  --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
  --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
  --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
  --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
  --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
  --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 4%);
  --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 40%);
  --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
  --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
  --kui-color-foreground-pending: var(--kui-color-scale-purple11);
  --kui-color-foreground-critical: var(--kui-color-scale-red11);
  --kui-color-foreground-caution: var(--kui-color-scale-amber11);
  --kui-color-foreground-positive: var(--kui-color-scale-green11);
  --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
  --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
  --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
  --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
  --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
  --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
  --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
  --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
  --kui-color-border-highlight: var(--kui-color-scale-pink6);
  --kui-color-border-pending: var(--kui-color-scale-purple6);
  --kui-color-border-critical: var(--kui-color-scale-red6);
  --kui-color-border-caution: var(--kui-color-scale-amber6);
  --kui-color-border-positive: var(--kui-color-scale-green6);
  --kui-color-border-accent: var(--kui-color-scale-indigo6);
  --kui-color-border-emphasis: var(--kui-color-scale-slate6);
  --kui-color-border-neutral: var(--kui-color-scale-slate5);
  --kui-color-border-muted: var(--kui-color-scale-slate4);
  --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
  --kui-color-background-highlight: var(--kui-color-scale-pink3);
  --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
  --kui-color-background-pending: var(--kui-color-scale-purple3);
  --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
  --kui-color-background-critical: var(--kui-color-scale-red3);
  --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
  --kui-color-background-caution: var(--kui-color-scale-amber3);
  --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
  --kui-color-background-positive: var(--kui-color-scale-green3);
  --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
  --kui-color-background-accent: var(--kui-color-scale-indigo3);
  --kui-color-background-inverse: var(--kui-color-scale-slate10);
  --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
  --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
  --kui-color-background-surface: var(--kui-color-scale-slate2);
  --kui-color-background-canvas: var(--kui-color-scale-slate1);
}
@media (prefers-color-scheme: dark) {
  .kui-scheme--auto {
    color-scheme: dark;

    --kui-color-scale-slate11: #e3e3e3;
    --kui-color-scale-slate10: #b9b9b9;
    --kui-color-scale-slate9: #909090;
    --kui-color-scale-slate8: #6e6e6e;
    --kui-color-scale-slate7: #5a5a5a;
    --kui-color-scale-slate6: #4a4a4a;
    --kui-color-scale-slate5: #3e3e3e;
    --kui-color-scale-slate4: #323232;
    --kui-color-scale-slate3: #2f2f2f;
    --kui-color-scale-slate2: #252525;
    --kui-color-scale-slate1: #1f1f1f;
    --kui-color-scale-red11: #ff6369;
    --kui-color-scale-red10: #f2555a;
    --kui-color-scale-red9: #e5484d;
    --kui-color-scale-red8: #aa2429;
    --kui-color-scale-red7: #822025;
    --kui-color-scale-red6: #671e22;
    --kui-color-scale-red5: #541b1f;
    --kui-color-scale-red4: #481a1d;
    --kui-color-scale-red3: #3c181a;
    --kui-color-scale-red2: #291415;
    --kui-color-scale-red1: #1f1315;
    --kui-color-scale-purple11: #bf7af0;
    --kui-color-scale-purple10: #9d5bd2;
    --kui-color-scale-purple9: #8e4ec6;
    --kui-color-scale-purple8: #7938b2;
    --kui-color-scale-purple7: #5f2d84;
    --kui-color-scale-purple6: #4e2667;
    --kui-color-scale-purple5: #432155;
    --kui-color-scale-purple4: #3a1e48;
    --kui-color-scale-purple3: #301a3a;
    --kui-color-scale-purple2: #221527;
    --kui-color-scale-purple1: #1b141d;
    --kui-color-scale-pink11: #f65cb6;
    --kui-color-scale-pink10: #e34ba9;
    --kui-color-scale-pink9: #d6409f;
    --kui-color-scale-pink8: #a71873;
    --kui-color-scale-pink7: #7a1d5a;
    --kui-color-scale-pink6: #601d48;
    --kui-color-scale-pink5: #501b3f;
    --kui-color-scale-pink4: #451a37;
    --kui-color-scale-pink3: #3a182f;
    --kui-color-scale-pink2: #271421;
    --kui-color-scale-pink1: #1f121b;
    --kui-color-scale-indigo11: #849dff;
    --kui-color-scale-indigo10: #5373e7;
    --kui-color-scale-indigo9: #3e63dd;
    --kui-color-scale-indigo8: #2f4eb2;
    --kui-color-scale-indigo7: #273e89;
    --kui-color-scale-indigo6: #22346e;
    --kui-color-scale-indigo5: #1f2c5c;
    --kui-color-scale-indigo4: #1c274f;
    --kui-color-scale-indigo3: #192140;
    --kui-color-scale-indigo2: #15192d;
    --kui-color-scale-indigo1: #131620;
    --kui-color-scale-green11: #4cc38a;
    --kui-color-scale-green10: #3cb179;
    --kui-color-scale-green9: #30a46c;
    --kui-color-scale-green8: #236e4a;
    --kui-color-scale-green7: #1b543a;
    --kui-color-scale-green6: #164430;
    --kui-color-scale-green5: #133929;
    --kui-color-scale-green4: #113123;
    --kui-color-scale-green3: #0f291e;
    --kui-color-scale-green2: #0c1f17;
    --kui-color-scale-green1: #0d1912;
    --kui-color-scale-amber11: #f1a10d;
    --kui-color-scale-amber10: #ffcb47;
    --kui-color-scale-amber9: #ffb224;
    --kui-color-scale-amber8: #824e00;
    --kui-color-scale-amber7: #693f05;
    --kui-color-scale-amber6: #573300;
    --kui-color-scale-amber5: #4a2900;
    --kui-color-scale-amber4: #3f2200;
    --kui-color-scale-amber3: #341c00;
    --kui-color-scale-amber2: #271700;
    --kui-color-scale-amber1: #1f1300;
    --kui-color-scale-white: #ffffff;
    --kui-color-scale-black: #000000;
    --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
    --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
    --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
    --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
    --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
    --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
    --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
    --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
    --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
    --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
    --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
    --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
    --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
    --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
    --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
    --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
    --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
    --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
    --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
    --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
    --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 4%);
    --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
    --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
    --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 40%);
    --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
    --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
    --kui-color-foreground-pending: var(--kui-color-scale-purple11);
    --kui-color-foreground-critical: var(--kui-color-scale-red11);
    --kui-color-foreground-caution: var(--kui-color-scale-amber11);
    --kui-color-foreground-positive: var(--kui-color-scale-green11);
    --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
    --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
    --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
    --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
    --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
    --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
    --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
    --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
    --kui-color-border-highlight: var(--kui-color-scale-pink6);
    --kui-color-border-pending: var(--kui-color-scale-purple6);
    --kui-color-border-critical: var(--kui-color-scale-red6);
    --kui-color-border-caution: var(--kui-color-scale-amber6);
    --kui-color-border-positive: var(--kui-color-scale-green6);
    --kui-color-border-accent: var(--kui-color-scale-indigo6);
    --kui-color-border-emphasis: var(--kui-color-scale-slate6);
    --kui-color-border-neutral: var(--kui-color-scale-slate5);
    --kui-color-border-muted: var(--kui-color-scale-slate4);
    --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
    --kui-color-background-highlight: var(--kui-color-scale-pink3);
    --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
    --kui-color-background-pending: var(--kui-color-scale-purple3);
    --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
    --kui-color-background-critical: var(--kui-color-scale-red3);
    --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
    --kui-color-background-caution: var(--kui-color-scale-amber3);
    --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
    --kui-color-background-positive: var(--kui-color-scale-green3);
    --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
    --kui-color-background-accent: var(--kui-color-scale-indigo3);
    --kui-color-background-inverse: var(--kui-color-scale-slate10);
    --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
    --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
    --kui-color-background-surface: var(--kui-color-scale-slate2);
    --kui-color-background-canvas: var(--kui-color-scale-slate1);
  }
}
.kui-theme {
  --kui-animation-easing-ease-out: cubic-bezier(0, 0, 0.4, 1);
  --kui-animation-easing-ease-in: cubic-bezier(0.5, 0, 1, 1);
  --kui-animation-easing-ease-in-out: cubic-bezier(0.45, 0, 0.4, 1);
  --kui-animation-duration-xlong: 1920ms;
  --kui-animation-duration-long: 960ms;
  --kui-animation-duration-regular: 320ms;
  --kui-animation-duration-short: 160ms;
}
.kui-theme {
  --kui-size-dialog-large: 860px;
  --kui-size-dialog-medium: 640px;
  --kui-size-dialog-small: 420px;
  --kui-size-dialog-xsmall: 320px;
  --kui-size-container-xlarge: 1400px;
  --kui-size-container-large: 1280px;
  --kui-size-container-medium: 940px;
  --kui-size-container-small: 660px;
  --kui-size-container-xsmall: 400px;
  --kui-size-alias-focus-ring-gap: 2px;
  --kui-size-alias-focus-ring: 2px;
  --kui-size-icon-large: var(--kui-size-scale-400);
  --kui-size-icon-medium: var(--kui-size-scale-300);
  --kui-size-icon-regular: var(--kui-size-scale-200);
  --kui-size-icon-small: var(--kui-size-scale-150);
  --kui-size-element-xlarge: var(--kui-size-scale-800);
  --kui-size-element-large: var(--kui-size-scale-600);
  --kui-size-element-medium: var(--kui-size-scale-450);
  --kui-size-element-regular: var(--kui-size-scale-400);
  --kui-size-element-small: var(--kui-size-scale-300);
  --kui-size-element-xsmall: var(--kui-size-scale-200);
  --kui-size-alias-single-line-width: var(--kui-size-scale-2400);
  --kui-size-alias-single-line-height: var(--kui-size-scale-400);
}
.kui-theme {
  --kui-size-radius-xlarge: 16px;
  --kui-size-radius-large: 12px;
  --kui-size-radius-medium: 8px;
  --kui-size-radius-regular: 6px;
  --kui-size-radius-small: 4px;
  --kui-size-radius-xsmall: 2px;
  --kui-size-radius-full: 9999px;
  --kui-size-border-large: 4px;
  --kui-size-border-medium: 2px;
  --kui-size-border-regular: 1px;
  --kui-size-space-xxlarge: var(--kui-size-scale-400);
  --kui-size-space-xlarge: var(--kui-size-scale-300);
  --kui-size-space-large: var(--kui-size-scale-200);
  --kui-size-space-medium: var(--kui-size-scale-150);
  --kui-size-space-regular: var(--kui-size-scale-100);
  --kui-size-space-small: var(--kui-size-scale-50);
  --kui-size-space-xsmall: var(--kui-size-scale-25);
  --kui-size-shadow-large: 0px var(--kui-size-scale-100) var(--kui-size-scale-300) 0px;
  --kui-size-shadow-medium: 0px var(--kui-size-scale-40) var(--kui-size-scale-75) 0px;
  --kui-size-shadow-small: 0px var(--kui-size-scale-10) var(--kui-size-scale-25) 0px;
}
.kui-theme {
  --kui-size-scale-6000: 480px;
  --kui-size-scale-5000: 400px;
  --kui-size-scale-4600: 368px;
  --kui-size-scale-3600: 288px;
  --kui-size-scale-3400: 272px;
  --kui-size-scale-3000: 240px;
  --kui-size-scale-2400: 192px;
  --kui-size-scale-2000: 160px;
  --kui-size-scale-1700: 136px;
  --kui-size-scale-1600: 128px;
  --kui-size-scale-1250: 100px;
  --kui-size-scale-1200: 96px;
  --kui-size-scale-1000: 80px;
  --kui-size-scale-900: 72px;
  --kui-size-scale-800: 64px;
  --kui-size-scale-700: 56px;
  --kui-size-scale-675: 54px;
  --kui-size-scale-600: 48px;
  --kui-size-scale-550: 44px;
  --kui-size-scale-500: 40px;
  --kui-size-scale-450: 36px;
  --kui-size-scale-400: 32px;
  --kui-size-scale-350: 28px;
  --kui-size-scale-325: 26px;
  --kui-size-scale-300: 24px;
  --kui-size-scale-275: 22px;
  --kui-size-scale-250: 20px;
  --kui-size-scale-225: 18px;
  --kui-size-scale-200: 16px;
  --kui-size-scale-175: 14px;
  --kui-size-scale-160: 13px;
  --kui-size-scale-150: 12px;
  --kui-size-scale-130: 11px;
  --kui-size-scale-125: 10px;
  --kui-size-scale-115: 9px;
  --kui-size-scale-100: 8px;
  --kui-size-scale-85: 7px;
  --kui-size-scale-75: 6px;
  --kui-size-scale-65: 5px;
  --kui-size-scale-50: 4px;
  --kui-size-scale-40: 3px;
  --kui-size-scale-25: 2px;
  --kui-size-scale-10: 1px;
  --kui-size-scale-0: 0px;
}
.kui-theme {
  --kui-typography-heading-large-lineheight: 1.2;
  --kui-typography-heading-large-size: 32px;
  --kui-typography-heading-medium-lineheight: 1.2;
  --kui-typography-heading-medium-size: 24px;
  --kui-typography-heading-regular-lineheight: 1.2;
  --kui-typography-heading-regular-size: 20px;
  --kui-typography-heading-small-lineheight: 1.2;
  --kui-typography-heading-small-size: 16px;
  --kui-typography-text-large-lineheight: 1.2;
  --kui-typography-text-large-size: 18px;
  --kui-typography-text-medium-lineheight: 1.4;
  --kui-typography-text-medium-size: 16px;
  --kui-typography-text-regular-lineheight: 1.4;
  --kui-typography-text-regular-size: 14px;
  --kui-typography-text-small-lineheight: 1.4;
  --kui-typography-text-small-size: 12px;
  --kui-typography-lineheight-small: 1.2;
  --kui-typography-lineheight-medium: 1.4;
  --kui-typography-lineheight-large: 1.6;
  --kui-typography-font-weight-bold: 700;
  --kui-typography-font-weight-semibold: 600;
  --kui-typography-font-weight-medium: 500;
  --kui-typography-font-weight-regular: 400;
  --kui-typography-font-family-code: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  --kui-typography-font-family-base: var(--font-inter, Inter);
  --kui-typography-heading-large-capheight: 23.2727px;
  --kui-typography-heading-large-capheight-trim: -0.2364em;
  --kui-typography-heading-large-baseline-trim: -0.2364em;
  --kui-typography-heading-medium-capheight: 17.4545px;
  --kui-typography-heading-medium-capheight-trim: -0.2364em;
  --kui-typography-heading-medium-baseline-trim: -0.2364em;
  --kui-typography-heading-regular-capheight: 14.5455px;
  --kui-typography-heading-regular-capheight-trim: -0.2364em;
  --kui-typography-heading-regular-baseline-trim: -0.2364em;
  --kui-typography-heading-small-capheight: 11.6364px;
  --kui-typography-heading-small-capheight-trim: -0.2364em;
  --kui-typography-heading-small-baseline-trim: -0.2364em;
  --kui-typography-text-large-capheight: 13.0909px;
  --kui-typography-text-large-capheight-trim: -0.2364em;
  --kui-typography-text-large-baseline-trim: -0.2364em;
  --kui-typography-text-medium-capheight: 11.6364px;
  --kui-typography-text-medium-capheight-trim: -0.3364em;
  --kui-typography-text-medium-baseline-trim: -0.3364em;
  --kui-typography-text-regular-capheight: 10.1818px;
  --kui-typography-text-regular-capheight-trim: -0.3364em;
  --kui-typography-text-regular-baseline-trim: -0.3364em;
  --kui-typography-text-small-capheight: 8.7273px;
  --kui-typography-text-small-capheight-trim: -0.3364em;
  --kui-typography-text-small-baseline-trim: -0.3364em;
}`;
var schemes = {
  auto: SCHEME_AUTO,
  light: SCHEME_LIGHT,
  dark: SCHEME_DARK
};
var documentElementClasses = (args2) => {
  const scheme = schemes[args2.colorScheme || "auto"];
  return `${documentReset(args2.bodyBackground)} ${THEME_DEFAULT} ${scheme}`;
};
var documentReset = (background = "canvas") => css`
  html& {
    scroll-behavior: smooth;
    text-size-adjust: none;
    -webkit-tap-highlight-color: #0000;
  }
  @media (prefers-reduced-motion: reduce) {
    html& {
      scroll-behavior: auto;
    }
  }

  html& body {
    background-color: ${tokenSchema.color.background[background]};
    margin: 0;
  }
`;
function flatString(str) {
  return str.replace(/\n|\s{2,}/g, "");
}
var reset = resetClassName.replace(":", "\\:");
var elementReset = flatString(`
  :where(.${reset}) {
    border: 0;
    box-sizing: border-box;
    font: inherit;
    font-size: 100%;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
  }
  :where(ol.${reset}, ul.${reset}) { list-style: none; }
  :where(canvas.${reset}, img.${reset}, picture.${reset}, svg.${reset}, video.${reset}) { display: block; }
  :where(input.${reset}, button.${reset}, textarea.${reset}, select.${reset}) { appearance: none; background-color: transparent; }
  :where(a.${reset}, abbr.${reset}) { color: inherit; text-decoration: none; }
  :where(table.${reset}) = { border-collapse: collapse; border-spacing: 0; }
`);
injectGlobal(cssCustomProperties);
injectGlobal(elementReset);
function useScale() {
  const matchesFine = useMediaQuery("(any-pointer: fine)");
  return !matchesFine ? "large" : "medium";
}
var KeystarProvider = forwardRefWithAs(function KeystarProvider2(props, forwardedRef) {
  let prevContext = (0, import_react59.useContext)(Context);
  let prevColorScheme = prevContext && prevContext.colorScheme;
  let autoScale = useScale();
  let {
    locale: prevLocale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let matchedBreakpoints = useMatchedBreakpoints();
  let {
    children,
    colorScheme = prevColorScheme || "auto",
    isDisabled,
    isRequired,
    isReadOnly,
    locale = prevContext ? prevLocale : void 0,
    router,
    scale = prevContext ? prevContext.scale : autoScale,
    ...otherProps
  } = props;
  let currentProps = {
    colorScheme,
    isDisabled,
    isRequired,
    isReadOnly,
    scale
  };
  let filteredProps = Object.fromEntries(Object.entries(currentProps).filter(([_2, value2]) => value2 !== void 0));
  let context = Object.assign({}, prevContext, filteredProps);
  let contents = children;
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
  let styleProps = useStyleProps(otherProps);
  if (!prevContext || props.elementType || props.locale || colorScheme !== prevContext.colorScheme || scale !== prevContext.scale || Object.keys(domProps).length > 0 || otherProps.UNSAFE_className || styleProps.style && Object.keys(styleProps.style).length > 0) {
    var _props$elementType;
    contents = (0, import_jsx_runtime2.jsx)(ProviderWrapper, {
      ref: forwardedRef,
      ...props,
      style: {
        isolation: !prevContext ? "isolate" : void 0
      },
      elementType: (_props$elementType = props.elementType) !== null && _props$elementType !== void 0 ? _props$elementType : "div",
      children: contents
    });
  }
  if (router) {
    contents = (0, import_jsx_runtime2.jsx)($ea8dcbcb9ea1b556$export$323e4fc2fa4753fb, {
      ...router,
      children: contents
    });
  }
  return (0, import_jsx_runtime2.jsx)(Context.Provider, {
    value: context,
    children: (0, import_jsx_runtime2.jsx)(BreakpointProvider, {
      value: matchedBreakpoints,
      children: (0, import_jsx_runtime2.jsx)($18f2051aff69b9bf$export$a54013f0d02a8f82, {
        locale,
        children: (0, import_jsx_runtime2.jsx)($f57aed4a881a3485$export$178405afcd8c5eb, {
          children: contents
        })
      })
    })
  });
});
var ProviderWrapper = forwardRefWithAs(function ProviderWrapper2(props, forwardedRef) {
  var _props$elementType2;
  let {
    children,
    style
  } = props;
  let {
    locale,
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let {
    modalProviderProps
  } = $f57aed4a881a3485$export$d9aaed4c3ece1bc0();
  let {
    colorScheme
  } = useProvider();
  const ElementType = (_props$elementType2 = props.elementType) !== null && _props$elementType2 !== void 0 ? _props$elementType2 : "div";
  return (0, import_jsx_runtime2.jsx)(ElementType, {
    ...modalProviderProps,
    className: `${props.UNSAFE_className ? `${props.UNSAFE_className} ` : ""}${documentElementClasses({
      bodyBackground: props.bodyBackground,
      colorScheme
    })}`,
    lang: locale,
    dir: direction,
    ref: forwardedRef,
    style: {
      ...style,
      ...props.UNSAFE_style
    },
    children
  });
});
function ClientSideOnlyDocumentElement(props) {
  const $ = c2(6);
  const context = useProvider();
  let t0;
  if ($[0] !== props.bodyBackground || $[1] !== context.colorScheme) {
    t0 = documentElementClasses({
      bodyBackground: props.bodyBackground,
      colorScheme: context.colorScheme
    });
    $[0] = props.bodyBackground;
    $[1] = context.colorScheme;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const classes = t0;
  let t1;
  let t22;
  if ($[3] !== classes) {
    t1 = () => {
      const split2 = classes.split(" ");
      const root = document.documentElement;
      root.classList.add(...split2);
      return () => {
        root.classList.remove(...split2);
      };
    };
    t22 = [classes];
    $[3] = classes;
    $[4] = t1;
    $[5] = t22;
  } else {
    t1 = $[4];
    t22 = $[5];
  }
  (0, import_react59.useLayoutEffect)(t1, t22);
  return null;
}

// node_modules/@keystar/ui/dist/keystar-ui-slots.js
var import_react60 = __toESM(require_react());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var SlotContext = import_react60.default.createContext({});
function useSlotProps(props, defaultSlot) {
  let slot = props.slot || defaultSlot;
  let {
    [slot]: slotProps = {}
  } = (0, import_react60.useContext)(SlotContext);
  return $3ef42575df84b30b$export$9d1611c77c2fe928(props, $3ef42575df84b30b$export$9d1611c77c2fe928(slotProps, {
    id: props.id
  }));
}
var SlotProvider = (props) => {
  const $ = c2(6);
  const {
    children,
    slots
  } = props;
  const parentSlots = (0, import_react60.useContext)(SlotContext);
  let t0;
  let t1;
  if ($[0] !== parentSlots || $[1] !== slots) {
    t1 = Object.keys(parentSlots).concat(Object.keys(slots)).reduce((obj, key) => ({
      ...obj,
      [key]: $3ef42575df84b30b$export$9d1611c77c2fe928(parentSlots[key], slots[key])
    }), {});
    $[0] = parentSlots;
    $[1] = slots;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  t0 = t1;
  const value2 = t0;
  let t22;
  if ($[3] !== value2 || $[4] !== children) {
    t22 = (0, import_jsx_runtime3.jsx)(SlotContext.Provider, {
      value: value2,
      children
    });
    $[3] = value2;
    $[4] = children;
    $[5] = t22;
  } else {
    t22 = $[5];
  }
  return t22;
};
var ClearSlots = (t0) => {
  const $ = c2(3);
  const {
    children
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {};
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t22;
  if ($[1] !== children) {
    t22 = (0, import_jsx_runtime3.jsx)(SlotContext.Provider, {
      value: t1,
      children
    });
    $[1] = children;
    $[2] = t22;
  } else {
    t22 = $[2];
  }
  return t22;
};
var Content = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "content");
  let {
    elementType: Element4 = "section",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children: (0, import_jsx_runtime3.jsx)(ClearSlots, {
      children
    })
  });
});
var Footer = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "footer");
  let {
    elementType: Element4 = "footer",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children
  });
});
var Header = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "header");
  let {
    elementType: Element4 = "header",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children
  });
});

// node_modules/@react-aria/link/dist/useLink.mjs
function $298d61e98472621b$export$dcf14c9974fe2767(props, ref) {
  let {
    elementType = "a",
    onPress,
    onPressStart,
    onPressEnd,
    // @ts-ignore
    onClick: deprecatedOnClick,
    isDisabled,
    ...otherProps
  } = props;
  let linkProps = {};
  if (elementType !== "a") linkProps = {
    role: "link",
    tabIndex: !isDisabled ? 0 : void 0
  };
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPress,
    onPressStart,
    onPressEnd,
    isDisabled,
    ref
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(otherProps, {
    labelable: true
  });
  let interactionHandlers = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, pressProps);
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let routerLinkProps = (0, $ea8dcbcb9ea1b556$export$7e924b3091a3bd18)(props);
  return {
    isPressed,
    linkProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, routerLinkProps, {
      ...interactionHandlers,
      ...linkProps,
      "aria-disabled": isDisabled || void 0,
      "aria-current": props["aria-current"],
      onClick: (e4) => {
        var _pressProps_onClick;
        (_pressProps_onClick = pressProps.onClick) === null || _pressProps_onClick === void 0 ? void 0 : _pressProps_onClick.call(pressProps, e4);
        if (deprecatedOnClick) {
          deprecatedOnClick(e4);
          console.warn("onClick is deprecated, please use onPress");
        }
        if (!router.isNative && e4.currentTarget instanceof HTMLAnchorElement && e4.currentTarget.href && // If props are applied to a router Link component, it may have already prevented default.
        !e4.isDefaultPrevented() && (0, $ea8dcbcb9ea1b556$export$efa8c9099e530235)(e4.currentTarget, e4) && props.href) {
          e4.preventDefault();
          router.open(e4.currentTarget, e4, props.href, props.routerOptions);
        }
      }
    })
  };
}

// node_modules/@keystar/ui/dist/children-f7c17978.js
var import_react61 = __toESM(require_react(), 1);
function useHasChild(query, ref) {
  const $ = c2(6);
  const [hasChild, setHasChild] = (0, import_react61.useState)(true);
  let t0;
  if ($[0] !== ref.current || $[1] !== query) {
    t0 = () => {
      setHasChild(!!(ref.current && ref.current.querySelector(query)));
    };
    $[0] = ref.current;
    $[1] = query;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] !== query || $[4] !== ref) {
    t1 = [setHasChild, query, ref];
    $[3] = query;
    $[4] = ref;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(t0, t1);
  return hasChild;
}
function cloneValidElement(child, props) {
  if (!(0, import_react61.isValidElement)(child)) {
    return null;
  }
  return (0, import_react61.cloneElement)(child, props);
}

// node_modules/@keystar/ui/dist/keystar-ui-utils.js
var import_react62 = __toESM(require_react());
function isReactText(value2) {
  if (Array.isArray(value2)) {
    return value2.every(isReactText);
  }
  return typeof value2 === "string" || typeof value2 === "number";
}
function useId(id2) {
  const generatedId = import_react62.default.useId();
  return id2 || generatedId;
}
function useIsMounted() {
  const $ = c2(3);
  const isMounted = (0, import_react62.useRef)(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  (0, import_react62.useEffect)(t0, t1);
  let t22;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = () => isMounted.current;
    $[2] = t22;
  } else {
    t22 = $[2];
  }
  return t22;
}
function usePrevious(value2) {
  const $ = c2(2);
  const ref = (0, import_react62.useRef)();
  let t0;
  if ($[0] !== value2) {
    t0 = () => {
      ref.current = value2;
    };
    $[0] = value2;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  (0, import_react62.useEffect)(t0);
  return ref.current;
}
function useRenderProps(props, values) {
  const $ = c2(3);
  const {
    children
  } = props;
  let t0;
  bb0: {
    if (typeof children === "function") {
      let t1;
      if ($[0] !== children || $[1] !== values) {
        t1 = children(values);
        $[0] = children;
        $[1] = values;
        $[2] = t1;
      } else {
        t1 = $[2];
      }
      t0 = t1;
      break bb0;
    }
    t0 = children;
  }
  return t0;
}

// node_modules/@keystar/ui/dist/keystar-ui-typography.js
var import_react63 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var HeadingContext = (0, import_react63.createContext)(void 0);
function useHeadingContext() {
  return (0, import_react63.useContext)(HeadingContext);
}
function getTrimStyles(fontDefinition) {
  const {
    capheightTrim: marginBottom,
    baselineTrim: marginTop
  } = fontDefinition;
  return {
    display: "block",
    lineHeight: fontDefinition.lineheight,
    "::before": {
      content: '" "',
      display: "table",
      marginBottom
    },
    "::after": {
      content: '" "',
      display: "table",
      marginTop
    }
  };
}
var TextContext = (0, import_react63.createContext)(void 0);
function useTextContext() {
  return (0, import_react63.useContext)(TextContext);
}
var textClassList = new ClassList("Text");
function useTextStyles(props) {
  const $ = c2(30);
  const prevContext = useTextContext();
  let t0;
  let t1;
  let size3;
  let color;
  let weight;
  let align;
  let variant;
  let casing;
  let otherProps;
  let UNSAFE_className;
  if ($[0] !== props) {
    ({
      align,
      casing,
      overflow: t0,
      size: size3,
      color,
      trim: t1,
      variant,
      weight,
      UNSAFE_className,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = size3;
    $[4] = color;
    $[5] = weight;
    $[6] = align;
    $[7] = variant;
    $[8] = casing;
    $[9] = otherProps;
    $[10] = UNSAFE_className;
  } else {
    t0 = $[1];
    t1 = $[2];
    size3 = $[3];
    color = $[4];
    weight = $[5];
    align = $[6];
    variant = $[7];
    casing = $[8];
    otherProps = $[9];
    UNSAFE_className = $[10];
  }
  const overflow = t0 === void 0 ? "breakword" : t0;
  const trim2 = t1 === void 0 ? !prevContext : t1;
  const fontDefinition = tokenSchema.typography.text[size3];
  let t22;
  let t32;
  let t4;
  if ($[11] !== trim2 || $[12] !== fontDefinition || $[13] !== color || $[14] !== weight || $[15] !== align || $[16] !== variant || $[17] !== casing || $[18] !== overflow || $[19] !== otherProps) {
    const trimStyles = trim2 ? getTrimStyles(fontDefinition) : null;
    const styles = [{
      color: maybeTokenByKey("color.foreground", color),
      fontFamily: tokenSchema.typography.fontFamily.base,
      fontSize: fontDefinition.size,
      fontVariantNumeric: variant,
      fontWeight: weight === "inherit" ? void 0 : tokenSchema.typography.fontWeight[weight],
      minWidth: 0,
      textAlign: align ? alignmentMap[align] : void 0,
      textTransform: casing
    }, textOptimizationStyles, overflow && overflowMap[overflow], trimStyles];
    t4 = useStyleProps;
    t32 = otherProps;
    t22 = css(styles);
    $[11] = trim2;
    $[12] = fontDefinition;
    $[13] = color;
    $[14] = weight;
    $[15] = align;
    $[16] = variant;
    $[17] = casing;
    $[18] = overflow;
    $[19] = otherProps;
    $[20] = t22;
    $[21] = t32;
    $[22] = t4;
  } else {
    t22 = $[20];
    t32 = $[21];
    t4 = $[22];
  }
  let t5;
  if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = textClassList.element("root");
    $[23] = t5;
  } else {
    t5 = $[23];
  }
  let t6;
  if ($[24] !== t22 || $[25] !== UNSAFE_className) {
    t6 = [t22, UNSAFE_className, t5];
    $[24] = t22;
    $[25] = UNSAFE_className;
    $[26] = t6;
  } else {
    t6 = $[26];
  }
  let t7;
  if ($[27] !== t32 || $[28] !== t6) {
    t7 = {
      ...t32,
      UNSAFE_className: t6
    };
    $[27] = t32;
    $[28] = t6;
    $[29] = t7;
  } else {
    t7 = $[29];
  }
  return t4(t7);
}
var textOptimizationStyles = {
  MozOsxFontSmoothing: "auto",
  WebkitFontSmoothing: "auto"
};
var alignmentMap = {
  start: "start",
  center: "center",
  end: "end",
  FORCE_left: "left",
  FORCE_right: "right"
};
var overflowMap = {
  unset: {},
  nowrap: {
    whiteSpace: "nowrap"
  },
  breakword: {
    // hyphens: 'auto', // too eager
    overflowWrap: "break-word"
  }
};
var headingClassList = new ClassList("Heading");
function useHeadingStyles(t0) {
  const $ = c2(19);
  let size3;
  let align;
  let otherProps;
  let UNSAFE_className;
  if ($[0] !== t0) {
    ({
      align,
      size: size3,
      UNSAFE_className,
      ...otherProps
    } = t0);
    $[0] = t0;
    $[1] = size3;
    $[2] = align;
    $[3] = otherProps;
    $[4] = UNSAFE_className;
  } else {
    size3 = $[1];
    align = $[2];
    otherProps = $[3];
    UNSAFE_className = $[4];
  }
  const fontDefinition = tokenSchema.typography.heading[size3];
  let t1;
  let t22;
  let t32;
  if ($[5] !== fontDefinition || $[6] !== size3 || $[7] !== align || $[8] !== otherProps) {
    const trimStyles = getTrimStyles(fontDefinition);
    const styles = [{
      color: tokenSchema.color.foreground.neutralEmphasis,
      fontSize: fontDefinition.size,
      fontFamily: tokenSchema.typography.fontFamily.base,
      fontWeight: sizeToWeight[size3],
      textAlign: align
    }, textOptimizationStyles, trimStyles];
    t32 = useStyleProps;
    t22 = otherProps;
    t1 = css(styles);
    $[5] = fontDefinition;
    $[6] = size3;
    $[7] = align;
    $[8] = otherProps;
    $[9] = t1;
    $[10] = t22;
    $[11] = t32;
  } else {
    t1 = $[9];
    t22 = $[10];
    t32 = $[11];
  }
  let t4;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = headingClassList.element("root");
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  let t5;
  if ($[13] !== t1 || $[14] !== UNSAFE_className) {
    t5 = [t1, UNSAFE_className, t4];
    $[13] = t1;
    $[14] = UNSAFE_className;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== t22 || $[17] !== t5) {
    t6 = {
      ...t22,
      UNSAFE_className: t5
    };
    $[16] = t22;
    $[17] = t5;
    $[18] = t6;
  } else {
    t6 = $[18];
  }
  return t32(t6);
}
var sizeToWeight = {
  small: tokenSchema.typography.fontWeight.semibold,
  regular: tokenSchema.typography.fontWeight.bold,
  medium: tokenSchema.typography.fontWeight.medium,
  large: tokenSchema.typography.fontWeight.bold
};
function Truncate(t0) {
  const $ = c2(11);
  let lines;
  let title;
  let props;
  if ($[0] !== t0) {
    ({
      lines,
      title,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = lines;
    $[2] = title;
    $[3] = props;
  } else {
    lines = $[1];
    title = $[2];
    props = $[3];
  }
  const className = useTruncateStyles(typeof lines === "boolean" ? 1 : lines);
  let t1;
  if ($[4] !== title || $[5] !== props) {
    var _title;
    t1 = (_title = title) !== null && _title !== void 0 ? _title : isReactText(props.children) ? props.children.toString() : void 0;
    $[4] = title;
    $[5] = props;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  let t22;
  if ($[7] !== className || $[8] !== t1 || $[9] !== props) {
    t22 = (0, import_jsx_runtime4.jsx)("span", {
      className,
      title: t1,
      ...props
    });
    $[7] = className;
    $[8] = t1;
    $[9] = props;
    $[10] = t22;
  } else {
    t22 = $[10];
  }
  return t22;
}
function useTruncateStyles(lineClamp) {
  return css({
    display: "-webkit-box",
    WebkitLineClamp: lineClamp,
    textOverflow: "ellipsis",
    WebkitBoxOrient: "vertical",
    overflow: "hidden"
  });
}
function useVisuallyHiddenRange(range) {
  const matchedBreakpoints = useResponsiveRange();
  const {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  if (range && matchedBreakpoints(range)) {
    return visuallyHiddenProps;
  }
}
var sizeToElement = {
  small: "h4",
  regular: "h3",
  medium: "h2",
  large: "h1"
};
var filterOptions$1 = {
  propNames: /* @__PURE__ */ new Set(["aria-hidden"])
};
var Heading = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "heading");
  const {
    children,
    size: size3 = "regular",
    truncate,
    elementType: ElementType = sizeToElement[size3],
    ...otherProps
  } = props;
  const styleProps = useHeadingStyles({
    size: size3,
    ...props
  });
  const headingContext = (0, import_react63.useMemo)(() => ({
    size: size3
  }), [size3]);
  const visuallyHiddenProps = useVisuallyHiddenRange(props.visuallyHidden);
  const content = truncate ? (0, import_jsx_runtime4.jsx)(Truncate, {
    lines: truncate,
    children
  }) : children;
  return (0, import_jsx_runtime4.jsx)(HeadingContext.Provider, {
    value: headingContext,
    children: (0, import_jsx_runtime4.jsx)(ElementType, {
      ref,
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions$1),
      ...styleProps,
      ...visuallyHiddenProps,
      children: content
    })
  });
});
var filterOptions = {
  propNames: /* @__PURE__ */ new Set(["aria-hidden", "role"])
};
var Text = forwardRefWithAs((props, forwardedRef) => {
  var _prevContext$color, _prevContext$size, _prevContext$weight;
  props = useSlotProps(props, "text");
  const headingContext = useHeadingContext();
  const prevContext = useTextContext();
  validateProps$1(props, prevContext);
  warning(!headingContext, "The `Text` component is not supported within `Heading` components.");
  if (headingContext) {
    return (0, import_jsx_runtime4.jsx)("span", {
      children: props.children
    });
  }
  const {
    children,
    color = (_prevContext$color = prevContext === null || prevContext === void 0 ? void 0 : prevContext.color) !== null && _prevContext$color !== void 0 ? _prevContext$color : "neutral",
    elementType: ElementType = "span",
    size: size3 = (_prevContext$size = prevContext === null || prevContext === void 0 ? void 0 : prevContext.size) !== null && _prevContext$size !== void 0 ? _prevContext$size : "regular",
    trim: trim2 = !prevContext,
    truncate,
    visuallyHidden,
    weight = (_prevContext$weight = prevContext === null || prevContext === void 0 ? void 0 : prevContext.weight) !== null && _prevContext$weight !== void 0 ? _prevContext$weight : "regular",
    ...otherProps
  } = props;
  const styleProps = useTextStyles({
    color,
    size: size3,
    trim: trim2,
    weight,
    ...otherProps
  });
  const visuallyHiddenProps = useVisuallyHiddenRange(visuallyHidden);
  const content = truncate ? (0, import_jsx_runtime4.jsx)(Truncate, {
    lines: truncate,
    children
  }) : children;
  const element2 = (0, import_jsx_runtime4.jsx)(ElementType, {
    ref: forwardedRef,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions),
    ...styleProps,
    ...visuallyHiddenProps,
    children: content
  });
  const nextContext = (0, import_react63.useMemo)(() => ({
    size: size3,
    color,
    weight
  }), [size3, color, weight]);
  if (prevContext || visuallyHidden) {
    return element2;
  }
  return (0, import_jsx_runtime4.jsx)(TextContext.Provider, {
    value: nextContext,
    children: element2
  });
});
function validateProps$1(props, context) {
  assert(!context || !props.align, 'The "align" prop is unsupported on nested Text.');
  assert(!context || !props.trim, 'The "trim" prop is unsupported on nested Text.');
}
var Emoji = (0, import_react63.forwardRef)(function Emoji2(props, forwardedRef) {
  const $ = c2(13);
  let otherProps;
  let label;
  let symbol;
  if ($[0] !== props) {
    ({
      label,
      symbol,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = label;
    $[3] = symbol;
  } else {
    otherProps = $[1];
    label = $[2];
    symbol = $[3];
  }
  const styleProps = useStyleProps(otherProps);
  const t0 = label ? void 0 : true;
  let t1;
  if ($[4] !== otherProps) {
    t1 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
    $[4] = otherProps;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t22;
  if ($[6] !== t0 || $[7] !== label || $[8] !== forwardedRef || $[9] !== styleProps || $[10] !== t1 || $[11] !== symbol) {
    t22 = (0, import_jsx_runtime4.jsx)("span", {
      "aria-hidden": t0,
      "aria-label": label,
      ref: forwardedRef,
      role: "img",
      ...styleProps,
      ...t1,
      children: symbol
    });
    $[6] = t0;
    $[7] = label;
    $[8] = forwardedRef;
    $[9] = styleProps;
    $[10] = t1;
    $[11] = symbol;
    $[12] = t22;
  } else {
    t22 = $[12];
  }
  return t22;
});
function noopSubscribe() {
  return () => {
  };
}
function useIsMac() {
  const $ = c2(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => false;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return (0, import_react63.useSyncExternalStore)(noopSubscribe, $c87311424ea30a05$export$9ac100e40613ea10, t0);
}
var Kbd = (0, import_react63.forwardRef)(function Kbd2(props, forwardedRef) {
  const $ = c2(25);
  props = useSlotProps(props, "kbd");
  let otherProps;
  let alt;
  let meta;
  let shift;
  let children;
  if ($[0] !== props) {
    ({
      alt,
      meta,
      shift,
      children,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = alt;
    $[3] = meta;
    $[4] = shift;
    $[5] = children;
  } else {
    otherProps = $[1];
    alt = $[2];
    meta = $[3];
    shift = $[4];
    children = $[5];
  }
  let t0;
  if ($[6] !== otherProps) {
    t0 = {
      casing: "full-width",
      color: "neutral",
      size: "regular",
      weight: "regular",
      ...otherProps
    };
    $[6] = otherProps;
    $[7] = t0;
  } else {
    t0 = $[7];
  }
  const styleProps = useTextStyles(t0);
  const isMac2 = useIsMac();
  let t1;
  let t22;
  if ($[8] !== isMac2) {
    t22 = isMac2 ? {
      alt: "⌥",
      meta: "⌘",
      shift: "⇧"
    } : {
      alt: "Alt",
      meta: "Ctrl",
      shift: "Shift"
    };
    $[8] = isMac2;
    $[9] = t22;
  } else {
    t22 = $[9];
  }
  const SYSTEM_KEYS = t22;
  const t32 = alt && SYSTEM_KEYS.alt;
  const t4 = shift && SYSTEM_KEYS.shift;
  const t5 = meta && SYSTEM_KEYS.meta;
  let t6;
  if ($[10] !== t32 || $[11] !== t4 || $[12] !== t5 || $[13] !== isMac2) {
    const keys3 = [t32, t4, t5].filter(Boolean);
    t6 = joinModifierKeys(keys3, isMac2);
    $[10] = t32;
    $[11] = t4;
    $[12] = t5;
    $[13] = isMac2;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  t1 = t6;
  const modifiers = t1;
  let t7;
  if ($[15] !== otherProps) {
    t7 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
    $[15] = otherProps;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  let t8;
  if ($[17] !== children) {
    t8 = (0, import_jsx_runtime4.jsx)(Char, {
      children
    });
    $[17] = children;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] !== t7 || $[20] !== styleProps || $[21] !== forwardedRef || $[22] !== modifiers || $[23] !== t8) {
    t9 = (0, import_jsx_runtime4.jsxs)("kbd", {
      ...t7,
      ...styleProps,
      dir: "ltr",
      ref: forwardedRef,
      children: [modifiers, t8]
    });
    $[19] = t7;
    $[20] = styleProps;
    $[21] = forwardedRef;
    $[22] = modifiers;
    $[23] = t8;
    $[24] = t9;
  } else {
    t9 = $[24];
  }
  return t9;
});
function Char(props) {
  const $ = c2(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      display: "inline-block",
      minWidth: "1em",
      textAlign: "center"
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = (0, import_jsx_runtime4.jsx)("span", {
      className: t0,
      ...props
    });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
function joinModifierKeys(modifiers, isMac2) {
  if (modifiers.length === 0) {
    return "";
  }
  let delimiter2 = isMac2 ? "" : "+";
  return modifiers.join(delimiter2) + delimiter2;
}
var Numeral = (0, import_react63.forwardRef)(function Numeral2(props, forwardedRef) {
  const $ = c2(15);
  props = useDerivedProps(props);
  validateProps(props);
  let t0;
  if ($[0] !== props) {
    t0 = optionsByFormat(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const formatter = $a916eb452884faea$export$b7a616150fdb9f44(t0);
  let value2;
  let textProps;
  if ($[2] !== props) {
    const {
      abbreviate,
      format,
      value: t12,
      ...t23
    } = props;
    value2 = t12;
    textProps = t23;
    $[2] = props;
    $[3] = value2;
    $[4] = textProps;
  } else {
    value2 = $[3];
    textProps = $[4];
  }
  const headingContext = useHeadingContext();
  let t1;
  if ($[5] !== formatter || $[6] !== value2) {
    t1 = formatter.format(value2);
    $[5] = formatter;
    $[6] = value2;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const formattedText = t1;
  if (headingContext) {
    let t23;
    if ($[8] !== forwardedRef || $[9] !== formattedText) {
      t23 = (0, import_jsx_runtime4.jsx)("span", {
        ref: forwardedRef,
        children: formattedText
      });
      $[8] = forwardedRef;
      $[9] = formattedText;
      $[10] = t23;
    } else {
      t23 = $[10];
    }
    return t23;
  }
  let t22;
  if ($[11] !== forwardedRef || $[12] !== textProps || $[13] !== formattedText) {
    t22 = (0, import_jsx_runtime4.jsx)(Text, {
      ref: forwardedRef,
      ...textProps,
      children: formattedText
    });
    $[11] = forwardedRef;
    $[12] = textProps;
    $[13] = formattedText;
    $[14] = t22;
  } else {
    t22 = $[14];
  }
  return t22;
});
function getFormat(props) {
  const {
    format,
    currency,
    unit
  } = props;
  if (format) {
    return format;
  }
  if (currency) {
    return "currency";
  }
  if (unit) {
    return "unit";
  }
  return "decimal";
}
function useDerivedProps(props) {
  return {
    ...props,
    format: getFormat(props)
  };
}
function toFractionDigits(precision) {
  return Array.isArray(precision) ? precision : [precision, precision];
}
function optionsByFormat(props) {
  const {
    abbreviate,
    format,
    precision,
    currency,
    unit
  } = props;
  const notation = abbreviate ? "compact" : void 0;
  const [minimumFractionDigits, maximumFractionDigits] = toFractionDigits(precision);
  const common = {
    maximumFractionDigits,
    minimumFractionDigits,
    notation,
    compactDisplay: abbreviate === "long" ? "long" : "short"
  };
  switch (format) {
    case "currency":
      return {
        ...common,
        style: "currency",
        currency,
        currencyDisplay: "narrowSymbol"
      };
    case "percent":
      return {
        ...common,
        style: "percent"
      };
    case "unit":
      return {
        ...common,
        style: "unit",
        unit,
        unitDisplay: "narrow"
      };
    default:
      return common;
  }
}
function validateProps(props) {
  const {
    format,
    currency,
    precision,
    unit
  } = props;
  assert(currency ? format === "currency" : true, 'When format is "currency", the currency property must be provided.');
  assert(unit ? format === "unit" : true, 'When format is "unit", the unit property must be provided.');
  assert(!(currency && unit), 'Formatting of "currency" and "unit" cannot be combined.');
  if (precision) {
    assert(Array.isArray(precision) ? precision.every(isInteger) : isInteger(precision), "Precision must be an integer, or an integer tuple for min/max.");
  }
}
var Prose = forwardRefWithAs((props, ref) => {
  const {
    children,
    elementType: ElementType = "div",
    ...otherProps
  } = props;
  const styleProps = useProseStyleProps(otherProps);
  return (0, import_jsx_runtime4.jsx)(ElementType, {
    ref,
    ...filterStyleProps(otherProps),
    ...styleProps,
    children
  });
});
function useProseStyleProps(props) {
  const $ = c2(11);
  let t0;
  let otherProps;
  if ($[0] !== props) {
    ({
      size: t0,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = otherProps;
  } else {
    t0 = $[1];
    otherProps = $[2];
  }
  const size3 = t0 === void 0 ? "medium" : t0;
  const styleProps = useStyleProps(otherProps);
  let t1;
  if ($[3] !== size3) {
    t1 = toDataAttributes({
      size: size3
    });
    $[3] = size3;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t22;
  if ($[5] !== styleProps.className) {
    t22 = classNames(css({
      color: tokenSchema.color.foreground.neutral,
      fontFamily: tokenSchema.typography.fontFamily.base,
      height: "100%",
      maxWidth: "100%",
      minHeight: 0,
      minWidth: 0,
      position: "relative",
      overflowWrap: "break-word",
      whiteSpace: "break-spaces",
      fontVariantLigatures: "none",
      fontFeatureSettings: '"liga" 0',
      MozOsxFontSmoothing: "auto",
      WebkitFontSmoothing: "auto",
      '&[data-size="small"]': {
        fontSize: tokenSchema.typography.text.small.size,
        lineHeight: 1.6
      },
      '&[data-size="regular"]': {
        fontSize: tokenSchema.typography.text.regular.size,
        lineHeight: 1.5
      },
      '&[data-size="medium"]': {
        fontSize: tokenSchema.typography.text.medium.size,
        lineHeight: 1.5
      },
      '&[data-size="large"]': {
        fontSize: tokenSchema.typography.text.large.size,
        lineHeight: 1.4
      },
      "& :is(blockquote, p, pre, ol, ul, table)": {
        marginBlock: "0.75em",
        ":first-child": {
          marginTop: 0
        },
        ":last-child": {
          marginBottom: 0
        }
      },
      "ol, ul": {
        paddingInlineStart: "1em"
      },
      "ol ol, ul ul, ol ul, ul ol": {
        marginBlock: 0
      },
      "li :is(blockquote, p, pre, ol, ul, table)": {
        marginBottom: 0
      },
      blockquote: {
        borderInlineStart: `${tokenSchema.size.border.large} solid ${tokenSchema.color.foreground.neutral}`,
        marginInline: 0,
        paddingInlineStart: "1em"
      },
      hr: {
        backgroundColor: tokenSchema.color.alias.borderIdle,
        border: 0,
        borderRadius: tokenSchema.size.border.medium,
        height: tokenSchema.size.border.medium,
        marginBlock: "1.5em"
      },
      img: {
        height: "auto",
        maxWidth: "100%"
      },
      strong: {
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      a: {
        color: tokenSchema.color.foreground.accent
      },
      pre: {
        backgroundColor: tokenSchema.color.background.surface,
        borderRadius: tokenSchema.size.radius.medium,
        color: tokenSchema.color.foreground.neutralEmphasis,
        fontFamily: tokenSchema.typography.fontFamily.code,
        fontSize: "0.85em",
        lineHeight: tokenSchema.typography.lineheight.medium,
        minWidth: 0,
        maxWidth: "100%",
        overflow: "auto",
        padding: tokenSchema.size.space.medium,
        whiteSpace: "pre-wrap"
      },
      "pre > code": {
        fontFamily: "inherit"
      },
      "& :not(pre) > code": {
        backgroundColor: tokenSchema.color.background.accent,
        borderRadius: tokenSchema.size.radius.small,
        color: tokenSchema.color.foreground.neutralEmphasis,
        display: "inline-block",
        fontSize: "0.85em",
        fontFamily: tokenSchema.typography.fontFamily.code,
        paddingInline: tokenSchema.size.space.small
      },
      "& :is(h1, h2, h3, h4, h5, h6)": {
        color: tokenSchema.color.foreground.neutralEmphasis,
        lineHeight: 1.25,
        marginTop: "1.5em",
        marginBottom: "0.67em",
        ":first-child": {
          marginTop: 0
        },
        ":last-child": {
          marginBottom: 0
        }
      },
      h1: {
        fontSize: "2em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h2: {
        fontSize: "1.5em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h3: {
        fontSize: "1.25em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h4: {
        fontSize: "1.1em",
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      h5: {
        fontSize: "1em",
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      h6: {
        fontSize: "0.9em",
        fontWeight: tokenSchema.typography.fontWeight.semibold,
        letterSpacing: "0.0125em"
      },
      ...getListStyles()
    }), styleProps.className);
    $[5] = styleProps.className;
    $[6] = t22;
  } else {
    t22 = $[6];
  }
  let t32;
  if ($[7] !== styleProps || $[8] !== t1 || $[9] !== t22) {
    t32 = {
      ...styleProps,
      ...t1,
      className: t22
    };
    $[7] = styleProps;
    $[8] = t1;
    $[9] = t22;
    $[10] = t32;
  } else {
    t32 = $[10];
  }
  return t32;
}
function getListStyles() {
  let styles = {};
  let listDepth = 10;
  const orderedListStyles = ["lower-roman", "decimal", "lower-alpha"];
  const unorderedListStyles = ["square", "disc", "circle"];
  while (listDepth--) {
    let arr = Array.from({
      length: listDepth
    });
    if (arr.length) {
      styles[arr.map(() => `ol`).join(" ")] = {
        listStyle: orderedListStyles[listDepth % 3]
      };
      styles[arr.map(() => `ul`).join(" ")] = {
        listStyle: unorderedListStyles[listDepth % 3]
      };
    }
  }
  return styles;
}

// node_modules/@react-aria/label/dist/useLabel.mjs
function $d191a55c9702f145$export$8467354a121f1b9f(props) {
  let { id: id2, label, "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel, labelElementType = "label" } = props;
  id2 = (0, $bdb11010cef70236$export$f680877a34711e37)(id2);
  let labelId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let labelProps = {};
  if (label) {
    ariaLabelledby = ariaLabelledby ? `${labelId} ${ariaLabelledby}` : labelId;
    labelProps = {
      id: labelId,
      htmlFor: labelElementType === "label" ? id2 : void 0
    };
  } else if (!ariaLabelledby && !ariaLabel) console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
  let fieldProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id: id2,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby
  });
  return {
    labelProps,
    fieldProps
  };
}

// node_modules/@react-aria/label/dist/useField.mjs
function $2baaea4c71418dea$export$294aa081a6c6f55d(props) {
  let { description, errorMessage, isInvalid, validationState } = props;
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)(props);
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)([
    Boolean(description),
    Boolean(errorMessage),
    isInvalid,
    validationState
  ]);
  let errorMessageId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)([
    Boolean(description),
    Boolean(errorMessage),
    isInvalid,
    validationState
  ]);
  fieldProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(fieldProps, {
    "aria-describedby": [
      descriptionId,
      // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
      errorMessageId,
      props["aria-describedby"]
    ].filter(Boolean).join(" ") || void 0
  });
  return {
    labelProps,
    fieldProps,
    descriptionProps: {
      id: descriptionId
    },
    errorMessageProps: {
      id: errorMessageId
    }
  };
}

// node_modules/@react-aria/progress/dist/useProgressBar.mjs
function $204d9ebcedfb8806$export$ed5abd763a836edc(props) {
  let { value: value2 = 0, minValue = 0, maxValue = 100, valueLabel, isIndeterminate, formatOptions = {
    style: "percent"
  } } = props;
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)({
    ...props,
    // Progress bar is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span"
  });
  value2 = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(value2, minValue, maxValue);
  let percentage = (value2 - minValue) / (maxValue - minValue);
  let formatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)(formatOptions);
  if (!isIndeterminate && !valueLabel) {
    let valueToFormat = formatOptions.style === "percent" ? percentage : value2;
    valueLabel = formatter.format(valueToFormat);
  }
  return {
    progressBarProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...fieldProps,
      "aria-valuenow": isIndeterminate ? void 0 : value2,
      "aria-valuemin": minValue,
      "aria-valuemax": maxValue,
      "aria-valuetext": isIndeterminate ? void 0 : valueLabel,
      role: "progressbar"
    }),
    labelProps
  };
}

// node_modules/@react-aria/meter/dist/useMeter.mjs
function $0002d7e1d16de204$export$e969dbfa146870ff(props) {
  let { progressBarProps, labelProps } = (0, $204d9ebcedfb8806$export$ed5abd763a836edc)(props);
  return {
    meterProps: {
      ...progressBarProps,
      // Use the meter role if available, but fall back to progressbar if not
      // Chrome currently falls back from meter automatically, and Firefox
      // does not support meter at all. Safari 13+ seems to support meter properly.
      // https://bugs.chromium.org/p/chromium/issues/detail?id=944542
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1460378
      role: "meter progressbar"
    },
    labelProps
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-progress.js
var import_react64 = __toESM(require_react());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var BarBase = (0, import_react64.forwardRef)(function BarBase2(props, forwardedRef) {
  var _isIndeterminate;
  const $ = c2(42);
  let t0;
  let t1;
  let t22;
  let t32;
  let label;
  let otherProps;
  let isIndeterminate;
  let ariaLabel;
  let ariaLabelledby;
  let barClassName;
  let labelProps;
  let barProps;
  if ($[0] !== props) {
    ({
      value: t0,
      minValue: t1,
      maxValue: t22,
      label,
      barClassName,
      showValueLabel: t32,
      isIndeterminate,
      barProps,
      labelProps,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = t22;
    $[4] = t32;
    $[5] = label;
    $[6] = otherProps;
    $[7] = isIndeterminate;
    $[8] = ariaLabel;
    $[9] = ariaLabelledby;
    $[10] = barClassName;
    $[11] = labelProps;
    $[12] = barProps;
  } else {
    t0 = $[1];
    t1 = $[2];
    t22 = $[3];
    t32 = $[4];
    label = $[5];
    otherProps = $[6];
    isIndeterminate = $[7];
    ariaLabel = $[8];
    ariaLabelledby = $[9];
    barClassName = $[10];
    labelProps = $[11];
    barProps = $[12];
  }
  let value2 = t0 === void 0 ? 0 : t0;
  const minValue = t1 === void 0 ? 0 : t1;
  const maxValue = t22 === void 0 ? 100 : t22;
  const showValueLabel = t32 === void 0 ? !!label : t32;
  const styleProps = useStyleProps(otherProps);
  value2 = $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, minValue, maxValue);
  let barStyle;
  if ($[13] !== isIndeterminate || $[14] !== value2 || $[15] !== minValue || $[16] !== maxValue) {
    barStyle = {};
    if (!isIndeterminate) {
      const percentage = (value2 - minValue) / (maxValue - minValue);
      barStyle.width = `${Math.round(percentage * 100)}%`;
    }
    $[13] = isIndeterminate;
    $[14] = value2;
    $[15] = minValue;
    $[16] = maxValue;
    $[17] = barStyle;
  } else {
    barStyle = $[17];
  }
  warning(!!(label || ariaLabel || ariaLabelledby), "If you do not provide a visible label via children, you must specify an aria-label or aria-labelledby attribute for accessibility.");
  let t4;
  if ($[18] !== barClassName || $[19] !== styleProps.className) {
    t4 = classNames(css({
      "--bar-fill": tokenSchema.color.background.accentEmphasis,
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      flexFlow: "wrap",
      isolation: "isolate",
      justifyContent: "space-between",
      minWidth: 0,
      position: "relative",
      verticalAlign: "top",
      width: tokenSchema.size.alias.singleLineWidth
    }), barClassName, styleProps.className);
    $[18] = barClassName;
    $[19] = styleProps.className;
    $[20] = t4;
  } else {
    t4 = $[20];
  }
  let t5;
  if ($[21] !== label || $[22] !== labelProps) {
    t5 = label && (0, import_jsx_runtime5.jsx)(Text, {
      ...labelProps,
      flex: true,
      children: label
    });
    $[21] = label;
    $[22] = labelProps;
    $[23] = t5;
  } else {
    t5 = $[23];
  }
  let t6;
  if ($[24] !== showValueLabel || $[25] !== barProps) {
    t6 = showValueLabel && barProps && (0, import_jsx_runtime5.jsx)(Text, {
      flexShrink: 0,
      children: barProps["aria-valuetext"]
    });
    $[24] = showValueLabel;
    $[25] = barProps;
    $[26] = t6;
  } else {
    t6 = $[26];
  }
  let t7;
  if ($[27] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = css({
      backgroundColor: tokenSchema.color.border.muted,
      borderRadius: tokenSchema.size.radius.full,
      height: tokenSchema.size.space.regular,
      minWidth: 0,
      overflow: "hidden",
      width: "100%",
      zIndex: "1"
    });
    $[27] = t7;
  } else {
    t7 = $[27];
  }
  const t8 = (_isIndeterminate = isIndeterminate) !== null && _isIndeterminate !== void 0 ? _isIndeterminate : void 0;
  let t9;
  if ($[28] !== t8) {
    t9 = toDataAttributes({
      indeterminate: t8
    });
    $[28] = t8;
    $[29] = t9;
  } else {
    t9 = $[29];
  }
  let t10;
  if ($[30] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = css({
      backgroundColor: "var(--bar-fill)",
      height: tokenSchema.size.space.regular,
      transition: transition("width", {
        duration: "regular"
      }),
      "&[data-indeterminate]": {
        animation: `${indeterminateLoopLtr} ${tokenSchema.animation.duration.long} ${tokenSchema.animation.easing.easeInOut} infinite`,
        willChange: "transform",
        "[dir=rtl] &": {
          animationName: indeterminateLoopRtl
        }
      }
    });
    $[30] = t10;
  } else {
    t10 = $[30];
  }
  let t11;
  if ($[31] !== t9 || $[32] !== barStyle) {
    t11 = (0, import_jsx_runtime5.jsx)("div", {
      className: t7,
      children: (0, import_jsx_runtime5.jsx)("div", {
        ...t9,
        className: t10,
        style: barStyle
      })
    });
    $[31] = t9;
    $[32] = barStyle;
    $[33] = t11;
  } else {
    t11 = $[33];
  }
  let t12;
  if ($[34] !== barProps || $[35] !== styleProps || $[36] !== forwardedRef || $[37] !== t4 || $[38] !== t5 || $[39] !== t6 || $[40] !== t11) {
    t12 = (0, import_jsx_runtime5.jsxs)("div", {
      ...barProps,
      ...styleProps,
      ref: forwardedRef,
      className: t4,
      children: [t5, t6, t11]
    });
    $[34] = barProps;
    $[35] = styleProps;
    $[36] = forwardedRef;
    $[37] = t4;
    $[38] = t5;
    $[39] = t6;
    $[40] = t11;
    $[41] = t12;
  } else {
    t12 = $[41];
  }
  return t12;
});
var indeterminateLoopLtr = keyframes({
  from: {
    transform: "translate(-100%)"
  },
  to: {
    transform: "translate(100%)"
  }
});
var indeterminateLoopRtl = keyframes({
  from: {
    transform: "translate(100%)"
  },
  to: {
    transform: "translate(-100%)"
  }
});
var Meter = (0, import_react64.forwardRef)(function Meter2(props, forwardedRef) {
  const $ = c2(14);
  let tone;
  let otherProps;
  if ($[0] !== props) {
    ({
      tone,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = tone;
    $[2] = otherProps;
  } else {
    tone = $[1];
    otherProps = $[2];
  }
  const {
    meterProps,
    labelProps
  } = $0002d7e1d16de204$export$e969dbfa146870ff(props);
  let t0;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      '&[data-tone="positive"]': {
        "--bar-fill": tokenSchema.color.background.positiveEmphasis
      },
      '&[data-tone="caution"]': {
        "--bar-fill": tokenSchema.color.background.cautionEmphasis
      },
      '&[data-tone="critical"]': {
        "--bar-fill": tokenSchema.color.background.criticalEmphasis
      }
    });
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  let t1;
  if ($[4] !== tone) {
    t1 = toDataAttributes({
      tone
    });
    $[4] = tone;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t22;
  if ($[6] !== meterProps || $[7] !== t1) {
    t22 = {
      ...meterProps,
      ...t1
    };
    $[6] = meterProps;
    $[7] = t1;
    $[8] = t22;
  } else {
    t22 = $[8];
  }
  let t32;
  if ($[9] !== otherProps || $[10] !== forwardedRef || $[11] !== t22 || $[12] !== labelProps) {
    t32 = (0, import_jsx_runtime5.jsx)(BarBase, {
      ...otherProps,
      ref: forwardedRef,
      barClassName: t0,
      barProps: t22,
      labelProps
    });
    $[9] = otherProps;
    $[10] = forwardedRef;
    $[11] = t22;
    $[12] = labelProps;
    $[13] = t32;
  } else {
    t32 = $[13];
  }
  return t32;
});
var ProgressBar = (0, import_react64.forwardRef)(function ProgressBar2(props, forwardedRef) {
  const $ = c2(5);
  const {
    progressBarProps,
    labelProps
  } = $204d9ebcedfb8806$export$ed5abd763a836edc(props);
  let t0;
  if ($[0] !== props || $[1] !== forwardedRef || $[2] !== progressBarProps || $[3] !== labelProps) {
    t0 = (0, import_jsx_runtime5.jsx)(BarBase, {
      ...props,
      ref: forwardedRef,
      barProps: progressBarProps,
      labelProps
    });
    $[0] = props;
    $[1] = forwardedRef;
    $[2] = progressBarProps;
    $[3] = labelProps;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
});
var ProgressCircle = (0, import_react64.forwardRef)(function ProgressCircle2(props, forwardRef18) {
  var _isIndeterminate, _isIndeterminate2, _isIndeterminate3;
  const $ = c2(40);
  let t0;
  let t1;
  let t22;
  let t32;
  let otherProps;
  let ariaLabel;
  let ariaLabelledby;
  let isIndeterminate;
  if ($[0] !== props) {
    ({
      value: t0,
      minValue: t1,
      maxValue: t22,
      size: t32,
      isIndeterminate,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = t22;
    $[4] = t32;
    $[5] = otherProps;
    $[6] = ariaLabel;
    $[7] = ariaLabelledby;
    $[8] = isIndeterminate;
  } else {
    t0 = $[1];
    t1 = $[2];
    t22 = $[3];
    t32 = $[4];
    otherProps = $[5];
    ariaLabel = $[6];
    ariaLabelledby = $[7];
    isIndeterminate = $[8];
  }
  let value2 = t0 === void 0 ? 0 : t0;
  const minValue = t1 === void 0 ? 0 : t1;
  const maxValue = t22 === void 0 ? 100 : t22;
  const size3 = t32 === void 0 ? "medium" : t32;
  value2 = $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, minValue, maxValue);
  let t4;
  if ($[9] !== props || $[10] !== value2) {
    t4 = {
      ...props,
      value: value2
    };
    $[9] = props;
    $[10] = value2;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  const {
    progressBarProps
  } = $204d9ebcedfb8806$export$ed5abd763a836edc(t4);
  const styleProps = useStyleProps(otherProps);
  warning(!!(ariaLabel || ariaLabelledby), "ProgressCircle requires an aria-label or aria-labelledby attribute for accessibility.");
  const t5 = (_isIndeterminate = isIndeterminate) !== null && _isIndeterminate !== void 0 ? _isIndeterminate : void 0;
  const t6 = size3 === "medium" ? void 0 : size3;
  let t7;
  if ($[12] !== t5 || $[13] !== t6) {
    t7 = toDataAttributes({
      indeterminate: t5,
      size: t6
    });
    $[12] = t5;
    $[13] = t6;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] !== styleProps.className) {
    t8 = classNames(css({
      height: "var(--diameter)",
      width: "var(--diameter)",
      "--diameter": tokenSchema.size.element.regular,
      "--radius": "calc(var(--diameter) / 2)",
      "--stroke-width": tokenSchema.size.scale[40],
      "--offset-radius": "calc(var(--radius) - var(--stroke-width) / 2)",
      "--circumference": `calc(var(--offset-radius) * pi * 2)`,
      "&[data-size=small]": {
        "--diameter": tokenSchema.size.element.xsmall,
        "--stroke-width": tokenSchema.size.border.medium
      },
      "&[data-size=large]": {
        "--diameter": tokenSchema.size.element.xlarge,
        "--stroke-width": tokenSchema.size.border.large
      }
    }), styleProps.className);
    $[15] = styleProps.className;
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  const t9 = (value2 - minValue) / (maxValue - minValue);
  let t10;
  if ($[17] !== t9 || $[18] !== styleProps.style) {
    t10 = {
      "--percent": t9,
      ...styleProps.style
    };
    $[17] = t9;
    $[18] = styleProps.style;
    $[19] = t10;
  } else {
    t10 = $[19];
  }
  const t11 = (_isIndeterminate2 = isIndeterminate) !== null && _isIndeterminate2 !== void 0 ? _isIndeterminate2 : void 0;
  let t12;
  if ($[20] !== t11) {
    t12 = toDataAttributes({
      indeterminate: t11
    });
    $[20] = t11;
    $[21] = t12;
  } else {
    t12 = $[21];
  }
  let t13;
  if ($[22] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = css({
      height: "var(--diameter)",
      width: "var(--diameter)",
      "&[data-indeterminate]": {
        animation: `${rotateAnimation} ${tokenSchema.animation.duration.xlong} linear infinite`
      }
    });
    $[22] = t13;
  } else {
    t13 = $[22];
  }
  let t14;
  if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = (0, import_jsx_runtime5.jsx)("circle", {
      className: circle({
        stroke: tokenSchema.color.border.muted
      })
    });
    $[23] = t14;
  } else {
    t14 = $[23];
  }
  const t15 = (_isIndeterminate3 = isIndeterminate) !== null && _isIndeterminate3 !== void 0 ? _isIndeterminate3 : void 0;
  let t16;
  if ($[24] !== t15) {
    t16 = toDataAttributes({
      indeterminate: t15
    });
    $[24] = t15;
    $[25] = t16;
  } else {
    t16 = $[25];
  }
  let t17;
  if ($[26] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = circle({
      stroke: tokenSchema.color.background.accentEmphasis,
      strokeDasharray: "var(--circumference)",
      strokeLinecap: "round",
      "&:not([data-indeterminate])": {
        strokeDashoffset: `calc(var(--circumference) - var(--percent) * var(--circumference))`,
        transition: transition("stroke-dashoffset", {
          duration: "regular"
        }),
        transform: "rotate(-90deg)",
        transformOrigin: "center"
      },
      "&[data-indeterminate]": {
        animation: `${dashAnimation} ${tokenSchema.animation.duration.xlong} ${tokenSchema.animation.easing.easeInOut} infinite`
      }
    });
    $[26] = t17;
  } else {
    t17 = $[26];
  }
  let t18;
  if ($[27] !== t16) {
    t18 = (0, import_jsx_runtime5.jsx)("circle", {
      ...t16,
      className: t17
    });
    $[27] = t16;
    $[28] = t18;
  } else {
    t18 = $[28];
  }
  let t19;
  if ($[29] !== t12 || $[30] !== t18) {
    t19 = (0, import_jsx_runtime5.jsxs)("svg", {
      ...t12,
      role: "presentation",
      tabIndex: -1,
      className: t13,
      children: [t14, t18]
    });
    $[29] = t12;
    $[30] = t18;
    $[31] = t19;
  } else {
    t19 = $[31];
  }
  let t20;
  if ($[32] !== styleProps || $[33] !== progressBarProps || $[34] !== forwardRef18 || $[35] !== t7 || $[36] !== t8 || $[37] !== t10 || $[38] !== t19) {
    t20 = (0, import_jsx_runtime5.jsx)("div", {
      ...styleProps,
      ...progressBarProps,
      ref: forwardRef18,
      ...t7,
      className: t8,
      style: t10,
      children: t19
    });
    $[32] = styleProps;
    $[33] = progressBarProps;
    $[34] = forwardRef18;
    $[35] = t7;
    $[36] = t8;
    $[37] = t10;
    $[38] = t19;
    $[39] = t20;
  } else {
    t20 = $[39];
  }
  return t20;
});
function circle(styles) {
  return css([{
    cx: "var(--radius)",
    cy: "var(--radius)",
    r: "var(--offset-radius)",
    fill: "transparent",
    strokeWidth: "var(--stroke-width)"
  }, styles]);
}
var rotateAnimation = keyframes({
  from: {
    transform: "rotate(0deg)"
  },
  to: {
    transform: "rotate(360deg)"
  }
});
var dashAnimation = keyframes({
  from: {
    strokeDashoffset: "calc(var(--circumference) * 1.25)"
  },
  to: {
    strokeDashoffset: "calc(var(--circumference) * -0.75)"
  }
});

// node_modules/@keystar/ui/dist/keystar-ui-icon.js
var import_react65 = __toESM(require_react());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var STROKE_VAR = `--${TOKEN_PREFIX}-icon-stroke`;
var Icon = (props) => {
  var _maybeTokenByKey;
  props = useSlotProps(props, "icon");
  const {
    strokeScaling,
    size: size3,
    color,
    ...otherProps
  } = props;
  const stroke = (_maybeTokenByKey = maybeTokenByKey("color.foreground", color)) !== null && _maybeTokenByKey !== void 0 ? _maybeTokenByKey : "currentColor";
  const iconClassName2 = css({
    fill: "none",
    stroke: `var(${STROKE_VAR})`,
    flexShrink: 0,
    height: tokenSchema.size.icon.regular,
    width: tokenSchema.size.icon.regular,
    "&[data-size=small]": {
      height: tokenSchema.size.icon.small,
      width: tokenSchema.size.icon.small
    },
    "&[data-size=medium]": {
      height: tokenSchema.size.icon.medium,
      width: tokenSchema.size.icon.medium
    },
    "&[data-size=large]": {
      height: tokenSchema.size.icon.large,
      width: tokenSchema.size.icon.large
    },
    // Maintain stroke width, no matter the size.
    // @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/vector-effect#non-scaling-stroke
    "&[data-stroke-scaling=false] > *": {
      vectorEffect: "non-scaling-stroke"
    }
  });
  const styleProps = useStyleProps(otherProps);
  const hasAriaLabel = "aria-label" in props && !!props["aria-label"];
  return (0, import_jsx_runtime6.jsx)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...toDataAttributes({
      strokeScaling,
      size: size3
    }),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    "aria-hidden": !hasAriaLabel,
    focusable: "false",
    role: "img",
    className: classNames(iconClassName2, styleProps.className),
    style: {
      [STROKE_VAR]: stroke,
      ...styleProps.style
    },
    height: "1em",
    children: props.src
  });
};

// node_modules/@keystar/ui/dist/keystar-ui-button.js
var import_react66 = __toESM(require_react());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());

// node_modules/@react-aria/button/dist/useButton.mjs
function $701a24aa0da5b062$export$ea18c227d4417cc3(props, ref) {
  let {
    elementType = "button",
    isDisabled,
    onPress,
    onPressStart,
    onPressEnd,
    onPressUp,
    onPressChange,
    preventFocusOnPress,
    allowFocusWhenDisabled,
    // @ts-ignore
    onClick: deprecatedOnClick,
    href,
    target,
    rel,
    type: type3 = "button"
  } = props;
  let additionalProps;
  if (elementType === "button") additionalProps = {
    type: type3,
    disabled: isDisabled
  };
  else additionalProps = {
    role: "button",
    tabIndex: isDisabled ? void 0 : 0,
    href: elementType === "a" && isDisabled ? void 0 : href,
    target: elementType === "a" ? target : void 0,
    type: elementType === "input" ? type3 : void 0,
    disabled: elementType === "input" ? isDisabled : void 0,
    "aria-disabled": !isDisabled || elementType === "input" ? void 0 : isDisabled,
    rel: elementType === "a" ? rel : void 0
  };
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPressStart,
    onPressEnd,
    onPressChange,
    onPress,
    onPressUp,
    isDisabled,
    preventFocusOnPress,
    ref
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  if (allowFocusWhenDisabled) focusableProps.tabIndex = isDisabled ? -1 : focusableProps.tabIndex;
  let buttonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, pressProps, (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  }));
  return {
    isPressed,
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(additionalProps, buttonProps, {
      "aria-haspopup": props["aria-haspopup"],
      "aria-expanded": props["aria-expanded"],
      "aria-controls": props["aria-controls"],
      "aria-pressed": props["aria-pressed"],
      onClick: (e4) => {
        if (deprecatedOnClick) {
          deprecatedOnClick(e4);
          console.warn("onClick is deprecated, please use onPress");
        }
      }
    })
  };
}

// node_modules/@react-aria/button/dist/useToggleButton.mjs
function $55f54f7887471b58$export$51e84d46ca0bc451(props, state, ref) {
  const { isSelected } = state;
  const { isPressed, buttonProps } = (0, $701a24aa0da5b062$export$ea18c227d4417cc3)({
    ...props,
    onPress: (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(state.toggle, props.onPress)
  }, ref);
  return {
    isPressed,
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(buttonProps, {
      "aria-pressed": isSelected
    })
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-xIcon.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var xIcon = (0, import_jsx_runtime7.jsx)("path", {
  d: "M18 6 6 18M6 6l12 12"
});

// node_modules/@react-stately/toggle/dist/useToggleState.mjs
function $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {
  let { isReadOnly } = props;
  let [isSelected, setSelected] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.isSelected, props.defaultSelected || false, props.onChange);
  function updateSelected(value2) {
    if (!isReadOnly) setSelected(value2);
  }
  function toggleState() {
    if (!isReadOnly) setSelected(!isSelected);
  }
  return {
    isSelected,
    setSelected: updateSelected,
    toggle: toggleState
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-button.js
function getCheckForOverflow(domRef, orientation, _scale, setHasOverflow, _children) {
  return () => {
    let computeHasOverflow = () => {
      if (domRef.current && orientation === "horizontal") {
        let buttonGroupChildren = Array.from(domRef.current.children);
        let maxX = domRef.current.offsetWidth + 1;
        if (buttonGroupChildren.some((child) => child.offsetLeft < 0 || child.offsetLeft + child.offsetWidth > maxX)) {
          return true;
        }
        return false;
      }
    };
    if (orientation === "horizontal") {
      setHasOverflow(function* () {
        yield false;
        yield computeHasOverflow();
      });
    }
  };
}
var ButtonGroup = (0, import_react66.forwardRef)(function ButtonGroup2(props, forwardedRef) {
  const $ = c2(37);
  const {
    scale
  } = useProvider();
  props = useProviderProps(props);
  props = useSlotProps(props, "buttonGroup");
  let t0;
  let t1;
  let otherProps;
  let children;
  let isDisabled;
  if ($[0] !== props) {
    ({
      align: t0,
      children,
      isDisabled,
      orientation: t1,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = otherProps;
    $[4] = children;
    $[5] = isDisabled;
  } else {
    t0 = $[1];
    t1 = $[2];
    otherProps = $[3];
    children = $[4];
    isDisabled = $[5];
  }
  const align = t0 === void 0 ? "start" : t0;
  const orientation = t1 === void 0 ? "horizontal" : t1;
  const styleProps = useStyleProps(otherProps);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const [hasOverflow, setHasOverflow] = $1dbecbe27a04f9af$export$14d238f342723f25(false);
  let t22;
  let t32;
  if ($[6] !== domRef || $[7] !== orientation || $[8] !== scale || $[9] !== setHasOverflow || $[10] !== children) {
    t32 = getCheckForOverflow(domRef, orientation, scale, setHasOverflow);
    $[6] = domRef;
    $[7] = orientation;
    $[8] = scale;
    $[9] = setHasOverflow;
    $[10] = children;
    $[11] = t32;
  } else {
    t32 = $[11];
  }
  t22 = t32;
  const checkForOverflow = t22;
  let t4;
  let t5;
  if ($[12] !== checkForOverflow) {
    t4 = () => {
      checkForOverflow();
    };
    t5 = [checkForOverflow];
    $[12] = checkForOverflow;
    $[13] = t4;
    $[14] = t5;
  } else {
    t4 = $[13];
    t5 = $[14];
  }
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(t4, t5);
  const parent = (0, import_react66.useRef)();
  let t6;
  if ($[15] !== domRef.current) {
    t6 = () => {
      if (domRef.current) {
        parent.current = domRef.current.parentElement;
      }
    };
    $[15] = domRef.current;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(t6);
  let t7;
  if ($[17] !== parent || $[18] !== checkForOverflow) {
    t7 = {
      ref: parent,
      onResize: checkForOverflow
    };
    $[17] = parent;
    $[18] = checkForOverflow;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  $9daab02d461809db$export$683480f191c0e3ea(t7);
  let t8;
  if ($[20] !== otherProps) {
    t8 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
    $[20] = otherProps;
    $[21] = t8;
  } else {
    t8 = $[21];
  }
  const t9 = hasOverflow ? "vertical" : orientation;
  let t10;
  if ($[22] !== align || $[23] !== t9) {
    t10 = toDataAttributes({
      align,
      orientation: t9
    });
    $[22] = align;
    $[23] = t9;
    $[24] = t10;
  } else {
    t10 = $[24];
  }
  let t11;
  if ($[25] !== styleProps.className) {
    t11 = classNames(styleProps.className, css({
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      position: "relative",
      '&[data-orientation="horizontal"]': {
        '&[data-align="center"]': {
          justifyContent: "center"
        },
        '&[data-align="end"]': {
          justifyContent: "flex-end"
        }
      },
      '&[data-orientation="vertical"]': {
        flexDirection: "column",
        '&[data-align="center"]': {
          alignItems: "center"
        },
        '&[data-align="end"]': {
          alignItems: "flex-end"
        }
      }
    }));
    $[25] = styleProps.className;
    $[26] = t11;
  } else {
    t11 = $[26];
  }
  let t12;
  if ($[27] !== isDisabled || $[28] !== children) {
    t12 = (0, import_jsx_runtime8.jsx)(KeystarProvider, {
      isDisabled,
      children
    });
    $[27] = isDisabled;
    $[28] = children;
    $[29] = t12;
  } else {
    t12 = $[29];
  }
  let t13;
  if ($[30] !== t8 || $[31] !== t10 || $[32] !== styleProps || $[33] !== domRef || $[34] !== t11 || $[35] !== t12) {
    t13 = (0, import_jsx_runtime8.jsx)("div", {
      ...t8,
      ...t10,
      ...styleProps,
      ref: domRef,
      className: t11,
      children: t12
    });
    $[30] = t8;
    $[31] = t10;
    $[32] = styleProps;
    $[33] = domRef;
    $[34] = t11;
    $[35] = t12;
    $[36] = t13;
  } else {
    t13 = $[36];
  }
  return t13;
});
var localizedMessages = {
  "ar-AE": {
    "pending": `قيد الانتظار`
  },
  "bg-BG": {
    "pending": `недовършено`
  },
  "cs-CZ": {
    "pending": `čeká na vyřízení`
  },
  "da-DK": {
    "pending": `afventende`
  },
  "de-DE": {
    "pending": `Ausstehend`
  },
  "el-GR": {
    "pending": `σε εκκρεμότητα`
  },
  "en-US": {
    "pending": `pending`
  },
  "es-ES": {
    "pending": `pendiente`
  },
  "et-EE": {
    "pending": `ootel`
  },
  "fi-FI": {
    "pending": `odottaa`
  },
  "fr-FR": {
    "pending": `En attente`
  },
  "he-IL": {
    "pending": `ממתין ל`
  },
  "hr-HR": {
    "pending": `u tijeku`
  },
  "hu-HU": {
    "pending": `függőben levő`
  },
  "it-IT": {
    "pending": `in sospeso`
  },
  "ja-JP": {
    "pending": `保留`
  },
  "ko-KR": {
    "pending": `보류 중`
  },
  "lt-LT": {
    "pending": `laukiama`
  },
  "lv-LV": {
    "pending": `gaida`
  },
  "nb-NO": {
    "pending": `avventer`
  },
  "nl-NL": {
    "pending": `in behandeling`
  },
  "pl-PL": {
    "pending": `oczekujące`
  },
  "pt-BR": {
    "pending": `pendente`
  },
  "pt-PT": {
    "pending": `pendente`
  },
  "ro-RO": {
    "pending": `în așteptare`
  },
  "ru-RU": {
    "pending": `в ожидании`
  },
  "sk-SK": {
    "pending": `čakajúce`
  },
  "sl-SI": {
    "pending": `v teku`
  },
  "sr-SP": {
    "pending": `nerešeno`
  },
  "sv-SE": {
    "pending": `väntande`
  },
  "tr-TR": {
    "pending": `beklemede`
  },
  "uk-UA": {
    "pending": `в очікуванні`
  },
  "zh-CN": {
    "pending": `待处理`
  },
  "zh-TW": {
    "pending": `待處理`
  }
};
var buttonClassList = new ClassList("Button", ["icon", "text"]);
function useButtonStyles(props, state) {
  const {
    prominence = "default",
    tone = prominence === "high" ? "accent" : "neutral"
  } = props;
  const {
    isHovered,
    isPending,
    isPressed
  } = state;
  const styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      hovered: isHovered || void 0,
      pending: isPending || void 0,
      pressed: isPressed || void 0,
      prominence: prominence === "default" ? void 0 : prominence,
      tone,
      static: props.static
    }),
    style: styleProps.style,
    className: classNames(buttonClassList.element("root"), css({
      alignItems: "center",
      borderRadius: tokenSchema.size.radius.full,
      cursor: "default",
      display: "inline-flex",
      flexShrink: 0,
      fontSize: tokenSchema.typography.text.regular.size,
      fontWeight: tokenSchema.typography.fontWeight.medium,
      height: tokenSchema.size.element.regular,
      justifyContent: "center",
      minWidth: tokenSchema.size.element.regular,
      outline: 0,
      paddingInline: tokenSchema.size.space.medium,
      position: "relative",
      transitionDuration: "130ms",
      transitionProperty: "background, border-color, box-shadow, color, ",
      transitionTimingFunction: "ease-out",
      userSelect: "none",
      // indicate when external link? e.g. `&[href^=http]`
      "a&": {
        cursor: "pointer"
      },
      "&:disabled, &[aria-disabled]": {
        cursor: "default"
      },
      // inherit text styles from parent
      [buttonClassList.selector("text", "descendant")]: {
        fontSize: "inherit",
        fontWeight: "inherit",
        marginInline: tokenSchema.size.space.regular
      },
      [`&[data-pending] ${buttonClassList.selector("text")}`]: {
        opacity: 0
      },
      // special size for button icons. otherwise they appear too "thin"
      // beside the bold text
      [buttonClassList.selector("icon", "descendant")]: {
        height: tokenSchema.size.scale[225],
        width: tokenSchema.size.scale[225]
      },
      [`&[data-pending] ${buttonClassList.selector("icon")}`]: {
        opacity: 0
      },
      // focus ring
      "--focus-ring-color": tokenSchema.color.alias.focusRing,
      "&[data-static=light]": {
        "--focus-ring-color": "#fff"
      },
      "&[data-static=dark]": {
        "--focus-ring-color": "#000"
      },
      "&::after": {
        borderRadius: tokenSchema.size.radius.full,
        content: '""',
        inset: 0,
        pointerEvents: "none",
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      "&[data-focus=visible]::after": {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`,
        margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`
      },
      // PROMINENCE: default
      "&:not([data-prominence])": {
        backgroundColor: tokenSchema.color.scale.slate4,
        color: tokenSchema.color.foreground.neutralEmphasis,
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.scale.slate5
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.scale.slate6
        },
        // tones
        "&[data-tone=accent]": {
          color: tokenSchema.color.foreground.accent
        },
        "&[data-tone=critical]": {
          color: tokenSchema.color.foreground.critical
        },
        // states
        "&:disabled, &[aria-disabled=true]": {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          backgroundColor: "#ffffff12",
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-pressed]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#ffffff1a",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          backgroundColor: "#00000012",
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-pressed]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#0000001a",
            color: "#0000008c"
          }
        }
      },
      // PROMINENCE: high
      "&[data-prominence=high]": {
        backgroundColor: tokenSchema.color.scale.slate10,
        color: tokenSchema.color.foreground.inverse,
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.scale.slate11
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.scale.slate11
        },
        // NOTE: "neutral" tone invalid for "high" prominence
        "&[data-tone=accent]": {
          backgroundColor: tokenSchema.color.scale.indigo9,
          color: tokenSchema.color.foreground.onEmphasis,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.indigo10
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.indigo11
          }
        },
        "&[data-tone=critical]": {
          backgroundColor: tokenSchema.color.scale.red9,
          color: tokenSchema.color.foreground.onEmphasis,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.red10
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.red11
          }
        },
        // tone selector to increase specificity
        "&[data-tone]:disabled, &[data-tone][aria-disabled=true]": {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          backgroundColor: "#ffffffe6",
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#fff"
          },
          "&[data-pressed]": {
            backgroundColor: "#fff"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#ffffff1a",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          backgroundColor: "#000000e6",
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#000"
          },
          "&[data-pressed]": {
            backgroundColor: "#000"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#0000001a",
            color: "#0000008c"
          }
        }
      },
      // PROMINENCE: low
      "&[data-prominence=low]": {
        color: tokenSchema.color.foreground.neutral,
        // neutral interactions
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.foreground.neutralEmphasis
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // tones
        "&[data-tone=accent]": {
          color: tokenSchema.color.foreground.accent,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.indigo3
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.indigo4
          }
        },
        "&[data-tone=critical]": {
          color: tokenSchema.color.foreground.critical,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.red3
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.red4
          }
        },
        "&:disabled, &[aria-disabled=true]": {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-pressed]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-pressed]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#0000008c"
          }
        }
      }
    }), styleProps.className)
  };
}
var Button = (0, import_react66.forwardRef)(function Button2(props, forwardedRef) {
  const $ = c2(14);
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const children = useButtonChildren(props);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  if ("href" in props && props.href) {
    const t02 = domRef;
    let t12;
    if ($[0] !== t02 || $[1] !== props || $[2] !== children) {
      t12 = (0, import_jsx_runtime8.jsx)(LinkButton$1, {
        ref: t02,
        ...props,
        children
      });
      $[0] = t02;
      $[1] = props;
      $[2] = children;
      $[3] = t12;
    } else {
      t12 = $[3];
    }
    let t23;
    if ($[4] !== props.autoFocus || $[5] !== t12) {
      t23 = (0, import_jsx_runtime8.jsx)(FocusRing, {
        autoFocus: props.autoFocus,
        children: t12
      });
      $[4] = props.autoFocus;
      $[5] = t12;
      $[6] = t23;
    } else {
      t23 = $[6];
    }
    return t23;
  }
  const t0 = domRef;
  let t1;
  if ($[7] !== t0 || $[8] !== props || $[9] !== children) {
    t1 = (0, import_jsx_runtime8.jsx)(BaseButton$1, {
      ref: t0,
      ...props,
      children
    });
    $[7] = t0;
    $[8] = props;
    $[9] = children;
    $[10] = t1;
  } else {
    t1 = $[10];
  }
  let t22;
  if ($[11] !== props.autoFocus || $[12] !== t1) {
    t22 = (0, import_jsx_runtime8.jsx)(FocusRing, {
      autoFocus: props.autoFocus,
      children: t1
    });
    $[11] = props.autoFocus;
    $[12] = t1;
    $[13] = t22;
  } else {
    t22 = $[13];
  }
  return t22;
});
var LinkButton$1 = (0, import_react66.forwardRef)(function Button3(props, forwardedRef) {
  const $ = c2(23);
  let isDisabled;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      isDisabled,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = otherProps;
    $[3] = children;
  } else {
    isDisabled = $[1];
    otherProps = $[2];
    children = $[3];
  }
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let t0;
  if ($[4] !== props) {
    t0 = {
      elementType: "a",
      ...props
    };
    $[4] = props;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(t0, domRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, domRef);
  let t1;
  if ($[6] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[6] = isDisabled;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t1);
  let t22;
  if ($[8] !== isHovered || $[9] !== isPressed) {
    t22 = {
      isHovered,
      isPressed
    };
    $[8] = isHovered;
    $[9] = isPressed;
    $[10] = t22;
  } else {
    t22 = $[10];
  }
  const styleProps = useButtonStyles(props, t22);
  let t32;
  if ($[11] !== otherProps) {
    t32 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
    $[11] = otherProps;
    $[12] = t32;
  } else {
    t32 = $[12];
  }
  let t4;
  if ($[13] !== buttonProps || $[14] !== linkProps || $[15] !== hoverProps || $[16] !== styleProps) {
    t4 = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, linkProps, hoverProps, styleProps);
    $[13] = buttonProps;
    $[14] = linkProps;
    $[15] = hoverProps;
    $[16] = styleProps;
    $[17] = t4;
  } else {
    t4 = $[17];
  }
  let t5;
  if ($[18] !== t32 || $[19] !== t4 || $[20] !== domRef || $[21] !== children) {
    t5 = (0, import_jsx_runtime8.jsx)("a", {
      ...t32,
      ...t4,
      ref: domRef,
      children
    });
    $[18] = t32;
    $[19] = t4;
    $[20] = domRef;
    $[21] = children;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  return t5;
});
var BaseButton$1 = (0, import_react66.forwardRef)(function Button4(props, forwardedRef) {
  const $ = c2(39);
  let t0;
  if ($[0] !== props) {
    t0 = disablePendingProps(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  props = t0;
  let isDisabled;
  let isPending;
  let otherProps;
  let children;
  if ($[2] !== props) {
    ({
      children,
      isDisabled,
      isPending,
      ...otherProps
    } = props);
    $[2] = props;
    $[3] = isDisabled;
    $[4] = isPending;
    $[5] = otherProps;
    $[6] = children;
  } else {
    isDisabled = $[3];
    isPending = $[4];
    otherProps = $[5];
    children = $[6];
  }
  const [isProgressVisible, setIsProgressVisible] = (0, import_react66.useState)(false);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  let t1;
  if ($[7] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[7] = isDisabled;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t1);
  let t22;
  if ($[9] !== isHovered || $[10] !== isProgressVisible || $[11] !== isPressed) {
    t22 = {
      isHovered,
      isPending: isProgressVisible,
      isPressed
    };
    $[9] = isHovered;
    $[10] = isProgressVisible;
    $[11] = isPressed;
    $[12] = t22;
  } else {
    t22 = $[12];
  }
  const styleProps = useButtonStyles(props, t22);
  let t32;
  let t4;
  if ($[13] !== isPending) {
    t32 = () => {
      let timeout2;
      if (isPending) {
        timeout2 = setTimeout(() => {
          setIsProgressVisible(true);
        }, 1e3);
      } else {
        setIsProgressVisible(false);
      }
      return () => {
        clearTimeout(timeout2);
      };
    };
    t4 = [isPending];
    $[13] = isPending;
    $[14] = t32;
    $[15] = t4;
  } else {
    t32 = $[14];
    t4 = $[15];
  }
  (0, import_react66.useEffect)(t32, t4);
  let t5;
  let t6;
  let t7;
  let t8;
  if ($[16] !== isPending || $[17] !== domRef || $[18] !== styleProps || $[19] !== otherProps || $[20] !== buttonProps || $[21] !== hoverProps) {
    const pendingProps = isPending ? {
      onClick: (e4) => e4.preventDefault()
    } : {
      onClick: () => {
      }
    };
    t5 = domRef;
    t6 = styleProps;
    if ($[26] !== otherProps) {
      t7 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
        propNames: /* @__PURE__ */ new Set(["form"])
      });
      $[26] = otherProps;
      $[27] = t7;
    } else {
      t7 = $[27];
    }
    t8 = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps, pendingProps);
    $[16] = isPending;
    $[17] = domRef;
    $[18] = styleProps;
    $[19] = otherProps;
    $[20] = buttonProps;
    $[21] = hoverProps;
    $[22] = t5;
    $[23] = t6;
    $[24] = t7;
    $[25] = t8;
  } else {
    t5 = $[22];
    t6 = $[23];
    t7 = $[24];
    t8 = $[25];
  }
  const t9 = isPending ? "true" : void 0;
  let t10;
  if ($[28] !== isProgressVisible || $[29] !== stringFormatter) {
    t10 = isProgressVisible && (0, import_jsx_runtime8.jsx)(ProgressCircle, {
      "aria-atomic": "false",
      "aria-live": "assertive",
      "aria-label": stringFormatter.format("pending"),
      isIndeterminate: true,
      size: "small",
      UNSAFE_style: {
        position: "absolute"
      }
    });
    $[28] = isProgressVisible;
    $[29] = stringFormatter;
    $[30] = t10;
  } else {
    t10 = $[30];
  }
  let t11;
  if ($[31] !== t5 || $[32] !== t6 || $[33] !== t7 || $[34] !== t8 || $[35] !== t9 || $[36] !== children || $[37] !== t10) {
    t11 = (0, import_jsx_runtime8.jsxs)("button", {
      ref: t5,
      ...t6,
      ...t7,
      ...t8,
      "aria-disabled": t9,
      children: [children, t10]
    });
    $[31] = t5;
    $[32] = t6;
    $[33] = t7;
    $[34] = t8;
    $[35] = t9;
    $[36] = children;
    $[37] = t10;
    $[38] = t11;
  } else {
    t11 = $[38];
  }
  return t11;
});
function disablePendingProps(props) {
  if (props.isPending) {
    props = {
      ...props
    };
    props.onKeyDown = void 0;
    props.onKeyUp = void 0;
    props.onPress = void 0;
    props.onPressChange = void 0;
    props.onPressEnd = void 0;
    props.onPressStart = void 0;
    props.onPressUp = void 0;
  }
  return props;
}
var useButtonChildren = (props) => {
  const $ = c2(4);
  const {
    children
  } = props;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      UNSAFE_className: buttonClassList.element("icon")
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t22;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = {
      icon: t1,
      text: {
        color: "inherit",
        overflow: "unset",
        trim: false,
        UNSAFE_className: buttonClassList.element("text")
      }
    };
    $[1] = t22;
  } else {
    t22 = $[1];
  }
  t0 = t22;
  const slots = t0;
  let t32;
  if ($[2] !== children) {
    t32 = (0, import_jsx_runtime8.jsx)(SlotProvider, {
      slots,
      children: isReactText(children) ? (0, import_jsx_runtime8.jsx)(Text, {
        children
      }) : children
    });
    $[2] = children;
    $[3] = t32;
  } else {
    t32 = $[3];
  }
  return t32;
};
var actionButtonClassList = new ClassList("ActionButton", ["icon", "text"]);
function useActionButtonStyles(props, state) {
  const {
    prominence = "default"
  } = props;
  const {
    isHovered,
    isPressed
  } = state;
  const isSelected = "isSelected" in props && props.isSelected || state.isSelected;
  const styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      interaction: isPressed ? "press" : isHovered ? "hover" : void 0,
      prominence: prominence === "default" ? void 0 : prominence,
      selected: isSelected || void 0,
      static: props.static
    }),
    style: styleProps.style,
    className: classNames(actionButtonClassList.element("root"), css({
      alignItems: "center",
      borderColor: "transparent",
      borderRadius: tokenSchema.size.radius.regular,
      borderStyle: "solid",
      borderWidth: tokenSchema.size.border.regular,
      cursor: "default",
      display: "inline-flex",
      flexShrink: 0,
      fontWeight: tokenSchema.typography.fontWeight.regular,
      height: tokenSchema.size.element.regular,
      justifyContent: "center",
      minWidth: tokenSchema.size.element.regular,
      outline: 0,
      paddingInline: tokenSchema.size.space.regular,
      position: "relative",
      transitionDuration: "130ms",
      transitionProperty: "background, border-color, box-shadow, color",
      transitionTimingFunction: "ease-out",
      userSelect: "none",
      // indicate when external link? e.g. `&[href^=http]`
      "a&": {
        cursor: "pointer"
      },
      // CONTENTS
      [actionButtonClassList.selector("text", "descendant")]: {
        fontWeight: "inherit",
        marginInline: tokenSchema.size.space.small,
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      },
      // FOCUS RING
      "--focus-ring-color": tokenSchema.color.alias.focusRing,
      "&[data-static]": {
        "--focus-ring-color": "currentColor"
      },
      "&::after": {
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        pointerEvents: "none",
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      "&[data-focus=visible]::after": {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`
      },
      // PROMINENCE
      // prominence: default
      "&:not([data-prominence])": {
        backgroundColor: tokenSchema.color.alias.backgroundIdle,
        borderColor: tokenSchema.color.alias.borderIdle,
        color: tokenSchema.color.alias.foregroundIdle,
        // interactions
        "&[data-interaction=hover]": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          borderColor: tokenSchema.color.alias.borderHovered,
          // boxShadow: `${tokenSchema.size.shadow.small} ${tokenSchema.color.shadow.regular}`,
          color: tokenSchema.color.alias.foregroundHovered
        },
        "&[data-interaction=press]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed,
          borderColor: tokenSchema.color.alias.borderPressed,
          color: tokenSchema.color.alias.foregroundPressed
        },
        // states
        "&[data-selected]": {
          backgroundColor: tokenSchema.color.foreground.neutralSecondary,
          borderColor: tokenSchema.color.foreground.neutralSecondary,
          color: tokenSchema.color.foreground.inverse,
          "&[data-interaction=hover]": {
            backgroundColor: tokenSchema.color.foreground.neutral,
            borderColor: tokenSchema.color.foreground.neutral
          },
          "&[data-interaction=press]": {
            backgroundColor: tokenSchema.color.foreground.neutralEmphasis,
            borderColor: tokenSchema.color.foreground.neutralEmphasis
          }
        },
        "&:disabled, &[aria-disabled=true], &[data-disabled=true]": {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          borderColor: "transparent",
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static]": {
          backgroundColor: "transparent"
        },
        "&[data-static=light]": {
          borderColor: "#fff6",
          color: "#fff",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a",
            borderColor: "#ffffff8c"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#ffffff26",
            borderColor: "#ffffffb3"
          },
          "&:disabled, &[aria-disabled]": {
            borderColor: "#ffffff40",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          borderColor: "#0006",
          color: "#000",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#0000001a",
            borderColor: "#0000008c"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#00000026",
            borderColor: "#000000b3"
          },
          "&:disabled, &[aria-disabled]": {
            borderColor: "#00000040",
            color: "#0000008c"
          }
        }
      },
      // prominence: low
      "&[data-prominence=low]": {
        color: tokenSchema.color.foreground.neutral,
        // interactions
        "&[data-interaction=hover]": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.alias.foregroundHovered
        },
        "&[data-interaction=press]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed,
          color: tokenSchema.color.alias.foregroundPressed
        },
        // states
        "&[data-selected]": {
          backgroundColor: tokenSchema.color.foreground.neutralSecondary,
          borderColor: tokenSchema.color.foreground.neutralSecondary,
          color: tokenSchema.color.foreground.inverse,
          "&[data-interaction=hover]": {
            backgroundColor: tokenSchema.color.foreground.neutral,
            borderColor: tokenSchema.color.foreground.neutral
          },
          "&[data-interaction=press]": {
            backgroundColor: tokenSchema.color.foreground.neutralEmphasis,
            borderColor: tokenSchema.color.foreground.neutralEmphasis
          }
        },
        "&:disabled, &[aria-disabled=true], &[data-disabled=true]": {
          borderColor: "transparent",
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          color: "#fff",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          color: "#000",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#0000008c"
          }
        }
      }
    }), styleProps.className)
  };
}
var ActionButton = (0, import_react66.forwardRef)(function ActionButton2(props, forwardedRef) {
  const $ = c2(14);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const children = useActionButtonChildren(props);
  if ("href" in props && props.href) {
    const t02 = domRef;
    let t12;
    if ($[0] !== t02 || $[1] !== props || $[2] !== children) {
      t12 = (0, import_jsx_runtime8.jsx)(LinkButton, {
        ref: t02,
        ...props,
        children
      });
      $[0] = t02;
      $[1] = props;
      $[2] = children;
      $[3] = t12;
    } else {
      t12 = $[3];
    }
    let t23;
    if ($[4] !== props.autoFocus || $[5] !== t12) {
      t23 = (0, import_jsx_runtime8.jsx)(FocusRing, {
        autoFocus: props.autoFocus,
        children: t12
      });
      $[4] = props.autoFocus;
      $[5] = t12;
      $[6] = t23;
    } else {
      t23 = $[6];
    }
    return t23;
  }
  const t0 = domRef;
  let t1;
  if ($[7] !== t0 || $[8] !== props || $[9] !== children) {
    t1 = (0, import_jsx_runtime8.jsx)(BaseButton, {
      ref: t0,
      ...props,
      children
    });
    $[7] = t0;
    $[8] = props;
    $[9] = children;
    $[10] = t1;
  } else {
    t1 = $[10];
  }
  let t22;
  if ($[11] !== props.autoFocus || $[12] !== t1) {
    t22 = (0, import_jsx_runtime8.jsx)(FocusRing, {
      autoFocus: props.autoFocus,
      children: t1
    });
    $[11] = props.autoFocus;
    $[12] = t1;
    $[13] = t22;
  } else {
    t22 = $[13];
  }
  return t22;
});
var LinkButton = (0, import_react66.forwardRef)(function LinkActionButton(props, forwardedRef) {
  const $ = c2(23);
  let isDisabled;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      isDisabled,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = otherProps;
    $[3] = children;
  } else {
    isDisabled = $[1];
    otherProps = $[2];
    children = $[3];
  }
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let t0;
  if ($[4] !== props) {
    t0 = {
      elementType: "a",
      ...props
    };
    $[4] = props;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(t0, domRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, domRef);
  let t1;
  if ($[6] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[6] = isDisabled;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t1);
  let t22;
  if ($[8] !== isHovered || $[9] !== isPressed) {
    t22 = {
      isHovered,
      isPressed
    };
    $[8] = isHovered;
    $[9] = isPressed;
    $[10] = t22;
  } else {
    t22 = $[10];
  }
  const styleProps = useActionButtonStyles(props, t22);
  let t32;
  if ($[11] !== otherProps) {
    t32 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
    $[11] = otherProps;
    $[12] = t32;
  } else {
    t32 = $[12];
  }
  let t4;
  if ($[13] !== buttonProps || $[14] !== linkProps || $[15] !== hoverProps || $[16] !== styleProps) {
    t4 = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, linkProps, hoverProps, styleProps);
    $[13] = buttonProps;
    $[14] = linkProps;
    $[15] = hoverProps;
    $[16] = styleProps;
    $[17] = t4;
  } else {
    t4 = $[17];
  }
  let t5;
  if ($[18] !== t32 || $[19] !== t4 || $[20] !== domRef || $[21] !== children) {
    t5 = (0, import_jsx_runtime8.jsx)("a", {
      ...t32,
      ...t4,
      ref: domRef,
      children
    });
    $[18] = t32;
    $[19] = t4;
    $[20] = domRef;
    $[21] = children;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  return t5;
});
var BaseButton = (0, import_react66.forwardRef)(function BaseActionButton(props, forwardedRef) {
  const $ = c2(20);
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  let isDisabled;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      isDisabled,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = otherProps;
    $[3] = children;
  } else {
    isDisabled = $[1];
    otherProps = $[2];
    children = $[3];
  }
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  let t0;
  if ($[4] !== isDisabled) {
    t0 = {
      isDisabled
    };
    $[4] = isDisabled;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t0);
  let t1;
  if ($[6] !== isHovered || $[7] !== isPressed) {
    t1 = {
      isHovered,
      isPressed
    };
    $[6] = isHovered;
    $[7] = isPressed;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const styleProps = useActionButtonStyles(props, t1);
  let t22;
  if ($[9] !== otherProps) {
    t22 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      propNames: /* @__PURE__ */ new Set(["form"])
    });
    $[9] = otherProps;
    $[10] = t22;
  } else {
    t22 = $[10];
  }
  let t32;
  if ($[11] !== buttonProps || $[12] !== hoverProps) {
    t32 = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps);
    $[11] = buttonProps;
    $[12] = hoverProps;
    $[13] = t32;
  } else {
    t32 = $[13];
  }
  let t4;
  if ($[14] !== domRef || $[15] !== styleProps || $[16] !== t22 || $[17] !== t32 || $[18] !== children) {
    t4 = (0, import_jsx_runtime8.jsx)("button", {
      ref: domRef,
      ...styleProps,
      ...t22,
      ...t32,
      children
    });
    $[14] = domRef;
    $[15] = styleProps;
    $[16] = t22;
    $[17] = t32;
    $[18] = children;
    $[19] = t4;
  } else {
    t4 = $[19];
  }
  return t4;
});
var iconClassName = actionButtonClassList.element("icon");
var textClassName = actionButtonClassList.element("text");
var useActionButtonChildren = (props, alternateSlots) => {
  const $ = c2(13);
  const {
    children
  } = props;
  let t0;
  const t1 = alternateSlots === null || alternateSlots === void 0 ? void 0 : alternateSlots.icon;
  let t22;
  if ($[0] !== t1) {
    t22 = {
      UNSAFE_className: iconClassName,
      ...t1
    };
    $[0] = t1;
    $[1] = t22;
  } else {
    t22 = $[1];
  }
  const t32 = alternateSlots === null || alternateSlots === void 0 ? void 0 : alternateSlots.text;
  let t4;
  if ($[2] !== t32) {
    t4 = {
      color: "inherit",
      overflow: "unset",
      trim: false,
      UNSAFE_className: textClassName,
      ...t32
    };
    $[2] = t32;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] !== alternateSlots || $[5] !== t22 || $[6] !== t4) {
    t5 = {
      ...alternateSlots,
      icon: t22,
      text: t4
    };
    $[4] = alternateSlots;
    $[5] = t22;
    $[6] = t4;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  t0 = t5;
  const slots = t0;
  let t6;
  if ($[8] !== children) {
    t6 = isReactText(children) ? (0, import_jsx_runtime8.jsx)(Text, {
      children
    }) : children;
    $[8] = children;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== slots || $[11] !== t6) {
    t7 = (0, import_jsx_runtime8.jsx)(SlotProvider, {
      slots,
      children: t6
    });
    $[10] = slots;
    $[11] = t6;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  return t7;
};
var ClearButton = (0, import_react66.forwardRef)(function ClearButton2(props, forwardedRef) {
  const $ = c2(28);
  let t0;
  let preventFocus;
  let isDisabled;
  let otherProps;
  let autoFocus;
  if ($[0] !== props) {
    ({
      autoFocus,
      isDisabled,
      preventFocus,
      elementType: t0,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = preventFocus;
    $[3] = isDisabled;
    $[4] = otherProps;
    $[5] = autoFocus;
  } else {
    t0 = $[1];
    preventFocus = $[2];
    isDisabled = $[3];
    otherProps = $[4];
    autoFocus = $[5];
  }
  const elementType = t0 === void 0 ? preventFocus ? "div" : "button" : t0;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let t1;
  if ($[6] !== props || $[7] !== elementType) {
    t1 = {
      ...props,
      elementType
    };
    $[6] = props;
    $[7] = elementType;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(t1, domRef);
  let t22;
  if ($[9] !== isDisabled) {
    t22 = {
      isDisabled
    };
    $[9] = isDisabled;
    $[10] = t22;
  } else {
    t22 = $[10];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t22);
  let t32;
  if ($[11] !== isHovered || $[12] !== isPressed) {
    t32 = {
      isHovered,
      isPressed
    };
    $[11] = isHovered;
    $[12] = isPressed;
    $[13] = t32;
  } else {
    t32 = $[13];
  }
  const styleProps = useClearButtonStyles(otherProps, t32);
  if (preventFocus) {
    let _buttonProps;
    if ($[14] !== buttonProps) {
      const {
        tabIndex,
        ...t42
      } = buttonProps;
      _buttonProps = t42;
      $[14] = buttonProps;
      $[15] = _buttonProps;
    } else {
      _buttonProps = $[15];
    }
    buttonProps = _buttonProps;
  }
  const ElementType = elementType;
  let t4;
  if ($[16] !== buttonProps || $[17] !== hoverProps) {
    t4 = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps);
    $[16] = buttonProps;
    $[17] = hoverProps;
    $[18] = t4;
  } else {
    t4 = $[18];
  }
  let t5;
  if ($[19] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime8.jsx)(Icon, {
      src: xIcon
    });
    $[19] = t5;
  } else {
    t5 = $[19];
  }
  let t6;
  if ($[20] !== ElementType || $[21] !== styleProps || $[22] !== t4 || $[23] !== domRef) {
    t6 = (0, import_jsx_runtime8.jsx)(ElementType, {
      ...styleProps,
      ...t4,
      ref: domRef,
      children: t5
    });
    $[20] = ElementType;
    $[21] = styleProps;
    $[22] = t4;
    $[23] = domRef;
    $[24] = t6;
  } else {
    t6 = $[24];
  }
  let t7;
  if ($[25] !== autoFocus || $[26] !== t6) {
    t7 = (0, import_jsx_runtime8.jsx)(FocusRing, {
      autoFocus,
      children: t6
    });
    $[25] = autoFocus;
    $[26] = t6;
    $[27] = t7;
  } else {
    t7 = $[27];
  }
  return t7;
});
function useClearButtonStyles(props, state) {
  const $ = c2(14);
  const {
    isPressed,
    isHovered
  } = state;
  const styleProps = useStyleProps(props);
  let t0;
  let t1;
  let t22;
  if ($[0] !== styleProps || $[1] !== isPressed || $[2] !== isHovered || $[3] !== props.static) {
    const clearButtonStyles = css({
      alignItems: "center",
      borderRadius: "100%",
      color: tokenSchema.color.foreground.neutralSecondary,
      display: "flex",
      height: tokenSchema.size.element.regular,
      justifyContent: "center",
      outline: 0,
      position: "relative",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      }),
      width: tokenSchema.size.element.regular,
      "--focus-ring-color": tokenSchema.color.alias.focusRing,
      "&[data-static]": {
        "--focus-ring-color": "currentColor"
      },
      "&::after": {
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        pointerEvents: "none",
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      "&[data-focus=visible]::after": {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`,
        margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`
      },
      "&[data-interaction=hover]": {
        color: tokenSchema.color.foreground.neutral
      },
      "&[data-interaction=press]": {
        color: tokenSchema.color.foreground.neutralEmphasis
      },
      "&:disabled, &[aria-disabled]": {
        color: tokenSchema.color.alias.foregroundDisabled
      },
      "&[data-static=light]": {
        color: "#fff",
        '&[data-interaction=hover], &[data-focus="visible"]': {
          backgroundColor: "#ffffff1a"
        },
        "&[data-interaction=press]": {
          backgroundColor: "#ffffff26"
        },
        "&:disabled, &[aria-disabled]": {
          backgroundColor: "#ffffff1a",
          color: "#ffffff8c"
        }
      },
      "&[data-static=dark]": {
        color: "#000",
        '&[data-interaction=hover], &[data-focus="visible"]': {
          backgroundColor: "#0000001a"
        },
        "&[data-interaction=press]": {
          backgroundColor: "#00000026"
        },
        "&:disabled, &[aria-disabled]": {
          backgroundColor: "#0000001a",
          color: "#0000008c"
        }
      }
    });
    t0 = styleProps;
    const t33 = isPressed ? "press" : isHovered ? "hover" : void 0;
    if ($[7] !== props.static || $[8] !== t33) {
      t1 = toDataAttributes({
        static: props.static,
        interaction: t33
      });
      $[7] = props.static;
      $[8] = t33;
      $[9] = t1;
    } else {
      t1 = $[9];
    }
    t22 = classNames(clearButtonStyles, styleProps.className);
    $[0] = styleProps;
    $[1] = isPressed;
    $[2] = isHovered;
    $[3] = props.static;
    $[4] = t0;
    $[5] = t1;
    $[6] = t22;
  } else {
    t0 = $[4];
    t1 = $[5];
    t22 = $[6];
  }
  let t32;
  if ($[10] !== t0 || $[11] !== t1 || $[12] !== t22) {
    t32 = {
      ...t0,
      ...t1,
      className: t22
    };
    $[10] = t0;
    $[11] = t1;
    $[12] = t22;
    $[13] = t32;
  } else {
    t32 = $[13];
  }
  return t32;
}
var FieldButton = (0, import_react66.forwardRef)(function FieldButton2(props, forwardedRef) {
  const $ = c2(23);
  props = useSlotProps(props, "button");
  const {
    elementType: t0,
    isDisabled,
    autoFocus,
    isActive
  } = props;
  const ElementType = t0 === void 0 ? "button" : t0;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  let t1;
  if ($[0] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[0] = isDisabled;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t1);
  const t22 = isActive !== null && isActive !== void 0 ? isActive : isPressed;
  let t32;
  if ($[2] !== isHovered || $[3] !== t22) {
    t32 = {
      isHovered,
      isPressed: t22
    };
    $[2] = isHovered;
    $[3] = t22;
    $[4] = t32;
  } else {
    t32 = $[4];
  }
  const {
    children,
    styleProps
  } = useFieldButton(props, t32);
  let t4;
  if ($[5] !== buttonProps || $[6] !== hoverProps) {
    t4 = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps);
    $[5] = buttonProps;
    $[6] = hoverProps;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== styleProps.className) {
    t5 = classNames(css({
      justifyContent: "space-between",
      textAlign: "start"
    }), styleProps.className);
    $[8] = styleProps.className;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== styleProps.style) {
    t6 = {
      ...styleProps.style,
      boxShadow: "none"
    };
    $[10] = styleProps.style;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== ElementType || $[13] !== styleProps || $[14] !== t4 || $[15] !== domRef || $[16] !== t5 || $[17] !== t6 || $[18] !== children) {
    t7 = (0, import_jsx_runtime8.jsx)(ElementType, {
      ...styleProps,
      ...t4,
      ref: domRef,
      className: t5,
      style: t6,
      children
    });
    $[12] = ElementType;
    $[13] = styleProps;
    $[14] = t4;
    $[15] = domRef;
    $[16] = t5;
    $[17] = t6;
    $[18] = children;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  let t8;
  if ($[20] !== autoFocus || $[21] !== t7) {
    t8 = (0, import_jsx_runtime8.jsx)(FocusRing, {
      autoFocus,
      children: t7
    });
    $[20] = autoFocus;
    $[21] = t7;
    $[22] = t8;
  } else {
    t8 = $[22];
  }
  return t8;
});
function useFieldButton(props, state) {
  const $ = c2(7);
  const {
    isHovered,
    isPressed
  } = state;
  let t0;
  if ($[0] !== isHovered || $[1] !== isPressed) {
    t0 = {
      isHovered,
      isPressed
    };
    $[0] = isHovered;
    $[1] = isPressed;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const styleProps = useActionButtonStyles(props, t0);
  let t1;
  let t22;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = {
      text: {
        flex: true
      }
    };
    $[3] = t22;
  } else {
    t22 = $[3];
  }
  t1 = t22;
  const slots = t1;
  const children = useActionButtonChildren(props, slots);
  let t32;
  if ($[4] !== children || $[5] !== styleProps) {
    t32 = {
      children,
      styleProps
    };
    $[4] = children;
    $[5] = styleProps;
    $[6] = t32;
  } else {
    t32 = $[6];
  }
  return t32;
}
var ToggleButton = (0, import_react66.forwardRef)(function ToggleButton2(props, forwardedRef) {
  const $ = c2(23);
  let isDisabled;
  let otherProps;
  if ($[0] !== props) {
    ({
      isDisabled,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = otherProps;
  } else {
    isDisabled = $[1];
    otherProps = $[2];
  }
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const children = useActionButtonChildren(props);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const state = $3017fa7ffdddec74$export$8042c6c013fd5226(props);
  const {
    buttonProps,
    isPressed
  } = $55f54f7887471b58$export$51e84d46ca0bc451(props, state, domRef);
  let t0;
  if ($[3] !== isDisabled) {
    t0 = {
      isDisabled
    };
    $[3] = isDisabled;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t0);
  let t1;
  if ($[5] !== isHovered || $[6] !== isPressed || $[7] !== state.isSelected) {
    t1 = {
      isHovered,
      isPressed,
      isSelected: state.isSelected
    };
    $[5] = isHovered;
    $[6] = isPressed;
    $[7] = state.isSelected;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const styleProps = useActionButtonStyles(props, t1);
  let t22;
  if ($[9] !== buttonProps || $[10] !== hoverProps) {
    t22 = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps);
    $[9] = buttonProps;
    $[10] = hoverProps;
    $[11] = t22;
  } else {
    t22 = $[11];
  }
  let t32;
  if ($[12] !== otherProps) {
    t32 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
    $[12] = otherProps;
    $[13] = t32;
  } else {
    t32 = $[13];
  }
  let t4;
  if ($[14] !== domRef || $[15] !== styleProps || $[16] !== t22 || $[17] !== t32 || $[18] !== children) {
    t4 = (0, import_jsx_runtime8.jsx)("button", {
      ref: domRef,
      ...styleProps,
      ...t22,
      ...t32,
      children
    });
    $[14] = domRef;
    $[15] = styleProps;
    $[16] = t22;
    $[17] = t32;
    $[18] = children;
    $[19] = t4;
  } else {
    t4 = $[19];
  }
  let t5;
  if ($[20] !== props.autoFocus || $[21] !== t4) {
    t5 = (0, import_jsx_runtime8.jsx)(FocusRing, {
      autoFocus: props.autoFocus,
      children: t4
    });
    $[20] = props.autoFocus;
    $[21] = t4;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  return t5;
});

// node_modules/@keystar/ui/dist/keystar-ui-layout.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());

// node_modules/@react-aria/separator/dist/useSeparator.mjs
function $f4b273590fab9f93$export$52210f68a14655d0(props) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let ariaOrientation;
  if (props.orientation === "vertical") ariaOrientation = "vertical";
  if (props.elementType !== "hr") return {
    separatorProps: {
      ...domProps,
      role: "separator",
      "aria-orientation": ariaOrientation
    }
  };
  return {
    separatorProps: domProps
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-layout.js
var import_react67 = __toESM(require_react());
var Box = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime9.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps),
    ...styleProps,
    children
  });
});
var dividerClassList = new ClassList("Divider");
var filterOptions2 = {
  propNames: /* @__PURE__ */ new Set(["role"])
};
var Divider = forwardRefWithAs((props, forwardedRef) => {
  props = useSlotProps(props, "divider");
  const {
    orientation = "horizontal",
    elementType: Element4 = orientation === "vertical" ? "div" : "hr",
    size: size3 = "regular",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  let {
    separatorProps
  } = $f4b273590fab9f93$export$52210f68a14655d0({
    ...props,
    // FIXME: `forwardRefWithAs` yields `React.ElementType<any>` which is
    // incompatible with react-aria's expectations for `elementType`.
    elementType: Element4
  });
  return (0, import_jsx_runtime9.jsx)(Element4, {
    ...styleProps,
    ...separatorProps,
    ...toDataAttributes({
      orientation,
      size: size3
    }),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions2),
    ref: forwardedRef,
    className: classNames(dividerClassList.element("root"), css({
      alignSelf: "stretch",
      backgroundColor: tokenSchema.color.border.neutral,
      borderRadius: "var(--size)",
      "&[data-size=regular]": {
        "--size": tokenSchema.size.border.regular
      },
      "&[data-size=medium]": {
        "--size": tokenSchema.size.border.medium
      },
      "&[data-size=large]": {
        "--size": tokenSchema.size.border.large
      },
      "&[data-orientation=horizontal]": {
        height: "var(--size)"
      },
      "&[data-orientation=vertical]": {
        width: "var(--size)"
      }
    }), styleProps.className)
  });
});
var sharedStyleProps = {
  gap: resolvePropWithPath("gap", "size.space"),
  columnGap: resolvePropWithPath("columnGap", "size.space"),
  rowGap: resolvePropWithPath("rowGap", "size.space"),
  alignContent: resolveProp("alignContent", flexAlignValue),
  alignItems: resolveProp("alignItems", flexAlignValue),
  direction: resolveProp("flexDirection"),
  justifyContent: resolveProp("justifyContent", flexAlignValue)
};
function displayInline(block2) {
  const resolver = (inline) => inline ? `inline-${block2}` : block2;
  return resolver;
}
function useFlexStyleProps(props) {
  const $ = c2(2);
  let t0;
  if ($[0] !== props) {
    t0 = {
      inline: false,
      ...props
    };
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return useStyleProps(t0, flexStyleProps);
}
var flexStyleProps = {
  ...sharedStyleProps,
  direction: resolveProp("flexDirection"),
  inline: resolveProp("display", displayInline("flex")),
  wrap: resolveProp("flexWrap", flexWrapValue)
};
function flexAlignValue(value2) {
  if (value2 === "start") {
    return "flex-start";
  }
  if (value2 === "end") {
    return "flex-end";
  }
  return value2;
}
function flexWrapValue(value2) {
  if (typeof value2 === "boolean") {
    return value2 ? "wrap" : "nowrap";
  }
  return value2;
}
function isFractionUnit(value2) {
  return value2.endsWith("fr");
}
function gridSizeResolver(value2) {
  if (typeof value2 === "number") {
    return value2;
  }
  if (isFractionUnit(value2)) {
    return value2;
  }
  return sizeResolver(value2);
}
function useGridStyleProps(props) {
  const $ = c2(2);
  let t0;
  if ($[0] !== props) {
    t0 = {
      inline: false,
      ...props
    };
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return useStyleProps(t0, gridStyleProps);
}
var gridStyleProps = {
  ...sharedStyleProps,
  inline: resolveProp("display", displayInline("grid")),
  autoFlow: resolveProp("gridAutoFlow"),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  autoColumns: resolveProp("gridAutoColumns", sizeResolver),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  autoRows: resolveProp("gridAutoRows", sizeResolver),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  areas: resolveProp("gridTemplateAreas", gridTemplateAreasValue),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  columns: resolveProp("gridTemplateColumns", gridTemplateValue),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  rows: resolveProp("gridTemplateRows", gridTemplateValue),
  justifyItems: resolveProp("justifyItems"),
  justifyContent: resolveProp("justifyContent"),
  alignItems: resolveProp("alignItems"),
  alignContent: resolveProp("alignContent")
};
function gridTemplateAreasValue(values) {
  return values.map((value2) => `"${value2}"`).join("\n");
}
function gridTemplateValue(value2) {
  if (Array.isArray(value2)) {
    return value2.map(gridSizeResolver).join(" ");
  }
  return value2;
}
function minmax(min2, max2) {
  return `minmax(${gridSizeResolver(min2)}, ${gridSizeResolver(max2)})`;
}
var Flex = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps(otherProps);
  return (0, import_jsx_runtime9.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var Grid = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useGridStyleProps(otherProps);
  return (0, import_jsx_runtime9.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(gridStyleProps)),
    ...styleProps,
    children
  });
});
var ScrollView = (0, import_react67.forwardRef)(function ScrollView2(props, forwardedRef) {
  let {
    children,
    direction = "vertical",
    ...otherProps
  } = props;
  let ref = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let [scrollIndicator, setScrollIndicator] = (0, import_react67.useState)("none");
  let styleProps = useGridStyleProps(otherProps);
  let updateScrollPosition = (0, import_react67.useCallback)(() => {
    let node2 = ref.current;
    if (!node2) {
      return;
    }
    let {
      clientDimension,
      scrollDimension,
      scrollStart
    } = getScrollProps(direction, node2);
    let indicator = "none";
    if (scrollDimension > clientDimension) {
      if (scrollStart === 0) {
        indicator = "end";
      } else if (Math.ceil(scrollStart + clientDimension) >= scrollDimension) {
        indicator = "start";
      } else if (scrollStart > 0) {
        indicator = "both";
      }
    }
    setScrollIndicator(indicator);
  }, [direction, ref]);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    updateScrollPosition();
  }, [updateScrollPosition]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref,
    onResize: updateScrollPosition
  });
  return (0, import_jsx_runtime9.jsx)("div", {
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    onScroll: updateScrollPosition,
    ref,
    "data-scroll-indicator": scrollIndicator,
    "data-scroll-direction": direction,
    className: classNames(css({
      height: "100%",
      width: "100%",
      minHeight: 0,
      minWidth: 0,
      transition: transition("border-color", {
        duration: "regular"
      }),
      WebkitOverflowScrolling: "touch",
      "&[data-scroll-direction=vertical]": {
        borderBlock: `${tokenSchema.size.border.regular} solid transparent`,
        // marginBlock: `calc(${tokenSchema.size.border.regular} * -1)`,
        overflowX: "hidden",
        overflowY: "auto",
        "&[data-scroll-indicator=both]": {
          borderBlockColor: tokenSchema.color.border.neutral
        },
        "&[data-scroll-indicator=start]": {
          borderBlockStartColor: tokenSchema.color.border.neutral
        },
        "&[data-scroll-indicator=end]": {
          borderBlockEndColor: tokenSchema.color.border.neutral
        }
      },
      "&[data-scroll-direction=horizontal]": {
        borderInline: `${tokenSchema.size.border.regular} solid transparent`,
        // marginInline: `calc(${tokenSchema.size.border.regular} * -1)`,
        gridAutoFlow: "column",
        overflowX: "auto",
        overflowY: "hidden",
        "&[data-scroll-indicator=both]": {
          borderInlineColor: tokenSchema.color.border.neutral
        },
        "&[data-scroll-indicator=start]": {
          borderInlineStartColor: tokenSchema.color.border.neutral
        },
        "&[data-scroll-indicator=end]": {
          borderInlineEndColor: tokenSchema.color.border.neutral
        }
      }
    }), styleProps.className),
    children
  });
});
function getScrollProps(direction, node2) {
  let scrollStart = direction === "horizontal" ? node2.scrollLeft : node2.scrollTop;
  let scrollDimension = direction === "horizontal" ? node2.scrollWidth : node2.scrollHeight;
  let clientDimension = direction === "horizontal" ? node2.clientWidth : node2.clientHeight;
  return {
    clientDimension,
    scrollDimension,
    scrollStart
  };
}
var VStack = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps({
    direction: "column",
    ...otherProps
  });
  return (0, import_jsx_runtime9.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var HStack = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps({
    direction: "row",
    ...otherProps
  });
  return (0, import_jsx_runtime9.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var levels = ["one", "two", "three"];
var MAX_LEVEL = levels.length - 1;
var SurfaceContext = (0, import_react67.createContext)(1);
var Surface = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    level: overrideLevel,
    ...otherProps
  } = props;
  const contextLevel = (0, import_react67.useContext)(SurfaceContext);
  const level = overrideLevel !== null && overrideLevel !== void 0 ? overrideLevel : contextLevel;
  const levelClassName = `${TOKEN_PREFIX}--surface-${levels[level]}`;
  const value2 = Math.max(0, Math.min(level + 1, MAX_LEVEL));
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime9.jsx)(SurfaceContext.Provider, {
    value: value2,
    children: (0, import_jsx_runtime9.jsx)(ElementType, {
      ref: forwardedRef,
      ...filterStyleProps(otherProps),
      ...styleProps,
      className: classNames(levelClassName, styleProps.className),
      children
    })
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-link.js
var import_react68 = __toESM(require_react());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
function useTextLink(t0) {
  const $ = c2(18);
  const {
    autoFocus,
    prominence: t1
  } = t0;
  const prominence = t1 === void 0 ? "default" : t1;
  const headingContext = useHeadingContext();
  const textContext = useTextContext();
  let t22;
  if ($[0] !== autoFocus) {
    t22 = {
      autoFocus
    };
    $[0] = autoFocus;
    $[1] = t22;
  } else {
    t22 = $[1];
  }
  const {
    focusProps,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f(t22);
  let t32;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t32 = {};
    $[2] = t32;
  } else {
    t32 = $[2];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t32);
  const t4 = isHovered ? "true" : void 0;
  const t5 = isFocusVisible ? "visible" : void 0;
  let t6;
  let t7;
  if ($[3] !== prominence || $[4] !== t4 || $[5] !== t5 || $[6] !== hoverProps || $[7] !== focusProps) {
    const dataOptions = {
      prominence,
      hover: t4,
      focus: t5
    };
    if ($[10] !== hoverProps || $[11] !== focusProps) {
      t6 = $3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, focusProps);
      $[10] = hoverProps;
      $[11] = focusProps;
      $[12] = t6;
    } else {
      t6 = $[12];
    }
    t7 = toDataAttributes(dataOptions);
    $[3] = prominence;
    $[4] = t4;
    $[5] = t5;
    $[6] = hoverProps;
    $[7] = focusProps;
    $[8] = t6;
    $[9] = t7;
  } else {
    t6 = $[8];
    t7 = $[9];
  }
  const t8 = !textContext && !headingContext ? Text : import_react68.Fragment;
  let t9;
  if ($[13] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = classNames(css({
      color: tokenSchema.color.foreground.neutral,
      cursor: "pointer",
      outline: 0,
      textDecoration: "underline",
      textDecorationColor: tokenSchema.color.border.emphasis,
      textDecorationThickness: tokenSchema.size.border.regular,
      textUnderlineOffset: tokenSchema.size.border.medium,
      '&[data-hover="true"], &[data-focus="visible"]': {
        color: tokenSchema.color.foreground.neutralEmphasis,
        textDecorationColor: tokenSchema.color.foreground.neutral
      },
      '&[data-focus="visible"]': {
        textDecorationStyle: "double"
      },
      '&[data-prominence="high"]': {
        color: tokenSchema.color.foreground.accent,
        textDecorationColor: tokenSchema.color.border.accent,
        '&[data-hover="true"], &[data-focus="visible"]': {
          textDecorationColor: tokenSchema.color.foreground.accent
        }
      }
    }));
    $[13] = t9;
  } else {
    t9 = $[13];
  }
  let t10;
  if ($[14] !== t6 || $[15] !== t7 || $[16] !== t8) {
    t10 = {
      ...t6,
      ...t7,
      Wrapper: t8,
      className: t9
    };
    $[14] = t6;
    $[15] = t7;
    $[16] = t8;
    $[17] = t10;
  } else {
    t10 = $[17];
  }
  return t10;
}
var TextLinkAnchor = (0, import_react68.forwardRef)(function TextLink(props, forwardedRef) {
  const $ = c2(13);
  const {
    children
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const t0 = useTextLink(props);
  let styleProps;
  let Wrapper;
  if ($[0] !== t0) {
    ({
      Wrapper,
      ...styleProps
    } = t0);
    $[0] = t0;
    $[1] = styleProps;
    $[2] = Wrapper;
  } else {
    styleProps = $[1];
    Wrapper = $[2];
  }
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, domRef);
  let t1;
  if ($[3] !== linkProps || $[4] !== styleProps) {
    t1 = $3ef42575df84b30b$export$9d1611c77c2fe928(linkProps, styleProps);
    $[3] = linkProps;
    $[4] = styleProps;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t22;
  if ($[6] !== domRef || $[7] !== t1 || $[8] !== children) {
    t22 = (0, import_jsx_runtime10.jsx)("a", {
      ref: domRef,
      ...t1,
      children
    });
    $[6] = domRef;
    $[7] = t1;
    $[8] = children;
    $[9] = t22;
  } else {
    t22 = $[9];
  }
  let t32;
  if ($[10] !== Wrapper || $[11] !== t22) {
    t32 = (0, import_jsx_runtime10.jsx)(Wrapper, {
      children: t22
    });
    $[10] = Wrapper;
    $[11] = t22;
    $[12] = t32;
  } else {
    t32 = $[12];
  }
  return t32;
});
var TextLinkButton = (0, import_react68.forwardRef)(function TextLink2(props, forwardedRef) {
  const $ = c2(18);
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = children;
  } else {
    otherProps = $[1];
    children = $[2];
  }
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const t0 = useTextLink(otherProps);
  let styleProps;
  let Wrapper;
  if ($[3] !== t0) {
    ({
      Wrapper,
      ...styleProps
    } = t0);
    $[3] = t0;
    $[4] = styleProps;
    $[5] = Wrapper;
  } else {
    styleProps = $[4];
    Wrapper = $[5];
  }
  let t1;
  if ($[6] !== otherProps) {
    t1 = {
      elementType: "span",
      ...otherProps
    };
    $[6] = otherProps;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const {
    buttonProps
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(t1, domRef);
  let t22;
  if ($[8] !== buttonProps || $[9] !== styleProps) {
    t22 = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, styleProps);
    $[8] = buttonProps;
    $[9] = styleProps;
    $[10] = t22;
  } else {
    t22 = $[10];
  }
  let t32;
  if ($[11] !== domRef || $[12] !== t22 || $[13] !== children) {
    t32 = (0, import_jsx_runtime10.jsx)("span", {
      ref: domRef,
      ...t22,
      children
    });
    $[11] = domRef;
    $[12] = t22;
    $[13] = children;
    $[14] = t32;
  } else {
    t32 = $[14];
  }
  let t4;
  if ($[15] !== Wrapper || $[16] !== t32) {
    t4 = (0, import_jsx_runtime10.jsx)(Wrapper, {
      children: t32
    });
    $[15] = Wrapper;
    $[16] = t32;
    $[17] = t4;
  } else {
    t4 = $[17];
  }
  return t4;
});
var TextLink3 = (0, import_react68.forwardRef)(function TextLink4(props, forwardedRef) {
  const $ = c2(6);
  if ("href" in props) {
    const t02 = forwardedRef;
    let t12;
    if ($[0] !== props || $[1] !== t02) {
      t12 = (0, import_jsx_runtime10.jsx)(TextLinkAnchor, {
        ...props,
        ref: t02
      });
      $[0] = props;
      $[1] = t02;
      $[2] = t12;
    } else {
      t12 = $[2];
    }
    return t12;
  }
  const t0 = forwardedRef;
  let t1;
  if ($[3] !== props || $[4] !== t0) {
    t1 = (0, import_jsx_runtime10.jsx)(TextLinkButton, {
      ...props,
      ref: t0
    });
    $[3] = props;
    $[4] = t0;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
});

// node_modules/@keystar/ui/dist/keystar-ui-field.js
var import_react69 = __toESM(require_react());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-alertTriangleIcon.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var alertTriangleIcon = (0, import_jsx_runtime11.jsx)("path", {
  d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3ZM12 9v4M12 17h.01"
});

// node_modules/@keystar/ui/dist/keystar-ui-field.js
var localizedMessages2 = {
  "ar-AE": {
    "(optional)": `(اختياري)`,
    "(required)": `(مطلوب)`
  },
  "bg-BG": {
    "(optional)": `(незадължително)`,
    "(required)": `(задължително)`
  },
  "cs-CZ": {
    "(optional)": `(volitelně)`,
    "(required)": `(požadováno)`
  },
  "da-DK": {
    "(optional)": `(valgfrit)`,
    "(required)": `(obligatorisk)`
  },
  "de-DE": {
    "(optional)": `(optional)`,
    "(required)": `(erforderlich)`
  },
  "el-GR": {
    "(optional)": `(προαιρετικό)`,
    "(required)": `(απαιτείται)`
  },
  "en-US": {
    "(optional)": `(optional)`,
    "(required)": `(required)`
  },
  "es-ES": {
    "(optional)": `(opcional)`,
    "(required)": `(necesario)`
  },
  "et-EE": {
    "(optional)": `(valikuline)`,
    "(required)": `(nõutav)`
  },
  "fi-FI": {
    "(optional)": `(valinnainen)`,
    "(required)": `(pakollinen)`
  },
  "fr-FR": {
    "(optional)": `(facultatif)`,
    "(required)": `(requis)`
  },
  "he-IL": {
    "(optional)": `(אופציונלי)`,
    "(required)": `(נדרש)`
  },
  "hr-HR": {
    "(optional)": `(opcionalno)`,
    "(required)": `(obvezno)`
  },
  "hu-HU": {
    "(optional)": `(opcionális)`,
    "(required)": `(kötelező)`
  },
  "it-IT": {
    "(optional)": `(facoltativo)`,
    "(required)": `(obbligatorio)`
  },
  "ja-JP": {
    "(optional)": `（オプション）`,
    "(required)": `（必須）`
  },
  "ko-KR": {
    "(optional)": `(선택 사항)`,
    "(required)": `(필수 사항)`
  },
  "lt-LT": {
    "(optional)": `(pasirenkama)`,
    "(required)": `(privaloma)`
  },
  "lv-LV": {
    "(optional)": `(neobligāti)`,
    "(required)": `(obligāti)`
  },
  "nb-NO": {
    "(optional)": `(valgfritt)`,
    "(required)": `(obligatorisk)`
  },
  "nl-NL": {
    "(optional)": `(optioneel)`,
    "(required)": `(vereist)`
  },
  "pl-PL": {
    "(optional)": `(opcjonalne)`,
    "(required)": `(wymagane)`
  },
  "pt-BR": {
    "(optional)": `(opcional)`,
    "(required)": `(obrigatório)`
  },
  "pt-PT": {
    "(optional)": `(opcional)`,
    "(required)": `(obrigatório)`
  },
  "ro-RO": {
    "(optional)": `(opţional)`,
    "(required)": `(obligatoriu)`
  },
  "ru-RU": {
    "(optional)": `(дополнительно)`,
    "(required)": `(обязательно)`
  },
  "sk-SK": {
    "(optional)": `(nepovinné)`,
    "(required)": `(povinné)`
  },
  "sl-SI": {
    "(optional)": `(opcijsko)`,
    "(required)": `(obvezno)`
  },
  "sr-SP": {
    "(optional)": `(opciono)`,
    "(required)": `(obavezno)`
  },
  "sv-SE": {
    "(optional)": `(valfritt)`,
    "(required)": `(krävs)`
  },
  "tr-TR": {
    "(optional)": `(isteğe bağlı)`,
    "(required)": `(gerekli)`
  },
  "uk-UA": {
    "(optional)": `(необов’язково)`,
    "(required)": `(обов’язково)`
  },
  "zh-CN": {
    "(optional)": `（可选）`,
    "(required)": `（必填）`
  },
  "zh-TW": {
    "(optional)": `(選填)`,
    "(required)": `(必填)`
  }
};
var FieldLabel = forwardRefWithAs(function FieldLabel2({
  children,
  elementType: ElementType = "label",
  isRequired,
  supplementRequiredState,
  ...labelProps
}, forwardedRef) {
  const styleProps = useTextStyles({
    color: "neutral",
    size: "regular",
    trim: true,
    weight: "medium",
    UNSAFE_className: css({
      cursor: "default"
    })
  });
  return (0, import_jsx_runtime12.jsxs)(ElementType, {
    ref: forwardedRef,
    ...labelProps,
    ...styleProps,
    children: [children, isRequired && (0, import_jsx_runtime12.jsx)(Asterisk, {
      supplementRequiredState
    })]
  });
});
function Asterisk(t0) {
  const $ = c2(6);
  const {
    supplementRequiredState
  } = t0;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  let t1;
  if ($[0] !== supplementRequiredState || $[1] !== stringFormatter) {
    t1 = supplementRequiredState ? stringFormatter.format("(required)") : void 0;
    $[0] = supplementRequiredState;
    $[1] = stringFormatter;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t22;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = (0, import_jsx_runtime12.jsx)("span", {
      "aria-hidden": true,
      className: css({
        color: tokenSchema.color.foreground.critical,
        fontSize: tokenSchema.typography.text.large.size,
        lineHeight: 1,
        paddingInlineStart: "0.125em"
      }),
      children: "*"
    });
    $[3] = t22;
  } else {
    t22 = $[3];
  }
  let t32;
  if ($[4] !== t1) {
    t32 = (0, import_jsx_runtime12.jsx)("span", {
      "aria-label": t1,
      children: t22
    });
    $[4] = t1;
    $[5] = t32;
  } else {
    t32 = $[5];
  }
  return t32;
}
var FieldMessage = (props) => {
  const $ = c2(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      marginTop: "calc(var(--icon-offset) * -1)"
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      "--icon-offset": `calc(${tokenSchema.size.icon.regular} - ${tokenSchema.typography.text.small.size})`
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t22;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = (0, import_jsx_runtime12.jsx)(Icon, {
      src: alertTriangleIcon,
      color: "critical"
    });
    $[2] = t22;
  } else {
    t22 = $[2];
  }
  let t32;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t32 = css({
      paddingTop: "var(--icon-offset)"
    });
    $[3] = t32;
  } else {
    t32 = $[3];
  }
  let t4;
  if ($[4] !== props) {
    t4 = (0, import_jsx_runtime12.jsxs)(Flex, {
      gap: "regular",
      UNSAFE_className: t0,
      UNSAFE_style: t1,
      children: [t22, (0, import_jsx_runtime12.jsx)(Text, {
        color: "critical",
        size: "small",
        UNSAFE_className: t32,
        ...props
      })]
    });
    $[4] = props;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  return t4;
};
var FieldPrimitive = (0, import_react69.forwardRef)(function FieldPrimitive2(props, forwardedRef) {
  const $ = c2(30);
  const {
    children,
    contextualHelp,
    isRequired,
    label,
    labelElementType,
    labelProps,
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    supplementRequiredState
  } = props;
  const styleProps = useStyleProps(props);
  const contextualHelpId = (0, import_react69.useId)();
  labelProps === null || labelProps === void 0 || labelProps.id;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = css({
      marginBottom: tokenSchema.typography.text.regular.capheightTrim,
      marginTop: tokenSchema.typography.text.regular.baselineTrim
    });
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const t22 = labelProps !== null && labelProps !== void 0 && labelProps.id ? `${labelProps.id} ${contextualHelpId}` : void 0;
  let t32;
  if ($[1] !== contextualHelpId || $[2] !== t22) {
    t32 = {
      button: {
        UNSAFE_className: t1,
        id: contextualHelpId,
        "aria-labelledby": t22
      }
    };
    $[1] = contextualHelpId;
    $[2] = t22;
    $[3] = t32;
  } else {
    t32 = $[3];
  }
  t0 = t32;
  const contextualHelpSlots = t0;
  let t4;
  bb0: {
    if (!label) {
      t4 = null;
      break bb0;
    }
    let t52;
    if ($[4] !== labelElementType || $[5] !== isRequired || $[6] !== supplementRequiredState || $[7] !== labelProps || $[8] !== label) {
      t52 = (0, import_jsx_runtime12.jsx)(FieldLabel, {
        elementType: labelElementType,
        isRequired,
        supplementRequiredState,
        ...labelProps,
        children: label
      });
      $[4] = labelElementType;
      $[5] = isRequired;
      $[6] = supplementRequiredState;
      $[7] = labelProps;
      $[8] = label;
      $[9] = t52;
    } else {
      t52 = $[9];
    }
    const labelUI = t52;
    if (contextualHelp) {
      let t62;
      if ($[10] !== contextualHelpSlots || $[11] !== contextualHelp) {
        t62 = (0, import_jsx_runtime12.jsx)(SlotProvider, {
          slots: contextualHelpSlots,
          children: contextualHelp
        });
        $[10] = contextualHelpSlots;
        $[11] = contextualHelp;
        $[12] = t62;
      } else {
        t62 = $[12];
      }
      let t72;
      if ($[13] !== labelUI || $[14] !== t62) {
        t72 = (0, import_jsx_runtime12.jsxs)(Flex, {
          gap: "small",
          alignItems: "center",
          children: [labelUI, t62]
        });
        $[13] = labelUI;
        $[14] = t62;
        $[15] = t72;
      } else {
        t72 = $[15];
      }
      t4 = t72;
      break bb0;
    }
    t4 = labelUI;
  }
  let t5;
  if ($[16] !== description || $[17] !== descriptionProps) {
    t5 = description && (0, import_jsx_runtime12.jsx)(Text, {
      ...descriptionProps,
      size: "small",
      color: "neutralSecondary",
      children: description
    });
    $[16] = description;
    $[17] = descriptionProps;
    $[18] = t5;
  } else {
    t5 = $[18];
  }
  let t6;
  if ($[19] !== errorMessage || $[20] !== errorMessageProps) {
    t6 = errorMessage && (0, import_jsx_runtime12.jsx)(FieldMessage, {
      ...errorMessageProps,
      children: errorMessage
    });
    $[19] = errorMessage;
    $[20] = errorMessageProps;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  let t7;
  if ($[22] !== forwardedRef || $[23] !== styleProps.className || $[24] !== styleProps.style || $[25] !== t4 || $[26] !== t5 || $[27] !== children || $[28] !== t6) {
    t7 = (0, import_jsx_runtime12.jsxs)(Flex, {
      ref: forwardedRef,
      direction: "column",
      gap: "medium",
      minWidth: 0,
      UNSAFE_className: styleProps.className,
      UNSAFE_style: styleProps.style,
      children: [t4, t5, children, t6]
    });
    $[22] = forwardedRef;
    $[23] = styleProps.className;
    $[24] = styleProps.style;
    $[25] = t4;
    $[26] = t5;
    $[27] = children;
    $[28] = t6;
    $[29] = t7;
  } else {
    t7 = $[29];
  }
  return t7;
});
var Field = (props) => {
  const $ = c2(44);
  let isRequired;
  let errorMessage;
  let isDisabled;
  let isReadOnly;
  let label;
  let description;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      description,
      errorMessage,
      isDisabled,
      isReadOnly,
      isRequired,
      label,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isRequired;
    $[2] = errorMessage;
    $[3] = isDisabled;
    $[4] = isReadOnly;
    $[5] = label;
    $[6] = description;
    $[7] = otherProps;
    $[8] = children;
  } else {
    isRequired = $[1];
    errorMessage = $[2];
    isDisabled = $[3];
    isReadOnly = $[4];
    label = $[5];
    description = $[6];
    otherProps = $[7];
    children = $[8];
  }
  const {
    labelProps,
    fieldProps,
    descriptionProps,
    errorMessageProps
  } = $2baaea4c71418dea$export$294aa081a6c6f55d(props);
  const t0 = isRequired || void 0;
  const t1 = errorMessage ? true : void 0;
  let T0;
  let t22;
  let t32;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  if ($[9] !== fieldProps || $[10] !== isDisabled || $[11] !== isReadOnly || $[12] !== t0 || $[13] !== t1 || $[14] !== isRequired || $[15] !== label || $[16] !== labelProps || $[17] !== description || $[18] !== descriptionProps || $[19] !== errorMessage || $[20] !== errorMessageProps || $[21] !== otherProps || $[22] !== children) {
    const renderProps = {
      ...fieldProps,
      disabled: isDisabled,
      readOnly: isReadOnly,
      "aria-required": t0,
      "aria-invalid": t1
    };
    T0 = FieldPrimitive;
    t22 = isRequired;
    t32 = label;
    t4 = labelProps;
    t5 = description;
    t6 = descriptionProps;
    t7 = errorMessage;
    t8 = errorMessageProps;
    t9 = otherProps;
    t10 = children(renderProps);
    $[9] = fieldProps;
    $[10] = isDisabled;
    $[11] = isReadOnly;
    $[12] = t0;
    $[13] = t1;
    $[14] = isRequired;
    $[15] = label;
    $[16] = labelProps;
    $[17] = description;
    $[18] = descriptionProps;
    $[19] = errorMessage;
    $[20] = errorMessageProps;
    $[21] = otherProps;
    $[22] = children;
    $[23] = T0;
    $[24] = t22;
    $[25] = t32;
    $[26] = t4;
    $[27] = t5;
    $[28] = t6;
    $[29] = t7;
    $[30] = t8;
    $[31] = t9;
    $[32] = t10;
  } else {
    T0 = $[23];
    t22 = $[24];
    t32 = $[25];
    t4 = $[26];
    t5 = $[27];
    t6 = $[28];
    t7 = $[29];
    t8 = $[30];
    t9 = $[31];
    t10 = $[32];
  }
  let t11;
  if ($[33] !== T0 || $[34] !== t22 || $[35] !== t32 || $[36] !== t4 || $[37] !== t5 || $[38] !== t6 || $[39] !== t7 || $[40] !== t8 || $[41] !== t9 || $[42] !== t10) {
    t11 = (0, import_jsx_runtime12.jsx)(T0, {
      isRequired: t22,
      label: t32,
      labelProps: t4,
      description: t5,
      descriptionProps: t6,
      errorMessage: t7,
      errorMessageProps: t8,
      ...t9,
      children: t10
    });
    $[33] = T0;
    $[34] = t22;
    $[35] = t32;
    $[36] = t4;
    $[37] = t5;
    $[38] = t6;
    $[39] = t7;
    $[40] = t8;
    $[41] = t9;
    $[42] = t10;
    $[43] = t11;
  } else {
    t11 = $[43];
  }
  return t11;
};
function validateFieldProps(props) {
  if (props.errorMessage) {
    return Object.assign({}, {
      validationState: "invalid"
    }, props);
  }
  return props;
}

// node_modules/@keystar/ui/dist/keystar-ui-text-field.js
var import_react74 = __toESM(require_react());
var import_jsx_runtime13 = __toESM(require_jsx_runtime());

// node_modules/@react-aria/textfield/dist/useTextField.mjs
var import_react72 = __toESM(require_react(), 1);

// node_modules/@react-aria/form/dist/useFormValidation.mjs
var import_react70 = __toESM(require_react(), 1);
function $e93e671b31057976$export$b8473d3665f3a75a(props, state, ref) {
  let { validationBehavior, focus } = props;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (validationBehavior === "native" && (ref === null || ref === void 0 ? void 0 : ref.current)) {
      let errorMessage = state.realtimeValidation.isInvalid ? state.realtimeValidation.validationErrors.join(" ") || "Invalid value." : "";
      ref.current.setCustomValidity(errorMessage);
      if (!ref.current.hasAttribute("title")) ref.current.title = "";
      if (!state.realtimeValidation.isInvalid) state.updateValidation($e93e671b31057976$var$getNativeValidity(ref.current));
    }
  });
  let onReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    state.resetValidation();
  });
  let onInvalid = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    var _ref_current;
    if (!state.displayValidation.isInvalid) state.commitValidation();
    let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;
    if (!e4.defaultPrevented && ref && form && $e93e671b31057976$var$getFirstInvalidInput(form) === ref.current) {
      var _ref_current1;
      if (focus) focus();
      else (_ref_current1 = ref.current) === null || _ref_current1 === void 0 ? void 0 : _ref_current1.focus();
      (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
    }
    e4.preventDefault();
  });
  let onChange2 = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    state.commitValidation();
  });
  (0, import_react70.useEffect)(() => {
    let input = ref === null || ref === void 0 ? void 0 : ref.current;
    if (!input) return;
    let form = input.form;
    input.addEventListener("invalid", onInvalid);
    input.addEventListener("change", onChange2);
    form === null || form === void 0 ? void 0 : form.addEventListener("reset", onReset);
    return () => {
      input.removeEventListener("invalid", onInvalid);
      input.removeEventListener("change", onChange2);
      form === null || form === void 0 ? void 0 : form.removeEventListener("reset", onReset);
    };
  }, [
    ref,
    onInvalid,
    onChange2,
    onReset,
    validationBehavior
  ]);
}
function $e93e671b31057976$var$getValidity(input) {
  let validity = input.validity;
  return {
    badInput: validity.badInput,
    customError: validity.customError,
    patternMismatch: validity.patternMismatch,
    rangeOverflow: validity.rangeOverflow,
    rangeUnderflow: validity.rangeUnderflow,
    stepMismatch: validity.stepMismatch,
    tooLong: validity.tooLong,
    tooShort: validity.tooShort,
    typeMismatch: validity.typeMismatch,
    valueMissing: validity.valueMissing,
    valid: validity.valid
  };
}
function $e93e671b31057976$var$getNativeValidity(input) {
  return {
    isInvalid: !input.validity.valid,
    validationDetails: $e93e671b31057976$var$getValidity(input),
    validationErrors: input.validationMessage ? [
      input.validationMessage
    ] : []
  };
}
function $e93e671b31057976$var$getFirstInvalidInput(form) {
  for (let i4 = 0; i4 < form.elements.length; i4++) {
    let element2 = form.elements[i4];
    if (!element2.validity.valid) return element2;
  }
  return null;
}

// node_modules/@react-stately/form/dist/useFormValidationState.mjs
var import_react71 = __toESM(require_react(), 1);
var $e5be200c675c3b3a$export$aca958c65c314e6c = {
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valueMissing: false,
  valid: true
};
var $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {
  ...$e5be200c675c3b3a$export$aca958c65c314e6c,
  customError: true,
  valid: false
};
var $e5be200c675c3b3a$export$dad6ae84456c676a = {
  isInvalid: false,
  validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,
  validationErrors: []
};
var $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, import_react71.createContext)({});
var $e5be200c675c3b3a$export$a763b9476acd3eb = "__formValidationState" + Date.now();
function $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {
  if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {
    let { realtimeValidation, displayValidation, updateValidation, resetValidation, commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];
    return {
      realtimeValidation,
      displayValidation,
      updateValidation,
      resetValidation,
      commitValidation
    };
  }
  return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);
}
function $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {
  let { isInvalid, validationState, name, value: value2, builtinValidation, validate: validate2, validationBehavior = "aria" } = props;
  if (validationState) isInvalid || (isInvalid = validationState === "invalid");
  let controlledError = isInvalid !== void 0 ? {
    isInvalid,
    validationErrors: [],
    validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE
  } : null;
  let clientError = (0, import_react71.useMemo)(() => $e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate2, value2)), [
    validate2,
    value2
  ]);
  if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid) builtinValidation = null;
  let serverErrors = (0, import_react71.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);
  let serverErrorMessages = (0, import_react71.useMemo)(() => {
    if (name) return Array.isArray(name) ? name.flatMap((name2) => $e5be200c675c3b3a$var$asArray(serverErrors[name2])) : $e5be200c675c3b3a$var$asArray(serverErrors[name]);
    return [];
  }, [
    serverErrors,
    name
  ]);
  let [lastServerErrors, setLastServerErrors] = (0, import_react71.useState)(serverErrors);
  let [isServerErrorCleared, setServerErrorCleared] = (0, import_react71.useState)(false);
  if (serverErrors !== lastServerErrors) {
    setLastServerErrors(serverErrors);
    setServerErrorCleared(false);
  }
  let serverError = (0, import_react71.useMemo)(() => $e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [
    isServerErrorCleared,
    serverErrorMessages
  ]);
  let nextValidation = (0, import_react71.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let [currentValidity, setCurrentValidity] = (0, import_react71.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let lastError = (0, import_react71.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let commitValidation = () => {
    if (!commitQueued) return;
    setCommitQueued(false);
    let error2 = clientError || builtinValidation || nextValidation.current;
    if (!$e5be200c675c3b3a$var$isEqualValidation(error2, lastError.current)) {
      lastError.current = error2;
      setCurrentValidity(error2);
    }
  };
  let [commitQueued, setCommitQueued] = (0, import_react71.useState)(false);
  (0, import_react71.useEffect)(commitValidation);
  let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;
  let displayValidation = validationBehavior === "native" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;
  return {
    realtimeValidation,
    displayValidation,
    updateValidation(value3) {
      if (validationBehavior === "aria" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value3)) setCurrentValidity(value3);
      else nextValidation.current = value3;
    },
    resetValidation() {
      let error2 = $e5be200c675c3b3a$export$dad6ae84456c676a;
      if (!$e5be200c675c3b3a$var$isEqualValidation(error2, lastError.current)) {
        lastError.current = error2;
        setCurrentValidity(error2);
      }
      if (validationBehavior === "native") setCommitQueued(false);
      setServerErrorCleared(true);
    },
    commitValidation() {
      if (validationBehavior === "native") setCommitQueued(true);
      setServerErrorCleared(true);
    }
  };
}
function $e5be200c675c3b3a$var$asArray(v6) {
  if (!v6) return [];
  return Array.isArray(v6) ? v6 : [
    v6
  ];
}
function $e5be200c675c3b3a$var$runValidate(validate2, value2) {
  if (typeof validate2 === "function") {
    let e4 = validate2(value2);
    if (e4 && typeof e4 !== "boolean") return $e5be200c675c3b3a$var$asArray(e4);
  }
  return [];
}
function $e5be200c675c3b3a$var$getValidationResult(errors) {
  return errors.length ? {
    isInvalid: true,
    validationErrors: errors,
    validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE
  } : null;
}
function $e5be200c675c3b3a$var$isEqualValidation(a3, b2) {
  if (a3 === b2) return true;
  return a3 && b2 && a3.isInvalid === b2.isInvalid && a3.validationErrors.length === b2.validationErrors.length && a3.validationErrors.every((a4, i4) => a4 === b2.validationErrors[i4]) && Object.entries(a3.validationDetails).every(([k2, v6]) => b2.validationDetails[k2] === v6);
}
function $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {
  let errors = /* @__PURE__ */ new Set();
  let isInvalid = false;
  let validationDetails = {
    ...$e5be200c675c3b3a$export$aca958c65c314e6c
  };
  for (let v6 of results) {
    var _validationDetails, _key;
    for (let e4 of v6.validationErrors) errors.add(e4);
    isInvalid || (isInvalid = v6.isInvalid);
    for (let key in validationDetails) (_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v6.validationDetails[key]);
  }
  validationDetails.valid = !isInvalid;
  return {
    isInvalid,
    validationErrors: [
      ...errors
    ],
    validationDetails
  };
}

// node_modules/@react-aria/textfield/dist/useTextField.mjs
function $2d73ec29415bd339$export$712718f7aec83d5(props, ref) {
  let { inputElementType = "input", isDisabled = false, isRequired = false, isReadOnly = false, type: type3 = "text", validationBehavior = "aria" } = props;
  let [value2, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, props.defaultValue || "", props.onChange);
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: value2
  });
  let { isInvalid, validationErrors, validationDetails } = validationState.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  const inputOnlyProps = {
    type: type3,
    pattern: props.pattern
  };
  (0, $99facab73266f662$export$5add1d006293d136)(ref, value2, setValue);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)(props, validationState, ref);
  (0, import_react72.useEffect)(() => {
    if (ref.current instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(ref.current).HTMLTextAreaElement) {
      let input = ref.current;
      Object.defineProperty(input, "defaultValue", {
        get: () => input.value,
        set: () => {
        },
        configurable: true
      });
    }
  }, [
    ref
  ]);
  return {
    labelProps,
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, inputElementType === "input" ? inputOnlyProps : void 0, {
      disabled: isDisabled,
      readOnly: isReadOnly,
      required: isRequired && validationBehavior === "native",
      "aria-required": isRequired && validationBehavior === "aria" || void 0,
      "aria-invalid": isInvalid || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-activedescendant": props["aria-activedescendant"],
      "aria-autocomplete": props["aria-autocomplete"],
      "aria-haspopup": props["aria-haspopup"],
      value: value2,
      onChange: (e4) => setValue(e4.target.value),
      autoComplete: props.autoComplete,
      autoCapitalize: props.autoCapitalize,
      maxLength: props.maxLength,
      minLength: props.minLength,
      name: props.name,
      placeholder: props.placeholder,
      inputMode: props.inputMode,
      // Clipboard events
      onCopy: props.onCopy,
      onCut: props.onCut,
      onPaste: props.onPaste,
      // Composition events
      onCompositionEnd: props.onCompositionEnd,
      onCompositionStart: props.onCompositionStart,
      onCompositionUpdate: props.onCompositionUpdate,
      // Selection events
      onSelect: props.onSelect,
      // Input events
      onBeforeInput: props.onBeforeInput,
      onInput: props.onInput,
      ...focusableProps,
      ...fieldProps
    }),
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@react-aria/textfield/dist/useFormattedTextField.mjs
var import_react73 = __toESM(require_react(), 1);
function $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {
  return typeof window !== "undefined" && window.InputEvent && // @ts-ignore
  typeof InputEvent.prototype.getTargetRanges === "function";
}
function $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {
  let onBeforeInputFallback = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    let input = inputRef.current;
    let nextValue;
    switch (e4.inputType) {
      case "historyUndo":
      case "historyRedo":
        return;
      case "insertLineBreak":
        return;
      case "deleteContent":
      case "deleteByCut":
      case "deleteByDrag":
        nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteContentForward":
        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteContentBackward":
        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteSoftLineBackward":
      case "deleteHardLineBackward":
        nextValue = input.value.slice(input.selectionStart);
        break;
      default:
        if (e4.data != null) nextValue = input.value.slice(0, input.selectionStart) + e4.data + input.value.slice(input.selectionEnd);
        break;
    }
    if (nextValue == null || !state.validate(nextValue)) e4.preventDefault();
  });
  (0, import_react73.useEffect)(() => {
    if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent()) return;
    let input = inputRef.current;
    input.addEventListener("beforeinput", onBeforeInputFallback, false);
    return () => {
      input.removeEventListener("beforeinput", onBeforeInputFallback, false);
    };
  }, [
    inputRef,
    onBeforeInputFallback
  ]);
  let onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? (e4) => {
    let nextValue = e4.target.value.slice(0, e4.target.selectionStart) + e4.data + e4.target.value.slice(e4.target.selectionEnd);
    if (!state.validate(nextValue)) e4.preventDefault();
  } : null;
  let { labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps, ...validation } = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef);
  let compositionStartState = (0, import_react73.useRef)(null);
  return {
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(textFieldProps, {
      onBeforeInput,
      onCompositionStart() {
        let { value: value2, selectionStart, selectionEnd } = inputRef.current;
        compositionStartState.current = {
          value: value2,
          selectionStart,
          selectionEnd
        };
      },
      onCompositionEnd() {
        if (!state.validate(inputRef.current.value)) {
          let { value: value2, selectionStart, selectionEnd } = compositionStartState.current;
          inputRef.current.value = value2;
          inputRef.current.setSelectionRange(selectionStart, selectionEnd);
          state.setInputValue(value2);
        }
      }
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    ...validation
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-text-field.js
var TextFieldPrimitive = (0, import_react74.forwardRef)(function TextFieldPrimitive2(props, forwardedRef) {
  var _inputProps;
  const $ = c2(66);
  let t0;
  let isDisabled;
  let inputWrapperProps;
  let inputProps;
  let autoFocus;
  let startElement;
  let endElement;
  let isRequired;
  let description;
  let descriptionProps;
  let errorMessage;
  let errorMessageProps;
  let label;
  let labelProps;
  let otherProps;
  if ($[0] !== props) {
    const {
      autoFocus: t15,
      description: t23,
      descriptionProps: t33,
      endElement: t42,
      errorMessage: t52,
      errorMessageProps: t62,
      id: id2,
      inputProps: t72,
      inputWrapperProps: t82,
      isDisabled: t92,
      isMultiline: t102,
      isRequired: t112,
      label: t122,
      labelProps: t132,
      startElement: t142,
      ...t152
    } = props;
    autoFocus = t15;
    description = t23;
    descriptionProps = t33;
    endElement = t42;
    errorMessage = t52;
    errorMessageProps = t62;
    inputProps = t72;
    inputWrapperProps = t82;
    isDisabled = t92;
    t0 = t102;
    isRequired = t112;
    label = t122;
    labelProps = t132;
    startElement = t142;
    otherProps = t152;
    $[0] = props;
    $[1] = t0;
    $[2] = isDisabled;
    $[3] = inputWrapperProps;
    $[4] = inputProps;
    $[5] = autoFocus;
    $[6] = startElement;
    $[7] = endElement;
    $[8] = isRequired;
    $[9] = description;
    $[10] = descriptionProps;
    $[11] = errorMessage;
    $[12] = errorMessageProps;
    $[13] = label;
    $[14] = labelProps;
    $[15] = otherProps;
  } else {
    t0 = $[1];
    isDisabled = $[2];
    inputWrapperProps = $[3];
    inputProps = $[4];
    autoFocus = $[5];
    startElement = $[6];
    endElement = $[7];
    isRequired = $[8];
    description = $[9];
    descriptionProps = $[10];
    errorMessage = $[11];
    errorMessageProps = $[12];
    label = $[13];
    labelProps = $[14];
    otherProps = $[15];
  }
  const isMultiline = t0 === void 0 ? false : t0;
  const InputElement = isMultiline ? "textarea" : "input";
  let t1;
  if ($[16] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[16] = isDisabled;
    $[17] = t1;
  } else {
    t1 = $[17];
  }
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(t1);
  const inputClassName = useTextFieldStyles();
  const inputRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let t22;
  if ($[18] !== inputRef.current) {
    t22 = () => {
      var _inputRef$current;
      if (document.activeElement === inputRef.current) {
        return;
      }
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
    };
    $[18] = inputRef.current;
    $[19] = t22;
  } else {
    t22 = $[19];
  }
  const onIndicatorPressStart = t22;
  let t32;
  if ($[20] !== isDisabled || $[21] !== onIndicatorPressStart) {
    t32 = {
      isDisabled,
      onPressStart: onIndicatorPressStart,
      preventFocusOnPress: true
    };
    $[20] = isDisabled;
    $[21] = onIndicatorPressStart;
    $[22] = t32;
  } else {
    t32 = $[22];
  }
  const {
    pressProps
  } = $f6c31cce2adf654f$export$45712eceda6fad21(t32);
  let t4;
  if ($[23] !== inputWrapperProps) {
    var _inputWrapperProps;
    t4 = classNames(css({
      display: "flex",
      flex: "1 1 auto",
      position: "relative",
      zIndex: 0
    }), (_inputWrapperProps = inputWrapperProps) === null || _inputWrapperProps === void 0 ? void 0 : _inputWrapperProps.className);
    $[23] = inputWrapperProps;
    $[24] = t4;
  } else {
    t4 = $[24];
  }
  let t5;
  if ($[25] !== props || $[26] !== isHovered || $[27] !== isMultiline) {
    t5 = toDataAttributes({
      adornment: getAdornmentType(props),
      hovered: isHovered || void 0,
      multiline: isMultiline || void 0
    });
    $[25] = props;
    $[26] = isHovered;
    $[27] = isMultiline;
    $[28] = t5;
  } else {
    t5 = $[28];
  }
  const t6 = (_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps.className;
  let t7;
  if ($[29] !== inputClassName || $[30] !== t6) {
    t7 = classNames(inputClassName, t6);
    $[29] = inputClassName;
    $[30] = t6;
    $[31] = t7;
  } else {
    t7 = $[31];
  }
  let t8;
  if ($[32] !== props) {
    t8 = getAdornmentType(props);
    $[32] = props;
    $[33] = t8;
  } else {
    t8 = $[33];
  }
  const t9 = isMultiline ? 1 : void 0;
  let t10;
  if ($[34] !== InputElement || $[35] !== inputProps || $[36] !== t5 || $[37] !== t7 || $[38] !== t8 || $[39] !== inputRef || $[40] !== t9) {
    t10 = (0, import_jsx_runtime13.jsx)(InputElement, {
      ...inputProps,
      ...t5,
      className: t7,
      "data-adornment": t8,
      ref: inputRef,
      rows: t9
    });
    $[34] = InputElement;
    $[35] = inputProps;
    $[36] = t5;
    $[37] = t7;
    $[38] = t8;
    $[39] = inputRef;
    $[40] = t9;
    $[41] = t10;
  } else {
    t10 = $[41];
  }
  let t11;
  if ($[42] !== autoFocus || $[43] !== t10) {
    t11 = (0, import_jsx_runtime13.jsx)(FocusRing, {
      autoFocus,
      isTextInput: true,
      children: t10
    });
    $[42] = autoFocus;
    $[43] = t10;
    $[44] = t11;
  } else {
    t11 = $[44];
  }
  let t12;
  if ($[45] !== inputClassName || $[46] !== pressProps) {
    t12 = (0, import_jsx_runtime13.jsx)(InputStateIndicator, {
      inputClassName,
      ...pressProps
    });
    $[45] = inputClassName;
    $[46] = pressProps;
    $[47] = t12;
  } else {
    t12 = $[47];
  }
  let t13;
  if ($[48] !== inputWrapperProps || $[49] !== hoverProps || $[50] !== t4 || $[51] !== startElement || $[52] !== t11 || $[53] !== t12 || $[54] !== endElement) {
    t13 = (0, import_jsx_runtime13.jsxs)("div", {
      ...inputWrapperProps,
      ...hoverProps,
      className: t4,
      children: [startElement, t11, t12, endElement]
    });
    $[48] = inputWrapperProps;
    $[49] = hoverProps;
    $[50] = t4;
    $[51] = startElement;
    $[52] = t11;
    $[53] = t12;
    $[54] = endElement;
    $[55] = t13;
  } else {
    t13 = $[55];
  }
  let t14;
  if ($[56] !== isRequired || $[57] !== description || $[58] !== descriptionProps || $[59] !== errorMessage || $[60] !== errorMessageProps || $[61] !== label || $[62] !== labelProps || $[63] !== otherProps || $[64] !== t13) {
    t14 = (0, import_jsx_runtime13.jsx)(FieldPrimitive, {
      isRequired,
      description,
      descriptionProps,
      errorMessage,
      errorMessageProps,
      label,
      labelProps,
      ...otherProps,
      children: t13
    });
    $[56] = isRequired;
    $[57] = description;
    $[58] = descriptionProps;
    $[59] = errorMessage;
    $[60] = errorMessageProps;
    $[61] = label;
    $[62] = labelProps;
    $[63] = otherProps;
    $[64] = t13;
    $[65] = t14;
  } else {
    t14 = $[65];
  }
  return t14;
});
function makeSiblingSelector(base) {
  return function siblingSelector(...selectors) {
    return selectors.map((s4) => `.${base}${s4} + &`).join(", ");
  };
}
var InputStateIndicator = ({
  inputClassName,
  ...props
}) => {
  const s4 = makeSiblingSelector(inputClassName);
  return (0, import_jsx_runtime13.jsx)("div", {
    role: "presentation",
    ...props,
    className: css({
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
      borderRadius: tokenSchema.size.radius.regular,
      cursor: "text",
      inset: 0,
      position: "absolute",
      transition: transition(["border-color", "box-shadow"]),
      zIndex: -1,
      [s4("[data-hovered]")]: {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      [s4(":invalid", "[aria-invalid]")]: {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [s4(":focus")]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [s4(":focus:not([readonly])")]: {
        boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
      },
      [s4(":disabled", "[aria-disabled]")]: {
        backgroundColor: tokenSchema.color.alias.backgroundDisabled,
        // borderColor: tokenSchema.color.alias.borderDisabled,
        borderColor: "transparent",
        cursor: "auto"
      }
    })
  });
};
function useTextFieldStyles() {
  return css({
    color: tokenSchema.color.foreground.neutral,
    flex: 1,
    fontFamily: tokenSchema.typography.fontFamily.base,
    fontSize: tokenSchema.typography.text.regular.size,
    fontWeight: tokenSchema.typography.fontWeight.regular,
    height: tokenSchema.size.element.regular,
    lineHeight: tokenSchema.typography.lineheight.small,
    outline: 0,
    overflow: "visible",
    paddingBlock: tokenSchema.size.space.small,
    paddingInline: tokenSchema.size.space.medium,
    position: "relative",
    textIndent: 0,
    textOverflow: "ellipsis",
    verticalAlign: "top",
    width: "100%",
    MozOsxFontSmoothing: "auto",
    WebkitFontSmoothing: "auto",
    "::placeholder": {
      color: tokenSchema.color.foreground.neutralTertiary
    },
    "&:disabled, &[aria-disabled]": {
      color: tokenSchema.color.alias.foregroundDisabled,
      "::placeholder": {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    },
    /* Remove the inner padding and cancel buttons for input[type="search"] in Chrome and Safari on macOS. */
    "&::-webkit-search-cancel-button, &::-webkit-search-decoration": {
      WebkitAppearance: "none"
    },
    // TEXTAREA
    // ------------------------------
    "&[data-multiline]": {
      height: "auto",
      lineHeight: tokenSchema.typography.lineheight.medium,
      // min: 3 lines
      minHeight: `calc(${tokenSchema.size.space.regular} * 2 + ${tokenSchema.typography.text.regular.size} * ${tokenSchema.typography.lineheight.medium} * 3)`,
      overflow: "auto",
      paddingBlock: tokenSchema.size.space.regular,
      resize: "none"
    }
  });
}
function getAdornmentType(props) {
  if (props.startElement && props.endElement) {
    return "both";
  } else if (props.startElement) {
    return "start";
  } else if (props.endElement) {
    return "end";
  }
  return "none";
}
function validateTextFieldProps(props) {
  warning(!props.placeholder || !!props.description, "Placeholder text is not accessible. Use the `description` prop to provide information that will aid user input.");
  return validateFieldProps(props);
}
var TextField = (0, import_react74.forwardRef)(function TextField2(props, forwardedRef) {
  const $ = c2(9);
  let t0;
  if ($[0] !== props) {
    t0 = validateTextFieldProps(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  props = t0;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  } = $2d73ec29415bd339$export$712718f7aec83d5(props, domRef);
  let t1;
  if ($[2] !== domRef || $[3] !== props || $[4] !== labelProps || $[5] !== inputProps || $[6] !== descriptionProps || $[7] !== errorMessageProps) {
    t1 = (0, import_jsx_runtime13.jsx)(TextFieldPrimitive, {
      ref: domRef,
      ...props,
      labelProps,
      inputProps,
      descriptionProps,
      errorMessageProps
    });
    $[2] = domRef;
    $[3] = props;
    $[4] = labelProps;
    $[5] = inputProps;
    $[6] = descriptionProps;
    $[7] = errorMessageProps;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  return t1;
});
var TextArea = (0, import_react74.forwardRef)(function TextArea2({
  onChange: onChange2,
  ...props
}, forwardedRef) {
  var _props$defaultValue;
  props = validateTextFieldProps(props);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let [inputValue, setInputValue] = $458b0a5536c1a7cf$export$40bfa8c7b0832715(props.value, (_props$defaultValue = props.defaultValue) !== null && _props$defaultValue !== void 0 ? _props$defaultValue : "", () => {
  });
  let onHeightChange = (0, import_react74.useCallback)(() => {
    let input = domRef.current;
    if (!props.height && input) {
      let prevOverflow = input.style.overflow;
      let isFirefox = "MozAppearance" in input.style;
      if (!isFirefox) {
        input.style.overflow = "hidden";
      }
      input.style.height = "auto";
      input.style.height = `${input.scrollHeight + (input.offsetHeight - input.clientHeight)}px`;
      input.style.overflow = prevOverflow;
    }
  }, [domRef, props.height]);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (domRef.current) {
      onHeightChange();
    }
  }, [onHeightChange, inputValue, domRef]);
  let {
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  } = $2d73ec29415bd339$export$712718f7aec83d5({
    ...props,
    onChange: $ff5963eb1fccf552$export$e08e3b67e392101e(onChange2, setInputValue),
    inputElementType: "textarea"
  }, domRef);
  return (0, import_jsx_runtime13.jsx)(TextFieldPrimitive, {
    ...props,
    ref: domRef,
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps,
    isMultiline: true
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-minusIcon.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var minusIcon = (0, import_jsx_runtime14.jsx)("path", {
  d: "M5 12h14"
});

// node_modules/@keystar/ui/dist/keystar-ui-overlays.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var import_react75 = __toESM(require_react());
function Blanket(props) {
  const $ = c2(18);
  let otherProps;
  let isTransparent;
  let isOpen;
  if ($[0] !== props) {
    ({
      isOpen,
      isTransparent,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = isTransparent;
    $[3] = isOpen;
  } else {
    otherProps = $[1];
    isTransparent = $[2];
    isOpen = $[3];
  }
  const styleProps = useStyleProps(otherProps);
  let t0;
  if ($[4] !== otherProps) {
    t0 = filterStyleProps(otherProps);
    $[4] = otherProps;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const t1 = isTransparent ? "transparent" : "translucent";
  const t22 = isOpen || void 0;
  let t32;
  if ($[6] !== t1 || $[7] !== t22) {
    t32 = toDataAttributes({
      fill: t1,
      open: t22
    });
    $[6] = t1;
    $[7] = t22;
    $[8] = t32;
  } else {
    t32 = $[8];
  }
  let t4;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = transition("opacity", {
      easing: "easeOut",
      duration: "regular",
      delay: "short"
    });
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  let t5;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = [t4, transition("visibility", {
      delay: "regular",
      duration: 0,
      easing: "linear"
    })];
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== styleProps.className) {
    t6 = classNames(css({
      inset: 0,
      opacity: 0,
      overflow: "hidden",
      pointerEvents: "none",
      position: "fixed",
      visibility: "hidden",
      zIndex: 1,
      '&[data-fill="translucent"]': {
        backgroundColor: "#0006",
        transition: t5.join(", ")
      },
      '&[data-open="true"]': {
        opacity: 1,
        pointerEvents: "auto",
        visibility: "visible",
        transition: transition("opacity", {
          easing: "easeIn"
        })
      }
    }), styleProps.className);
    $[11] = styleProps.className;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  let t7;
  if ($[13] !== t0 || $[14] !== t32 || $[15] !== styleProps || $[16] !== t6) {
    t7 = (0, import_jsx_runtime15.jsx)("div", {
      ...t0,
      ...t32,
      ...styleProps,
      className: t6
    });
    $[13] = t0;
    $[14] = t32;
    $[15] = styleProps;
    $[16] = t6;
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  return t7;
}
function DirectionIndicator(t0) {
  const $ = c2(25);
  let fill;
  let placement;
  let size3;
  let props;
  let stroke;
  if ($[0] !== t0) {
    ({
      fill,
      placement,
      size: size3,
      stroke,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = fill;
    $[2] = placement;
    $[3] = size3;
    $[4] = props;
    $[5] = stroke;
  } else {
    fill = $[1];
    placement = $[2];
    size3 = $[3];
    props = $[4];
    stroke = $[5];
  }
  let t1;
  if ($[6] !== fill || $[7] !== placement || $[8] !== size3) {
    t1 = toDataAttributes({
      fill,
      placement,
      size: size3
    });
    $[6] = fill;
    $[7] = placement;
    $[8] = size3;
    $[9] = t1;
  } else {
    t1 = $[9];
  }
  let t22;
  if ($[10] !== props.className) {
    t22 = classNames(css({
      height: "var(--size)",
      position: "absolute",
      width: "var(--size)",
      '&[data-fill="surface"]': {
        fill: tokenSchema.color.background.surface
      },
      '&[data-fill="inverse"]': {
        fill: tokenSchema.color.background.inverse
      },
      '&[data-fill="accent"]': {
        fill: tokenSchema.color.background.accentEmphasis
      },
      '&[data-fill="critical"]': {
        fill: tokenSchema.color.background.criticalEmphasis
      },
      '&[data-fill="positive"]': {
        fill: tokenSchema.color.background.positiveEmphasis
      },
      '&[data-size="xsmall"]': {
        "--size": tokenSchema.size.element.xsmall
      },
      '&[data-size="small"]': {
        "--size": tokenSchema.size.element.small
      },
      '&[data-size="regular"]': {
        "--size": tokenSchema.size.element.regular
      },
      '&[data-placement="top"], &[data-placement="bottom"]': {
        left: "50%",
        transform: "translateX(-50%)"
      },
      '&[data-placement="top"]': {
        top: "100%"
      },
      '&[data-placement="bottom"]': {
        bottom: "100%"
      },
      '&[data-placement="left"], &[data-placement="right"], &[data-placement="start"], &[data-placement="end"]': {
        top: "50%",
        transform: "translateY(-50%)"
      },
      '&[data-placement="left"]': {
        left: "100%"
      },
      '&[data-placement="right"]': {
        right: "100%"
      },
      '&[data-placement="start"]': {
        insetInlineStart: "100%"
      },
      '&[data-placement="end"]': {
        insetInlineEnd: "100%"
      }
    }), props.className);
    $[10] = props.className;
    $[11] = t22;
  } else {
    t22 = $[11];
  }
  let t32;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t32 = css({
      '&[data-placement="top"]': {
        transform: "rotate(180deg)"
      },
      '&[data-placement="left"], [dir=ltr] &[data-placement="start"], [dir=rtl] &[data-placement="end"]': {
        transform: "rotate(90deg)"
      },
      '&[data-placement="right"], [dir=ltr] &[data-placement="end"], [dir=rtl] &[data-placement="start"]': {
        transform: "rotate(270deg)"
      }
    });
    $[12] = t32;
  } else {
    t32 = $[12];
  }
  let t4;
  if ($[13] !== stroke) {
    t4 = stroke && (0, import_jsx_runtime15.jsx)("path", {
      fill: stroke,
      d: "M23.7,27.1L17,19.9C16.5,19.3,15.8,19,15,19s-1.6,0.3-2.1,0.9l-6.6,7.2C5.3,28.1,3.4,29,2,29h26 C26.7,29,24.6,28.1,23.7,27.1z"
    });
    $[13] = stroke;
    $[14] = t4;
  } else {
    t4 = $[14];
  }
  let t5;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime15.jsx)("path", {
      d: "M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"
    });
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== placement || $[17] !== t4) {
    t6 = (0, import_jsx_runtime15.jsxs)("svg", {
      "data-placement": placement,
      viewBox: "0 0 30 30",
      className: t32,
      children: [t4, t5]
    });
    $[16] = placement;
    $[17] = t4;
    $[18] = t6;
  } else {
    t6 = $[18];
  }
  let t7;
  if ($[19] !== props || $[20] !== t1 || $[21] !== placement || $[22] !== t22 || $[23] !== t6) {
    t7 = (0, import_jsx_runtime15.jsx)("span", {
      ...props,
      ...t1,
      "data-placement": placement,
      className: t22,
      children: t6
    });
    $[19] = props;
    $[20] = t1;
    $[21] = placement;
    $[22] = t22;
    $[23] = t6;
    $[24] = t7;
  } else {
    t7 = $[24];
  }
  return t7;
}
var forceReflow = (node2) => node2.scrollTop;
var Transition = function Transition2(props) {
  const $ = c2(3);
  const {
    isOpen
  } = useTransition(props);
  if (!isOpen) {
    return null;
  }
  let t0;
  if ($[0] !== isOpen || $[1] !== props) {
    var _cloneValidElement;
    t0 = (_cloneValidElement = cloneValidElement(props.children, {
      isOpen: isOpen === "mounting" ? false : props.isOpen
    })) !== null && _cloneValidElement !== void 0 ? _cloneValidElement : props.children;
    $[0] = isOpen;
    $[1] = props;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
};
function useTransition(props) {
  const $ = c2(22);
  const {
    isOpen: isOpenProp,
    nodeRef,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting
  } = props;
  const [isOpen, setIsOpen] = (0, import_react75.useState)(isOpenProp ? "mounting" : false);
  if (isOpenProp && !isOpen) {
    setIsOpen("mounting");
  }
  const hasCalledCompletedCallback = (0, import_react75.useRef)(false);
  let t0;
  if ($[0] !== isOpenProp || $[1] !== isOpen || $[2] !== onEntered || $[3] !== onExited || $[4] !== onEnter || $[5] !== nodeRef.current || $[6] !== onEntering || $[7] !== onExit || $[8] !== onExiting) {
    t0 = () => {
      if (!hasCalledCompletedCallback.current && isOpenProp === isOpen) {
        hasCalledCompletedCallback.current = true;
        if (isOpenProp) {
          onEntered === null || onEntered === void 0 || onEntered();
        } else {
          onExited === null || onExited === void 0 || onExited();
        }
      }
      if (isOpenProp === isOpen) {
        return;
      }
      hasCalledCompletedCallback.current = false;
      if (isOpenProp) {
        onEnter === null || onEnter === void 0 || onEnter();
        if (nodeRef.current) {
          forceReflow(nodeRef.current);
        }
        setIsOpen(true);
        onEntering === null || onEntering === void 0 || onEntering();
      } else {
        onExit === null || onExit === void 0 || onExit();
        onExiting === null || onExiting === void 0 || onExiting();
        const id2 = setTimeout(() => {
          setIsOpen(false);
        }, 320);
        return () => clearTimeout(id2);
      }
    };
    $[0] = isOpenProp;
    $[1] = isOpen;
    $[2] = onEntered;
    $[3] = onExited;
    $[4] = onEnter;
    $[5] = nodeRef.current;
    $[6] = onEntering;
    $[7] = onExit;
    $[8] = onExiting;
    $[9] = t0;
  } else {
    t0 = $[9];
  }
  let t1;
  if ($[10] !== isOpenProp || $[11] !== isOpen || $[12] !== nodeRef || $[13] !== onEnter || $[14] !== onEntering || $[15] !== onExit || $[16] !== onExiting || $[17] !== onEntered || $[18] !== onExited) {
    t1 = [isOpenProp, isOpen, nodeRef, onEnter, onEntering, onExit, onExiting, onEntered, onExited];
    $[10] = isOpenProp;
    $[11] = isOpen;
    $[12] = nodeRef;
    $[13] = onEnter;
    $[14] = onEntering;
    $[15] = onExit;
    $[16] = onExiting;
    $[17] = onEntered;
    $[18] = onExited;
    $[19] = t1;
  } else {
    t1 = $[19];
  }
  (0, import_react75.useLayoutEffect)(t0, t1);
  let t22;
  if ($[20] !== isOpen) {
    t22 = {
      isOpen,
      setIsOpen
    };
    $[20] = isOpen;
    $[21] = t22;
  } else {
    t22 = $[21];
  }
  return t22;
}
var Overlay = (0, import_react75.forwardRef)(function Overlay2(props, forwardedRef) {
  const $ = c2(10);
  const {
    isOpen
  } = useTransition(props);
  if (!isOpen) {
    return null;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      background: "transparent",
      isolation: "isolate"
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== isOpen || $[2] !== props) {
    var _cloneValidElement;
    t1 = (_cloneValidElement = cloneValidElement(props.children, {
      isOpen: isOpen === "mounting" ? false : props.isOpen
    })) !== null && _cloneValidElement !== void 0 ? _cloneValidElement : props.children;
    $[1] = isOpen;
    $[2] = props;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t22;
  if ($[4] !== forwardedRef || $[5] !== t1) {
    t22 = (0, import_jsx_runtime15.jsx)(KeystarProvider, {
      ref: forwardedRef,
      UNSAFE_style: t0,
      isDisabled: false,
      children: t1
    });
    $[4] = forwardedRef;
    $[5] = t1;
    $[6] = t22;
  } else {
    t22 = $[6];
  }
  let t32;
  if ($[7] !== props.container || $[8] !== t22) {
    t32 = (0, import_jsx_runtime15.jsx)($337b884510726a0d$export$c6fdb837b070b4ff, {
      portalContainer: props.container,
      children: t22
    });
    $[7] = props.container;
    $[8] = t22;
    $[9] = t32;
  } else {
    t32 = $[9];
  }
  return t32;
});
var Modal = (0, import_react75.forwardRef)(function Modal2(props, forwardedRef) {
  const $ = c2(14);
  let children;
  let otherProps;
  let state;
  if ($[0] !== props) {
    ({
      children,
      state,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = children;
    $[2] = otherProps;
    $[3] = state;
  } else {
    children = $[1];
    otherProps = $[2];
    state = $[3];
  }
  const wrapperRef = (0, import_react75.useRef)(null);
  let t0;
  if ($[4] !== forwardedRef || $[5] !== props || $[6] !== wrapperRef || $[7] !== children) {
    t0 = (0, import_jsx_runtime15.jsx)(ModalWrapper, {
      ref: forwardedRef,
      ...props,
      wrapperRef,
      children
    });
    $[4] = forwardedRef;
    $[5] = props;
    $[6] = wrapperRef;
    $[7] = children;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  let t1;
  if ($[9] !== otherProps || $[10] !== state.isOpen || $[11] !== wrapperRef || $[12] !== t0) {
    t1 = (0, import_jsx_runtime15.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: t0
    });
    $[9] = otherProps;
    $[10] = state.isOpen;
    $[11] = wrapperRef;
    $[12] = t0;
    $[13] = t1;
  } else {
    t1 = $[13];
  }
  return t1;
});
var MAX_HEIGHT_VAR = `--${TOKEN_PREFIX}-visual-viewport-height`;
var ModalWrapper = (0, import_react75.forwardRef)(function ModalWrapper2(props, forwardedRef) {
  const $ = c2(27);
  const {
    type: type3,
    children,
    state,
    isOpen,
    wrapperRef
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, domRef);
  const styleProps = useStyleProps(props);
  const viewport = $5df64b3807dc15ee$export$d699905dd57c73ca();
  let t0;
  if ($[0] !== underlayProps || $[1] !== isOpen) {
    t0 = (0, import_jsx_runtime15.jsx)(Blanket, {
      ...underlayProps,
      isOpen
    });
    $[0] = underlayProps;
    $[1] = isOpen;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = css({
      alignItems: "center",
      boxSizing: "border-box",
      display: "flex",
      insetBlockStart: 0,
      insetInlineStart: 0,
      justifyContent: "center",
      pointerEvents: "none",
      position: "fixed",
      width: "100vw",
      zIndex: 2
    });
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const t22 = `${viewport.height}px`;
  let t32;
  if ($[4] !== t22) {
    t32 = {
      [MAX_HEIGHT_VAR]: t22,
      height: `var(${MAX_HEIGHT_VAR})`
    };
    $[4] = t22;
    $[5] = t32;
  } else {
    t32 = $[5];
  }
  let t4;
  if ($[6] !== isOpen || $[7] !== type3) {
    t4 = toDataAttributes({
      open: isOpen,
      type: type3
    });
    $[6] = isOpen;
    $[7] = type3;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  let t5;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = transition("opacity", {
      easing: "easeIn"
    });
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = [t5, transition("transform", {
      delay: "short",
      duration: 0,
      easing: "linear"
    })];
    $[10] = t6;
  } else {
    t6 = $[10];
  }
  let t7;
  if ($[11] !== styleProps.className) {
    t7 = classNames(styleProps.className, css({
      backgroundColor: tokenSchema.color.background.surface,
      borderRadius: tokenSchema.size.radius.large,
      boxShadow: `${tokenSchema.size.shadow.large} ${tokenSchema.color.shadow.emphasis}`,
      maxHeight: `calc(var(${MAX_HEIGHT_VAR}) * 0.9)`,
      maxWidth: "90vw",
      opacity: 0,
      outline: 0,
      pointerEvents: "auto",
      transform: `translateY(${tokenSchema.size.space.large})`,
      zIndex: 2,
      transition: t6.join(", "),
      '&[data-type="fullscreen"]': {
        position: "fixed",
        inset: tokenSchema.size.space.xxlarge,
        maxWidth: "none",
        maxHeight: "none",
        width: `calc(100% - calc(2 * ${tokenSchema.size.space.xxlarge}))`,
        height: `calc(100% - calc(2 * ${tokenSchema.size.space.xxlarge}))`
      },
      '&[data-open="true"]': {
        opacity: 1,
        transform: `translateY(0)`,
        transition: transition(["opacity", "transform"], {
          easing: "easeOut"
        })
      }
    }));
    $[11] = styleProps.className;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  let t8;
  if ($[13] !== modalProps || $[14] !== t4 || $[15] !== styleProps || $[16] !== domRef || $[17] !== t7 || $[18] !== children) {
    t8 = (0, import_jsx_runtime15.jsx)("div", {
      ...modalProps,
      ...t4,
      ...styleProps,
      ref: domRef,
      className: t7,
      children
    });
    $[13] = modalProps;
    $[14] = t4;
    $[15] = styleProps;
    $[16] = domRef;
    $[17] = t7;
    $[18] = children;
    $[19] = t8;
  } else {
    t8 = $[19];
  }
  let t9;
  if ($[20] !== t32 || $[21] !== t8) {
    t9 = (0, import_jsx_runtime15.jsx)("div", {
      className: t1,
      style: t32,
      children: t8
    });
    $[20] = t32;
    $[21] = t8;
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== wrapperRef || $[24] !== t0 || $[25] !== t9) {
    t10 = (0, import_jsx_runtime15.jsxs)("div", {
      ref: wrapperRef,
      children: [t0, t9]
    });
    $[23] = wrapperRef;
    $[24] = t0;
    $[25] = t9;
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  return t10;
});
var Popover = (0, import_react75.forwardRef)(function Popover2(props, forwardedRef) {
  const $ = c2(14);
  let children;
  let otherProps;
  let state;
  if ($[0] !== props) {
    ({
      children,
      state,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = children;
    $[2] = otherProps;
    $[3] = state;
  } else {
    children = $[1];
    otherProps = $[2];
    state = $[3];
  }
  const wrapperRef = (0, import_react75.useRef)(null);
  let t0;
  if ($[4] !== forwardedRef || $[5] !== props || $[6] !== wrapperRef || $[7] !== children) {
    t0 = (0, import_jsx_runtime15.jsx)(PopoverWrapper, {
      ref: forwardedRef,
      ...props,
      wrapperRef,
      children
    });
    $[4] = forwardedRef;
    $[5] = props;
    $[6] = wrapperRef;
    $[7] = children;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  let t1;
  if ($[9] !== otherProps || $[10] !== state.isOpen || $[11] !== wrapperRef || $[12] !== t0) {
    t1 = (0, import_jsx_runtime15.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: t0
    });
    $[9] = otherProps;
    $[10] = state.isOpen;
    $[11] = wrapperRef;
    $[12] = t0;
    $[13] = t1;
  } else {
    t1 = $[13];
  }
  return t1;
});
var PopoverWrapper = (0, import_react75.forwardRef)(function PopoverWrapper2(props, forwardedRef) {
  const $ = c2(35);
  const {
    children,
    isOpen,
    hideArrow,
    isNonModal,
    state,
    wrapperRef
  } = props;
  const popoverRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let t0;
  if ($[0] !== props || $[1] !== popoverRef) {
    t0 = {
      ...props,
      containerPadding: 8,
      popoverRef,
      maxHeight: null
    };
    $[0] = props;
    $[1] = popoverRef;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const {
    popoverProps,
    arrowProps,
    underlayProps,
    placement
  } = $f2f8a6077418541e$export$542a6fd13ac93354(t0, state);
  const t1 = placement;
  let t22;
  if ($[3] !== props || $[4] !== t1) {
    t22 = {
      ...props,
      placement: t1
    };
    $[3] = props;
    $[4] = t1;
    $[5] = t22;
  } else {
    t22 = $[5];
  }
  const styleProps = usePopoverStyles(t22);
  let t32;
  if ($[6] !== isNonModal || $[7] !== underlayProps || $[8] !== isOpen) {
    t32 = !isNonModal && (0, import_jsx_runtime15.jsx)(Blanket, {
      isTransparent: true,
      ...underlayProps,
      isOpen
    });
    $[6] = isNonModal;
    $[7] = underlayProps;
    $[8] = isOpen;
    $[9] = t32;
  } else {
    t32 = $[9];
  }
  let t4;
  if ($[10] !== styleProps.style || $[11] !== popoverProps.style) {
    t4 = {
      ...styleProps.style,
      ...popoverProps.style
    };
    $[10] = styleProps.style;
    $[11] = popoverProps.style;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  let t5;
  if ($[13] !== isNonModal || $[14] !== state) {
    t5 = !isNonModal && (0, import_jsx_runtime15.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
      onDismiss: state.close
    });
    $[13] = isNonModal;
    $[14] = state;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== hideArrow || $[17] !== placement || $[18] !== arrowProps) {
    t6 = hideArrow ? null : (0, import_jsx_runtime15.jsx)(DirectionIndicator, {
      ...arrowProps,
      fill: "surface",
      stroke: tokenSchema.color.border.emphasis,
      placement,
      size: "regular"
    });
    $[16] = hideArrow;
    $[17] = placement;
    $[18] = arrowProps;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  let t7;
  if ($[20] !== state.close) {
    t7 = (0, import_jsx_runtime15.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
      onDismiss: state.close
    });
    $[20] = state.close;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  let t8;
  if ($[22] !== styleProps || $[23] !== popoverProps || $[24] !== t4 || $[25] !== popoverRef || $[26] !== t5 || $[27] !== t6 || $[28] !== children || $[29] !== t7) {
    t8 = (0, import_jsx_runtime15.jsxs)("div", {
      ...styleProps,
      ...popoverProps,
      style: t4,
      ref: popoverRef,
      role: "presentation",
      children: [t5, t6, children, t7]
    });
    $[22] = styleProps;
    $[23] = popoverProps;
    $[24] = t4;
    $[25] = popoverRef;
    $[26] = t5;
    $[27] = t6;
    $[28] = children;
    $[29] = t7;
    $[30] = t8;
  } else {
    t8 = $[30];
  }
  let t9;
  if ($[31] !== wrapperRef || $[32] !== t32 || $[33] !== t8) {
    t9 = (0, import_jsx_runtime15.jsxs)("div", {
      ref: wrapperRef,
      children: [t32, t8]
    });
    $[31] = wrapperRef;
    $[32] = t32;
    $[33] = t8;
    $[34] = t9;
  } else {
    t9 = $[34];
  }
  return t9;
});
function usePopoverStyles(props) {
  const $ = c2(19);
  const {
    hideArrow,
    isOpen,
    placement
  } = props;
  const consumerStyleProps = useStyleProps(props);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = transition("opacity", {
      easing: "easeIn"
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [t0, transition("transform", {
      delay: "short",
      duration: 0,
      easing: "linear"
    })];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t22;
  let t32;
  if ($[2] !== hideArrow || $[3] !== isOpen || $[4] !== placement || $[5] !== consumerStyleProps.className) {
    const popoverStyles = css({
      backgroundColor: tokenSchema.color.background.surface,
      borderRadius: tokenSchema.size.radius.medium,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
      boxSizing: "content-box",
      opacity: 0,
      outline: 0,
      pointerEvents: "auto",
      position: "absolute",
      filter: `drop-shadow(0 1px 4px ${tokenSchema.color.shadow.regular})`,
      willChange: "filter, transform",
      transition: t1.join(", "),
      "&[data-placement=top]": {
        marginTop: tokenSchema.size.space.regular
      },
      "&[data-placement=bottom]": {
        marginBottom: tokenSchema.size.space.regular
      },
      "&[data-placement=left]": {
        marginLeft: tokenSchema.size.space.regular
      },
      "&[data-placement=right]": {
        marginRight: tokenSchema.size.space.regular
      },
      "&[data-open]": {
        opacity: 1,
        transition: transition(["opacity", "transform"], {
          easing: "easeOut"
        })
      },
      "&[data-placement=top][data-open]": {
        transform: `translateY(calc(${"var(--popover-offset)"} * -1))`
      },
      "&[data-placement=bottom][data-open]": {
        transform: `translateY(${"var(--popover-offset)"})`
      },
      "&[data-placement=left][data-open]": {
        transform: `translateX(calc(${"var(--popover-offset)"} * -1))`
      },
      "&[data-placement=right][data-open]": {
        transform: `translateX(${"var(--popover-offset)"})`
      }
    });
    const t42 = !hideArrow || void 0;
    const t52 = isOpen || void 0;
    if ($[8] !== t42 || $[9] !== placement || $[10] !== t52) {
      t22 = toDataAttributes({
        arrow: t42,
        placement,
        open: t52
      });
      $[8] = t42;
      $[9] = placement;
      $[10] = t52;
      $[11] = t22;
    } else {
      t22 = $[11];
    }
    t32 = classNames(popoverStyles, consumerStyleProps.className);
    $[2] = hideArrow;
    $[3] = isOpen;
    $[4] = placement;
    $[5] = consumerStyleProps.className;
    $[6] = t22;
    $[7] = t32;
  } else {
    t22 = $[6];
    t32 = $[7];
  }
  const t4 = hideArrow ? tokenSchema.size.space.regular : tokenSchema.size.space.large;
  let t5;
  if ($[12] !== t4 || $[13] !== consumerStyleProps.style) {
    t5 = {
      "--popover-offset": t4,
      ...consumerStyleProps.style
    };
    $[12] = t4;
    $[13] = consumerStyleProps.style;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  let t6;
  if ($[15] !== t22 || $[16] !== t32 || $[17] !== t5) {
    t6 = {
      ...t22,
      className: t32,
      style: t5
    };
    $[15] = t22;
    $[16] = t32;
    $[17] = t5;
    $[18] = t6;
  } else {
    t6 = $[18];
  }
  return t6;
}
var Tray = (0, import_react75.forwardRef)(function Tray2(props, forwardedRef) {
  const $ = c2(14);
  let children;
  let otherProps;
  let state;
  if ($[0] !== props) {
    ({
      children,
      state,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = children;
    $[2] = otherProps;
    $[3] = state;
  } else {
    children = $[1];
    otherProps = $[2];
    state = $[3];
  }
  const wrapperRef = (0, import_react75.useRef)(null);
  let t0;
  if ($[4] !== forwardedRef || $[5] !== props || $[6] !== wrapperRef || $[7] !== children) {
    t0 = (0, import_jsx_runtime15.jsx)(TrayWrapper, {
      ref: forwardedRef,
      ...props,
      wrapperRef,
      children
    });
    $[4] = forwardedRef;
    $[5] = props;
    $[6] = wrapperRef;
    $[7] = children;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  let t1;
  if ($[9] !== otherProps || $[10] !== state.isOpen || $[11] !== wrapperRef || $[12] !== t0) {
    t1 = (0, import_jsx_runtime15.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: t0
    });
    $[9] = otherProps;
    $[10] = state.isOpen;
    $[11] = wrapperRef;
    $[12] = t0;
    $[13] = t1;
  } else {
    t1 = $[13];
  }
  return t1;
});
var TrayWrapper = (0, import_react75.forwardRef)(function TrayWrapper2(props, forwardedRef) {
  let {
    children,
    state,
    isFixedHeight,
    isOpen,
    wrapperRef
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb({
    ...props,
    isDismissable: true
  }, state, domRef);
  let styleProps = useStyleProps(props);
  let viewport = $5df64b3807dc15ee$export$d699905dd57c73ca();
  return (0, import_jsx_runtime15.jsxs)("div", {
    ref: wrapperRef,
    children: [(0, import_jsx_runtime15.jsx)(Blanket, {
      ...underlayProps,
      isOpen
    }), (0, import_jsx_runtime15.jsx)("div", {
      className: css({
        boxSizing: "border-box",
        display: "flex",
        insetBlockStart: 0,
        insetInlineStart: 0,
        justifyContent: "center",
        pointerEvents: "none",
        position: "fixed",
        height: "100vh",
        width: "100%",
        zIndex: 2
        // above blanket
      }),
      style: {
        height: viewport.height
      },
      children: (0, import_jsx_runtime15.jsx)("div", {
        ...modalProps,
        ...toDataAttributes({
          open: isOpen,
          fillScreen: isFixedHeight || void 0
        }),
        ref: domRef,
        style: Object.assign({}, isFixedHeight ? {
          height: `calc(${viewport.height}px - ${tokenSchema.size.space.xxlarge})`,
          top: tokenSchema.size.space.xxlarge
        } : {}, {
          maxHeight: `calc(${viewport.height}px - ${tokenSchema.size.space.xxlarge})`,
          paddingBottom: `max(calc(100vh - ${viewport.height}px), env(safe-area-inset-bottom))`
        }, styleProps.style),
        className: classNames(styleProps.className, css({
          backgroundColor: tokenSchema.color.background.surface,
          // TODO: component token?
          bottom: 0,
          maxWidth: "100vw",
          opacity: 0,
          outline: 0,
          pointerEvents: "auto",
          position: "absolute",
          transform: "translateY(100%)",
          // initialise with offset
          width: "100%",
          zIndex: 2,
          // above blanket
          // NOTE: trays shouldn't be used for larger screens, but in case
          // they are we need to tweak the appearance.
          [breakpointQueries$1.above.mobile]: {
            borderStartStartRadius: tokenSchema.size.radius.medium,
            // TODO: component token?
            borderStartEndRadius: tokenSchema.size.radius.medium,
            // TODO: component token?
            maxWidth: breakpoints.tablet
          },
          // exit animation
          transition: transition(["opacity", "transform"], {
            easing: "easeIn"
          }),
          '&[data-open="true"]': {
            opacity: 1,
            transform: `translateY(0)`,
            // enter animation
            transition: transition(["opacity", "transform"], {
              easing: "easeOut",
              delay: "short"
            })
          }
        })),
        children
      })
    })]
  });
});

// node_modules/@react-stately/overlays/dist/useOverlayTriggerState.mjs
var import_react76 = __toESM(require_react(), 1);
function $fc909762b330b746$export$61c6a8c84e605fb6(props) {
  let [isOpen, setOpen] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.isOpen, props.defaultOpen || false, props.onOpenChange);
  const open = (0, import_react76.useCallback)(() => {
    setOpen(true);
  }, [
    setOpen
  ]);
  const close = (0, import_react76.useCallback)(() => {
    setOpen(false);
  }, [
    setOpen
  ]);
  const toggle = (0, import_react76.useCallback)(() => {
    setOpen(!isOpen);
  }, [
    setOpen,
    isOpen
  ]);
  return {
    isOpen,
    setOpen,
    open,
    close,
    toggle
  };
}

// node_modules/@react-aria/tooltip/dist/useTooltip.mjs
function $326e436e94273fe1$export$1c4b08e0eca38426(props, state) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    onHoverStart: () => state === null || state === void 0 ? void 0 : state.open(true),
    onHoverEnd: () => state === null || state === void 0 ? void 0 : state.close()
  });
  return {
    tooltipProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, hoverProps, {
      role: "tooltip"
    })
  };
}

// node_modules/@react-aria/tooltip/dist/useTooltipTrigger.mjs
var import_react77 = __toESM(require_react(), 1);
function $4e1b34546679e357$export$a6da6c504e4bba8b(props, state, ref) {
  let { isDisabled, trigger: trigger2 } = props;
  let tooltipId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let isHovered = (0, import_react77.useRef)(false);
  let isFocused = (0, import_react77.useRef)(false);
  let handleShow = () => {
    if (isHovered.current || isFocused.current) state.open(isFocused.current);
  };
  let handleHide = (immediate) => {
    if (!isHovered.current && !isFocused.current) state.close(immediate);
  };
  (0, import_react77.useEffect)(() => {
    let onKeyDown = (e4) => {
      if (ref && ref.current) {
        if (e4.key === "Escape") {
          e4.stopPropagation();
          state.close(true);
        }
      }
    };
    if (state.isOpen) {
      document.addEventListener("keydown", onKeyDown, true);
      return () => {
        document.removeEventListener("keydown", onKeyDown, true);
      };
    }
  }, [
    ref,
    state
  ]);
  let onHoverStart = () => {
    if (trigger2 === "focus") return;
    if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "pointer") isHovered.current = true;
    else isHovered.current = false;
    handleShow();
  };
  let onHoverEnd = () => {
    if (trigger2 === "focus") return;
    isFocused.current = false;
    isHovered.current = false;
    handleHide();
  };
  let onPressStart = () => {
    isFocused.current = false;
    isHovered.current = false;
    handleHide(true);
  };
  let onFocus = () => {
    let isVisible2 = (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)();
    if (isVisible2) {
      isFocused.current = true;
      handleShow();
    }
  };
  let onBlur = () => {
    isFocused.current = false;
    isHovered.current = false;
    handleHide(true);
  };
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled,
    onHoverStart,
    onHoverEnd
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)({
    isDisabled,
    onFocus,
    onBlur
  }, ref);
  return {
    triggerProps: {
      "aria-describedby": state.isOpen ? tooltipId : void 0,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, hoverProps, {
        onPointerDown: onPressStart,
        onKeyDown: onPressStart
      })
    },
    tooltipProps: {
      id: tooltipId
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-tooltip.js
var import_react79 = __toESM(require_react());
var import_jsx_runtime16 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/tooltip/dist/useTooltipTriggerState.mjs
var import_react78 = __toESM(require_react(), 1);
var $8796f90736e175cb$var$TOOLTIP_DELAY = 1500;
var $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;
var $8796f90736e175cb$var$tooltips = {};
var $8796f90736e175cb$var$tooltipId = 0;
var $8796f90736e175cb$var$globalWarmedUp = false;
var $8796f90736e175cb$var$globalWarmUpTimeout = null;
var $8796f90736e175cb$var$globalCooldownTimeout = null;
function $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {
  let { delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;
  let { isOpen, open, close } = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let id2 = (0, import_react78.useMemo)(() => `${++$8796f90736e175cb$var$tooltipId}`, []);
  let closeTimeout = (0, import_react78.useRef)(void 0);
  let closeCallback = (0, import_react78.useRef)(close);
  let ensureTooltipEntry = () => {
    $8796f90736e175cb$var$tooltips[id2] = hideTooltip;
  };
  let closeOpenTooltips = () => {
    for (let hideTooltipId in $8796f90736e175cb$var$tooltips) if (hideTooltipId !== id2) {
      $8796f90736e175cb$var$tooltips[hideTooltipId](true);
      delete $8796f90736e175cb$var$tooltips[hideTooltipId];
    }
  };
  let showTooltip = () => {
    clearTimeout(closeTimeout.current);
    closeTimeout.current = null;
    closeOpenTooltips();
    ensureTooltipEntry();
    $8796f90736e175cb$var$globalWarmedUp = true;
    open();
    if ($8796f90736e175cb$var$globalWarmUpTimeout) {
      clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);
      $8796f90736e175cb$var$globalWarmUpTimeout = null;
    }
    if ($8796f90736e175cb$var$globalCooldownTimeout) {
      clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);
      $8796f90736e175cb$var$globalCooldownTimeout = null;
    }
  };
  let hideTooltip = (immediate) => {
    if (immediate || closeDelay <= 0) {
      clearTimeout(closeTimeout.current);
      closeTimeout.current = null;
      closeCallback.current();
    } else if (!closeTimeout.current) closeTimeout.current = setTimeout(() => {
      closeTimeout.current = null;
      closeCallback.current();
    }, closeDelay);
    if ($8796f90736e175cb$var$globalWarmUpTimeout) {
      clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);
      $8796f90736e175cb$var$globalWarmUpTimeout = null;
    }
    if ($8796f90736e175cb$var$globalWarmedUp) {
      if ($8796f90736e175cb$var$globalCooldownTimeout) clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);
      $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(() => {
        delete $8796f90736e175cb$var$tooltips[id2];
        $8796f90736e175cb$var$globalCooldownTimeout = null;
        $8796f90736e175cb$var$globalWarmedUp = false;
      }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));
    }
  };
  let warmupTooltip = () => {
    closeOpenTooltips();
    ensureTooltipEntry();
    if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp) $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(() => {
      $8796f90736e175cb$var$globalWarmUpTimeout = null;
      $8796f90736e175cb$var$globalWarmedUp = true;
      showTooltip();
    }, delay);
    else if (!isOpen) showTooltip();
  };
  (0, import_react78.useEffect)(() => {
    closeCallback.current = close;
  }, [
    close
  ]);
  (0, import_react78.useEffect)(() => {
    return () => {
      clearTimeout(closeTimeout.current);
      let tooltip = $8796f90736e175cb$var$tooltips[id2];
      if (tooltip) delete $8796f90736e175cb$var$tooltips[id2];
    };
  }, [
    id2
  ]);
  return {
    isOpen,
    open: (immediate) => {
      if (!immediate && delay > 0 && !closeTimeout.current) warmupTooltip();
      else showTooltip();
    },
    close: hideTooltip
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-tooltip.js
var TooltipContext = import_react79.default.createContext({});
var Tooltip = (0, import_react79.forwardRef)(function Tooltip2(props, forwardedRef) {
  var _triggerRef, _state, _tone;
  const $ = c2(61);
  const t0 = (0, import_react79.useContext)(TooltipContext);
  let contextualProps;
  let state;
  let tooltipRef;
  let triggerRef;
  if ($[0] !== t0) {
    const {
      state: t110,
      targetRef: t23,
      overlayRef: t33,
      crossOffset,
      offset,
      ...t42
    } = t0;
    state = t110;
    triggerRef = t23;
    tooltipRef = t33;
    contextualProps = t42;
    $[0] = t0;
    $[1] = contextualProps;
    $[2] = state;
    $[3] = tooltipRef;
    $[4] = triggerRef;
  } else {
    contextualProps = $[1];
    state = $[2];
    tooltipRef = $[3];
    triggerRef = $[4];
  }
  let t1;
  if ($[5] !== props || $[6] !== contextualProps) {
    t1 = $3ef42575df84b30b$export$9d1611c77c2fe928(props, contextualProps);
    $[5] = props;
    $[6] = contextualProps;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  props = t1;
  let otherProps;
  let isOpen;
  let tone;
  if ($[8] !== props) {
    ({
      isOpen,
      tone,
      ...otherProps
    } = props);
    $[8] = props;
    $[9] = otherProps;
    $[10] = isOpen;
    $[11] = tone;
  } else {
    otherProps = $[9];
    isOpen = $[10];
    tone = $[11];
  }
  const targetGapToken = tokenSchema.size.space.regular;
  const {
    tooltipProps
  } = $326e436e94273fe1$export$1c4b08e0eca38426(contextualProps, state);
  const styleProps = useStyleProps(otherProps);
  const ref = (0, import_react79.useRef)(null);
  let t22;
  if ($[12] !== tooltipRef || $[13] !== forwardedRef) {
    t22 = tooltipRef ? $5dc95899b306f630$export$c9058316764c140e(tooltipRef, forwardedRef) : forwardedRef;
    $[12] = tooltipRef;
    $[13] = forwardedRef;
    $[14] = t22;
  } else {
    t22 = $[14];
  }
  const overlayRef = $df56164dff5785e2$export$4338b53315abf666(t22);
  const targetRef = (_triggerRef = triggerRef) !== null && _triggerRef !== void 0 ? _triggerRef : ref;
  let t32;
  let t4;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      icon: {
        size: "small",
        color: "inherit"
      },
      text: {
        size: "small",
        color: "inherit"
      },
      kbd: {
        size: "small",
        color: "inherit"
      }
    };
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  t32 = t4;
  const slots = t32;
  const preferredPlacement = contextualProps.placement || "top";
  const t5 = (_state = state) === null || _state === void 0 ? void 0 : _state.isOpen;
  let t6;
  if ($[16] !== contextualProps || $[17] !== preferredPlacement || $[18] !== t5 || $[19] !== overlayRef || $[20] !== targetRef) {
    t6 = {
      ...contextualProps,
      placement: preferredPlacement,
      isOpen: t5,
      overlayRef,
      targetRef
    };
    $[16] = contextualProps;
    $[17] = preferredPlacement;
    $[18] = t5;
    $[19] = overlayRef;
    $[20] = targetRef;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  const {
    overlayProps,
    arrowProps,
    placement: resolvedPlacement
  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1(t6);
  const t7 = resolvedPlacement || preferredPlacement;
  let placement;
  let t8;
  let t9;
  let t10;
  if ($[22] !== t7 || $[23] !== overlayProps || $[24] !== tooltipProps || $[25] !== otherProps || $[26] !== isOpen || $[27] !== tone) {
    placement = t7.split(" ")[0];
    if ($[32] !== overlayProps || $[33] !== tooltipProps) {
      t8 = $3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, tooltipProps);
      $[32] = overlayProps;
      $[33] = tooltipProps;
      $[34] = t8;
    } else {
      t8 = $[34];
    }
    if ($[35] !== otherProps) {
      t9 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
      $[35] = otherProps;
      $[36] = t9;
    } else {
      t9 = $[36];
    }
    t10 = toDataAttributes({
      placement,
      tone,
      open: isOpen || void 0
    });
    $[22] = t7;
    $[23] = overlayProps;
    $[24] = tooltipProps;
    $[25] = otherProps;
    $[26] = isOpen;
    $[27] = tone;
    $[28] = placement;
    $[29] = t8;
    $[30] = t9;
    $[31] = t10;
  } else {
    placement = $[28];
    t8 = $[29];
    t9 = $[30];
    t10 = $[31];
  }
  let t11;
  if ($[37] !== styleProps.className) {
    t11 = classNames(css({
      backgroundColor: tokenSchema.color.background.inverse,
      color: tokenSchema.color.foreground.inverse,
      borderRadius: tokenSchema.size.radius.small,
      maxWidth: tokenSchema.size.alias.singleLineWidth,
      minHeight: tokenSchema.size.element.small,
      paddingBlock: tokenSchema.size.space.regular,
      paddingInline: tokenSchema.size.space.regular,
      opacity: 0,
      pointerEvents: "none",
      transition: transition(["opacity", "transform"]),
      userSelect: "none",
      '&[data-tone="accent"]': {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      '&[data-tone="critical"]': {
        backgroundColor: tokenSchema.color.background.criticalEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      '&[data-tone="positive"]': {
        backgroundColor: tokenSchema.color.background.positiveEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      '&[data-placement="top"]': {
        marginBottom: targetGapToken,
        transform: `translateY(calc(${targetGapToken} * 0.5))`
      },
      '&[data-placement="bottom"]': {
        marginTop: targetGapToken,
        transform: `translateY(calc(${targetGapToken} * -0.5))`
      },
      '&[data-placement="left"], [dir=ltr] &[data-placement="start"], [dir=rtl] &[data-placement="end"]': {
        marginRight: targetGapToken,
        transform: `translateX(calc(${targetGapToken} * 0.5))`
      },
      '&[data-placement="right"], [dir=ltr] &[data-placement="end"], [dir=rtl] &[data-placement="start"]': {
        marginLeft: targetGapToken,
        transform: `translateX(calc(${targetGapToken} * -0.5))`
      },
      '&[data-open="true"]': {
        opacity: 1,
        transform: `translate(0)`
      }
    }), styleProps.className);
    $[37] = styleProps.className;
    $[38] = t11;
  } else {
    t11 = $[38];
  }
  let t12;
  if ($[39] !== overlayProps.style || $[40] !== tooltipProps.style || $[41] !== styleProps.style) {
    t12 = {
      ...overlayProps.style,
      ...tooltipProps.style,
      ...styleProps.style
    };
    $[39] = overlayProps.style;
    $[40] = tooltipProps.style;
    $[41] = styleProps.style;
    $[42] = t12;
  } else {
    t12 = $[42];
  }
  let t13;
  if ($[43] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = css({
      alignItems: "center",
      boxSizing: "border-box",
      display: "flex",
      gap: tokenSchema.size.space.small
    });
    $[43] = t13;
  } else {
    t13 = $[43];
  }
  let t14;
  if ($[44] !== props.children) {
    t14 = props.children && (isReactText(props.children) ? (0, import_jsx_runtime16.jsx)(Text, {
      children: props.children
    }) : props.children);
    $[44] = props.children;
    $[45] = t14;
  } else {
    t14 = $[45];
  }
  let t15;
  if ($[46] !== t14) {
    t15 = (0, import_jsx_runtime16.jsx)("div", {
      className: t13,
      children: (0, import_jsx_runtime16.jsx)(SlotProvider, {
        slots,
        children: t14
      })
    });
    $[46] = t14;
    $[47] = t15;
  } else {
    t15 = $[47];
  }
  const t16 = toneToFill[(_tone = tone) !== null && _tone !== void 0 ? _tone : "neutral"];
  const t17 = placement;
  let t18;
  if ($[48] !== arrowProps || $[49] !== t16 || $[50] !== t17) {
    t18 = (0, import_jsx_runtime16.jsx)(DirectionIndicator, {
      ...arrowProps,
      fill: t16,
      placement: t17,
      size: "xsmall"
    });
    $[48] = arrowProps;
    $[49] = t16;
    $[50] = t17;
    $[51] = t18;
  } else {
    t18 = $[51];
  }
  let t19;
  if ($[52] !== t8 || $[53] !== t9 || $[54] !== t10 || $[55] !== overlayRef || $[56] !== t11 || $[57] !== t12 || $[58] !== t15 || $[59] !== t18) {
    t19 = (0, import_jsx_runtime16.jsxs)("div", {
      ...t8,
      ...t9,
      ...t10,
      ref: overlayRef,
      className: t11,
      style: t12,
      children: [t15, t18]
    });
    $[52] = t8;
    $[53] = t9;
    $[54] = t10;
    $[55] = overlayRef;
    $[56] = t11;
    $[57] = t12;
    $[58] = t15;
    $[59] = t18;
    $[60] = t19;
  } else {
    t19 = $[60];
  }
  return t19;
});
var toneToFill = {
  accent: "accent",
  critical: "critical",
  neutral: "inverse",
  positive: "positive"
};
var MOUSE_REST_TIMEOUT = 600;
function TooltipTrigger(props) {
  const $ = c2(32);
  let isDisabled;
  let triggerMode;
  let children;
  let otherProps;
  if ($[0] !== props) {
    ({
      children,
      isDisabled,
      trigger: triggerMode,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = triggerMode;
    $[3] = children;
    $[4] = otherProps;
  } else {
    isDisabled = $[1];
    triggerMode = $[2];
    children = $[3];
    otherProps = $[4];
  }
  const targetRef = (0, import_react79.useRef)(null);
  const overlayRef = (0, import_react79.useRef)(null);
  let t0;
  if ($[5] !== isDisabled || $[6] !== triggerMode || $[7] !== props) {
    t0 = {
      isDisabled,
      delay: MOUSE_REST_TIMEOUT,
      trigger: triggerMode,
      ...props
    };
    $[5] = isDisabled;
    $[6] = triggerMode;
    $[7] = props;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  const state = $8796f90736e175cb$export$4d40659c25ecb50b(t0);
  let t1;
  if ($[9] !== isDisabled || $[10] !== triggerMode) {
    t1 = {
      isDisabled,
      trigger: triggerMode
    };
    $[9] = isDisabled;
    $[10] = triggerMode;
    $[11] = t1;
  } else {
    t1 = $[11];
  }
  const {
    triggerProps,
    tooltipProps
  } = $4e1b34546679e357$export$a6da6c504e4bba8b(t1, state, targetRef);
  let t22;
  if ($[12] !== children) {
    t22 = import_react79.default.Children.toArray(children);
    $[12] = children;
    $[13] = t22;
  } else {
    t22 = $[13];
  }
  const [triggerElement, tooltipElement] = t22;
  let t32;
  if ($[14] !== overlayRef || $[15] !== targetRef || $[16] !== state || $[17] !== otherProps || $[18] !== tooltipProps) {
    t32 = {
      overlayRef,
      targetRef,
      state,
      ...otherProps,
      ...tooltipProps
    };
    $[14] = overlayRef;
    $[15] = targetRef;
    $[16] = state;
    $[17] = otherProps;
    $[18] = tooltipProps;
    $[19] = t32;
  } else {
    t32 = $[19];
  }
  let t4;
  if ($[20] !== state.isOpen || $[21] !== overlayRef || $[22] !== tooltipElement) {
    t4 = (0, import_jsx_runtime16.jsx)(Overlay, {
      isOpen: state.isOpen,
      nodeRef: overlayRef,
      children: tooltipElement
    });
    $[20] = state.isOpen;
    $[21] = overlayRef;
    $[22] = tooltipElement;
    $[23] = t4;
  } else {
    t4 = $[23];
  }
  let t5;
  if ($[24] !== t32 || $[25] !== t4) {
    t5 = (0, import_jsx_runtime16.jsx)(TooltipContext.Provider, {
      value: t32,
      children: t4
    });
    $[24] = t32;
    $[25] = t4;
    $[26] = t5;
  } else {
    t5 = $[26];
  }
  let t6;
  if ($[27] !== triggerProps || $[28] !== targetRef || $[29] !== triggerElement || $[30] !== t5) {
    t6 = (0, import_jsx_runtime16.jsxs)($e6afbd83fe6ebbd2$export$13f3202a3e5ddd5, {
      ...triggerProps,
      ref: targetRef,
      children: [triggerElement, t5]
    });
    $[27] = triggerProps;
    $[28] = targetRef;
    $[29] = triggerElement;
    $[30] = t5;
    $[31] = t6;
  } else {
    t6 = $[31];
  }
  return t6;
}
TooltipTrigger.getCollectionNode = function* (props) {
  let childArray = [];
  import_react79.default.Children.forEach(props.children, (child) => {
    if (import_react79.default.isValidElement(child)) {
      childArray.push(child);
    }
  });
  let [trigger2, tooltip] = childArray;
  yield {
    element: trigger2,
    wrapper: (element2) => (0, import_jsx_runtime16.jsxs)(TooltipTrigger, {
      ...props,
      children: [element2, tooltip]
    }, element2.key)
  };
};
var _TooltipTrigger = TooltipTrigger;

// node_modules/@react-aria/dnd/dist/constants.mjs
var $103790afe9474d1c$export$60b7b4bcf3903d8e;
(function(DROP_OPERATION) {
  DROP_OPERATION[DROP_OPERATION["none"] = 0] = "none";
  DROP_OPERATION[DROP_OPERATION["cancel"] = 0] = "cancel";
  DROP_OPERATION[DROP_OPERATION["move"] = 1] = "move";
  DROP_OPERATION[DROP_OPERATION["copy"] = 2] = "copy";
  DROP_OPERATION[DROP_OPERATION["link"] = 4] = "link";
  DROP_OPERATION[DROP_OPERATION["all"] = 7] = "all";
})($103790afe9474d1c$export$60b7b4bcf3903d8e || ($103790afe9474d1c$export$60b7b4bcf3903d8e = {}));
var $103790afe9474d1c$export$9bbdfc78cf083e16 = {
  ...$103790afe9474d1c$export$60b7b4bcf3903d8e,
  copyMove: 3,
  copyLink: 6,
  linkMove: 5,
  all: 7,
  uninitialized: 7
};
var $103790afe9474d1c$export$dd0165308d8bff45 = $103790afe9474d1c$var$invert($103790afe9474d1c$export$9bbdfc78cf083e16);
$103790afe9474d1c$export$dd0165308d8bff45[7] = "all";
var $103790afe9474d1c$export$d7ebf00f36b7a95e = $103790afe9474d1c$var$invert($103790afe9474d1c$export$60b7b4bcf3903d8e);
var $103790afe9474d1c$export$608ecc6f1b23c35d = {
  none: "cancel",
  link: "link",
  copy: "copy",
  move: "move"
};
var $103790afe9474d1c$export$5eacb0769d26d3b2 = $103790afe9474d1c$var$invert($103790afe9474d1c$export$608ecc6f1b23c35d);
function $103790afe9474d1c$var$invert(object3) {
  let res = {};
  for (let key in object3) res[object3[key]] = key;
  return res;
}
var $103790afe9474d1c$export$4a7729b856e9a690 = /* @__PURE__ */ new Set([
  "text/plain",
  "text/uri-list",
  "text/html"
]);
var $103790afe9474d1c$export$fd9f9fc120c5402d = "application/vnd.react-aria.items+json";
var $103790afe9474d1c$export$f8fc6581787339b3 = "application/octet-stream";

// node_modules/@react-aria/dnd/dist/utils.mjs
var $7252cd45fc48c07c$export$dfdf5deeaf27473f = /* @__PURE__ */ new WeakMap();
var $7252cd45fc48c07c$export$990fced5dfac2637 = Symbol();
function $7252cd45fc48c07c$export$3093291712f09a77(state) {
  let { id: id2 } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);
  if (!id2) throw new Error("Droppable item outside a droppable collection");
  return id2;
}
function $7252cd45fc48c07c$export$7e397efd01d3db27(state) {
  let { ref } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);
  if (!ref) throw new Error("Droppable item outside a droppable collection");
  return ref;
}
function $7252cd45fc48c07c$export$e1d41611756c6326(items) {
  let types = /* @__PURE__ */ new Set();
  for (let item of items) for (let type3 of Object.keys(item)) types.add(type3);
  return types;
}
function $7252cd45fc48c07c$var$mapModality(modality) {
  if (!modality) modality = "virtual";
  if (modality === "pointer") modality = "virtual";
  if (modality === "virtual" && typeof window !== "undefined" && "ontouchstart" in window) modality = "touch";
  return modality;
}
function $7252cd45fc48c07c$export$49bac5d6d4b352ea() {
  return $7252cd45fc48c07c$var$mapModality((0, $507fabe10e71c6fb$export$98e20ec92f614cfe)());
}
function $7252cd45fc48c07c$export$1fb2158d224b542c() {
  return $7252cd45fc48c07c$var$mapModality((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)());
}
function $7252cd45fc48c07c$export$f9c1490890ddd063(dataTransfer, items) {
  let groupedByType = /* @__PURE__ */ new Map();
  let needsCustomData = false;
  let customData = [];
  for (let item of items) {
    let types = Object.keys(item);
    if (types.length > 1) needsCustomData = true;
    let dataByType = {};
    for (let type3 of types) {
      let typeItems = groupedByType.get(type3);
      if (!typeItems) {
        typeItems = [];
        groupedByType.set(type3, typeItems);
      } else needsCustomData = true;
      let data = item[type3];
      dataByType[type3] = data;
      typeItems.push(data);
    }
    customData.push(dataByType);
  }
  for (let [type3, items2] of groupedByType) if ((0, $103790afe9474d1c$export$4a7729b856e9a690).has(type3)) {
    let data = items2.join("\n");
    dataTransfer.items.add(data, type3);
  } else
    dataTransfer.items.add(items2[0], type3);
  if (needsCustomData) {
    let data = JSON.stringify(customData);
    dataTransfer.items.add(data, (0, $103790afe9474d1c$export$fd9f9fc120c5402d));
  }
}
var $7252cd45fc48c07c$export$7f04ce188c91447c = class {
  has(type3) {
    if (this.includesUnknownTypes || type3 === $7252cd45fc48c07c$export$990fced5dfac2637 && this.types.has((0, $103790afe9474d1c$export$f8fc6581787339b3))) return true;
    return typeof type3 === "string" && this.types.has(type3);
  }
  constructor(dataTransfer) {
    this.types = /* @__PURE__ */ new Set();
    let hasFiles = false;
    for (let item of dataTransfer.items) if (item.type !== (0, $103790afe9474d1c$export$fd9f9fc120c5402d)) {
      if (item.kind === "file") hasFiles = true;
      if (item.type) this.types.add(item.type);
      else
        this.types.add((0, $103790afe9474d1c$export$f8fc6581787339b3));
    }
    this.includesUnknownTypes = !hasFiles && dataTransfer.types.includes("Files");
  }
};
function $7252cd45fc48c07c$export$d9e760437831f8b3(dataTransfer) {
  let items = [];
  let hasCustomType = false;
  if (dataTransfer.types.includes((0, $103790afe9474d1c$export$fd9f9fc120c5402d))) try {
    let data = dataTransfer.getData((0, $103790afe9474d1c$export$fd9f9fc120c5402d));
    let parsed = JSON.parse(data);
    for (let item of parsed) items.push({
      kind: "text",
      types: new Set(Object.keys(item)),
      getText: (type3) => Promise.resolve(item[type3])
    });
    hasCustomType = true;
  } catch (e4) {
  }
  if (!hasCustomType) {
    let stringItems = /* @__PURE__ */ new Map();
    for (let item of dataTransfer.items) {
      if (item.kind === "string")
        stringItems.set(item.type || (0, $103790afe9474d1c$export$f8fc6581787339b3), dataTransfer.getData(item.type));
      else if (item.kind === "file") {
        if (typeof item.webkitGetAsEntry === "function") {
          let entry = item.webkitGetAsEntry();
          if (!entry) continue;
          if (entry.isFile) items.push($7252cd45fc48c07c$var$createFileItem(item.getAsFile()));
          else if (entry.isDirectory) items.push($7252cd45fc48c07c$var$createDirectoryItem(entry));
        } else
          items.push($7252cd45fc48c07c$var$createFileItem(item.getAsFile()));
      }
    }
    if (stringItems.size > 0) items.push({
      kind: "text",
      types: new Set(stringItems.keys()),
      getText: (type3) => Promise.resolve(stringItems.get(type3))
    });
  }
  return items;
}
function $7252cd45fc48c07c$var$blobToString(blob) {
  if (typeof blob.text === "function") return blob.text();
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onload = () => {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsText(blob);
  });
}
function $7252cd45fc48c07c$var$createFileItem(file) {
  return {
    kind: "file",
    type: file.type || (0, $103790afe9474d1c$export$f8fc6581787339b3),
    name: file.name,
    getText: () => $7252cd45fc48c07c$var$blobToString(file),
    getFile: () => Promise.resolve(file)
  };
}
function $7252cd45fc48c07c$var$createDirectoryItem(entry) {
  return {
    kind: "directory",
    name: entry.name,
    getEntries: () => $7252cd45fc48c07c$var$getEntries(entry)
  };
}
async function* $7252cd45fc48c07c$var$getEntries(item) {
  let reader = item.createReader();
  let entries2;
  do {
    entries2 = await new Promise((resolve, reject) => {
      reader.readEntries(resolve, reject);
    });
    for (let entry of entries2) {
      if (entry.isFile) {
        let file = await $7252cd45fc48c07c$var$getEntryFile(entry);
        yield $7252cd45fc48c07c$var$createFileItem(file);
      } else if (entry.isDirectory) yield $7252cd45fc48c07c$var$createDirectoryItem(entry);
    }
  } while (entries2.length > 0);
}
function $7252cd45fc48c07c$var$getEntryFile(entry) {
  return new Promise((resolve, reject) => entry.file(resolve, reject));
}
var $7252cd45fc48c07c$export$6ca6700462636d0b = {
  draggingKeys: /* @__PURE__ */ new Set()
};
function $7252cd45fc48c07c$export$f2be18a910c0caa6(ref) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.draggingCollectionRef = ref;
}
function $7252cd45fc48c07c$export$72cb63bdda528276(keys3) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.draggingKeys = keys3;
}
function $7252cd45fc48c07c$export$dac8db29d42db9a1(ref) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.dropCollectionRef = ref;
}
function $7252cd45fc48c07c$export$70936501603e6c57() {
  $7252cd45fc48c07c$export$6ca6700462636d0b = {
    draggingKeys: /* @__PURE__ */ new Set()
  };
}
function $7252cd45fc48c07c$export$6c10d32b362bfa5f(state) {
  $7252cd45fc48c07c$export$6ca6700462636d0b = state;
}
function $7252cd45fc48c07c$export$78bf638634500fa5(ref) {
  let { draggingCollectionRef, dropCollectionRef } = $7252cd45fc48c07c$export$6ca6700462636d0b;
  return (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) != null && draggingCollectionRef.current === ((ref === null || ref === void 0 ? void 0 : ref.current) || (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current));
}
var $7252cd45fc48c07c$export$8e6636520ac15722;
function $7252cd45fc48c07c$export$64f52ed7349ddb84(dropEffect) {
  $7252cd45fc48c07c$export$8e6636520ac15722 = dropEffect;
}
var $7252cd45fc48c07c$export$f0130eb70b6347b8 = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
function $7252cd45fc48c07c$export$6539bc8c3a0a2d67(o3) {
  $7252cd45fc48c07c$export$f0130eb70b6347b8 = o3;
}

// node_modules/@react-aria/live-announcer/dist/LiveAnnouncer.mjs
var $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY = 7e3;
var $319e236875307eab$var$liveAnnouncer = null;
function $319e236875307eab$export$a9b970dcc4ae71a9(message, assertiveness = "assertive", timeout2 = $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY) {
  if (!$319e236875307eab$var$liveAnnouncer) {
    $319e236875307eab$var$liveAnnouncer = new $319e236875307eab$var$LiveAnnouncer();
    if (!(typeof IS_REACT_ACT_ENVIRONMENT === "boolean" ? IS_REACT_ACT_ENVIRONMENT : typeof jest !== "undefined")) setTimeout(() => {
      if ($319e236875307eab$var$liveAnnouncer === null || $319e236875307eab$var$liveAnnouncer === void 0 ? void 0 : $319e236875307eab$var$liveAnnouncer.isAttached()) $319e236875307eab$var$liveAnnouncer === null || $319e236875307eab$var$liveAnnouncer === void 0 ? void 0 : $319e236875307eab$var$liveAnnouncer.announce(message, assertiveness, timeout2);
    }, 100);
    else $319e236875307eab$var$liveAnnouncer.announce(message, assertiveness, timeout2);
  } else $319e236875307eab$var$liveAnnouncer.announce(message, assertiveness, timeout2);
}
function $319e236875307eab$export$d10ae4f68404609a(assertiveness) {
  if ($319e236875307eab$var$liveAnnouncer) $319e236875307eab$var$liveAnnouncer.clear(assertiveness);
}
var $319e236875307eab$var$LiveAnnouncer = class {
  isAttached() {
    var _this_node;
    return (_this_node = this.node) === null || _this_node === void 0 ? void 0 : _this_node.isConnected;
  }
  createLog(ariaLive) {
    let node2 = document.createElement("div");
    node2.setAttribute("role", "log");
    node2.setAttribute("aria-live", ariaLive);
    node2.setAttribute("aria-relevant", "additions");
    return node2;
  }
  destroy() {
    if (!this.node) return;
    document.body.removeChild(this.node);
    this.node = null;
  }
  announce(message, assertiveness = "assertive", timeout2 = $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY) {
    var _this_assertiveLog, _this_politeLog;
    if (!this.node) return;
    let node2 = document.createElement("div");
    if (typeof message === "object") {
      node2.setAttribute("role", "img");
      node2.setAttribute("aria-labelledby", message["aria-labelledby"]);
    } else node2.textContent = message;
    if (assertiveness === "assertive") (_this_assertiveLog = this.assertiveLog) === null || _this_assertiveLog === void 0 ? void 0 : _this_assertiveLog.appendChild(node2);
    else (_this_politeLog = this.politeLog) === null || _this_politeLog === void 0 ? void 0 : _this_politeLog.appendChild(node2);
    if (message !== "") setTimeout(() => {
      node2.remove();
    }, timeout2);
  }
  clear(assertiveness) {
    if (!this.node) return;
    if ((!assertiveness || assertiveness === "assertive") && this.assertiveLog) this.assertiveLog.innerHTML = "";
    if ((!assertiveness || assertiveness === "polite") && this.politeLog) this.politeLog.innerHTML = "";
  }
  constructor() {
    this.node = null;
    this.assertiveLog = null;
    this.politeLog = null;
    if (typeof document !== "undefined") {
      this.node = document.createElement("div");
      this.node.dataset.liveAnnouncer = "true";
      Object.assign(this.node.style, {
        border: 0,
        clip: "rect(0 0 0 0)",
        clipPath: "inset(50%)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: 0,
        position: "absolute",
        width: "1px",
        whiteSpace: "nowrap"
      });
      this.assertiveLog = this.createLog("assertive");
      this.node.appendChild(this.assertiveLog);
      this.politeLog = this.createLog("polite");
      this.node.appendChild(this.politeLog);
      document.body.prepend(this.node);
    }
  }
};

// node_modules/@react-aria/dnd/dist/DragManager.mjs
var import_react80 = __toESM(require_react(), 1);
var $67560de7c78cb232$var$dropTargets = /* @__PURE__ */ new Map();
var $67560de7c78cb232$var$dropItems = /* @__PURE__ */ new Map();
var $67560de7c78cb232$var$dragSession = null;
var $67560de7c78cb232$var$subscriptions = /* @__PURE__ */ new Set();
function $67560de7c78cb232$export$c28d9fb4a54e471a(target) {
  $67560de7c78cb232$var$dropTargets.set(target.element, target);
  $67560de7c78cb232$var$dragSession === null || $67560de7c78cb232$var$dragSession === void 0 ? void 0 : $67560de7c78cb232$var$dragSession.updateValidDropTargets();
  return () => {
    $67560de7c78cb232$var$dropTargets.delete(target.element);
    $67560de7c78cb232$var$dragSession === null || $67560de7c78cb232$var$dragSession === void 0 ? void 0 : $67560de7c78cb232$var$dragSession.updateValidDropTargets();
  };
}
function $67560de7c78cb232$export$aef80212ac99c003(item) {
  $67560de7c78cb232$var$dropItems.set(item.element, item);
  return () => {
    $67560de7c78cb232$var$dropItems.delete(item.element);
  };
}
function $67560de7c78cb232$export$549dbcf8649bf3b2(target, stringFormatter) {
  if ($67560de7c78cb232$var$dragSession) throw new Error("Cannot begin dragging while already dragging");
  $67560de7c78cb232$var$dragSession = new $67560de7c78cb232$var$DragSession(target, stringFormatter);
  requestAnimationFrame(() => {
    $67560de7c78cb232$var$dragSession.setup();
    if ((0, $7252cd45fc48c07c$export$1fb2158d224b542c)() === "keyboard") $67560de7c78cb232$var$dragSession.next();
  });
  for (let cb of $67560de7c78cb232$var$subscriptions) cb();
}
function $67560de7c78cb232$export$418e185dd3f1b968() {
  let [session, setSession] = (0, import_react80.useState)($67560de7c78cb232$var$dragSession);
  (0, import_react80.useEffect)(() => {
    let cb = () => setSession($67560de7c78cb232$var$dragSession);
    $67560de7c78cb232$var$subscriptions.add(cb);
    return () => {
      $67560de7c78cb232$var$subscriptions.delete(cb);
    };
  }, []);
  return session;
}
function $67560de7c78cb232$export$403bc76cbf68cf60() {
  return !!$67560de7c78cb232$var$dragSession;
}
function $67560de7c78cb232$var$endDragging() {
  $67560de7c78cb232$var$dragSession = null;
  for (let cb of $67560de7c78cb232$var$subscriptions) cb();
}
var $67560de7c78cb232$var$CANCELED_EVENTS = [
  "pointerdown",
  "pointermove",
  "pointerenter",
  "pointerleave",
  "pointerover",
  "pointerout",
  "pointerup",
  "mousedown",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "mouseup",
  "touchstart",
  "touchmove",
  "touchend",
  "focusin",
  "focusout"
];
var $67560de7c78cb232$var$CLICK_EVENTS = [
  "pointerup",
  "mouseup",
  "touchend"
];
var $67560de7c78cb232$var$MESSAGES = {
  keyboard: "dragStartedKeyboard",
  touch: "dragStartedTouch",
  virtual: "dragStartedVirtual"
};
var $67560de7c78cb232$var$DragSession = class {
  setup() {
    document.addEventListener("keydown", this.onKeyDown, true);
    document.addEventListener("keyup", this.onKeyUp, true);
    window.addEventListener("focus", this.onFocus, true);
    window.addEventListener("blur", this.onBlur, true);
    document.addEventListener("click", this.onClick, true);
    document.addEventListener("pointerdown", this.onPointerDown, true);
    for (let event of $67560de7c78cb232$var$CANCELED_EVENTS) document.addEventListener(event, this.cancelEvent, true);
    this.mutationObserver = new MutationObserver(() => this.updateValidDropTargets());
    this.updateValidDropTargets();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format($67560de7c78cb232$var$MESSAGES[(0, $7252cd45fc48c07c$export$1fb2158d224b542c)()]));
  }
  teardown() {
    document.removeEventListener("keydown", this.onKeyDown, true);
    document.removeEventListener("keyup", this.onKeyUp, true);
    window.removeEventListener("focus", this.onFocus, true);
    window.removeEventListener("blur", this.onBlur, true);
    document.removeEventListener("click", this.onClick, true);
    document.removeEventListener("pointerdown", this.onPointerDown, true);
    for (let event of $67560de7c78cb232$var$CANCELED_EVENTS) document.removeEventListener(event, this.cancelEvent, true);
    this.mutationObserver.disconnect();
    this.restoreAriaHidden();
  }
  onKeyDown(e4) {
    var _this_currentDropTarget;
    this.cancelEvent(e4);
    if (e4.key === "Escape") {
      this.cancel();
      return;
    }
    if (e4.key === "Tab" && !(e4.metaKey || e4.altKey || e4.ctrlKey)) {
      if (e4.shiftKey) this.previous();
      else this.next();
    }
    if (typeof ((_this_currentDropTarget = this.currentDropTarget) === null || _this_currentDropTarget === void 0 ? void 0 : _this_currentDropTarget.onKeyDown) === "function") this.currentDropTarget.onKeyDown(e4, this.dragTarget);
  }
  onKeyUp(e4) {
    this.cancelEvent(e4);
    if (e4.key === "Enter") {
      if (e4.altKey) this.activate();
      else this.drop();
    }
  }
  onFocus(e4) {
    if (e4.target !== this.dragTarget.element) this.cancelEvent(e4);
    if (!(e4.target instanceof HTMLElement) || e4.target === this.dragTarget.element) return;
    let dropTarget = this.validDropTargets.find((target) => target.element === e4.target) || this.validDropTargets.find((target) => target.element.contains(e4.target));
    if (!dropTarget) {
      if (this.currentDropTarget) this.currentDropTarget.element.focus();
      else this.dragTarget.element.focus();
      return;
    }
    let item = $67560de7c78cb232$var$dropItems.get(e4.target);
    this.setCurrentDropTarget(dropTarget, item);
  }
  onBlur(e4) {
    if (e4.target !== this.dragTarget.element) this.cancelEvent(e4);
    if (!e4.relatedTarget || !(e4.relatedTarget instanceof HTMLElement)) {
      if (this.currentDropTarget) this.currentDropTarget.element.focus();
      else this.dragTarget.element.focus();
    }
  }
  onClick(e4) {
    this.cancelEvent(e4);
    if ((0, $6a7db85432448f7f$export$60278871457622de)(e4) || this.isVirtualClick) {
      if (e4.target === this.dragTarget.element) {
        this.cancel();
        return;
      }
      let dropTarget = this.validDropTargets.find((target) => target.element.contains(e4.target));
      if (dropTarget) {
        let item = $67560de7c78cb232$var$dropItems.get(e4.target);
        this.setCurrentDropTarget(dropTarget, item);
        this.drop(item);
      }
    }
  }
  onPointerDown(e4) {
    this.cancelEvent(e4);
    this.isVirtualClick = (0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e4);
  }
  cancelEvent(e4) {
    var _this_dragTarget;
    if ((e4.type === "focusin" || e4.type === "focusout") && e4.target === ((_this_dragTarget = this.dragTarget) === null || _this_dragTarget === void 0 ? void 0 : _this_dragTarget.element)) return;
    if (!$67560de7c78cb232$var$CLICK_EVENTS.includes(e4.type)) e4.preventDefault();
    e4.stopPropagation();
    e4.stopImmediatePropagation();
  }
  updateValidDropTargets() {
    if (!this.mutationObserver) return;
    this.mutationObserver.disconnect();
    if (this.restoreAriaHidden) this.restoreAriaHidden();
    this.validDropTargets = $67560de7c78cb232$var$findValidDropTargets(this.dragTarget);
    if (this.validDropTargets.length > 0) {
      let nearestIndex = this.findNearestDropTarget();
      this.validDropTargets = [
        ...this.validDropTargets.slice(nearestIndex),
        ...this.validDropTargets.slice(0, nearestIndex)
      ];
    }
    if (this.currentDropTarget && !this.validDropTargets.includes(this.currentDropTarget)) this.setCurrentDropTarget(this.validDropTargets[0]);
    let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
    let validDropItems = [
      ...$67560de7c78cb232$var$dropItems.values()
    ].filter((item) => {
      if (typeof item.getDropOperation === "function") return item.getDropOperation(types, this.dragTarget.allowedDropOperations) !== "cancel";
      return true;
    });
    let visibleDropTargets = this.validDropTargets.filter((target) => !validDropItems.some((item) => target.element.contains(item.element)));
    this.restoreAriaHidden = (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
      this.dragTarget.element,
      ...validDropItems.map((item) => item.element),
      ...visibleDropTargets.map((target) => target.element)
    ]);
    this.mutationObserver.observe(document.body, {
      subtree: true,
      attributes: true,
      attributeFilter: [
        "aria-hidden"
      ]
    });
  }
  next() {
    if (!this.currentDropTarget) {
      this.setCurrentDropTarget(this.validDropTargets[0]);
      return;
    }
    let index2 = this.validDropTargets.indexOf(this.currentDropTarget);
    if (index2 < 0) {
      this.setCurrentDropTarget(this.validDropTargets[0]);
      return;
    }
    if (index2 === this.validDropTargets.length - 1) {
      if (!this.dragTarget.element.closest('[aria-hidden="true"]')) {
        this.setCurrentDropTarget(null);
        this.dragTarget.element.focus();
      } else this.setCurrentDropTarget(this.validDropTargets[0]);
    } else this.setCurrentDropTarget(this.validDropTargets[index2 + 1]);
  }
  previous() {
    if (!this.currentDropTarget) {
      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
      return;
    }
    let index2 = this.validDropTargets.indexOf(this.currentDropTarget);
    if (index2 < 0) {
      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
      return;
    }
    if (index2 === 0) {
      if (!this.dragTarget.element.closest('[aria-hidden="true"]')) {
        this.setCurrentDropTarget(null);
        this.dragTarget.element.focus();
      } else this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
    } else this.setCurrentDropTarget(this.validDropTargets[index2 - 1]);
  }
  findNearestDropTarget() {
    let dragTargetRect = this.dragTarget.element.getBoundingClientRect();
    let minDistance = Infinity;
    let nearest = -1;
    for (let i4 = 0; i4 < this.validDropTargets.length; i4++) {
      let dropTarget = this.validDropTargets[i4];
      let rect = dropTarget.element.getBoundingClientRect();
      let dx = rect.left - dragTargetRect.left;
      let dy = rect.top - dragTargetRect.top;
      let dist = dx * dx + dy * dy;
      if (dist < minDistance) {
        minDistance = dist;
        nearest = i4;
      }
    }
    return nearest;
  }
  setCurrentDropTarget(dropTarget, item) {
    if (dropTarget !== this.currentDropTarget) {
      if (this.currentDropTarget && typeof this.currentDropTarget.onDropExit === "function") {
        let rect = this.currentDropTarget.element.getBoundingClientRect();
        this.currentDropTarget.onDropExit({
          type: "dropexit",
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        });
      }
      this.currentDropTarget = dropTarget;
      if (dropTarget) {
        if (typeof dropTarget.onDropEnter === "function") {
          let rect = dropTarget.element.getBoundingClientRect();
          dropTarget.onDropEnter({
            type: "dropenter",
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          }, this.dragTarget);
        }
        if (!item) dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.element.focus();
      }
    }
    if (item !== this.currentDropItem) {
      if (item && typeof this.currentDropTarget.onDropTargetEnter === "function") this.currentDropTarget.onDropTargetEnter(item === null || item === void 0 ? void 0 : item.target);
      item === null || item === void 0 ? void 0 : item.element.focus();
      this.currentDropItem = item;
      if (!this.initialFocused) {
        let label = item === null || item === void 0 ? void 0 : item.element.getAttribute("aria-label");
        if (label) (0, $319e236875307eab$export$a9b970dcc4ae71a9)(label, "polite");
        this.initialFocused = true;
      }
    }
  }
  end() {
    this.teardown();
    $67560de7c78cb232$var$endDragging();
    if (typeof this.dragTarget.onDragEnd === "function") {
      let target = this.currentDropTarget && this.dropOperation !== "cancel" ? this.currentDropTarget : this.dragTarget;
      let rect = target.element.getBoundingClientRect();
      this.dragTarget.onDragEnd({
        type: "dragend",
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2,
        dropOperation: this.dropOperation || "cancel"
      });
    }
    if (this.currentDropTarget && !this.currentDropTarget.preventFocusOnDrop)
      document.activeElement.dispatchEvent(new FocusEvent("focusin", {
        bubbles: true
      }));
    this.setCurrentDropTarget(null);
  }
  cancel() {
    this.setCurrentDropTarget(null);
    this.end();
    if (!this.dragTarget.element.closest('[aria-hidden="true"]')) this.dragTarget.element.focus();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format("dropCanceled"));
  }
  drop(item) {
    if (!this.currentDropTarget) {
      this.cancel();
      return;
    }
    if (typeof (item === null || item === void 0 ? void 0 : item.getDropOperation) === "function") {
      let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
      this.dropOperation = item.getDropOperation(types, this.dragTarget.allowedDropOperations);
    } else if (typeof this.currentDropTarget.getDropOperation === "function") {
      let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
      this.dropOperation = this.currentDropTarget.getDropOperation(types, this.dragTarget.allowedDropOperations);
    } else
      this.dropOperation = this.dragTarget.allowedDropOperations[0];
    if (typeof this.currentDropTarget.onDrop === "function") {
      let items = this.dragTarget.items.map((item2) => ({
        kind: "text",
        types: new Set(Object.keys(item2)),
        getText: (type3) => Promise.resolve(item2[type3])
      }));
      let rect = this.currentDropTarget.element.getBoundingClientRect();
      this.currentDropTarget.onDrop({
        type: "drop",
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2,
        items,
        dropOperation: this.dropOperation
      }, item === null || item === void 0 ? void 0 : item.target);
    }
    this.end();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format("dropComplete"));
  }
  activate() {
    if (this.currentDropTarget && typeof this.currentDropTarget.onDropActivate === "function") {
      let rect = this.currentDropTarget.element.getBoundingClientRect();
      this.currentDropTarget.onDropActivate({
        type: "dropactivate",
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      });
    }
  }
  constructor(target, stringFormatter) {
    this.dragTarget = target;
    this.stringFormatter = stringFormatter;
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.onClick = this.onClick.bind(this);
    this.onPointerDown = this.onPointerDown.bind(this);
    this.cancelEvent = this.cancelEvent.bind(this);
    this.initialFocused = false;
  }
};
function $67560de7c78cb232$var$findValidDropTargets(options) {
  let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(options.items);
  return [
    ...$67560de7c78cb232$var$dropTargets.values()
  ].filter((target) => {
    if (target.element.closest('[aria-hidden="true"]')) return false;
    if (typeof target.getDropOperation === "function") return target.getDropOperation(types, options.allowedDropOperations) !== "cancel";
    return true;
  });
}

// node_modules/@react-aria/dnd/dist/ar-AE.mjs
var $7dfcac1a0c98c789$exports = {};
$7dfcac1a0c98c789$exports = {
  "dragDescriptionKeyboard": `اضغط Enter لبدء السحب.`,
  "dragDescriptionKeyboardAlt": `اضغط على Alt + Enter لبدء السحب.`,
  "dragDescriptionLongPress": `اضغط باستمرار لبدء السحب.`,
  "dragDescriptionTouch": `اضغط مرتين لبدء السحب.`,
  "dragDescriptionVirtual": `انقر لبدء السحب.`,
  "dragItem": (args2) => `اسحب ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `اسحب ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} عنصر محدد`,
    other: () => `${formatter.number(args2.count)} عناصر محددة`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `اضغط على Enter للسحب ${formatter.plural(args2.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `اضغط على مفتاحي Alt + Enter للسحب ${formatter.plural(args2.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `اضغط باستمرار للسحب ${formatter.plural(args2.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragStartedKeyboard": `بدأ السحب. اضغط Tab للانتقال إلى موضع الإفلات، ثم اضغط Enter للإفلات، أو اضغط Escape للإلغاء.`,
  "dragStartedTouch": `بدأ السحب. انتقل إلى موضع الإفلات، ثم اضغط مرتين للإفلات.`,
  "dragStartedVirtual": `بدأ السحب. انتقل إلى مكان الإفلات، ثم انقر أو اضغط Enter للإفلات.`,
  "dropCanceled": `تم إلغاء الإفلات.`,
  "dropComplete": `اكتمل الإفلات.`,
  "dropDescriptionKeyboard": `اضغط Enter للإفلات. اضغط Escape لإلغاء السحب.`,
  "dropDescriptionTouch": `اضغط مرتين للإفلات.`,
  "dropDescriptionVirtual": `انقر للإفلات.`,
  "dropIndicator": `مؤشر الإفلات`,
  "dropOnItem": (args2) => `إفلات ${args2.itemText}`,
  "dropOnRoot": `الإفلات`,
  "endDragKeyboard": `السحب. اضغط Enter لإلغاء السحب.`,
  "endDragTouch": `السحب. اضغط مرتين لإلغاء السحب.`,
  "endDragVirtual": `السحب. انقر لإلغاء السحب.`,
  "insertAfter": (args2) => `أدخل بعد ${args2.itemText}`,
  "insertBefore": (args2) => `أدخل قبل ${args2.itemText}`,
  "insertBetween": (args2) => `أدخل بين ${args2.beforeItemText} و ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/bg-BG.mjs
var $f311c26671219eca$exports = {};
$f311c26671219eca$exports = {
  "dragDescriptionKeyboard": `Натиснете „Enter“, за да започнете да плъзгате.`,
  "dragDescriptionKeyboardAlt": `Натиснете Alt + Enter, за да започнете да плъзгате.`,
  "dragDescriptionLongPress": `Натиснете продължително, за да започнете да плъзгате.`,
  "dragDescriptionTouch": `Натиснете двукратно, за да започнете да плъзгате.`,
  "dragDescriptionVirtual": `Щракнете, за да започнете да плъзгате.`,
  "dragItem": (args2) => `Плъзни ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Плъзни ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елемента`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Натиснете Enter, за да плъзнете ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елементи`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Натиснете Alt и Enter, за да плъзнете ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елементи`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Натиснете продължително, за да плъзнете ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} избран елемент`,
    other: () => `${formatter.number(args2.count)} избрани елементи`
  })}.`,
  "dragStartedKeyboard": `Започна плъзгане. Натиснете „Tab“, за да се придвижите до целта, след което натиснете „Enter“ за пускане или натиснете „Escape“ за отмяна.`,
  "dragStartedTouch": `Започна плъзгане. Придвижете се до целта, след което натиснете двукратно, за да пуснете.`,
  "dragStartedVirtual": `Започна плъзгане. Придвижете се до целта, след което щракнете или натиснете „Enter“ за пускане.`,
  "dropCanceled": `Пускането е отменено.`,
  "dropComplete": `Пускането е завършено.`,
  "dropDescriptionKeyboard": `Натиснете „Enter“ за пускане. Натиснете „Escape“ за отмяна на плъзгането.`,
  "dropDescriptionTouch": `Натиснете двукратно за пускане.`,
  "dropDescriptionVirtual": `Щракнете за пускане.`,
  "dropIndicator": `индикатор за пускане`,
  "dropOnItem": (args2) => `Пусни върху ${args2.itemText}`,
  "dropOnRoot": `Пусни върху`,
  "endDragKeyboard": `Плъзгане. Натиснете „Enter“ за отмяна на плъзгането.`,
  "endDragTouch": `Плъзгане. Натиснете двукратно за отмяна на плъзгането.`,
  "endDragVirtual": `Плъзгане. Щракнете за отмяна.`,
  "insertAfter": (args2) => `Вмъкни след ${args2.itemText}`,
  "insertBefore": (args2) => `Вмъкни преди ${args2.itemText}`,
  "insertBetween": (args2) => `Вмъкни между ${args2.beforeItemText} и ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/cs-CZ.mjs
var $1aa4ade186550f72$exports = {};
$1aa4ade186550f72$exports = {
  "dragDescriptionKeyboard": `Stisknutím klávesy Enter začnete s přetahováním.`,
  "dragDescriptionKeyboardAlt": `Stisknutím Alt + Enter zahájíte přetahování.`,
  "dragDescriptionLongPress": `Dlouhým stisknutím zahájíte přetahování.`,
  "dragDescriptionTouch": `Poklepáním začnete s přetahováním.`,
  "dragDescriptionVirtual": `Kliknutím začnete s přetahováním.`,
  "dragItem": (args2) => `Přetáhnout ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Přetáhnout ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybranou položku`,
    few: () => `${formatter.number(args2.count)} vybrané položky`,
    other: () => `${formatter.number(args2.count)} vybraných položek`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Stisknutím klávesy Enter přetáhněte ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybranou položku`,
    other: () => `${formatter.number(args2.count)} vybrané položky`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Stisknutím Alt + Enter přetáhněte ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybranou položku`,
    other: () => `${formatter.number(args2.count)} vybrané položky`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Dlouhým stisknutím přetáhnete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybranou položku`,
    other: () => `${formatter.number(args2.count)} vybrané položky`
  })}.`,
  "dragStartedKeyboard": `Začněte s přetahováním. Po stisknutí klávesy Tab najděte požadovaný cíl a stisknutím klávesy Enter přetažení dokončete nebo stisknutím klávesy Esc akci zrušte.`,
  "dragStartedTouch": `Začněte s přetahováním. Najděte požadovaný cíl a poklepáním přetažení dokončete.`,
  "dragStartedVirtual": `Začněte s přetahováním. Najděte požadovaný cíl a kliknutím nebo stisknutím klávesy Enter přetažení dokončete.`,
  "dropCanceled": `Přetažení bylo zrušeno.`,
  "dropComplete": `Přetažení bylo dokončeno.`,
  "dropDescriptionKeyboard": `Stisknutím klávesy Enter přetažení dokončete nebo stisknutím klávesy Esc akci zrušte.`,
  "dropDescriptionTouch": `Poklepáním přetažení dokončete.`,
  "dropDescriptionVirtual": `Kliknutím objekt přetáhněte.`,
  "dropIndicator": `indikátor přetažení`,
  "dropOnItem": (args2) => `Přetáhnout na ${args2.itemText}`,
  "dropOnRoot": `Přetáhnout na`,
  "endDragKeyboard": `Probíhá přetahování. Stisknutím klávesy Enter přetažení zrušíte.`,
  "endDragTouch": `Probíhá přetahování. Poklepáním přetažení zrušíte.`,
  "endDragVirtual": `Probíhá přetahování. Kliknutím přetažení zrušíte.`,
  "insertAfter": (args2) => `Vložit za ${args2.itemText}`,
  "insertBefore": (args2) => `Vložit před ${args2.itemText}`,
  "insertBetween": (args2) => `Vložit mezi ${args2.beforeItemText} a ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/da-DK.mjs
var $b6b0ea1b94a7633c$exports = {};
$b6b0ea1b94a7633c$exports = {
  "dragDescriptionKeyboard": `Tryk på Enter for at starte med at trække.`,
  "dragDescriptionKeyboardAlt": `Tryk på Alt + Enter for at starte med at trække.`,
  "dragDescriptionLongPress": `Tryk længe for at starte med at trække.`,
  "dragDescriptionTouch": `Dobbelttryk for at starte med at trække.`,
  "dragDescriptionVirtual": `Klik for at starte med at trække.`,
  "dragItem": (args2) => `Træk ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Træk ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgt element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Tryk på Enter for at trække ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgte element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Tryk på Alt + Enter for at trække ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgte element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Tryk længe for at trække ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgte element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragStartedKeyboard": `Startet med at trække. Tryk på Tab for at gå til et slip-mål, tryk derefter på Enter for at slippe, eller tryk på Escape for at annullere.`,
  "dragStartedTouch": `Startet med at trække. Gå til et slip-mål, og dobbelttryk derefter for at slippe.`,
  "dragStartedVirtual": `Startet med at trække. Gå til et slip-mål, og klik eller tryk derefter på enter for at slippe.`,
  "dropCanceled": `Slip annulleret.`,
  "dropComplete": `Slip fuldført.`,
  "dropDescriptionKeyboard": `Tryk på Enter for at slippe. Tryk på Escape for at annullere trækning.`,
  "dropDescriptionTouch": `Dobbelttryk for at slippe.`,
  "dropDescriptionVirtual": `Klik for at slippe.`,
  "dropIndicator": `slip-indikator`,
  "dropOnItem": (args2) => `Slip på ${args2.itemText}`,
  "dropOnRoot": `Slip på`,
  "endDragKeyboard": `Trækning. Tryk på enter for at annullere træk.`,
  "endDragTouch": `Trækning. Dobbelttryk for at annullere træk.`,
  "endDragVirtual": `Trækning. Klik for at annullere trækning.`,
  "insertAfter": (args2) => `Indsæt efter ${args2.itemText}`,
  "insertBefore": (args2) => `Indsæt før ${args2.itemText}`,
  "insertBetween": (args2) => `Indsæt mellem ${args2.beforeItemText} og ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/de-DE.mjs
var $d10e4f47c744ad52$exports = {};
$d10e4f47c744ad52$exports = {
  "dragDescriptionKeyboard": `Drücken Sie die Eingabetaste, um den Ziehvorgang zu starten.`,
  "dragDescriptionKeyboardAlt": `Alt + Eingabe drücken, um den Ziehvorgang zu starten.`,
  "dragDescriptionLongPress": `Lang drücken, um mit dem Ziehen zu beginnen.`,
  "dragDescriptionTouch": `Tippen Sie doppelt, um den Ziehvorgang zu starten.`,
  "dragDescriptionVirtual": `Zum Starten des Ziehvorgangs klicken.`,
  "dragItem": (args2) => `${args2.itemText} ziehen`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ausgewähltes Objekt`,
    other: () => `${formatter.number(args2.count)} ausgewählte Objekte`
  })} ziehen`,
  "dragSelectedKeyboard": (args2, formatter) => `Eingabetaste drücken, um ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args2.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Alt + Eingabetaste drücken, um ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args2.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragSelectedLongPress": (args2, formatter) => `Lang drücken, um ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args2.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragStartedKeyboard": `Ziehvorgang gestartet. Drücken Sie die Tabulatortaste, um zu einem Ablegeziel zu navigieren und drücken Sie dann die Eingabetaste, um das Objekt abzulegen, oder Escape, um den Vorgang abzubrechen.`,
  "dragStartedTouch": `Ziehvorgang gestartet. Navigieren Sie zu einem Ablegeziel und tippen Sie doppelt, um das Objekt abzulegen.`,
  "dragStartedVirtual": `Ziehvorgang gestartet. Navigieren Sie zu einem Ablegeziel und klicken Sie oder drücken Sie die Eingabetaste, um das Objekt abzulegen.`,
  "dropCanceled": `Ablegen abgebrochen.`,
  "dropComplete": `Ablegen abgeschlossen.`,
  "dropDescriptionKeyboard": `Drücken Sie die Eingabetaste, um das Objekt abzulegen. Drücken Sie Escape, um den Vorgang abzubrechen.`,
  "dropDescriptionTouch": `Tippen Sie doppelt, um das Objekt abzulegen.`,
  "dropDescriptionVirtual": `Zum Ablegen klicken.`,
  "dropIndicator": `Ablegeanzeiger`,
  "dropOnItem": (args2) => `Auf ${args2.itemText} ablegen`,
  "dropOnRoot": `Ablegen auf`,
  "endDragKeyboard": `Ziehvorgang läuft. Drücken Sie die Eingabetaste, um den Vorgang abzubrechen.`,
  "endDragTouch": `Ziehvorgang läuft. Tippen Sie doppelt, um den Vorgang abzubrechen.`,
  "endDragVirtual": `Ziehvorgang läuft. Klicken Sie, um den Vorgang abzubrechen.`,
  "insertAfter": (args2) => `Nach ${args2.itemText} einfügen`,
  "insertBefore": (args2) => `Vor ${args2.itemText} einfügen`,
  "insertBetween": (args2) => `Zwischen ${args2.beforeItemText} und ${args2.afterItemText} einfügen`
};

// node_modules/@react-aria/dnd/dist/el-GR.mjs
var $b3d2bb9abce688ab$exports = {};
$b3d2bb9abce688ab$exports = {
  "dragDescriptionKeyboard": `Πατήστε Enter για έναρξη της μεταφοράς.`,
  "dragDescriptionKeyboardAlt": `Πατήστε Alt + Enter για έναρξη της μεταφοράς.`,
  "dragDescriptionLongPress": `Πατήστε παρατεταμένα για να ξεκινήσετε τη μεταφορά.`,
  "dragDescriptionTouch": `Πατήστε δύο φορές για έναρξη της μεταφοράς.`,
  "dragDescriptionVirtual": `Κάντε κλικ για να ξεκινήσετε τη μεταφορά.`,
  "dragItem": (args2) => `Μεταφορά ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Μεταφορά σε ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args2.count)} επιλεγμένα στοιχεία`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Πατήστε Enter για να σύρετε ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args2.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Πατήστε Alt + Enter για να σύρετε ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args2.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Πατήστε παρατεταμένα για να σύρετε ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args2.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragStartedKeyboard": `Η μεταφορά ξεκίνησε. Πατήστε το πλήκτρο Tab για να μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, πατήστε Enter για απόθεση ή πατήστε Escape για ακύρωση.`,
  "dragStartedTouch": `Η μεταφορά ξεκίνησε. Μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, πατήστε δύο φορές για απόθεση.`,
  "dragStartedVirtual": `Η μεταφορά ξεκίνησε. Μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, κάντε κλικ ή πατήστε Enter για απόθεση.`,
  "dropCanceled": `Η απόθεση ακυρώθηκε.`,
  "dropComplete": `Η απόθεση ολοκληρώθηκε.`,
  "dropDescriptionKeyboard": `Πατήστε Enter για απόθεση. Πατήστε Escape για ακύρωση της μεταφοράς.`,
  "dropDescriptionTouch": `Πατήστε δύο φορές για απόθεση.`,
  "dropDescriptionVirtual": `Κάντε κλικ για απόθεση.`,
  "dropIndicator": `δείκτης απόθεσης`,
  "dropOnItem": (args2) => `Απόθεση σε ${args2.itemText}`,
  "dropOnRoot": `Απόθεση σε`,
  "endDragKeyboard": `Μεταφορά σε εξέλιξη. Πατήστε Enter για ακύρωση της μεταφοράς.`,
  "endDragTouch": `Μεταφορά σε εξέλιξη. Πατήστε δύο φορές για ακύρωση της μεταφοράς.`,
  "endDragVirtual": `Μεταφορά σε εξέλιξη. Κάντε κλικ για ακύρωση της μεταφοράς.`,
  "insertAfter": (args2) => `Εισαγωγή μετά από ${args2.itemText}`,
  "insertBefore": (args2) => `Εισαγωγή πριν από ${args2.itemText}`,
  "insertBetween": (args2) => `Εισαγωγή μεταξύ ${args2.beforeItemText} και ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/en-US.mjs
var $f9b46437e610cca1$exports = {};
$f9b46437e610cca1$exports = {
  "dragItem": (args2) => `Drag ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Drag ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} selected item`,
    other: () => `${formatter.number(args2.count)} selected items`
  })}`,
  "dragDescriptionKeyboard": `Press Enter to start dragging.`,
  "dragDescriptionKeyboardAlt": `Press Alt + Enter to start dragging.`,
  "dragDescriptionTouch": `Double tap to start dragging.`,
  "dragDescriptionVirtual": `Click to start dragging.`,
  "dragDescriptionLongPress": `Long press to start dragging.`,
  "dragSelectedKeyboard": (args2, formatter) => `Press Enter to drag ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} selected item`,
    other: () => `${formatter.number(args2.count)} selected items`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Press Alt + Enter to drag ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} selected item`,
    other: () => `${formatter.number(args2.count)} selected items`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Long press to drag ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} selected item`,
    other: () => `${formatter.number(args2.count)} selected items`
  })}.`,
  "dragStartedKeyboard": `Started dragging. Press Tab to navigate to a drop target, then press Enter to drop, or press Escape to cancel.`,
  "dragStartedTouch": `Started dragging. Navigate to a drop target, then double tap to drop.`,
  "dragStartedVirtual": `Started dragging. Navigate to a drop target, then click or press Enter to drop.`,
  "endDragKeyboard": `Dragging. Press Enter to cancel drag.`,
  "endDragTouch": `Dragging. Double tap to cancel drag.`,
  "endDragVirtual": `Dragging. Click to cancel drag.`,
  "dropDescriptionKeyboard": `Press Enter to drop. Press Escape to cancel drag.`,
  "dropDescriptionTouch": `Double tap to drop.`,
  "dropDescriptionVirtual": `Click to drop.`,
  "dropCanceled": `Drop canceled.`,
  "dropComplete": `Drop complete.`,
  "dropIndicator": `drop indicator`,
  "dropOnRoot": `Drop on`,
  "dropOnItem": (args2) => `Drop on ${args2.itemText}`,
  "insertBefore": (args2) => `Insert before ${args2.itemText}`,
  "insertBetween": (args2) => `Insert between ${args2.beforeItemText} and ${args2.afterItemText}`,
  "insertAfter": (args2) => `Insert after ${args2.itemText}`
};

// node_modules/@react-aria/dnd/dist/es-ES.mjs
var $204b5c01bd3acf26$exports = {};
$204b5c01bd3acf26$exports = {
  "dragDescriptionKeyboard": `Pulse Intro para empezar a arrastrar.`,
  "dragDescriptionKeyboardAlt": `Pulse Intro para empezar a arrastrar.`,
  "dragDescriptionLongPress": `Mantenga pulsado para comenzar a arrastrar.`,
  "dragDescriptionTouch": `Pulse dos veces para iniciar el arrastre.`,
  "dragDescriptionVirtual": `Haga clic para iniciar el arrastre.`,
  "dragItem": (args2) => `Arrastrar ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Arrastrar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pulse Intro para arrastrar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pulse Alt + Intro para arrastrar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Mantenga pulsado para arrastrar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento seleccionado`,
    other: () => `${formatter.number(args2.count)} elementos seleccionados`
  })}.`,
  "dragStartedKeyboard": `Se ha empezado a arrastrar. Pulse el tabulador para ir al público destinatario donde se vaya a colocar y, a continuación, pulse Intro para soltar, o pulse Escape para cancelar.`,
  "dragStartedTouch": `Se ha empezado a arrastrar. Vaya al público destinatario donde se vaya a colocar y, a continuación, pulse dos veces para soltar.`,
  "dragStartedVirtual": `Se ha empezado a arrastrar. Vaya al público destinatario donde se vaya a colocar y, a continuación, haga clic o pulse Intro para soltar.`,
  "dropCanceled": `Se ha cancelado la colocación.`,
  "dropComplete": `Colocación finalizada.`,
  "dropDescriptionKeyboard": `Pulse Intro para soltar. Pulse Escape para cancelar el arrastre.`,
  "dropDescriptionTouch": `Pulse dos veces para soltar.`,
  "dropDescriptionVirtual": `Haga clic para soltar.`,
  "dropIndicator": `indicador de colocación`,
  "dropOnItem": (args2) => `Soltar en ${args2.itemText}`,
  "dropOnRoot": `Soltar en`,
  "endDragKeyboard": `Arrastrando. Pulse Intro para cancelar el arrastre.`,
  "endDragTouch": `Arrastrando. Pulse dos veces para cancelar el arrastre.`,
  "endDragVirtual": `Arrastrando. Haga clic para cancelar el arrastre.`,
  "insertAfter": (args2) => `Insertar después de ${args2.itemText}`,
  "insertBefore": (args2) => `Insertar antes de ${args2.itemText}`,
  "insertBetween": (args2) => `Insertar entre ${args2.beforeItemText} y ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/et-EE.mjs
var $110bdd83348ecbc0$exports = {};
$110bdd83348ecbc0$exports = {
  "dragDescriptionKeyboard": `Lohistamise alustamiseks vajutage klahvi Enter.`,
  "dragDescriptionKeyboardAlt": `Lohistamise alustamiseks vajutage klahvikombinatsiooni Alt + Enter.`,
  "dragDescriptionLongPress": `Vajutage pikalt lohistamise alustamiseks.`,
  "dragDescriptionTouch": `Topeltpuudutage lohistamise alustamiseks.`,
  "dragDescriptionVirtual": `Klõpsake lohistamise alustamiseks.`,
  "dragItem": (args2) => `Lohista ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Lohista ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valitud üksust`,
    other: () => `${formatter.number(args2.count)} valitud üksust`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valitud üksuse`,
    other: () => `${formatter.number(args2.count)} valitud üksuse`
  })} lohistamiseks vajutage sisestusklahvi Enter.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Lohistamiseks vajutage klahvikombinatsiooni Alt + Enter ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valitud üksuse`,
    other: () => `${formatter.number(args2.count)} valitud üksuse`
  })} jaoks.`,
  "dragSelectedLongPress": (args2, formatter) => `Pikk vajutus ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valitud üksuse`,
    other: () => `${formatter.number(args2.count)} valitud üksuse`
  })} lohistamiseks.`,
  "dragStartedKeyboard": `Alustati lohistamist. Kukutamise sihtmärgi juurde navigeerimiseks vajutage klahvi Tab, seejärel vajutage kukutamiseks klahvi Enter või loobumiseks klahvi Escape.`,
  "dragStartedTouch": `Alustati lohistamist. Navigeerige kukutamise sihtmärgi juurde ja topeltpuudutage kukutamiseks.`,
  "dragStartedVirtual": `Alustati lohistamist. Navigeerige kukutamise sihtmärgi juurde ja kukutamiseks klõpsake või vajutage klahvi Enter.`,
  "dropCanceled": `Lohistamisest loobuti.`,
  "dropComplete": `Lohistamine on tehtud.`,
  "dropDescriptionKeyboard": `Kukutamiseks vajutage klahvi Enter. Lohistamisest loobumiseks vajutage klahvi Escape.`,
  "dropDescriptionTouch": `Kukutamiseks topeltpuudutage.`,
  "dropDescriptionVirtual": `Kukutamiseks klõpsake.`,
  "dropIndicator": `lohistamise indikaator`,
  "dropOnItem": (args2) => `Kukuta asukohta ${args2.itemText}`,
  "dropOnRoot": `Kukuta asukohta`,
  "endDragKeyboard": `Lohistamine. Lohistamisest loobumiseks vajutage klahvi Enter.`,
  "endDragTouch": `Lohistamine. Lohistamisest loobumiseks topeltpuudutage.`,
  "endDragVirtual": `Lohistamine. Lohistamisest loobumiseks klõpsake.`,
  "insertAfter": (args2) => `Sisesta ${args2.itemText} järele`,
  "insertBefore": (args2) => `Sisesta ${args2.itemText} ette`,
  "insertBetween": (args2) => `Sisesta ${args2.beforeItemText} ja ${args2.afterItemText} vahele`
};

// node_modules/@react-aria/dnd/dist/fi-FI.mjs
var $87d3ccd5e347c7cc$exports = {};
$87d3ccd5e347c7cc$exports = {
  "dragDescriptionKeyboard": `Aloita vetäminen painamalla Enter-näppäintä.`,
  "dragDescriptionKeyboardAlt": `Aloita vetäminen painamalla Alt + Enter -näppäinyhdistelmää.`,
  "dragDescriptionLongPress": `Aloita vetäminen pitämällä painettuna.`,
  "dragDescriptionTouch": `Aloita vetäminen kaksoisnapauttamalla.`,
  "dragDescriptionVirtual": `Aloita vetäminen napsauttamalla.`,
  "dragItem": (args2) => `Vedä kohdetta ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Vedä ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valittua kohdetta`,
    other: () => `${formatter.number(args2.count)} valittua kohdetta`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Vedä painamalla Enter ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valittu kohde`,
    other: () => `${formatter.number(args2.count)} valittua kohdetta`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Vedä painamalla Alt + Enter ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valittu kohde`,
    other: () => `${formatter.number(args2.count)} valittua kohdetta`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Vedä pitämällä painettuna ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valittu kohde`,
    other: () => `${formatter.number(args2.count)} valittua kohdetta`
  })}.`,
  "dragStartedKeyboard": `Vetäminen aloitettu. Siirry pudotuskohteeseen painamalla sarkainnäppäintä ja sitten pudota painamalla Enter-näppäintä tai peruuta painamalla Escape-näppäintä.`,
  "dragStartedTouch": `Vetäminen aloitettu. Siirry pudotuskohteeseen ja pudota kaksoisnapauttamalla.`,
  "dragStartedVirtual": `Vetäminen aloitettu. Siirry pudotuskohteeseen ja pudota napsauttamalla tai painamalla Enter-näppäintä.`,
  "dropCanceled": `Pudotus peruutettu.`,
  "dropComplete": `Pudotus suoritettu.`,
  "dropDescriptionKeyboard": `Pudota painamalla Enter-näppäintä. Peruuta vetäminen painamalla Escape-näppäintä.`,
  "dropDescriptionTouch": `Pudota kaksoisnapauttamalla.`,
  "dropDescriptionVirtual": `Pudota napsauttamalla.`,
  "dropIndicator": `pudotuksen ilmaisin`,
  "dropOnItem": (args2) => `Pudota kohteeseen ${args2.itemText}`,
  "dropOnRoot": `Pudota kohteeseen`,
  "endDragKeyboard": `Vedetään. Peruuta vetäminen painamalla Enter-näppäintä.`,
  "endDragTouch": `Vedetään. Peruuta vetäminen kaksoisnapauttamalla.`,
  "endDragVirtual": `Vedetään. Peruuta vetäminen napsauttamalla.`,
  "insertAfter": (args2) => `Lisää kohteen ${args2.itemText} jälkeen`,
  "insertBefore": (args2) => `Lisää ennen kohdetta ${args2.itemText}`,
  "insertBetween": (args2) => `Lisää kohteiden ${args2.beforeItemText} ja ${args2.afterItemText} väliin`
};

// node_modules/@react-aria/dnd/dist/fr-FR.mjs
var $a5de891427686596$exports = {};
$a5de891427686596$exports = {
  "dragDescriptionKeyboard": `Appuyez sur Entrée pour commencer le déplacement.`,
  "dragDescriptionKeyboardAlt": `Appuyez sur Alt + Entrée pour commencer à faire glisser.`,
  "dragDescriptionLongPress": `Appuyez de manière prolongée pour commencer à faire glisser.`,
  "dragDescriptionTouch": `Touchez deux fois pour commencer le déplacement.`,
  "dragDescriptionVirtual": `Cliquez pour commencer le déplacement.`,
  "dragItem": (args2) => `Déplacer ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Déplacer ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Appuyez sur Entrée pour faire glisser ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Appuyez sur Alt + Entrée pour faire glisser ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Appuyez de manière prolongée pour faire glisser ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} élément sélectionné`,
    other: () => `${formatter.number(args2.count)} éléments sélectionnés`
  })}.`,
  "dragStartedKeyboard": `Déplacement commencé. Appuyez sur Tabulation pour accéder à une cible de dépôt, puis appuyez sur Entrée pour déposer, ou appuyez sur Échap pour annuler.`,
  "dragStartedTouch": `Déplacement commencé. Accédez à une cible de dépôt, puis touchez deux fois pour déposer.`,
  "dragStartedVirtual": `Déplacement commencé. Accédez à une cible de dépôt, puis cliquez ou appuyez sur Entrée pour déposer.`,
  "dropCanceled": `Dépôt annulé.`,
  "dropComplete": `Dépôt terminé.`,
  "dropDescriptionKeyboard": `Appuyez sur Entrée pour déposer. Appuyez sur Échap pour annuler le déplacement.`,
  "dropDescriptionTouch": `Touchez deux fois pour déposer.`,
  "dropDescriptionVirtual": `Cliquez pour déposer.`,
  "dropIndicator": `indicateur de dépôt`,
  "dropOnItem": (args2) => `Déposer sur ${args2.itemText}`,
  "dropOnRoot": `Déposer sur`,
  "endDragKeyboard": `Déplacement. Appuyez sur Entrée pour annuler le déplacement.`,
  "endDragTouch": `Déplacement. Touchez deux fois pour annuler le déplacement.`,
  "endDragVirtual": `Déplacement. Cliquez pour annuler le déplacement.`,
  "insertAfter": (args2) => `Insérer après ${args2.itemText}`,
  "insertBefore": (args2) => `Insérer avant ${args2.itemText}`,
  "insertBetween": (args2) => `Insérer entre ${args2.beforeItemText} et ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/he-IL.mjs
var $ad7f4c66d85b4494$exports = {};
$ad7f4c66d85b4494$exports = {
  "dragDescriptionKeyboard": `הקש על Enter כדי להתחיל לגרור.`,
  "dragDescriptionKeyboardAlt": `הקש Alt + Enter כדי להתחיל לגרור.`,
  "dragDescriptionLongPress": `לחץ לחיצה ארוכה כדי להתחיל לגרור.`,
  "dragDescriptionTouch": `הקש פעמיים כדי להתחיל בגרירה.`,
  "dragDescriptionVirtual": `לחץ כדי להתחיל לגרור.`,
  "dragItem": (args2) => `גרור את ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `גרור ${formatter.plural(args2.count, {
    one: () => `פריט נבחר ${formatter.number(args2.count)}`,
    other: () => `${formatter.number(args2.count)} פריטים שנבחרו`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `הקש על Enter כדי לגרור ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} פריט שנבחר`,
    other: () => `${formatter.number(args2.count)} פריטים שנבחרו`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `הקש Alt + Enter כדי לגרור ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} פריט שנבחר`,
    other: () => `${formatter.number(args2.count)} פריטים שנבחרו`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `לחץ לחיצה ארוכה כדי לגרור ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} פריט שנבחר`,
    other: () => `${formatter.number(args2.count)} פריטים שנבחרו`
  })}.`,
  "dragStartedKeyboard": `התחלת לגרור. הקש על Tab כדי לנווט לנקודת הגרירה ולאחר מכן הקש על Enter כדי לשחרר או על Escape כדי לבטל.`,
  "dragStartedTouch": `התחלת לגרור. נווט לנקודת השחרור ולאחר מכן הקש פעמיים כדי לשחרר.`,
  "dragStartedVirtual": `התחלת לגרור. נווט לנקודת השחרור ולאחר מכן לחץ או הקש על Enter כדי לשחרר.`,
  "dropCanceled": `השחרור בוטל.`,
  "dropComplete": `השחרור הושלם.`,
  "dropDescriptionKeyboard": `הקש על Enter כדי לשחרר. הקש על Escape כדי לבטל את הגרירה.`,
  "dropDescriptionTouch": `הקש פעמיים כדי לשחרר.`,
  "dropDescriptionVirtual": `לחץ כדי לשחרר.`,
  "dropIndicator": `מחוון שחרור`,
  "dropOnItem": (args2) => `שחרר על ${args2.itemText}`,
  "dropOnRoot": `שחרר על`,
  "endDragKeyboard": `גורר. הקש על Enter כדי לבטל את הגרירה.`,
  "endDragTouch": `גורר. הקש פעמיים כדי לבטל את הגרירה.`,
  "endDragVirtual": `גורר. לחץ כדי לבטל את הגרירה.`,
  "insertAfter": (args2) => `הוסף אחרי ${args2.itemText}`,
  "insertBefore": (args2) => `הוסף לפני ${args2.itemText}`,
  "insertBetween": (args2) => `הוסף בין ${args2.beforeItemText} לבין ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/hr-HR.mjs
var $4aa59f3c6a796cae$exports = {};
$4aa59f3c6a796cae$exports = {
  "dragDescriptionKeyboard": `Pritisnite Enter da biste počeli povlačiti.`,
  "dragDescriptionKeyboardAlt": `Pritisnite Alt + Enter za početak povlačenja.`,
  "dragDescriptionLongPress": `Dugo pritisnite za početak povlačenja.`,
  "dragDescriptionTouch": `Dvaput dodirnite da biste počeli povlačiti.`,
  "dragDescriptionVirtual": `Kliknite da biste počeli povlačiti.`,
  "dragItem": (args2) => `Povucite stavku ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Povucite ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} odabranu stavku`,
    other: () => `ovoliko odabranih stavki: ${formatter.number(args2.count)}`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pritisnite Enter za povlačenje ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} odabrana stavka`,
    other: () => `${formatter.number(args2.count)} odabrane stavke`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pritisnite Alt + Enter za povlačenje ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} odabrana stavka`,
    other: () => `${formatter.number(args2.count)} odabrane stavke`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Dugo pritisnite za povlačenje ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} odabrana stavka`,
    other: () => `${formatter.number(args2.count)} odabrane stavke`
  })}.`,
  "dragStartedKeyboard": `Počeli ste povlačiti. Pritisnite tipku tabulatora da biste došli do cilja ispuštanja, a zatim Enter da biste ispustili stavku ili Escape da biste prekinuli povlačenje.`,
  "dragStartedTouch": `Počeli ste povlačiti. Dođite do cilja ispuštanja, a zatim dvaput dodirnite da biste ispustili stavku.`,
  "dragStartedVirtual": `Počeli ste povlačiti. Dođite do cilja ispuštanja, a zatim kliknite ili pritisnite Enter da biste ispustili stavku.`,
  "dropCanceled": `Povlačenje je prekinuto.`,
  "dropComplete": `Ispuštanje je dovršeno.`,
  "dropDescriptionKeyboard": `Pritisnite Enter da biste ispustili stavku. Pritisnite Escape da biste prekinuli povlačenje.`,
  "dropDescriptionTouch": `Dvaput dodirnite da biste ispustili stavku.`,
  "dropDescriptionVirtual": `Kliknite da biste ispustili stavku.`,
  "dropIndicator": `pokazatelj ispuštanja`,
  "dropOnItem": (args2) => `Ispustite na stavku ${args2.itemText}`,
  "dropOnRoot": `Ispustite na`,
  "endDragKeyboard": `Povlačenje. Pritisnite Enter da biste prekinuli povlačenje.`,
  "endDragTouch": `Povlačenje. Dvaput dodirnite da biste prekinuli povlačenje.`,
  "endDragVirtual": `Povlačenje. Kliknite da biste prekinuli povlačenje.`,
  "insertAfter": (args2) => `Umetnite iza stavke ${args2.itemText}`,
  "insertBefore": (args2) => `Ispustite ispred stavke ${args2.itemText}`,
  "insertBetween": (args2) => `Umetnite između stavki ${args2.beforeItemText} i ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/hu-HU.mjs
var $d8d3646556c40586$exports = {};
$d8d3646556c40586$exports = {
  "dragDescriptionKeyboard": `Nyomja le az Enter billentyűt a húzás megkezdéséhez.`,
  "dragDescriptionKeyboardAlt": `Nyomja le az Alt + Enter billentyűket a húzás megkezdéséhez.`,
  "dragDescriptionLongPress": `Hosszan nyomja meg a húzás elindításához.`,
  "dragDescriptionTouch": `Koppintson duplán a húzás megkezdéséhez.`,
  "dragDescriptionVirtual": `Kattintson a húzás megkezdéséhez.`,
  "dragItem": (args2) => `${args2.itemText} húzása`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} kijelölt elem`,
    other: () => `${formatter.number(args2.count)} kijelölt elem`
  })} húzása`,
  "dragSelectedKeyboard": (args2, formatter) => `Nyomja meg az Entert ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} kijelölt elem`,
    other: () => `${formatter.number(args2.count)} kijelölt elem`
  })} húzásához.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Nyomja meg az Alt + Enter billentyűket ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} kijelölt elem`,
    other: () => `${formatter.number(args2.count)} kijelölt elem`
  })} húzásához.`,
  "dragSelectedLongPress": (args2, formatter) => `Tartsa lenyomva hosszan ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} kijelölt elem`,
    other: () => `${formatter.number(args2.count)} kijelölt elem`
  })} húzásához.`,
  "dragStartedKeyboard": `Húzás megkezdve. Nyomja le a Tab billentyűt az elengedési célhoz navigálásához, majd nyomja le az Enter billentyűt az elengedéshez, vagy nyomja le az Escape billentyűt a megszakításhoz.`,
  "dragStartedTouch": `Húzás megkezdve. Navigáljon egy elengedési célhoz, majd koppintson duplán az elengedéshez.`,
  "dragStartedVirtual": `Húzás megkezdve. Navigáljon egy elengedési célhoz, majd kattintson vagy nyomja le az Enter billentyűt az elengedéshez.`,
  "dropCanceled": `Elengedés megszakítva.`,
  "dropComplete": `Elengedés teljesítve.`,
  "dropDescriptionKeyboard": `Nyomja le az Enter billentyűt az elengedéshez. Nyomja le az Escape billentyűt a húzás megszakításához.`,
  "dropDescriptionTouch": `Koppintson duplán az elengedéshez.`,
  "dropDescriptionVirtual": `Kattintson az elengedéshez.`,
  "dropIndicator": `elengedésjelző`,
  "dropOnItem": (args2) => `Elengedés erre: ${args2.itemText}`,
  "dropOnRoot": `Elengedés erre:`,
  "endDragKeyboard": `Húzás folyamatban. Nyomja le az Enter billentyűt a húzás megszakításához.`,
  "endDragTouch": `Húzás folyamatban. Koppintson duplán a húzás megszakításához.`,
  "endDragVirtual": `Húzás folyamatban. Kattintson a húzás megszakításához.`,
  "insertAfter": (args2) => `Beszúrás ${args2.itemText} után`,
  "insertBefore": (args2) => `Beszúrás ${args2.itemText} elé`,
  "insertBetween": (args2) => `Beszúrás ${args2.beforeItemText} és ${args2.afterItemText} közé`
};

// node_modules/@react-aria/dnd/dist/it-IT.mjs
var $982d558b45395246$exports = {};
$982d558b45395246$exports = {
  "dragDescriptionKeyboard": `Premi Invio per iniziare a trascinare.`,
  "dragDescriptionKeyboardAlt": `Premi Alt + Invio per iniziare a trascinare.`,
  "dragDescriptionLongPress": `Premi a lungo per iniziare a trascinare.`,
  "dragDescriptionTouch": `Tocca due volte per iniziare a trascinare.`,
  "dragDescriptionVirtual": `Fai clic per iniziare a trascinare.`,
  "dragItem": (args2) => `Trascina ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Trascina ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} altro elemento selezionato`,
    other: () => `${formatter.number(args2.count)} altri elementi selezionati`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Premi Invio per trascinare ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento selezionato`,
    other: () => `${formatter.number(args2.count)} elementi selezionati`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Premi Alt + Invio per trascinare ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento selezionato`,
    other: () => `${formatter.number(args2.count)} elementi selezionati`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Premi a lungo per trascinare ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} elemento selezionato`,
    other: () => `${formatter.number(args2.count)} elementi selezionati`
  })}.`,
  "dragStartedKeyboard": `Hai iniziato a trascinare. Premi Tab per arrivare sull’area di destinazione, quindi premi Invio per rilasciare o Esc per annullare.`,
  "dragStartedTouch": `Hai iniziato a trascinare. Arriva sull’area di destinazione, quindi tocca due volte per rilasciare.`,
  "dragStartedVirtual": `Hai iniziato a trascinare. Arriva sull’area di destinazione, quindi fai clic o premi Invio per rilasciare.`,
  "dropCanceled": `Rilascio annullato.`,
  "dropComplete": `Rilascio completato.`,
  "dropDescriptionKeyboard": `Premi Invio per rilasciare. Premi Esc per annullare.`,
  "dropDescriptionTouch": `Tocca due volte per rilasciare.`,
  "dropDescriptionVirtual": `Fai clic per rilasciare.`,
  "dropIndicator": `indicatore di rilascio`,
  "dropOnItem": (args2) => `Rilascia su ${args2.itemText}`,
  "dropOnRoot": `Rilascia su`,
  "endDragKeyboard": `Trascinamento. Premi Invio per annullare.`,
  "endDragTouch": `Trascinamento. Tocca due volte per annullare.`,
  "endDragVirtual": `Trascinamento. Fai clic per annullare.`,
  "insertAfter": (args2) => `Inserisci dopo ${args2.itemText}`,
  "insertBefore": (args2) => `Inserisci prima di ${args2.itemText}`,
  "insertBetween": (args2) => `Inserisci tra ${args2.beforeItemText} e ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/ja-JP.mjs
var $6a0cf387b9de036c$exports = {};
$6a0cf387b9de036c$exports = {
  "dragDescriptionKeyboard": `Enter キーを押してドラッグを開始してください。`,
  "dragDescriptionKeyboardAlt": `Alt+Enter キーを押してドラッグを開始します。`,
  "dragDescriptionLongPress": `長押ししてドラッグを開始します。`,
  "dragDescriptionTouch": `ダブルタップしてドラッグを開始します。`,
  "dragDescriptionVirtual": `クリックしてドラッグを開始します。`,
  "dragItem": (args2) => `${args2.itemText} をドラッグ`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個の選択項目`,
    other: () => `${formatter.number(args2.count)} 個の選択項目`
  })} をドラッグ`,
  "dragSelectedKeyboard": (args2, formatter) => `Enter キーを押して、${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 選択した項目`,
    other: () => `${formatter.number(args2.count)} 選択した項目`
  })}をドラッグします。`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Alt+Enter キーを押して、${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 選択した項目`,
    other: () => `${formatter.number(args2.count)} 選択した項目`
  })}をドラッグします。`,
  "dragSelectedLongPress": (args2, formatter) => `長押しして、${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 選択した項目`,
    other: () => `${formatter.number(args2.count)} 選択した項目`
  })}をドラッグします。`,
  "dragStartedKeyboard": `ドラッグを開始します。Tab キーを押してドロップターゲットにいどうし、Enter キーを押してドロップするか、Esc キーを押してキャンセルします。`,
  "dragStartedTouch": `ドラッグを開始しました。ドロップのターゲットに移動し、ダブルタップしてドロップします。`,
  "dragStartedVirtual": `ドラッグを開始しました。ドロップのターゲットに移動し、クリックまたは Enter キーを押してドロップします。`,
  "dropCanceled": `ドロップがキャンセルされました。`,
  "dropComplete": `ドロップが完了しました。`,
  "dropDescriptionKeyboard": `Enter キーを押してドロップします。Esc キーを押してドラッグをキャンセルします。`,
  "dropDescriptionTouch": `ダブルタップしてドロップします。`,
  "dropDescriptionVirtual": `クリックしてドロップします。`,
  "dropIndicator": `ドロップインジケーター`,
  "dropOnItem": (args2) => `${args2.itemText} にドロップ`,
  "dropOnRoot": `ドロップ場所`,
  "endDragKeyboard": `ドラッグしています。Enter キーを押してドラッグをキャンセルします。`,
  "endDragTouch": `ドラッグしています。ダブルタップしてドラッグをキャンセルします。`,
  "endDragVirtual": `ドラッグしています。クリックしてドラッグをキャンセルします。`,
  "insertAfter": (args2) => `${args2.itemText} の後に挿入`,
  "insertBefore": (args2) => `${args2.itemText} の前に挿入`,
  "insertBetween": (args2) => `${args2.beforeItemText} と ${args2.afterItemText} の間に挿入`
};

// node_modules/@react-aria/dnd/dist/ko-KR.mjs
var $a97fefa2956f4bcb$exports = {};
$a97fefa2956f4bcb$exports = {
  "dragDescriptionKeyboard": `드래그를 시작하려면 Enter를 누르세요.`,
  "dragDescriptionKeyboardAlt": `드래그를 시작하려면 Alt + Enter를 누르십시오.`,
  "dragDescriptionLongPress": `드래그를 시작하려면 길게 누르십시오.`,
  "dragDescriptionTouch": `드래그를 시작하려면 더블 탭하세요.`,
  "dragDescriptionVirtual": `드래그를 시작하려면 클릭하세요.`,
  "dragItem": (args2) => `${args2.itemText} 드래그`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 선택 항목`,
    other: () => `${formatter.number(args2.count)}개 선택 항목`
  })} 드래그`,
  "dragSelectedKeyboard": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 선택 항목`,
    other: () => `${formatter.number(args2.count)}개 선택 항목`
  })}을 드래그하려면 Enter를 누르십시오.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 선택 항목`,
    other: () => `${formatter.number(args2.count)}개 선택 항목`
  })}을 드래그하려면 Alt + Enter를 누르십시오.`,
  "dragSelectedLongPress": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 선택 항목`,
    other: () => `${formatter.number(args2.count)}개 선택 항목`
  })}을 드래그하려면 길게 누르십시오.`,
  "dragStartedKeyboard": `드래그가 시작되었습니다. Tab을 눌러 드롭 대상으로 이동한 다음 Enter를 눌러 드롭하거나 Esc를 눌러 취소하세요.`,
  "dragStartedTouch": `드래그가 시작되었습니다. 드롭 대상으로 이동한 다음 더블 탭하여 드롭하세요.`,
  "dragStartedVirtual": `드래그가 시작되었습니다. 드롭 대상으로 이동한 다음 클릭하거나 Enter를 눌러 드롭하세요.`,
  "dropCanceled": `드롭이 취소되었습니다.`,
  "dropComplete": `드롭이 완료되었습니다.`,
  "dropDescriptionKeyboard": `드롭하려면 Enter를 누르세요. 드래그를 취소하려면 Esc를 누르세요.`,
  "dropDescriptionTouch": `더블 탭하여 드롭하세요.`,
  "dropDescriptionVirtual": `드롭하려면 클릭하세요.`,
  "dropIndicator": `드롭 표시기`,
  "dropOnItem": (args2) => `${args2.itemText}에 드롭`,
  "dropOnRoot": `드롭 대상`,
  "endDragKeyboard": `드래그 중입니다. 드래그를 취소하려면 Enter를 누르세요.`,
  "endDragTouch": `드래그 중입니다. 드래그를 취소하려면 더블 탭하세요.`,
  "endDragVirtual": `드래그 중입니다. 드래그를 취소하려면 클릭하세요.`,
  "insertAfter": (args2) => `${args2.itemText} 이후에 삽입`,
  "insertBefore": (args2) => `${args2.itemText} 이전에 삽입`,
  "insertBetween": (args2) => `${args2.beforeItemText} 및 ${args2.afterItemText} 사이에 삽입`
};

// node_modules/@react-aria/dnd/dist/lt-LT.mjs
var $5fb5837f94e1c150$exports = {};
$5fb5837f94e1c150$exports = {
  "dragDescriptionKeyboard": `Paspauskite „Enter“, kad pradėtumėte vilkti.`,
  "dragDescriptionKeyboardAlt": `Paspauskite „Alt + Enter“, kad pradėtumėte vilkti.`,
  "dragDescriptionLongPress": `Palaikykite nuspaudę, kad pradėtumėte vilkti.`,
  "dragDescriptionTouch": `Palieskite dukart, kad pradėtumėte vilkti.`,
  "dragDescriptionVirtual": `Spustelėkite, kad pradėtumėte vilkti.`,
  "dragItem": (args2) => `Vilkti ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Vilkti ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args2.count)} pasirinktus elementus`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Paspauskite „Enter“, jei norite nuvilkti ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args2.count)} pasirinktus elementus`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Paspauskite „Alt + Enter“, kad nuvilktumėte ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args2.count)} pasirinktus elementus`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Nuspaudę palaikykite, kad nuvilktumėte ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args2.count)} pasirinktus elementus`
  })}.`,
  "dragStartedKeyboard": `Pradėta vilkti. Paspauskite „Tab“, kad pereitumėte į tiesioginę paskirties vietą, tada paspauskite „Enter“, kad numestumėte, arba „Escape“, kad atšauktumėte.`,
  "dragStartedTouch": `Pradėta vilkti. Eikite į tiesioginę paskirties vietą, tada palieskite dukart, kad numestumėte.`,
  "dragStartedVirtual": `Pradėta vilkti. Eikite į tiesioginę paskirties vietą ir spustelėkite arba paspauskite „Enter“, kad numestumėte.`,
  "dropCanceled": `Numetimas atšauktas.`,
  "dropComplete": `Numesta.`,
  "dropDescriptionKeyboard": `Paspauskite „Enter“, kad numestumėte. Paspauskite „Escape“, kad atšauktumėte vilkimą.`,
  "dropDescriptionTouch": `Palieskite dukart, kad numestumėte.`,
  "dropDescriptionVirtual": `Spustelėkite, kad numestumėte.`,
  "dropIndicator": `numetimo indikatorius`,
  "dropOnItem": (args2) => `Numesti ant ${args2.itemText}`,
  "dropOnRoot": `Numesti ant`,
  "endDragKeyboard": `Velkama. Paspauskite „Enter“, kad atšauktumėte vilkimą.`,
  "endDragTouch": `Velkama. Spustelėkite dukart, kad atšauktumėte vilkimą.`,
  "endDragVirtual": `Velkama. Spustelėkite, kad atšauktumėte vilkimą.`,
  "insertAfter": (args2) => `Įterpti po ${args2.itemText}`,
  "insertBefore": (args2) => `Įterpti prieš ${args2.itemText}`,
  "insertBetween": (args2) => `Įterpti tarp ${args2.beforeItemText} ir ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/lv-LV.mjs
var $5b2e5709864cc922$exports = {};
$5b2e5709864cc922$exports = {
  "dragDescriptionKeyboard": `Nospiediet Enter, lai sāktu vilkšanu.`,
  "dragDescriptionKeyboardAlt": `Nospiediet taustiņu kombināciju Alt+Enter, lai sāktu vilkšanu.`,
  "dragDescriptionLongPress": `Turiet nospiestu, lai sāktu vilkšanu.`,
  "dragDescriptionTouch": `Veiciet dubultskārienu, lai sāktu vilkšanu.`,
  "dragDescriptionVirtual": `Noklikšķiniet, lai sāktu vilkšanu.`,
  "dragItem": (args2) => `Velciet ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Velciet ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args2.count)} atlasītos vienumus`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Nospiediet taustiņu Enter, lai vilktu ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args2.count)} atlasītos vienumus`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Nospiediet taustiņu kombināciju Alt+Enter, lai vilktu ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args2.count)} atlasītos vienumus`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Turiet nospiestu, lai vilktu ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args2.count)} atlasītos vienumus`
  })}.`,
  "dragStartedKeyboard": `Uzsākta vilkšana. Nospiediet taustiņu Tab, lai pārietu uz nomešanas mērķi, pēc tam nospiediet Enter, lai nomestu, vai nospiediet Escape, lai atceltu.`,
  "dragStartedTouch": `Uzsākta vilkšana. Pārejiet uz nomešanas mērķi, pēc tam veiciet dubultskārienu, lai nomestu.`,
  "dragStartedVirtual": `Uzsākta vilkšana. Pārejiet uz nomešanas mērķi, pēc tam nospiediet Enter, lai nomestu.`,
  "dropCanceled": `Nomešana atcelta.`,
  "dropComplete": `Nomešana pabeigta.`,
  "dropDescriptionKeyboard": `Nospiediet Enter, lai nomestu. Nospiediet Escape, lai atceltu vilkšanu.`,
  "dropDescriptionTouch": `Veiciet dubultskārienu, lai nomestu.`,
  "dropDescriptionVirtual": `Noklikšķiniet, lai nomestu.`,
  "dropIndicator": `nomešanas indikators`,
  "dropOnItem": (args2) => `Nometiet uz ${args2.itemText}`,
  "dropOnRoot": `Nometiet uz`,
  "endDragKeyboard": `Notiek vilkšana. Nospiediet Enter, lai atceltu vilkšanu.`,
  "endDragTouch": `Notiek vilkšana. Veiciet dubultskārienu, lai atceltu vilkšanu.`,
  "endDragVirtual": `Notiek vilkšana. Noklikšķiniet, lai atceltu vilkšanu.`,
  "insertAfter": (args2) => `Ievietojiet pēc ${args2.itemText}`,
  "insertBefore": (args2) => `Ievietojiet pirms ${args2.itemText}`,
  "insertBetween": (args2) => `Ievietojiet starp ${args2.beforeItemText} un ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/nb-NO.mjs
var $ee15bb8efb18cc69$exports = {};
$ee15bb8efb18cc69$exports = {
  "dragDescriptionKeyboard": `Trykk på Enter for å begynne å dra.`,
  "dragDescriptionKeyboardAlt": `Trykk på Alt + Enter for å begynne å dra.`,
  "dragDescriptionLongPress": `Trykk lenge for å begynne å dra.`,
  "dragDescriptionTouch": `Dobbelttrykk for å begynne å dra.`,
  "dragDescriptionVirtual": `Klikk for å begynne å dra.`,
  "dragItem": (args2) => `Dra ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} merket element`,
    other: () => `${formatter.number(args2.count)} merkede elementer`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Trykk Enter for å dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgt element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Trykk på Alt + Enter for å dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgt element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Trykk lenge for å dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valgt element`,
    other: () => `${formatter.number(args2.count)} valgte elementer`
  })}.`,
  "dragStartedKeyboard": `Begynte å dra. Trykk på Tab for å navigere til et mål, og trykk deretter på Enter for å slippe eller på Esc for å avbryte.`,
  "dragStartedTouch": `Begynte å dra. Naviger til et mål, og dobbelttrykk for å slippe.`,
  "dragStartedVirtual": `Begynte å dra. Naviger til et mål, og klikk eller trykk på Enter for å slippe.`,
  "dropCanceled": `Avbrøt slipping.`,
  "dropComplete": `Slippingen er fullført.`,
  "dropDescriptionKeyboard": `Trykk på Enter for å slippe. Trykk på Esc hvis du vil avbryte draingen.`,
  "dropDescriptionTouch": `Dobbelttrykk for å slippe.`,
  "dropDescriptionVirtual": `Klikk for å slippe.`,
  "dropIndicator": `slippeindikator`,
  "dropOnItem": (args2) => `Slipp på ${args2.itemText}`,
  "dropOnRoot": `Slipp på`,
  "endDragKeyboard": `Drar. Trykk på Enter hvis du vil avbryte.`,
  "endDragTouch": `Drar. Dobbelttrykk hvis du vil avbryte.`,
  "endDragVirtual": `Drar. Klikk hvis du vil avbryte.`,
  "insertAfter": (args2) => `Sett inn etter ${args2.itemText}`,
  "insertBefore": (args2) => `Sett inn før ${args2.itemText}`,
  "insertBetween": (args2) => `Sett inn mellom ${args2.beforeItemText} og ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/nl-NL.mjs
var $1daf2d4602e26ac4$exports = {};
$1daf2d4602e26ac4$exports = {
  "dragDescriptionKeyboard": `Druk op Enter om te slepen.`,
  "dragDescriptionKeyboardAlt": `Druk op Alt + Enter om te slepen.`,
  "dragDescriptionLongPress": `Houd lang ingedrukt om te slepen.`,
  "dragDescriptionTouch": `Dubbeltik om te slepen.`,
  "dragDescriptionVirtual": `Klik om met slepen te starten.`,
  "dragItem": (args2) => `${args2.itemText} slepen`,
  "dragSelectedItems": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} geselecteerd item`,
    other: () => `${formatter.number(args2.count)} geselecteerde items`
  })} slepen`,
  "dragSelectedKeyboard": (args2, formatter) => `Druk op Enter om ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} geselecteerd item`,
    other: () => `${formatter.number(args2.count)} geselecteerde items`
  })} te slepen.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Druk op Alt + Enter om ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} geselecteerd item`,
    other: () => `${formatter.number(args2.count)} geselecteerde items`
  })} te slepen.`,
  "dragSelectedLongPress": (args2, formatter) => `Houd lang ingedrukt om ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} geselecteerd item`,
    other: () => `${formatter.number(args2.count)} geselecteerde items`
  })} te slepen.`,
  "dragStartedKeyboard": `Begonnen met slepen. Druk op Tab om naar een locatie te gaan. Druk dan op Enter om neer te zetten, of op Esc om te annuleren.`,
  "dragStartedTouch": `Begonnen met slepen. Ga naar de gewenste locatie en dubbeltik om neer te zetten.`,
  "dragStartedVirtual": `Begonnen met slepen. Ga naar de gewenste locatie en klik of druk op Enter om neer te zetten.`,
  "dropCanceled": `Neerzetten geannuleerd.`,
  "dropComplete": `Neerzetten voltooid.`,
  "dropDescriptionKeyboard": `Druk op Enter om neer te zetten. Druk op Esc om het slepen te annuleren.`,
  "dropDescriptionTouch": `Dubbeltik om neer te zetten.`,
  "dropDescriptionVirtual": `Klik om neer te zetten.`,
  "dropIndicator": `aanwijzer voor neerzetten`,
  "dropOnItem": (args2) => `Neerzetten op ${args2.itemText}`,
  "dropOnRoot": `Neerzetten op`,
  "endDragKeyboard": `Bezig met slepen. Druk op Enter om te annuleren.`,
  "endDragTouch": `Bezig met slepen. Dubbeltik om te annuleren.`,
  "endDragVirtual": `Bezig met slepen. Klik om te annuleren.`,
  "insertAfter": (args2) => `Plaatsen na ${args2.itemText}`,
  "insertBefore": (args2) => `Plaatsen vóór ${args2.itemText}`,
  "insertBetween": (args2) => `Plaatsen tussen ${args2.beforeItemText} en ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/pl-PL.mjs
var $7115429b0f60511f$exports = {};
$7115429b0f60511f$exports = {
  "dragDescriptionKeyboard": `Naciśnij Enter, aby rozpocząć przeciąganie.`,
  "dragDescriptionKeyboardAlt": `Naciśnij Alt + Enter, aby rozpocząć przeciąganie.`,
  "dragDescriptionLongPress": `Naciśnij i przytrzymaj, aby rozpocząć przeciąganie.`,
  "dragDescriptionTouch": `Dotknij dwukrotnie, aby rozpocząć przeciąganie.`,
  "dragDescriptionVirtual": `Kliknij, aby rozpocząć przeciąganie.`,
  "dragItem": (args2) => `Przeciągnij ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Przeciągnij ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} wybrany element`,
    other: () => `${formatter.number(args2.count)} wybranych elementów`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Naciśnij Enter, aby przeciągnąć ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} wybrany element`,
    other: () => `${formatter.number(args2.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Naciśnij Alt + Enter, aby przeciągnąć ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} wybrany element`,
    other: () => `${formatter.number(args2.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Naciśnij i przytrzymaj, aby przeciągnąć ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} wybrany element`,
    other: () => `${formatter.number(args2.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragStartedKeyboard": `Rozpoczęto przeciąganie. Naciśnij Tab, aby wybrać miejsce docelowe, a następnie naciśnij Enter, aby upuścić, lub Escape, aby anulować.`,
  "dragStartedTouch": `Rozpoczęto przeciąganie. Wybierz miejsce, w którym chcesz upuścić element, a następnie dotknij dwukrotnie, aby upuścić.F`,
  "dragStartedVirtual": `Rozpoczęto przeciąganie. Wybierz miejsce, w którym chcesz upuścić element, a następnie kliknij lub naciśnij Enter, aby upuścić.`,
  "dropCanceled": `Anulowano upuszczenie.`,
  "dropComplete": `Zakończono upuszczanie.`,
  "dropDescriptionKeyboard": `Naciśnij Enter, aby upuścić. Naciśnij Escape, aby anulować przeciągnięcie.`,
  "dropDescriptionTouch": `Dotknij dwukrotnie, aby upuścić.`,
  "dropDescriptionVirtual": `Kliknij, aby upuścić.`,
  "dropIndicator": `wskaźnik upuszczenia`,
  "dropOnItem": (args2) => `Upuść na ${args2.itemText}`,
  "dropOnRoot": `Upuść`,
  "endDragKeyboard": `Przeciąganie. Naciśnij Enter, aby anulować przeciągnięcie.`,
  "endDragTouch": `Przeciąganie. Kliknij dwukrotnie, aby anulować przeciągnięcie.`,
  "endDragVirtual": `Przeciąganie. Kliknij, aby anulować przeciąganie.`,
  "insertAfter": (args2) => `Umieść za ${args2.itemText}`,
  "insertBefore": (args2) => `Umieść przed ${args2.itemText}`,
  "insertBetween": (args2) => `Umieść między ${args2.beforeItemText} i ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/pt-BR.mjs
var $5edd453ae5d4a8bc$exports = {};
$5edd453ae5d4a8bc$exports = {
  "dragDescriptionKeyboard": `Pressione Enter para começar a arrastar.`,
  "dragDescriptionKeyboardAlt": `Pressione Alt + Enter para começar a arrastar.`,
  "dragDescriptionLongPress": `Pressione e segure para começar a arrastar.`,
  "dragDescriptionTouch": `Toque duas vezes para começar a arrastar.`,
  "dragDescriptionVirtual": `Clique para começar a arrastar.`,
  "dragItem": (args2) => `Arrastar ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} item selecionado`,
    other: () => `${formatter.number(args2.count)} itens selecionados`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pressione Enter para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pressione Alt + Enter para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Pressione e segure para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragStartedKeyboard": `Comece a arrastar. Pressione Tab para navegar até um alvo e, em seguida, pressione Enter para soltar ou pressione Escape para cancelar.`,
  "dragStartedTouch": `Comece a arrastar. Navegue até um alvo e toque duas vezes para soltar.`,
  "dragStartedVirtual": `Comece a arrastar. Navegue até um alvo e clique ou pressione Enter para soltar.`,
  "dropCanceled": `Liberação cancelada.`,
  "dropComplete": `Liberação concluída.`,
  "dropDescriptionKeyboard": `Pressione Enter para soltar. Pressione Escape para cancelar.`,
  "dropDescriptionTouch": `Toque duas vezes para soltar.`,
  "dropDescriptionVirtual": `Clique para soltar.`,
  "dropIndicator": `indicador de liberação`,
  "dropOnItem": (args2) => `Soltar em ${args2.itemText}`,
  "dropOnRoot": `Soltar`,
  "endDragKeyboard": `Arrastando. Pressione Enter para cancelar.`,
  "endDragTouch": `Arrastando. Toque duas vezes para cancelar.`,
  "endDragVirtual": `Arrastando. Clique para cancelar.`,
  "insertAfter": (args2) => `Inserir após ${args2.itemText}`,
  "insertBefore": (args2) => `Inserir antes de ${args2.itemText}`,
  "insertBetween": (args2) => `Inserir entre ${args2.beforeItemText} e ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/pt-PT.mjs
var $5f431994f708535e$exports = {};
$5f431994f708535e$exports = {
  "dragDescriptionKeyboard": `Prima Enter para iniciar o arrasto.`,
  "dragDescriptionKeyboardAlt": `Prima Alt + Enter para iniciar o arrasto.`,
  "dragDescriptionLongPress": `Prima longamente para começar a arrastar.`,
  "dragDescriptionTouch": `Faça duplo toque para começar a arrastar.`,
  "dragDescriptionVirtual": `Clique para iniciar o arrasto.`,
  "dragItem": (args2) => `Arrastar ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} item selecionado`,
    other: () => `${formatter.number(args2.count)} itens selecionados`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Prima Enter para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Prima Alt + Enter para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Prima longamente para arrastar ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} o item selecionado`,
    other: () => `${formatter.number(args2.count)} os itens selecionados`
  })}.`,
  "dragStartedKeyboard": `Arrasto iniciado. Prima a tecla de tabulação para navegar para um destino para largar, e em seguida prima Enter para largar ou prima Escape para cancelar.`,
  "dragStartedTouch": `Arrasto iniciado. Navegue para um destino para largar, e em seguida faça duplo toque para largar.`,
  "dragStartedVirtual": `Arrasto iniciado. Navegue para um destino para largar, e em seguida clique ou prima Enter para largar.`,
  "dropCanceled": `Largar cancelado.`,
  "dropComplete": `Largar completo.`,
  "dropDescriptionKeyboard": `Prima Enter para largar. Prima Escape para cancelar o arrasto.`,
  "dropDescriptionTouch": `Faça duplo toque para largar.`,
  "dropDescriptionVirtual": `Clique para largar.`,
  "dropIndicator": `Indicador de largar`,
  "dropOnItem": (args2) => `Largar em ${args2.itemText}`,
  "dropOnRoot": `Largar em`,
  "endDragKeyboard": `A arrastar. Prima Enter para cancelar o arrasto.`,
  "endDragTouch": `A arrastar. Faça duplo toque para cancelar o arrasto.`,
  "endDragVirtual": `A arrastar. Clique para cancelar o arrasto.`,
  "insertAfter": (args2) => `Inserir depois de ${args2.itemText}`,
  "insertBefore": (args2) => `Inserir antes de ${args2.itemText}`,
  "insertBetween": (args2) => `Inserir entre ${args2.beforeItemText} e ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/ro-RO.mjs
var $107b5e2e45e971f1$exports = {};
$107b5e2e45e971f1$exports = {
  "dragDescriptionKeyboard": `Apăsați pe Enter pentru a începe glisarea.`,
  "dragDescriptionKeyboardAlt": `Apăsați pe Alt + Enter pentru a începe glisarea.`,
  "dragDescriptionLongPress": `Apăsați lung pentru a începe glisarea.`,
  "dragDescriptionTouch": `Atingeți de două ori pentru a începe să glisați.`,
  "dragDescriptionVirtual": `Faceți clic pentru a începe glisarea.`,
  "dragItem": (args2) => `Glisați ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Glisați ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Apăsați pe Enter pentru a glisa ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Apăsați pe Alt + Enter pentru a glisa ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Apăsați lung pentru a glisa ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} element selectat`,
    other: () => `${formatter.number(args2.count)} elemente selectate`
  })}.`,
  "dragStartedKeyboard": `A început glisarea. Apăsați pe Tab pentru a naviga la o țintă de fixare, apoi apăsați pe Enter pentru a fixa sau apăsați pe Escape pentru a anula glisarea.`,
  "dragStartedTouch": `A început glisarea. Navigați la o țintă de fixare, apoi atingeți de două ori pentru a fixa.`,
  "dragStartedVirtual": `A început glisarea. Navigați la o țintă de fixare, apoi faceți clic sau apăsați pe Enter pentru a fixa.`,
  "dropCanceled": `Fixare anulată.`,
  "dropComplete": `Fixare finalizată.`,
  "dropDescriptionKeyboard": `Apăsați pe Enter pentru a fixa. Apăsați pe Escape pentru a anula glisarea.`,
  "dropDescriptionTouch": `Atingeți de două ori pentru a fixa.`,
  "dropDescriptionVirtual": `Faceți clic pentru a fixa.`,
  "dropIndicator": `indicator de fixare`,
  "dropOnItem": (args2) => `Fixați pe ${args2.itemText}`,
  "dropOnRoot": `Fixare pe`,
  "endDragKeyboard": `Se glisează. Apăsați pe Enter pentru a anula glisarea.`,
  "endDragTouch": `Se glisează. Atingeți de două ori pentru a anula glisarea.`,
  "endDragVirtual": `Se glisează. Faceți clic pentru a anula glisarea.`,
  "insertAfter": (args2) => `Inserați după ${args2.itemText}`,
  "insertBefore": (args2) => `Inserați înainte de ${args2.itemText}`,
  "insertBetween": (args2) => `Inserați între ${args2.beforeItemText} și ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/ru-RU.mjs
var $d4b9c2f01c1892f7$exports = {};
$d4b9c2f01c1892f7$exports = {
  "dragDescriptionKeyboard": `Нажмите клавишу Enter для начала перетаскивания.`,
  "dragDescriptionKeyboardAlt": `Нажмите Alt + Enter, чтобы начать перетаскивать.`,
  "dragDescriptionLongPress": `Нажмите и удерживайте, чтобы начать перетаскивать.`,
  "dragDescriptionTouch": `Дважды нажмите для начала перетаскивания.`,
  "dragDescriptionVirtual": `Щелкните для начала перетаскивания.`,
  "dragItem": (args2) => `Перетащить ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Перетащить ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} выбранный элемент`,
    other: () => `${formatter.number(args2.count)} выбранных элем`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Нажмите Enter для перетаскивания ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} выбранного элемента`,
    other: () => `${formatter.number(args2.count)} выбранных элементов`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Нажмите Alt + Enter для перетаскивания ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} выбранного элемента`,
    other: () => `${formatter.number(args2.count)} выбранных элементов`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Нажмите и удерживайте для перетаскивания ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} выбранного элемента`,
    other: () => `${formatter.number(args2.count)} выбранных элементов`
  })}.`,
  "dragStartedKeyboard": `Начато перетаскивание. Нажмите клавишу Tab для выбора цели, затем нажмите клавишу Enter, чтобы применить перетаскивание, или клавишу Escape для отмены действия.`,
  "dragStartedTouch": `Начато перетаскивание. Выберите цель, затем дважды нажмите, чтобы применить перетаскивание.`,
  "dragStartedVirtual": `Начато перетаскивание. Нажмите клавишу Tab для выбора цели, затем нажмите клавишу Enter, чтобы применить перетаскивание.`,
  "dropCanceled": `Перетаскивание отменено.`,
  "dropComplete": `Перетаскивание завершено.`,
  "dropDescriptionKeyboard": `Нажмите клавишу Enter, чтобы применить перетаскивание. Нажмите клавишу Escape для отмены.`,
  "dropDescriptionTouch": `Дважды нажмите, чтобы применить перетаскивание.`,
  "dropDescriptionVirtual": `Щелкните, чтобы применить перетаскивание.`,
  "dropIndicator": `индикатор перетаскивания`,
  "dropOnItem": (args2) => `Перетащить на ${args2.itemText}`,
  "dropOnRoot": `Перетащить на`,
  "endDragKeyboard": `Перетаскивание. Нажмите клавишу Enter для отмены.`,
  "endDragTouch": `Перетаскивание. Дважды нажмите для отмены.`,
  "endDragVirtual": `Перетаскивание. Щелкните для отмены.`,
  "insertAfter": (args2) => `Вставить после ${args2.itemText}`,
  "insertBefore": (args2) => `Вставить перед ${args2.itemText}`,
  "insertBetween": (args2) => `Вставить между ${args2.beforeItemText} и ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/sk-SK.mjs
var $dbdc1942894e83e4$exports = {};
$dbdc1942894e83e4$exports = {
  "dragDescriptionKeyboard": `Stlačením klávesu Enter začnete presúvanie.`,
  "dragDescriptionKeyboardAlt": `Stlačením klávesov Alt + Enter začnete presúvanie.`,
  "dragDescriptionLongPress": `Dlhým stlačením začnete presúvanie.`,
  "dragDescriptionTouch": `Dvojitým kliknutím začnete presúvanie.`,
  "dragDescriptionVirtual": `Kliknutím začnete presúvanie.`,
  "dragItem": (args2) => `Presunúť položku ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Presunúť ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybratú položku`,
    other: () => `${formatter.number(args2.count)} vybraté položky`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Stlačením klávesu Enter presuniete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybratú položku`,
    other: () => `${formatter.number(args2.count)} vybratých položiek`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Stlačením klávesov Alt + Enter presuniete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybratú položku`,
    other: () => `${formatter.number(args2.count)} vybratých položiek`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Dlhým stlačením presuniete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} vybratú položku`,
    other: () => `${formatter.number(args2.count)} vybratých položiek`
  })}.`,
  "dragStartedKeyboard": `Presúvanie sa začalo. Do cieľového umiestnenia prejdete stlačením klávesu Tab. Ak chcete položku umiestniť, stlačte kláves Enter alebo stlačte kláves Esc, ak chcete presúvanie zrušiť.`,
  "dragStartedTouch": `Presúvanie sa začalo. Prejdite na cieľové umiestnenie a dvojitým kliknutím umiestnite položku.`,
  "dragStartedVirtual": `Presúvanie sa začalo. Prejdite na cieľové umiestnenie a kliknutím alebo stlačením klávesu Enter umiestnite položku.`,
  "dropCanceled": `Umiestnenie zrušené.`,
  "dropComplete": `Umiestnenie dokončené.`,
  "dropDescriptionKeyboard": `Stlačením klávesu Enter umiestnite položku. Stlačením klávesu Esc zrušíte presúvanie.`,
  "dropDescriptionTouch": `Dvojitým kliknutím umiestnite položku.`,
  "dropDescriptionVirtual": `Kliknutím umiestnite položku.`,
  "dropIndicator": `indikátor umiestnenia`,
  "dropOnItem": (args2) => `Umiestniť na položku ${args2.itemText}`,
  "dropOnRoot": `Umiestniť na`,
  "endDragKeyboard": `Prebieha presúvanie. Ak ho chcete zrušiť, stlačte kláves Enter.`,
  "endDragTouch": `Prebieha presúvanie. Dvojitým kliknutím ho môžete zrušiť.`,
  "endDragVirtual": `Prebieha presúvanie.`,
  "insertAfter": (args2) => `Vložiť za položku ${args2.itemText}`,
  "insertBefore": (args2) => `Vložiť pred položku ${args2.itemText}`,
  "insertBetween": (args2) => `Vložiť medzi položky ${args2.beforeItemText} a ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/sl-SI.mjs
var $fbaaaaebd547d998$exports = {};
$fbaaaaebd547d998$exports = {
  "dragDescriptionKeyboard": `Pritisnite tipko Enter za začetek vlečenja.`,
  "dragDescriptionKeyboardAlt": `Pritisnite tipki Alt + Enter za začetek vlečenja.`,
  "dragDescriptionLongPress": `Pritisnite in zadržite za začetek vlečenja.`,
  "dragDescriptionTouch": `Dvotapnite za začetek vlečenja.`,
  "dragDescriptionVirtual": `Kliknite za začetek vlečenja.`,
  "dragItem": (args2) => `Povleci ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Povlecite ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izbran element`,
    other: () => `izbrane elemente (${formatter.number(args2.count)})`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pritisnite tipko Enter, da povlečete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izbrani element`,
    other: () => `${formatter.number(args2.count)} izbranih elementov`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pritisnite tipki Alt + Enter, da povlečete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izbrani element`,
    other: () => `${formatter.number(args2.count)} izbranih elementov`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Pritisnite in zadržite, da povlečete ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izbrani element`,
    other: () => `${formatter.number(args2.count)} izbranih elementov`
  })}.`,
  "dragStartedKeyboard": `Vlečenje se je začelo. Pritisnite tipko Tab za pomik na mesto, kamor želite spustiti elemente, in pritisnite tipko Enter, da jih spustite, ali tipko Escape, da prekličete postopek.`,
  "dragStartedTouch": `Vlečenje se je začelo. Pomaknite se na mesto, kamor želite spustiti elemente, in dvotapnite, da jih spustite.`,
  "dragStartedVirtual": `Vlečenje se je začelo. Pomaknite se na mesto, kamor želite spustiti elemente, in kliknite ali pritisnite tipko Enter, da jih spustite.`,
  "dropCanceled": `Spust je preklican.`,
  "dropComplete": `Spust je končan.`,
  "dropDescriptionKeyboard": `Pritisnite tipko Enter, da spustite. Pritisnite tipko Escape, da prekličete vlečenje.`,
  "dropDescriptionTouch": `Dvotapnite, da spustite.`,
  "dropDescriptionVirtual": `Kliknite, da spustite.`,
  "dropIndicator": `indikator spusta`,
  "dropOnItem": (args2) => `Spusti na mesto ${args2.itemText}`,
  "dropOnRoot": `Spusti na mesto`,
  "endDragKeyboard": `Vlečenje. Pritisnite tipko Enter za preklic vlečenja.`,
  "endDragTouch": `Vlečenje. Dvotapnite za preklic vlečenja.`,
  "endDragVirtual": `Vlečenje. Kliknite, da prekličete vlečenje.`,
  "insertAfter": (args2) => `Vstavi za ${args2.itemText}`,
  "insertBefore": (args2) => `Vstavi pred ${args2.itemText}`,
  "insertBetween": (args2) => `Vstavi med ${args2.beforeItemText} in ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/sr-SP.mjs
var $a0caa33f1e264489$exports = {};
$a0caa33f1e264489$exports = {
  "dragDescriptionKeyboard": `Pritisnite Enter da biste započeli prevlačenje.`,
  "dragDescriptionKeyboardAlt": `Pritisnite Alt + Enter da biste započeli prevlačenje.`,
  "dragDescriptionLongPress": `Pritisnite dugo da biste započeli prevlačenje.`,
  "dragDescriptionTouch": `Dvaput dodirnite da biste započeli prevlačenje.`,
  "dragDescriptionVirtual": `Kliknite da biste započeli prevlačenje.`,
  "dragItem": (args2) => `Prevucite ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Prevucite ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izabranu stavku`,
    other: () => `${formatter.number(args2.count)} izabrane stavke`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Pritisnite Enter da biste prevukli ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izabranu stavku`,
    other: () => `${formatter.number(args2.count)} izabranih stavki`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Pritisnite Alt + Enter da biste prevukli ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izabranu stavku`,
    other: () => `${formatter.number(args2.count)} izabranih stavki`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Pritisnite dugo da biste prevukli ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} izabranu stavku`,
    other: () => `${formatter.number(args2.count)} izabranih stavki`
  })}.`,
  "dragStartedKeyboard": `Prevlačenje je započeto. Pritisnite Tab da biste otišli do cilja za otpuštanje, zatim pritisnite Enter za ispuštanje ili pritisnite Escape za otkazivanje.`,
  "dragStartedTouch": `Prevlačenje je započeto. Idite do cilja za otpuštanje, a zatim dvaput dodirnite za otpuštanje.`,
  "dragStartedVirtual": `Prevlačenje je započeto. Idite do cilja za otpuštanje, a zatim kliknite ili pritinite Enter za otpuštanje.`,
  "dropCanceled": `Otpuštanje je otkazano.`,
  "dropComplete": `Prevlačenje je završeno.`,
  "dropDescriptionKeyboard": `Pritisnite Enter da biste otpustili. Pritisnite Escape da biste otkazali prevlačenje.`,
  "dropDescriptionTouch": `Dvaput dodirnite za otpuštanje.`,
  "dropDescriptionVirtual": `Kliknite za otpuštanje.`,
  "dropIndicator": `Indikator otpuštanja`,
  "dropOnItem": (args2) => `Otpusti na ${args2.itemText}`,
  "dropOnRoot": `Otpusti na`,
  "endDragKeyboard": `Prevlačenje u toku. Pritisnite Enter da biste otkazali prevlačenje.`,
  "endDragTouch": `Prevlačenje u toku. Dvaput dodirnite da biste otkazali prevlačenje.`,
  "endDragVirtual": `Prevlačenje u toku. Kliknite da biste otkazali prevlačenje.`,
  "insertAfter": (args2) => `Umetnite posle ${args2.itemText}`,
  "insertBefore": (args2) => `Umetnite ispred ${args2.itemText}`,
  "insertBetween": (args2) => `Umetnite između ${args2.beforeItemText} i ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/sv-SE.mjs
var $d576b66176f5c0ff$exports = {};
$d576b66176f5c0ff$exports = {
  "dragDescriptionKeyboard": `Tryck på enter för att börja dra.`,
  "dragDescriptionKeyboardAlt": `Tryck på Alt + Retur för att börja dra.`,
  "dragDescriptionLongPress": `Tryck länge för att börja dra.`,
  "dragDescriptionTouch": `Dubbeltryck för att börja dra.`,
  "dragDescriptionVirtual": `Klicka för att börja dra.`,
  "dragItem": (args2) => `Dra ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} valt objekt`,
    other: () => `${formatter.number(args2.count)} valda objekt`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Tryck på Retur för att dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} markerat objekt`,
    other: () => `${formatter.number(args2.count)} markerade objekt`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Tryck på Alt + Retur för att dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} markerat objekt`,
    other: () => `${formatter.number(args2.count)} markerade objekt`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Tryck länge för att dra ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} markerat objekt`,
    other: () => `${formatter.number(args2.count)} markerade objekt`
  })}.`,
  "dragStartedKeyboard": `Börja dra. Tryck på tabb för att navigera till målet, tryck på enter för att släppa eller på escape för att avbryta.`,
  "dragStartedTouch": `Börja dra. Navigera till ett mål och dubbeltryck för att släppa.`,
  "dragStartedVirtual": `Börja dra. Navigera till ett mål och klicka eller tryck på enter för att släppa.`,
  "dropCanceled": `Släppåtgärd avbröts.`,
  "dropComplete": `Släppåtgärd klar.`,
  "dropDescriptionKeyboard": `Tryck på enter för att släppa. Tryck på escape för att avbryta dragåtgärd.`,
  "dropDescriptionTouch": `Dubbeltryck för att släppa.`,
  "dropDescriptionVirtual": `Klicka för att släppa.`,
  "dropIndicator": `släppindikator`,
  "dropOnItem": (args2) => `Släpp på ${args2.itemText}`,
  "dropOnRoot": `Släpp på`,
  "endDragKeyboard": `Drar. Tryck på enter för att avbryta dragåtgärd.`,
  "endDragTouch": `Drar. Dubbeltryck för att avbryta dragåtgärd.`,
  "endDragVirtual": `Drar. Klicka för att avbryta dragåtgärd.`,
  "insertAfter": (args2) => `Infoga efter ${args2.itemText}`,
  "insertBefore": (args2) => `Infoga före ${args2.itemText}`,
  "insertBetween": (args2) => `Infoga mellan ${args2.beforeItemText} och ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/tr-TR.mjs
var $0681f168c13d8f2a$exports = {};
$0681f168c13d8f2a$exports = {
  "dragDescriptionKeyboard": `Sürüklemeyi başlatmak için Enter'a basın.`,
  "dragDescriptionKeyboardAlt": `Sürüklemeyi başlatmak için Alt + Enter'a basın.`,
  "dragDescriptionLongPress": `Sürüklemeye başlamak için uzun basın.`,
  "dragDescriptionTouch": `Sürüklemeyi başlatmak için çift tıklayın.`,
  "dragDescriptionVirtual": `Sürüklemeyi başlatmak için tıklayın.`,
  "dragItem": (args2) => `${args2.itemText}’i sürükle`,
  "dragSelectedItems": (args2, formatter) => `Sürükle ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} seçili öge`,
    other: () => `${formatter.number(args2.count)} seçili öge`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args2.count)} seçilmiş öğe`
  })} öğesini sürüklemek için Enter'a basın.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args2.count)} seçilmiş öğe`
  })} öğesini sürüklemek için Alt + Enter tuşuna basın.`,
  "dragSelectedLongPress": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args2.count)} seçilmiş öğe`
  })} öğesini sürüklemek için uzun basın.`,
  "dragStartedKeyboard": `Sürükleme başlatıldı. Bir bırakma hedefine gitmek için Tab’a basın, ardından bırakmak için Enter’a basın veya iptal etmek için Escape’e basın.`,
  "dragStartedTouch": `Sürükleme başlatıldı. Bir bırakma hedefine gidin, ardından bırakmak için çift tıklayın.`,
  "dragStartedVirtual": `Sürükleme başlatıldı. Bir bırakma hedefine gidin, ardından bırakmak için Enter’a tıklayın veya basın.`,
  "dropCanceled": `Bırakma iptal edildi.`,
  "dropComplete": `Bırakma tamamlandı.`,
  "dropDescriptionKeyboard": `Bırakmak için Enter'a basın. Sürüklemeyi iptal etmek için Escape'e basın.`,
  "dropDescriptionTouch": `Bırakmak için çift tıklayın.`,
  "dropDescriptionVirtual": `Bırakmak için tıklayın.`,
  "dropIndicator": `bırakma göstergesi`,
  "dropOnItem": (args2) => `${args2.itemText} üzerine bırak`,
  "dropOnRoot": `Bırakın`,
  "endDragKeyboard": `Sürükleme. Sürüklemeyi iptal etmek için Enter'a basın.`,
  "endDragTouch": `Sürükleme. Sürüklemeyi iptal etmek için çift tıklayın.`,
  "endDragVirtual": `Sürükleme. Sürüklemeyi iptal etmek için tıklayın.`,
  "insertAfter": (args2) => `${args2.itemText}’den sonra gir`,
  "insertBefore": (args2) => `${args2.itemText}’den önce gir`,
  "insertBetween": (args2) => `${args2.beforeItemText} ve ${args2.afterItemText} arasına gir`
};

// node_modules/@react-aria/dnd/dist/uk-UA.mjs
var $2bfbc1f42c1cf5a7$exports = {};
$2bfbc1f42c1cf5a7$exports = {
  "dragDescriptionKeyboard": `Натисніть Enter, щоб почати перетягування.`,
  "dragDescriptionKeyboardAlt": `Натисніть Alt + Enter, щоб почати перетягування.`,
  "dragDescriptionLongPress": `Натисніть і утримуйте, щоб почати перетягування.`,
  "dragDescriptionTouch": `Натисніть двічі, щоб почати перетягування.`,
  "dragDescriptionVirtual": `Натисніть, щоб почати перетягування.`,
  "dragItem": (args2) => `Перетягнути ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `Перетягніть ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} вибраний елемент`,
    other: () => `${formatter.number(args2.count)} вибраних елем`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `Натисніть Enter, щоб перетягнути ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} вибраний елемент`,
    other: () => `${formatter.number(args2.count)} вибраних елементи(-ів)`
  })}.`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `Натисніть Alt + Enter, щоб перетягнути ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} вибраний елемент`,
    other: () => `${formatter.number(args2.count)} вибраних елементи(-ів)`
  })}.`,
  "dragSelectedLongPress": (args2, formatter) => `Утримуйте, щоб перетягнути ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} вибраний елемент`,
    other: () => `${formatter.number(args2.count)} вибраних елементи(-ів)`
  })}.`,
  "dragStartedKeyboard": `Перетягування почалося. Натисніть Tab, щоб перейти до цілі перетягування, потім натисніть Enter, щоб перетягнути, або Escape, щоб скасувати.`,
  "dragStartedTouch": `Перетягування почалося. Перейдіть до цілі перетягування, потім натисніть двічі, щоб перетягнути.`,
  "dragStartedVirtual": `Перетягування почалося. Перейдіть до цілі перетягування, потім натисніть Enter, щоб перетягнути.`,
  "dropCanceled": `Перетягування скасовано.`,
  "dropComplete": `Перетягування завершено.`,
  "dropDescriptionKeyboard": `Натисніть Enter, щоб перетягнути. Натисніть Escape, щоб скасувати перетягування.`,
  "dropDescriptionTouch": `Натисніть двічі, щоб перетягнути.`,
  "dropDescriptionVirtual": `Натисніть, щоб перетягнути.`,
  "dropIndicator": `індикатор перетягування`,
  "dropOnItem": (args2) => `Перетягнути на ${args2.itemText}`,
  "dropOnRoot": `Перетягнути на`,
  "endDragKeyboard": `Триває перетягування. Натисніть Enter, щоб скасувати перетягування.`,
  "endDragTouch": `Триває перетягування. Натисніть двічі, щоб скасувати перетягування.`,
  "endDragVirtual": `Триває перетягування. Натисніть, щоб скасувати перетягування.`,
  "insertAfter": (args2) => `Вставити після ${args2.itemText}`,
  "insertBefore": (args2) => `Вставити перед ${args2.itemText}`,
  "insertBetween": (args2) => `Вставити між ${args2.beforeItemText} і ${args2.afterItemText}`
};

// node_modules/@react-aria/dnd/dist/zh-CN.mjs
var $d0f488d433b55b8a$exports = {};
$d0f488d433b55b8a$exports = {
  "dragDescriptionKeyboard": `按 Enter 开始拖动。`,
  "dragDescriptionKeyboardAlt": `按 Alt + Enter 开始拖动。`,
  "dragDescriptionLongPress": `长按以开始拖动。`,
  "dragDescriptionTouch": `双击开始拖动。`,
  "dragDescriptionVirtual": `单击开始拖动。`,
  "dragItem": (args2) => `拖动 ${args2.itemText}`,
  "dragSelectedItems": (args2, formatter) => `拖动 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 选中项目`,
    other: () => `${formatter.number(args2.count)} 选中项目`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `按 Enter 以拖动 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 个选定项`,
    other: () => `${formatter.number(args2.count)} 个选定项`
  })}。`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `按 Alt + Enter 以拖动 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 个选定项`,
    other: () => `${formatter.number(args2.count)} 个选定项`
  })}。`,
  "dragSelectedLongPress": (args2, formatter) => `长按以拖动 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 个选定项`,
    other: () => `${formatter.number(args2.count)} 个选定项`
  })}。`,
  "dragStartedKeyboard": `已开始拖动。按 Tab 导航到放置目标，然后按 Enter 放置或按 Escape 取消。`,
  "dragStartedTouch": `已开始拖动。导航到放置目标，然后双击放置。`,
  "dragStartedVirtual": `已开始拖动。导航到放置目标，然后单击或按 Enter 放置。`,
  "dropCanceled": `放置已取消。`,
  "dropComplete": `放置已完成。`,
  "dropDescriptionKeyboard": `按 Enter 放置。按 Escape 取消拖动。`,
  "dropDescriptionTouch": `双击放置。`,
  "dropDescriptionVirtual": `单击放置。`,
  "dropIndicator": `放置标记`,
  "dropOnItem": (args2) => `放置于 ${args2.itemText}`,
  "dropOnRoot": `放置于`,
  "endDragKeyboard": `正在拖动。按 Enter 取消拖动。`,
  "endDragTouch": `正在拖动。双击取消拖动。`,
  "endDragVirtual": `正在拖动。单击取消拖动。`,
  "insertAfter": (args2) => `插入到 ${args2.itemText} 之后`,
  "insertBefore": (args2) => `插入到 ${args2.itemText} 之前`,
  "insertBetween": (args2) => `插入到 ${args2.beforeItemText} 和 ${args2.afterItemText} 之间`
};

// node_modules/@react-aria/dnd/dist/zh-TW.mjs
var $46168b0dce85301e$exports = {};
$46168b0dce85301e$exports = {
  "dragDescriptionKeyboard": `按 Enter 鍵以開始拖曳。`,
  "dragDescriptionKeyboardAlt": `按 Alt+Enter 鍵以開始拖曳。`,
  "dragDescriptionLongPress": `長按以開始拖曳。`,
  "dragDescriptionTouch": `輕點兩下以開始拖曳。`,
  "dragDescriptionVirtual": `按一下滑鼠以開始拖曳。`,
  "dragItem": (args2) => `拖曳「${args2.itemText}」`,
  "dragSelectedItems": (args2, formatter) => `拖曳 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個選定項目`,
    other: () => `${formatter.number(args2.count)} 個選定項目`
  })}`,
  "dragSelectedKeyboard": (args2, formatter) => `按 Enter 鍵以拖曳 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個選定項目`,
    other: () => `${formatter.number(args2.count)} 個選定項目`
  })}。`,
  "dragSelectedKeyboardAlt": (args2, formatter) => `按 Alt+Enter 鍵以拖曳 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個選定項目`,
    other: () => `${formatter.number(args2.count)} 個選定項目`
  })}。`,
  "dragSelectedLongPress": (args2, formatter) => `長按以拖曳 ${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個選定項目`,
    other: () => `${formatter.number(args2.count)} 個選定項目`
  })}。`,
  "dragStartedKeyboard": `已開始拖曳。按 Tab 鍵以瀏覽至放置目標，然後按 Enter 鍵以放置，或按 Escape 鍵以取消。`,
  "dragStartedTouch": `已開始拖曳。瀏覽至放置目標，然後輕點兩下以放置。`,
  "dragStartedVirtual": `已開始拖曳。瀏覽至放置目標，然後按一下滑鼠或按 Enter 鍵以放置。`,
  "dropCanceled": `放置已取消。`,
  "dropComplete": `放置已完成。`,
  "dropDescriptionKeyboard": `按 Enter 鍵以放置。按 Escape 鍵以取消拖曳。`,
  "dropDescriptionTouch": `輕點兩下以放置。`,
  "dropDescriptionVirtual": `按一下滑鼠以放置。`,
  "dropIndicator": `放置指示器`,
  "dropOnItem": (args2) => `放置在「${args2.itemText}」上`,
  "dropOnRoot": `放置在`,
  "endDragKeyboard": `拖曳中。按 Enter 鍵以取消拖曳。`,
  "endDragTouch": `拖曳中。輕點兩下以取消拖曳。`,
  "endDragVirtual": `拖曳中。按一下滑鼠以取消拖曳。`,
  "insertAfter": (args2) => `插入至「${args2.itemText}」之後`,
  "insertBefore": (args2) => `插入至「${args2.itemText}」之前`,
  "insertBetween": (args2) => `插入至「${args2.beforeItemText}」和「${args2.afterItemText}」之間`
};

// node_modules/@react-aria/dnd/dist/intlStrings.mjs
var $865c2eb7c00a83f1$exports = {};
$865c2eb7c00a83f1$exports = {
  "ar-AE": $7dfcac1a0c98c789$exports,
  "bg-BG": $f311c26671219eca$exports,
  "cs-CZ": $1aa4ade186550f72$exports,
  "da-DK": $b6b0ea1b94a7633c$exports,
  "de-DE": $d10e4f47c744ad52$exports,
  "el-GR": $b3d2bb9abce688ab$exports,
  "en-US": $f9b46437e610cca1$exports,
  "es-ES": $204b5c01bd3acf26$exports,
  "et-EE": $110bdd83348ecbc0$exports,
  "fi-FI": $87d3ccd5e347c7cc$exports,
  "fr-FR": $a5de891427686596$exports,
  "he-IL": $ad7f4c66d85b4494$exports,
  "hr-HR": $4aa59f3c6a796cae$exports,
  "hu-HU": $d8d3646556c40586$exports,
  "it-IT": $982d558b45395246$exports,
  "ja-JP": $6a0cf387b9de036c$exports,
  "ko-KR": $a97fefa2956f4bcb$exports,
  "lt-LT": $5fb5837f94e1c150$exports,
  "lv-LV": $5b2e5709864cc922$exports,
  "nb-NO": $ee15bb8efb18cc69$exports,
  "nl-NL": $1daf2d4602e26ac4$exports,
  "pl-PL": $7115429b0f60511f$exports,
  "pt-BR": $5edd453ae5d4a8bc$exports,
  "pt-PT": $5f431994f708535e$exports,
  "ro-RO": $107b5e2e45e971f1$exports,
  "ru-RU": $d4b9c2f01c1892f7$exports,
  "sk-SK": $dbdc1942894e83e4$exports,
  "sl-SI": $fbaaaaebd547d998$exports,
  "sr-SP": $a0caa33f1e264489$exports,
  "sv-SE": $d576b66176f5c0ff$exports,
  "tr-TR": $0681f168c13d8f2a$exports,
  "uk-UA": $2bfbc1f42c1cf5a7$exports,
  "zh-CN": $d0f488d433b55b8a$exports,
  "zh-TW": $46168b0dce85301e$exports
};

// node_modules/@react-aria/dnd/dist/useDrag.mjs
var import_react81 = __toESM(require_react(), 1);
function $parcel$interopDefault2(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $8253ed7ece74b463$var$MESSAGES = {
  keyboard: {
    start: "dragDescriptionKeyboard",
    end: "endDragKeyboard"
  },
  touch: {
    start: "dragDescriptionTouch",
    end: "endDragTouch"
  },
  virtual: {
    start: "dragDescriptionVirtual",
    end: "endDragVirtual"
  }
};
function $8253ed7ece74b463$export$7941f8aafa4b6021(options) {
  let { hasDragButton, isDisabled } = options;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)), "@react-aria/dnd");
  let state = (0, import_react81.useRef)({
    options,
    x: 0,
    y: 0
  }).current;
  state.options = options;
  let isDraggingRef = (0, import_react81.useRef)(false);
  let [isDragging, setDraggingState] = (0, import_react81.useState)(false);
  let setDragging = (isDragging2) => {
    isDraggingRef.current = isDragging2;
    setDraggingState(isDragging2);
  };
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let modalityOnPointerDown = (0, import_react81.useRef)(null);
  let onDragStart = (e4) => {
    var _options_preview;
    if (e4.defaultPrevented) return;
    e4.stopPropagation();
    if (modalityOnPointerDown.current === "virtual") {
      e4.preventDefault();
      startDragging(e4.target);
      modalityOnPointerDown.current = null;
      return;
    }
    if (typeof options.onDragStart === "function") options.onDragStart({
      type: "dragstart",
      x: e4.clientX,
      y: e4.clientY
    });
    let items = options.getItems();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e4.dataTransfer, items);
    let allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all;
    if (typeof options.getAllowedDropOperations === "function") {
      let allowedOperations = options.getAllowedDropOperations();
      allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
      for (let operation of allowedOperations) allowed |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation] || (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
    }
    (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)(allowed);
    e4.dataTransfer.effectAllowed = (0, $103790afe9474d1c$export$dd0165308d8bff45)[allowed] || "none";
    if (typeof ((_options_preview = options.preview) === null || _options_preview === void 0 ? void 0 : _options_preview.current) === "function") options.preview.current(items, (node2) => {
      let size3 = node2.getBoundingClientRect();
      let rect = e4.currentTarget.getBoundingClientRect();
      let x3 = e4.clientX - rect.x;
      let y3 = e4.clientY - rect.y;
      if (x3 > size3.width || y3 > size3.height) {
        x3 = size3.width / 2;
        y3 = size3.height / 2;
      }
      let height = 2 * Math.round(size3.height / 2);
      node2.style.height = `${height}px`;
      e4.dataTransfer.setDragImage(node2, x3, y3);
    });
    addGlobalListener(window, "drop", (e5) => {
      e5.preventDefault();
      e5.stopPropagation();
      console.warn("Drags initiated from the React Aria useDrag hook may only be dropped on a target created with useDrop. This ensures that a keyboard and screen reader accessible alternative is available.");
    }, {
      once: true
    });
    state.x = e4.clientX;
    state.y = e4.clientY;
    requestAnimationFrame(() => {
      setDragging(true);
    });
  };
  let onDrag = (e4) => {
    e4.stopPropagation();
    if (e4.clientX === state.x && e4.clientY === state.y) return;
    if (typeof options.onDragMove === "function") options.onDragMove({
      type: "dragmove",
      x: e4.clientX,
      y: e4.clientY
    });
    state.x = e4.clientX;
    state.y = e4.clientY;
  };
  let onDragEnd = (e4) => {
    e4.stopPropagation();
    if (typeof options.onDragEnd === "function") {
      let event = {
        type: "dragend",
        x: e4.clientX,
        y: e4.clientY,
        dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[e4.dataTransfer.dropEffect]
      };
      if (0, $7252cd45fc48c07c$export$8e6636520ac15722) event.dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[0, $7252cd45fc48c07c$export$8e6636520ac15722];
      options.onDragEnd(event);
    }
    setDragging(false);
    removeAllGlobalListeners();
    (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);
    (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
  };
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      if (isDraggingRef.current) {
        if (typeof state.options.onDragEnd === "function") {
          let event = {
            type: "dragend",
            x: 0,
            y: 0,
            dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[(0, $7252cd45fc48c07c$export$8e6636520ac15722) || "none"]
          };
          state.options.onDragEnd(event);
        }
        setDragging(false);
        (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);
        (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
      }
    };
  }, [
    state
  ]);
  let onPress = (e4) => {
    if (e4.pointerType !== "keyboard" && e4.pointerType !== "virtual") return;
    startDragging(e4.target);
  };
  let startDragging = (target) => {
    if (typeof state.options.onDragStart === "function") {
      let rect = target.getBoundingClientRect();
      state.options.onDragStart({
        type: "dragstart",
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
      });
    }
    $67560de7c78cb232$export$549dbcf8649bf3b2({
      element: target,
      items: state.options.getItems(),
      allowedDropOperations: typeof state.options.getAllowedDropOperations === "function" ? state.options.getAllowedDropOperations() : [
        "move",
        "copy",
        "link"
      ],
      onDragEnd(e4) {
        setDragging(false);
        if (typeof state.options.onDragEnd === "function") state.options.onDragEnd(e4);
      }
    }, stringFormatter);
    setDragging(true);
  };
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  let message = !isDragging ? $8253ed7ece74b463$var$MESSAGES[modality].start : $8253ed7ece74b463$var$MESSAGES[modality].end;
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(stringFormatter.format(message));
  let interactions;
  if (!hasDragButton)
    interactions = {
      ...descriptionProps,
      onPointerDown(e4) {
        modalityOnPointerDown.current = (0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e4.nativeEvent) ? "virtual" : e4.pointerType;
        if (e4.width < 1 && e4.height < 1)
          modalityOnPointerDown.current = "virtual";
        else {
          let rect = e4.currentTarget.getBoundingClientRect();
          let offsetX = e4.clientX - rect.x;
          let offsetY = e4.clientY - rect.y;
          let centerX = rect.width / 2;
          let centerY = rect.height / 2;
          if (Math.abs(offsetX - centerX) <= 0.5 && Math.abs(offsetY - centerY) <= 0.5)
            modalityOnPointerDown.current = "virtual";
          else modalityOnPointerDown.current = e4.pointerType;
        }
      },
      onKeyDownCapture(e4) {
        if (e4.target === e4.currentTarget && e4.key === "Enter") {
          e4.preventDefault();
          e4.stopPropagation();
        }
      },
      onKeyUpCapture(e4) {
        if (e4.target === e4.currentTarget && e4.key === "Enter") {
          e4.preventDefault();
          e4.stopPropagation();
          startDragging(e4.target);
        }
      },
      onClick(e4) {
        if ((0, $6a7db85432448f7f$export$60278871457622de)(e4.nativeEvent) || modalityOnPointerDown.current === "virtual") {
          e4.preventDefault();
          e4.stopPropagation();
          startDragging(e4.target);
        }
      }
    };
  if (isDisabled) return {
    dragProps: {
      draggable: "false"
    },
    dragButtonProps: {},
    isDragging: false
  };
  return {
    dragProps: {
      ...interactions,
      draggable: "true",
      onDragStart,
      onDrag,
      onDragEnd
    },
    dragButtonProps: {
      ...descriptionProps,
      onPress
    },
    isDragging
  };
}

// node_modules/@react-aria/dnd/dist/useVirtualDrop.mjs
function $parcel$interopDefault3(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $224594fe3e57ff1e$var$MESSAGES = {
  keyboard: "dropDescriptionKeyboard",
  touch: "dropDescriptionTouch",
  virtual: "dropDescriptionVirtual"
};
function $224594fe3e57ff1e$export$62447ad3d2ec7da6() {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($865c2eb7c00a83f1$exports)), "@react-aria/dnd");
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(dragSession ? stringFormatter.format($224594fe3e57ff1e$var$MESSAGES[modality]) : "");
  return {
    dropProps: {
      ...descriptionProps,
      // Mobile Safari does not properly bubble click events on elements except links or inputs
      // unless there is an onclick handler bound directly to the element itself. By adding this
      // handler, React will take care of adding that for us, and we are able to handle document
      // level click events in the DragManager.
      // See https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
      onClick: () => {
      }
    }
  };
}

// node_modules/@react-aria/dnd/dist/useDrop.mjs
var import_react82 = __toESM(require_react(), 1);
var $5c06e4929e123553$var$DROP_ACTIVATE_TIMEOUT = 800;
function $5c06e4929e123553$export$ccdee5eaf73cf661(options) {
  let { hasDropButton, isDisabled } = options;
  let [isDropTarget, setDropTarget] = (0, import_react82.useState)(false);
  let state = (0, import_react82.useRef)({
    x: 0,
    y: 0,
    dragOverElements: /* @__PURE__ */ new Set(),
    dropEffect: "none",
    allowedOperations: (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all,
    dropActivateTimer: null
  }).current;
  let fireDropEnter = (e4) => {
    setDropTarget(true);
    if (typeof options.onDropEnter === "function") {
      let rect = e4.currentTarget.getBoundingClientRect();
      options.onDropEnter({
        type: "dropenter",
        x: e4.clientX - rect.x,
        y: e4.clientY - rect.y
      });
    }
  };
  let fireDropExit = (e4) => {
    setDropTarget(false);
    if (typeof options.onDropExit === "function") {
      let rect = e4.currentTarget.getBoundingClientRect();
      options.onDropExit({
        type: "dropexit",
        x: e4.clientX - rect.x,
        y: e4.clientY - rect.y
      });
    }
  };
  let onDragOver = (e4) => {
    e4.preventDefault();
    e4.stopPropagation();
    let allowedOperations = $5c06e4929e123553$var$getAllowedOperations(e4);
    if (e4.clientX === state.x && e4.clientY === state.y && allowedOperations === state.allowedOperations) {
      e4.dataTransfer.dropEffect = state.dropEffect;
      return;
    }
    state.x = e4.clientX;
    state.y = e4.clientY;
    let prevDropEffect = state.dropEffect;
    if (allowedOperations !== state.allowedOperations) {
      let allowedOps = $5c06e4929e123553$var$allowedOperationsToArray(allowedOperations);
      let dropOperation = allowedOps[0];
      if (typeof options.getDropOperation === "function") {
        let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e4.dataTransfer);
        dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperations, options.getDropOperation(types, allowedOps));
      }
      state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    }
    if (typeof options.getDropOperationForPoint === "function") {
      let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e4.dataTransfer);
      let rect = e4.currentTarget.getBoundingClientRect();
      let dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperations, options.getDropOperationForPoint(types, $5c06e4929e123553$var$allowedOperationsToArray(allowedOperations), state.x - rect.x, state.y - rect.y));
      state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    }
    state.allowedOperations = allowedOperations;
    e4.dataTransfer.dropEffect = state.dropEffect;
    if (state.dropEffect === "none" && prevDropEffect !== "none") fireDropExit(e4);
    else if (state.dropEffect !== "none" && prevDropEffect === "none") fireDropEnter(e4);
    if (typeof options.onDropMove === "function" && state.dropEffect !== "none") {
      let rect = e4.currentTarget.getBoundingClientRect();
      options.onDropMove({
        type: "dropmove",
        x: state.x - rect.x,
        y: state.y - rect.y
      });
    }
    clearTimeout(state.dropActivateTimer);
    if (typeof options.onDropActivate === "function" && state.dropEffect !== "none") {
      let rect = e4.currentTarget.getBoundingClientRect();
      state.dropActivateTimer = setTimeout(() => {
        options.onDropActivate({
          type: "dropactivate",
          x: state.x - rect.x,
          y: state.y - rect.y
        });
      }, $5c06e4929e123553$var$DROP_ACTIVATE_TIMEOUT);
    }
  };
  let onDragEnter = (e4) => {
    e4.preventDefault();
    e4.stopPropagation();
    state.dragOverElements.add(e4.target);
    if (state.dragOverElements.size > 1) return;
    let allowedOperationsBits = $5c06e4929e123553$var$getAllowedOperations(e4);
    let allowedOperations = $5c06e4929e123553$var$allowedOperationsToArray(allowedOperationsBits);
    let dropOperation = allowedOperations[0];
    if (typeof options.getDropOperation === "function") {
      let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e4.dataTransfer);
      dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperationsBits, options.getDropOperation(types, allowedOperations));
    }
    if (typeof options.getDropOperationForPoint === "function") {
      let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e4.dataTransfer);
      let rect = e4.currentTarget.getBoundingClientRect();
      dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperationsBits, options.getDropOperationForPoint(types, allowedOperations, e4.clientX - rect.x, e4.clientY - rect.y));
    }
    state.x = e4.clientX;
    state.y = e4.clientY;
    state.allowedOperations = allowedOperationsBits;
    state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    e4.dataTransfer.dropEffect = state.dropEffect;
    if (dropOperation !== "cancel") fireDropEnter(e4);
  };
  let onDragLeave = (e4) => {
    e4.preventDefault();
    e4.stopPropagation();
    state.dragOverElements.delete(e4.target);
    for (let element2 of state.dragOverElements) if (!e4.currentTarget.contains(element2)) state.dragOverElements.delete(element2);
    if (state.dragOverElements.size > 0) return;
    if (state.dropEffect !== "none") fireDropExit(e4);
    clearTimeout(state.dropActivateTimer);
  };
  let onDrop = (e4) => {
    e4.preventDefault();
    e4.stopPropagation();
    (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(state.dropEffect);
    if (typeof options.onDrop === "function") {
      let dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[state.dropEffect];
      let items = (0, $7252cd45fc48c07c$export$d9e760437831f8b3)(e4.dataTransfer);
      let rect = e4.currentTarget.getBoundingClientRect();
      let event = {
        type: "drop",
        x: e4.clientX - rect.x,
        y: e4.clientY - rect.y,
        items,
        dropOperation
      };
      options.onDrop(event);
    }
    let dndStateSnapshot = {
      ...(0, $7252cd45fc48c07c$export$6ca6700462636d0b)
    };
    state.dragOverElements.clear();
    fireDropExit(e4);
    clearTimeout(state.dropActivateTimer);
    if (dndStateSnapshot.draggingCollectionRef == null) (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
    else
      (0, $7252cd45fc48c07c$export$6c10d32b362bfa5f)(dndStateSnapshot);
  };
  let onDropEnter = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (typeof options.onDropEnter === "function") options.onDropEnter(e4);
  });
  let onDropExit = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (typeof options.onDropExit === "function") options.onDropExit(e4);
  });
  let onDropActivate = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (typeof options.onDropActivate === "function") options.onDropActivate(e4);
  });
  let onKeyboardDrop = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (typeof options.onDrop === "function") options.onDrop(e4);
  });
  let getDropOperationKeyboard = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((types, allowedOperations) => {
    if (options.getDropOperation) return options.getDropOperation(types, allowedOperations);
    return allowedOperations[0];
  });
  let { ref } = options;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (isDisabled) return;
    return $67560de7c78cb232$export$c28d9fb4a54e471a({
      element: ref.current,
      getDropOperation: getDropOperationKeyboard,
      onDropEnter(e4) {
        setDropTarget(true);
        onDropEnter(e4);
      },
      onDropExit(e4) {
        setDropTarget(false);
        onDropExit(e4);
      },
      onDrop: onKeyboardDrop,
      onDropActivate
    });
  }, [
    isDisabled,
    ref,
    getDropOperationKeyboard,
    onDropEnter,
    onDropExit,
    onKeyboardDrop,
    onDropActivate
  ]);
  let { dropProps } = (0, $224594fe3e57ff1e$export$62447ad3d2ec7da6)();
  if (isDisabled) return {
    dropProps: {},
    dropButtonProps: {
      isDisabled: true
    },
    isDropTarget: false
  };
  return {
    dropProps: {
      ...!hasDropButton && dropProps,
      onDragEnter,
      onDragOver,
      onDragLeave,
      onDrop
    },
    dropButtonProps: {
      ...hasDropButton && dropProps
    },
    isDropTarget
  };
}
function $5c06e4929e123553$var$getAllowedOperations(e4) {
  let allowedOperations = (0, $103790afe9474d1c$export$9bbdfc78cf083e16)[e4.dataTransfer.effectAllowed];
  if (0, $7252cd45fc48c07c$export$f0130eb70b6347b8) allowedOperations &= (0, $7252cd45fc48c07c$export$f0130eb70b6347b8);
  let allowedModifiers = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
  if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) {
    if (e4.altKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy;
    if (e4.ctrlKey && !(0, $c87311424ea30a05$export$7bef049ce92e4224)()) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link;
    if (e4.metaKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move;
  } else {
    if (e4.altKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link;
    if (e4.shiftKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move;
    if (e4.ctrlKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy;
  }
  if (allowedModifiers) return allowedOperations & allowedModifiers;
  return allowedOperations;
}
function $5c06e4929e123553$var$allowedOperationsToArray(allowedOperationsBits) {
  let allowedOperations = [];
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move) allowedOperations.push("move");
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy) allowedOperations.push("copy");
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link) allowedOperations.push("link");
  return allowedOperations;
}
function $5c06e4929e123553$var$getDropOperation(allowedOperations, operation) {
  let op = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation];
  return allowedOperations & op ? operation : "cancel";
}

// node_modules/@react-aria/dnd/dist/useAutoScroll.mjs
var import_react83 = __toESM(require_react(), 1);
var $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE = 20;
function $80d9daea3067eff3$export$6323452ca4533ed8(ref) {
  let scrollableRef = (0, import_react83.useRef)(null);
  let scrollableX = (0, import_react83.useRef)(true);
  let scrollableY = (0, import_react83.useRef)(true);
  (0, import_react83.useEffect)(() => {
    if (ref.current) {
      scrollableRef.current = (0, $cc38e7bd3fc7b213$export$2bb74740c4e19def)(ref.current) ? ref.current : (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current);
      let style = window.getComputedStyle(scrollableRef.current);
      scrollableX.current = /(auto|scroll)/.test(style.overflowX);
      scrollableY.current = /(auto|scroll)/.test(style.overflowY);
    }
  }, [
    ref
  ]);
  let state = (0, import_react83.useRef)({
    timer: null,
    dx: 0,
    dy: 0
  }).current;
  (0, import_react83.useEffect)(() => {
    return () => {
      if (state.timer) {
        cancelAnimationFrame(state.timer);
        state.timer = null;
      }
    };
  }, [
    state
  ]);
  let scroll = (0, import_react83.useCallback)(() => {
    if (scrollableX.current) scrollableRef.current.scrollLeft += state.dx;
    if (scrollableY.current) scrollableRef.current.scrollTop += state.dy;
    if (state.timer) state.timer = requestAnimationFrame(scroll);
  }, [
    scrollableRef,
    state
  ]);
  return {
    move(x3, y3) {
      if (!(0, $c87311424ea30a05$export$78551043582a6a98)() || (0, $c87311424ea30a05$export$fedb369cb70207f1)() || !scrollableRef.current) return;
      let box = scrollableRef.current.getBoundingClientRect();
      let left = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let top = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let bottom = box.height - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let right = box.width - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      if (x3 < left || x3 > right || y3 < top || y3 > bottom) {
        if (x3 < left) state.dx = x3 - left;
        else if (x3 > right) state.dx = x3 - right;
        if (y3 < top) state.dy = y3 - top;
        else if (y3 > bottom) state.dy = y3 - bottom;
        if (!state.timer) state.timer = requestAnimationFrame(scroll);
      } else this.stop();
    },
    stop() {
      if (state.timer) {
        cancelAnimationFrame(state.timer);
        state.timer = null;
      }
    }
  };
}

// node_modules/@react-aria/dnd/dist/useDroppableCollection.mjs
var import_react84 = __toESM(require_react(), 1);
var $4b52e4eff84e5217$var$DROP_POSITIONS = [
  "before",
  "on",
  "after"
];
var $4b52e4eff84e5217$var$DROP_POSITIONS_RTL = [
  "after",
  "on",
  "before"
];
function $4b52e4eff84e5217$export$f4e2f423c21f7b04(props, state, ref) {
  let localState = (0, import_react84.useRef)({
    props,
    state,
    nextTarget: null,
    dropOperation: null
  }).current;
  localState.props = props;
  localState.state = state;
  let defaultOnDrop = (0, import_react84.useCallback)(async (e4) => {
    let { onInsert, onRootDrop, onItemDrop, onReorder, acceptedDragTypes = "all", shouldAcceptItemDrop } = localState.props;
    let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
    let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
    let { target, dropOperation, items } = e4;
    let filteredItems = items;
    if (acceptedDragTypes !== "all" || shouldAcceptItemDrop) filteredItems = items.filter((item) => {
      let itemTypes;
      if (item.kind === "directory") itemTypes = /* @__PURE__ */ new Set([
        (0, $7252cd45fc48c07c$export$990fced5dfac2637)
      ]);
      else itemTypes = item.kind === "file" ? /* @__PURE__ */ new Set([
        item.type
      ]) : item.types;
      if (acceptedDragTypes === "all" || acceptedDragTypes.some((type3) => itemTypes.has(type3))) {
        if (target.type === "item" && target.dropPosition === "on" && shouldAcceptItemDrop) return shouldAcceptItemDrop(target, itemTypes);
        return true;
      }
      return false;
    });
    if (filteredItems.length > 0) {
      if (target.type === "root" && onRootDrop) await onRootDrop({
        items: filteredItems,
        dropOperation
      });
      if (target.type === "item") {
        if (target.dropPosition === "on" && onItemDrop) await onItemDrop({
          items: filteredItems,
          dropOperation,
          isInternal,
          target
        });
        if (target.dropPosition !== "on") {
          if (!isInternal && onInsert) await onInsert({
            items: filteredItems,
            dropOperation,
            target
          });
          if (isInternal && onReorder) await onReorder({
            keys: draggingKeys,
            dropOperation,
            target
          });
        }
      }
    }
  }, [
    localState,
    ref
  ]);
  let autoScroll = (0, $80d9daea3067eff3$export$6323452ca4533ed8)(ref);
  let { dropProps } = (0, $5c06e4929e123553$export$ccdee5eaf73cf661)({
    ref,
    onDropEnter() {
      state.setTarget(localState.nextTarget);
    },
    onDropMove(e4) {
      state.setTarget(localState.nextTarget);
      autoScroll.move(e4.x, e4.y);
    },
    getDropOperationForPoint(types, allowedOperations, x3, y3) {
      let { draggingKeys, dropCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
      let isValidDropTarget = (target2) => state.getDropOperation({
        target: target2,
        types,
        allowedOperations,
        isInternal,
        draggingKeys
      }) !== "cancel";
      let target = props.dropTargetDelegate.getDropTargetFromPoint(x3, y3, isValidDropTarget);
      if (!target) {
        localState.dropOperation = "cancel";
        localState.nextTarget = null;
        return "cancel";
      }
      localState.dropOperation = state.getDropOperation({
        target,
        types,
        allowedOperations,
        isInternal,
        draggingKeys
      });
      if (localState.dropOperation === "cancel") {
        let rootTarget = {
          type: "root"
        };
        let dropOperation = state.getDropOperation({
          target: rootTarget,
          types,
          allowedOperations,
          isInternal,
          draggingKeys
        });
        if (dropOperation !== "cancel") {
          target = rootTarget;
          localState.dropOperation = dropOperation;
        }
      }
      if (target && localState.dropOperation !== "cancel" && (ref === null || ref === void 0 ? void 0 : ref.current) !== (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current)) (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
      localState.nextTarget = localState.dropOperation === "cancel" ? null : target;
      return localState.dropOperation;
    },
    onDropExit() {
      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(void 0);
      state.setTarget(null);
      autoScroll.stop();
    },
    onDropActivate(e4) {
      var _state_target, _state_target1;
      if (((_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.type) === "item" && ((_state_target1 = state.target) === null || _state_target1 === void 0 ? void 0 : _state_target1.dropPosition) === "on" && typeof props.onDropActivate === "function") props.onDropActivate({
        type: "dropactivate",
        x: e4.x,
        y: e4.y,
        target: state.target
      });
    },
    onDrop(e4) {
      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
      if (state.target) onDrop(e4, state.target);
      let { draggingCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      if (draggingCollectionRef == null) (0, $7252cd45fc48c07c$export$70936501603e6c57)();
    }
  });
  let droppingState = (0, import_react84.useRef)(null);
  let updateFocusAfterDrop = (0, import_react84.useCallback)(() => {
    let { state: state2 } = localState;
    if (droppingState.current) {
      var _state_collection_getItem;
      let { target, collection: prevCollection, selectedKeys: prevSelectedKeys, focusedKey: prevFocusedKey, isInternal, draggingKeys } = droppingState.current;
      if (state2.collection.size > prevCollection.size && state2.selectionManager.isSelectionEqual(prevSelectedKeys)) {
        let newKeys = /* @__PURE__ */ new Set();
        for (let key of state2.collection.getKeys()) if (!prevCollection.getItem(key)) newKeys.add(key);
        state2.selectionManager.setSelectedKeys(newKeys);
        if (state2.selectionManager.focusedKey === prevFocusedKey) {
          let first = newKeys.keys().next().value;
          let item = state2.collection.getItem(first);
          if ((item === null || item === void 0 ? void 0 : item.type) === "cell") first = item.parentKey;
          state2.selectionManager.setFocusedKey(first);
          if (state2.selectionManager.selectionMode === "none") (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
        }
      } else if (state2.selectionManager.focusedKey === prevFocusedKey && isInternal && target.type === "item" && target.dropPosition !== "on" && draggingKeys.has((_state_collection_getItem = state2.collection.getItem(prevFocusedKey)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.parentKey)) {
        state2.selectionManager.setFocusedKey(state2.collection.getItem(prevFocusedKey).parentKey);
        (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      } else if (state2.selectionManager.focusedKey === prevFocusedKey && target.type === "item" && target.dropPosition === "on" && state2.collection.getItem(target.key) != null) {
        state2.selectionManager.setFocusedKey(target.key);
        (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      } else if (!state2.selectionManager.isSelected(state2.selectionManager.focusedKey)) (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      state2.selectionManager.setFocused(true);
    }
  }, [
    localState
  ]);
  let onDrop = (0, import_react84.useCallback)((e4, target) => {
    let { state: state2 } = localState;
    droppingState.current = {
      timeout: null,
      focusedKey: state2.selectionManager.focusedKey,
      collection: state2.collection,
      selectedKeys: state2.selectionManager.selectedKeys,
      draggingKeys: (0, $7252cd45fc48c07c$export$6ca6700462636d0b).draggingKeys,
      isInternal: (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref),
      target
    };
    let onDropFn = localState.props.onDrop || defaultOnDrop;
    onDropFn({
      type: "drop",
      x: e4.x,
      y: e4.y,
      target,
      items: e4.items,
      dropOperation: e4.dropOperation
    });
    droppingState.current.timeout = setTimeout(() => {
      updateFocusAfterDrop();
      droppingState.current = null;
    }, 50);
  }, [
    localState,
    defaultOnDrop,
    ref,
    updateFocusAfterDrop
  ]);
  (0, import_react84.useEffect)(() => {
    return () => {
      if (droppingState.current) clearTimeout(droppingState.current.timeout);
    };
  }, []);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (droppingState.current && state.collection !== droppingState.current.collection) updateFocusAfterDrop();
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  (0, import_react84.useEffect)(() => {
    let getNextTarget = (target, wrap3 = true, horizontal = false) => {
      if (!target) return {
        type: "root"
      };
      let { keyboardDelegate } = localState.props;
      let nextKey;
      if ((target === null || target === void 0 ? void 0 : target.type) === "item") nextKey = horizontal ? keyboardDelegate.getKeyRightOf(target.key) : keyboardDelegate.getKeyBelow(target.key);
      else nextKey = horizontal && direction === "rtl" ? keyboardDelegate.getLastKey() : keyboardDelegate.getFirstKey();
      let dropPositions = horizontal && direction === "rtl" ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;
      let dropPosition = dropPositions[0];
      if (target.type === "item") {
        let nextCollectionKey = horizontal && direction === "rtl" ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);
        if (nextKey == null || nextKey === nextCollectionKey) {
          let positionIndex = dropPositions.indexOf(target.dropPosition);
          let nextDropPosition = dropPositions[positionIndex + 1];
          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null)) return {
            type: "item",
            key: target.key,
            dropPosition: nextDropPosition
          };
          if (target.dropPosition === dropPositions[2]) dropPosition = "on";
        } else dropPosition = target.dropPosition;
      }
      if (nextKey == null) {
        if (wrap3) return {
          type: "root"
        };
        return null;
      }
      return {
        type: "item",
        key: nextKey,
        dropPosition
      };
    };
    let getPreviousTarget = (target, wrap3 = true, horizontal = false) => {
      let { keyboardDelegate } = localState.props;
      let nextKey;
      if ((target === null || target === void 0 ? void 0 : target.type) === "item") nextKey = horizontal ? keyboardDelegate.getKeyLeftOf(target.key) : keyboardDelegate.getKeyAbove(target.key);
      else nextKey = horizontal && direction === "rtl" ? keyboardDelegate.getFirstKey() : keyboardDelegate.getLastKey();
      let dropPositions = horizontal && direction === "rtl" ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;
      let dropPosition = !target || target.type === "root" ? dropPositions[2] : "on";
      if ((target === null || target === void 0 ? void 0 : target.type) === "item") {
        let prevCollectionKey = horizontal && direction === "rtl" ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);
        if (nextKey == null || nextKey === prevCollectionKey) {
          let positionIndex = dropPositions.indexOf(target.dropPosition);
          let nextDropPosition = dropPositions[positionIndex - 1];
          if (positionIndex > 0 && nextDropPosition !== dropPositions[2]) return {
            type: "item",
            key: target.key,
            dropPosition: nextDropPosition
          };
          if (target.dropPosition === dropPositions[0]) dropPosition = "on";
        } else dropPosition = target.dropPosition;
      }
      if (nextKey == null) {
        if (wrap3) return {
          type: "root"
        };
        return null;
      }
      return {
        type: "item",
        key: nextKey,
        dropPosition
      };
    };
    let nextValidTarget = (target, types, allowedDropOperations, getNextTarget2, wrap3 = true) => {
      let seenRoot = 0;
      let operation;
      let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
      do {
        let nextTarget = getNextTarget2(target, wrap3);
        if (!nextTarget) return null;
        target = nextTarget;
        operation = localState.state.getDropOperation({
          target: nextTarget,
          types,
          allowedOperations: allowedDropOperations,
          isInternal,
          draggingKeys
        });
        if (target.type === "root") seenRoot++;
      } while (operation === "cancel" && !localState.state.isDropTarget(target) && seenRoot < 2);
      if (operation === "cancel") return null;
      return target;
    };
    return $67560de7c78cb232$export$c28d9fb4a54e471a({
      element: ref.current,
      preventFocusOnDrop: true,
      getDropOperation(types, allowedOperations) {
        if (localState.state.target) {
          let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
          return localState.state.getDropOperation({
            target: localState.state.target,
            types,
            allowedOperations,
            isInternal,
            draggingKeys
          });
        }
        let target = nextValidTarget(null, types, allowedOperations, getNextTarget);
        return target ? "move" : "cancel";
      },
      onDropEnter(e4, drag) {
        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);
        let selectionManager = localState.state.selectionManager;
        let target;
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
        let key = selectionManager.focusedKey;
        let dropPosition = "after";
        let item = localState.state.collection.getItem(key);
        if ((item === null || item === void 0 ? void 0 : item.type) === "cell") key = item.parentKey;
        if (selectionManager.isSelected(key)) {
          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key) dropPosition = "before";
          else key = selectionManager.lastSelectedKey;
        }
        if (key != null) {
          target = {
            type: "item",
            key,
            dropPosition
          };
          let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
          var _nextValidTarget;
          if (localState.state.getDropOperation({
            target,
            types,
            allowedOperations: drag.allowedDropOperations,
            isInternal,
            draggingKeys
          }) === "cancel") target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);
        }
        if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
        localState.state.setTarget(target);
      },
      onDropExit() {
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(void 0);
        localState.state.setTarget(null);
      },
      onDropTargetEnter(target) {
        localState.state.setTarget(target);
      },
      onDropActivate(e4) {
        var _localState_state_target, _localState_state_target1;
        if (((_localState_state_target = localState.state.target) === null || _localState_state_target === void 0 ? void 0 : _localState_state_target.type) === "item" && ((_localState_state_target1 = localState.state.target) === null || _localState_state_target1 === void 0 ? void 0 : _localState_state_target1.dropPosition) === "on" && typeof localState.props.onDropActivate === "function") localState.props.onDropActivate({
          type: "dropactivate",
          x: e4.x,
          y: e4.y,
          target: localState.state.target
        });
      },
      onDrop(e4, target) {
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
        if (localState.state.target) onDrop(e4, target || localState.state.target);
      },
      onKeyDown(e4, drag) {
        let { keyboardDelegate } = localState.props;
        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);
        switch (e4.key) {
          case "ArrowDown":
            if (keyboardDelegate.getKeyBelow) {
              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);
              localState.state.setTarget(target);
            }
            break;
          case "ArrowUp":
            if (keyboardDelegate.getKeyAbove) {
              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);
              localState.state.setTarget(target);
            }
            break;
          case "ArrowLeft":
            if (keyboardDelegate.getKeyLeftOf) {
              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target2, wrap3) => getPreviousTarget(target2, wrap3, true));
              localState.state.setTarget(target);
            }
            break;
          case "ArrowRight":
            if (keyboardDelegate.getKeyRightOf) {
              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target2, wrap3) => getNextTarget(target2, wrap3, true));
              localState.state.setTarget(target);
            }
            break;
          case "Home":
            if (keyboardDelegate.getFirstKey) {
              let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
              localState.state.setTarget(target);
            }
            break;
          case "End":
            if (keyboardDelegate.getLastKey) {
              let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);
              localState.state.setTarget(target);
            }
            break;
          case "PageDown":
            if (keyboardDelegate.getKeyPageBelow) {
              let target = localState.state.target;
              if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
              else {
                let nextKey = keyboardDelegate.getKeyPageBelow(target.type === "item" ? target.key : keyboardDelegate.getFirstKey());
                let dropPosition = target.type === "item" ? target.dropPosition : "after";
                if (nextKey == null || target.type === "item" && target.key === keyboardDelegate.getLastKey()) {
                  nextKey = keyboardDelegate.getLastKey();
                  dropPosition = "after";
                }
                target = {
                  type: "item",
                  key: nextKey,
                  dropPosition
                };
                let { draggingCollectionRef, draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
                let isInternal = (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) === (ref === null || ref === void 0 ? void 0 : ref.current);
                let operation = localState.state.getDropOperation({
                  target,
                  types,
                  allowedOperations: drag.allowedDropOperations,
                  isInternal,
                  draggingKeys
                });
                var _nextValidTarget;
                if (operation === "cancel") target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);
              }
              localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);
            }
            break;
          case "PageUp": {
            if (!keyboardDelegate.getKeyPageAbove) break;
            let target = localState.state.target;
            if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);
            else if (target.type === "item") {
              if (target.key === keyboardDelegate.getFirstKey()) target = {
                type: "root"
              };
              else {
                let nextKey = keyboardDelegate.getKeyPageAbove(target.key);
                let dropPosition = target.dropPosition;
                if (nextKey == null) {
                  nextKey = keyboardDelegate.getFirstKey();
                  dropPosition = "before";
                }
                target = {
                  type: "item",
                  key: nextKey,
                  dropPosition
                };
              }
              let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
              let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
              let operation = localState.state.getDropOperation({
                target,
                types,
                allowedOperations: drag.allowedDropOperations,
                isInternal,
                draggingKeys
              });
              var _nextValidTarget1;
              if (operation === "cancel") target = (_nextValidTarget1 = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)) !== null && _nextValidTarget1 !== void 0 ? _nextValidTarget1 : nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);
            }
            localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);
            break;
          }
        }
      }
    });
  }, [
    localState,
    ref,
    onDrop,
    direction
  ]);
  let id2 = (0, $bdb11010cef70236$export$f680877a34711e37)();
  (0, $7252cd45fc48c07c$export$dfdf5deeaf27473f).set(state, {
    id: id2,
    ref
  });
  return {
    collectionProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(dropProps, {
      id: id2,
      // Remove description from collection element. If dropping on the entire collection,
      // there should be a drop indicator that has this description, so no need to double announce.
      "aria-describedby": null
    })
  };
}

// node_modules/@react-aria/dnd/dist/useDroppableItem.mjs
var import_react85 = __toESM(require_react(), 1);
function $bfaab576ce1c580e$export$f7b0c5d28b66b6a5(options, state, ref) {
  let { dropProps } = (0, $224594fe3e57ff1e$export$62447ad3d2ec7da6)();
  let droppableCollectionRef = (0, $7252cd45fc48c07c$export$7e397efd01d3db27)(state);
  (0, import_react85.useEffect)(() => {
    if (ref.current) return $67560de7c78cb232$export$aef80212ac99c003({
      element: ref.current,
      target: options.target,
      getDropOperation(types, allowedOperations) {
        let { draggingKeys: draggingKeys2 } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
        let isInternal2 = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(droppableCollectionRef);
        return state.getDropOperation({
          target: options.target,
          types,
          allowedOperations,
          isInternal: isInternal2,
          draggingKeys: draggingKeys2
        });
      }
    });
  }, [
    ref,
    options.target,
    state,
    droppableCollectionRef
  ]);
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
  let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(droppableCollectionRef);
  let isValidDropTarget = dragSession && state.getDropOperation({
    target: options.target,
    types: (0, $7252cd45fc48c07c$export$e1d41611756c6326)(dragSession.dragTarget.items),
    allowedOperations: dragSession.dragTarget.allowedDropOperations,
    isInternal,
    draggingKeys
  }) !== "cancel";
  let isDropTarget = state.isDropTarget(options.target);
  (0, import_react85.useEffect)(() => {
    if (dragSession && isDropTarget && ref.current) ref.current.focus();
  }, [
    isDropTarget,
    dragSession,
    ref
  ]);
  return {
    dropProps: {
      ...dropProps,
      "aria-hidden": !dragSession || isValidDropTarget ? void 0 : "true"
    },
    isDropTarget
  };
}

// node_modules/@react-aria/dnd/dist/useDropIndicator.mjs
function $parcel$interopDefault4(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
function $ddf25448c71fc93a$export$8d0e41d2815afac5(props, state, ref) {
  let { target } = props;
  let { collection } = state;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault4($865c2eb7c00a83f1$exports)), "@react-aria/dnd");
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let { dropProps } = (0, $bfaab576ce1c580e$export$f7b0c5d28b66b6a5)(props, state, ref);
  let id2 = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let getText = (key) => {
    var _collection_getTextValue, _collection_getItem;
    var _collection_getTextValue1;
    return (_collection_getTextValue1 = (_collection_getTextValue = collection.getTextValue) === null || _collection_getTextValue === void 0 ? void 0 : _collection_getTextValue.call(collection, key)) !== null && _collection_getTextValue1 !== void 0 ? _collection_getTextValue1 : (_collection_getItem = collection.getItem(key)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue;
  };
  let label = "";
  let labelledBy;
  if (target.type === "root") {
    label = stringFormatter.format("dropOnRoot");
    labelledBy = `${id2} ${(0, $7252cd45fc48c07c$export$3093291712f09a77)(state)}`;
  } else if (target.dropPosition === "on") label = stringFormatter.format("dropOnItem", {
    itemText: getText(target.key)
  });
  else {
    let before;
    let after;
    if (collection.getFirstKey() === target.key && target.dropPosition === "before") before = null;
    else before = target.dropPosition === "before" ? collection.getKeyBefore(target.key) : target.key;
    if (collection.getLastKey() === target.key && target.dropPosition === "after") after = null;
    else after = target.dropPosition === "after" ? collection.getKeyAfter(target.key) : target.key;
    if (before && after) label = stringFormatter.format("insertBetween", {
      beforeItemText: getText(before),
      afterItemText: getText(after)
    });
    else if (before) label = stringFormatter.format("insertAfter", {
      itemText: getText(before)
    });
    else if (after) label = stringFormatter.format("insertBefore", {
      itemText: getText(after)
    });
  }
  let isDropTarget = state.isDropTarget(target);
  let ariaHidden = !dragSession ? "true" : dropProps["aria-hidden"];
  return {
    dropIndicatorProps: {
      ...dropProps,
      id: id2,
      "aria-roledescription": stringFormatter.format("dropIndicator"),
      "aria-label": label,
      "aria-labelledby": labelledBy,
      "aria-hidden": ariaHidden,
      tabIndex: -1
    },
    isDropTarget,
    // If aria-hidden, we are either not in a drag session or the drop target is invalid.
    // In that case, there's no need to render anything at all unless we need to show the indicator visually.
    // This can happen when dragging using the native DnD API as opposed to keyboard dragging.
    isHidden: !isDropTarget && !!ariaHidden
  };
}

// node_modules/@react-aria/dnd/dist/useDraggableItem.mjs
function $parcel$interopDefault5(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $fd98cf7cbf233429$var$MESSAGES = {
  keyboard: {
    selected: "dragSelectedKeyboard",
    notSelected: "dragDescriptionKeyboard"
  },
  touch: {
    selected: "dragSelectedLongPress",
    notSelected: "dragDescriptionLongPress"
  },
  virtual: {
    selected: "dragDescriptionVirtual",
    notSelected: "dragDescriptionVirtual"
  }
};
function $fd98cf7cbf233429$export$b35afafff42da2d9(props, state) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault5($865c2eb7c00a83f1$exports)), "@react-aria/dnd");
  let isDisabled = state.isDisabled || state.selectionManager.isDisabled(props.key);
  let { dragProps, dragButtonProps } = (0, $8253ed7ece74b463$export$7941f8aafa4b6021)({
    getItems() {
      return state.getItems(props.key);
    },
    preview: state.preview,
    getAllowedDropOperations: state.getAllowedDropOperations,
    hasDragButton: props.hasDragButton,
    onDragStart(e4) {
      state.startDrag(props.key, e4);
      (0, $7252cd45fc48c07c$export$72cb63bdda528276)(state.draggingKeys);
    },
    onDragMove(e4) {
      state.moveDrag(e4);
    },
    onDragEnd(e4) {
      let { dropOperation } = e4;
      let isInternal = dropOperation === "cancel" ? false : (0, $7252cd45fc48c07c$export$78bf638634500fa5)();
      state.endDrag({
        ...e4,
        keys: state.draggingKeys,
        isInternal
      });
      (0, $7252cd45fc48c07c$export$70936501603e6c57)();
    }
  });
  let item = state.collection.getItem(props.key);
  let numKeysForDrag = state.getKeysForDrag(props.key).size;
  let isSelected = numKeysForDrag > 1 && state.selectionManager.isSelected(props.key);
  let dragButtonLabel;
  let description;
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  if (!props.hasDragButton && state.selectionManager.selectionMode !== "none") {
    let msg2 = $fd98cf7cbf233429$var$MESSAGES[modality][isSelected ? "selected" : "notSelected"];
    if (props.hasAction && modality === "keyboard") msg2 += "Alt";
    if (isSelected) description = stringFormatter.format(msg2, {
      count: numKeysForDrag
    });
    else description = stringFormatter.format(msg2);
    delete dragProps.onClick;
  } else if (isSelected) dragButtonLabel = stringFormatter.format("dragSelectedItems", {
    count: numKeysForDrag
  });
  else {
    var _state_collection_getTextValue, _state_collection;
    var _state_collection_getTextValue1, _ref;
    let itemText = (_ref = (_state_collection_getTextValue1 = (_state_collection_getTextValue = (_state_collection = state.collection).getTextValue) === null || _state_collection_getTextValue === void 0 ? void 0 : _state_collection_getTextValue.call(_state_collection, props.key)) !== null && _state_collection_getTextValue1 !== void 0 ? _state_collection_getTextValue1 : item === null || item === void 0 ? void 0 : item.textValue) !== null && _ref !== void 0 ? _ref : "";
    dragButtonLabel = stringFormatter.format("dragItem", {
      itemText
    });
  }
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(description);
  if (description) Object.assign(dragProps, descriptionProps);
  if (!props.hasDragButton && props.hasAction) {
    let { onKeyDownCapture, onKeyUpCapture } = dragProps;
    if (modality === "touch")
      delete dragProps["aria-describedby"];
    dragProps.onKeyDownCapture = (e4) => {
      if (e4.altKey) onKeyDownCapture === null || onKeyDownCapture === void 0 ? void 0 : onKeyDownCapture(e4);
    };
    dragProps.onKeyUpCapture = (e4) => {
      if (e4.altKey) onKeyUpCapture === null || onKeyUpCapture === void 0 ? void 0 : onKeyUpCapture(e4);
    };
  }
  return {
    dragProps: isDisabled ? {} : dragProps,
    dragButtonProps: {
      ...dragButtonProps,
      isDisabled,
      "aria-label": dragButtonLabel
    }
  };
}

// node_modules/@react-aria/dnd/dist/useDraggableCollection.mjs
function $4ac1fdc3a0fcd564$export$2962a7984b2f0a80(props, state, ref) {
  let { draggingCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
  if (state.draggingKeys.size > 0 && (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) !== ref.current) (0, $7252cd45fc48c07c$export$f2be18a910c0caa6)(ref);
}

// node_modules/@react-aria/dnd/dist/useClipboard.mjs
var import_react86 = __toESM(require_react(), 1);
var $9fcc7f0d70d084ee$var$globalEvents = /* @__PURE__ */ new Map();
function $9fcc7f0d70d084ee$var$addGlobalEventListener(event, fn2) {
  let eventData = $9fcc7f0d70d084ee$var$globalEvents.get(event);
  if (!eventData) {
    let handlers = /* @__PURE__ */ new Set();
    let listener = (e4) => {
      for (let handler of handlers) handler(e4);
    };
    eventData = {
      listener,
      handlers
    };
    $9fcc7f0d70d084ee$var$globalEvents.set(event, eventData);
    document.addEventListener(event, listener);
  }
  eventData.handlers.add(fn2);
  return () => {
    eventData.handlers.delete(fn2);
    if (eventData.handlers.size === 0) {
      document.removeEventListener(event, eventData.listener);
      $9fcc7f0d70d084ee$var$globalEvents.delete(event);
    }
  };
}
function $9fcc7f0d70d084ee$export$2314ca2a3e892862(options) {
  let { isDisabled } = options;
  let isFocusedRef = (0, import_react86.useRef)(false);
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    onFocusChange: (isFocused) => {
      isFocusedRef.current = isFocused;
    }
  });
  let onBeforeCopy = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (isFocusedRef.current && options.getItems) e4.preventDefault();
  });
  let onCopy = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    var _options_onCopy;
    if (!isFocusedRef.current || !options.getItems) return;
    e4.preventDefault();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e4.clipboardData, options.getItems());
    (_options_onCopy = options.onCopy) === null || _options_onCopy === void 0 ? void 0 : _options_onCopy.call(options);
  });
  let onBeforeCut = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (isFocusedRef.current && options.onCut && options.getItems) e4.preventDefault();
  });
  let onCut = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (!isFocusedRef.current || !options.onCut || !options.getItems) return;
    e4.preventDefault();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e4.clipboardData, options.getItems());
    options.onCut();
  });
  let onBeforePaste = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (isFocusedRef.current && options.onPaste) e4.preventDefault();
  });
  let onPaste = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e4) => {
    if (!isFocusedRef.current || !options.onPaste) return;
    e4.preventDefault();
    let items = (0, $7252cd45fc48c07c$export$d9e760437831f8b3)(e4.clipboardData);
    options.onPaste(items);
  });
  (0, import_react86.useEffect)(() => {
    if (isDisabled) return;
    return (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($9fcc7f0d70d084ee$var$addGlobalEventListener("beforecopy", onBeforeCopy), $9fcc7f0d70d084ee$var$addGlobalEventListener("copy", onCopy), $9fcc7f0d70d084ee$var$addGlobalEventListener("beforecut", onBeforeCut), $9fcc7f0d70d084ee$var$addGlobalEventListener("cut", onCut), $9fcc7f0d70d084ee$var$addGlobalEventListener("beforepaste", onBeforePaste), $9fcc7f0d70d084ee$var$addGlobalEventListener("paste", onPaste));
  }, [
    isDisabled,
    onBeforeCopy,
    onCopy,
    onBeforeCut,
    onCut,
    onBeforePaste,
    onPaste
  ]);
  return {
    clipboardProps: focusProps
  };
}

// node_modules/@react-aria/dnd/dist/DragPreview.mjs
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_react87 = __toESM(require_react(), 1);
function $ad0e3f3d9c50e4ba$var$DragPreview(props, ref) {
  let render = props.children;
  let [children, setChildren] = (0, import_react87.useState)(null);
  let domRef = (0, import_react87.useRef)(null);
  (0, import_react87.useImperativeHandle)(ref, () => (items, callback) => {
    (0, import_react_dom3.flushSync)(() => {
      setChildren(render(items));
    });
    callback(domRef.current);
    requestAnimationFrame(() => {
      setChildren(null);
    });
  }, [
    render
  ]);
  if (!children) return null;
  return (0, import_react87.default).createElement("div", {
    style: {
      zIndex: -100,
      position: "absolute",
      top: 0,
      left: -1e5
    },
    ref: domRef
  }, children);
}
var $ad0e3f3d9c50e4ba$export$905ab40ac2179daa = (0, import_react87.default).forwardRef($ad0e3f3d9c50e4ba$var$DragPreview);

// node_modules/@keystar/ui/dist/DropZone-46475078.js
var import_react88 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var localizedMessages3 = {
  "ar-AE": {
    "dropzoneLabel": `DropZone`
  },
  "bg-BG": {
    "dropzoneLabel": `DropZone`
  },
  "cs-CZ": {
    "dropzoneLabel": `Místo pro přetažení`
  },
  "da-DK": {
    "dropzoneLabel": `DropZone`
  },
  "de-DE": {
    "dropzoneLabel": `Ablegebereich`
  },
  "el-GR": {
    "dropzoneLabel": `DropZone`
  },
  "en-US": {
    "dropzoneLabel": `DropZone`
  },
  "es-ES": {
    "dropzoneLabel": `DropZone`
  },
  "et-EE": {
    "dropzoneLabel": `DropZone`
  },
  "fi-FI": {
    "dropzoneLabel": `DropZone`
  },
  "fr-FR": {
    "dropzoneLabel": `DropZone`
  },
  "he-IL": {
    "dropzoneLabel": `DropZone`
  },
  "hr-HR": {
    "dropzoneLabel": `Zona spuštanja`
  },
  "hu-HU": {
    "dropzoneLabel": `DropZone`
  },
  "it-IT": {
    "dropzoneLabel": `Zona di rilascio`
  },
  "ja-JP": {
    "dropzoneLabel": `ドロップゾーン`
  },
  "ko-KR": {
    "dropzoneLabel": `드롭 영역`
  },
  "lt-LT": {
    "dropzoneLabel": `„DropZone“`
  },
  "lv-LV": {
    "dropzoneLabel": `DropZone`
  },
  "nb-NO": {
    "dropzoneLabel": `Droppsone`
  },
  "nl-NL": {
    "dropzoneLabel": `DropZone`
  },
  "pl-PL": {
    "dropzoneLabel": `Strefa upuszczania`
  },
  "pt-BR": {
    "dropzoneLabel": `DropZone`
  },
  "pt-PT": {
    "dropzoneLabel": `DropZone`
  },
  "ro-RO": {
    "dropzoneLabel": `Zonă de plasare`
  },
  "ru-RU": {
    "dropzoneLabel": `DropZone`
  },
  "sk-SK": {
    "dropzoneLabel": `DropZone`
  },
  "sl-SI": {
    "dropzoneLabel": `DropZone`
  },
  "sr-SP": {
    "dropzoneLabel": `DropZone`
  },
  "sv-SE": {
    "dropzoneLabel": `DropZone`
  },
  "tr-TR": {
    "dropzoneLabel": `DropZone`
  },
  "uk-UA": {
    "dropzoneLabel": `DropZone`
  },
  "zh-CN": {
    "dropzoneLabel": `放置区域`
  },
  "zh-TW": {
    "dropzoneLabel": `放置區`
  }
};
var dropZoneClassList = new ClassList("DropZone");
var DropZone = forwardRefWithAs(function DropZone2(props, forwardedRef) {
  let dropzoneRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let buttonRef = (0, import_react88.useRef)(null);
  let {
    dropProps,
    dropButtonProps,
    isDropTarget
  } = $5c06e4929e123553$export$ccdee5eaf73cf661({
    ...props,
    ref: buttonRef,
    hasDropButton: true
  });
  let {
    clipboardProps
  } = $9fcc7f0d70d084ee$export$2314ca2a3e892862({
    onPaste: (items) => {
      var _props$onDrop;
      return (_props$onDrop = props.onDrop) === null || _props$onDrop === void 0 ? void 0 : _props$onDrop.call(props, {
        type: "drop",
        items,
        x: 0,
        y: 0,
        dropOperation: "copy"
      });
    }
  });
  let {
    focusProps,
    isFocused,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages3);
  let labelId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let dropzoneId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let ariaLabel = props["aria-label"] || stringFormatter.format("dropzoneLabel");
  let messageId = props["aria-labelledby"];
  let ariaLabelledby = [dropzoneId, labelId, messageId].filter(Boolean).join(" ");
  let labelProps = $313b98861ee5dd6c$export$d6875122194c7b44({
    "aria-labelledby": ariaLabelledby
  });
  let slots = {
    icon: {
      color: isDropTarget ? "accent" : "neutral"
    },
    label: {
      id: labelId,
      color: isDropTarget ? "accent" : void 0
    }
  };
  let renderProps = (0, import_react88.useMemo)(() => ({
    isDropTarget
  }), [isDropTarget]);
  let children = useRenderProps(props, renderProps);
  let styleProps = useStyleProps(props);
  let ElementType = props.elementType || "div";
  return (0, import_jsx_runtime17.jsxs)(ElementType, {
    ...dropProps,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    }),
    ...toDataAttributes({
      isDropTarget,
      isFocused,
      isFocusVisible
    }, {
      omitFalsyValues: true,
      trimBooleanKeys: true
    }),
    ref: dropzoneRef,
    className: classNames(dropZoneClassList.element("root"), css({
      border: `${tokenSchema.size.border.medium} dashed ${tokenSchema.color.border.neutral}`,
      borderRadius: tokenSchema.size.radius.regular,
      display: "flex",
      flexDirection: "column",
      gap: tokenSchema.size.space.medium,
      "&[data-drop-target]": {
        backgroundColor: tokenSchema.color.alias.backgroundSelected,
        borderColor: tokenSchema.color.alias.focusRing,
        borderStyle: "solid",
        cursor: "copy"
      },
      "&[data-focus-visible]": {
        borderColor: tokenSchema.color.alias.focusRing
      }
    }), styleProps.className),
    children: [(0, import_jsx_runtime17.jsxs)($5c3e21d68f1c4674$export$439d29a4e110a164, {
      children: [(0, import_jsx_runtime17.jsx)("div", {
        id: dropzoneId,
        "aria-hidden": "true",
        children: ariaLabel
      }), (0, import_jsx_runtime17.jsx)("button", {
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(dropButtonProps, focusProps, clipboardProps, labelProps),
        ref: buttonRef
      })]
    }), (0, import_jsx_runtime17.jsx)(SlotProvider, {
      slots,
      children
    })]
  });
});

// node_modules/@keystar/ui/dist/keystar-ui-drag-and-drop.js
var import_react91 = __toESM(require_react());
var import_jsx_runtime18 = __toESM(require_jsx_runtime());

// node_modules/@react-stately/dnd/dist/useDraggableCollectionState.mjs
var import_react89 = __toESM(require_react(), 1);
function $b45bbbaf0c3785df$export$29efd034f1d79f81(props) {
  let { getItems, isDisabled, collection, selectionManager, onDragStart, onDragMove, onDragEnd, preview, getAllowedDropOperations } = props;
  let [, setDragging] = (0, import_react89.useState)(false);
  let draggingKeys = (0, import_react89.useRef)(/* @__PURE__ */ new Set());
  let draggedKey = (0, import_react89.useRef)(null);
  let getKeys = (key) => {
    let keys3 = new Set(selectionManager.isSelected(key) ? new Set([
      ...selectionManager.selectedKeys
    ].filter((key2) => !!collection.getItem(key2))) : []);
    keys3.add(key);
    return keys3;
  };
  return {
    collection,
    selectionManager,
    get draggedKey() {
      return draggedKey.current;
    },
    get draggingKeys() {
      return draggingKeys.current;
    },
    isDragging(key) {
      return draggingKeys.current.has(key);
    },
    getKeysForDrag: getKeys,
    getItems(key) {
      return getItems(getKeys(key));
    },
    isDisabled,
    preview,
    getAllowedDropOperations,
    startDrag(key, event) {
      let keys3 = getKeys(key);
      draggingKeys.current = keys3;
      draggedKey.current = key;
      selectionManager.setFocused(false);
      setDragging(true);
      if (typeof onDragStart === "function") onDragStart({
        ...event,
        keys: keys3
      });
    },
    moveDrag(event) {
      if (typeof onDragMove === "function") onDragMove({
        ...event,
        keys: draggingKeys.current
      });
    },
    endDrag(event) {
      let { isInternal } = event;
      if (typeof onDragEnd === "function") onDragEnd({
        ...event,
        keys: draggingKeys.current,
        isInternal
      });
      draggingKeys.current = /* @__PURE__ */ new Set();
      draggedKey.current = null;
      setDragging(false);
    }
  };
}

// node_modules/@react-stately/dnd/dist/useDroppableCollectionState.mjs
var import_react90 = __toESM(require_react(), 1);
function $e672e8bc247525d1$export$926850f6ecef79d0(props) {
  let { acceptedDragTypes = "all", isDisabled, onInsert, onRootDrop, onItemDrop, onReorder, shouldAcceptItemDrop, collection, selectionManager, onDropEnter, getDropOperation, onDrop } = props;
  let [target, setTarget] = (0, import_react90.useState)(null);
  let targetRef = (0, import_react90.useRef)(null);
  let getOppositeTarget = (target2) => {
    if (target2.dropPosition === "before") {
      let key = collection.getKeyBefore(target2.key);
      return key != null ? {
        type: "item",
        key,
        dropPosition: "after"
      } : null;
    } else if (target2.dropPosition === "after") {
      let key = collection.getKeyAfter(target2.key);
      return key != null ? {
        type: "item",
        key,
        dropPosition: "before"
      } : null;
    }
  };
  let defaultGetDropOperation = (0, import_react90.useCallback)((e4) => {
    if (isDisabled) return "cancel";
    let { target: target2, types, allowedOperations, isInternal, draggingKeys } = e4;
    if (acceptedDragTypes === "all" || acceptedDragTypes.some((type3) => types.has(type3))) {
      let isValidInsert = onInsert && target2.type === "item" && !isInternal && (target2.dropPosition === "before" || target2.dropPosition === "after");
      let isValidReorder = onReorder && target2.type === "item" && isInternal && (target2.dropPosition === "before" || target2.dropPosition === "after");
      let isValidRootDrop = onRootDrop && target2.type === "root" && !isInternal;
      let isValidOnItemDrop = onItemDrop && target2.type === "item" && target2.dropPosition === "on" && !(isInternal && draggingKeys.has(target2.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target2, types));
      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {
        if (getDropOperation) return getDropOperation(target2, types, allowedOperations);
        else return allowedOperations[0];
      }
    }
    return "cancel";
  }, [
    isDisabled,
    acceptedDragTypes,
    getDropOperation,
    onInsert,
    onRootDrop,
    onItemDrop,
    shouldAcceptItemDrop,
    onReorder,
    onDrop
  ]);
  return {
    collection,
    selectionManager,
    isDisabled,
    target,
    setTarget(newTarget) {
      if (this.isDropTarget(newTarget)) return;
      let target2 = targetRef.current;
      if (target2 && typeof props.onDropExit === "function") props.onDropExit({
        type: "dropexit",
        x: 0,
        y: 0,
        target: target2
      });
      if (newTarget && typeof onDropEnter === "function") onDropEnter({
        type: "dropenter",
        x: 0,
        y: 0,
        target: newTarget
      });
      targetRef.current = newTarget;
      setTarget(newTarget);
    },
    isDropTarget(dropTarget) {
      let target2 = targetRef.current;
      if ($e672e8bc247525d1$var$isEqualDropTarget(dropTarget, target2)) return true;
      if ((dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.type) === "item" && (target2 === null || target2 === void 0 ? void 0 : target2.type) === "item" && dropTarget.key !== target2.key && dropTarget.dropPosition !== target2.dropPosition && dropTarget.dropPosition !== "on" && target2.dropPosition !== "on") return $e672e8bc247525d1$var$isEqualDropTarget(getOppositeTarget(dropTarget), target2) || $e672e8bc247525d1$var$isEqualDropTarget(dropTarget, getOppositeTarget(target2));
      return false;
    },
    getDropOperation(e4) {
      return defaultGetDropOperation(e4);
    }
  };
}
function $e672e8bc247525d1$var$isEqualDropTarget(a3, b2) {
  if (!a3) return !b2;
  switch (a3.type) {
    case "root":
      return (b2 === null || b2 === void 0 ? void 0 : b2.type) === "root";
    case "item":
      return (b2 === null || b2 === void 0 ? void 0 : b2.type) === "item" && (b2 === null || b2 === void 0 ? void 0 : b2.key) === a3.key && (b2 === null || b2 === void 0 ? void 0 : b2.dropPosition) === a3.dropPosition;
  }
}

// node_modules/@keystar/ui/dist/keystar-ui-drag-and-drop.js
function FileTrigger(props, ref) {
  let {
    acceptedFileTypes,
    allowsMultiple,
    children,
    defaultCamera,
    onSelect,
    ...rest
  } = props;
  let inputRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(rest);
  return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, {
    children: [(0, import_jsx_runtime18.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      onPress: () => {
        var _inputRef$current, _inputRef$current2;
        if ((_inputRef$current = inputRef.current) !== null && _inputRef$current !== void 0 && _inputRef$current.value) {
          inputRef.current.value = "";
        }
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.click();
      },
      children
    }), (0, import_jsx_runtime18.jsx)("input", {
      ...domProps,
      accept: acceptedFileTypes === null || acceptedFileTypes === void 0 ? void 0 : acceptedFileTypes.toString(),
      capture: defaultCamera,
      multiple: allowsMultiple,
      onChange: (e4) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(e4.target.files),
      ref: inputRef,
      style: {
        display: "none"
      },
      type: "file"
    })]
  });
}
var _FileTrigger = (0, import_react91.forwardRef)(FileTrigger);
function InsertionIndicatorPrimitive(props) {
  const $ = c2(11);
  let otherProps;
  let isDropTarget;
  let children;
  if ($[0] !== props) {
    ({
      children,
      isDropTarget,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = isDropTarget;
    $[3] = children;
  } else {
    otherProps = $[1];
    isDropTarget = $[2];
    children = $[3];
  }
  const maskColor = tokenSchema.color.background.canvas;
  const borderColor = tokenSchema.color.background.accentEmphasis;
  const borderSize = tokenSchema.size.border.medium;
  const circleSize = tokenSchema.size.space.regular;
  let t0;
  if ($[4] !== otherProps.className) {
    t0 = classNames(css({
      insetInlineStart: circleSize,
      outline: "none",
      position: "absolute",
      width: `calc(100% - (2 * ${circleSize}))`,
      "&[data-drop-target=true]": {
        borderBottom: `${borderSize} solid ${borderColor}`,
        "&::before": {
          left: `calc(${circleSize} * -1)`
        },
        "&::after": {
          right: `calc(${circleSize} * -1)`
        },
        "&::before, &::after": {
          backgroundColor: maskColor,
          border: `${borderSize} solid ${borderColor}`,
          borderRadius: "50%",
          content: '" "',
          height: circleSize,
          position: "absolute",
          top: `calc(${circleSize} / -2 - ${borderSize} / 2)`,
          width: circleSize,
          zIndex: 5
        }
      }
    }), otherProps.className);
    $[4] = otherProps.className;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  let t1;
  if ($[6] !== isDropTarget || $[7] !== otherProps || $[8] !== t0 || $[9] !== children) {
    t1 = (0, import_jsx_runtime18.jsx)("div", {
      "data-drop-target": isDropTarget,
      ...otherProps,
      className: t0,
      children
    });
    $[6] = isDropTarget;
    $[7] = otherProps;
    $[8] = t0;
    $[9] = children;
    $[10] = t1;
  } else {
    t1 = $[10];
  }
  return t1;
}
function useDragAndDrop(options) {
  let dragAndDropHooks = (0, import_react91.useMemo)(() => {
    let {
      onDrop,
      onInsert,
      onItemDrop,
      onReorder,
      onRootDrop,
      getItems,
      renderPreview
    } = options;
    let isDraggable = !!getItems;
    let isDroppable = !!(onDrop || onInsert || onItemDrop || onReorder || onRootDrop);
    let hooks = {};
    if (isDraggable) {
      hooks.useDraggableCollectionState = function useDraggableCollectionStateOverride(props) {
        return $b45bbbaf0c3785df$export$29efd034f1d79f81({
          ...props,
          ...options
        });
      };
      hooks.useDraggableCollection = $4ac1fdc3a0fcd564$export$2962a7984b2f0a80;
      hooks.useDraggableItem = $fd98cf7cbf233429$export$b35afafff42da2d9;
      hooks.DragPreview = $ad0e3f3d9c50e4ba$export$905ab40ac2179daa;
      hooks.renderPreview = renderPreview;
    }
    if (isDroppable) {
      hooks.useDroppableCollectionState = function useDroppableCollectionStateOverride(props_0) {
        return $e672e8bc247525d1$export$926850f6ecef79d0({
          ...props_0,
          ...options
        });
      };
      hooks.useDroppableItem = $bfaab576ce1c580e$export$f7b0c5d28b66b6a5;
      hooks.useDroppableCollection = function useDroppableCollectionOverride(props_1, state, ref) {
        return $4b52e4eff84e5217$export$f4e2f423c21f7b04({
          ...props_1,
          ...options
        }, state, ref);
      };
      hooks.useDropIndicator = $ddf25448c71fc93a$export$8d0e41d2815afac5;
    }
    if (isDraggable || isDroppable) {
      hooks.isVirtualDragging = $67560de7c78cb232$export$403bc76cbf68cf60;
    }
    return hooks;
  }, [options]);
  return {
    dragAndDropHooks
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronDownIcon.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var chevronDownIcon = (0, import_jsx_runtime19.jsx)("path", {
  d: "m6 9 6 6 6-6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-plusIcon.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var plusIcon = (0, import_jsx_runtime20.jsx)("path", {
  d: "M5 12h14M12 5v14"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-imageIcon.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var imageIcon = (0, import_jsx_runtime21.jsxs)(import_jsx_runtime21.Fragment, {
  children: [(0, import_jsx_runtime21.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime21.jsx)("circle", {
    cx: 9,
    cy: 9,
    r: 2
  }), (0, import_jsx_runtime21.jsx)("path", {
    d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-dialog.js
var import_react93 = __toESM(require_react());

// node_modules/@react-aria/dialog/dist/useDialog.mjs
var import_react92 = __toESM(require_react(), 1);
function $40df3f8667284809$export$d55e7ee900f34e93(props, ref) {
  let { role = "dialog" } = props;
  let titleId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  titleId = props["aria-label"] ? void 0 : titleId;
  let isRefocusing = (0, import_react92.useRef)(false);
  (0, import_react92.useEffect)(() => {
    if (ref.current && !ref.current.contains(document.activeElement)) {
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
      let timeout2 = setTimeout(() => {
        if (document.activeElement === ref.current) {
          isRefocusing.current = true;
          if (ref.current) {
            ref.current.blur();
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
          }
          isRefocusing.current = false;
        }
      }, 500);
      return () => {
        clearTimeout(timeout2);
      };
    }
  }, [
    ref
  ]);
  (0, $337b884510726a0d$export$14c98a7594375490)();
  return {
    dialogProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
        labelable: true
      }),
      role,
      tabIndex: -1,
      "aria-labelledby": props["aria-labelledby"] || titleId,
      // Prevent blur events from reaching useOverlay, which may cause
      // popovers to close. Since focus is contained within the dialog,
      // we don't want this to occur due to the above useEffect.
      onBlur: (e4) => {
        if (isRefocusing.current) e4.stopPropagation();
      }
    },
    titleProps: {
      id: titleId
    }
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-dialog.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var DialogContext = import_react93.default.createContext(null);
var localizedMessages4 = {
  "ar-AE": {
    "alert": `تنبيه`,
    "dismiss": `تجاهل`
  },
  "bg-BG": {
    "alert": `Сигнал`,
    "dismiss": `Отхвърляне`
  },
  "cs-CZ": {
    "alert": `Výstraha`,
    "dismiss": `Odstranit`
  },
  "da-DK": {
    "alert": `Advarsel`,
    "dismiss": `Luk`
  },
  "de-DE": {
    "alert": `Warnhinweis`,
    "dismiss": `Schließen`
  },
  "el-GR": {
    "alert": `Ειδοποίηση`,
    "dismiss": `Απόρριψη`
  },
  "en-US": {
    "alert": `Alert`,
    "dismiss": `Dismiss`
  },
  "es-ES": {
    "alert": `Alerta`,
    "dismiss": `Descartar`
  },
  "et-EE": {
    "alert": `Teade`,
    "dismiss": `Lõpeta`
  },
  "fi-FI": {
    "alert": `Hälytys`,
    "dismiss": `Hylkää`
  },
  "fr-FR": {
    "alert": `Alerte`,
    "dismiss": `Rejeter`
  },
  "he-IL": {
    "alert": `התראה`,
    "dismiss": `התעלם`
  },
  "hr-HR": {
    "alert": `Upozorenje`,
    "dismiss": `Odbaci`
  },
  "hu-HU": {
    "alert": `Figyelmeztetés`,
    "dismiss": `Elutasítás`
  },
  "it-IT": {
    "alert": `Avviso`,
    "dismiss": `Ignora`
  },
  "ja-JP": {
    "alert": `アラート`,
    "dismiss": `閉じる`
  },
  "ko-KR": {
    "alert": `경고`,
    "dismiss": `무시`
  },
  "lt-LT": {
    "alert": `Įspėjimas`,
    "dismiss": `Atmesti`
  },
  "lv-LV": {
    "alert": `Brīdinājums`,
    "dismiss": `Nerādīt`
  },
  "nb-NO": {
    "alert": `Varsel`,
    "dismiss": `Lukk`
  },
  "nl-NL": {
    "alert": `Melding`,
    "dismiss": `Negeren`
  },
  "pl-PL": {
    "alert": `Ostrzeżenie`,
    "dismiss": `Zignoruj`
  },
  "pt-BR": {
    "alert": `Alerta`,
    "dismiss": `Descartar`
  },
  "pt-PT": {
    "alert": `Alerta`,
    "dismiss": `Dispensar`
  },
  "ro-RO": {
    "alert": `Alertă`,
    "dismiss": `Revocare`
  },
  "ru-RU": {
    "alert": `Предупреждение`,
    "dismiss": `Пропустить`
  },
  "sk-SK": {
    "alert": `Upozornenie`,
    "dismiss": `Zrušiť`
  },
  "sl-SI": {
    "alert": `Opozorilo`,
    "dismiss": `Opusti`
  },
  "sr-SP": {
    "alert": `Upozorenje`,
    "dismiss": `Odbaci`
  },
  "sv-SE": {
    "alert": `Varning`,
    "dismiss": `Avvisa`
  },
  "tr-TR": {
    "alert": `Uyarı`,
    "dismiss": `Kapat`
  },
  "uk-UA": {
    "alert": `Сигнал тривоги`,
    "dismiss": `Скасувати`
  },
  "zh-CN": {
    "alert": `警报`,
    "dismiss": `取消`
  },
  "zh-T": {
    "alert": `警示`,
    "dismiss": `關閉`
  }
};
var dialogClassList = new ClassList("Dialog", ["root", "grid", "heading", "header", "footer", "button-group"]);
var Dialog = (0, import_react93.forwardRef)(function Dialog2(props, forwardedRef) {
  let {
    type: type3 = "modal",
    ...contextProps
  } = (0, import_react93.useContext)(DialogContext) || {};
  let {
    children,
    isDismissable = contextProps.isDismissable,
    onDismiss = contextProps.onClose,
    size: size3
  } = props;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages4);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let gridRef = (0, import_react93.useRef)(null);
  let {
    dialogProps,
    titleProps
  } = $40df3f8667284809$export$d55e7ee900f34e93($3ef42575df84b30b$export$9d1611c77c2fe928(contextProps, props), domRef);
  const headingSize = "regular";
  let hasHeading = useHasChild(dialogClassList.selector("heading"), gridRef);
  let hasHeader = useHasChild(dialogClassList.selector("header"), gridRef);
  let hasFooter = useHasChild(dialogClassList.selector("footer"), gridRef);
  let hasButtonGroup = useHasChild(dialogClassList.selector("button-group"), gridRef);
  let slots = (0, import_react93.useMemo)(() => ({
    heading: {
      ...toDataAttributes({
        hasHeader
      }),
      UNSAFE_className: classNames(dialogClassList.element("heading"), getHeadingStyles()),
      elementType: "h2",
      size: headingSize,
      // FIXME: declared as const—shouldn't need this weirdness.
      ...titleProps
    },
    header: {
      // ...toDataAttributes({ hasHeading }),
      UNSAFE_className: classNames(dialogClassList.element("header"), getHeaderStyles())
    },
    content: {
      ...toDataAttributes({
        hasHeader: hasHeader || hasHeading || void 0,
        hasFooter: hasFooter || hasButtonGroup && type3 !== "fullscreen" || void 0
      }),
      UNSAFE_className: getContentStyles()
    },
    footer: {
      UNSAFE_className: classNames(dialogClassList.element("footer"), getFooterStyles())
    },
    buttonGroup: {
      ...toDataAttributes({
        hasFooter
      }),
      UNSAFE_className: classNames(dialogClassList.element("button-group"), getButtonGroupStyles()),
      align: "end"
    }
  }), [hasButtonGroup, hasFooter, hasHeader, hasHeading, headingSize, titleProps, type3]);
  const sizeVariant = getSizeVariant(type3, size3);
  const dialogStyleProps = useDialogStyleProps(props, {
    type: type3,
    size: sizeVariant
  });
  const gridStyleProps2 = useGridStyleProps2({
    isDismissable,
    size: sizeVariant
  });
  return (0, import_jsx_runtime22.jsx)("section", {
    ...dialogStyleProps,
    ...dialogProps,
    ref: domRef,
    children: (0, import_jsx_runtime22.jsxs)(Grid, {
      ref: gridRef,
      ...gridStyleProps2,
      children: [(0, import_jsx_runtime22.jsx)(SlotProvider, {
        slots,
        children
      }), isDismissable && (0, import_jsx_runtime22.jsx)(ActionButton, {
        prominence: "low",
        "aria-label": stringFormatter.format("dismiss"),
        onPress: onDismiss,
        gridArea: "closeButton",
        UNSAFE_className: css({
          placeSelf: "flex-start end",
          paddingInline: 0,
          marginBlock: `calc((${tokenSchema.size.element.regular} - ${tokenSchema.typography.heading[headingSize].capheight}) / 2 * -1)`,
          marginInlineEnd: `calc(${tokenSchema.size.space.medium} * -1)`,
          marginInlineStart: tokenSchema.size.space.regular
        }),
        children: (0, import_jsx_runtime22.jsx)(Icon, {
          src: xIcon,
          size: "medium"
        })
      })]
    })
  });
});
function getSizeVariant(type3, size3) {
  if (type3 === "fullscreen") {
    return "fullscreen";
  }
  if (type3 === "popover") {
    return size3 || "xsmall";
  }
  return size3 || "medium";
}
function useDialogStyleProps(props, t0) {
  const $ = c2(8);
  const {
    size: size3,
    type: type3
  } = t0;
  const styleProps = useStyleProps(props);
  const t1 = type3 === "tray" ? void 0 : size3;
  let t22;
  if ($[0] !== t1) {
    t22 = toDataAttributes({
      size: t1
    });
    $[0] = t1;
    $[1] = t22;
  } else {
    t22 = $[1];
  }
  let t32;
  if ($[2] !== styleProps.className) {
    t32 = classNames(dialogClassList.element("root"), css({
      display: "flex",
      maxHeight: "inherit",
      maxWidth: "100%",
      outline: 0,
      width: "var(--dialog-width)",
      "--dialog-width": "fit-content",
      '&[data-size="xsmall"]': {
        "--dialog-width": tokenSchema.size.dialog.xsmall
      },
      '&[data-size="small"]': {
        "--dialog-width": tokenSchema.size.dialog.small
      },
      '&[data-size="medium"]': {
        "--dialog-width": tokenSchema.size.dialog.medium
      },
      '&[data-size="large"]': {
        "--dialog-width": tokenSchema.size.dialog.large
      },
      '&[data-size="fullscreen"]': {
        maxHeight: "none",
        maxWidth: "none",
        height: "100%",
        "--dialog-width": "100%"
      }
    }), styleProps.className);
    $[2] = styleProps.className;
    $[3] = t32;
  } else {
    t32 = $[3];
  }
  let t4;
  if ($[4] !== t22 || $[5] !== styleProps || $[6] !== t32) {
    t4 = {
      ...t22,
      ...styleProps,
      className: t32
    };
    $[4] = t22;
    $[5] = styleProps;
    $[6] = t32;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  return t4;
}
function useGridStyleProps2({
  isDismissable,
  size: size3
}) {
  let gridStyles = css({
    display: "grid",
    padding: tokenSchema.size.space.xxlarge,
    gridTemplateColumns: "auto minmax(0, 1fr) auto",
    gridTemplateRows: "auto minmax(0, 1fr) auto",
    gridTemplateAreas: `"heading header header"
      "content content content"
      "footer footer buttonGroup"`,
    width: "100%",
    "&[data-dismissable]": {
      gridTemplateColumns: "auto minmax(0, 1fr) auto auto",
      gridTemplateAreas: `"heading header header closeButton"
        "content content content content"
        "footer footer footer footer"`,
      // slot styles
      [dialogClassList.selector("button-group")]: {
        display: "none"
      }
    },
    // MOBILE SPECIFIC
    [breakpointQueries$1.below.tablet]: {
      padding: tokenSchema.size.space.xlarge,
      gridTemplateRows: "auto auto minmax(0, 1fr) auto",
      gridTemplateAreas: `"heading heading heading"
      "header header header"
        "content content content"
        "footer footer buttonGroup"`,
      "&[data-dismissable]": {
        gridTemplateAreas: `"heading heading closeButton"
          "header header header"
            "content content content"
            "footer footer buttonGroup"`
      }
    },
    // TABLET & ABOVE
    [breakpointQueries$1.above.mobile]: {
      '&[data-size="fullscreen"]': {
        gridTemplateAreas: `"heading header buttonGroup"
          "content content content"
          "footer footer footer"`
      }
    }
  });
  return {
    ...toDataAttributes({
      dismissable: isDismissable || void 0,
      size: size3
    }),
    UNSAFE_className: classNames(dialogClassList.element("grid"), gridStyles)
  };
}
function getHeadingStyles() {
  return css({
    alignSelf: "center",
    gridArea: "heading",
    paddingBottom: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingBottom: tokenSchema.size.space.xlarge
    },
    "&[data-has-header=false]": {
      gridArea: "heading-start / heading-start / header-end / header-end"
    }
  });
}
function getHeaderStyles() {
  return css({
    alignItems: "center",
    boxSizing: "border-box",
    display: "flex",
    gridArea: "header",
    minWidth: "fit-content",
    outline: 0,
    paddingBottom: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      justifyContent: "flex-end",
      paddingBottom: tokenSchema.size.space.xlarge
    }
  });
}
function getContentStyles() {
  return css({
    gridArea: "content",
    overflowX: "hidden",
    overflowY: "auto",
    WebkitOverflowScrolling: "touch",
    // fixes two issues:
    // - focus rings get clipped by overflow: auto
    // - trimmed text (capsize) creates unwanted scrollbars
    padding: tokenSchema.size.space.regular,
    margin: `calc(${tokenSchema.size.space.regular} * -1)`
  });
}
function getButtonGroupStyles() {
  return css({
    gridArea: "buttonGroup",
    minWidth: 0,
    marginInlineStart: tokenSchema.size.space.regular,
    paddingTop: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingTop: tokenSchema.size.space.xlarge
    },
    [`${dialogClassList.selector("root")}:not([data-size=fullscreen]) &[data-has-footer=false]`]: {
      gridArea: "footer-start / footer-start / buttonGroup-end / buttonGroup-end"
    },
    // correct consumer error; hide the button group when the dialog is dismissable
    [`${dialogClassList.selector("root")}[data-dismissable] &`]: {
      display: "none"
    }
  });
}
function getFooterStyles() {
  return css({
    alignItems: "center",
    display: "flex",
    flexWrap: "wrap",
    gridArea: "footer",
    minWidth: 0,
    paddingTop: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingTop: tokenSchema.size.space.xlarge
    }
  });
}
var AlertDialog = (0, import_react93.forwardRef)(function AlertDialog2(props, forwardedRef) {
  const $ = c2(58);
  const {
    onClose: t0
  } = (0, import_react93.useContext)(DialogContext) || {};
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === void 0 ? () => {
    } : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onClose = t1;
  let t22;
  let t32;
  let t4;
  let otherProps;
  let title;
  let children;
  let cancelLabel;
  let autoFocusButton;
  let secondaryActionLabel;
  let isSecondaryActionDisabled;
  let tone;
  let isPrimaryActionDisabled;
  let primaryActionLabel;
  if ($[2] !== props) {
    ({
      autoFocusButton,
      cancelLabel,
      children,
      isPrimaryActionDisabled,
      isSecondaryActionDisabled,
      onCancel: t22,
      onPrimaryAction: t32,
      onSecondaryAction: t4,
      primaryActionLabel,
      secondaryActionLabel,
      title,
      tone,
      ...otherProps
    } = props);
    $[2] = props;
    $[3] = t22;
    $[4] = t32;
    $[5] = t4;
    $[6] = otherProps;
    $[7] = title;
    $[8] = children;
    $[9] = cancelLabel;
    $[10] = autoFocusButton;
    $[11] = secondaryActionLabel;
    $[12] = isSecondaryActionDisabled;
    $[13] = tone;
    $[14] = isPrimaryActionDisabled;
    $[15] = primaryActionLabel;
  } else {
    t22 = $[3];
    t32 = $[4];
    t4 = $[5];
    otherProps = $[6];
    title = $[7];
    children = $[8];
    cancelLabel = $[9];
    autoFocusButton = $[10];
    secondaryActionLabel = $[11];
    isSecondaryActionDisabled = $[12];
    tone = $[13];
    isPrimaryActionDisabled = $[14];
    primaryActionLabel = $[15];
  }
  let t5;
  if ($[16] !== t22) {
    t5 = t22 === void 0 ? () => {
    } : t22;
    $[16] = t22;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  const onCancel = t5;
  let t6;
  if ($[18] !== t32) {
    t6 = t32 === void 0 ? () => {
    } : t32;
    $[18] = t32;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  const onPrimaryAction = t6;
  let t7;
  if ($[20] !== t4) {
    t7 = t4 === void 0 ? () => {
    } : t4;
    $[20] = t4;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  const onSecondaryAction = t7;
  const styleProps = useStyleProps(otherProps);
  let t8;
  if ($[22] !== title) {
    t8 = (0, import_jsx_runtime22.jsx)(Heading, {
      children: title
    });
    $[22] = title;
    $[23] = t8;
  } else {
    t8 = $[23];
  }
  let t9;
  if ($[24] !== children) {
    t9 = (0, import_jsx_runtime22.jsx)(Content, {
      children: isReactText(children) ? (0, import_jsx_runtime22.jsx)(Text, {
        children
      }) : children
    });
    $[24] = children;
    $[25] = t9;
  } else {
    t9 = $[25];
  }
  let t10;
  if ($[26] !== cancelLabel || $[27] !== onClose || $[28] !== onCancel || $[29] !== autoFocusButton || $[30] !== secondaryActionLabel) {
    t10 = cancelLabel && (0, import_jsx_runtime22.jsx)(Button, {
      onPress: () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onCancel()),
      autoFocus: autoFocusButton === "cancel",
      prominence: secondaryActionLabel ? "low" : void 0,
      children: cancelLabel
    });
    $[26] = cancelLabel;
    $[27] = onClose;
    $[28] = onCancel;
    $[29] = autoFocusButton;
    $[30] = secondaryActionLabel;
    $[31] = t10;
  } else {
    t10 = $[31];
  }
  let t11;
  if ($[32] !== secondaryActionLabel || $[33] !== onClose || $[34] !== onSecondaryAction || $[35] !== autoFocusButton || $[36] !== isSecondaryActionDisabled) {
    t11 = secondaryActionLabel && (0, import_jsx_runtime22.jsx)(Button, {
      onPress: () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onSecondaryAction()),
      autoFocus: autoFocusButton === "secondary",
      isDisabled: isSecondaryActionDisabled,
      children: secondaryActionLabel
    });
    $[32] = secondaryActionLabel;
    $[33] = onClose;
    $[34] = onSecondaryAction;
    $[35] = autoFocusButton;
    $[36] = isSecondaryActionDisabled;
    $[37] = t11;
  } else {
    t11 = $[37];
  }
  let t12;
  if ($[38] !== onClose || $[39] !== onPrimaryAction) {
    t12 = () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onPrimaryAction());
    $[38] = onClose;
    $[39] = onPrimaryAction;
    $[40] = t12;
  } else {
    t12 = $[40];
  }
  const t13 = autoFocusButton === "primary";
  let t14;
  if ($[41] !== tone || $[42] !== t12 || $[43] !== isPrimaryActionDisabled || $[44] !== t13 || $[45] !== primaryActionLabel) {
    t14 = (0, import_jsx_runtime22.jsx)(Button, {
      prominence: "high",
      tone,
      onPress: t12,
      isDisabled: isPrimaryActionDisabled,
      autoFocus: t13,
      children: primaryActionLabel
    });
    $[41] = tone;
    $[42] = t12;
    $[43] = isPrimaryActionDisabled;
    $[44] = t13;
    $[45] = primaryActionLabel;
    $[46] = t14;
  } else {
    t14 = $[46];
  }
  let t15;
  if ($[47] !== t10 || $[48] !== t11 || $[49] !== t14) {
    t15 = (0, import_jsx_runtime22.jsxs)(ButtonGroup, {
      align: "end",
      children: [t10, t11, t14]
    });
    $[47] = t10;
    $[48] = t11;
    $[49] = t14;
    $[50] = t15;
  } else {
    t15 = $[50];
  }
  let t16;
  if ($[51] !== forwardedRef || $[52] !== styleProps.className || $[53] !== styleProps.style || $[54] !== t8 || $[55] !== t9 || $[56] !== t15) {
    t16 = (0, import_jsx_runtime22.jsxs)(Dialog, {
      role: "alertdialog",
      ref: forwardedRef,
      size: "small",
      UNSAFE_className: styleProps.className,
      UNSAFE_style: styleProps.style,
      children: [t8, t9, t15]
    });
    $[51] = forwardedRef;
    $[52] = styleProps.className;
    $[53] = styleProps.style;
    $[54] = t8;
    $[55] = t9;
    $[56] = t15;
    $[57] = t16;
  } else {
    t16 = $[57];
  }
  return t16;
});
function DialogContainer(props) {
  const $ = c2(18);
  const {
    children,
    type: t0,
    onDismiss,
    isDismissable,
    isKeyboardDismissDisabled
  } = props;
  const type3 = t0 === void 0 ? "modal" : t0;
  const child = (0, import_react93.isValidElement)(children) ? children : null;
  const [lastChild, setLastChild] = (0, import_react93.useState)(child);
  if (child && child !== lastChild) {
    setLastChild(child);
  }
  let t1;
  if ($[0] !== type3 || $[1] !== onDismiss || $[2] !== isDismissable) {
    t1 = {
      type: type3,
      onClose: onDismiss,
      isDismissable
    };
    $[0] = type3;
    $[1] = onDismiss;
    $[2] = isDismissable;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const context = t1;
  const t22 = !!child;
  let t32;
  if ($[4] !== onDismiss) {
    t32 = (isOpen) => {
      if (!isOpen) {
        onDismiss();
      }
    };
    $[4] = onDismiss;
    $[5] = t32;
  } else {
    t32 = $[5];
  }
  let t4;
  if ($[6] !== t22 || $[7] !== t32) {
    t4 = {
      isOpen: t22,
      onOpenChange: t32
    };
    $[6] = t22;
    $[7] = t32;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const state = $fc909762b330b746$export$61c6a8c84e605fb6(t4);
  let t5;
  if ($[9] !== context || $[10] !== lastChild) {
    t5 = (0, import_jsx_runtime22.jsx)(DialogContext.Provider, {
      value: context,
      children: lastChild
    });
    $[9] = context;
    $[10] = lastChild;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  let t6;
  if ($[12] !== state || $[13] !== type3 || $[14] !== isDismissable || $[15] !== isKeyboardDismissDisabled || $[16] !== t5) {
    t6 = (0, import_jsx_runtime22.jsx)(Modal, {
      state,
      type: type3,
      isDismissable,
      isKeyboardDismissDisabled,
      children: t5
    });
    $[12] = state;
    $[13] = type3;
    $[14] = isDismissable;
    $[15] = isKeyboardDismissDisabled;
    $[16] = t5;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  return t6;
}
function useDialogContainer() {
  const $ = c2(2);
  const context = (0, import_react93.useContext)(DialogContext);
  assert(!!context, "Cannot call `useDialogContext` outside of `<DialogTrigger>` or `<DialogContainer>`.");
  let t0;
  if ($[0] !== context) {
    t0 = {
      type: context.type,
      dismiss() {
        context.onClose();
      }
    };
    $[0] = context;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function DialogTrigger(props) {
  let {
    children,
    type: type3 = "modal",
    mobileType = type3 === "popover" ? "modal" : type3,
    hideArrow,
    targetRef,
    isDismissable,
    isKeyboardDismissDisabled,
    ...positionProps
  } = props;
  if (!Array.isArray(children) || children.length > 2) {
    throw new Error("DialogTrigger must have exactly 2 children");
  }
  let [trigger2, content] = children;
  let isMobile = useMediaQuery(breakpointQueries$1.below.tablet);
  if (isMobile) {
    if (type3 !== "modal" && mobileType === "modal") {
      isDismissable = true;
    }
    type3 = mobileType;
  }
  let state = $fc909762b330b746$export$61c6a8c84e605fb6(props);
  let wasOpen = (0, import_react93.useRef)(false);
  wasOpen.current = state.isOpen;
  let isExiting = (0, import_react93.useRef)(false);
  let onExiting = () => isExiting.current = true;
  let onExited = () => isExiting.current = false;
  const onUnmount = $8ae05eaa5c114e9c$export$7f54fc3180508a52(() => {
    if ((wasOpen.current || isExiting.current) && type3 !== "popover" && type3 !== "tray") {
      console.warn("A DialogTrigger unmounted while open. This is likely due to being placed within a trigger that unmounts or inside a conditional. Consider using a DialogContainer instead.");
    }
  });
  (0, import_react93.useEffect)(() => {
    return onUnmount;
  }, [onUnmount]);
  if (type3 === "popover") {
    return (0, import_jsx_runtime22.jsx)(PopoverTrigger, {
      ...positionProps,
      state,
      targetRef,
      trigger: trigger2,
      content,
      isKeyboardDismissDisabled,
      hideArrow
    });
  }
  let renderOverlay = () => {
    switch (type3) {
      case "fullscreen":
      case "modal":
        return (0, import_jsx_runtime22.jsx)(Modal, {
          state,
          isDismissable: type3 === "modal" ? isDismissable : false,
          type: type3,
          isKeyboardDismissDisabled,
          onExiting,
          onExited,
          children: typeof content === "function" ? content(state.close) : content
        });
      case "tray":
        return (0, import_jsx_runtime22.jsx)(Tray, {
          state,
          isKeyboardDismissDisabled,
          children: typeof content === "function" ? content(state.close) : content
        });
    }
    assertNever(type3);
  };
  return (0, import_jsx_runtime22.jsx)(DialogTriggerBase, {
    type: type3,
    state,
    isDismissable,
    trigger: trigger2,
    overlay: renderOverlay()
  });
}
DialogTrigger.getCollectionNode = function* (props) {
  let [trigger2] = import_react93.Children.toArray(props.children);
  let [, content] = props.children;
  yield {
    element: trigger2,
    wrapper: (element2) => (0, import_jsx_runtime22.jsxs)(DialogTrigger, {
      ...props,
      children: [element2, content]
    }, element2.key)
  };
};
var _DialogTrigger = DialogTrigger;
function PopoverTrigger(t0) {
  const $ = c2(26);
  let state;
  let targetRef;
  let content;
  let props;
  let hideArrow;
  let trigger2;
  if ($[0] !== t0) {
    ({
      state,
      targetRef,
      trigger: trigger2,
      content,
      hideArrow,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = state;
    $[2] = targetRef;
    $[3] = content;
    $[4] = props;
    $[5] = hideArrow;
    $[6] = trigger2;
  } else {
    state = $[1];
    targetRef = $[2];
    content = $[3];
    props = $[4];
    hideArrow = $[5];
    trigger2 = $[6];
  }
  const triggerRef = (0, import_react93.useRef)(null);
  let t1;
  if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      type: "dialog"
    };
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const {
    triggerProps,
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d(t1, state, triggerRef);
  const t22 = targetRef ? void 0 : triggerRef;
  let t32;
  if ($[8] !== triggerProps || $[9] !== t22) {
    t32 = {
      ...triggerProps,
      ref: t22
    };
    $[8] = triggerProps;
    $[9] = t22;
    $[10] = t32;
  } else {
    t32 = $[10];
  }
  const triggerPropsWithRef = t32;
  const t4 = targetRef || triggerRef;
  let t5;
  if ($[11] !== content || $[12] !== state) {
    t5 = typeof content === "function" ? content(state.close) : content;
    $[11] = content;
    $[12] = state;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  let t6;
  if ($[14] !== props || $[15] !== hideArrow || $[16] !== t4 || $[17] !== state || $[18] !== t5) {
    t6 = (0, import_jsx_runtime22.jsx)(Popover, {
      ...props,
      hideArrow,
      triggerRef: t4,
      state,
      children: t5
    });
    $[14] = props;
    $[15] = hideArrow;
    $[16] = t4;
    $[17] = state;
    $[18] = t5;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  const overlay = t6;
  let t7;
  if ($[20] !== state || $[21] !== triggerPropsWithRef || $[22] !== overlayProps || $[23] !== trigger2 || $[24] !== overlay) {
    t7 = (0, import_jsx_runtime22.jsx)(DialogTriggerBase, {
      type: "popover",
      state,
      triggerProps: triggerPropsWithRef,
      dialogProps: overlayProps,
      trigger: trigger2,
      overlay
    });
    $[20] = state;
    $[21] = triggerPropsWithRef;
    $[22] = overlayProps;
    $[23] = trigger2;
    $[24] = overlay;
    $[25] = t7;
  } else {
    t7 = $[25];
  }
  return t7;
}
function DialogTriggerBase(t0) {
  const $ = c2(22);
  const {
    type: type3,
    state,
    isDismissable,
    dialogProps: t1,
    triggerProps: t22,
    overlay,
    trigger: trigger2
  } = t0;
  let t32;
  if ($[0] !== t1) {
    t32 = t1 === void 0 ? {} : t1;
    $[0] = t1;
    $[1] = t32;
  } else {
    t32 = $[1];
  }
  const dialogProps = t32;
  let t4;
  if ($[2] !== t22) {
    t4 = t22 === void 0 ? {} : t22;
    $[2] = t22;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  const triggerProps = t4;
  let t5;
  if ($[4] !== type3 || $[5] !== state.close || $[6] !== isDismissable || $[7] !== dialogProps) {
    t5 = {
      type: type3,
      onClose: state.close,
      isDismissable,
      ...dialogProps
    };
    $[4] = type3;
    $[5] = state.close;
    $[6] = isDismissable;
    $[7] = dialogProps;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  const context = t5;
  let t6;
  if ($[9] !== state.open || $[10] !== triggerProps) {
    t6 = $3ef42575df84b30b$export$9d1611c77c2fe928(triggerProps, {
      onPress: state.open
    });
    $[9] = state.open;
    $[10] = triggerProps;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  const t7 = state.isOpen && type3 !== "modal" && type3 !== "fullscreen";
  let t8;
  if ($[12] !== t6 || $[13] !== t7 || $[14] !== trigger2) {
    t8 = (0, import_jsx_runtime22.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...t6,
      isPressed: t7,
      children: trigger2
    });
    $[12] = t6;
    $[13] = t7;
    $[14] = trigger2;
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] !== context || $[17] !== overlay) {
    t9 = (0, import_jsx_runtime22.jsx)(DialogContext.Provider, {
      value: context,
      children: overlay
    });
    $[16] = context;
    $[17] = overlay;
    $[18] = t9;
  } else {
    t9 = $[18];
  }
  let t10;
  if ($[19] !== t8 || $[20] !== t9) {
    t10 = (0, import_jsx_runtime22.jsxs)(import_react93.Fragment, {
      children: [t8, t9]
    });
    $[19] = t8;
    $[20] = t9;
    $[21] = t10;
  } else {
    t10 = $[21];
  }
  return t10;
}

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o3) {
  return Object.prototype.toString.call(o3) === "[object Object]";
}
function isPlainObject(o3) {
  var ctor, prot;
  if (isObject(o3) === false) return false;
  ctor = o3.constructor;
  if (ctor === void 0) return true;
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/immer/dist/immer.esm.mjs
function n(n5) {
  for (var r6 = arguments.length, t4 = Array(r6 > 1 ? r6 - 1 : 0), e4 = 1; e4 < r6; e4++) t4[e4 - 1] = arguments[e4];
  if (true) {
    var i4 = Y[n5], o3 = i4 ? "function" == typeof i4 ? i4.apply(null, t4) : i4 : "unknown error nr: " + n5;
    throw Error("[Immer] " + o3);
  }
  throw Error("[Immer] minified error nr: " + n5 + (t4.length ? " " + t4.map(function(n6) {
    return "'" + n6 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r2(n5) {
  return !!n5 && !!n5[Q];
}
function t(n5) {
  var r6;
  return !!n5 && (function(n6) {
    if (!n6 || "object" != typeof n6) return false;
    var r7 = Object.getPrototypeOf(n6);
    if (null === r7) return true;
    var t4 = Object.hasOwnProperty.call(r7, "constructor") && r7.constructor;
    return t4 === Object || "function" == typeof t4 && Function.toString.call(t4) === Z;
  }(n5) || Array.isArray(n5) || !!n5[L] || !!(null === (r6 = n5.constructor) || void 0 === r6 ? void 0 : r6[L]) || s(n5) || v(n5));
}
function i(n5, r6, t4) {
  void 0 === t4 && (t4 = false), 0 === o(n5) ? (t4 ? Object.keys : nn)(n5).forEach(function(e4) {
    t4 && "symbol" == typeof e4 || r6(e4, n5[e4], n5);
  }) : n5.forEach(function(t5, e4) {
    return r6(e4, t5, n5);
  });
}
function o(n5) {
  var r6 = n5[Q];
  return r6 ? r6.i > 3 ? r6.i - 4 : r6.i : Array.isArray(n5) ? 1 : s(n5) ? 2 : v(n5) ? 3 : 0;
}
function u(n5, r6) {
  return 2 === o(n5) ? n5.has(r6) : Object.prototype.hasOwnProperty.call(n5, r6);
}
function a(n5, r6) {
  return 2 === o(n5) ? n5.get(r6) : n5[r6];
}
function f(n5, r6, t4) {
  var e4 = o(n5);
  2 === e4 ? n5.set(r6, t4) : 3 === e4 ? n5.add(t4) : n5[r6] = t4;
}
function c3(n5, r6) {
  return n5 === r6 ? 0 !== n5 || 1 / n5 == 1 / r6 : n5 != n5 && r6 != r6;
}
function s(n5) {
  return X && n5 instanceof Map;
}
function v(n5) {
  return q && n5 instanceof Set;
}
function p(n5) {
  return n5.o || n5.t;
}
function l(n5) {
  if (Array.isArray(n5)) return Array.prototype.slice.call(n5);
  var r6 = rn(n5);
  delete r6[Q];
  for (var t4 = nn(r6), e4 = 0; e4 < t4.length; e4++) {
    var i4 = t4[e4], o3 = r6[i4];
    false === o3.writable && (o3.writable = true, o3.configurable = true), (o3.get || o3.set) && (r6[i4] = { configurable: true, writable: true, enumerable: o3.enumerable, value: n5[i4] });
  }
  return Object.create(Object.getPrototypeOf(n5), r6);
}
function d(n5, e4) {
  return void 0 === e4 && (e4 = false), y(n5) || r2(n5) || !t(n5) || (o(n5) > 1 && (n5.set = n5.add = n5.clear = n5.delete = h), Object.freeze(n5), e4 && i(n5, function(n6, r6) {
    return d(r6, true);
  }, true)), n5;
}
function h() {
  n(2);
}
function y(n5) {
  return null == n5 || "object" != typeof n5 || Object.isFrozen(n5);
}
function b(r6) {
  var t4 = tn[r6];
  return t4 || n(18, r6), t4;
}
function _() {
  return U || n(0), U;
}
function j(n5, r6) {
  r6 && (b("Patches"), n5.u = [], n5.s = [], n5.v = r6);
}
function g(n5) {
  O(n5), n5.p.forEach(S), n5.p = null;
}
function O(n5) {
  n5 === U && (U = n5.l);
}
function w(n5) {
  return U = { p: [], l: U, h: n5, m: true, _: 0 };
}
function S(n5) {
  var r6 = n5[Q];
  0 === r6.i || 1 === r6.i ? r6.j() : r6.g = true;
}
function P(r6, e4) {
  e4._ = e4.p.length;
  var i4 = e4.p[0], o3 = void 0 !== r6 && r6 !== i4;
  return e4.h.O || b("ES5").S(e4, r6, o3), o3 ? (i4[Q].P && (g(e4), n(4)), t(r6) && (r6 = M(e4, r6), e4.l || x(e4, r6)), e4.u && b("Patches").M(i4[Q].t, r6, e4.u, e4.s)) : r6 = M(e4, i4, []), g(e4), e4.u && e4.v(e4.u, e4.s), r6 !== H ? r6 : void 0;
}
function M(n5, r6, t4) {
  if (y(r6)) return r6;
  var e4 = r6[Q];
  if (!e4) return i(r6, function(i4, o4) {
    return A(n5, e4, r6, i4, o4, t4);
  }, true), r6;
  if (e4.A !== n5) return r6;
  if (!e4.P) return x(n5, e4.t, true), e4.t;
  if (!e4.I) {
    e4.I = true, e4.A._--;
    var o3 = 4 === e4.i || 5 === e4.i ? e4.o = l(e4.k) : e4.o, u4 = o3, a3 = false;
    3 === e4.i && (u4 = new Set(o3), o3.clear(), a3 = true), i(u4, function(r7, i4) {
      return A(n5, e4, o3, r7, i4, t4, a3);
    }), x(n5, o3, false), t4 && n5.u && b("Patches").N(e4, t4, n5.u, n5.s);
  }
  return e4.o;
}
function A(e4, i4, o3, a3, c6, s4, v6) {
  if (c6 === o3 && n(5), r2(c6)) {
    var p4 = M(e4, c6, s4 && i4 && 3 !== i4.i && !u(i4.R, a3) ? s4.concat(a3) : void 0);
    if (f(o3, a3, p4), !r2(p4)) return;
    e4.m = false;
  } else v6 && o3.add(c6);
  if (t(c6) && !y(c6)) {
    if (!e4.h.D && e4._ < 1) return;
    M(e4, c6), i4 && i4.A.l || x(e4, c6);
  }
}
function x(n5, r6, t4) {
  void 0 === t4 && (t4 = false), !n5.l && n5.h.D && n5.m && d(r6, t4);
}
function z(n5, r6) {
  var t4 = n5[Q];
  return (t4 ? p(t4) : n5)[r6];
}
function I(n5, r6) {
  if (r6 in n5) for (var t4 = Object.getPrototypeOf(n5); t4; ) {
    var e4 = Object.getOwnPropertyDescriptor(t4, r6);
    if (e4) return e4;
    t4 = Object.getPrototypeOf(t4);
  }
}
function k(n5) {
  n5.P || (n5.P = true, n5.l && k(n5.l));
}
function E(n5) {
  n5.o || (n5.o = l(n5.t));
}
function N(n5, r6, t4) {
  var e4 = s(r6) ? b("MapSet").F(r6, t4) : v(r6) ? b("MapSet").T(r6, t4) : n5.O ? function(n6, r7) {
    var t5 = Array.isArray(n6), e5 = { i: t5 ? 1 : 0, A: r7 ? r7.A : _(), P: false, I: false, R: {}, l: r7, t: n6, k: null, o: null, j: null, C: false }, i4 = e5, o3 = en;
    t5 && (i4 = [e5], o3 = on);
    var u4 = Proxy.revocable(i4, o3), a3 = u4.revoke, f6 = u4.proxy;
    return e5.k = f6, e5.j = a3, f6;
  }(r6, t4) : b("ES5").J(r6, t4);
  return (t4 ? t4.A : _()).p.push(e4), e4;
}
function R(e4) {
  return r2(e4) || n(22, e4), function n5(r6) {
    if (!t(r6)) return r6;
    var e5, u4 = r6[Q], c6 = o(r6);
    if (u4) {
      if (!u4.P && (u4.i < 4 || !b("ES5").K(u4))) return u4.t;
      u4.I = true, e5 = D(r6, c6), u4.I = false;
    } else e5 = D(r6, c6);
    return i(e5, function(r7, t4) {
      u4 && a(u4.t, r7) === t4 || f(e5, r7, n5(t4));
    }), 3 === c6 ? new Set(e5) : e5;
  }(e4);
}
function D(n5, r6) {
  switch (r6) {
    case 2:
      return new Map(n5);
    case 3:
      return Array.from(n5);
  }
  return l(n5);
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n5) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n5;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n5) {
  return "Cannot apply patch, path doesn't resolve: " + n5;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n5) {
  return "Unsupported patch operation: " + n5;
}, 18: function(n5) {
  return "The plugin for '" + n5 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n5 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n5) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n5 + "'";
}, 22: function(n5) {
  return "'current' expects a draft, got: " + n5;
}, 23: function(n5) {
  return "'original' expects a draft, got: " + n5;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n5) {
  return Object.getOwnPropertyNames(n5).concat(Object.getOwnPropertySymbols(n5));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n5) {
  var r6 = {};
  return nn(n5).forEach(function(t4) {
    r6[t4] = Object.getOwnPropertyDescriptor(n5, t4);
  }), r6;
};
var tn = {};
var en = { get: function(n5, r6) {
  if (r6 === Q) return n5;
  var e4 = p(n5);
  if (!u(e4, r6)) return function(n6, r7, t4) {
    var e5, i5 = I(r7, t4);
    return i5 ? "value" in i5 ? i5.value : null === (e5 = i5.get) || void 0 === e5 ? void 0 : e5.call(n6.k) : void 0;
  }(n5, e4, r6);
  var i4 = e4[r6];
  return n5.I || !t(i4) ? i4 : i4 === z(n5.t, r6) ? (E(n5), n5.o[r6] = N(n5.A.h, i4, n5)) : i4;
}, has: function(n5, r6) {
  return r6 in p(n5);
}, ownKeys: function(n5) {
  return Reflect.ownKeys(p(n5));
}, set: function(n5, r6, t4) {
  var e4 = I(p(n5), r6);
  if (null == e4 ? void 0 : e4.set) return e4.set.call(n5.k, t4), true;
  if (!n5.P) {
    var i4 = z(p(n5), r6), o3 = null == i4 ? void 0 : i4[Q];
    if (o3 && o3.t === t4) return n5.o[r6] = t4, n5.R[r6] = false, true;
    if (c3(t4, i4) && (void 0 !== t4 || u(n5.t, r6))) return true;
    E(n5), k(n5);
  }
  return n5.o[r6] === t4 && (void 0 !== t4 || r6 in n5.o) || Number.isNaN(t4) && Number.isNaN(n5.o[r6]) || (n5.o[r6] = t4, n5.R[r6] = true), true;
}, deleteProperty: function(n5, r6) {
  return void 0 !== z(n5.t, r6) || r6 in n5.t ? (n5.R[r6] = false, E(n5), k(n5)) : delete n5.R[r6], n5.o && delete n5.o[r6], true;
}, getOwnPropertyDescriptor: function(n5, r6) {
  var t4 = p(n5), e4 = Reflect.getOwnPropertyDescriptor(t4, r6);
  return e4 ? { writable: true, configurable: 1 !== n5.i || "length" !== r6, enumerable: e4.enumerable, value: t4[r6] } : e4;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n5) {
  return Object.getPrototypeOf(n5.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n5, r6) {
  on[n5] = function() {
    return arguments[0] = arguments[0][0], r6.apply(this, arguments);
  };
}), on.deleteProperty = function(r6, t4) {
  return isNaN(parseInt(t4)) && n(13), on.set.call(this, r6, t4, void 0);
}, on.set = function(r6, t4, e4) {
  return "length" !== t4 && isNaN(parseInt(t4)) && n(14), en.set.call(this, r6[0], t4, e4, r6[0]);
};
var un = function() {
  function e4(r6) {
    var e5 = this;
    this.O = B, this.D = true, this.produce = function(r7, i5, o3) {
      if ("function" == typeof r7 && "function" != typeof i5) {
        var u4 = i5;
        i5 = r7;
        var a3 = e5;
        return function(n5) {
          var r8 = this;
          void 0 === n5 && (n5 = u4);
          for (var t4 = arguments.length, e6 = Array(t4 > 1 ? t4 - 1 : 0), o4 = 1; o4 < t4; o4++) e6[o4 - 1] = arguments[o4];
          return a3.produce(n5, function(n6) {
            var t5;
            return (t5 = i5).call.apply(t5, [r8, n6].concat(e6));
          });
        };
      }
      var f6;
      if ("function" != typeof i5 && n(6), void 0 !== o3 && "function" != typeof o3 && n(7), t(r7)) {
        var c6 = w(e5), s4 = N(e5, r7, void 0), v6 = true;
        try {
          f6 = i5(s4), v6 = false;
        } finally {
          v6 ? g(c6) : O(c6);
        }
        return "undefined" != typeof Promise && f6 instanceof Promise ? f6.then(function(n5) {
          return j(c6, o3), P(n5, c6);
        }, function(n5) {
          throw g(c6), n5;
        }) : (j(c6, o3), P(f6, c6));
      }
      if (!r7 || "object" != typeof r7) {
        if (void 0 === (f6 = i5(r7)) && (f6 = r7), f6 === H && (f6 = void 0), e5.D && d(f6, true), o3) {
          var p4 = [], l6 = [];
          b("Patches").M(r7, f6, p4, l6), o3(p4, l6);
        }
        return f6;
      }
      n(21, r7);
    }, this.produceWithPatches = function(n5, r7) {
      if ("function" == typeof n5) return function(r8) {
        for (var t5 = arguments.length, i6 = Array(t5 > 1 ? t5 - 1 : 0), o4 = 1; o4 < t5; o4++) i6[o4 - 1] = arguments[o4];
        return e5.produceWithPatches(r8, function(r9) {
          return n5.apply(void 0, [r9].concat(i6));
        });
      };
      var t4, i5, o3 = e5.produce(n5, r7, function(n6, r8) {
        t4 = n6, i5 = r8;
      });
      return "undefined" != typeof Promise && o3 instanceof Promise ? o3.then(function(n6) {
        return [n6, t4, i5];
      }) : [o3, t4, i5];
    }, "boolean" == typeof (null == r6 ? void 0 : r6.useProxies) && this.setUseProxies(r6.useProxies), "boolean" == typeof (null == r6 ? void 0 : r6.autoFreeze) && this.setAutoFreeze(r6.autoFreeze);
  }
  var i4 = e4.prototype;
  return i4.createDraft = function(e5) {
    t(e5) || n(8), r2(e5) && (e5 = R(e5));
    var i5 = w(this), o3 = N(this, e5, void 0);
    return o3[Q].C = true, O(i5), o3;
  }, i4.finishDraft = function(r6, t4) {
    var e5 = r6 && r6[Q];
    e5 && e5.C || n(9), e5.I && n(10);
    var i5 = e5.A;
    return j(i5, t4), P(void 0, i5);
  }, i4.setAutoFreeze = function(n5) {
    this.D = n5;
  }, i4.setUseProxies = function(r6) {
    r6 && !B && n(20), this.O = r6;
  }, i4.applyPatches = function(n5, t4) {
    var e5;
    for (e5 = t4.length - 1; e5 >= 0; e5--) {
      var i5 = t4[e5];
      if (0 === i5.path.length && "replace" === i5.op) {
        n5 = i5.value;
        break;
      }
    }
    e5 > -1 && (t4 = t4.slice(e5 + 1));
    var o3 = b("Patches").$;
    return r2(n5) ? o3(n5, t4) : this.produce(n5, function(n6) {
      return o3(n6, t4);
    });
  }, e4;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);

// node_modules/slate/dist/index.es.js
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
var DIRTY_PATHS = /* @__PURE__ */ new WeakMap();
var DIRTY_PATH_KEYS = /* @__PURE__ */ new WeakMap();
var FLUSHING = /* @__PURE__ */ new WeakMap();
var NORMALIZING = /* @__PURE__ */ new WeakMap();
var PATH_REFS = /* @__PURE__ */ new WeakMap();
var POINT_REFS = /* @__PURE__ */ new WeakMap();
var RANGE_REFS = /* @__PURE__ */ new WeakMap();
function ownKeys$9(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$9(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var createEditor = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isInline: () => false,
    isVoid: () => false,
    markableVoid: () => false,
    onChange: () => {
    },
    apply: (op) => {
      for (var ref of Editor.pathRefs(editor)) {
        PathRef.transform(ref, op);
      }
      for (var _ref of Editor.pointRefs(editor)) {
        PointRef.transform(_ref, op);
      }
      for (var _ref2 of Editor.rangeRefs(editor)) {
        RangeRef.transform(_ref2, op);
      }
      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || /* @__PURE__ */ new Set();
      var dirtyPaths;
      var dirtyPathKeys;
      var add = (path2) => {
        if (path2) {
          var key = path2.join(",");
          if (!dirtyPathKeys.has(key)) {
            dirtyPathKeys.add(key);
            dirtyPaths.push(path2);
          }
        }
      };
      if (Path.operationCanTransformPath(op)) {
        dirtyPaths = [];
        dirtyPathKeys = /* @__PURE__ */ new Set();
        for (var path of oldDirtyPaths) {
          var newPath = Path.transform(path, op);
          add(newPath);
        }
      } else {
        dirtyPaths = oldDirtyPaths;
        dirtyPathKeys = oldDirtyPathKeys;
      }
      var newDirtyPaths = editor.getDirtyPaths(op);
      for (var _path of newDirtyPaths) {
        add(_path);
      }
      DIRTY_PATHS.set(editor, dirtyPaths);
      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
      Transforms.transform(editor, op);
      editor.operations.push(op);
      Editor.normalize(editor, {
        operation: op
      });
      if (op.type === "set_selection") {
        editor.marks = null;
      }
      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange({
            operation: op
          });
          editor.operations = [];
        });
      }
    },
    addMark: (key, value2) => {
      var {
        selection,
        markableVoid
      } = editor;
      if (selection) {
        var match2 = (node2, path) => {
          if (!Text2.isText(node2)) {
            return false;
          }
          var [parentNode2, parentPath] = Editor.parent(editor, path);
          return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
          var [selectedNode, selectedPath] = Editor.node(editor, selection);
          if (selectedNode && match2(selectedNode, selectedPath)) {
            var [parentNode] = Editor.parent(editor, selectedPath);
            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
          }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
          Transforms.setNodes(editor, {
            [key]: value2
          }, {
            match: match2,
            split: true,
            voids: true
          });
        } else {
          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {
            [key]: value2
          });
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    deleteBackward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    },
    deleteForward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    },
    deleteFragment: (direction) => {
      var {
        selection
      } = editor;
      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor, {
          reverse: direction === "backward"
        });
      }
    },
    getFragment: () => {
      var {
        selection
      } = editor;
      if (selection) {
        return Node2.fragment(editor, selection);
      }
      return [];
    },
    insertBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertSoftBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertFragment: (fragment) => {
      Transforms.insertFragment(editor, fragment);
    },
    insertNode: (node2) => {
      Transforms.insertNodes(editor, node2);
    },
    insertText: (text3) => {
      var {
        selection,
        marks
      } = editor;
      if (selection) {
        if (marks) {
          var node2 = _objectSpread$9({
            text: text3
          }, marks);
          Transforms.insertNodes(editor, node2);
        } else {
          Transforms.insertText(editor, text3);
        }
        editor.marks = null;
      }
    },
    normalizeNode: (entry) => {
      var [node2, path] = entry;
      if (Text2.isText(node2)) {
        return;
      }
      if (Element2.isElement(node2) && node2.children.length === 0) {
        var child = {
          text: ""
        };
        Transforms.insertNodes(editor, child, {
          at: path.concat(0),
          voids: true
        });
        return;
      }
      var shouldHaveInlines = Editor.isEditor(node2) ? false : Element2.isElement(node2) && (editor.isInline(node2) || node2.children.length === 0 || Text2.isText(node2.children[0]) || editor.isInline(node2.children[0]));
      var n5 = 0;
      for (var i4 = 0; i4 < node2.children.length; i4++, n5++) {
        var currentNode = Node2.get(editor, path);
        if (Text2.isText(currentNode)) continue;
        var _child = node2.children[i4];
        var prev2 = currentNode.children[n5 - 1];
        var isLast = i4 === node2.children.length - 1;
        var isInlineOrText = Text2.isText(_child) || Element2.isElement(_child) && editor.isInline(_child);
        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path.concat(n5),
            voids: true
          });
          n5--;
        } else if (Element2.isElement(_child)) {
          if (editor.isInline(_child)) {
            if (prev2 == null || !Text2.isText(prev2)) {
              var newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, newChild, {
                at: path.concat(n5),
                voids: true
              });
              n5++;
            } else if (isLast) {
              var _newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path.concat(n5 + 1),
                voids: true
              });
              n5++;
            }
          }
        } else {
          if (prev2 != null && Text2.isText(prev2)) {
            if (Text2.equals(_child, prev2, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path.concat(n5),
                voids: true
              });
              n5--;
            } else if (prev2.text === "") {
              Transforms.removeNodes(editor, {
                at: path.concat(n5 - 1),
                voids: true
              });
              n5--;
            } else if (_child.text === "") {
              Transforms.removeNodes(editor, {
                at: path.concat(n5),
                voids: true
              });
              n5--;
            }
          }
        }
      }
    },
    removeMark: (key) => {
      var {
        selection
      } = editor;
      if (selection) {
        var match2 = (node2, path) => {
          if (!Text2.isText(node2)) {
            return false;
          }
          var [parentNode2, parentPath] = Editor.parent(editor, path);
          return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
          var [selectedNode, selectedPath] = Editor.node(editor, selection);
          if (selectedNode && match2(selectedNode, selectedPath)) {
            var [parentNode] = Editor.parent(editor, selectedPath);
            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
          }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
          Transforms.unsetNodes(editor, key, {
            match: match2,
            split: true,
            voids: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor.marks(editor) || {});
          delete marks[key];
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    /**
     * Get the "dirty" paths generated from an operation.
     */
    getDirtyPaths: (op) => {
      switch (op.type) {
        case "insert_text":
        case "remove_text":
        case "set_node": {
          var {
            path
          } = op;
          return Path.levels(path);
        }
        case "insert_node": {
          var {
            node: node2,
            path: _path2
          } = op;
          var levels2 = Path.levels(_path2);
          var descendants = Text2.isText(node2) ? [] : Array.from(Node2.nodes(node2), (_ref3) => {
            var [, p5] = _ref3;
            return _path2.concat(p5);
          });
          return [...levels2, ...descendants];
        }
        case "merge_node": {
          var {
            path: _path3
          } = op;
          var ancestors = Path.ancestors(_path3);
          var previousPath = Path.previous(_path3);
          return [...ancestors, previousPath];
        }
        case "move_node": {
          var {
            path: _path4,
            newPath
          } = op;
          if (Path.equals(_path4, newPath)) {
            return [];
          }
          var oldAncestors = [];
          var newAncestors = [];
          for (var ancestor of Path.ancestors(_path4)) {
            var p4 = Path.transform(ancestor, op);
            oldAncestors.push(p4);
          }
          for (var _ancestor of Path.ancestors(newPath)) {
            var _p = Path.transform(_ancestor, op);
            newAncestors.push(_p);
          }
          var newParent = newAncestors[newAncestors.length - 1];
          var newIndex = newPath[newPath.length - 1];
          var resultPath = newParent.concat(newIndex);
          return [...oldAncestors, ...newAncestors, resultPath];
        }
        case "remove_node": {
          var {
            path: _path5
          } = op;
          var _ancestors = Path.ancestors(_path5);
          return [..._ancestors];
        }
        case "split_node": {
          var {
            path: _path6
          } = op;
          var _levels = Path.levels(_path6);
          var nextPath = Path.next(_path6);
          return [..._levels, nextPath];
        }
        default: {
          return [];
        }
      }
    },
    shouldNormalize: (_ref4) => {
      var {
        iteration,
        initialDirtyPathsLength
      } = _ref4;
      var maxIterations = initialDirtyPathsLength * 42;
      if (iteration > maxIterations) {
        throw new Error("Could not completely normalize the editor after ".concat(maxIterations, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
      }
      return true;
    }
  };
  return editor;
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i4;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
      key = sourceSymbolKeys[i4];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var getCharacterDistance = function getCharacterDistance2(str) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var isLTR = !isRTL;
  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;
  var left = CodepointType.None;
  var right = CodepointType.None;
  var distance = 0;
  var gb11 = null;
  var gb12Or13 = null;
  for (var char2 of codepoints) {
    var code = char2.codePointAt(0);
    if (!code) break;
    var type3 = getCodepointType(char2, code);
    [left, right] = isLTR ? [right, type3] : [type3, left];
    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
      if (isLTR) {
        gb11 = endsWithEmojiZWJ(str.substring(0, distance));
      } else {
        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));
      }
      if (!gb11) break;
    }
    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
      if (gb12Or13 !== null) {
        gb12Or13 = !gb12Or13;
      } else {
        if (isLTR) {
          gb12Or13 = true;
        } else {
          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));
        }
      }
      if (!gb12Or13) break;
    }
    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
      break;
    }
    distance += char2.length;
  }
  return distance || 1;
};
var SPACE = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var getWordDistance = function getWordDistance2(text3) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var dist = 0;
  var started = false;
  while (text3.length > 0) {
    var charDist = getCharacterDistance(text3, isRTL);
    var [char2, remaining] = splitByCharacterDistance(text3, charDist, isRTL);
    if (isWordCharacter(char2, remaining, isRTL)) {
      started = true;
      dist += charDist;
    } else if (!started) {
      dist += charDist;
    } else {
      break;
    }
    text3 = remaining;
  }
  return dist;
};
var splitByCharacterDistance = (str, dist, isRTL) => {
  if (isRTL) {
    var at = str.length - dist;
    return [str.slice(at, str.length), str.slice(0, at)];
  }
  return [str.slice(0, dist), str.slice(dist)];
};
var isWordCharacter = function isWordCharacter2(char2, remaining) {
  var isRTL = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (SPACE.test(char2)) {
    return false;
  }
  if (CHAMELEON.test(char2)) {
    var charDist = getCharacterDistance(remaining, isRTL);
    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);
    if (isWordCharacter2(nextChar, nextRemaining, isRTL)) {
      return true;
    }
  }
  if (PUNCTUATION.test(char2)) {
    return false;
  }
  return true;
};
var codepointsIteratorRTL = function* codepointsIteratorRTL2(str) {
  var end = str.length - 1;
  for (var i4 = 0; i4 < str.length; i4++) {
    var char1 = str.charAt(end - i4);
    if (isLowSurrogate(char1.charCodeAt(0))) {
      var char2 = str.charAt(end - i4 - 1);
      if (isHighSurrogate(char2.charCodeAt(0))) {
        yield char2 + char1;
        i4++;
        continue;
      }
    }
    yield char1;
  }
};
var isHighSurrogate = (charCode) => {
  return charCode >= 55296 && charCode <= 56319;
};
var isLowSurrogate = (charCode) => {
  return charCode >= 56320 && charCode <= 57343;
};
var CodepointType;
(function(CodepointType2) {
  CodepointType2[CodepointType2["None"] = 0] = "None";
  CodepointType2[CodepointType2["Extend"] = 1] = "Extend";
  CodepointType2[CodepointType2["ZWJ"] = 2] = "ZWJ";
  CodepointType2[CodepointType2["RI"] = 4] = "RI";
  CodepointType2[CodepointType2["Prepend"] = 8] = "Prepend";
  CodepointType2[CodepointType2["SpacingMark"] = 16] = "SpacingMark";
  CodepointType2[CodepointType2["L"] = 32] = "L";
  CodepointType2[CodepointType2["V"] = 64] = "V";
  CodepointType2[CodepointType2["T"] = 128] = "T";
  CodepointType2[CodepointType2["LV"] = 256] = "LV";
  CodepointType2[CodepointType2["LVT"] = 512] = "LVT";
  CodepointType2[CodepointType2["ExtPict"] = 1024] = "ExtPict";
  CodepointType2[CodepointType2["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
var getCodepointType = (char2, code) => {
  var type3 = CodepointType.Any;
  if (char2.search(reExtend) !== -1) {
    type3 |= CodepointType.Extend;
  }
  if (code === 8205) {
    type3 |= CodepointType.ZWJ;
  }
  if (code >= 127462 && code <= 127487) {
    type3 |= CodepointType.RI;
  }
  if (char2.search(rePrepend) !== -1) {
    type3 |= CodepointType.Prepend;
  }
  if (char2.search(reSpacingMark) !== -1) {
    type3 |= CodepointType.SpacingMark;
  }
  if (char2.search(reL) !== -1) {
    type3 |= CodepointType.L;
  }
  if (char2.search(reV) !== -1) {
    type3 |= CodepointType.V;
  }
  if (char2.search(reT) !== -1) {
    type3 |= CodepointType.T;
  }
  if (char2.search(reLV) !== -1) {
    type3 |= CodepointType.LV;
  }
  if (char2.search(reLVT) !== -1) {
    type3 |= CodepointType.LVT;
  }
  if (char2.search(reExtPict) !== -1) {
    type3 |= CodepointType.ExtPict;
  }
  return type3;
};
function intersects(x3, y3) {
  return (x3 & y3) !== 0;
}
var NonBoundaryPairs = [
  // GB6
  [CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],
  // GB7
  [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],
  // GB8
  [CodepointType.LVT | CodepointType.T, CodepointType.T],
  // GB9
  [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],
  // GB9a
  [CodepointType.Any, CodepointType.SpacingMark],
  // GB9b
  [CodepointType.Prepend, CodepointType.Any],
  // GB11
  [CodepointType.ZWJ, CodepointType.ExtPict],
  // GB12 and GB13
  [CodepointType.RI, CodepointType.RI]
];
function isBoundaryPair(left, right) {
  return NonBoundaryPairs.findIndex((r6) => intersects(left, r6[0]) && intersects(right, r6[1])) === -1;
}
var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
var endsWithEmojiZWJ = (str) => {
  return str.search(endingEmojiZWJ) !== -1;
};
var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
var endsWithOddNumberOfRIs = (str) => {
  var match2 = str.match(endingRIs);
  if (match2 === null) {
    return false;
  } else {
    var numRIs = match2[0].length / 2;
    return numRIs % 2 === 1;
  }
};
var isElement = (value2) => {
  return isPlainObject(value2) && Node2.isNodeList(value2.children) && !Editor.isEditor(value2);
};
var Element2 = {
  /**
   * Check if a value implements the 'Ancestor' interface.
   */
  isAncestor(value2) {
    return isPlainObject(value2) && Node2.isNodeList(value2.children);
  },
  /**
   * Check if a value implements the `Element` interface.
   */
  isElement,
  /**
   * Check if a value is an array of `Element` objects.
   */
  isElementList(value2) {
    return Array.isArray(value2) && value2.every((val) => Element2.isElement(val));
  },
  /**
   * Check if a set of props is a partial of Element.
   */
  isElementProps(props) {
    return props.children !== void 0;
  },
  /**
   * Check if a value implements the `Element` interface and has elementKey with selected value.
   * Default it check to `type` key value
   */
  isElementType: function isElementType(value2, elementVal) {
    var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return isElement(value2) && value2[elementKey] === elementVal;
  },
  /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */
  matches(element2, props) {
    for (var key in props) {
      if (key === "children") {
        continue;
      }
      if (element2[key] !== props[key]) {
        return false;
      }
    }
    return true;
  }
};
var _excluded$4 = ["text"];
var _excluded2$3 = ["text"];
function ownKeys$8(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$8(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();
var Editor = {
  /**
   * Get the ancestor above a location in the document.
   */
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      voids = false,
      mode = "lowest",
      at = editor.selection,
      match: match2
    } = options;
    if (!at) {
      return;
    }
    var path = Editor.path(editor, at);
    var reverse = mode === "lowest";
    for (var [n5, p4] of Editor.levels(editor, {
      at: path,
      voids,
      match: match2,
      reverse
    })) {
      if (Text2.isText(n5)) continue;
      if (Range.isRange(at)) {
        if (Path.isAncestor(p4, at.anchor.path) && Path.isAncestor(p4, at.focus.path)) {
          return [n5, p4];
        }
      } else {
        if (!Path.equals(path, p4)) {
          return [n5, p4];
        }
      }
    }
  },
  /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */
  addMark(editor, key, value2) {
    editor.addMark(key, value2);
  },
  /**
   * Get the point after a location.
   */
  after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor.point(editor, at, {
      edge: "end"
    });
    var focus = Editor.end(editor, []);
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d5 = 0;
    var target;
    for (var p4 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range
    }))) {
      if (d5 > distance) {
        break;
      }
      if (d5 !== 0) {
        target = p4;
      }
      d5++;
    }
    return target;
  },
  /**
   * Get the point before a location.
   */
  before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor.start(editor, []);
    var focus = Editor.point(editor, at, {
      edge: "start"
    });
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d5 = 0;
    var target;
    for (var p4 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range,
      reverse: true
    }))) {
      if (d5 > distance) {
        break;
      }
      if (d5 !== 0) {
        target = p4;
      }
      d5++;
    }
    return target;
  },
  /**
   * Delete content in the editor backward from the current selection.
   */
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteBackward(unit);
  },
  /**
   * Delete content in the editor forward from the current selection.
   */
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteForward(unit);
  },
  /**
   * Delete the content in the current selection.
   */
  deleteFragment(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      direction = "forward"
    } = options;
    editor.deleteFragment(direction);
  },
  /**
   * Get the start and end points of a location.
   */
  edges(editor, at) {
    return [Editor.start(editor, at), Editor.end(editor, at)];
  },
  /**
   * Get the end point of a location.
   */
  end(editor, at) {
    return Editor.point(editor, at, {
      edge: "end"
    });
  },
  /**
   * Get the first node at a location.
   */
  first(editor, at) {
    var path = Editor.path(editor, at, {
      edge: "start"
    });
    return Editor.node(editor, path);
  },
  /**
   * Get the fragment at a location.
   */
  fragment(editor, at) {
    var range = Editor.range(editor, at);
    var fragment = Node2.fragment(editor, range);
    return fragment;
  },
  /**
   * Check if a node has block children.
   */
  hasBlocks(editor, element2) {
    return element2.children.some((n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5));
  },
  /**
   * Check if a node has inline and text children.
   */
  hasInlines(editor, element2) {
    return element2.children.some((n5) => Text2.isText(n5) || Editor.isInline(editor, n5));
  },
  /**
   * Check if a node has text children.
   */
  hasTexts(editor, element2) {
    return element2.children.every((n5) => Text2.isText(n5));
  },
  /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertBreak(editor) {
    editor.insertBreak();
  },
  /**
   * Insert a soft break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertSoftBreak(editor) {
    editor.insertSoftBreak();
  },
  /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertFragment(editor, fragment) {
    editor.insertFragment(fragment);
  },
  /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertNode(editor, node2) {
    editor.insertNode(node2);
  },
  /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertText(editor, text3) {
    editor.insertText(text3);
  },
  /**
   * Check if a value is a block `Element` object.
   */
  isBlock(editor, value2) {
    return !editor.isInline(value2);
  },
  /**
   * Check if a value is an `Editor` object.
   */
  isEditor(value2) {
    var cachedIsEditor = IS_EDITOR_CACHE.get(value2);
    if (cachedIsEditor !== void 0) {
      return cachedIsEditor;
    }
    if (!isPlainObject(value2)) {
      return false;
    }
    var isEditor = typeof value2.addMark === "function" && typeof value2.apply === "function" && typeof value2.deleteBackward === "function" && typeof value2.deleteForward === "function" && typeof value2.deleteFragment === "function" && typeof value2.insertBreak === "function" && typeof value2.insertSoftBreak === "function" && typeof value2.insertFragment === "function" && typeof value2.insertNode === "function" && typeof value2.insertText === "function" && typeof value2.isInline === "function" && typeof value2.isVoid === "function" && typeof value2.normalizeNode === "function" && typeof value2.onChange === "function" && typeof value2.removeMark === "function" && typeof value2.getDirtyPaths === "function" && (value2.marks === null || isPlainObject(value2.marks)) && (value2.selection === null || Range.isRange(value2.selection)) && Node2.isNodeList(value2.children) && Operation.isOperationList(value2.operations);
    IS_EDITOR_CACHE.set(value2, isEditor);
    return isEditor;
  },
  /**
   * Check if a point is the end point of a location.
   */
  isEnd(editor, point, at) {
    var end = Editor.end(editor, at);
    return Point.equals(point, end);
  },
  /**
   * Check if a point is an edge of a location.
   */
  isEdge(editor, point, at) {
    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);
  },
  /**
   * Check if an element is empty, accounting for void nodes.
   */
  isEmpty(editor, element2) {
    var {
      children
    } = element2;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text2.isText(first) && first.text === "" && !editor.isVoid(element2);
  },
  /**
   * Check if a value is an inline `Element` object.
   */
  isInline(editor, value2) {
    return editor.isInline(value2);
  },
  /**
   * Check if the editor is currently normalizing after each operation.
   */
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === void 0 ? true : isNormalizing;
  },
  /**
   * Check if a point is the start point of a location.
   */
  isStart(editor, point, at) {
    if (point.offset !== 0) {
      return false;
    }
    var start2 = Editor.start(editor, at);
    return Point.equals(point, start2);
  },
  /**
   * Check if a value is a void `Element` object.
   */
  isVoid(editor, value2) {
    return editor.isVoid(value2);
  },
  /**
   * Get the last node at a location.
   */
  last(editor, at) {
    var path = Editor.path(editor, at, {
      edge: "end"
    });
    return Editor.node(editor, path);
  },
  /**
   * Get the leaf text node at a location.
   */
  leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node2 = Node2.leaf(editor, path);
    return [node2, path];
  },
  /**
   * Iterate through all of the levels at a location.
   */
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match2
    } = options;
    if (match2 == null) {
      match2 = () => true;
    }
    if (!at) {
      return;
    }
    var levels2 = [];
    var path = Editor.path(editor, at);
    for (var [n5, p4] of Node2.levels(editor, path)) {
      if (!match2(n5, p4)) {
        continue;
      }
      levels2.push([n5, p4]);
      if (!voids && Element2.isElement(n5) && Editor.isVoid(editor, n5)) {
        break;
      }
    }
    if (reverse) {
      levels2.reverse();
    }
    yield* levels2;
  },
  /**
   * Get the marks that would be added to text at the current selection.
   */
  marks(editor) {
    var {
      marks,
      selection
    } = editor;
    if (!selection) {
      return null;
    }
    if (marks) {
      return marks;
    }
    if (Range.isExpanded(selection)) {
      var [match2] = Editor.nodes(editor, {
        match: Text2.isText
      });
      if (match2) {
        var [_node] = match2;
        var _rest = _objectWithoutProperties(_node, _excluded$4);
        return _rest;
      } else {
        return {};
      }
    }
    var {
      anchor
    } = selection;
    var {
      path
    } = anchor;
    var [node2] = Editor.leaf(editor, path);
    if (anchor.offset === 0) {
      var prev2 = Editor.previous(editor, {
        at: path,
        match: Text2.isText
      });
      var markedVoid = Editor.above(editor, {
        match: (n5) => Element2.isElement(n5) && Editor.isVoid(editor, n5) && editor.markableVoid(n5)
      });
      if (!markedVoid) {
        var block2 = Editor.above(editor, {
          match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5)
        });
        if (prev2 && block2) {
          var [prevNode, prevPath] = prev2;
          var [, blockPath] = block2;
          if (Path.isAncestor(blockPath, prevPath)) {
            node2 = prevNode;
          }
        }
      }
    }
    var rest = _objectWithoutProperties(node2, _excluded2$3);
    return rest;
  },
  /**
   * Get the matching node in the branch of the document after a location.
   */
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match: match2,
      at = editor.selection
    } = options;
    if (!at) {
      return;
    }
    var pointAfterLocation = Editor.after(editor, at, {
      voids
    });
    if (!pointAfterLocation) return;
    var [, to] = Editor.last(editor, []);
    var span = [pointAfterLocation.path, to];
    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }
    if (match2 == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);
        match2 = (n5) => parent.children.includes(n5);
      } else {
        match2 = () => true;
      }
    }
    var [next2] = Editor.nodes(editor, {
      at: span,
      match: match2,
      mode,
      voids
    });
    return next2;
  },
  /**
   * Get the node at a location.
   */
  node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node2 = Node2.get(editor, path);
    return [node2, path];
  },
  /**
   * Iterate through all of the nodes in the Editor.
   */
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      mode = "all",
      universal = false,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match2
    } = options;
    if (!match2) {
      match2 = () => true;
    }
    if (!at) {
      return;
    }
    var from4;
    var to;
    if (Span.isSpan(at)) {
      from4 = at[0];
      to = at[1];
    } else {
      var first = Editor.path(editor, at, {
        edge: "start"
      });
      var last2 = Editor.path(editor, at, {
        edge: "end"
      });
      from4 = reverse ? last2 : first;
      to = reverse ? first : last2;
    }
    var nodeEntries = Node2.nodes(editor, {
      reverse,
      from: from4,
      to,
      pass: (_ref) => {
        var [n5] = _ref;
        return voids ? false : Element2.isElement(n5) && Editor.isVoid(editor, n5);
      }
    });
    var matches = [];
    var hit;
    for (var [node2, path] of nodeEntries) {
      var isLower = hit && Path.compare(path, hit[1]) === 0;
      if (mode === "highest" && isLower) {
        continue;
      }
      if (!match2(node2, path)) {
        if (universal && !isLower && Text2.isText(node2)) {
          return;
        } else {
          continue;
        }
      }
      if (mode === "lowest" && isLower) {
        hit = [node2, path];
        continue;
      }
      var emit = mode === "lowest" ? hit : [node2, path];
      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }
      hit = [node2, path];
    }
    if (mode === "lowest" && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    }
    if (universal) {
      yield* matches;
    }
  },
  /**
   * Normalize any dirty objects in the editor.
   */
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      force = false,
      operation
    } = options;
    var getDirtyPaths = (editor2) => {
      return DIRTY_PATHS.get(editor2) || [];
    };
    var getDirtyPathKeys = (editor2) => {
      return DIRTY_PATH_KEYS.get(editor2) || /* @__PURE__ */ new Set();
    };
    var popDirtyPath = (editor2) => {
      var path = getDirtyPaths(editor2).pop();
      var key = path.join(",");
      getDirtyPathKeys(editor2).delete(key);
      return path;
    };
    if (!Editor.isNormalizing(editor)) {
      return;
    }
    if (force) {
      var allPaths = Array.from(Node2.nodes(editor), (_ref2) => {
        var [, p4] = _ref2;
        return p4;
      });
      var allPathKeys = new Set(allPaths.map((p4) => p4.join(",")));
      DIRTY_PATHS.set(editor, allPaths);
      DIRTY_PATH_KEYS.set(editor, allPathKeys);
    }
    if (getDirtyPaths(editor).length === 0) {
      return;
    }
    Editor.withoutNormalizing(editor, () => {
      for (var dirtyPath of getDirtyPaths(editor)) {
        if (Node2.has(editor, dirtyPath)) {
          var entry = Editor.node(editor, dirtyPath);
          var [node2, _2] = entry;
          if (Element2.isElement(node2) && node2.children.length === 0) {
            editor.normalizeNode(entry, {
              operation
            });
          }
        }
      }
      var dirtyPaths = getDirtyPaths(editor);
      var initialDirtyPathsLength = dirtyPaths.length;
      var iteration = 0;
      while (dirtyPaths.length !== 0) {
        if (!editor.shouldNormalize({
          dirtyPaths,
          iteration,
          initialDirtyPathsLength,
          operation
        })) {
          return;
        }
        var _dirtyPath = popDirtyPath(editor);
        if (Node2.has(editor, _dirtyPath)) {
          var _entry = Editor.node(editor, _dirtyPath);
          editor.normalizeNode(_entry, {
            operation
          });
        }
        iteration++;
        dirtyPaths = getDirtyPaths(editor);
      }
    });
  },
  /**
   * Get the parent node of a location.
   */
  parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var parentPath = Path.parent(path);
    var entry = Editor.node(editor, parentPath);
    return entry;
  },
  /**
   * Get the path of a location.
   */
  path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;
    if (Path.isPath(at)) {
      if (edge === "start") {
        var [, firstPath] = Node2.first(editor, at);
        at = firstPath;
      } else if (edge === "end") {
        var [, lastPath] = Node2.last(editor, at);
        at = lastPath;
      }
    }
    if (Range.isRange(at)) {
      if (edge === "start") {
        at = Range.start(at);
      } else if (edge === "end") {
        at = Range.end(at);
      } else {
        at = Path.common(at.anchor.path, at.focus.path);
      }
    }
    if (Point.isPoint(at)) {
      at = at.path;
    }
    if (depth != null) {
      at = at.slice(0, depth);
    }
    return at;
  },
  hasPath(editor, path) {
    return Node2.has(editor, path);
  },
  /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pathRef(editor, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: path,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var pathRefs = Editor.pathRefs(editor);
        pathRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.pathRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked path refs of the editor.
   */
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      PATH_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Get the start or end point of a location.
   */
  point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      edge = "start"
    } = options;
    if (Path.isPath(at)) {
      var path;
      if (edge === "end") {
        var [, lastPath] = Node2.last(editor, at);
        path = lastPath;
      } else {
        var [, firstPath] = Node2.first(editor, at);
        path = firstPath;
      }
      var node2 = Node2.get(editor, path);
      if (!Text2.isText(node2)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
      }
      return {
        path,
        offset: edge === "end" ? node2.text.length : 0
      };
    }
    if (Range.isRange(at)) {
      var [start2, end] = Range.edges(at);
      return edge === "start" ? start2 : end;
    }
    return at;
  },
  /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: point,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var pointRefs = Editor.pointRefs(editor);
        pointRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.pointRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked point refs of the editor.
   */
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      POINT_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Return all the positions in `at` range where a `Point` can be placed.
   *
   * By default, moves forward by individual offsets at a time, but
   * the `unit` option can be used to to move by character, word, line, or block.
   *
   * The `reverse` option can be used to change iteration direction.
   *
   * Note: By default void nodes are treated as a single point and iteration
   * will not happen inside their content unless you pass in true for the
   * `voids` option, then iteration will occur.
   */
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      unit = "offset",
      reverse = false,
      voids = false
    } = options;
    if (!at) {
      return;
    }
    var range = Editor.range(editor, at);
    var [start2, end] = Range.edges(range);
    var first = reverse ? end : start2;
    var isNewBlock = false;
    var blockText = "";
    var distance = 0;
    var leafTextRemaining = 0;
    var leafTextOffset = 0;
    for (var [node2, path] of Editor.nodes(editor, {
      at,
      reverse,
      voids
    })) {
      if (Element2.isElement(node2)) {
        if (!voids && editor.isVoid(node2)) {
          yield Editor.start(editor, path);
          continue;
        }
        if (editor.isInline(node2)) continue;
        if (Editor.hasInlines(editor, node2)) {
          var e4 = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);
          var s4 = Path.isAncestor(path, start2.path) ? start2 : Editor.start(editor, path);
          blockText = Editor.string(editor, {
            anchor: s4,
            focus: e4
          }, {
            voids
          });
          isNewBlock = true;
        }
      }
      if (Text2.isText(node2)) {
        var isFirst = Path.equals(path, first.path);
        if (isFirst) {
          leafTextRemaining = reverse ? first.offset : node2.text.length - first.offset;
          leafTextOffset = first.offset;
        } else {
          leafTextRemaining = node2.text.length;
          leafTextOffset = reverse ? leafTextRemaining : 0;
        }
        if (isFirst || isNewBlock || unit === "offset") {
          yield {
            path,
            offset: leafTextOffset
          };
          isNewBlock = false;
        }
        while (true) {
          if (distance === 0) {
            if (blockText === "") break;
            distance = calcDistance(blockText, unit, reverse);
            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];
          }
          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;
          leafTextRemaining = leafTextRemaining - distance;
          if (leafTextRemaining < 0) {
            distance = -leafTextRemaining;
            break;
          }
          distance = 0;
          yield {
            path,
            offset: leafTextOffset
          };
        }
      }
    }
    function calcDistance(text3, unit2, reverse2) {
      if (unit2 === "character") {
        return getCharacterDistance(text3, reverse2);
      } else if (unit2 === "word") {
        return getWordDistance(text3, reverse2);
      } else if (unit2 === "line" || unit2 === "block") {
        return text3.length;
      }
      return 1;
    }
  },
  /**
   * Get the matching node in the branch of the document before a location.
   */
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match: match2,
      at = editor.selection
    } = options;
    if (!at) {
      return;
    }
    var pointBeforeLocation = Editor.before(editor, at, {
      voids
    });
    if (!pointBeforeLocation) {
      return;
    }
    var [, to] = Editor.first(editor, []);
    var span = [pointBeforeLocation.path, to];
    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }
    if (match2 == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);
        match2 = (n5) => parent.children.includes(n5);
      } else {
        match2 = () => true;
      }
    }
    var [previous] = Editor.nodes(editor, {
      reverse: true,
      at: span,
      match: match2,
      mode,
      voids
    });
    return previous;
  },
  /**
   * Get a range of a location.
   */
  range(editor, at, to) {
    if (Range.isRange(at) && !to) {
      return at;
    }
    var start2 = Editor.start(editor, at);
    var end = Editor.end(editor, to || at);
    return {
      anchor: start2,
      focus: end
    };
  },
  /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: range,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var rangeRefs = Editor.rangeRefs(editor);
        rangeRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.rangeRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked range refs of the editor.
   */
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      RANGE_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */
  removeMark(editor, key) {
    editor.removeMark(key);
  },
  /**
   * Manually set if the editor should currently be normalizing.
   *
   * Note: Using this incorrectly can leave the editor in an invalid state.
   *
   */
  setNormalizing(editor, isNormalizing) {
    NORMALIZING.set(editor, isNormalizing);
  },
  /**
   * Get the start point of a location.
   */
  start(editor, at) {
    return Editor.point(editor, at, {
      edge: "start"
    });
  },
  /**
   * Get the text string content of a location.
   *
   * Note: by default the text of void nodes is considered to be an empty
   * string, regardless of content, unless you pass in true for the voids option
   */
  string(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var range = Editor.range(editor, at);
    var [start2, end] = Range.edges(range);
    var text3 = "";
    for (var [node2, path] of Editor.nodes(editor, {
      at: range,
      match: Text2.isText,
      voids
    })) {
      var t4 = node2.text;
      if (Path.equals(path, end.path)) {
        t4 = t4.slice(0, end.offset);
      }
      if (Path.equals(path, start2.path)) {
        t4 = t4.slice(start2.offset);
      }
      text3 += t4;
    }
    return text3;
  },
  /**
   * Convert a range into a non-hanging one.
   */
  unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start2, end] = Range.edges(range);
    if (start2.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {
      return range;
    }
    var endBlock = Editor.above(editor, {
      at: end,
      match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5),
      voids
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor.start(editor, start2);
    var before = {
      anchor: first,
      focus: end
    };
    var skip = true;
    for (var [node2, path] of Editor.nodes(editor, {
      at: before,
      match: Text2.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }
      if (node2.text !== "" || Path.isBefore(path, blockPath)) {
        end = {
          path,
          offset: node2.text.length
        };
        break;
      }
    }
    return {
      anchor: start2,
      focus: end
    };
  },
  /**
   * Match a void node in the current branch of the editor.
   */
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      match: (n5) => Element2.isElement(n5) && Editor.isVoid(editor, n5)
    }));
  },
  /**
   * Call a function, deferring normalization until after it completes.
   */
  withoutNormalizing(editor, fn2) {
    var value2 = Editor.isNormalizing(editor);
    Editor.setNormalizing(editor, false);
    try {
      fn2();
    } finally {
      Editor.setNormalizing(editor, value2);
    }
    Editor.normalize(editor);
  }
};
var Span = {
  /**
   * Check if a value implements the `Span` interface.
   */
  isSpan(value2) {
    return Array.isArray(value2) && value2.length === 2 && value2.every(Path.isPath);
  }
};
var _excluded$3 = ["children"];
var _excluded2$2 = ["text"];
var IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();
var Node2 = {
  /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */
  ancestor(root, path) {
    var node2 = Node2.get(root, path);
    if (Text2.isText(node2)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node2)));
    }
    return node2;
  },
  /**
   * Return a generator of all the ancestor nodes above a specific path.
   *
   * By default the order is top-down, from highest to lowest ancestor in
   * the tree, but you can pass the `reverse: true` option to go bottom-up.
   */
  *ancestors(root, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p4 of Path.ancestors(path, options)) {
      var n5 = Node2.ancestor(root, p4);
      var entry = [n5, p4];
      yield entry;
    }
  },
  /**
   * Get the child of a node at a specific index.
   */
  child(root, index2) {
    if (Text2.isText(root)) {
      throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root)));
    }
    var c6 = root.children[index2];
    if (c6 == null) {
      throw new Error("Cannot get child at index `".concat(index2, "` in node: ").concat(Scrubber.stringify(root)));
    }
    return c6;
  },
  /**
   * Iterate over the children of a node at a specific path.
   */
  *children(root, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      reverse = false
    } = options;
    var ancestor = Node2.ancestor(root, path);
    var {
      children
    } = ancestor;
    var index2 = reverse ? children.length - 1 : 0;
    while (reverse ? index2 >= 0 : index2 < children.length) {
      var child = Node2.child(ancestor, index2);
      var childPath = path.concat(index2);
      yield [child, childPath];
      index2 = reverse ? index2 - 1 : index2 + 1;
    }
  },
  /**
   * Get an entry for the common ancesetor node of two paths.
   */
  common(root, path, another) {
    var p4 = Path.common(path, another);
    var n5 = Node2.get(root, p4);
    return [n5, p4];
  },
  /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */
  descendant(root, path) {
    var node2 = Node2.get(root, path);
    if (Editor.isEditor(node2)) {
      throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node2)));
    }
    return node2;
  },
  /**
   * Return a generator of all the descendant node entries inside a root node.
   */
  *descendants(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node2, path] of Node2.nodes(root, options)) {
      if (path.length !== 0) {
        yield [node2, path];
      }
    }
  },
  /**
   * Return a generator of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */
  *elements(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node2, path] of Node2.nodes(root, options)) {
      if (Element2.isElement(node2)) {
        yield [node2, path];
      }
    }
  },
  /**
   * Extract props from a Node.
   */
  extractProps(node2) {
    if (Element2.isAncestor(node2)) {
      var properties = _objectWithoutProperties(node2, _excluded$3);
      return properties;
    } else {
      var properties = _objectWithoutProperties(node2, _excluded2$2);
      return properties;
    }
  },
  /**
   * Get the first node entry in a root node from a path.
   */
  first(root, path) {
    var p4 = path.slice();
    var n5 = Node2.get(root, p4);
    while (n5) {
      if (Text2.isText(n5) || n5.children.length === 0) {
        break;
      } else {
        n5 = n5.children[0];
        p4.push(0);
      }
    }
    return [n5, p4];
  },
  /**
   * Get the sliced fragment represented by a range inside a root node.
   */
  fragment(root, range) {
    if (Text2.isText(root)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root)));
    }
    var newRoot = fn({
      children: root.children
    }, (r6) => {
      var [start2, end] = Range.edges(range);
      var nodeEntries = Node2.nodes(r6, {
        reverse: true,
        pass: (_ref) => {
          var [, path2] = _ref;
          return !Range.includes(range, path2);
        }
      });
      for (var [, path] of nodeEntries) {
        if (!Range.includes(range, path)) {
          var parent = Node2.parent(r6, path);
          var index2 = path[path.length - 1];
          parent.children.splice(index2, 1);
        }
        if (Path.equals(path, end.path)) {
          var leaf = Node2.leaf(r6, path);
          leaf.text = leaf.text.slice(0, end.offset);
        }
        if (Path.equals(path, start2.path)) {
          var _leaf = Node2.leaf(r6, path);
          _leaf.text = _leaf.text.slice(start2.offset);
        }
      }
      if (Editor.isEditor(r6)) {
        r6.selection = null;
      }
    });
    return newRoot.children;
  },
  /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */
  get(root, path) {
    var node2 = root;
    for (var i4 = 0; i4 < path.length; i4++) {
      var p4 = path[i4];
      if (Text2.isText(node2) || !node2.children[p4]) {
        throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(Scrubber.stringify(root)));
      }
      node2 = node2.children[p4];
    }
    return node2;
  },
  /**
   * Check if a descendant node exists at a specific path.
   */
  has(root, path) {
    var node2 = root;
    for (var i4 = 0; i4 < path.length; i4++) {
      var p4 = path[i4];
      if (Text2.isText(node2) || !node2.children[p4]) {
        return false;
      }
      node2 = node2.children[p4];
    }
    return true;
  },
  /**
   * Check if a value implements the `Node` interface.
   */
  isNode(value2) {
    return Text2.isText(value2) || Element2.isElement(value2) || Editor.isEditor(value2);
  },
  /**
   * Check if a value is a list of `Node` objects.
   */
  isNodeList(value2) {
    if (!Array.isArray(value2)) {
      return false;
    }
    var cachedResult = IS_NODE_LIST_CACHE.get(value2);
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    var isNodeList = value2.every((val) => Node2.isNode(val));
    IS_NODE_LIST_CACHE.set(value2, isNodeList);
    return isNodeList;
  },
  /**
   * Get the last node entry in a root node from a path.
   */
  last(root, path) {
    var p4 = path.slice();
    var n5 = Node2.get(root, p4);
    while (n5) {
      if (Text2.isText(n5) || n5.children.length === 0) {
        break;
      } else {
        var i4 = n5.children.length - 1;
        n5 = n5.children[i4];
        p4.push(i4);
      }
    }
    return [n5, p4];
  },
  /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */
  leaf(root, path) {
    var node2 = Node2.get(root, path);
    if (!Text2.isText(node2)) {
      throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node2)));
    }
    return node2;
  },
  /**
   * Return a generator of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from highest to lowest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */
  *levels(root, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p4 of Path.levels(path, options)) {
      var n5 = Node2.get(root, p4);
      yield [n5, p4];
    }
  },
  /**
   * Check if a node matches a set of props.
   */
  matches(node2, props) {
    return Element2.isElement(node2) && Element2.isElementProps(props) && Element2.matches(node2, props) || Text2.isText(node2) && Text2.isTextProps(props) && Text2.matches(node2, props);
  },
  /**
   * Return a generator of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */
  *nodes(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      pass,
      reverse = false
    } = options;
    var {
      from: from4 = [],
      to
    } = options;
    var visited = /* @__PURE__ */ new Set();
    var p4 = [];
    var n5 = root;
    while (true) {
      if (to && (reverse ? Path.isBefore(p4, to) : Path.isAfter(p4, to))) {
        break;
      }
      if (!visited.has(n5)) {
        yield [n5, p4];
      }
      if (!visited.has(n5) && !Text2.isText(n5) && n5.children.length !== 0 && (pass == null || pass([n5, p4]) === false)) {
        visited.add(n5);
        var nextIndex = reverse ? n5.children.length - 1 : 0;
        if (Path.isAncestor(p4, from4)) {
          nextIndex = from4[p4.length];
        }
        p4 = p4.concat(nextIndex);
        n5 = Node2.get(root, p4);
        continue;
      }
      if (p4.length === 0) {
        break;
      }
      if (!reverse) {
        var newPath = Path.next(p4);
        if (Node2.has(root, newPath)) {
          p4 = newPath;
          n5 = Node2.get(root, p4);
          continue;
        }
      }
      if (reverse && p4[p4.length - 1] !== 0) {
        var _newPath = Path.previous(p4);
        p4 = _newPath;
        n5 = Node2.get(root, p4);
        continue;
      }
      p4 = Path.parent(p4);
      n5 = Node2.get(root, p4);
      visited.add(n5);
    }
  },
  /**
   * Get the parent of a node at a specific path.
   */
  parent(root, path) {
    var parentPath = Path.parent(path);
    var p4 = Node2.get(root, parentPath);
    if (Text2.isText(p4)) {
      throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
    }
    return p4;
  },
  /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */
  string(node2) {
    if (Text2.isText(node2)) {
      return node2.text;
    } else {
      return node2.children.map(Node2.string).join("");
    }
  },
  /**
   * Return a generator of all leaf text nodes in a root node.
   */
  *texts(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node2, path] of Node2.nodes(root, options)) {
      if (Text2.isText(node2)) {
        yield [node2, path];
      }
    }
  }
};
function ownKeys$7(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$7(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Operation = {
  /**
   * Check if a value is a `NodeOperation` object.
   */
  isNodeOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_node");
  },
  /**
   * Check if a value is an `Operation` object.
   */
  isOperation(value2) {
    if (!isPlainObject(value2)) {
      return false;
    }
    switch (value2.type) {
      case "insert_node":
        return Path.isPath(value2.path) && Node2.isNode(value2.node);
      case "insert_text":
        return typeof value2.offset === "number" && typeof value2.text === "string" && Path.isPath(value2.path);
      case "merge_node":
        return typeof value2.position === "number" && Path.isPath(value2.path) && isPlainObject(value2.properties);
      case "move_node":
        return Path.isPath(value2.path) && Path.isPath(value2.newPath);
      case "remove_node":
        return Path.isPath(value2.path) && Node2.isNode(value2.node);
      case "remove_text":
        return typeof value2.offset === "number" && typeof value2.text === "string" && Path.isPath(value2.path);
      case "set_node":
        return Path.isPath(value2.path) && isPlainObject(value2.properties) && isPlainObject(value2.newProperties);
      case "set_selection":
        return value2.properties === null && Range.isRange(value2.newProperties) || value2.newProperties === null && Range.isRange(value2.properties) || isPlainObject(value2.properties) && isPlainObject(value2.newProperties);
      case "split_node":
        return Path.isPath(value2.path) && typeof value2.position === "number" && isPlainObject(value2.properties);
      default:
        return false;
    }
  },
  /**
   * Check if a value is a list of `Operation` objects.
   */
  isOperationList(value2) {
    return Array.isArray(value2) && value2.every((val) => Operation.isOperation(val));
  },
  /**
   * Check if a value is a `SelectionOperation` object.
   */
  isSelectionOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_selection");
  },
  /**
   * Check if a value is a `TextOperation` object.
   */
  isTextOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_text");
  },
  /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */
  inverse(op) {
    switch (op.type) {
      case "insert_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "remove_node"
        });
      }
      case "insert_text": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "remove_text"
        });
      }
      case "merge_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "split_node",
          path: Path.previous(op.path)
        });
      }
      case "move_node": {
        var {
          newPath,
          path
        } = op;
        if (Path.equals(newPath, path)) {
          return op;
        }
        if (Path.isSibling(path, newPath)) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            path: newPath,
            newPath: path
          });
        }
        var inversePath = Path.transform(path, op);
        var inverseNewPath = Path.transform(Path.next(path), op);
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          path: inversePath,
          newPath: inverseNewPath
        });
      }
      case "remove_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "insert_node"
        });
      }
      case "remove_text": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "insert_text"
        });
      }
      case "set_node": {
        var {
          properties,
          newProperties
        } = op;
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          properties: newProperties,
          newProperties: properties
        });
      }
      case "set_selection": {
        var {
          properties: _properties,
          newProperties: _newProperties
        } = op;
        if (_properties == null) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: _newProperties,
            newProperties: null
          });
        } else if (_newProperties == null) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: null,
            newProperties: _properties
          });
        } else {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: _newProperties,
            newProperties: _properties
          });
        }
      }
      case "split_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "merge_node",
          path: Path.next(op.path)
        });
      }
    }
  }
};
var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from shallowest to deepest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var paths = Path.levels(path, options);
    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }
    return paths;
  },
  /**
   * Get the common ancestor path of two paths.
   */
  common(path, another) {
    var common = [];
    for (var i4 = 0; i4 < path.length && i4 < another.length; i4++) {
      var av = path[i4];
      var bv = another[i4];
      if (av !== bv) {
        break;
      }
      common.push(av);
    }
    return common;
  },
  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path, another) {
    var min2 = Math.min(path.length, another.length);
    for (var i4 = 0; i4 < min2; i4++) {
      if (path[i4] < another[i4]) return -1;
      if (path[i4] > another[i4]) return 1;
    }
    return 0;
  },
  /**
   * Check if a path ends after one of the indexes in another.
   */
  endsAfter(path, another) {
    var i4 = path.length - 1;
    var as = path.slice(0, i4);
    var bs = another.slice(0, i4);
    var av = path[i4];
    var bv = another[i4];
    return Path.equals(as, bs) && av > bv;
  },
  /**
   * Check if a path ends at one of the indexes in another.
   */
  endsAt(path, another) {
    var i4 = path.length;
    var as = path.slice(0, i4);
    var bs = another.slice(0, i4);
    return Path.equals(as, bs);
  },
  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path, another) {
    var i4 = path.length - 1;
    var as = path.slice(0, i4);
    var bs = another.slice(0, i4);
    var av = path[i4];
    var bv = another[i4];
    return Path.equals(as, bs) && av < bv;
  },
  /**
   * Check if a path is exactly equal to another.
   */
  equals(path, another) {
    return path.length === another.length && path.every((n5, i4) => n5 === another[i4]);
  },
  /**
   * Check if the path of previous sibling node exists
   */
  hasPrevious(path) {
    return path[path.length - 1] > 0;
  },
  /**
   * Check if a path is after another.
   */
  isAfter(path, another) {
    return Path.compare(path, another) === 1;
  },
  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path, another) {
    return path.length < another.length && Path.compare(path, another) === 0;
  },
  /**
   * Check if a path is before another.
   */
  isBefore(path, another) {
    return Path.compare(path, another) === -1;
  },
  /**
   * Check if a path is a child of another.
   */
  isChild(path, another) {
    return path.length === another.length + 1 && Path.compare(path, another) === 0;
  },
  /**
   * Check if a path is equal to or an ancestor of another.
   */
  isCommon(path, another) {
    return path.length <= another.length && Path.compare(path, another) === 0;
  },
  /**
   * Check if a path is a descendant of another.
   */
  isDescendant(path, another) {
    return path.length > another.length && Path.compare(path, another) === 0;
  },
  /**
   * Check if a path is the parent of another.
   */
  isParent(path, another) {
    return path.length + 1 === another.length && Path.compare(path, another) === 0;
  },
  /**
   * Check is a value implements the `Path` interface.
   */
  isPath(value2) {
    return Array.isArray(value2) && (value2.length === 0 || typeof value2[0] === "number");
  },
  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path, another) {
    if (path.length !== another.length) {
      return false;
    }
    var as = path.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path[path.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },
  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var list = [];
    for (var i4 = 0; i4 <= path.length; i4++) {
      list.push(path.slice(0, i4));
    }
    if (reverse) {
      list.reverse();
    }
    return list;
  },
  /**
   * Given a path, get the path to the next sibling node.
   */
  next(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
    }
    var last2 = path[path.length - 1];
    return path.slice(0, -1).concat(last2 + 1);
  },
  /**
   * Returns whether this operation can affect paths or not. Used as an
   * optimization when updating dirty paths during normalization
   *
   * NOTE: This *must* be kept in sync with the implementation of 'transform'
   * below
   */
  operationCanTransformPath(operation) {
    switch (operation.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return true;
      default:
        return false;
    }
  },
  /**
   * Given a path, return a new path referring to the parent node above it.
   */
  parent(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
    }
    return path.slice(0, -1);
  },
  /**
   * Given a path, get the path to the previous sibling node.
   */
  previous(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
    }
    var last2 = path[path.length - 1];
    if (last2 <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
    }
    return path.slice(0, -1).concat(last2 - 1);
  },
  /**
   * Get a path relative to an ancestor.
   */
  relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }
    return path.slice(ancestor.length);
  },
  /**
   * Transform a path by an operation.
   */
  transform(path, operation) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!path) return null;
    var p4 = [...path];
    var {
      affinity = "forward"
    } = options;
    if (path.length === 0) {
      return p4;
    }
    switch (operation.type) {
      case "insert_node": {
        var {
          path: op
        } = operation;
        if (Path.equals(op, p4) || Path.endsBefore(op, p4) || Path.isAncestor(op, p4)) {
          p4[op.length - 1] += 1;
        }
        break;
      }
      case "remove_node": {
        var {
          path: _op
        } = operation;
        if (Path.equals(_op, p4) || Path.isAncestor(_op, p4)) {
          return null;
        } else if (Path.endsBefore(_op, p4)) {
          p4[_op.length - 1] -= 1;
        }
        break;
      }
      case "merge_node": {
        var {
          path: _op2,
          position: position2
        } = operation;
        if (Path.equals(_op2, p4) || Path.endsBefore(_op2, p4)) {
          p4[_op2.length - 1] -= 1;
        } else if (Path.isAncestor(_op2, p4)) {
          p4[_op2.length - 1] -= 1;
          p4[_op2.length] += position2;
        }
        break;
      }
      case "split_node": {
        var {
          path: _op3,
          position: _position
        } = operation;
        if (Path.equals(_op3, p4)) {
          if (affinity === "forward") {
            p4[p4.length - 1] += 1;
          } else if (affinity === "backward") ;
          else {
            return null;
          }
        } else if (Path.endsBefore(_op3, p4)) {
          p4[_op3.length - 1] += 1;
        } else if (Path.isAncestor(_op3, p4) && path[_op3.length] >= _position) {
          p4[_op3.length - 1] += 1;
          p4[_op3.length] -= _position;
        }
        break;
      }
      case "move_node": {
        var {
          path: _op4,
          newPath: onp
        } = operation;
        if (Path.equals(_op4, onp)) {
          return p4;
        }
        if (Path.isAncestor(_op4, p4) || Path.equals(_op4, p4)) {
          var copy3 = onp.slice();
          if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
            copy3[_op4.length - 1] -= 1;
          }
          return copy3.concat(p4.slice(_op4.length));
        } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p4) || Path.equals(onp, p4))) {
          if (Path.endsBefore(_op4, p4)) {
            p4[_op4.length - 1] -= 1;
          } else {
            p4[_op4.length - 1] += 1;
          }
        } else if (Path.endsBefore(onp, p4) || Path.equals(onp, p4) || Path.isAncestor(onp, p4)) {
          if (Path.endsBefore(_op4, p4)) {
            p4[_op4.length - 1] -= 1;
          }
          p4[onp.length - 1] += 1;
        } else if (Path.endsBefore(_op4, p4)) {
          if (Path.equals(onp, p4)) {
            p4[onp.length - 1] += 1;
          }
          p4[_op4.length - 1] -= 1;
        }
        break;
      }
    }
    return p4;
  }
};
var PathRef = {
  /**
   * Transform the path ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var path = Path.transform(current, op, {
      affinity
    });
    ref.current = path;
    if (path == null) {
      ref.unref();
    }
  }
};
function ownKeys$6(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$6(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Point = {
  /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */
  compare(point, another) {
    var result = Path.compare(point.path, another.path);
    if (result === 0) {
      if (point.offset < another.offset) return -1;
      if (point.offset > another.offset) return 1;
      return 0;
    }
    return result;
  },
  /**
   * Check if a point is after another.
   */
  isAfter(point, another) {
    return Point.compare(point, another) === 1;
  },
  /**
   * Check if a point is before another.
   */
  isBefore(point, another) {
    return Point.compare(point, another) === -1;
  },
  /**
   * Check if a point is exactly equal to another.
   */
  equals(point, another) {
    return point.offset === another.offset && Path.equals(point.path, another.path);
  },
  /**
   * Check if a value implements the `Point` interface.
   */
  isPoint(value2) {
    return isPlainObject(value2) && typeof value2.offset === "number" && Path.isPath(value2.path);
  },
  /**
   * Transform a point by an operation.
   */
  transform(point, op) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(point, (p4) => {
      if (p4 === null) {
        return null;
      }
      var {
        affinity = "forward"
      } = options;
      var {
        path,
        offset
      } = p4;
      switch (op.type) {
        case "insert_node":
        case "move_node": {
          p4.path = Path.transform(path, op, options);
          break;
        }
        case "insert_text": {
          if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === "forward")) {
            p4.offset += op.text.length;
          }
          break;
        }
        case "merge_node": {
          if (Path.equals(op.path, path)) {
            p4.offset += op.position;
          }
          p4.path = Path.transform(path, op, options);
          break;
        }
        case "remove_text": {
          if (Path.equals(op.path, path) && op.offset <= offset) {
            p4.offset -= Math.min(offset - op.offset, op.text.length);
          }
          break;
        }
        case "remove_node": {
          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
            return null;
          }
          p4.path = Path.transform(path, op, options);
          break;
        }
        case "split_node": {
          if (Path.equals(op.path, path)) {
            if (op.position === offset && affinity == null) {
              return null;
            } else if (op.position < offset || op.position === offset && affinity === "forward") {
              p4.offset -= op.position;
              p4.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {
                affinity: "forward"
              }));
            }
          } else {
            p4.path = Path.transform(path, op, options);
          }
          break;
        }
      }
    });
  }
};
var PointRef = {
  /**
   * Transform the point ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var point = Point.transform(current, op, {
      affinity
    });
    ref.current = point;
    if (point == null) {
      ref.unref();
    }
  }
};
var _excluded$2 = ["anchor", "focus"];
function ownKeys$5(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$5(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Range = {
  /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */
  edges(range) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var {
      anchor,
      focus
    } = range;
    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];
  },
  /**
   * Get the end point of a range.
   */
  end(range) {
    var [, end] = Range.edges(range);
    return end;
  },
  /**
   * Check if a range is exactly equal to another.
   */
  equals(range, another) {
    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
  },
  /**
   * Check if a range includes a path, a point or part of another range.
   */
  includes(range, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
        return true;
      }
      var [rs, re] = Range.edges(range);
      var [ts, te] = Range.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re, te);
    }
    var [start2, end] = Range.edges(range);
    var isAfterStart = false;
    var isBeforeEnd = false;
    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start2) >= 0;
      isBeforeEnd = Point.compare(target, end) <= 0;
    } else {
      isAfterStart = Path.compare(target, start2.path) >= 0;
      isBeforeEnd = Path.compare(target, end.path) <= 0;
    }
    return isAfterStart && isBeforeEnd;
  },
  /**
   * Get the intersection of a range with another.
   */
  intersection(range, another) {
    var rest = _objectWithoutProperties(range, _excluded$2);
    var [s1, e1] = Range.edges(range);
    var [s22, e22] = Range.edges(another);
    var start2 = Point.isBefore(s1, s22) ? s22 : s1;
    var end = Point.isBefore(e1, e22) ? e1 : e22;
    if (Point.isBefore(end, start2)) {
      return null;
    } else {
      return _objectSpread$5({
        anchor: start2,
        focus: end
      }, rest);
    }
  },
  /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */
  isBackward(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.isAfter(anchor, focus);
  },
  /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */
  isCollapsed(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.equals(anchor, focus);
  },
  /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */
  isExpanded(range) {
    return !Range.isCollapsed(range);
  },
  /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */
  isForward(range) {
    return !Range.isBackward(range);
  },
  /**
   * Check if a value implements the [[Range]] interface.
   */
  isRange(value2) {
    return isPlainObject(value2) && Point.isPoint(value2.anchor) && Point.isPoint(value2.focus);
  },
  /**
   * Iterate through all of the point entries in a range.
   */
  *points(range) {
    yield [range.anchor, "anchor"];
    yield [range.focus, "focus"];
  },
  /**
   * Get the start point of a range.
   */
  start(range) {
    var [start2] = Range.edges(range);
    return start2;
  },
  /**
   * Transform a range by an operation.
   */
  transform(range, op) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(range, (r6) => {
      if (r6 === null) {
        return null;
      }
      var {
        affinity = "inward"
      } = options;
      var affinityAnchor;
      var affinityFocus;
      if (affinity === "inward") {
        var isCollapsed = Range.isCollapsed(r6);
        if (Range.isForward(r6)) {
          affinityAnchor = "forward";
          affinityFocus = isCollapsed ? affinityAnchor : "backward";
        } else {
          affinityAnchor = "backward";
          affinityFocus = isCollapsed ? affinityAnchor : "forward";
        }
      } else if (affinity === "outward") {
        if (Range.isForward(r6)) {
          affinityAnchor = "backward";
          affinityFocus = "forward";
        } else {
          affinityAnchor = "forward";
          affinityFocus = "backward";
        }
      } else {
        affinityAnchor = affinity;
        affinityFocus = affinity;
      }
      var anchor = Point.transform(r6.anchor, op, {
        affinity: affinityAnchor
      });
      var focus = Point.transform(r6.focus, op, {
        affinity: affinityFocus
      });
      if (!anchor || !focus) {
        return null;
      }
      r6.anchor = anchor;
      r6.focus = focus;
    });
  }
};
var RangeRef = {
  /**
   * Transform the range ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var path = Range.transform(current, op, {
      affinity
    });
    ref.current = path;
    if (path == null) {
      ref.unref();
    }
  }
};
var _scrubber = void 0;
var Scrubber = {
  setScrubber(scrubber) {
    _scrubber = scrubber;
  },
  stringify(value2) {
    return JSON.stringify(value2, _scrubber);
  }
};
var isDeepEqual = (node2, another) => {
  for (var key in node2) {
    var a3 = node2[key];
    var b2 = another[key];
    if (isPlainObject(a3) && isPlainObject(b2)) {
      if (!isDeepEqual(a3, b2)) return false;
    } else if (Array.isArray(a3) && Array.isArray(b2)) {
      if (a3.length !== b2.length) return false;
      for (var i4 = 0; i4 < a3.length; i4++) {
        if (a3[i4] !== b2[i4]) return false;
      }
    } else if (a3 !== b2) {
      return false;
    }
  }
  for (var _key in another) {
    if (node2[_key] === void 0 && another[_key] !== void 0) {
      return false;
    }
  }
  return true;
};
var _excluded$1 = ["text"];
var _excluded2$1 = ["anchor", "focus"];
function ownKeys$4(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$4(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Text2 = {
  /**
   * Check if two text nodes are equal.
   *
   * When loose is set, the text is not compared. This is
   * used to check whether sibling text nodes can be merged.
   */
  equals(text3, another) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      loose = false
    } = options;
    function omitText(obj) {
      var rest = _objectWithoutProperties(obj, _excluded$1);
      return rest;
    }
    return isDeepEqual(loose ? omitText(text3) : text3, loose ? omitText(another) : another);
  },
  /**
   * Check if a value implements the `Text` interface.
   */
  isText(value2) {
    return isPlainObject(value2) && typeof value2.text === "string";
  },
  /**
   * Check if a value is a list of `Text` objects.
   */
  isTextList(value2) {
    return Array.isArray(value2) && value2.every((val) => Text2.isText(val));
  },
  /**
   * Check if some props are a partial of Text.
   */
  isTextProps(props) {
    return props.text !== void 0;
  },
  /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */
  matches(text3, props) {
    for (var key in props) {
      if (key === "text") {
        continue;
      }
      if (!text3.hasOwnProperty(key) || text3[key] !== props[key]) {
        return false;
      }
    }
    return true;
  },
  /**
   * Get the leaves for a text node given decorations.
   */
  decorations(node2, decorations) {
    var leaves = [_objectSpread$4({}, node2)];
    for (var dec of decorations) {
      var rest = _objectWithoutProperties(dec, _excluded2$1);
      var [start2, end] = Range.edges(dec);
      var next2 = [];
      var leafEnd = 0;
      var decorationStart = start2.offset;
      var decorationEnd = end.offset;
      for (var leaf of leaves) {
        var {
          length: length4
        } = leaf.text;
        var leafStart = leafEnd;
        leafEnd += length4;
        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
          Object.assign(leaf, rest);
          next2.push(leaf);
          continue;
        }
        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
          next2.push(leaf);
          continue;
        }
        var middle = leaf;
        var before = void 0;
        var after = void 0;
        if (decorationEnd < leafEnd) {
          var off = decorationEnd - leafStart;
          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, off)
          });
        }
        if (decorationStart > leafStart) {
          var _off = decorationStart - leafStart;
          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(_off)
          });
        }
        Object.assign(middle, rest);
        if (before) {
          next2.push(before);
        }
        next2.push(middle);
        if (after) {
          next2.push(after);
        }
      }
      leaves = next2;
    }
    return leaves;
  }
};
function ownKeys$3(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$3(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var applyToDraft = (editor, selection, op) => {
  switch (op.type) {
    case "insert_node": {
      var {
        path,
        node: node2
      } = op;
      var parent = Node2.parent(editor, path);
      var index2 = path[path.length - 1];
      if (index2 > parent.children.length) {
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path, "] because the destination is past the end of the node."));
      }
      parent.children.splice(index2, 0, node2);
      if (selection) {
        for (var [point, key] of Range.points(selection)) {
          selection[key] = Point.transform(point, op);
        }
      }
      break;
    }
    case "insert_text": {
      var {
        path: _path,
        offset,
        text: text3
      } = op;
      if (text3.length === 0) break;
      var _node = Node2.leaf(editor, _path);
      var before = _node.text.slice(0, offset);
      var after = _node.text.slice(offset);
      _node.text = before + text3 + after;
      if (selection) {
        for (var [_point, _key] of Range.points(selection)) {
          selection[_key] = Point.transform(_point, op);
        }
      }
      break;
    }
    case "merge_node": {
      var {
        path: _path2
      } = op;
      var _node2 = Node2.get(editor, _path2);
      var prevPath = Path.previous(_path2);
      var prev2 = Node2.get(editor, prevPath);
      var _parent = Node2.parent(editor, _path2);
      var _index = _path2[_path2.length - 1];
      if (Text2.isText(_node2) && Text2.isText(prev2)) {
        prev2.text += _node2.text;
      } else if (!Text2.isText(_node2) && !Text2.isText(prev2)) {
        prev2.children.push(..._node2.children);
      } else {
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev2)));
      }
      _parent.children.splice(_index, 1);
      if (selection) {
        for (var [_point2, _key2] of Range.points(selection)) {
          selection[_key2] = Point.transform(_point2, op);
        }
      }
      break;
    }
    case "move_node": {
      var {
        path: _path3,
        newPath
      } = op;
      if (Path.isAncestor(_path3, newPath)) {
        throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
      }
      var _node3 = Node2.get(editor, _path3);
      var _parent2 = Node2.parent(editor, _path3);
      var _index2 = _path3[_path3.length - 1];
      _parent2.children.splice(_index2, 1);
      var truePath = Path.transform(_path3, op);
      var newParent = Node2.get(editor, Path.parent(truePath));
      var newIndex = truePath[truePath.length - 1];
      newParent.children.splice(newIndex, 0, _node3);
      if (selection) {
        for (var [_point3, _key3] of Range.points(selection)) {
          selection[_key3] = Point.transform(_point3, op);
        }
      }
      break;
    }
    case "remove_node": {
      var {
        path: _path4
      } = op;
      var _index3 = _path4[_path4.length - 1];
      var _parent3 = Node2.parent(editor, _path4);
      _parent3.children.splice(_index3, 1);
      if (selection) {
        for (var [_point4, _key4] of Range.points(selection)) {
          var result = Point.transform(_point4, op);
          if (selection != null && result != null) {
            selection[_key4] = result;
          } else {
            var _prev2 = void 0;
            var next2 = void 0;
            for (var [n5, p4] of Node2.texts(editor)) {
              if (Path.compare(p4, _path4) === -1) {
                _prev2 = [n5, p4];
              } else {
                next2 = [n5, p4];
                break;
              }
            }
            var preferNext = false;
            if (_prev2 && next2) {
              if (Path.equals(next2[1], _path4)) {
                preferNext = !Path.hasPrevious(next2[1]);
              } else {
                preferNext = Path.common(_prev2[1], _path4).length < Path.common(next2[1], _path4).length;
              }
            }
            if (_prev2 && !preferNext) {
              _point4.path = _prev2[1];
              _point4.offset = _prev2[0].text.length;
            } else if (next2) {
              _point4.path = next2[1];
              _point4.offset = 0;
            } else {
              selection = null;
            }
          }
        }
      }
      break;
    }
    case "remove_text": {
      var {
        path: _path5,
        offset: _offset,
        text: _text
      } = op;
      if (_text.length === 0) break;
      var _node4 = Node2.leaf(editor, _path5);
      var _before = _node4.text.slice(0, _offset);
      var _after = _node4.text.slice(_offset + _text.length);
      _node4.text = _before + _after;
      if (selection) {
        for (var [_point5, _key5] of Range.points(selection)) {
          selection[_key5] = Point.transform(_point5, op);
        }
      }
      break;
    }
    case "set_node": {
      var {
        path: _path6,
        properties,
        newProperties
      } = op;
      if (_path6.length === 0) {
        throw new Error("Cannot set properties on the root node!");
      }
      var _node5 = Node2.get(editor, _path6);
      for (var _key6 in newProperties) {
        if (_key6 === "children" || _key6 === "text") {
          throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
        }
        var value2 = newProperties[_key6];
        if (value2 == null) {
          delete _node5[_key6];
        } else {
          _node5[_key6] = value2;
        }
      }
      for (var _key7 in properties) {
        if (!newProperties.hasOwnProperty(_key7)) {
          delete _node5[_key7];
        }
      }
      break;
    }
    case "set_selection": {
      var {
        newProperties: _newProperties
      } = op;
      if (_newProperties == null) {
        selection = _newProperties;
      } else {
        if (selection == null) {
          if (!Range.isRange(_newProperties)) {
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
          }
          selection = _objectSpread$3({}, _newProperties);
        }
        for (var _key8 in _newProperties) {
          var _value = _newProperties[_key8];
          if (_value == null) {
            if (_key8 === "anchor" || _key8 === "focus") {
              throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
            }
            delete selection[_key8];
          } else {
            selection[_key8] = _value;
          }
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: _path7,
        position: position2,
        properties: _properties
      } = op;
      if (_path7.length === 0) {
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
      }
      var _node6 = Node2.get(editor, _path7);
      var _parent4 = Node2.parent(editor, _path7);
      var _index4 = _path7[_path7.length - 1];
      var newNode;
      if (Text2.isText(_node6)) {
        var _before2 = _node6.text.slice(0, position2);
        var _after2 = _node6.text.slice(position2);
        _node6.text = _before2;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          text: _after2
        });
      } else {
        var _before3 = _node6.children.slice(0, position2);
        var _after3 = _node6.children.slice(position2);
        _node6.children = _before3;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          children: _after3
        });
      }
      _parent4.children.splice(_index4 + 1, 0, newNode);
      if (selection) {
        for (var [_point6, _key9] of Range.points(selection)) {
          selection[_key9] = Point.transform(_point6, op);
        }
      }
      break;
    }
  }
  return selection;
};
var GeneralTransforms = {
  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = ln(editor.children);
    var selection = editor.selection && ln(editor.selection);
    try {
      selection = applyToDraft(editor, selection, op);
    } finally {
      editor.children = dn(editor.children);
      if (selection) {
        editor.selection = r2(selection) ? dn(selection) : selection;
      } else {
        editor.selection = null;
      }
    }
  }
};
var _excluded = ["text"];
var _excluded2 = ["children"];
function ownKeys$2(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$2(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var NodeTransforms = {
  /**
   * Insert nodes at a specific location in the Editor.
   */
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at,
        match: match2,
        select
      } = options;
      if (Node2.isNode(nodes)) {
        nodes = [nodes];
      }
      if (nodes.length === 0) {
        return;
      }
      var [node2] = nodes;
      if (!at) {
        if (editor.selection) {
          at = editor.selection;
        } else if (editor.children.length > 0) {
          at = Editor.end(editor, []);
        } else {
          at = [0];
        }
        select = true;
      }
      if (select == null) {
        select = false;
      }
      if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      }
      if (Point.isPoint(at)) {
        if (match2 == null) {
          if (Text2.isText(node2)) {
            match2 = (n5) => Text2.isText(n5);
          } else if (editor.isInline(node2)) {
            match2 = (n5) => Text2.isText(n5) || Editor.isInline(editor, n5);
          } else {
            match2 = (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
          }
        }
        var [entry] = Editor.nodes(editor, {
          at: at.path,
          match: match2,
          mode,
          voids
        });
        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor.pathRef(editor, _matchPath);
          var isAtEnd = Editor.isEnd(editor, at, _matchPath);
          Transforms.splitNodes(editor, {
            at,
            match: match2,
            mode,
            voids
          });
          var path = pathRef.unref();
          at = isAtEnd ? Path.next(path) : path;
        } else {
          return;
        }
      }
      var parentPath = Path.parent(at);
      var index2 = at[at.length - 1];
      if (!voids && Editor.void(editor, {
        at: parentPath
      })) {
        return;
      }
      for (var _node of nodes) {
        var _path = parentPath.concat(index2);
        index2++;
        editor.apply({
          type: "insert_node",
          path: _path,
          node: _node
        });
        at = Path.next(at);
      }
      at = Path.previous(at);
      if (select) {
        var point = Editor.end(editor, at);
        if (point) {
          Transforms.select(editor, point);
        }
      }
    });
  },
  /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        at = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match2
      } = options;
      if (match2 == null) {
        match2 = Path.isPath(at) ? matchPath(editor, at) : (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
      }
      if (!at) {
        return;
      }
      var matches = Editor.nodes(editor, {
        at,
        match: match2,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p4] = _ref;
        return Editor.pathRef(editor, p4);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        if (path.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
        }
        var parentNodeEntry = Editor.node(editor, Path.parent(path));
        var [parent, parentPath] = parentNodeEntry;
        var index2 = path[path.length - 1];
        var {
          length: length4
        } = parent.children;
        if (length4 === 1) {
          var toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: toPath,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index2 === 0) {
          Transforms.moveNodes(editor, {
            at: path,
            to: parentPath,
            voids
          });
        } else if (index2 === length4 - 1) {
          var _toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path);
          var _toPath2 = Path.next(parentPath);
          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },
  /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match: match2,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      if (!at) {
        return;
      }
      if (match2 == null) {
        if (Path.isPath(at)) {
          var [parent] = Editor.parent(editor, at);
          match2 = (n5) => parent.children.includes(n5);
        } else {
          match2 = (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
        }
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
          if (options.at == null) {
            Transforms.select(editor, at);
          }
        }
      }
      var [current] = Editor.nodes(editor, {
        at,
        match: match2,
        voids,
        mode
      });
      var prev2 = Editor.previous(editor, {
        at,
        match: match2,
        voids,
        mode
      });
      if (!current || !prev2) {
        return;
      }
      var [node2, path] = current;
      var [prevNode, prevPath] = prev2;
      if (path.length === 0 || prevPath.length === 0) {
        return;
      }
      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path, prevPath);
      var isPreviousSibling = Path.isSibling(path, prevPath);
      var levels2 = Array.from(Editor.levels(editor, {
        at: path
      }), (_ref2) => {
        var [n5] = _ref2;
        return n5;
      }).slice(commonPath.length).slice(0, -1);
      var emptyAncestor = Editor.above(editor, {
        at: path,
        mode: "highest",
        match: (n5) => levels2.includes(n5) && hasSingleChildNest(editor, n5)
      });
      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position2;
      if (Text2.isText(node2) && Text2.isText(prevNode)) {
        var rest = _objectWithoutProperties(node2, _excluded);
        position2 = prevNode.text.length;
        properties = rest;
      } else if (Element2.isElement(node2) && Element2.isElement(prevNode)) {
        var rest = _objectWithoutProperties(node2, _excluded2);
        position2 = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(Scrubber.stringify(node2), " ").concat(Scrubber.stringify(prevNode)));
      }
      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path,
          to: newPath,
          voids
        });
      }
      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      }
      if (Element2.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text2.isText(prevNode) && prevNode.text === "" && prevPath[prevPath.length - 1] !== 0) {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: "merge_node",
          path: newPath,
          position: position2,
          properties
        });
      }
      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },
  /**
   * Move the nodes at a location to a new location.
   */
  moveNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        to,
        at = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match2
      } = options;
      if (!at) {
        return;
      }
      if (match2 == null) {
        match2 = Path.isPath(at) ? matchPath(editor, at) : (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
      }
      var toRef = Editor.pathRef(editor, to);
      var targets = Editor.nodes(editor, {
        at,
        match: match2,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, (_ref3) => {
        var [, p4] = _ref3;
        return Editor.pathRef(editor, p4);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        var newPath = toRef.current;
        if (path.length !== 0) {
          editor.apply({
            type: "move_node",
            path,
            newPath
          });
        }
        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {
          toRef.current = Path.next(toRef.current);
        }
      }
      toRef.unref();
    });
  },
  /**
   * Remove the nodes at a specific location in the document.
   */
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at = editor.selection,
        match: match2
      } = options;
      if (!at) {
        return;
      }
      if (match2 == null) {
        match2 = Path.isPath(at) ? matchPath(editor, at) : (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      var depths = Editor.nodes(editor, {
        at,
        match: match2,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, (_ref4) => {
        var [, p4] = _ref4;
        return Editor.pathRef(editor, p4);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        if (path) {
          var [node2] = Editor.node(editor, path);
          editor.apply({
            type: "remove_node",
            path,
            node: node2
          });
        }
      }
    });
  },
  /**
   * Set new properties on the nodes at a location.
   */
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match: match2,
        at = editor.selection,
        compare,
        merge: merge4
      } = options;
      var {
        hanging = false,
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      if (!at) {
        return;
      }
      if (match2 == null) {
        match2 = Path.isPath(at) ? matchPath(editor, at) : (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      if (split2 && Range.isRange(at)) {
        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {
          return;
        }
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: "inward"
        });
        var [start2, end] = Range.edges(at);
        var splitMode = mode === "lowest" ? "lowest" : "highest";
        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);
        Transforms.splitNodes(editor, {
          at: end,
          match: match2,
          mode: splitMode,
          voids,
          always: !endAtEndOfNode
        });
        var startAtStartOfNode = Editor.isStart(editor, start2, start2.path);
        Transforms.splitNodes(editor, {
          at: start2,
          match: match2,
          mode: splitMode,
          voids,
          always: !startAtStartOfNode
        });
        at = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }
      if (!compare) {
        compare = (prop, nodeProp) => prop !== nodeProp;
      }
      for (var [node2, path] of Editor.nodes(editor, {
        at,
        match: match2,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {};
        if (path.length === 0) {
          continue;
        }
        var hasChanges = false;
        for (var k2 in props) {
          if (k2 === "children" || k2 === "text") {
            continue;
          }
          if (compare(props[k2], node2[k2])) {
            hasChanges = true;
            if (node2.hasOwnProperty(k2)) properties[k2] = node2[k2];
            if (merge4) {
              if (props[k2] != null) newProperties[k2] = merge4(node2[k2], props[k2]);
            } else {
              if (props[k2] != null) newProperties[k2] = props[k2];
            }
          }
        }
        if (hasChanges) {
          editor.apply({
            type: "set_node",
            path,
            properties,
            newProperties
          });
        }
      }
    });
  },
  /**
   * Split the nodes at a specific location.
   */
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match2,
        at = editor.selection,
        height = 0,
        always = false
      } = options;
      if (match2 == null) {
        match2 = (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
      }
      if (Range.isRange(at)) {
        at = deleteRange(editor, at);
      }
      if (Path.isPath(at)) {
        var path = at;
        var point = Editor.point(editor, path);
        var [parent] = Editor.parent(editor, path);
        match2 = (n5) => n5 === parent;
        height = point.path.length - path.length + 1;
        at = point;
        always = true;
      }
      if (!at) {
        return;
      }
      var beforeRef = Editor.pointRef(editor, at, {
        affinity: "backward"
      });
      var afterRef;
      try {
        var [highest] = Editor.nodes(editor, {
          at,
          match: match2,
          mode,
          voids
        });
        if (!highest) {
          return;
        }
        var voidMatch = Editor.void(editor, {
          at,
          mode: "highest"
        });
        var nudge = 0;
        if (!voids && voidMatch) {
          var [voidNode, voidPath] = voidMatch;
          if (Element2.isElement(voidNode) && editor.isInline(voidNode)) {
            var after = Editor.after(editor, voidPath);
            if (!after) {
              var text3 = {
                text: ""
              };
              var afterPath = Path.next(voidPath);
              Transforms.insertNodes(editor, text3, {
                at: afterPath,
                voids
              });
              after = Editor.point(editor, afterPath);
            }
            at = after;
            always = true;
          }
          var siblingHeight = at.path.length - voidPath.length;
          height = siblingHeight + 1;
          always = true;
        }
        afterRef = Editor.pointRef(editor, at);
        var depth = at.path.length - height;
        var [, highestPath] = highest;
        var lowestPath = at.path.slice(0, depth);
        var position2 = height === 0 ? at.offset : at.path[depth] + nudge;
        for (var [node2, _path2] of Editor.levels(editor, {
          at: lowestPath,
          reverse: true,
          voids
        })) {
          var split2 = false;
          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element2.isElement(node2) && Editor.isVoid(editor, node2)) {
            break;
          }
          var _point = beforeRef.current;
          var isEnd = Editor.isEnd(editor, _point, _path2);
          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {
            split2 = true;
            var properties = Node2.extractProps(node2);
            editor.apply({
              type: "split_node",
              path: _path2,
              position: position2,
              properties
            });
          }
          position2 = _path2[_path2.length - 1] + (split2 || isEnd ? 1 : 0);
        }
        if (options.at == null) {
          var _point2 = afterRef.current || Editor.end(editor, []);
          Transforms.select(editor, _point2);
        }
      } finally {
        var _afterRef;
        beforeRef.unref();
        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();
      }
    });
  },
  /**
   * Unset properties on the nodes at a location.
   */
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!Array.isArray(props)) {
      props = [props];
    }
    var obj = {};
    for (var key of props) {
      obj[key] = null;
    }
    Transforms.setNodes(editor, obj, options);
  },
  /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */
  unwrapNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        at = editor.selection,
        match: match2
      } = options;
      if (!at) {
        return;
      }
      if (match2 == null) {
        match2 = Path.isPath(at) ? matchPath(editor, at) : (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
      }
      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }
      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;
      var matches = Editor.nodes(editor, {
        at,
        match: match2,
        mode,
        voids
      });
      var pathRefs = Array.from(
        matches,
        (_ref5) => {
          var [, p4] = _ref5;
          return Editor.pathRef(editor, p4);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse();
      var _loop = function _loop2(pathRef2) {
        var path = pathRef2.unref();
        var [node2] = Editor.node(editor, path);
        var range = Editor.range(editor, path);
        if (split2 && rangeRef) {
          range = Range.intersection(rangeRef.current, range);
        }
        Transforms.liftNodes(editor, {
          at: range,
          match: (n5) => Element2.isAncestor(node2) && node2.children.includes(n5),
          voids
        });
      };
      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }
      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },
  /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */
  wrapNodes(editor, element2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        match: match2,
        at = editor.selection
      } = options;
      if (!at) {
        return;
      }
      if (match2 == null) {
        if (Path.isPath(at)) {
          match2 = matchPath(editor, at);
        } else if (editor.isInline(element2)) {
          match2 = (n5) => Element2.isElement(n5) && Editor.isInline(editor, n5) || Text2.isText(n5);
        } else {
          match2 = (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5);
        }
      }
      if (split2 && Range.isRange(at)) {
        var [start2, end] = Range.edges(at);
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: "inward"
        });
        Transforms.splitNodes(editor, {
          at: end,
          match: match2,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start2,
          match: match2,
          voids
        });
        at = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }
      var roots = Array.from(Editor.nodes(editor, {
        at,
        match: editor.isInline(element2) ? (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5) : (n5) => Editor.isEditor(n5),
        mode: "lowest",
        voids
      }));
      for (var [, rootPath] of roots) {
        var a3 = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;
        if (!a3) {
          continue;
        }
        var matches = Array.from(Editor.nodes(editor, {
          at: a3,
          match: match2,
          mode,
          voids
        }));
        if (matches.length > 0) {
          var _ret = function() {
            var [first] = matches;
            var last2 = matches[matches.length - 1];
            var [, firstPath] = first;
            var [, lastPath] = last2;
            if (firstPath.length === 0 && lastPath.length === 0) {
              return "continue";
            }
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range = Editor.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));
            var wrapper = _objectSpread$2(_objectSpread$2({}, element2), {}, {
              children: []
            });
            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range,
              match: (n5) => Element2.isAncestor(commonNode) && commonNode.children.includes(n5),
              to: wrapperPath.concat(0),
              voids
            });
          }();
          if (_ret === "continue") continue;
        }
      }
    });
  }
};
var hasSingleChildNest = (editor, node2) => {
  if (Element2.isElement(node2)) {
    var element2 = node2;
    if (Editor.isVoid(editor, node2)) {
      return true;
    } else if (element2.children.length === 1) {
      return hasSingleChildNest(editor, element2.children[0]);
    } else {
      return false;
    }
  } else if (Editor.isEditor(node2)) {
    return false;
  } else {
    return true;
  }
};
var deleteRange = (editor, range) => {
  if (Range.isCollapsed(range)) {
    return range.anchor;
  } else {
    var [, end] = Range.edges(range);
    var pointRef = Editor.pointRef(editor, end);
    Transforms.delete(editor, {
      at: range
    });
    return pointRef.unref();
  }
};
var matchPath = (editor, path) => {
  var [node2] = Editor.node(editor, path);
  return (n5) => n5 === node2;
};
function ownKeys$1(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$1(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var SelectionTransforms = {
  /**
   * Collapse the selection.
   */
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      edge = "anchor"
    } = options;
    var {
      selection
    } = editor;
    if (!selection) {
      return;
    } else if (edge === "anchor") {
      Transforms.select(editor, selection.anchor);
    } else if (edge === "focus") {
      Transforms.select(editor, selection.focus);
    } else if (edge === "start") {
      var [start2] = Range.edges(selection);
      Transforms.select(editor, start2);
    } else if (edge === "end") {
      var [, end] = Range.edges(selection);
      Transforms.select(editor, end);
    }
  },
  /**
   * Unset the selection.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    if (selection) {
      editor.apply({
        type: "set_selection",
        properties: selection,
        newProperties: null
      });
    }
  },
  /**
   * Move the selection's point forward or backward.
   */
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance = 1,
      unit = "character",
      reverse = false
    } = options;
    var {
      edge = null
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus
    } = selection;
    var opts = {
      distance,
      unit
    };
    var props = {};
    if (edge == null || edge === "anchor") {
      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);
      if (point) {
        props.anchor = point;
      }
    }
    if (edge == null || edge === "focus") {
      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);
      if (_point) {
        props.focus = _point;
      }
    }
    Transforms.setSelection(editor, props);
  },
  /**
   * Set the selection to a new value.
   */
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor.range(editor, target);
    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }
    if (!Range.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Scrubber.stringify(target)));
    }
    editor.apply({
      type: "set_selection",
      properties: selection,
      newProperties: target
    });
  },
  /**
   * Set new properties on one of the selection's points.
   */
  setPoint(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      selection
    } = editor;
    var {
      edge = "both"
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus
    } = selection;
    var point = edge === "anchor" ? anchor : focus;
    Transforms.setSelection(editor, {
      [edge === "anchor" ? "anchor" : "focus"]: _objectSpread$1(_objectSpread$1({}, point), props)
    });
  },
  /**
   * Set new properties on the selection.
   */
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};
    if (!selection) {
      return;
    }
    for (var k2 in props) {
      if (k2 === "anchor" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k2 === "focus" && props.focus != null && !Point.equals(props.focus, selection.focus) || k2 !== "anchor" && k2 !== "focus" && props[k2] !== selection[k2]) {
        oldProps[k2] = selection[k2];
        newProps[k2] = props[k2];
      }
    }
    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: "set_selection",
        properties: oldProps,
        newProperties: newProps
      });
    }
  }
};
var TextTransforms = {
  /**
   * Delete content in the editor.
   */
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        reverse = false,
        unit = "character",
        distance = 1,
        voids = false
      } = options;
      var {
        at = editor.selection,
        hanging = false
      } = options;
      if (!at) {
        return;
      }
      var isCollapsed = false;
      if (Range.isRange(at) && Range.isCollapsed(at)) {
        isCollapsed = true;
        at = at.anchor;
      }
      if (Point.isPoint(at)) {
        var furthestVoid = Editor.void(editor, {
          at,
          mode: "highest"
        });
        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at = voidPath;
        } else {
          var opts = {
            unit,
            distance
          };
          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
          at = {
            anchor: at,
            focus: target
          };
          hanging = true;
        }
      }
      if (Path.isPath(at)) {
        Transforms.removeNodes(editor, {
          at,
          voids
        });
        return;
      }
      if (Range.isCollapsed(at)) {
        return;
      }
      if (!hanging) {
        var [, _end] = Range.edges(at);
        var endOfDoc = Editor.end(editor, []);
        if (!Point.equals(_end, endOfDoc)) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
      }
      var [start2, end] = Range.edges(at);
      var startBlock = Editor.above(editor, {
        match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5),
        at: start2,
        voids
      });
      var endBlock = Editor.above(editor, {
        match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5),
        at: end,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start2.path, end.path);
      var startVoid = voids ? null : Editor.void(editor, {
        at: start2,
        mode: "highest"
      });
      var endVoid = voids ? null : Editor.void(editor, {
        at: end,
        mode: "highest"
      });
      if (startVoid) {
        var before = Editor.before(editor, start2);
        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
          start2 = before;
        }
      }
      if (endVoid) {
        var after = Editor.after(editor, end);
        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
          end = after;
        }
      }
      var matches = [];
      var lastPath;
      for (var entry of Editor.nodes(editor, {
        at,
        voids
      })) {
        var [node2, path] = entry;
        if (lastPath && Path.compare(path, lastPath) === 0) {
          continue;
        }
        if (!voids && Element2.isElement(node2) && Editor.isVoid(editor, node2) || !Path.isCommon(path, start2.path) && !Path.isCommon(path, end.path)) {
          matches.push(entry);
          lastPath = path;
        }
      }
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p4] = _ref;
        return Editor.pathRef(editor, p4);
      });
      var startRef = Editor.pointRef(editor, start2);
      var endRef = Editor.pointRef(editor, end);
      var removedText = "";
      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset
        } = start2;
        var text3 = _node.text.slice(offset);
        if (text3.length > 0) {
          editor.apply({
            type: "remove_text",
            path: _path,
            offset,
            text: text3
          });
          removedText = text3;
        }
      }
      pathRefs.reverse().map((r6) => r6.unref()).filter((r6) => r6 !== null).forEach((p4) => Transforms.removeNodes(editor, {
        at: p4,
        voids
      }));
      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor.leaf(editor, _point2);
        var {
          path: _path2
        } = _point2;
        var _offset = isSingleText ? start2.offset : 0;
        var _text = _node2.text.slice(_offset, end.offset);
        if (_text.length > 0) {
          editor.apply({
            type: "remove_text",
            path: _path2,
            offset: _offset,
            text: _text
          });
          removedText = _text;
        }
      }
      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }
      if (isCollapsed && reverse && unit === "character" && removedText.length > 1 && removedText.match(/[\u0E00-\u0E7F]+/)) {
        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));
      }
      var startUnref = startRef.unref();
      var endUnref = endRef.unref();
      var point = reverse ? startUnref || endUnref : endUnref || startUnref;
      if (options.at == null && point) {
        Transforms.select(editor, point);
      }
    });
  },
  /**
   * Insert a fragment at a specific location in the editor.
   */
  insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;
      if (!fragment.length) {
        return;
      }
      if (!at) {
        return;
      } else if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      } else if (Path.isPath(at)) {
        at = Editor.start(editor, at);
      }
      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }
      var inlineElementMatch = Editor.above(editor, {
        at,
        match: (n5) => Element2.isElement(n5) && Editor.isInline(editor, n5),
        mode: "highest",
        voids
      });
      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;
        if (Editor.isEnd(editor, at, _inlinePath)) {
          var after = Editor.after(editor, _inlinePath);
          at = after;
        } else if (Editor.isStart(editor, at, _inlinePath)) {
          var before = Editor.before(editor, _inlinePath);
          at = before;
        }
      }
      var blockMatch = Editor.above(editor, {
        match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5),
        at,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor.isStart(editor, at, blockPath);
      var isBlockEnd = Editor.isEnd(editor, at, blockPath);
      var isBlockEmpty = isBlockStart && isBlockEnd;
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node2.first({
        children: fragment
      }, []);
      var [, lastPath] = Node2.last({
        children: fragment
      }, []);
      var matches = [];
      var matcher = (_ref2) => {
        var [n5, p4] = _ref2;
        var isRoot = p4.length === 0;
        if (isRoot) {
          return false;
        }
        if (isBlockEmpty) {
          return true;
        }
        if (mergeStart && Path.isAncestor(p4, firstPath) && Element2.isElement(n5) && !editor.isVoid(n5) && !editor.isInline(n5)) {
          return false;
        }
        if (mergeEnd && Path.isAncestor(p4, lastPath) && Element2.isElement(n5) && !editor.isVoid(n5) && !editor.isInline(n5)) {
          return false;
        }
        return true;
      };
      for (var entry of Node2.nodes({
        children: fragment
      }, {
        pass: matcher
      })) {
        if (matcher(entry)) {
          matches.push(entry);
        }
      }
      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;
      for (var [node2] of matches) {
        if (Element2.isElement(node2) && !editor.isInline(node2)) {
          starting = false;
          hasBlocks = true;
          middles.push(node2);
        } else if (starting) {
          starts.push(node2);
        } else {
          ends.push(node2);
        }
      }
      var [inlineMatch] = Editor.nodes(editor, {
        at,
        match: (n5) => Text2.isText(n5) || Editor.isInline(editor, n5),
        mode: "highest",
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor.isStart(editor, at, inlinePath);
      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);
      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.splitNodes(editor, {
        at,
        match: (n5) => hasBlocks ? Element2.isElement(n5) && Editor.isBlock(editor, n5) : Text2.isText(n5) || Editor.isInline(editor, n5),
        mode: hasBlocks ? "lowest" : "highest",
        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),
        voids
      });
      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: (n5) => Text2.isText(n5) || Editor.isInline(editor, n5),
        mode: "highest",
        voids
      });
      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {
        Transforms.delete(editor, {
          at: blockPath,
          voids
        });
      }
      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5),
        mode: "lowest",
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: (n5) => Text2.isText(n5) || Editor.isInline(editor, n5),
        mode: "highest",
        voids
      });
      if (!options.at) {
        var path;
        if (ends.length > 0 && endRef.current) {
          path = Path.previous(endRef.current);
        } else if (middles.length > 0 && middleRef.current) {
          path = Path.previous(middleRef.current);
        } else if (startRef.current) {
          path = Path.previous(startRef.current);
        }
        if (path) {
          var _end2 = Editor.end(editor, path);
          Transforms.select(editor, _end2);
        }
      }
      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },
  /**
   * Insert a string of text in the Editor.
   */
  insertText(editor, text3) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;
      if (!at) {
        return;
      }
      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }
      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var end = Range.end(at);
          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }
          var start2 = Range.start(at);
          var startRef = Editor.pointRef(editor, start2);
          var endRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at,
            voids
          });
          var startPoint = startRef.unref();
          var endPoint = endRef.unref();
          at = startPoint || endPoint;
          Transforms.setSelection(editor, {
            anchor: at,
            focus: at
          });
        }
      }
      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }
      var {
        path,
        offset
      } = at;
      if (text3.length > 0) editor.apply({
        type: "insert_text",
        path,
        offset,
        text: text3
      });
    });
  }
};
function ownKeys(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);

// node_modules/slate-react/dist/index.es.js
var import_direction = __toESM(require_direction());
var import_debounce = __toESM(require_debounce());
var import_throttle = __toESM(require_throttle());
var import_react94 = __toESM(require_react());

// node_modules/slate-react/node_modules/compute-scroll-into-view/dist/index.mjs
function t2(t4) {
  return "object" == typeof t4 && null != t4 && 1 === t4.nodeType;
}
function e(t4, e4) {
  return (!e4 || "hidden" !== t4) && "visible" !== t4 && "clip" !== t4;
}
function n2(t4, n5) {
  if (t4.clientHeight < t4.scrollHeight || t4.clientWidth < t4.scrollWidth) {
    var r6 = getComputedStyle(t4, null);
    return e(r6.overflowY, n5) || e(r6.overflowX, n5) || function(t5) {
      var e4 = function(t6) {
        if (!t6.ownerDocument || !t6.ownerDocument.defaultView) return null;
        try {
          return t6.ownerDocument.defaultView.frameElement;
        } catch (t7) {
          return null;
        }
      }(t5);
      return !!e4 && (e4.clientHeight < t5.scrollHeight || e4.clientWidth < t5.scrollWidth);
    }(t4);
  }
  return false;
}
function r3(t4, e4, n5, r6, i4, o3, l6, d5) {
  return o3 < t4 && l6 > e4 || o3 > t4 && l6 < e4 ? 0 : o3 <= t4 && d5 <= n5 || l6 >= e4 && d5 >= n5 ? o3 - t4 - r6 : l6 > e4 && d5 < n5 || o3 < t4 && d5 > n5 ? l6 - e4 + i4 : 0;
}
var i2 = function(e4, i4) {
  var o3 = window, l6 = i4.scrollMode, d5 = i4.block, f6 = i4.inline, h3 = i4.boundary, u4 = i4.skipOverflowHiddenElements, s4 = "function" == typeof h3 ? h3 : function(t4) {
    return t4 !== h3;
  };
  if (!t2(e4)) throw new TypeError("Invalid target");
  for (var a3, c6, g4 = document.scrollingElement || document.documentElement, p4 = [], m3 = e4; t2(m3) && s4(m3); ) {
    if ((m3 = null == (c6 = (a3 = m3).parentElement) ? a3.getRootNode().host || null : c6) === g4) {
      p4.push(m3);
      break;
    }
    null != m3 && m3 === document.body && n2(m3) && !n2(document.documentElement) || null != m3 && n2(m3, u4) && p4.push(m3);
  }
  for (var w2 = o3.visualViewport ? o3.visualViewport.width : innerWidth, v6 = o3.visualViewport ? o3.visualViewport.height : innerHeight, W3 = window.scrollX || pageXOffset, H2 = window.scrollY || pageYOffset, b2 = e4.getBoundingClientRect(), y3 = b2.height, E3 = b2.width, M2 = b2.top, V = b2.right, x3 = b2.bottom, I3 = b2.left, C3 = "start" === d5 || "nearest" === d5 ? M2 : "end" === d5 ? x3 : M2 + y3 / 2, R2 = "center" === f6 ? I3 + E3 / 2 : "end" === f6 ? V : I3, T2 = [], k2 = 0; k2 < p4.length; k2++) {
    var B3 = p4[k2], D2 = B3.getBoundingClientRect(), O2 = D2.height, X2 = D2.width, Y2 = D2.top, L2 = D2.right, S2 = D2.bottom, j3 = D2.left;
    if ("if-needed" === l6 && M2 >= 0 && I3 >= 0 && x3 <= v6 && V <= w2 && M2 >= Y2 && x3 <= S2 && I3 >= j3 && V <= L2) return T2;
    var N2 = getComputedStyle(B3), q2 = parseInt(N2.borderLeftWidth, 10), z2 = parseInt(N2.borderTopWidth, 10), A3 = parseInt(N2.borderRightWidth, 10), F = parseInt(N2.borderBottomWidth, 10), G2 = 0, J = 0, K = "offsetWidth" in B3 ? B3.offsetWidth - B3.clientWidth - q2 - A3 : 0, P2 = "offsetHeight" in B3 ? B3.offsetHeight - B3.clientHeight - z2 - F : 0, Q3 = "offsetWidth" in B3 ? 0 === B3.offsetWidth ? 0 : X2 / B3.offsetWidth : 0, U2 = "offsetHeight" in B3 ? 0 === B3.offsetHeight ? 0 : O2 / B3.offsetHeight : 0;
    if (g4 === B3) G2 = "start" === d5 ? C3 : "end" === d5 ? C3 - v6 : "nearest" === d5 ? r3(H2, H2 + v6, v6, z2, F, H2 + C3, H2 + C3 + y3, y3) : C3 - v6 / 2, J = "start" === f6 ? R2 : "center" === f6 ? R2 - w2 / 2 : "end" === f6 ? R2 - w2 : r3(W3, W3 + w2, w2, q2, A3, W3 + R2, W3 + R2 + E3, E3), G2 = Math.max(0, G2 + H2), J = Math.max(0, J + W3);
    else {
      G2 = "start" === d5 ? C3 - Y2 - z2 : "end" === d5 ? C3 - S2 + F + P2 : "nearest" === d5 ? r3(Y2, S2, O2, z2, F + P2, C3, C3 + y3, y3) : C3 - (Y2 + O2 / 2) + P2 / 2, J = "start" === f6 ? R2 - j3 - q2 : "center" === f6 ? R2 - (j3 + X2 / 2) + K / 2 : "end" === f6 ? R2 - L2 + A3 + K : r3(j3, L2, X2, q2, A3 + K, R2, R2 + E3, E3);
      var Z2 = B3.scrollLeft, $ = B3.scrollTop;
      C3 += $ - (G2 = Math.max(0, Math.min($ + G2 / U2, B3.scrollHeight - O2 / U2 + P2))), R2 += Z2 - (J = Math.max(0, Math.min(Z2 + J / Q3, B3.scrollWidth - X2 / Q3 + K)));
    }
    T2.push({ el: B3, top: G2, left: J });
  }
  return T2;
};

// node_modules/slate-react/node_modules/scroll-into-view-if-needed/es/index.js
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top,
        left,
        behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target, options) {
  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? i2(target, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(i2(target, computeOptions), computeOptions.behavior);
}
var es_default = scrollIntoView;

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function(obj) {
  return Object.freeze(obj);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x3, y3, width, height) {
    this.x = x3;
    this.y = y3;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a5 = this, x3 = _a5.x, y3 = _a5.y, top = _a5.top, right = _a5.right, bottom = _a5.bottom, left = _a5.left, width = _a5.width, height = _a5.height;
    return { x: x3, y: y3, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a5 = target.getBBox(), width = _a5.width, height = _a5.height;
    return !width && !height;
  }
  var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement2 = function(obj) {
  var _a5;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a5 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a5 === void 0 ? void 0 : _a5.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global2 = typeof window !== "undefined" ? window : {};

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache2 = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size2 = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size2(),
  borderBoxSize: size2(),
  contentBoxSize: size2(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache2.has(target) && !forceRecalculation) {
    return cache2.get(target);
  }
  if (isHidden(target)) {
    cache2.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size2(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size2(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size2(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache2.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a5 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a5.borderBoxSize, contentBoxSize = _a5.contentBoxSize, devicePixelContentBoxSize = _a5.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node2) {
  if (isHidden(node2)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node2.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries2 = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries2.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries2, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process2 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb);
  });
};

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout2) {
  if (timeout2 === void 0) {
    timeout2 = 0;
  }
  return Date.now() + timeout2;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout2) {
    var _this = this;
    if (timeout2 === void 0) {
      timeout2 = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout2);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process2();
      } finally {
        scheduled = false;
        timeout2 = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout2 > 0) {
          _this.run(timeout2);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global2.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global2.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global2.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n5) {
  !watching && n5 > 0 && scheduler.start();
  watching += n5;
  !watching && scheduler.stop();
};

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size3 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size3;
    }
    if (this.lastReportedSize.inlineSize !== size3.inlineSize || this.lastReportedSize.blockSize !== size3.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i4 = 0; i4 < observationTargets.length; i4 += 1) {
    if (observationTargets[i4].target === target) {
      return i4;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index2 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index2 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index2, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement2(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement2(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
}();

// node_modules/slate-react/dist/index.es.js
var import_is_hotkey = __toESM(require_lib());
var import_react_dom4 = __toESM(require_react_dom());
function _defineProperty2(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i4;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
      key = sourceSymbolKeys[i4];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var n3 = 0;
var Key = class {
  constructor() {
    this.id = "".concat(n3++);
  }
};
var NODE_TO_INDEX = /* @__PURE__ */ new WeakMap();
var NODE_TO_PARENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_WINDOW = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PLACEHOLDER_ELEMENT = /* @__PURE__ */ new WeakMap();
var ELEMENT_TO_NODE = /* @__PURE__ */ new WeakMap();
var NODE_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var NODE_TO_KEY = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_KEY_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var IS_READ_ONLY = /* @__PURE__ */ new WeakMap();
var IS_FOCUSED = /* @__PURE__ */ new WeakMap();
var IS_COMPOSING = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ON_CHANGE = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_SCHEDULE_FLUSH = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_INSERTION_MARKS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_MARKS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_DIFFS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_ACTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_FORCE_RENDER = /* @__PURE__ */ new WeakMap();
var PLACEHOLDER_SYMBOL = Symbol("placeholder");
var MARK_PLACEHOLDER_SYMBOL = Symbol("mark-placeholder");
var DOMText = globalThis.Text;
var getDefaultView = (value2) => {
  return value2 && value2.ownerDocument && value2.ownerDocument.defaultView || null;
};
var isDOMComment = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 8;
};
var isDOMElement = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 1;
};
var isDOMNode = (value2) => {
  var window2 = getDefaultView(value2);
  return !!window2 && value2 instanceof window2.Node;
};
var isDOMSelection = (value2) => {
  var window2 = value2 && value2.anchorNode && getDefaultView(value2.anchorNode);
  return !!window2 && value2 instanceof window2.Selection;
};
var isDOMText = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 3;
};
var isPlainTextOnlyPaste = (event) => {
  return event.clipboardData && event.clipboardData.getData("text/plain") !== "" && event.clipboardData.types.length === 1;
};
var normalizeDOMPoint = (domPoint) => {
  var [node2, offset] = domPoint;
  if (isDOMElement(node2) && node2.childNodes.length) {
    var isLast = offset === node2.childNodes.length;
    var index2 = isLast ? offset - 1 : offset;
    [node2, index2] = getEditableChildAndIndex(node2, index2, isLast ? "backward" : "forward");
    isLast = index2 < offset;
    while (isDOMElement(node2) && node2.childNodes.length) {
      var i4 = isLast ? node2.childNodes.length - 1 : 0;
      node2 = getEditableChild(node2, i4, isLast ? "backward" : "forward");
    }
    offset = isLast && node2.textContent != null ? node2.textContent.length : 0;
  }
  return [node2, offset];
};
var hasShadowRoot = (node2) => {
  var parent = node2 && node2.parentNode;
  while (parent) {
    if (parent.toString() === "[object ShadowRoot]") {
      return true;
    }
    parent = parent.parentNode;
  }
  return false;
};
var getEditableChildAndIndex = (parent, index2, direction) => {
  var {
    childNodes
  } = parent;
  var child = childNodes[index2];
  var i4 = index2;
  var triedForward = false;
  var triedBackward = false;
  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute("contenteditable") === "false") {
    if (triedForward && triedBackward) {
      break;
    }
    if (i4 >= childNodes.length) {
      triedForward = true;
      i4 = index2 - 1;
      direction = "backward";
      continue;
    }
    if (i4 < 0) {
      triedBackward = true;
      i4 = index2 + 1;
      direction = "forward";
      continue;
    }
    child = childNodes[i4];
    index2 = i4;
    i4 += direction === "forward" ? 1 : -1;
  }
  return [child, index2];
};
var getEditableChild = (parent, index2, direction) => {
  var [child] = getEditableChildAndIndex(parent, index2, direction);
  return child;
};
var getPlainText = (domNode) => {
  var text3 = "";
  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }
  if (isDOMElement(domNode)) {
    for (var childNode of Array.from(domNode.childNodes)) {
      text3 += getPlainText(childNode);
    }
    var display = getComputedStyle(domNode).getPropertyValue("display");
    if (display === "block" || display === "list" || domNode.tagName === "BR") {
      text3 += "\n";
    }
  }
  return text3;
};
var catchSlateFragment = /data-slate-fragment="(.+?)"/m;
var getSlateFragmentAttribute = (dataTransfer) => {
  var htmlData = dataTransfer.getData("text/html");
  var [, fragment] = htmlData.match(catchSlateFragment) || [];
  return fragment;
};
var isTrackedMutation = (editor, mutation, batch) => {
  var {
    target
  } = mutation;
  if (isDOMElement(target) && target.matches('[contentEditable="false"]')) {
    return false;
  }
  var {
    document: document2
  } = ReactEditor.getWindow(editor);
  if (document2.contains(target)) {
    return ReactEditor.hasDOMNode(editor, target, {
      editable: true
    });
  }
  var parentMutation = batch.find((_ref) => {
    var {
      addedNodes,
      removedNodes
    } = _ref;
    for (var node2 of addedNodes) {
      if (node2 === target || node2.contains(target)) {
        return true;
      }
    }
    for (var _node of removedNodes) {
      if (_node === target || _node.contains(target)) {
        return true;
      }
    }
  });
  if (!parentMutation || parentMutation === mutation) {
    return false;
  }
  return isTrackedMutation(editor, parentMutation, batch);
};
var IS_REACT_VERSION_17_OR_ABOVE = parseInt(import_react94.default.version.split(".")[0], 10) >= 17;
var IS_IOS = typeof navigator !== "undefined" && typeof window !== "undefined" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== "undefined" && /Mac OS X/.test(navigator.userAgent);
var IS_ANDROID = typeof navigator !== "undefined" && /Android/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_SAFARI = typeof navigator !== "undefined" && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
var IS_EDGE_LEGACY = typeof navigator !== "undefined" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent);
var IS_CHROME = typeof navigator !== "undefined" && /Chrome/i.test(navigator.userAgent);
var IS_CHROME_LEGACY = typeof navigator !== "undefined" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent);
var IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== "undefined" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent);
var IS_FIREFOX_LEGACY = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);
var IS_UC_MOBILE = typeof navigator !== "undefined" && /.*UCBrowser/.test(navigator.userAgent);
var IS_WECHATBROWSER = typeof navigator !== "undefined" && /.*Wechat/.test(navigator.userAgent);
var CAN_USE_DOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers
typeof globalThis !== "undefined" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges === "function";
var ReactEditor = {
  /**
   * Check if the user is currently composing inside the editor.
   */
  isComposing(editor) {
    return !!IS_COMPOSING.get(editor);
  },
  /**
   * Return the host window of the current editor.
   */
  getWindow(editor) {
    var window2 = EDITOR_TO_WINDOW.get(editor);
    if (!window2) {
      throw new Error("Unable to find a host window element for this editor");
    }
    return window2;
  },
  /**
   * Find a key for a Slate node.
   */
  findKey(editor, node2) {
    var key = NODE_TO_KEY.get(node2);
    if (!key) {
      key = new Key();
      NODE_TO_KEY.set(node2, key);
    }
    return key;
  },
  /**
   * Find the path of Slate node.
   */
  findPath(editor, node2) {
    var path = [];
    var child = node2;
    while (true) {
      var parent = NODE_TO_PARENT.get(child);
      if (parent == null) {
        if (Editor.isEditor(child)) {
          return path;
        } else {
          break;
        }
      }
      var i4 = NODE_TO_INDEX.get(child);
      if (i4 == null) {
        break;
      }
      path.unshift(i4);
      child = parent;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Scrubber.stringify(node2)));
  },
  /**
   * Find the DOM node that implements DocumentOrShadowRoot for the editor.
   */
  findDocumentOrShadowRoot(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = el.getRootNode();
    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {
      return root;
    }
    return el.ownerDocument;
  },
  /**
   * Check if the editor is focused.
   */
  isFocused(editor) {
    return !!IS_FOCUSED.get(editor);
  },
  /**
   * Check if the editor is in read-only mode.
   */
  isReadOnly(editor) {
    return !!IS_READ_ONLY.get(editor);
  },
  /**
   * Blur the editor.
   */
  blur(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, false);
    if (root.activeElement === el) {
      el.blur();
    }
  },
  /**
   * Focus the editor.
   */
  focus(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, true);
    if (root.activeElement !== el) {
      el.focus({
        preventScroll: true
      });
    }
  },
  /**
   * Deselect the editor.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root.getSelection();
    if (domSelection && domSelection.rangeCount > 0) {
      domSelection.removeAllRanges();
    }
    if (selection) {
      Transforms.deselect(editor);
    }
  },
  /**
   * Check if a DOM node is within the editor.
   */
  hasDOMNode(editor, target) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      editable = false
    } = options;
    var editorEl = ReactEditor.toDOMNode(editor, editor);
    var targetEl;
    try {
      targetEl = isDOMElement(target) ? target : target.parentElement;
    } catch (err) {
      if (!err.message.includes('Permission denied to access property "nodeType"')) {
        throw err;
      }
    }
    if (!targetEl) {
      return false;
    }
    return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    targetEl.closest('[contenteditable="false"]') === editorEl || !!targetEl.getAttribute("data-slate-zero-width"));
  },
  /**
   * Insert data from a `DataTransfer` into the editor.
   */
  insertData(editor, data) {
    editor.insertData(data);
  },
  /**
   * Insert fragment data from a `DataTransfer` into the editor.
   */
  insertFragmentData(editor, data) {
    return editor.insertFragmentData(data);
  },
  /**
   * Insert text data from a `DataTransfer` into the editor.
   */
  insertTextData(editor, data) {
    return editor.insertTextData(data);
  },
  /**
   * Sets data from the currently selected fragment on a `DataTransfer`.
   */
  setFragmentData(editor, data, originEvent) {
    editor.setFragmentData(data, originEvent);
  },
  /**
   * Find the native DOM element from a Slate node.
   */
  toDOMNode(editor, node2) {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    var domNode = Editor.isEditor(node2) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node2));
    if (!domNode) {
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Scrubber.stringify(node2)));
    }
    return domNode;
  },
  /**
   * Find a native DOM selection point from a Slate point.
   */
  toDOMPoint(editor, point) {
    var [node2] = Editor.node(editor, point.path);
    var el = ReactEditor.toDOMNode(editor, node2);
    var domPoint;
    if (Editor.void(editor, {
      at: point
    })) {
      point = {
        path: point.path,
        offset: 0
      };
    }
    var selector = "[data-slate-string], [data-slate-zero-width]";
    var texts = Array.from(el.querySelectorAll(selector));
    var start2 = 0;
    for (var i4 = 0; i4 < texts.length; i4++) {
      var text3 = texts[i4];
      var domNode = text3.childNodes[0];
      if (domNode == null || domNode.textContent == null) {
        continue;
      }
      var {
        length: length4
      } = domNode.textContent;
      var attr = text3.getAttribute("data-slate-length");
      var trueLength = attr == null ? length4 : parseInt(attr, 10);
      var end = start2 + trueLength;
      var nextText = texts[i4 + 1];
      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute("data-slate-mark-placeholder")) {
        var _nextText$textContent;
        var domText = nextText.childNodes[0];
        domPoint = [
          // COMPAT: If we don't explicity set the dom point to be on the actual
          // dom text element, chrome will put the selection behind the actual dom
          // text element, causing domRange.getBoundingClientRect() calls on a collapsed
          // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
          // which will cause issues when scrolling to it.
          domText instanceof DOMText ? domText : nextText,
          (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith("\uFEFF") ? 1 : 0
        ];
        break;
      }
      if (point.offset <= end) {
        var offset = Math.min(length4, Math.max(0, point.offset - start2));
        domPoint = [domNode, offset];
        break;
      }
      start2 = end;
    }
    if (!domPoint) {
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Scrubber.stringify(point)));
    }
    return domPoint;
  },
  /**
   * Find a native DOM range from a Slate `range`.
   *
   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.
   *
   * there is no way to create a reverse DOM Range using Range.setStart/setEnd
   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.
   */
  toDOMRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    var isBackward = Range.isBackward(range);
    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);
    var window2 = ReactEditor.getWindow(editor);
    var domRange = window2.document.createRange();
    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;
    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
    var isStartAtZeroWidth = !!startEl.getAttribute("data-slate-zero-width");
    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
    var isEndAtZeroWidth = !!endEl.getAttribute("data-slate-zero-width");
    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
    return domRange;
  },
  /**
   * Find a Slate node from a native DOM `element`.
   */
  toSlateNode(editor, domNode) {
    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;
    if (domEl && !domEl.hasAttribute("data-slate-node")) {
      domEl = domEl.closest("[data-slate-node]");
    }
    var node2 = domEl ? ELEMENT_TO_NODE.get(domEl) : null;
    if (!node2) {
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
    }
    return node2;
  },
  /**
   * Get the target range from a DOM `event`.
   */
  findEventRange(editor, event) {
    if ("nativeEvent" in event) {
      event = event.nativeEvent;
    }
    var {
      clientX: x3,
      clientY: y3,
      target
    } = event;
    if (x3 == null || y3 == null) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var node2 = ReactEditor.toSlateNode(editor, event.target);
    var path = ReactEditor.findPath(editor, node2);
    if (Element2.isElement(node2) && Editor.isVoid(editor, node2)) {
      var rect = target.getBoundingClientRect();
      var isPrev = editor.isInline(node2) ? x3 - rect.left < rect.left + rect.width - x3 : y3 - rect.top < rect.top + rect.height - y3;
      var edge = Editor.point(editor, path, {
        edge: isPrev ? "start" : "end"
      });
      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);
      if (point) {
        var _range = Editor.range(editor, point);
        return _range;
      }
    }
    var domRange;
    var {
      document: document2
    } = ReactEditor.getWindow(editor);
    if (document2.caretRangeFromPoint) {
      domRange = document2.caretRangeFromPoint(x3, y3);
    } else {
      var position2 = document2.caretPositionFromPoint(x3, y3);
      if (position2) {
        domRange = document2.createRange();
        domRange.setStart(position2.offsetNode, position2.offset);
        domRange.setEnd(position2.offsetNode, position2.offset);
      }
    }
    if (!domRange) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var range = ReactEditor.toSlateRange(editor, domRange, {
      exactMatch: false,
      suppressThrow: false
    });
    return range;
  },
  /**
   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.
   */
  toSlatePoint(editor, domPoint, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);
    var parentNode = nearestNode.parentNode;
    var textNode = null;
    var offset = 0;
    if (parentNode) {
      var _domNode$textContent, _domNode$textContent2;
      var editorEl = ReactEditor.toDOMNode(editor, editor);
      var potentialVoidNode = parentNode.closest('[data-slate-void="true"]');
      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;
      var leafNode = parentNode.closest("[data-slate-leaf]");
      var domNode = null;
      if (leafNode) {
        textNode = leafNode.closest('[data-slate-node="text"]');
        if (textNode) {
          var window2 = ReactEditor.getWindow(editor);
          var range = window2.document.createRange();
          range.setStart(textNode, 0);
          range.setEnd(nearestNode, nearestOffset);
          var contents = range.cloneContents();
          var removals = [...Array.prototype.slice.call(contents.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(contents.querySelectorAll("[contenteditable=false]"))];
          removals.forEach((el) => {
            if (IS_ANDROID && !exactMatch && el.hasAttribute("data-slate-zero-width") && el.textContent.length > 0 && el.textContext !== "\uFEFF") {
              if (el.textContent.startsWith("\uFEFF")) {
                el.textContent = el.textContent.slice(1);
              }
              return;
            }
            el.parentNode.removeChild(el);
          });
          offset = contents.textContent.length;
          domNode = textNode;
        }
      } else if (voidNode) {
        var leafNodes = voidNode.querySelectorAll("[data-slate-leaf]");
        for (var index2 = 0; index2 < leafNodes.length; index2++) {
          var current = leafNodes[index2];
          if (ReactEditor.hasDOMNode(editor, current)) {
            leafNode = current;
            break;
          }
        }
        if (!leafNode) {
          offset = 1;
        } else {
          textNode = leafNode.closest('[data-slate-node="text"]');
          domNode = leafNode;
          offset = domNode.textContent.length;
          domNode.querySelectorAll("[data-slate-zero-width]").forEach((el) => {
            offset -= el.textContent.length;
          });
        }
      }
      if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      IS_ANDROID && domNode.getAttribute("data-slate-zero-width") === "z" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith("\uFEFF") && (parentNode.hasAttribute("data-slate-zero-width") || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith("\n\n"))) {
        offset--;
      }
    }
    if (IS_ANDROID && !textNode && !exactMatch) {
      var node2 = parentNode.hasAttribute("data-slate-node") ? parentNode : parentNode.closest("[data-slate-node]");
      if (node2 && ReactEditor.hasDOMNode(editor, node2, {
        editable: true
      })) {
        var _slateNode = ReactEditor.toSlateNode(editor, node2);
        var {
          path: _path,
          offset: _offset
        } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));
        if (!node2.querySelector("[data-slate-leaf]")) {
          _offset = nearestOffset;
        }
        return {
          path: _path,
          offset: _offset
        };
      }
    }
    if (!textNode) {
      if (suppressThrow) {
        return null;
      }
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
    }
    var slateNode = ReactEditor.toSlateNode(editor, textNode);
    var path = ReactEditor.findPath(editor, slateNode);
    return {
      path,
      offset
    };
  },
  /**
   * Find a Slate range from a DOM range or selection.
   */
  toSlateRange(editor, domRange, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;
    var anchorNode;
    var anchorOffset;
    var focusNode;
    var focusOffset;
    var isCollapsed;
    if (el) {
      if (isDOMSelection(domRange)) {
        anchorNode = domRange.anchorNode;
        anchorOffset = domRange.anchorOffset;
        focusNode = domRange.focusNode;
        focusOffset = domRange.focusOffset;
        if (IS_CHROME && hasShadowRoot(anchorNode)) {
          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;
        } else {
          isCollapsed = domRange.isCollapsed;
        }
      } else {
        anchorNode = domRange.startContainer;
        anchorOffset = domRange.startOffset;
        focusNode = domRange.endContainer;
        focusOffset = domRange.endOffset;
        isCollapsed = domRange.collapsed;
      }
    }
    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
    }
    if ("getAttribute" in focusNode && focusNode.getAttribute("contenteditable") === "false") {
      var _anchorNode$textConte;
      focusNode = anchorNode;
      focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;
    }
    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {
      exactMatch,
      suppressThrow
    });
    if (!anchor) {
      return null;
    }
    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {
      exactMatch,
      suppressThrow
    });
    if (!focus) {
      return null;
    }
    if (IS_FIREFOX && !isCollapsed && anchorNode !== focusNode) {
      var isEnd = Editor.isEnd(editor, anchor, anchor.path);
      var isStart = Editor.isStart(editor, focus, focus.path);
      if (isEnd) {
        var after = Editor.after(editor, anchor);
        anchor = after || anchor;
      }
      if (isStart) {
        var before = Editor.before(editor, focus);
        focus = before || focus;
      }
    }
    var range = {
      anchor,
      focus
    };
    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {
      at: range.focus,
      mode: "highest"
    })) {
      range = Editor.unhangRange(editor, range, {
        voids: true
      });
    }
    return range;
  },
  hasRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);
  },
  /**
   * Check if the target is in the editor.
   */
  hasTarget(editor, target) {
    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);
  },
  /**
   * Check if the target is editable and in the editor.
   */
  hasEditableTarget(editor, target) {
    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
      editable: true
    });
  },
  /**
   * Check if the target can be selectable
   */
  hasSelectableTarget(editor, target) {
    return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);
  },
  /**
   * Check if the target is inside void and in an non-readonly editor.
   */
  isTargetInsideNonReadonlyVoid(editor, target) {
    if (IS_READ_ONLY.get(editor)) return false;
    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
    return Element2.isElement(slateNode) && Editor.isVoid(editor, slateNode);
  },
  /**
   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.
   */
  androidScheduleFlush(editor) {
    var _EDITOR_TO_SCHEDULE_F;
    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();
  },
  /**
   * Experimental and android specific: Get pending diffs
   */
  androidPendingDiffs(editor) {
    return EDITOR_TO_PENDING_DIFFS.get(editor);
  }
};
var _excluded$32 = ["anchor", "focus"];
var _excluded2$12 = ["anchor", "focus"];
var shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
var isDecorationFlagsEqual = (range, other) => {
  var rangeOwnProps = _objectWithoutProperties2(range, _excluded$32);
  var otherOwnProps = _objectWithoutProperties2(other, _excluded2$12);
  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);
};
var isElementDecorationsEqual = (list, another) => {
  if (list.length !== another.length) {
    return false;
  }
  for (var i4 = 0; i4 < list.length; i4++) {
    var range = list[i4];
    var other = another[i4];
    if (!Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {
      return false;
    }
  }
  return true;
};
var isTextDecorationsEqual = (list, another) => {
  if (list.length !== another.length) {
    return false;
  }
  for (var i4 = 0; i4 < list.length; i4++) {
    var range = list[i4];
    var other = another[i4];
    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {
      return false;
    }
  }
  return true;
};
var useIsomorphicLayoutEffect = CAN_USE_DOM ? import_react94.useLayoutEffect : import_react94.useEffect;
var String2 = (props) => {
  var {
    isLast,
    leaf,
    parent,
    text: text3
  } = props;
  var editor = useSlateStatic();
  var path = ReactEditor.findPath(editor, text3);
  var parentPath = Path.parent(path);
  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true;
  if (editor.isVoid(parent)) {
    return import_react94.default.createElement(ZeroWidthString, {
      length: Node2.string(parent).length
    });
  }
  if (leaf.text === "" && parent.children[parent.children.length - 1] === text3 && !editor.isInline(parent) && Editor.string(editor, parentPath) === "") {
    return import_react94.default.createElement(ZeroWidthString, {
      isLineBreak: true,
      isMarkPlaceholder
    });
  }
  if (leaf.text === "") {
    return import_react94.default.createElement(ZeroWidthString, {
      isMarkPlaceholder
    });
  }
  if (isLast && leaf.text.slice(-1) === "\n") {
    return import_react94.default.createElement(TextString, {
      isTrailing: true,
      text: leaf.text
    });
  }
  return import_react94.default.createElement(TextString, {
    text: leaf.text
  });
};
var TextString = (props) => {
  var {
    text: text3,
    isTrailing = false
  } = props;
  var ref = (0, import_react94.useRef)(null);
  var getTextContent = () => {
    return "".concat(text3 !== null && text3 !== void 0 ? text3 : "").concat(isTrailing ? "\n" : "");
  };
  var [initialText] = (0, import_react94.useState)(getTextContent);
  useIsomorphicLayoutEffect(() => {
    var textWithTrailing = getTextContent();
    if (ref.current && ref.current.textContent !== textWithTrailing) {
      ref.current.textContent = textWithTrailing;
    }
  });
  return import_react94.default.createElement(MemoizedText$1, {
    ref
  }, initialText);
};
var MemoizedText$1 = (0, import_react94.memo)((0, import_react94.forwardRef)((props, ref) => {
  return import_react94.default.createElement("span", {
    "data-slate-string": true,
    ref
  }, props.children);
}));
var ZeroWidthString = (props) => {
  var {
    length: length4 = 0,
    isLineBreak = false,
    isMarkPlaceholder = false
  } = props;
  var attributes = {
    "data-slate-zero-width": isLineBreak ? "n" : "z",
    "data-slate-length": length4
  };
  if (isMarkPlaceholder) {
    attributes["data-slate-mark-placeholder"] = true;
  }
  return import_react94.default.createElement("span", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? "\uFEFF" : null, isLineBreak ? import_react94.default.createElement("br", null) : null);
};
var EditorContext = (0, import_react94.createContext)(null);
var useSlateStatic = () => {
  var editor = (0, import_react94.useContext)(EditorContext);
  if (!editor) {
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  }
  return editor;
};
var Leaf = (props) => {
  var {
    leaf,
    isLast,
    text: text3,
    parent,
    renderPlaceholder,
    renderLeaf = (props2) => import_react94.default.createElement(DefaultLeaf, Object.assign({}, props2))
  } = props;
  var lastPlaceholderRef = (0, import_react94.useRef)(null);
  var placeholderRef = (0, import_react94.useRef)(null);
  var editor = useSlateStatic();
  var placeholderResizeObserver = (0, import_react94.useRef)(null);
  (0, import_react94.useEffect)(() => {
    return () => {
      if (placeholderResizeObserver.current) {
        placeholderResizeObserver.current.disconnect();
      }
    };
  }, []);
  (0, import_react94.useEffect)(() => {
    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;
    if (placeholderEl) {
      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);
    } else {
      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);
    }
    if (placeholderResizeObserver.current) {
      placeholderResizeObserver.current.disconnect();
      if (placeholderEl) placeholderResizeObserver.current.observe(placeholderEl);
    } else if (placeholderEl) {
      var ResizeObserver$1 = window.ResizeObserver || ResizeObserver;
      placeholderResizeObserver.current = new ResizeObserver$1(() => {
        var forceRender2 = EDITOR_TO_FORCE_RENDER.get(editor);
        forceRender2 === null || forceRender2 === void 0 ? void 0 : forceRender2();
      });
      placeholderResizeObserver.current.observe(placeholderEl);
    }
    if (!placeholderEl && lastPlaceholderRef.current) {
      var forceRender = EDITOR_TO_FORCE_RENDER.get(editor);
      forceRender === null || forceRender === void 0 ? void 0 : forceRender();
    }
    lastPlaceholderRef.current = placeholderRef.current;
    return () => {
      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);
    };
  }, [placeholderRef, leaf]);
  var children = import_react94.default.createElement(String2, {
    isLast,
    leaf,
    parent,
    text: text3
  });
  if (leaf[PLACEHOLDER_SYMBOL]) {
    var placeholderProps = {
      children: leaf.placeholder,
      attributes: {
        "data-slate-placeholder": true,
        style: {
          position: "absolute",
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none"
        },
        contentEditable: false,
        ref: placeholderRef
      }
    };
    children = import_react94.default.createElement(import_react94.default.Fragment, null, renderPlaceholder(placeholderProps), children);
  }
  var attributes = {
    "data-slate-leaf": true
  };
  return renderLeaf({
    attributes,
    children,
    leaf,
    text: text3
  });
};
var MemoizedLeaf = import_react94.default.memo(Leaf, (prev2, next2) => {
  return next2.parent === prev2.parent && next2.isLast === prev2.isLast && next2.renderLeaf === prev2.renderLeaf && next2.renderPlaceholder === prev2.renderPlaceholder && next2.text === prev2.text && Text2.equals(next2.leaf, prev2.leaf) && next2.leaf[PLACEHOLDER_SYMBOL] === prev2.leaf[PLACEHOLDER_SYMBOL];
});
var DefaultLeaf = (props) => {
  var {
    attributes,
    children
  } = props;
  return import_react94.default.createElement("span", Object.assign({}, attributes), children);
};
var Text3 = (props) => {
  var {
    decorations,
    isLast,
    parent,
    renderPlaceholder,
    renderLeaf,
    text: text3
  } = props;
  var editor = useSlateStatic();
  var ref = (0, import_react94.useRef)(null);
  var leaves = Text2.decorations(text3, decorations);
  var key = ReactEditor.findKey(editor, text3);
  var children = [];
  for (var i4 = 0; i4 < leaves.length; i4++) {
    var leaf = leaves[i4];
    children.push(import_react94.default.createElement(MemoizedLeaf, {
      isLast: isLast && i4 === leaves.length - 1,
      key: "".concat(key.id, "-").concat(i4),
      renderPlaceholder,
      leaf,
      text: text3,
      parent,
      renderLeaf
    }));
  }
  var callbackRef = (0, import_react94.useCallback)((span) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (span) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);
      NODE_TO_ELEMENT.set(text3, span);
      ELEMENT_TO_NODE.set(span, text3);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(text3);
      if (ref.current) {
        ELEMENT_TO_NODE.delete(ref.current);
      }
    }
    ref.current = span;
  }, [ref, editor, key, text3]);
  return import_react94.default.createElement("span", {
    "data-slate-node": "text",
    ref: callbackRef
  }, children);
};
var MemoizedText = import_react94.default.memo(Text3, (prev2, next2) => {
  return next2.parent === prev2.parent && next2.isLast === prev2.isLast && next2.renderLeaf === prev2.renderLeaf && next2.renderPlaceholder === prev2.renderPlaceholder && next2.text === prev2.text && isTextDecorationsEqual(next2.decorations, prev2.decorations);
});
var Element3 = (props) => {
  var {
    decorations,
    element: element2,
    renderElement = (p4) => import_react94.default.createElement(DefaultElement, Object.assign({}, p4)),
    renderPlaceholder,
    renderLeaf,
    selection
  } = props;
  var editor = useSlateStatic();
  var readOnly = useReadOnly();
  var isInline = editor.isInline(element2);
  var key = ReactEditor.findKey(editor, element2);
  var ref = (0, import_react94.useCallback)((ref2) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (ref2) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref2);
      NODE_TO_ELEMENT.set(element2, ref2);
      ELEMENT_TO_NODE.set(ref2, element2);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(element2);
    }
  }, [editor, key, element2]);
  var children = useChildren({
    decorations,
    node: element2,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection
  });
  var attributes = {
    "data-slate-node": "element",
    ref
  };
  if (isInline) {
    attributes["data-slate-inline"] = true;
  }
  if (!isInline && Editor.hasInlines(editor, element2)) {
    var text3 = Node2.string(element2);
    var dir = (0, import_direction.default)(text3);
    if (dir === "rtl") {
      attributes.dir = dir;
    }
  }
  if (Editor.isVoid(editor, element2)) {
    attributes["data-slate-void"] = true;
    if (!readOnly && isInline) {
      attributes.contentEditable = false;
    }
    var Tag = isInline ? "span" : "div";
    var [[_text]] = Node2.texts(element2);
    children = import_react94.default.createElement(Tag, {
      "data-slate-spacer": true,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, import_react94.default.createElement(MemoizedText, {
      renderPlaceholder,
      decorations: [],
      isLast: false,
      parent: element2,
      text: _text
    }));
    NODE_TO_INDEX.set(_text, 0);
    NODE_TO_PARENT.set(_text, element2);
  }
  return renderElement({
    attributes,
    children,
    element: element2
  });
};
var MemoizedElement = import_react94.default.memo(Element3, (prev2, next2) => {
  return prev2.element === next2.element && prev2.renderElement === next2.renderElement && prev2.renderLeaf === next2.renderLeaf && prev2.renderPlaceholder === next2.renderPlaceholder && isElementDecorationsEqual(prev2.decorations, next2.decorations) && (prev2.selection === next2.selection || !!prev2.selection && !!next2.selection && Range.equals(prev2.selection, next2.selection));
});
var DefaultElement = (props) => {
  var {
    attributes,
    children,
    element: element2
  } = props;
  var editor = useSlateStatic();
  var Tag = editor.isInline(element2) ? "span" : "div";
  return import_react94.default.createElement(Tag, Object.assign({}, attributes, {
    style: {
      position: "relative"
    }
  }), children);
};
var DecorateContext = (0, import_react94.createContext)(() => []);
var useDecorate = () => {
  return (0, import_react94.useContext)(DecorateContext);
};
var SelectedContext = (0, import_react94.createContext)(false);
var useSelected = () => {
  return (0, import_react94.useContext)(SelectedContext);
};
var useChildren = (props) => {
  var {
    decorations,
    node: node2,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection
  } = props;
  var decorate = useDecorate();
  var editor = useSlateStatic();
  var path = ReactEditor.findPath(editor, node2);
  var children = [];
  var isLeafBlock = Element2.isElement(node2) && !editor.isInline(node2) && Editor.hasInlines(editor, node2);
  for (var i4 = 0; i4 < node2.children.length; i4++) {
    var p4 = path.concat(i4);
    var n5 = node2.children[i4];
    var key = ReactEditor.findKey(editor, n5);
    var range = Editor.range(editor, p4);
    var sel = selection && Range.intersection(range, selection);
    var ds = decorate([n5, p4]);
    for (var dec of decorations) {
      var d5 = Range.intersection(dec, range);
      if (d5) {
        ds.push(d5);
      }
    }
    if (Element2.isElement(n5)) {
      children.push(import_react94.default.createElement(SelectedContext.Provider, {
        key: "provider-".concat(key.id),
        value: !!sel
      }, import_react94.default.createElement(MemoizedElement, {
        decorations: ds,
        element: n5,
        key: key.id,
        renderElement,
        renderPlaceholder,
        renderLeaf,
        selection: sel
      })));
    } else {
      children.push(import_react94.default.createElement(MemoizedText, {
        decorations: ds,
        key: key.id,
        isLast: isLeafBlock && i4 === node2.children.length - 1,
        parent: node2,
        renderPlaceholder,
        renderLeaf,
        text: n5
      }));
    }
    NODE_TO_INDEX.set(n5, i4);
    NODE_TO_PARENT.set(n5, node2);
  }
  return children;
};
var ReadOnlyContext = (0, import_react94.createContext)(false);
var useReadOnly = () => {
  return (0, import_react94.useContext)(ReadOnlyContext);
};
var SlateContext = (0, import_react94.createContext)(null);
var useSlate = () => {
  var context = (0, import_react94.useContext)(SlateContext);
  if (!context) {
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  }
  var {
    editor
  } = context;
  return editor;
};
var TRIPLE_CLICK = 3;
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
};
var APPLE_HOTKEYS = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var create2 = (key) => {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && (0, import_is_hotkey.isKeyHotkey)(generic);
  var isApple = apple && (0, import_is_hotkey.isKeyHotkey)(apple);
  var isWindows = windows && (0, import_is_hotkey.isKeyHotkey)(windows);
  return (event) => {
    if (isGeneric && isGeneric(event)) return true;
    if (IS_APPLE && isApple && isApple(event)) return true;
    if (!IS_APPLE && isWindows && isWindows(event)) return true;
    return false;
  };
};
var Hotkeys = {
  isBold: create2("bold"),
  isCompose: create2("compose"),
  isMoveBackward: create2("moveBackward"),
  isMoveForward: create2("moveForward"),
  isDeleteBackward: create2("deleteBackward"),
  isDeleteForward: create2("deleteForward"),
  isDeleteLineBackward: create2("deleteLineBackward"),
  isDeleteLineForward: create2("deleteLineForward"),
  isDeleteWordBackward: create2("deleteWordBackward"),
  isDeleteWordForward: create2("deleteWordForward"),
  isExtendBackward: create2("extendBackward"),
  isExtendForward: create2("extendForward"),
  isExtendLineBackward: create2("extendLineBackward"),
  isExtendLineForward: create2("extendLineForward"),
  isItalic: create2("italic"),
  isMoveLineBackward: create2("moveLineBackward"),
  isMoveLineForward: create2("moveLineForward"),
  isMoveWordBackward: create2("moveWordBackward"),
  isMoveWordForward: create2("moveWordForward"),
  isRedo: create2("redo"),
  isSoftBreak: create2("insertSoftBreak"),
  isSplitBlock: create2("splitBlock"),
  isTransposeCharacter: create2("transposeCharacter"),
  isUndo: create2("undo")
};
var createRestoreDomManager = (editor, receivedUserInput) => {
  var bufferedMutations = [];
  var clear2 = () => {
    bufferedMutations = [];
  };
  var registerMutations = (mutations) => {
    if (!receivedUserInput.current) {
      return;
    }
    var trackedMutations = mutations.filter((mutation) => isTrackedMutation(editor, mutation, mutations));
    bufferedMutations.push(...trackedMutations);
  };
  function restoreDOM() {
    if (bufferedMutations.length > 0) {
      bufferedMutations.reverse().forEach((mutation) => {
        if (mutation.type === "characterData") {
          return;
        }
        mutation.removedNodes.forEach((node2) => {
          mutation.target.insertBefore(node2, mutation.nextSibling);
        });
        mutation.addedNodes.forEach((node2) => {
          mutation.target.removeChild(node2);
        });
      });
      clear2();
    }
  }
  return {
    registerMutations,
    restoreDOM,
    clear: clear2
  };
};
var MUTATION_OBSERVER_CONFIG$1 = {
  subtree: true,
  childList: true,
  characterData: true,
  characterDataOldValue: true
};
var RestoreDOMComponent = class extends import_react94.Component {
  constructor() {
    super(...arguments);
    this.context = null;
    this.manager = null;
    this.mutationObserver = null;
  }
  observe() {
    var _this$mutationObserve;
    var {
      node: node2
    } = this.props;
    if (!node2.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node2.current, MUTATION_OBSERVER_CONFIG$1);
  }
  componentDidMount() {
    var {
      receivedUserInput
    } = this.props;
    var editor = this.context;
    this.manager = createRestoreDomManager(editor, receivedUserInput);
    this.mutationObserver = new MutationObserver(this.manager.registerMutations);
    this.observe();
  }
  getSnapshotBeforeUpdate() {
    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;
    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();
    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {
      var _this$manager;
      (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);
    }
    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();
    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();
    return null;
  }
  componentDidUpdate() {
    var _this$manager3;
    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();
    this.observe();
  }
  componentWillUnmount() {
    var _this$mutationObserve4;
    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();
  }
  render() {
    return this.props.children;
  }
};
RestoreDOMComponent.contextType = EditorContext;
var RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref) => {
  var {
    children
  } = _ref;
  return import_react94.default.createElement(import_react94.default.Fragment, null, children);
};
function verifyDiffState(editor, textDiff) {
  var {
    path,
    diff
  } = textDiff;
  if (!Editor.hasPath(editor, path)) {
    return false;
  }
  var node2 = Node2.get(editor, path);
  if (!Text2.isText(node2)) {
    return false;
  }
  if (diff.start !== node2.text.length || diff.text.length === 0) {
    return node2.text.slice(diff.start, diff.start + diff.text.length) === diff.text;
  }
  var nextPath = Path.next(path);
  if (!Editor.hasPath(editor, nextPath)) {
    return false;
  }
  var nextNode = Node2.get(editor, nextPath);
  return Text2.isText(nextNode) && nextNode.text.startsWith(diff.text);
}
function applyStringDiff(text3) {
  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    diffs[_key - 1] = arguments[_key];
  }
  return diffs.reduce((text4, diff) => text4.slice(0, diff.start) + diff.text + text4.slice(diff.end), text3);
}
function longestCommonPrefixLength(str, another) {
  var length4 = Math.min(str.length, another.length);
  for (var i4 = 0; i4 < length4; i4++) {
    if (str.charAt(i4) !== another.charAt(i4)) {
      return i4;
    }
  }
  return length4;
}
function longestCommonSuffixLength(str, another, max2) {
  var length4 = Math.min(str.length, another.length, max2);
  for (var i4 = 0; i4 < length4; i4++) {
    if (str.charAt(str.length - i4 - 1) !== another.charAt(another.length - i4 - 1)) {
      return i4;
    }
  }
  return length4;
}
function normalizeStringDiff(targetText, diff) {
  var {
    start: start2,
    end,
    text: text3
  } = diff;
  var removedText = targetText.slice(start2, end);
  var prefixLength = longestCommonPrefixLength(removedText, text3);
  var max2 = Math.min(removedText.length - prefixLength, text3.length - prefixLength);
  var suffixLength = longestCommonSuffixLength(removedText, text3, max2);
  var normalized = {
    start: start2 + prefixLength,
    end: end - suffixLength,
    text: text3.slice(prefixLength, text3.length - suffixLength)
  };
  if (normalized.start === normalized.end && normalized.text.length === 0) {
    return null;
  }
  return normalized;
}
function mergeStringDiffs(targetText, a3, b2) {
  var start2 = Math.min(a3.start, b2.start);
  var overlap = Math.max(0, Math.min(a3.start + a3.text.length, b2.end) - b2.start);
  var applied = applyStringDiff(targetText, a3, b2);
  var sliceEnd = Math.max(b2.start + b2.text.length, a3.start + a3.text.length + (a3.start + a3.text.length > b2.start ? b2.text.length : 0) - overlap);
  var text3 = applied.slice(start2, sliceEnd);
  var end = Math.max(a3.end, b2.end - a3.text.length + (a3.end - a3.start));
  return normalizeStringDiff(targetText, {
    start: start2,
    end,
    text: text3
  });
}
function targetRange(textDiff) {
  var {
    path,
    diff
  } = textDiff;
  return {
    anchor: {
      path,
      offset: diff.start
    },
    focus: {
      path,
      offset: diff.end
    }
  };
}
function normalizePoint(editor, point) {
  var {
    path,
    offset
  } = point;
  if (!Editor.hasPath(editor, path)) {
    return null;
  }
  var leaf = Node2.get(editor, path);
  if (!Text2.isText(leaf)) {
    return null;
  }
  var parentBlock = Editor.above(editor, {
    match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5),
    at: path
  });
  if (!parentBlock) {
    return null;
  }
  while (offset > leaf.text.length) {
    var entry = Editor.next(editor, {
      at: path,
      match: Text2.isText
    });
    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {
      return null;
    }
    offset -= leaf.text.length;
    leaf = entry[0];
    path = entry[1];
  }
  return {
    path,
    offset
  };
}
function normalizeRange(editor, range) {
  var anchor = normalizePoint(editor, range.anchor);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus = normalizePoint(editor, range.focus);
  if (!focus) {
    return null;
  }
  return {
    anchor,
    focus
  };
}
function transformPendingPoint(editor, point, op) {
  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref) => {
    var {
      path
    } = _ref;
    return Path.equals(path, point.path);
  });
  if (!textDiff || point.offset <= textDiff.diff.start) {
    return Point.transform(point, op, {
      affinity: "backward"
    });
  }
  var {
    diff
  } = textDiff;
  if (point.offset <= diff.start + diff.text.length) {
    var _anchor = {
      path: point.path,
      offset: diff.start
    };
    var _transformed = Point.transform(_anchor, op, {
      affinity: "backward"
    });
    if (!_transformed) {
      return null;
    }
    return {
      path: _transformed.path,
      offset: _transformed.offset + point.offset - diff.start
    };
  }
  var anchor = {
    path: point.path,
    offset: point.offset - diff.text.length + diff.end - diff.start
  };
  var transformed = Point.transform(anchor, op, {
    affinity: "backward"
  });
  if (!transformed) {
    return null;
  }
  if (op.type === "split_node" && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {
    return transformed;
  }
  return {
    path: transformed.path,
    offset: transformed.offset + diff.text.length - diff.end + diff.start
  };
}
function transformPendingRange(editor, range, op) {
  var anchor = transformPendingPoint(editor, range.anchor, op);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus = transformPendingPoint(editor, range.focus, op);
  if (!focus) {
    return null;
  }
  return {
    anchor,
    focus
  };
}
function transformTextDiff(textDiff, op) {
  var {
    path,
    diff,
    id: id2
  } = textDiff;
  switch (op.type) {
    case "insert_text": {
      if (!Path.equals(op.path, path) || op.offset >= diff.end) {
        return textDiff;
      }
      if (op.offset <= diff.start) {
        return {
          diff: {
            start: op.text.length + diff.start,
            end: op.text.length + diff.end,
            text: diff.text
          },
          id: id2,
          path
        };
      }
      return {
        diff: {
          start: diff.start,
          end: diff.end + op.text.length,
          text: diff.text
        },
        id: id2,
        path
      };
    }
    case "remove_text": {
      if (!Path.equals(op.path, path) || op.offset >= diff.end) {
        return textDiff;
      }
      if (op.offset + op.text.length <= diff.start) {
        return {
          diff: {
            start: diff.start - op.text.length,
            end: diff.end - op.text.length,
            text: diff.text
          },
          id: id2,
          path
        };
      }
      return {
        diff: {
          start: diff.start,
          end: diff.end - op.text.length,
          text: diff.text
        },
        id: id2,
        path
      };
    }
    case "split_node": {
      if (!Path.equals(op.path, path) || op.position >= diff.end) {
        return {
          diff,
          id: id2,
          path: Path.transform(path, op, {
            affinity: "backward"
          })
        };
      }
      if (op.position > diff.start) {
        return {
          diff: {
            start: diff.start,
            end: Math.min(op.position, diff.end),
            text: diff.text
          },
          id: id2,
          path
        };
      }
      return {
        diff: {
          start: diff.start - op.position,
          end: diff.end - op.position,
          text: diff.text
        },
        id: id2,
        path: Path.transform(path, op, {
          affinity: "forward"
        })
      };
    }
    case "merge_node": {
      if (!Path.equals(op.path, path)) {
        return {
          diff,
          id: id2,
          path: Path.transform(path, op)
        };
      }
      return {
        diff: {
          start: diff.start + op.position,
          end: diff.end + op.position,
          text: diff.text
        },
        id: id2,
        path: Path.transform(path, op)
      };
    }
  }
  var newPath = Path.transform(path, op);
  if (!newPath) {
    return null;
  }
  return {
    diff,
    path: newPath,
    id: id2
  };
}
function ownKeys$32(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$32(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$32(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$32(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var RESOLVE_DELAY = 25;
var FLUSH_DELAY = 200;
var debug = function debug2() {
};
var isDataTransfer = (value2) => (value2 === null || value2 === void 0 ? void 0 : value2.constructor.name) === "DataTransfer";
function createAndroidInputManager(_ref) {
  var {
    editor,
    scheduleOnDOMSelectionChange,
    onDOMSelectionChange
  } = _ref;
  var flushing = false;
  var compositionEndTimeoutId = null;
  var flushTimeoutId = null;
  var actionTimeoutId = null;
  var idCounter = 0;
  var insertPositionHint = false;
  var applyPendingSelection = () => {
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    if (pendingSelection) {
      var {
        selection
      } = editor;
      var normalized = normalizeRange(editor, pendingSelection);
      if (normalized && (!selection || !Range.equals(normalized, selection))) {
        Transforms.select(editor, normalized);
      }
    }
  };
  var performAction = () => {
    var action = EDITOR_TO_PENDING_ACTION.get(editor);
    EDITOR_TO_PENDING_ACTION.delete(editor);
    if (!action) {
      return;
    }
    if (action.at) {
      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);
      if (!target) {
        return;
      }
      var _targetRange = Editor.range(editor, target);
      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {
        Transforms.select(editor, target);
      }
    }
    action.run();
  };
  var flush2 = () => {
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    if (actionTimeoutId) {
      clearTimeout(actionTimeoutId);
      actionTimeoutId = null;
    }
    if (!hasPendingDiffs() && !hasPendingAction()) {
      applyPendingSelection();
      return;
    }
    if (!flushing) {
      flushing = true;
      setTimeout(() => flushing = false);
    }
    if (hasPendingAction()) {
      flushing = "action";
    }
    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {
      affinity: "forward"
    });
    EDITOR_TO_USER_MARKS.set(editor, editor.marks);
    debug("flush", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));
    var scheduleSelectionChange = hasPendingDiffs();
    var diff;
    while (diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {
      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;
      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
      if (pendingMarks !== void 0) {
        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
        editor.marks = pendingMarks;
      }
      if (pendingMarks && insertPositionHint === false) {
        insertPositionHint = null;
      }
      var range = targetRange(diff);
      if (!editor.selection || !Range.equals(editor.selection, range)) {
        Transforms.select(editor, range);
      }
      if (diff.diff.text) {
        Editor.insertText(editor, diff.diff.text);
      } else {
        Editor.deleteFragment(editor);
      }
      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2) => {
        var {
          id: id2
        } = _ref2;
        return id2 !== diff.id;
      }));
      if (!verifyDiffState(editor, diff)) {
        scheduleSelectionChange = false;
        EDITOR_TO_PENDING_ACTION.delete(editor);
        EDITOR_TO_USER_MARKS.delete(editor);
        flushing = "action";
        EDITOR_TO_PENDING_SELECTION.delete(editor);
        scheduleOnDOMSelectionChange.cancel();
        onDOMSelectionChange.cancel();
        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
      }
    }
    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {
      Transforms.select(editor, selection);
    }
    if (hasPendingAction()) {
      performAction();
      return;
    }
    if (scheduleSelectionChange) {
      scheduleOnDOMSelectionChange();
    }
    scheduleOnDOMSelectionChange.flush();
    onDOMSelectionChange.flush();
    applyPendingSelection();
    var userMarks = EDITOR_TO_USER_MARKS.get(editor);
    EDITOR_TO_USER_MARKS.delete(editor);
    if (userMarks !== void 0) {
      editor.marks = userMarks;
      editor.onChange();
    }
  };
  var handleCompositionEnd = (_event) => {
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
    }
    compositionEndTimeoutId = setTimeout(() => {
      IS_COMPOSING.set(editor, false);
      flush2();
    }, RESOLVE_DELAY);
  };
  var handleCompositionStart = (_event) => {
    IS_COMPOSING.set(editor, true);
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
      compositionEndTimeoutId = null;
    }
  };
  var updatePlaceholderVisibility = function updatePlaceholderVisibility2() {
    var forceHide = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);
    if (!placeholderElement) {
      return;
    }
    if (hasPendingDiffs() || forceHide) {
      placeholderElement.style.display = "none";
      return;
    }
    placeholderElement.style.removeProperty("display");
  };
  var storeDiff = (path, diff) => {
    var _EDITOR_TO_PENDING_DI3;
    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];
    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);
    var target = Node2.leaf(editor, path);
    var idx = pendingDiffs.findIndex((change) => Path.equals(change.path, path));
    if (idx < 0) {
      var normalized = normalizeStringDiff(target.text, diff);
      if (normalized) {
        pendingDiffs.push({
          path,
          diff,
          id: idCounter++
        });
      }
      updatePlaceholderVisibility();
      return;
    }
    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);
    if (!merged) {
      pendingDiffs.splice(idx, 1);
      updatePlaceholderVisibility();
      return;
    }
    pendingDiffs[idx] = _objectSpread$32(_objectSpread$32({}, pendingDiffs[idx]), {}, {
      diff: merged
    });
  };
  var scheduleAction = function scheduleAction2(run) {
    var {
      at
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    insertPositionHint = false;
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    scheduleOnDOMSelectionChange.cancel();
    onDOMSelectionChange.cancel();
    if (hasPendingAction()) {
      flush2();
    }
    EDITOR_TO_PENDING_ACTION.set(editor, {
      at,
      run
    });
    actionTimeoutId = setTimeout(flush2);
  };
  var handleDOMBeforeInput = (event) => {
    var _targetRange2;
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      inputType: type3
    } = event;
    var targetRange2 = null;
    var data = event.dataTransfer || event.data || void 0;
    if (insertPositionHint !== false && type3 !== "insertText" && type3 !== "insertCompositionText") {
      insertPositionHint = false;
    }
    var [nativeTargetRange] = event.getTargetRanges();
    if (nativeTargetRange) {
      targetRange2 = ReactEditor.toSlateRange(editor, nativeTargetRange, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    var window2 = ReactEditor.getWindow(editor);
    var domSelection = window2.getSelection();
    if (!targetRange2 && domSelection) {
      nativeTargetRange = domSelection;
      targetRange2 = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    targetRange2 = (_targetRange2 = targetRange2) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;
    if (!targetRange2) {
      return;
    }
    var canStoreDiff = true;
    if (type3.startsWith("delete")) {
      if (Range.isExpanded(targetRange2)) {
        var [_start, _end] = Range.edges(targetRange2);
        var _leaf = Node2.leaf(editor, _start.path);
        if (_leaf.text.length === _start.offset && _end.offset === 0) {
          var next2 = Editor.next(editor, {
            at: _start.path,
            match: Text2.isText
          });
          if (next2 && Path.equals(next2[1], _end.path)) {
            targetRange2 = {
              anchor: _end,
              focus: _end
            };
          }
        }
      }
      var direction = type3.endsWith("Backward") ? "backward" : "forward";
      var [start2, end] = Range.edges(targetRange2);
      var [leaf, path] = Editor.leaf(editor, start2.path);
      var diff = {
        text: "",
        start: start2.offset,
        end: end.offset
      };
      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change) => Path.equals(change.path, path));
      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];
      var text3 = applyStringDiff(leaf.text, ...diffs);
      if (text3.length === 0) {
        canStoreDiff = false;
      }
      if (Range.isExpanded(targetRange2)) {
        if (canStoreDiff && Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var point = {
            path: targetRange2.anchor.path,
            offset: start2.offset
          };
          var range = Editor.range(editor, point, point);
          handleUserSelect(range);
          return storeDiff(targetRange2.anchor.path, {
            text: "",
            end: end.offset,
            start: start2.offset
          });
        }
        return scheduleAction(() => Editor.deleteFragment(editor, {
          direction
        }), {
          at: targetRange2
        });
      }
    }
    switch (type3) {
      case "deleteByComposition":
      case "deleteByCut":
      case "deleteByDrag": {
        return scheduleAction(() => Editor.deleteFragment(editor), {
          at: targetRange2
        });
      }
      case "deleteContent":
      case "deleteContentForward": {
        var {
          anchor
        } = targetRange2;
        if (canStoreDiff && Range.isCollapsed(targetRange2)) {
          var targetNode = Node2.leaf(editor, anchor.path);
          if (anchor.offset < targetNode.text.length) {
            return storeDiff(anchor.path, {
              text: "",
              start: anchor.offset,
              end: anchor.offset + 1
            });
          }
        }
        return scheduleAction(() => Editor.deleteForward(editor), {
          at: targetRange2
        });
      }
      case "deleteContentBackward": {
        var _nativeTargetRange;
        var {
          anchor: _anchor
        } = targetRange2;
        var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);
        if (canStoreDiff && nativeCollapsed && Range.isCollapsed(targetRange2) && _anchor.offset > 0) {
          return storeDiff(_anchor.path, {
            text: "",
            start: _anchor.offset - 1,
            end: _anchor.offset
          });
        }
        return scheduleAction(() => Editor.deleteBackward(editor), {
          at: targetRange2
        });
      }
      case "deleteEntireSoftLine": {
        return scheduleAction(() => {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
        }, {
          at: targetRange2
        });
      }
      case "deleteHardLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteHardLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "insertLineBreak": {
        return scheduleAction(() => Editor.insertSoftBreak(editor), {
          at: targetRange2
        });
      }
      case "insertParagraph": {
        return scheduleAction(() => Editor.insertBreak(editor), {
          at: targetRange2
        });
      }
      case "insertCompositionText":
      case "deleteCompositionText":
      case "insertFromComposition":
      case "insertFromDrop":
      case "insertFromPaste":
      case "insertFromYank":
      case "insertReplacementText":
      case "insertText": {
        if (isDataTransfer(data)) {
          return scheduleAction(() => ReactEditor.insertData(editor, data), {
            at: targetRange2
          });
        }
        var _text = data !== null && data !== void 0 ? data : "";
        if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {
          _text = _text.replace("\uFEFF", "");
        }
        if (type3 === "insertText" && /.*\n.*\n$/.test(_text)) {
          _text = _text.slice(0, -1);
        }
        if (_text.includes("\n")) {
          return scheduleAction(() => {
            var parts = _text.split("\n");
            parts.forEach((line2, i4) => {
              if (line2) {
                Editor.insertText(editor, line2);
              }
              if (i4 !== parts.length - 1) {
                Editor.insertSoftBreak(editor);
              }
            });
          }, {
            at: targetRange2
          });
        }
        if (Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var [_start2, _end2] = Range.edges(targetRange2);
          var _diff = {
            start: _start2.offset,
            end: _end2.offset,
            text: _text
          };
          if (_text && insertPositionHint && type3 === "insertCompositionText") {
            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\S|$/);
            var diffPosition = _diff.start + _diff.text.search(/\S|$/);
            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {
              _diff.start -= 1;
              insertPositionHint = null;
              scheduleFlush();
            } else {
              insertPositionHint = false;
            }
          } else if (type3 === "insertText") {
            if (insertPositionHint === null) {
              insertPositionHint = _diff;
            } else if (insertPositionHint && Range.isCollapsed(targetRange2) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {
              insertPositionHint = _objectSpread$32(_objectSpread$32({}, insertPositionHint), {}, {
                text: insertPositionHint.text + _text
              });
            } else {
              insertPositionHint = false;
            }
          } else {
            insertPositionHint = false;
          }
          if (canStoreDiff) {
            storeDiff(_start2.path, _diff);
            return;
          }
        }
        return scheduleAction(() => Editor.insertText(editor, _text), {
          at: targetRange2
        });
      }
    }
  };
  var hasPendingAction = () => {
    return !!EDITOR_TO_PENDING_ACTION.get(editor);
  };
  var hasPendingDiffs = () => {
    var _EDITOR_TO_PENDING_DI4;
    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);
  };
  var hasPendingChanges = () => {
    return hasPendingAction() || hasPendingDiffs();
  };
  var isFlushing = () => {
    return flushing;
  };
  var handleUserSelect = (range) => {
    EDITOR_TO_PENDING_SELECTION.set(editor, range);
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      selection
    } = editor;
    if (!range) {
      return;
    }
    var pathChanged = !selection || !Path.equals(selection.anchor.path, range.anchor.path);
    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));
    if (pathChanged && insertPositionHint || parentPathChanged) {
      insertPositionHint = false;
    }
    if (pathChanged || hasPendingDiffs()) {
      flushTimeoutId = setTimeout(flush2, FLUSH_DELAY);
    }
  };
  var handleInput = () => {
    if (hasPendingAction() || !hasPendingDiffs()) {
      flush2();
    }
  };
  var handleKeyDown = (_2) => {
    if (!hasPendingDiffs()) {
      updatePlaceholderVisibility(true);
      setTimeout(updatePlaceholderVisibility);
    }
  };
  var scheduleFlush = () => {
    if (!hasPendingAction()) {
      actionTimeoutId = setTimeout(flush2);
    }
  };
  var handleDomMutations = (mutations) => {
    if (hasPendingDiffs() || hasPendingAction()) {
      return;
    }
    if (mutations.some((mutation) => isTrackedMutation(editor, mutation, mutations))) {
      var _EDITOR_TO_FORCE_REND;
      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();
    }
  };
  return {
    flush: flush2,
    scheduleFlush,
    hasPendingDiffs,
    hasPendingAction,
    hasPendingChanges,
    isFlushing,
    handleUserSelect,
    handleCompositionEnd,
    handleCompositionStart,
    handleDOMBeforeInput,
    handleKeyDown,
    handleDomMutations,
    handleInput
  };
}
function useIsMounted2() {
  var isMountedRef = (0, import_react94.useRef)(false);
  (0, import_react94.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef.current;
}
function useMutationObserver(node2, callback, options) {
  var [mutationObserver] = (0, import_react94.useState)(() => new MutationObserver(callback));
  useIsomorphicLayoutEffect(() => {
    mutationObserver.takeRecords();
  });
  (0, import_react94.useEffect)(() => {
    if (!node2.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    mutationObserver.observe(node2.current, options);
    return () => mutationObserver.disconnect();
  }, []);
}
var _excluded$22 = ["node"];
function ownKeys$22(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$22(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$22(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$22(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var MUTATION_OBSERVER_CONFIG = {
  subtree: true,
  childList: true,
  characterData: true
};
function useAndroidInputManager(_ref) {
  var {
    node: node2
  } = _ref, options = _objectWithoutProperties2(_ref, _excluded$22);
  if (!IS_ANDROID) {
    return null;
  }
  var editor = useSlateStatic();
  var isMounted = useIsMounted2();
  var [inputManager] = (0, import_react94.useState)(() => createAndroidInputManager(_objectSpread$22({
    editor
  }, options)));
  useMutationObserver(node2, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);
  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);
  if (isMounted) {
    inputManager.flush();
  }
  return inputManager;
}
function useTrackUserInput() {
  var editor = useSlateStatic();
  var receivedUserInput = (0, import_react94.useRef)(false);
  var animationFrameIdRef = (0, import_react94.useRef)(0);
  var onUserInput = (0, import_react94.useCallback)(() => {
    if (receivedUserInput.current) {
      return;
    }
    receivedUserInput.current = true;
    var window2 = ReactEditor.getWindow(editor);
    window2.cancelAnimationFrame(animationFrameIdRef.current);
    animationFrameIdRef.current = window2.requestAnimationFrame(() => {
      receivedUserInput.current = false;
    });
  }, []);
  (0, import_react94.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);
  return {
    receivedUserInput,
    onUserInput
  };
}
var _excluded$12 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"];
var _excluded22 = ["text"];
function ownKeys$12(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$12(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$12(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$12(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Children3 = (props) => import_react94.default.createElement(import_react94.default.Fragment, null, useChildren(props));
var Editable = (props) => {
  var _EDITOR_TO_PLACEHOLDE, _EDITOR_TO_PLACEHOLDE2;
  var defaultRenderPlaceholder = (0, import_react94.useCallback)((props2) => import_react94.default.createElement(DefaultPlaceholder, Object.assign({}, props2)), []);
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder,
    readOnly = false,
    renderElement,
    renderLeaf,
    renderPlaceholder = defaultRenderPlaceholder,
    scrollSelectionIntoView = defaultScrollSelectionIntoView,
    style: userStyle = {},
    as: Component2 = "div",
    disableDefaultStyles = false
  } = props, attributes = _objectWithoutProperties2(props, _excluded$12);
  var editor = useSlate();
  var [isComposing, setIsComposing] = (0, import_react94.useState)(false);
  var ref = (0, import_react94.useRef)(null);
  var deferredOperations = (0, import_react94.useRef)([]);
  var {
    onUserInput,
    receivedUserInput
  } = useTrackUserInput();
  var [, forceRender] = (0, import_react94.useReducer)((s4) => s4 + 1, 0);
  EDITOR_TO_FORCE_RENDER.set(editor, forceRender);
  IS_READ_ONLY.set(editor, readOnly);
  var state = (0, import_react94.useMemo)(() => ({
    isDraggingInternally: false,
    isUpdatingSelection: false,
    latestElement: null,
    hasMarkPlaceholder: false
  }), []);
  (0, import_react94.useEffect)(() => {
    if (ref.current && autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]);
  var onDOMSelectionChange = (0, import_react94.useCallback)((0, import_throttle.default)(() => {
    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      var {
        activeElement
      } = root;
      var el = ReactEditor.toDOMNode(editor, editor);
      var domSelection = root.getSelection();
      if (activeElement === el) {
        state.latestElement = activeElement;
        IS_FOCUSED.set(editor, true);
      } else {
        IS_FOCUSED.delete(editor);
      }
      if (!domSelection) {
        return Transforms.deselect(editor);
      }
      var {
        anchorNode,
        focusNode
      } = domSelection;
      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);
      var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);
      if (anchorNodeSelectable && focusNodeSelectable) {
        var range = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: true
        });
        if (range) {
          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {
            Transforms.select(editor, range);
          } else {
            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);
          }
        }
      }
      if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {
        Transforms.deselect(editor);
      }
    }
  }, 100), [readOnly]);
  var scheduleOnDOMSelectionChange = (0, import_react94.useMemo)(() => (0, import_debounce.default)(onDOMSelectionChange, 0), [onDOMSelectionChange]);
  var androidInputManager = useAndroidInputManager({
    node: ref,
    onDOMSelectionChange,
    scheduleOnDOMSelectionChange
  });
  useIsomorphicLayoutEffect(() => {
    var window2;
    if (ref.current && (window2 = getDefaultView(ref.current))) {
      EDITOR_TO_WINDOW.set(editor, window2);
      EDITOR_TO_ELEMENT.set(editor, ref.current);
      NODE_TO_ELEMENT.set(editor, ref.current);
      ELEMENT_TO_NODE.set(ref.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root.getSelection();
    if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {
      return;
    }
    var setDomSelection = (forceChange) => {
      var hasDomSelection = domSelection.type !== "None";
      if (!selection && !hasDomSelection) {
        return;
      }
      var editorElement = EDITOR_TO_ELEMENT.get(editor);
      var hasDomSelectionInEditor = false;
      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
        hasDomSelectionInEditor = true;
      }
      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {
        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: true,
          // domSelection is not necessarily a valid Slate range
          // (e.g. when clicking on contentEditable:false element)
          suppressThrow: true
        });
        if (slateRange && Range.equals(slateRange, selection)) {
          var _anchorNode$parentEle;
          if (!state.hasMarkPlaceholder) {
            return;
          }
          var {
            anchorNode
          } = domSelection;
          if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute("data-slate-mark-placeholder")) {
            return;
          }
        }
      }
      if (selection && !ReactEditor.hasRange(editor, selection)) {
        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: true
        });
        return;
      }
      state.isUpdatingSelection = true;
      var newDomRange2 = selection && ReactEditor.toDOMRange(editor, selection);
      if (newDomRange2) {
        if (Range.isBackward(selection)) {
          domSelection.setBaseAndExtent(newDomRange2.endContainer, newDomRange2.endOffset, newDomRange2.startContainer, newDomRange2.startOffset);
        } else {
          domSelection.setBaseAndExtent(newDomRange2.startContainer, newDomRange2.startOffset, newDomRange2.endContainer, newDomRange2.endOffset);
        }
        scrollSelectionIntoView(editor, newDomRange2);
      } else {
        domSelection.removeAllRanges();
      }
      return newDomRange2;
    };
    var newDomRange = setDomSelection();
    var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === "action";
    if (!IS_ANDROID || !ensureSelection) {
      setTimeout(() => {
        if (newDomRange && IS_FIREFOX) {
          var el = ReactEditor.toDOMNode(editor, editor);
          el.focus();
        }
        state.isUpdatingSelection = false;
      });
      return;
    }
    var timeoutId = null;
    var animationFrameId = requestAnimationFrame(() => {
      if (ensureSelection) {
        var ensureDomSelection = (forceChange) => {
          try {
            var el = ReactEditor.toDOMNode(editor, editor);
            el.focus();
            setDomSelection(forceChange);
          } catch (e4) {
          }
        };
        ensureDomSelection();
        timeoutId = setTimeout(() => {
          ensureDomSelection(true);
          state.isUpdatingSelection = false;
        });
      }
    });
    return () => {
      cancelAnimationFrame(animationFrameId);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  });
  var onDOMBeforeInput = (0, import_react94.useCallback)((event) => {
    onUserInput();
    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      var _EDITOR_TO_USER_SELEC;
      if (androidInputManager) {
        return androidInputManager.handleDOMBeforeInput(event);
      }
      scheduleOnDOMSelectionChange.flush();
      onDOMSelectionChange.flush();
      var {
        selection
      } = editor;
      var {
        inputType: type3
      } = event;
      var data = event.dataTransfer || event.data || void 0;
      var isCompositionChange = type3 === "insertCompositionText" || type3 === "deleteCompositionText";
      if (isCompositionChange && ReactEditor.isComposing(editor)) {
        return;
      }
      var native = false;
      if (type3 === "insertText" && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      selection.anchor.offset !== 0) {
        var _node$parentElement, _window$getComputedSt;
        native = true;
        if (editor.marks) {
          native = false;
        }
        var {
          anchor: anchor2
        } = selection;
        var [node2, offset] = ReactEditor.toDOMPoint(editor, anchor2);
        var anchorNode = (_node$parentElement = node2.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest("a");
        var window2 = ReactEditor.getWindow(editor);
        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {
          var _lastText$textContent;
          var lastText = window2 === null || window2 === void 0 ? void 0 : window2.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();
          if (lastText === node2 && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {
            native = false;
          }
        }
        if (native && node2.parentElement && (window2 === null || window2 === void 0 ? void 0 : (_window$getComputedSt = window2.getComputedStyle(node2.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === "pre") {
          var block2 = Editor.above(editor, {
            at: anchor2.path,
            match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5)
          });
          if (block2 && Node2.string(block2[0]).includes("	")) {
            native = false;
          }
        }
      }
      if (!type3.startsWith("delete") || type3.startsWith("deleteBy")) {
        var [targetRange2] = event.getTargetRanges();
        if (targetRange2) {
          var range = ReactEditor.toSlateRange(editor, targetRange2, {
            exactMatch: false,
            suppressThrow: false
          });
          if (!selection || !Range.equals(selection, range)) {
            native = false;
            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);
            Transforms.select(editor, range);
            if (selectionRef) {
              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);
            }
          }
        }
      }
      if (isCompositionChange) {
        return;
      }
      if (!native) {
        event.preventDefault();
      }
      if (selection && Range.isExpanded(selection) && type3.startsWith("delete")) {
        var direction = type3.endsWith("Backward") ? "backward" : "forward";
        Editor.deleteFragment(editor, {
          direction
        });
        return;
      }
      switch (type3) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          Editor.deleteFragment(editor);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          Editor.deleteForward(editor);
          break;
        }
        case "deleteContentBackward": {
          Editor.deleteBackward(editor);
          break;
        }
        case "deleteEntireSoftLine": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          Editor.deleteForward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          Editor.deleteBackward(editor, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          Editor.deleteForward(editor, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          Editor.insertSoftBreak(editor);
          break;
        case "insertParagraph": {
          Editor.insertBreak(editor);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          if (type3 === "insertFromComposition") {
            if (ReactEditor.isComposing(editor)) {
              setIsComposing(false);
              IS_COMPOSING.set(editor, false);
            }
          }
          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === "DataTransfer") {
            ReactEditor.insertData(editor, data);
          } else if (typeof data === "string") {
            if (native) {
              deferredOperations.current.push(() => Editor.insertText(editor, data));
            } else {
              Editor.insertText(editor, data);
            }
          }
          break;
        }
      }
      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
      EDITOR_TO_USER_SELECTION.delete(editor);
      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {
        Transforms.select(editor, toRestore);
      }
    }
  }, [readOnly, propsOnDOMBeforeInput]);
  var callbackRef = (0, import_react94.useCallback)((node2) => {
    if (node2 == null) {
      onDOMSelectionChange.cancel();
      scheduleOnDOMSelectionChange.cancel();
      EDITOR_TO_ELEMENT.delete(editor);
      NODE_TO_ELEMENT.delete(editor);
      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {
        ref.current.removeEventListener("beforeinput", onDOMBeforeInput);
      }
    } else {
      if (HAS_BEFORE_INPUT_SUPPORT) {
        node2.addEventListener("beforeinput", onDOMBeforeInput);
      }
    }
    ref.current = node2;
  }, [ref, onDOMBeforeInput, onDOMSelectionChange, scheduleOnDOMSelectionChange]);
  useIsomorphicLayoutEffect(() => {
    var window2 = ReactEditor.getWindow(editor);
    window2.document.addEventListener("selectionchange", scheduleOnDOMSelectionChange);
    return () => {
      window2.document.removeEventListener("selectionchange", scheduleOnDOMSelectionChange);
    };
  }, [scheduleOnDOMSelectionChange]);
  var decorations = decorate([editor, []]);
  if (placeholder && editor.children.length === 1 && Array.from(Node2.texts(editor)).length === 1 && Node2.string(editor) === "" && !isComposing) {
    var start2 = Editor.start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder,
      anchor: start2,
      focus: start2
    });
  }
  var {
    marks
  } = editor;
  state.hasMarkPlaceholder = false;
  if (editor.selection && Range.isCollapsed(editor.selection) && marks) {
    var {
      anchor
    } = editor.selection;
    var leaf = Node2.leaf(editor, anchor.path);
    var rest = _objectWithoutProperties2(leaf, _excluded22);
    if (!Text2.equals(leaf, marks, {
      loose: true
    })) {
      state.hasMarkPlaceholder = true;
      var unset = Object.fromEntries(Object.keys(rest).map((mark) => [mark, null]));
      decorations.push(_objectSpread$12(_objectSpread$12(_objectSpread$12({
        [MARK_PLACEHOLDER_SYMBOL]: true
      }, unset), marks), {}, {
        anchor,
        focus: anchor
      }));
    }
  }
  (0, import_react94.useEffect)(() => {
    setTimeout(() => {
      var {
        selection
      } = editor;
      if (selection) {
        var {
          anchor: _anchor
        } = selection;
        var _text = Node2.leaf(editor, _anchor.path);
        if (marks && !Text2.equals(_text, marks, {
          loose: true
        })) {
          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);
          return;
        }
      }
      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
    });
  });
  var placeholderHeight = (_EDITOR_TO_PLACEHOLDE = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor)) === null || _EDITOR_TO_PLACEHOLDE === void 0 ? void 0 : (_EDITOR_TO_PLACEHOLDE2 = _EDITOR_TO_PLACEHOLDE.getBoundingClientRect()) === null || _EDITOR_TO_PLACEHOLDE2 === void 0 ? void 0 : _EDITOR_TO_PLACEHOLDE2.height;
  return import_react94.default.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, import_react94.default.createElement(DecorateContext.Provider, {
    value: decorate
  }, import_react94.default.createElement(RestoreDOM, {
    node: ref,
    receivedUserInput
  }, import_react94.default.createElement(Component2, Object.assign({
    role: readOnly ? void 0 : "textbox",
    "aria-multiline": readOnly ? void 0 : true
  }, attributes, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,
    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : "false",
    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : "false",
    "data-slate-editor": true,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !readOnly,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: true,
    ref: callbackRef,
    style: _objectSpread$12(_objectSpread$12({}, disableDefaultStyles ? {} : _objectSpread$12({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Prevent the default outline styles.
      outline: "none",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, placeholderHeight ? {
      minHeight: placeholderHeight
    } : {})), userStyle),
    onBeforeInput: (0, import_react94.useCallback)((event) => {
      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {
        event.preventDefault();
        if (!ReactEditor.isComposing(editor)) {
          var _text2 = event.data;
          Editor.insertText(editor, _text2);
        }
      }
    }, [readOnly]),
    onInput: (0, import_react94.useCallback)((event) => {
      if (isEventHandled(event, attributes.onInput)) {
        return;
      }
      if (androidInputManager) {
        androidInputManager.handleInput();
        return;
      }
      for (var op of deferredOperations.current) {
        op();
      }
      deferredOperations.current = [];
    }, []),
    onBlur: (0, import_react94.useCallback)((event) => {
      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      }
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      if (state.latestElement === root.activeElement) {
        return;
      }
      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor);
      if (relatedTarget === el) {
        return;
      }
      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute("data-slate-spacer")) {
        return;
      }
      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node2 = ReactEditor.toSlateNode(editor, relatedTarget);
        if (Element2.isElement(node2) && !editor.isVoid(node2)) {
          return;
        }
      }
      if (IS_SAFARI) {
        var domSelection = root.getSelection();
        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();
      }
      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: (0, import_react94.useCallback)((event) => {
      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node2 = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node2);
        if (!Editor.hasPath(editor, path) || Node2.get(editor, path) !== node2) {
          return;
        }
        if (event.detail === TRIPLE_CLICK && path.length >= 1) {
          var blockPath = path;
          if (!(Element2.isElement(node2) && Editor.isBlock(editor, node2))) {
            var _block$;
            var block2 = Editor.above(editor, {
              match: (n5) => Element2.isElement(n5) && Editor.isBlock(editor, n5),
              at: path
            });
            blockPath = (_block$ = block2 === null || block2 === void 0 ? void 0 : block2[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);
          }
          var range = Editor.range(editor, blockPath);
          Transforms.select(editor, range);
          return;
        }
        if (readOnly) {
          return;
        }
        var _start = Editor.start(editor, path);
        var end = Editor.end(editor, path);
        var startVoid = Editor.void(editor, {
          at: _start
        });
        var endVoid = Editor.void(editor, {
          at: end
        });
        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
          var _range = Editor.range(editor, _start);
          Transforms.select(editor, _range);
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: (0, import_react94.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target)) {
        if (ReactEditor.isComposing(editor)) {
          setIsComposing(false);
          IS_COMPOSING.set(editor, false);
        }
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);
        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {
          return;
        }
        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {
          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
          if (placeholderMarks !== void 0) {
            EDITOR_TO_USER_MARKS.set(editor, editor.marks);
            editor.marks = placeholderMarks;
          }
          Editor.insertText(editor, event.data);
          var userMarks = EDITOR_TO_USER_MARKS.get(editor);
          EDITOR_TO_USER_MARKS.delete(editor);
          if (userMarks !== void 0) {
            editor.marks = userMarks;
          }
        }
      }
    }, [attributes.onCompositionEnd]),
    onCompositionUpdate: (0, import_react94.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
        if (!ReactEditor.isComposing(editor)) {
          setIsComposing(true);
          IS_COMPOSING.set(editor, true);
        }
      }
    }, [attributes.onCompositionUpdate]),
    onCompositionStart: (0, import_react94.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target)) {
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);
        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {
          return;
        }
        setIsComposing(true);
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
            return;
          }
          var inline = Editor.above(editor, {
            match: (n5) => Element2.isElement(n5) && Editor.isInline(editor, n5),
            mode: "highest"
          });
          if (inline) {
            var [, inlinePath] = inline;
            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {
              var point = Editor.after(editor, inlinePath);
              Transforms.setSelection(editor, {
                anchor: point,
                focus: point
              });
            }
          }
        }
      }
    }, [attributes.onCompositionStart]),
    onCopy: (0, import_react94.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "copy");
      }
    }, [attributes.onCopy]),
    onCut: (0, import_react94.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "cut");
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
          } else {
            var node2 = Node2.parent(editor, selection.anchor.path);
            if (Editor.isVoid(editor, node2)) {
              Transforms.delete(editor);
            }
          }
        }
      }
    }, [readOnly, attributes.onCut]),
    onDragOver: (0, import_react94.useCallback)((event) => {
      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
        var node2 = ReactEditor.toSlateNode(editor, event.target);
        if (Element2.isElement(node2) && Editor.isVoid(editor, node2)) {
          event.preventDefault();
        }
      }
    }, [attributes.onDragOver]),
    onDragStart: (0, import_react94.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
        var node2 = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node2);
        var voidMatch = Element2.isElement(node2) && Editor.isVoid(editor, node2) || Editor.void(editor, {
          at: path,
          voids: true
        });
        if (voidMatch) {
          var range = Editor.range(editor, path);
          Transforms.select(editor, range);
        }
        state.isDraggingInternally = true;
        ReactEditor.setFragmentData(editor, event.dataTransfer, "drag");
      }
    }, [readOnly, attributes.onDragStart]),
    onDrop: (0, import_react94.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {
        event.preventDefault();
        var draggedRange = editor.selection;
        var range = ReactEditor.findEventRange(editor, event);
        var data = event.dataTransfer;
        Transforms.select(editor, range);
        if (state.isDraggingInternally) {
          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {
            at: range,
            voids: true
          })) {
            Transforms.delete(editor, {
              at: draggedRange
            });
          }
        }
        ReactEditor.insertData(editor, data);
        if (!ReactEditor.isFocused(editor)) {
          ReactEditor.focus(editor);
        }
      }
      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDrop]),
    onDragEnd: (0, import_react94.useCallback)((event) => {
      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {
        attributes.onDragEnd(event);
      }
      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDragEnd]),
    onFocus: (0, import_react94.useCallback)((event) => {
      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var el = ReactEditor.toDOMNode(editor, editor);
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        state.latestElement = root.activeElement;
        if (IS_FIREFOX && event.target !== el) {
          el.focus();
          return;
        }
        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onKeyDown: (0, import_react94.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleKeyDown(event);
        var {
          nativeEvent
        } = event;
        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {
          IS_COMPOSING.set(editor, false);
          setIsComposing(false);
        }
        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {
          return;
        }
        var {
          selection
        } = editor;
        var element2 = editor.children[selection !== null ? selection.focus.path[0] : 0];
        var isRTL = (0, import_direction.default)(Node2.string(element2)) === "rtl";
        if (Hotkeys.isRedo(nativeEvent)) {
          event.preventDefault();
          var maybeHistoryEditor = editor;
          if (typeof maybeHistoryEditor.redo === "function") {
            maybeHistoryEditor.redo();
          }
          return;
        }
        if (Hotkeys.isUndo(nativeEvent)) {
          event.preventDefault();
          var _maybeHistoryEditor = editor;
          if (typeof _maybeHistoryEditor.undo === "function") {
            _maybeHistoryEditor.undo();
          }
          return;
        }
        if (Hotkeys.isMoveLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isMoveLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line"
          });
          return;
        }
        if (Hotkeys.isExtendLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isExtendLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Hotkeys.isMoveBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: !isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: "start"
            });
          }
          return;
        }
        if (Hotkeys.isMoveForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: "end"
            });
          }
          return;
        }
        if (Hotkeys.isMoveWordBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: !isRTL
          });
          return;
        }
        if (Hotkeys.isMoveWordForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: isRTL
          });
          return;
        }
        if (!HAS_BEFORE_INPUT_SUPPORT) {
          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
            event.preventDefault();
            return;
          }
          if (Hotkeys.isSoftBreak(nativeEvent)) {
            event.preventDefault();
            Editor.insertSoftBreak(editor);
            return;
          }
          if (Hotkeys.isSplitBlock(nativeEvent)) {
            event.preventDefault();
            Editor.insertBreak(editor);
            return;
          }
          if (Hotkeys.isDeleteBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteLineForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "word"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "word"
              });
            }
            return;
          }
        } else {
          if (IS_CHROME || IS_SAFARI) {
            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {
              var currentNode = Node2.parent(editor, selection.anchor.path);
              if (Element2.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {
                event.preventDefault();
                Editor.deleteBackward(editor, {
                  unit: "block"
                });
                return;
              }
            }
          }
        }
      }
    }, [readOnly, attributes.onKeyDown]),
    onPaste: (0, import_react94.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {
        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_SAFARI) {
          event.preventDefault();
          ReactEditor.insertData(editor, event.clipboardData);
        }
      }
    }, [readOnly, attributes.onPaste])
  }), import_react94.default.createElement(Children3, {
    decorations,
    node: editor,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection: editor.selection
  })))));
};
var DefaultPlaceholder = (_ref) => {
  var {
    attributes,
    children
  } = _ref;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    import_react94.default.createElement("span", Object.assign({}, attributes), children, IS_ANDROID && import_react94.default.createElement("br", null))
  );
};
var defaultDecorate = () => [];
var defaultScrollSelectionIntoView = (editor, domRange) => {
  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {
    var leafEl = domRange.startContainer.parentElement;
    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
    es_default(leafEl, {
      scrollMode: "if-needed"
    });
    delete leafEl.getBoundingClientRect;
  }
};
var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isDefaultPrevented() || event.isPropagationStopped();
};
var isDOMEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.defaultPrevented;
};
var FocusedContext = (0, import_react94.createContext)(false);
var SlateSelectorContext = (0, import_react94.createContext)({});
function getSelectorContext(editor) {
  var eventListeners = (0, import_react94.useRef)([]).current;
  var slateRef = (0, import_react94.useRef)({
    editor
  }).current;
  var onChange2 = (0, import_react94.useCallback)((editor2) => {
    slateRef.editor = editor2;
    eventListeners.forEach((listener) => listener(editor2));
  }, []);
  var selectorContext = (0, import_react94.useMemo)(() => {
    return {
      getSlate: () => slateRef.editor,
      addEventListener: (callback) => {
        eventListeners.push(callback);
        return () => {
          eventListeners.splice(eventListeners.indexOf(callback), 1);
        };
      }
    };
  }, [eventListeners, slateRef]);
  return {
    selectorContext,
    onChange: onChange2
  };
}
var _excluded3 = ["editor", "children", "onChange", "value"];
var Slate = (props) => {
  var {
    editor,
    children,
    onChange: onChange2,
    value: value2
  } = props, rest = _objectWithoutProperties2(props, _excluded3);
  var unmountRef = (0, import_react94.useRef)(false);
  var [context, setContext] = import_react94.default.useState(() => {
    if (!Node2.isNodeList(value2)) {
      throw new Error("[Slate] value is invalid! Expected a list of elements but got: ".concat(Scrubber.stringify(value2)));
    }
    if (!Editor.isEditor(editor)) {
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Scrubber.stringify(editor)));
    }
    editor.children = value2;
    Object.assign(editor, rest);
    return {
      v: 0,
      editor
    };
  });
  var {
    selectorContext,
    onChange: handleSelectorChange
  } = getSelectorContext(editor);
  var onContextChange = (0, import_react94.useCallback)(() => {
    if (onChange2) {
      onChange2(editor.children);
    }
    setContext((prevContext) => ({
      v: prevContext.v + 1,
      editor
    }));
    handleSelectorChange(editor);
  }, [onChange2]);
  (0, import_react94.useEffect)(() => {
    EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
    return () => {
      EDITOR_TO_ON_CHANGE.set(editor, () => {
      });
      unmountRef.current = true;
    };
  }, [onContextChange]);
  var [isFocused, setIsFocused] = (0, import_react94.useState)(ReactEditor.isFocused(editor));
  (0, import_react94.useEffect)(() => {
    setIsFocused(ReactEditor.isFocused(editor));
  });
  useIsomorphicLayoutEffect(() => {
    var fn2 = () => setIsFocused(ReactEditor.isFocused(editor));
    if (IS_REACT_VERSION_17_OR_ABOVE) {
      document.addEventListener("focusin", fn2);
      document.addEventListener("focusout", fn2);
      return () => {
        document.removeEventListener("focusin", fn2);
        document.removeEventListener("focusout", fn2);
      };
    } else {
      document.addEventListener("focus", fn2, true);
      document.addEventListener("blur", fn2, true);
      return () => {
        document.removeEventListener("focus", fn2, true);
        document.removeEventListener("blur", fn2, true);
      };
    }
  }, []);
  return import_react94.default.createElement(SlateSelectorContext.Provider, {
    value: selectorContext
  }, import_react94.default.createElement(SlateContext.Provider, {
    value: context
  }, import_react94.default.createElement(EditorContext.Provider, {
    value: context.editor
  }, import_react94.default.createElement(FocusedContext.Provider, {
    value: isFocused
  }, children))));
};
var doRectsIntersect = (rect, compareRect) => {
  var middle = (compareRect.top + compareRect.bottom) / 2;
  return rect.top <= middle && rect.bottom >= middle;
};
var areRangesSameLine = (editor, range1, range2) => {
  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();
  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();
  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);
};
var findCurrentLineRange = (editor, parentRange) => {
  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));
  var positions = Array.from(Editor.positions(editor, {
    at: parentRange
  }));
  var left = 0;
  var right = positions.length;
  var middle = Math.floor(right / 2);
  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {
    return Editor.range(editor, positions[left], parentRangeBoundary);
  }
  if (positions.length < 2) {
    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);
  }
  while (middle !== positions.length && middle !== left) {
    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {
      right = middle;
    } else {
      left = middle;
    }
    middle = Math.floor((left + right) / 2);
  }
  return Editor.range(editor, positions[right], parentRangeBoundary);
};
function ownKeys2(object3, enumerableOnly) {
  var keys3 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var withReact = function withReact2(editor) {
  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment";
  var e4 = editor;
  var {
    apply,
    onChange: onChange2,
    deleteBackward,
    addMark,
    removeMark
  } = e4;
  EDITOR_TO_KEY_TO_ELEMENT.set(e4, /* @__PURE__ */ new WeakMap());
  e4.addMark = (key, value2) => {
    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;
    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e4)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();
    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e4) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e4)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {
      EDITOR_TO_PENDING_INSERTION_MARKS.set(e4, null);
    }
    EDITOR_TO_USER_MARKS.delete(e4);
    addMark(key, value2);
  };
  e4.removeMark = (key) => {
    var _EDITOR_TO_PENDING_DI2;
    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e4) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e4)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {
      EDITOR_TO_PENDING_INSERTION_MARKS.set(e4, null);
    }
    EDITOR_TO_USER_MARKS.delete(e4);
    removeMark(key);
  };
  e4.deleteBackward = (unit) => {
    if (unit !== "line") {
      return deleteBackward(unit);
    }
    if (e4.selection && Range.isCollapsed(e4.selection)) {
      var parentBlockEntry = Editor.above(e4, {
        match: (n5) => Element2.isElement(n5) && Editor.isBlock(e4, n5),
        at: e4.selection
      });
      if (parentBlockEntry) {
        var [, parentBlockPath] = parentBlockEntry;
        var parentElementRange = Editor.range(e4, parentBlockPath, e4.selection.anchor);
        var currentLineRange = findCurrentLineRange(e4, parentElementRange);
        if (!Range.isCollapsed(currentLineRange)) {
          Transforms.delete(e4, {
            at: currentLineRange
          });
        }
      }
    }
  };
  e4.apply = (op) => {
    var matches = [];
    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e4);
    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {
      var transformed = pendingDiffs.map((textDiff) => transformTextDiff(textDiff, op)).filter(Boolean);
      EDITOR_TO_PENDING_DIFFS.set(e4, transformed);
    }
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e4);
    if (pendingSelection) {
      EDITOR_TO_PENDING_SELECTION.set(e4, transformPendingRange(e4, pendingSelection, op));
    }
    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e4);
    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {
      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e4, pendingAction.at, op) : transformPendingRange(e4, pendingAction.at, op);
      EDITOR_TO_PENDING_ACTION.set(e4, at ? _objectSpread2(_objectSpread2({}, pendingAction), {}, {
        at
      }) : null);
    }
    switch (op.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        matches.push(...getMatches(e4, op.path));
        break;
      }
      case "set_selection": {
        var _EDITOR_TO_USER_SELEC;
        (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e4)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
        EDITOR_TO_USER_SELECTION.delete(e4);
        break;
      }
      case "insert_node":
      case "remove_node": {
        matches.push(...getMatches(e4, Path.parent(op.path)));
        break;
      }
      case "merge_node": {
        var prevPath = Path.previous(op.path);
        matches.push(...getMatches(e4, prevPath));
        break;
      }
      case "move_node": {
        var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));
        matches.push(...getMatches(e4, commonPath));
        break;
      }
    }
    apply(op);
    for (var [path, key] of matches) {
      var [node2] = Editor.node(e4, path);
      NODE_TO_KEY.set(node2, key);
    }
  };
  e4.setFragmentData = (data) => {
    var {
      selection
    } = e4;
    if (!selection) {
      return;
    }
    var [start2, end] = Range.edges(selection);
    var startVoid = Editor.void(e4, {
      at: start2.path
    });
    var endVoid = Editor.void(e4, {
      at: end.path
    });
    if (Range.isCollapsed(selection) && !startVoid) {
      return;
    }
    var domRange = ReactEditor.toDOMRange(e4, selection);
    var contents = domRange.cloneContents();
    var attach = contents.childNodes[0];
    contents.childNodes.forEach((node2) => {
      if (node2.textContent && node2.textContent.trim() !== "") {
        attach = node2;
      }
    });
    if (endVoid) {
      var [voidNode] = endVoid;
      var r6 = domRange.cloneRange();
      var domNode = ReactEditor.toDOMNode(e4, voidNode);
      r6.setEndAfter(domNode);
      contents = r6.cloneContents();
    }
    if (startVoid) {
      attach = contents.querySelector("[data-slate-spacer]");
    }
    Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
      var isNewline = zw.getAttribute("data-slate-zero-width") === "n";
      zw.textContent = isNewline ? "\n" : "";
    });
    if (isDOMText(attach)) {
      var span = attach.ownerDocument.createElement("span");
      span.style.whiteSpace = "pre";
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }
    var fragment = e4.getFragment();
    var string2 = JSON.stringify(fragment);
    var encoded = window.btoa(encodeURIComponent(string2));
    attach.setAttribute("data-slate-fragment", encoded);
    data.setData("application/".concat(clipboardFormatKey), encoded);
    var div = contents.ownerDocument.createElement("div");
    div.appendChild(contents);
    div.setAttribute("hidden", "true");
    contents.ownerDocument.body.appendChild(div);
    data.setData("text/html", div.innerHTML);
    data.setData("text/plain", getPlainText(div));
    contents.ownerDocument.body.removeChild(div);
    return data;
  };
  e4.insertData = (data) => {
    if (!e4.insertFragmentData(data)) {
      e4.insertTextData(data);
    }
  };
  e4.insertFragmentData = (data) => {
    var fragment = data.getData("application/".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);
    if (fragment) {
      var decoded = decodeURIComponent(window.atob(fragment));
      var parsed = JSON.parse(decoded);
      e4.insertFragment(parsed);
      return true;
    }
    return false;
  };
  e4.insertTextData = (data) => {
    var text3 = data.getData("text/plain");
    if (text3) {
      var lines = text3.split(/\r\n|\r|\n/);
      var split2 = false;
      for (var line2 of lines) {
        if (split2) {
          Transforms.splitNodes(e4, {
            always: true
          });
        }
        e4.insertText(line2);
        split2 = true;
      }
      return true;
    }
    return false;
  };
  e4.onChange = (options) => {
    import_react_dom4.default.unstable_batchedUpdates(() => {
      var onContextChange = EDITOR_TO_ON_CHANGE.get(e4);
      if (onContextChange) {
        onContextChange();
      }
      onChange2(options);
    });
  };
  return e4;
};
var getMatches = (e4, path) => {
  var matches = [];
  for (var [n5, p4] of Editor.levels(e4, {
    at: path
  })) {
    var key = ReactEditor.findKey(e4, n5);
    matches.push([p4, key]);
  }
  return matches;
};

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-link2Icon.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var link2Icon = (0, import_jsx_runtime23.jsx)("path", {
  d: "M9 17H7A5 5 0 0 1 7 7h2M15 7h2a5 5 0 1 1 0 10h-2M8 12h8"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-link2OffIcon.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var link2OffIcon = (0, import_jsx_runtime24.jsx)("path", {
  d: "M9 17H7A5 5 0 0 1 7 7M15 7h2a5 5 0 0 1 4 8M8 12h4M2 2l20 20"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-pencilIcon.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var pencilIcon = (0, import_jsx_runtime25.jsx)("path", {
  d: "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5ZM15 5l4 4"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-trash2Icon.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var trash2Icon = (0, import_jsx_runtime26.jsx)("path", {
  d: "M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M10 11v6M14 11v6"
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-undo2Icon.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var undo2Icon = (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, {
  children: [(0, import_jsx_runtime27.jsx)("path", {
    d: "M9 14 4 9l5-5"
  }), (0, import_jsx_runtime27.jsx)("path", {
    d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"
  })]
});

// node_modules/@react-aria/numberfield/dist/ar-AE.mjs
var $fb78e0f6ab6349ed$exports = {};
$fb78e0f6ab6349ed$exports = {
  "decrease": (args2) => `خفض ${args2.fieldLabel}`,
  "increase": (args2) => `زيادة ${args2.fieldLabel}`,
  "numberField": `حقل رقمي`
};

// node_modules/@react-aria/numberfield/dist/bg-BG.mjs
var $2776acdd9959a647$exports = {};
$2776acdd9959a647$exports = {
  "decrease": (args2) => `Намаляване ${args2.fieldLabel}`,
  "increase": (args2) => `Усилване ${args2.fieldLabel}`,
  "numberField": `Номер на полето`
};

// node_modules/@react-aria/numberfield/dist/cs-CZ.mjs
var $741954410a365ad3$exports = {};
$741954410a365ad3$exports = {
  "decrease": (args2) => `Snížit ${args2.fieldLabel}`,
  "increase": (args2) => `Zvýšit ${args2.fieldLabel}`,
  "numberField": `Číselné pole`
};

// node_modules/@react-aria/numberfield/dist/da-DK.mjs
var $8321ed0f8ab642f0$exports = {};
$8321ed0f8ab642f0$exports = {
  "decrease": (args2) => `Reducer ${args2.fieldLabel}`,
  "increase": (args2) => `Øg ${args2.fieldLabel}`,
  "numberField": `Talfelt`
};

// node_modules/@react-aria/numberfield/dist/de-DE.mjs
var $92978e0c4ecafa32$exports = {};
$92978e0c4ecafa32$exports = {
  "decrease": (args2) => `${args2.fieldLabel} verringern`,
  "increase": (args2) => `${args2.fieldLabel} erhöhen`,
  "numberField": `Nummernfeld`
};

// node_modules/@react-aria/numberfield/dist/el-GR.mjs
var $ac5ff71962864a84$exports = {};
$ac5ff71962864a84$exports = {
  "decrease": (args2) => `Μείωση ${args2.fieldLabel}`,
  "increase": (args2) => `Αύξηση ${args2.fieldLabel}`,
  "numberField": `Πεδίο αριθμού`
};

// node_modules/@react-aria/numberfield/dist/en-US.mjs
var $efe4685e2440d8be$exports = {};
$efe4685e2440d8be$exports = {
  "decrease": (args2) => `Decrease ${args2.fieldLabel}`,
  "increase": (args2) => `Increase ${args2.fieldLabel}`,
  "numberField": `Number field`
};

// node_modules/@react-aria/numberfield/dist/es-ES.mjs
var $e50a9a48739b90e1$exports = {};
$e50a9a48739b90e1$exports = {
  "decrease": (args2) => `Reducir ${args2.fieldLabel}`,
  "increase": (args2) => `Aumentar ${args2.fieldLabel}`,
  "numberField": `Campo de número`
};

// node_modules/@react-aria/numberfield/dist/et-EE.mjs
var $6e0d5294ecbb8ab6$exports = {};
$6e0d5294ecbb8ab6$exports = {
  "decrease": (args2) => `Vähenda ${args2.fieldLabel}`,
  "increase": (args2) => `Suurenda ${args2.fieldLabel}`,
  "numberField": `Numbri väli`
};

// node_modules/@react-aria/numberfield/dist/fi-FI.mjs
var $e7129d65f607f77f$exports = {};
$e7129d65f607f77f$exports = {
  "decrease": (args2) => `Vähennä ${args2.fieldLabel}`,
  "increase": (args2) => `Lisää ${args2.fieldLabel}`,
  "numberField": `Numerokenttä`
};

// node_modules/@react-aria/numberfield/dist/fr-FR.mjs
var $d72adf5b20573e34$exports = {};
$d72adf5b20573e34$exports = {
  "decrease": (args2) => `Diminuer ${args2.fieldLabel}`,
  "increase": (args2) => `Augmenter ${args2.fieldLabel}`,
  "numberField": `Champ de nombre`
};

// node_modules/@react-aria/numberfield/dist/he-IL.mjs
var $a25c707e88b844a7$exports = {};
$a25c707e88b844a7$exports = {
  "decrease": (args2) => `הקטן ${args2.fieldLabel}`,
  "increase": (args2) => `הגדל ${args2.fieldLabel}`,
  "numberField": `שדה מספר`
};

// node_modules/@react-aria/numberfield/dist/hr-HR.mjs
var $69b41140b9a4ca54$exports = {};
$69b41140b9a4ca54$exports = {
  "decrease": (args2) => `Smanji ${args2.fieldLabel}`,
  "increase": (args2) => `Povećaj ${args2.fieldLabel}`,
  "numberField": `Polje broja`
};

// node_modules/@react-aria/numberfield/dist/hu-HU.mjs
var $81dab28f37f59d1a$exports = {};
$81dab28f37f59d1a$exports = {
  "decrease": (args2) => `${args2.fieldLabel} csökkentése`,
  "increase": (args2) => `${args2.fieldLabel} növelése`,
  "numberField": `Számmező`
};

// node_modules/@react-aria/numberfield/dist/it-IT.mjs
var $866555b31f2d7711$exports = {};
$866555b31f2d7711$exports = {
  "decrease": (args2) => `Riduci ${args2.fieldLabel}`,
  "increase": (args2) => `Aumenta ${args2.fieldLabel}`,
  "numberField": `Campo numero`
};

// node_modules/@react-aria/numberfield/dist/ja-JP.mjs
var $dafcd55d52b9d371$exports = {};
$dafcd55d52b9d371$exports = {
  "decrease": (args2) => `${args2.fieldLabel}を縮小`,
  "increase": (args2) => `${args2.fieldLabel}を拡大`,
  "numberField": `数値フィールド`
};

// node_modules/@react-aria/numberfield/dist/ko-KR.mjs
var $f090c1f8c5da0145$exports = {};
$f090c1f8c5da0145$exports = {
  "decrease": (args2) => `${args2.fieldLabel} 감소`,
  "increase": (args2) => `${args2.fieldLabel} 증가`,
  "numberField": `번호 필드`
};

// node_modules/@react-aria/numberfield/dist/lt-LT.mjs
var $6f10f3a13360a75c$exports = {};
$6f10f3a13360a75c$exports = {
  "decrease": (args2) => `Sumažinti ${args2.fieldLabel}`,
  "increase": (args2) => `Padidinti ${args2.fieldLabel}`,
  "numberField": `Numerio laukas`
};

// node_modules/@react-aria/numberfield/dist/lv-LV.mjs
var $47432cefd4b7bd1b$exports = {};
$47432cefd4b7bd1b$exports = {
  "decrease": (args2) => `Samazināšana ${args2.fieldLabel}`,
  "increase": (args2) => `Palielināšana ${args2.fieldLabel}`,
  "numberField": `Skaitļu lauks`
};

// node_modules/@react-aria/numberfield/dist/nb-NO.mjs
var $dc578a950a2bf23d$exports = {};
$dc578a950a2bf23d$exports = {
  "decrease": (args2) => `Reduser ${args2.fieldLabel}`,
  "increase": (args2) => `Øk ${args2.fieldLabel}`,
  "numberField": `Tallfelt`
};

// node_modules/@react-aria/numberfield/dist/nl-NL.mjs
var $353f1bfca4dc395a$exports = {};
$353f1bfca4dc395a$exports = {
  "decrease": (args2) => `${args2.fieldLabel} verlagen`,
  "increase": (args2) => `${args2.fieldLabel} verhogen`,
  "numberField": `Getalveld`
};

// node_modules/@react-aria/numberfield/dist/pl-PL.mjs
var $241bc0bbd870e982$exports = {};
$241bc0bbd870e982$exports = {
  "decrease": (args2) => `Zmniejsz ${args2.fieldLabel}`,
  "increase": (args2) => `Zwiększ ${args2.fieldLabel}`,
  "numberField": `Pole numeru`
};

// node_modules/@react-aria/numberfield/dist/pt-BR.mjs
var $da3005c7bd72b0a8$exports = {};
$da3005c7bd72b0a8$exports = {
  "decrease": (args2) => `Diminuir ${args2.fieldLabel}`,
  "increase": (args2) => `Aumentar ${args2.fieldLabel}`,
  "numberField": `Campo de número`
};

// node_modules/@react-aria/numberfield/dist/pt-PT.mjs
var $cf48bfc540882310$exports = {};
$cf48bfc540882310$exports = {
  "decrease": (args2) => `Diminuir ${args2.fieldLabel}`,
  "increase": (args2) => `Aumentar ${args2.fieldLabel}`,
  "numberField": `Campo numérico`
};

// node_modules/@react-aria/numberfield/dist/ro-RO.mjs
var $b63a28c481ab9ee3$exports = {};
$b63a28c481ab9ee3$exports = {
  "decrease": (args2) => `Scădere ${args2.fieldLabel}`,
  "increase": (args2) => `Creștere ${args2.fieldLabel}`,
  "numberField": `Câmp numeric`
};

// node_modules/@react-aria/numberfield/dist/ru-RU.mjs
var $19f9df95c2464ab6$exports = {};
$19f9df95c2464ab6$exports = {
  "decrease": (args2) => `Уменьшение ${args2.fieldLabel}`,
  "increase": (args2) => `Увеличение ${args2.fieldLabel}`,
  "numberField": `Числовое поле`
};

// node_modules/@react-aria/numberfield/dist/sk-SK.mjs
var $b272932a685e8482$exports = {};
$b272932a685e8482$exports = {
  "decrease": (args2) => `Znížiť ${args2.fieldLabel}`,
  "increase": (args2) => `Zvýšiť ${args2.fieldLabel}`,
  "numberField": `Číselné pole`
};

// node_modules/@react-aria/numberfield/dist/sl-SI.mjs
var $cbaf8b5b61f9e544$exports = {};
$cbaf8b5b61f9e544$exports = {
  "decrease": (args2) => `Upadati ${args2.fieldLabel}`,
  "increase": (args2) => `Povečajte ${args2.fieldLabel}`,
  "numberField": `Številčno polje`
};

// node_modules/@react-aria/numberfield/dist/sr-SP.mjs
var $e0a3af6ac1449b2f$exports = {};
$e0a3af6ac1449b2f$exports = {
  "decrease": (args2) => `Smanji ${args2.fieldLabel}`,
  "increase": (args2) => `Povećaj ${args2.fieldLabel}`,
  "numberField": `Polje broja`
};

// node_modules/@react-aria/numberfield/dist/sv-SE.mjs
var $71e167d2458a6019$exports = {};
$71e167d2458a6019$exports = {
  "decrease": (args2) => `Minska ${args2.fieldLabel}`,
  "increase": (args2) => `Öka ${args2.fieldLabel}`,
  "numberField": `Nummerfält`
};

// node_modules/@react-aria/numberfield/dist/tr-TR.mjs
var $3719245abc082946$exports = {};
$3719245abc082946$exports = {
  "decrease": (args2) => `${args2.fieldLabel} azalt`,
  "increase": (args2) => `${args2.fieldLabel} arttır`,
  "numberField": `Sayı alanı`
};

// node_modules/@react-aria/numberfield/dist/uk-UA.mjs
var $2ccc589e2f51824d$exports = {};
$2ccc589e2f51824d$exports = {
  "decrease": (args2) => `Зменшити ${args2.fieldLabel}`,
  "increase": (args2) => `Збільшити ${args2.fieldLabel}`,
  "numberField": `Поле номера`
};

// node_modules/@react-aria/numberfield/dist/zh-CN.mjs
var $e1103cb9b4c13942$exports = {};
$e1103cb9b4c13942$exports = {
  "decrease": (args2) => `降低 ${args2.fieldLabel}`,
  "increase": (args2) => `提高 ${args2.fieldLabel}`,
  "numberField": `数字字段`
};

// node_modules/@react-aria/numberfield/dist/zh-TW.mjs
var $448607634f80dccb$exports = {};
$448607634f80dccb$exports = {
  "decrease": (args2) => `縮小 ${args2.fieldLabel}`,
  "increase": (args2) => `放大 ${args2.fieldLabel}`,
  "numberField": `數字欄位`
};

// node_modules/@react-aria/numberfield/dist/intlStrings.mjs
var $280a227d7cb94b92$exports = {};
$280a227d7cb94b92$exports = {
  "ar-AE": $fb78e0f6ab6349ed$exports,
  "bg-BG": $2776acdd9959a647$exports,
  "cs-CZ": $741954410a365ad3$exports,
  "da-DK": $8321ed0f8ab642f0$exports,
  "de-DE": $92978e0c4ecafa32$exports,
  "el-GR": $ac5ff71962864a84$exports,
  "en-US": $efe4685e2440d8be$exports,
  "es-ES": $e50a9a48739b90e1$exports,
  "et-EE": $6e0d5294ecbb8ab6$exports,
  "fi-FI": $e7129d65f607f77f$exports,
  "fr-FR": $d72adf5b20573e34$exports,
  "he-IL": $a25c707e88b844a7$exports,
  "hr-HR": $69b41140b9a4ca54$exports,
  "hu-HU": $81dab28f37f59d1a$exports,
  "it-IT": $866555b31f2d7711$exports,
  "ja-JP": $dafcd55d52b9d371$exports,
  "ko-KR": $f090c1f8c5da0145$exports,
  "lt-LT": $6f10f3a13360a75c$exports,
  "lv-LV": $47432cefd4b7bd1b$exports,
  "nb-NO": $dc578a950a2bf23d$exports,
  "nl-NL": $353f1bfca4dc395a$exports,
  "pl-PL": $241bc0bbd870e982$exports,
  "pt-BR": $da3005c7bd72b0a8$exports,
  "pt-PT": $cf48bfc540882310$exports,
  "ro-RO": $b63a28c481ab9ee3$exports,
  "ru-RU": $19f9df95c2464ab6$exports,
  "sk-SK": $b272932a685e8482$exports,
  "sl-SI": $cbaf8b5b61f9e544$exports,
  "sr-SP": $e0a3af6ac1449b2f$exports,
  "sv-SE": $71e167d2458a6019$exports,
  "tr-TR": $3719245abc082946$exports,
  "uk-UA": $2ccc589e2f51824d$exports,
  "zh-CN": $e1103cb9b4c13942$exports,
  "zh-TW": $448607634f80dccb$exports
};

// node_modules/@react-aria/numberfield/dist/useNumberField.mjs
var import_react96 = __toESM(require_react(), 1);

// node_modules/@react-aria/spinbutton/dist/ar-AE.mjs
var $ed6aae4e5f766f1e$exports = {};
$ed6aae4e5f766f1e$exports = {
  "Empty": `فارغ`
};

// node_modules/@react-aria/spinbutton/dist/bg-BG.mjs
var $38854e2b175151fa$exports = {};
$38854e2b175151fa$exports = {
  "Empty": `Изпразни`
};

// node_modules/@react-aria/spinbutton/dist/cs-CZ.mjs
var $15b25ab20f3945b2$exports = {};
$15b25ab20f3945b2$exports = {
  "Empty": `Prázdné`
};

// node_modules/@react-aria/spinbutton/dist/da-DK.mjs
var $692a4298b6b649a2$exports = {};
$692a4298b6b649a2$exports = {
  "Empty": `Tom`
};

// node_modules/@react-aria/spinbutton/dist/de-DE.mjs
var $1c6e1539193f1243$exports = {};
$1c6e1539193f1243$exports = {
  "Empty": `Leer`
};

// node_modules/@react-aria/spinbutton/dist/el-GR.mjs
var $1e8678632c464b6d$exports = {};
$1e8678632c464b6d$exports = {
  "Empty": `Άδειο`
};

// node_modules/@react-aria/spinbutton/dist/en-US.mjs
var $4adc85d9bf5b9eed$exports = {};
$4adc85d9bf5b9eed$exports = {
  "Empty": `Empty`
};

// node_modules/@react-aria/spinbutton/dist/es-ES.mjs
var $41c4b2bb61dafbca$exports = {};
$41c4b2bb61dafbca$exports = {
  "Empty": `Vacío`
};

// node_modules/@react-aria/spinbutton/dist/et-EE.mjs
var $405f8b24f5dd2a60$exports = {};
$405f8b24f5dd2a60$exports = {
  "Empty": `Tühjenda`
};

// node_modules/@react-aria/spinbutton/dist/fi-FI.mjs
var $7efe3ed02b9b9dd4$exports = {};
$7efe3ed02b9b9dd4$exports = {
  "Empty": `Tyhjä`
};

// node_modules/@react-aria/spinbutton/dist/fr-FR.mjs
var $99fc4c101d92daf3$exports = {};
$99fc4c101d92daf3$exports = {
  "Empty": `Vide`
};

// node_modules/@react-aria/spinbutton/dist/he-IL.mjs
var $f9e155e6e8cacaa2$exports = {};
$f9e155e6e8cacaa2$exports = {
  "Empty": `ריק`
};

// node_modules/@react-aria/spinbutton/dist/hr-HR.mjs
var $c31b5e8e9a249fd5$exports = {};
$c31b5e8e9a249fd5$exports = {
  "Empty": `Prazno`
};

// node_modules/@react-aria/spinbutton/dist/hu-HU.mjs
var $9c5435bc17499bd9$exports = {};
$9c5435bc17499bd9$exports = {
  "Empty": `Üres`
};

// node_modules/@react-aria/spinbutton/dist/it-IT.mjs
var $6d1fc8e84d8165e1$exports = {};
$6d1fc8e84d8165e1$exports = {
  "Empty": `Vuoto`
};

// node_modules/@react-aria/spinbutton/dist/ja-JP.mjs
var $46ea6b3641b83e71$exports = {};
$46ea6b3641b83e71$exports = {
  "Empty": `空`
};

// node_modules/@react-aria/spinbutton/dist/ko-KR.mjs
var $0e3cc9a288289dc5$exports = {};
$0e3cc9a288289dc5$exports = {
  "Empty": `비어 있음`
};

// node_modules/@react-aria/spinbutton/dist/lt-LT.mjs
var $4ff2bb25c0089ffb$exports = {};
$4ff2bb25c0089ffb$exports = {
  "Empty": `Tuščias`
};

// node_modules/@react-aria/spinbutton/dist/lv-LV.mjs
var $6cf33cd4c010a2fb$exports = {};
$6cf33cd4c010a2fb$exports = {
  "Empty": `Tukšs`
};

// node_modules/@react-aria/spinbutton/dist/nb-NO.mjs
var $5a9f8486f8b8837e$exports = {};
$5a9f8486f8b8837e$exports = {
  "Empty": `Tom`
};

// node_modules/@react-aria/spinbutton/dist/nl-NL.mjs
var $583f94d807f6ecea$exports = {};
$583f94d807f6ecea$exports = {
  "Empty": `Leeg`
};

// node_modules/@react-aria/spinbutton/dist/pl-PL.mjs
var $cc4dcfeea2b4050d$exports = {};
$cc4dcfeea2b4050d$exports = {
  "Empty": `Pusty`
};

// node_modules/@react-aria/spinbutton/dist/pt-BR.mjs
var $68ac2954d56e12b4$exports = {};
$68ac2954d56e12b4$exports = {
  "Empty": `Vazio`
};

// node_modules/@react-aria/spinbutton/dist/pt-PT.mjs
var $fdb0616f309780b0$exports = {};
$fdb0616f309780b0$exports = {
  "Empty": `Vazio`
};

// node_modules/@react-aria/spinbutton/dist/ro-RO.mjs
var $fe1eccf4ee1d6f52$exports = {};
$fe1eccf4ee1d6f52$exports = {
  "Empty": `Gol`
};

// node_modules/@react-aria/spinbutton/dist/ru-RU.mjs
var $a38b6c4e18725976$exports = {};
$a38b6c4e18725976$exports = {
  "Empty": `Не заполнено`
};

// node_modules/@react-aria/spinbutton/dist/sk-SK.mjs
var $6c14ae2b766b652c$exports = {};
$6c14ae2b766b652c$exports = {
  "Empty": `Prázdne`
};

// node_modules/@react-aria/spinbutton/dist/sl-SI.mjs
var $8f1c9692e16dc5eb$exports = {};
$8f1c9692e16dc5eb$exports = {
  "Empty": `Prazen`
};

// node_modules/@react-aria/spinbutton/dist/sr-SP.mjs
var $d2aa7abea627cafa$exports = {};
$d2aa7abea627cafa$exports = {
  "Empty": `Prazno`
};

// node_modules/@react-aria/spinbutton/dist/sv-SE.mjs
var $676b82e4b56408e6$exports = {};
$676b82e4b56408e6$exports = {
  "Empty": `Tomt`
};

// node_modules/@react-aria/spinbutton/dist/tr-TR.mjs
var $14c9042552d7ce08$exports = {};
$14c9042552d7ce08$exports = {
  "Empty": `Boş`
};

// node_modules/@react-aria/spinbutton/dist/uk-UA.mjs
var $393254ebcb66c9f5$exports = {};
$393254ebcb66c9f5$exports = {
  "Empty": `Пусто`
};

// node_modules/@react-aria/spinbutton/dist/zh-CN.mjs
var $d49d621f310cf6ce$exports = {};
$d49d621f310cf6ce$exports = {
  "Empty": `空`
};

// node_modules/@react-aria/spinbutton/dist/zh-TW.mjs
var $94b60c866ca5dfe6$exports = {};
$94b60c866ca5dfe6$exports = {
  "Empty": `空白`
};

// node_modules/@react-aria/spinbutton/dist/intlStrings.mjs
var $a99895ee3dc79e61$exports = {};
$a99895ee3dc79e61$exports = {
  "ar-AE": $ed6aae4e5f766f1e$exports,
  "bg-BG": $38854e2b175151fa$exports,
  "cs-CZ": $15b25ab20f3945b2$exports,
  "da-DK": $692a4298b6b649a2$exports,
  "de-DE": $1c6e1539193f1243$exports,
  "el-GR": $1e8678632c464b6d$exports,
  "en-US": $4adc85d9bf5b9eed$exports,
  "es-ES": $41c4b2bb61dafbca$exports,
  "et-EE": $405f8b24f5dd2a60$exports,
  "fi-FI": $7efe3ed02b9b9dd4$exports,
  "fr-FR": $99fc4c101d92daf3$exports,
  "he-IL": $f9e155e6e8cacaa2$exports,
  "hr-HR": $c31b5e8e9a249fd5$exports,
  "hu-HU": $9c5435bc17499bd9$exports,
  "it-IT": $6d1fc8e84d8165e1$exports,
  "ja-JP": $46ea6b3641b83e71$exports,
  "ko-KR": $0e3cc9a288289dc5$exports,
  "lt-LT": $4ff2bb25c0089ffb$exports,
  "lv-LV": $6cf33cd4c010a2fb$exports,
  "nb-NO": $5a9f8486f8b8837e$exports,
  "nl-NL": $583f94d807f6ecea$exports,
  "pl-PL": $cc4dcfeea2b4050d$exports,
  "pt-BR": $68ac2954d56e12b4$exports,
  "pt-PT": $fdb0616f309780b0$exports,
  "ro-RO": $fe1eccf4ee1d6f52$exports,
  "ru-RU": $a38b6c4e18725976$exports,
  "sk-SK": $6c14ae2b766b652c$exports,
  "sl-SI": $8f1c9692e16dc5eb$exports,
  "sr-SP": $d2aa7abea627cafa$exports,
  "sv-SE": $676b82e4b56408e6$exports,
  "tr-TR": $14c9042552d7ce08$exports,
  "uk-UA": $393254ebcb66c9f5$exports,
  "zh-CN": $d49d621f310cf6ce$exports,
  "zh-TW": $94b60c866ca5dfe6$exports
};

// node_modules/@react-aria/spinbutton/dist/useSpinButton.mjs
var import_react95 = __toESM(require_react(), 1);
function $parcel$interopDefault6(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
function $d2e8511e6f209edf$export$e908e06f4b8e3402(props) {
  const _async = (0, import_react95.useRef)(void 0);
  let { value: value2, textValue, minValue, maxValue, isDisabled, isReadOnly, isRequired, onIncrement, onIncrementPage, onDecrement, onDecrementPage, onDecrementToMin, onIncrementToMax } = props;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault6($a99895ee3dc79e61$exports)), "@react-aria/spinbutton");
  const clearAsync = () => clearTimeout(_async.current);
  (0, import_react95.useEffect)(() => {
    return () => clearAsync();
  }, []);
  let onKeyDown = (e4) => {
    if (e4.ctrlKey || e4.metaKey || e4.shiftKey || e4.altKey || isReadOnly) return;
    switch (e4.key) {
      case "PageUp":
        if (onIncrementPage) {
          e4.preventDefault();
          onIncrementPage === null || onIncrementPage === void 0 ? void 0 : onIncrementPage();
          break;
        }
      case "ArrowUp":
      case "Up":
        if (onIncrement) {
          e4.preventDefault();
          onIncrement === null || onIncrement === void 0 ? void 0 : onIncrement();
        }
        break;
      case "PageDown":
        if (onDecrementPage) {
          e4.preventDefault();
          onDecrementPage === null || onDecrementPage === void 0 ? void 0 : onDecrementPage();
          break;
        }
      case "ArrowDown":
      case "Down":
        if (onDecrement) {
          e4.preventDefault();
          onDecrement === null || onDecrement === void 0 ? void 0 : onDecrement();
        }
        break;
      case "Home":
        if (onDecrementToMin) {
          e4.preventDefault();
          onDecrementToMin === null || onDecrementToMin === void 0 ? void 0 : onDecrementToMin();
        }
        break;
      case "End":
        if (onIncrementToMax) {
          e4.preventDefault();
          onIncrementToMax === null || onIncrementToMax === void 0 ? void 0 : onIncrementToMax();
        }
        break;
    }
  };
  let isFocused = (0, import_react95.useRef)(false);
  let onFocus = () => {
    isFocused.current = true;
  };
  let onBlur = () => {
    isFocused.current = false;
  };
  let ariaTextValue = textValue === "" ? stringFormatter.format("Empty") : (textValue || `${value2}`).replace("-", "−");
  (0, import_react95.useEffect)(() => {
    if (isFocused.current) {
      (0, $319e236875307eab$export$d10ae4f68404609a)("assertive");
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(ariaTextValue, "assertive");
    }
  }, [
    ariaTextValue
  ]);
  const onIncrementPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((initialStepDelay) => {
    clearAsync();
    onIncrement === null || onIncrement === void 0 ? void 0 : onIncrement();
    _async.current = window.setTimeout(() => {
      if (maxValue === void 0 || isNaN(maxValue) || value2 === void 0 || isNaN(value2) || value2 < maxValue) onIncrementPressStart(60);
    }, initialStepDelay);
  });
  const onDecrementPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((initialStepDelay) => {
    clearAsync();
    onDecrement === null || onDecrement === void 0 ? void 0 : onDecrement();
    _async.current = window.setTimeout(() => {
      if (minValue === void 0 || isNaN(minValue) || value2 === void 0 || isNaN(value2) || value2 > minValue) onDecrementPressStart(60);
    }, initialStepDelay);
  });
  let cancelContextMenu = (e4) => {
    e4.preventDefault();
  };
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  return {
    spinButtonProps: {
      role: "spinbutton",
      "aria-valuenow": value2 !== void 0 && !isNaN(value2) ? value2 : void 0,
      "aria-valuetext": ariaTextValue,
      "aria-valuemin": minValue,
      "aria-valuemax": maxValue,
      "aria-disabled": isDisabled || void 0,
      "aria-readonly": isReadOnly || void 0,
      "aria-required": isRequired || void 0,
      onKeyDown,
      onFocus,
      onBlur
    },
    incrementButtonProps: {
      onPressStart: () => {
        onIncrementPressStart(400);
        addGlobalListener(window, "contextmenu", cancelContextMenu);
      },
      onPressEnd: () => {
        clearAsync();
        removeAllGlobalListeners();
      },
      onFocus,
      onBlur
    },
    decrementButtonProps: {
      onPressStart: () => {
        onDecrementPressStart(400);
        addGlobalListener(window, "contextmenu", cancelContextMenu);
      },
      onPressEnd: () => {
        clearAsync();
        removeAllGlobalListeners();
      },
      onFocus,
      onBlur
    }
  };
}

// node_modules/@react-aria/numberfield/dist/useNumberField.mjs
function $parcel$interopDefault7(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
function $81397a9303501bda$export$23f548e970bdf099(props, state, inputRef) {
  let { id: id2, decrementAriaLabel, incrementAriaLabel, isDisabled, isReadOnly, isRequired, minValue, maxValue, autoFocus, label, formatOptions, onBlur = () => {
  }, onFocus, onFocusChange, onKeyDown, onKeyUp, description, errorMessage, isWheelDisabled, ...otherProps } = props;
  let { increment, incrementToMax, decrement, decrementToMin, numberValue, inputValue, commit, commitValidation } = state;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault7($280a227d7cb94b92$exports)), "@react-aria/numberfield");
  let inputId = (0, $bdb11010cef70236$export$f680877a34711e37)(id2);
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    onBlur() {
      commit();
    }
  });
  let numberFormatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)(formatOptions);
  let intlOptions = (0, import_react96.useMemo)(() => numberFormatter.resolvedOptions(), [
    numberFormatter
  ]);
  let textValueFormatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)({
    ...formatOptions,
    currencySign: void 0
  });
  let textValue = (0, import_react96.useMemo)(() => isNaN(numberValue) ? "" : textValueFormatter.format(numberValue), [
    textValueFormatter,
    numberValue
  ]);
  let { spinButtonProps, incrementButtonProps: incButtonProps, decrementButtonProps: decButtonProps } = (0, $d2e8511e6f209edf$export$e908e06f4b8e3402)({
    isDisabled,
    isReadOnly,
    isRequired,
    maxValue,
    minValue,
    onIncrement: increment,
    onIncrementToMax: incrementToMax,
    onDecrement: decrement,
    onDecrementToMin: decrementToMin,
    value: numberValue,
    textValue
  });
  let [focusWithin, setFocusWithin] = (0, import_react96.useState)(false);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled,
    onFocusWithinChange: setFocusWithin
  });
  let onWheel = (0, import_react96.useCallback)((e4) => {
    if (Math.abs(e4.deltaY) <= Math.abs(e4.deltaX)) return;
    if (e4.deltaY > 0) increment();
    else if (e4.deltaY < 0) decrement();
  }, [
    decrement,
    increment
  ]);
  let scrollingDisabled = isWheelDisabled || isDisabled || isReadOnly || !focusWithin;
  (0, $7d0a636d7a4dcefd$export$2123ff2b87c81ca)({
    onScroll: onWheel,
    isDisabled: scrollingDisabled
  }, inputRef);
  var _intlOptions_maximumFractionDigits;
  let hasDecimals = ((_intlOptions_maximumFractionDigits = intlOptions.maximumFractionDigits) !== null && _intlOptions_maximumFractionDigits !== void 0 ? _intlOptions_maximumFractionDigits : 0) > 0;
  let hasNegative = state.minValue === void 0 || isNaN(state.minValue) || state.minValue < 0;
  let inputMode = "numeric";
  if ((0, $c87311424ea30a05$export$186c6964ca17d99)()) {
    if (hasNegative) inputMode = "text";
    else if (hasDecimals) inputMode = "decimal";
  } else if ((0, $c87311424ea30a05$export$a11b0059900ceec8)()) {
    if (hasNegative) inputMode = "numeric";
    else if (hasDecimals) inputMode = "decimal";
  }
  let onChange2 = (value2) => {
    if (state.validate(value2)) state.setInputValue(value2);
  };
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props);
  let onKeyDownEnter = (0, import_react96.useCallback)((e4) => {
    if (e4.key === "Enter") {
      commit();
      commitValidation();
    } else e4.continuePropagation();
  }, [
    commit,
    commitValidation
  ]);
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps } = (0, $d841c8010a73d545$export$4f384c9210e583c3)({
    ...otherProps,
    ...domProps,
    name: void 0,
    label,
    autoFocus,
    isDisabled,
    isReadOnly,
    isRequired,
    validate: void 0,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: state,
    value: inputValue,
    defaultValue: void 0,
    autoComplete: "off",
    "aria-label": props["aria-label"] || void 0,
    "aria-labelledby": props["aria-labelledby"] || void 0,
    id: inputId,
    type: "text",
    inputMode,
    onChange: onChange2,
    onBlur,
    onFocus,
    onFocusChange,
    onKeyDown: (0, import_react96.useMemo)(() => (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(onKeyDownEnter, onKeyDown), [
      onKeyDownEnter,
      onKeyDown
    ]),
    onKeyUp,
    description,
    errorMessage
  }, state, inputRef);
  (0, $99facab73266f662$export$5add1d006293d136)(inputRef, state.numberValue, state.setNumberValue);
  let inputProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(spinButtonProps, focusProps, textFieldProps, {
    // override the spinbutton role, we can't focus a spin button with VO
    role: null,
    // ignore aria-roledescription on iOS so that required state will announce when it is present
    "aria-roledescription": !(0, $c87311424ea30a05$export$fedb369cb70207f1)() ? stringFormatter.format("numberField") : null,
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null,
    autoCorrect: "off",
    spellCheck: "false"
  });
  if (props.validationBehavior === "native") inputProps["aria-required"] = void 0;
  let onButtonPressStart = (e4) => {
    var _inputRef_current;
    if (document.activeElement === inputRef.current) return;
    if (e4.pointerType === "mouse") (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
    else e4.target.focus();
  };
  let fieldLabel = props["aria-label"] || (typeof props.label === "string" ? props.label : "");
  let ariaLabelledby;
  if (!fieldLabel) ariaLabelledby = props.label != null ? labelProps.id : props["aria-labelledby"];
  let incrementId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let decrementId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let incrementButtonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(incButtonProps, {
    "aria-label": incrementAriaLabel || stringFormatter.format("increase", {
      fieldLabel
    }).trim(),
    id: ariaLabelledby && !incrementAriaLabel ? incrementId : null,
    "aria-labelledby": ariaLabelledby && !incrementAriaLabel ? `${incrementId} ${ariaLabelledby}` : null,
    "aria-controls": inputId,
    excludeFromTabOrder: true,
    preventFocusOnPress: true,
    allowFocusWhenDisabled: true,
    isDisabled: !state.canIncrement,
    onPressStart: onButtonPressStart
  });
  let decrementButtonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(decButtonProps, {
    "aria-label": decrementAriaLabel || stringFormatter.format("decrease", {
      fieldLabel
    }).trim(),
    id: ariaLabelledby && !decrementAriaLabel ? decrementId : null,
    "aria-labelledby": ariaLabelledby && !decrementAriaLabel ? `${decrementId} ${ariaLabelledby}` : null,
    "aria-controls": inputId,
    excludeFromTabOrder: true,
    preventFocusOnPress: true,
    allowFocusWhenDisabled: true,
    isDisabled: !state.canDecrement,
    onPressStart: onButtonPressStart
  });
  return {
    groupProps: {
      ...focusWithinProps,
      role: "group",
      "aria-disabled": isDisabled,
      "aria-invalid": isInvalid ? "true" : void 0
    },
    labelProps,
    inputProps,
    incrementButtonProps,
    decrementButtonProps,
    errorMessageProps,
    descriptionProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/@react-stately/numberfield/dist/useNumberFieldState.mjs
var import_react97 = __toESM(require_react(), 1);
function $de67e98908f0c6ee$export$7f629e9dc1ecf37c(props) {
  let { minValue, maxValue, step, formatOptions, value: value2, defaultValue = NaN, onChange: onChange2, locale, isDisabled, isReadOnly } = props;
  if (value2 === null) value2 = NaN;
  if (value2 !== void 0 && !isNaN(value2)) {
    if (step !== void 0 && !isNaN(step)) value2 = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(value2, minValue, maxValue, step);
    else value2 = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(value2, minValue, maxValue);
  }
  if (!isNaN(defaultValue)) {
    if (step !== void 0 && !isNaN(step)) defaultValue = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(defaultValue, minValue, maxValue, step);
    else defaultValue = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(defaultValue, minValue, maxValue);
  }
  let [numberValue, setNumberValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(value2, isNaN(defaultValue) ? NaN : defaultValue, onChange2);
  let [inputValue, setInputValue] = (0, import_react97.useState)(() => isNaN(numberValue) ? "" : new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, formatOptions).format(numberValue));
  let numberParser = (0, import_react97.useMemo)(() => new (0, $6c7bd7858deea686$export$cd11ab140839f11d)(locale, formatOptions), [
    locale,
    formatOptions
  ]);
  let numberingSystem = (0, import_react97.useMemo)(() => numberParser.getNumberingSystem(inputValue), [
    numberParser,
    inputValue
  ]);
  let formatter = (0, import_react97.useMemo)(() => new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, {
    ...formatOptions,
    numberingSystem
  }), [
    locale,
    formatOptions,
    numberingSystem
  ]);
  let intlOptions = (0, import_react97.useMemo)(() => formatter.resolvedOptions(), [
    formatter
  ]);
  let format = (0, import_react97.useCallback)((value3) => isNaN(value3) || value3 === null ? "" : formatter.format(value3), [
    formatter
  ]);
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: numberValue
  });
  let clampStep = step !== void 0 && !isNaN(step) ? step : 1;
  if (intlOptions.style === "percent" && (step === void 0 || isNaN(step))) clampStep = 0.01;
  let [prevValue, setPrevValue] = (0, import_react97.useState)(numberValue);
  let [prevLocale, setPrevLocale] = (0, import_react97.useState)(locale);
  let [prevFormatOptions, setPrevFormatOptions] = (0, import_react97.useState)(formatOptions);
  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {
    setInputValue(format(numberValue));
    setPrevValue(numberValue);
    setPrevLocale(locale);
    setPrevFormatOptions(formatOptions);
  }
  let parsedValue = (0, import_react97.useMemo)(() => numberParser.parse(inputValue), [
    numberParser,
    inputValue
  ]);
  let commit = () => {
    if (!inputValue.length) {
      setNumberValue(NaN);
      setInputValue(value2 === void 0 ? "" : format(numberValue));
      return;
    }
    if (isNaN(parsedValue)) {
      setInputValue(format(numberValue));
      return;
    }
    let clampedValue;
    if (step === void 0 || isNaN(step)) clampedValue = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(parsedValue, minValue, maxValue);
    else clampedValue = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, step);
    clampedValue = numberParser.parse(format(clampedValue));
    setNumberValue(clampedValue);
    setInputValue(format(value2 === void 0 ? clampedValue : numberValue));
  };
  let safeNextStep = (operation, minMax = 0) => {
    let prev2 = parsedValue;
    if (isNaN(prev2)) {
      let newValue = isNaN(minMax) ? 0 : minMax;
      return (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(newValue, minValue, maxValue, clampStep);
    } else {
      let newValue = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(prev2, minValue, maxValue, clampStep);
      if (operation === "+" && newValue > prev2 || operation === "-" && newValue < prev2) return newValue;
      return (0, $9446cca9a3875146$export$cb6e0bb50bc19463)($de67e98908f0c6ee$var$handleDecimalOperation(operation, prev2, clampStep), minValue, maxValue, clampStep);
    }
  };
  let increment = () => {
    let newValue = safeNextStep("+", minValue);
    if (newValue === numberValue) setInputValue(format(newValue));
    setNumberValue(newValue);
    validation.commitValidation();
  };
  let decrement = () => {
    let newValue = safeNextStep("-", maxValue);
    if (newValue === numberValue) setInputValue(format(newValue));
    setNumberValue(newValue);
    validation.commitValidation();
  };
  let incrementToMax = () => {
    if (maxValue != null) {
      setNumberValue((0, $9446cca9a3875146$export$cb6e0bb50bc19463)(maxValue, minValue, maxValue, clampStep));
      validation.commitValidation();
    }
  };
  let decrementToMin = () => {
    if (minValue != null) {
      setNumberValue(minValue);
      validation.commitValidation();
    }
  };
  let canIncrement = (0, import_react97.useMemo)(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || maxValue === void 0 || isNaN(maxValue) || (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, clampStep) > parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation("+", parsedValue, clampStep) <= maxValue), [
    isDisabled,
    isReadOnly,
    minValue,
    maxValue,
    clampStep,
    parsedValue
  ]);
  let canDecrement = (0, import_react97.useMemo)(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || minValue === void 0 || isNaN(minValue) || (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, clampStep) < parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation("-", parsedValue, clampStep) >= minValue), [
    isDisabled,
    isReadOnly,
    minValue,
    maxValue,
    clampStep,
    parsedValue
  ]);
  let validate2 = (value3) => numberParser.isValidPartialNumber(value3, minValue, maxValue);
  return {
    ...validation,
    validate: validate2,
    increment,
    incrementToMax,
    decrement,
    decrementToMin,
    canIncrement,
    canDecrement,
    minValue,
    maxValue,
    numberValue: parsedValue,
    setNumberValue,
    setInputValue,
    inputValue,
    commit
  };
}
function $de67e98908f0c6ee$var$handleDecimalOperation(operator, value1, value2) {
  let result = operator === "+" ? value1 + value2 : value1 - value2;
  if (value1 % 1 !== 0 || value2 % 1 !== 0) {
    const value1Decimal = value1.toString().split(".");
    const value2Decimal = value2.toString().split(".");
    const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;
    const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;
    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));
    value1 = Math.round(value1 * multiplier);
    value2 = Math.round(value2 * multiplier);
    result = operator === "+" ? value1 + value2 : value1 - value2;
    result /= multiplier;
  }
  return result;
}

// node_modules/@keystar/ui/dist/keystar-ui-number-field.js
var import_react98 = __toESM(require_react());

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-chevronUpIcon.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var chevronUpIcon = (0, import_jsx_runtime28.jsx)("path", {
  d: "m18 15-6-6-6 6"
});

// node_modules/@keystar/ui/dist/keystar-ui-number-field.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var StepButton = (0, import_react98.forwardRef)(function StepButton2(props, forwardedRef) {
  const $ = c2(23);
  props = useProviderProps(props);
  const {
    scale
  } = useProvider();
  const {
    direction
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let t0;
  if ($[0] !== props) {
    t0 = {
      ...props,
      elementType: "div"
    };
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(t0, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(props);
  const incrementIcon = scale === "large" ? plusIcon : chevronUpIcon;
  const decrementIcon = scale === "large" ? minusIcon : chevronDownIcon;
  const t1 = isHovered || void 0;
  const t22 = isPressed || void 0;
  let t32;
  if ($[2] !== direction || $[3] !== t1 || $[4] !== t22 || $[5] !== scale) {
    t32 = toDataAttributes({
      direction,
      hovered: t1,
      pressed: t22,
      scale
    });
    $[2] = direction;
    $[3] = t1;
    $[4] = t22;
    $[5] = scale;
    $[6] = t32;
  } else {
    t32 = $[6];
  }
  let t4;
  if ($[7] !== hoverProps || $[8] !== buttonProps) {
    t4 = $3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, buttonProps);
    $[7] = hoverProps;
    $[8] = buttonProps;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  let t5;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = classNames(css({
      alignItems: "center",
      color: tokenSchema.color.alias.foregroundIdle,
      cursor: "default",
      display: "flex",
      justifyContent: "center",
      transition: transition("border-color"),
      svg: {
        position: "absolute"
      },
      "&[data-hovered]": {
        backgroundColor: tokenSchema.color.alias.backgroundHovered,
        color: tokenSchema.color.alias.foregroundHovered
      },
      "&[data-pressed]": {
        backgroundColor: tokenSchema.color.alias.backgroundPressed
      },
      "&[aria-disabled=true]": {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        color: tokenSchema.color.alias.foregroundDisabled
      },
      "&[data-direction=up]": {
        gridArea: "increment"
      },
      "&[data-direction=down]": {
        gridArea: "decrement"
      },
      "&:not([data-scale=large])": {
        "&[data-direction=up]": {
          borderStartStartRadius: tokenSchema.size.radius.small,
          borderStartEndRadius: tokenSchema.size.radius.small
        },
        "&[data-direction=down]": {
          borderEndStartRadius: tokenSchema.size.radius.small,
          borderEndEndRadius: tokenSchema.size.radius.small
        },
        svg: {
          width: tokenSchema.size.icon.small
        }
      },
      "&[data-scale=large]": {
        "&[data-direction=up]": {
          borderStartEndRadius: tokenSchema.size.radius.regular,
          borderEndEndRadius: tokenSchema.size.radius.regular
        },
        "&[data-direction=down]": {
          borderEndStartRadius: tokenSchema.size.radius.regular,
          borderStartStartRadius: tokenSchema.size.radius.regular
        },
        "input:enabled ~ &": {
          border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`
        },
        "input:focus ~ &": {
          borderColor: tokenSchema.color.alias.borderFocused
        }
      }
    }));
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== direction || $[12] !== incrementIcon) {
    t6 = direction === "up" && (0, import_jsx_runtime29.jsx)(Icon, {
      src: incrementIcon
    });
    $[11] = direction;
    $[12] = incrementIcon;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  let t7;
  if ($[14] !== direction || $[15] !== decrementIcon) {
    t7 = direction === "down" && (0, import_jsx_runtime29.jsx)(Icon, {
      src: decrementIcon
    });
    $[14] = direction;
    $[15] = decrementIcon;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  let t8;
  if ($[17] !== t32 || $[18] !== t4 || $[19] !== domRef || $[20] !== t6 || $[21] !== t7) {
    t8 = (0, import_jsx_runtime29.jsxs)("div", {
      ...t32,
      ...t4,
      ref: domRef,
      className: t5,
      children: [t6, t7]
    });
    $[17] = t32;
    $[18] = t4;
    $[19] = domRef;
    $[20] = t6;
    $[21] = t7;
    $[22] = t8;
  } else {
    t8 = $[22];
  }
  return t8;
});
var NumberField = (0, import_react98.forwardRef)(function NumberField2(props, forwardedRef) {
  const $ = c2(29);
  props = useProviderProps(props);
  const {
    isReadOnly,
    isDisabled,
    hideStepper,
    label,
    description
  } = props;
  const {
    locale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let t0;
  if ($[0] !== props || $[1] !== locale) {
    t0 = {
      ...props,
      locale
    };
    $[0] = props;
    $[1] = locale;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const state = $de67e98908f0c6ee$export$7f629e9dc1ecf37c(t0);
  const inputRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    groupProps,
    labelProps,
    inputProps,
    incrementButtonProps,
    decrementButtonProps,
    descriptionProps,
    errorMessageProps
  } = $81397a9303501bda$export$23f548e970bdf099(props, state, inputRef);
  const inputWrapperStyleProps = useInputWrapperStyleProps();
  let t1;
  if ($[3] !== props) {
    t1 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props);
    $[3] = props;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t22;
  if ($[5] !== props) {
    t22 = onlyStyleProps(props);
    $[5] = props;
    $[6] = t22;
  } else {
    t22 = $[6];
  }
  let t32;
  if ($[7] !== groupProps || $[8] !== inputWrapperStyleProps) {
    t32 = {
      ...groupProps,
      ...inputWrapperStyleProps
    };
    $[7] = groupProps;
    $[8] = inputWrapperStyleProps;
    $[9] = t32;
  } else {
    t32 = $[9];
  }
  let t4;
  if ($[10] !== hideStepper || $[11] !== incrementButtonProps || $[12] !== decrementButtonProps) {
    t4 = !hideStepper && (0, import_jsx_runtime29.jsxs)(import_jsx_runtime29.Fragment, {
      children: [(0, import_jsx_runtime29.jsx)(StepButton, {
        direction: "up",
        ...incrementButtonProps
      }), (0, import_jsx_runtime29.jsx)(StepButton, {
        direction: "down",
        ...decrementButtonProps
      })]
    });
    $[10] = hideStepper;
    $[11] = incrementButtonProps;
    $[12] = decrementButtonProps;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== t1 || $[15] !== t22 || $[16] !== label || $[17] !== description || $[18] !== props.errorMessage || $[19] !== descriptionProps || $[20] !== errorMessageProps || $[21] !== labelProps || $[22] !== t32 || $[23] !== inputRef || $[24] !== inputProps || $[25] !== isDisabled || $[26] !== isReadOnly || $[27] !== t4) {
    t5 = (0, import_jsx_runtime29.jsx)(TextFieldPrimitive, {
      width: "alias.singleLineWidth",
      ...t1,
      ...t22,
      label,
      description,
      errorMessage: props.errorMessage,
      descriptionProps,
      errorMessageProps,
      labelProps,
      inputWrapperProps: t32,
      ref: inputRef,
      inputProps,
      isDisabled,
      isReadOnly,
      endElement: t4
    });
    $[14] = t1;
    $[15] = t22;
    $[16] = label;
    $[17] = description;
    $[18] = props.errorMessage;
    $[19] = descriptionProps;
    $[20] = errorMessageProps;
    $[21] = labelProps;
    $[22] = t32;
    $[23] = inputRef;
    $[24] = inputProps;
    $[25] = isDisabled;
    $[26] = isReadOnly;
    $[27] = t4;
    $[28] = t5;
  } else {
    t5 = $[28];
  }
  return t5;
});
function useInputWrapperStyleProps() {
  const $ = c2(5);
  const {
    scale
  } = useProvider();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      display: "grid",
      gap: tokenSchema.size.border.regular,
      gridTemplateColumns: `1fr calc(${tokenSchema.size.element.regular} - ${tokenSchema.size.border.regular} * 2) ${tokenSchema.size.border.regular}`,
      gridTemplateRows: `${tokenSchema.size.border.regular} auto auto ${tokenSchema.size.border.regular}`,
      gridTemplateAreas: '"field . ." "field increment ." "field decrement ." "field . ."',
      '&[data-scale="large"]': {
        gridTemplateColumns: `${tokenSchema.size.element.regular} 1fr ${tokenSchema.size.element.regular}`,
        gridTemplateRows: "auto",
        gridTemplateAreas: '"decrement field increment"'
      },
      input: {
        gridArea: "field"
      }
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const className = t0;
  let t1;
  if ($[1] !== scale) {
    t1 = toDataAttributes({
      scale
    });
    $[1] = scale;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t22;
  if ($[3] !== t1) {
    t22 = {
      ...t1,
      className
    };
    $[3] = t1;
    $[4] = t22;
  } else {
    t22 = $[4];
  }
  return t22;
}

// node_modules/@react-stately/toast/dist/useToastState.mjs
var import_react99 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
function $77b352cf12efcf73$export$84726ef35ca2129a(queue) {
  let subscribe5 = (0, import_react99.useCallback)((fn2) => queue.subscribe(fn2), [
    queue
  ]);
  let getSnapshot = (0, import_react99.useCallback)(() => queue.visibleToasts, [
    queue
  ]);
  let visibleToasts = (0, import_shim.useSyncExternalStore)(subscribe5, getSnapshot, getSnapshot);
  return {
    visibleToasts,
    add: (content, options) => queue.add(content, options),
    close: (key) => queue.close(key),
    remove: (key) => queue.remove(key),
    pauseAll: () => queue.pauseAll(),
    resumeAll: () => queue.resumeAll()
  };
}
var $77b352cf12efcf73$export$f1f8569633bbbec4 = class {
  /** Subscribes to updates to the visible toasts. */
  subscribe(fn2) {
    this.subscriptions.add(fn2);
    return () => this.subscriptions.delete(fn2);
  }
  /** Adds a new toast to the queue. */
  add(content, options = {}) {
    let toastKey = Math.random().toString(36);
    let toast = {
      ...options,
      content,
      key: toastKey,
      timer: options.timeout ? new $77b352cf12efcf73$var$Timer(() => this.close(toastKey), options.timeout) : null
    };
    let low = 0;
    let high = this.queue.length;
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if ((toast.priority || 0) > (this.queue[mid].priority || 0)) high = mid;
      else low = mid + 1;
    }
    this.queue.splice(low, 0, toast);
    toast.animation = low < this.maxVisibleToasts ? "entering" : "queued";
    let i4 = this.maxVisibleToasts;
    while (i4 < this.queue.length) this.queue[i4++].animation = "queued";
    this.updateVisibleToasts({
      action: "add"
    });
    return toastKey;
  }
  /**
  * Closes a toast. If `hasExitAnimation` is true, the toast
  * transitions to an "exiting" state instead of being removed immediately.
  */
  close(key) {
    let index2 = this.queue.findIndex((t4) => t4.key === key);
    if (index2 >= 0) {
      var _this_queue_index_onClose, _this_queue_index;
      (_this_queue_index_onClose = (_this_queue_index = this.queue[index2]).onClose) === null || _this_queue_index_onClose === void 0 ? void 0 : _this_queue_index_onClose.call(_this_queue_index);
      this.queue.splice(index2, 1);
    }
    this.updateVisibleToasts({
      action: "close",
      key
    });
  }
  /** Removes a toast from the visible toasts after an exiting animation. */
  remove(key) {
    this.updateVisibleToasts({
      action: "remove",
      key
    });
  }
  updateVisibleToasts(options) {
    let { action, key } = options;
    let toasts = this.queue.slice(0, this.maxVisibleToasts);
    if (action === "add" && this.hasExitAnimation) {
      let prevToasts = this.visibleToasts.filter((t4) => !toasts.some((t22) => t4.key === t22.key)).map((t4) => ({
        ...t4,
        animation: "exiting"
      }));
      this.visibleToasts = prevToasts.concat(toasts).sort((a3, b2) => b2.priority - a3.priority);
    } else if (action === "close" && this.hasExitAnimation)
      this.visibleToasts = this.visibleToasts.map((t4) => {
        if (t4.key !== key) return t4;
        else return {
          ...t4,
          animation: "exiting"
        };
      });
    else this.visibleToasts = toasts;
    for (let fn2 of this.subscriptions) fn2();
  }
  /** Pauses the timers for all visible toasts. */
  pauseAll() {
    for (let toast of this.visibleToasts) if (toast.timer) toast.timer.pause();
  }
  /** Resumes the timers for all visible toasts. */
  resumeAll() {
    for (let toast of this.visibleToasts) if (toast.timer) toast.timer.resume();
  }
  constructor(options) {
    this.queue = [];
    this.subscriptions = /* @__PURE__ */ new Set();
    this.visibleToasts = [];
    var _options_maxVisibleToasts;
    this.maxVisibleToasts = (_options_maxVisibleToasts = options === null || options === void 0 ? void 0 : options.maxVisibleToasts) !== null && _options_maxVisibleToasts !== void 0 ? _options_maxVisibleToasts : 1;
    var _options_hasExitAnimation;
    this.hasExitAnimation = (_options_hasExitAnimation = options === null || options === void 0 ? void 0 : options.hasExitAnimation) !== null && _options_hasExitAnimation !== void 0 ? _options_hasExitAnimation : false;
  }
};
var $77b352cf12efcf73$var$Timer = class {
  reset(delay) {
    this.remaining = delay;
    this.resume();
  }
  pause() {
    if (this.timerId == null) return;
    clearTimeout(this.timerId);
    this.timerId = null;
    this.remaining -= Date.now() - this.startTime;
  }
  resume() {
    if (this.remaining <= 0) return;
    this.startTime = Date.now();
    this.timerId = setTimeout(() => {
      this.timerId = null;
      this.remaining = 0;
      this.callback();
    }, this.remaining);
  }
  constructor(callback, delay) {
    this.remaining = delay;
    this.callback = callback;
  }
};

// node_modules/@keystar/ui/dist/keystar-ui-toast.js
var import_react103 = __toESM(require_react());

// node_modules/@react-aria/toast/dist/ar-AE.mjs
var $ff9177efc58547ad$exports = {};
$ff9177efc58547ad$exports = {
  "close": `إغلاق`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} إشعار`,
    other: () => `${formatter.number(args2.count)} إشعارات`
  })}.`
};

// node_modules/@react-aria/toast/dist/bg-BG.mjs
var $25eb7c0c0c45e544$exports = {};
$25eb7c0c0c45e544$exports = {
  "close": `Затвори`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} известие`,
    other: () => `${formatter.number(args2.count)} известия`
  })}.`
};

// node_modules/@react-aria/toast/dist/cs-CZ.mjs
var $28feffc3d61a8691$exports = {};
$28feffc3d61a8691$exports = {
  "close": `Zavřít`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} oznámení`,
    other: () => `${formatter.number(args2.count)} oznámení`
  })}.`
};

// node_modules/@react-aria/toast/dist/da-DK.mjs
var $390d441203d25ff4$exports = {};
$390d441203d25ff4$exports = {
  "close": `Luk`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} besked`,
    other: () => `${formatter.number(args2.count)} beskeder`
  })}.`
};

// node_modules/@react-aria/toast/dist/de-DE.mjs
var $7063c2d0f14f979a$exports = {};
$7063c2d0f14f979a$exports = {
  "close": `Schließen`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} Benachrichtigung`,
    other: () => `${formatter.number(args2.count)} Benachrichtigungen`
  })}.`
};

// node_modules/@react-aria/toast/dist/el-GR.mjs
var $2dfc1dbb6590af88$exports = {};
$2dfc1dbb6590af88$exports = {
  "close": `Κλείσιμο`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ειδοποίηση`,
    other: () => `${formatter.number(args2.count)} ειδοποιήσεις`
  })}.`
};

// node_modules/@react-aria/toast/dist/en-US.mjs
var $9a12ff1caae5a7a5$exports = {};
$9a12ff1caae5a7a5$exports = {
  "close": `Close`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} notification`,
    other: () => `${formatter.number(args2.count)} notifications`
  })}.`
};

// node_modules/@react-aria/toast/dist/es-ES.mjs
var $f4095fb5a72adbe6$exports = {};
$f4095fb5a72adbe6$exports = {
  "close": `Cerrar`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} notificación`,
    other: () => `${formatter.number(args2.count)} notificaciones`
  })}.`
};

// node_modules/@react-aria/toast/dist/et-EE.mjs
var $75bc5191b9d7826a$exports = {};
$75bc5191b9d7826a$exports = {
  "close": `Sule`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} teatis`,
    other: () => `${formatter.number(args2.count)} teatist`
  })}.`
};

// node_modules/@react-aria/toast/dist/fi-FI.mjs
var $e4b9aef18b0db8dc$exports = {};
$e4b9aef18b0db8dc$exports = {
  "close": `Sulje`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} ilmoitus`,
    other: () => `${formatter.number(args2.count)} ilmoitusta`
  })}.`
};

// node_modules/@react-aria/toast/dist/fr-FR.mjs
var $888756784d832bd7$exports = {};
$888756784d832bd7$exports = {
  "close": `Fermer`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} notification`,
    other: () => `${formatter.number(args2.count)} notifications`
  })}.`
};

// node_modules/@react-aria/toast/dist/he-IL.mjs
var $6835949b68a1fabf$exports = {};
$6835949b68a1fabf$exports = {
  "close": `סגור`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} התראה`,
    other: () => `${formatter.number(args2.count)} התראות`
  })}.`
};

// node_modules/@react-aria/toast/dist/hr-HR.mjs
var $87ffcbc0b651e40b$exports = {};
$87ffcbc0b651e40b$exports = {
  "close": `Zatvori`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} obavijest`,
    other: () => `${formatter.number(args2.count)} obavijesti`
  })}.`
};

// node_modules/@react-aria/toast/dist/hu-HU.mjs
var $dc6e3b2813600d69$exports = {};
$dc6e3b2813600d69$exports = {
  "close": `Bezárás`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} értesítés`,
    other: () => `${formatter.number(args2.count)} értesítés`
  })}.`
};

// node_modules/@react-aria/toast/dist/it-IT.mjs
var $fe136bcbacfcfa14$exports = {};
$fe136bcbacfcfa14$exports = {
  "close": `Chiudi`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} notifica`,
    other: () => `${formatter.number(args2.count)} notifiche`
  })}.`
};

// node_modules/@react-aria/toast/dist/ja-JP.mjs
var $8fb53a929b46df83$exports = {};
$8fb53a929b46df83$exports = {
  "close": `閉じる`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個の通知`,
    other: () => `${formatter.number(args2.count)} 個の通知`
  })}。`
};

// node_modules/@react-aria/toast/dist/ko-KR.mjs
var $2c38dbfaf041a865$exports = {};
$2c38dbfaf041a865$exports = {
  "close": `닫기`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)}개 알림`,
    other: () => `${formatter.number(args2.count)}개 알림`
  })}.`
};

// node_modules/@react-aria/toast/dist/lt-LT.mjs
var $48f3f33a29908d4c$exports = {};
$48f3f33a29908d4c$exports = {
  "close": `Uždaryti`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} pranešimas`,
    other: () => `${formatter.number(args2.count)} pranešimai`
  })}.`
};

// node_modules/@react-aria/toast/dist/lv-LV.mjs
var $9867160d996455a0$exports = {};
$9867160d996455a0$exports = {
  "close": `Aizvērt`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} paziņojums`,
    other: () => `${formatter.number(args2.count)} paziņojumi`
  })}.`
};

// node_modules/@react-aria/toast/dist/nb-NO.mjs
var $196258ea25c96487$exports = {};
$196258ea25c96487$exports = {
  "close": `Lukk`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} varsling`,
    other: () => `${formatter.number(args2.count)} varsler`
  })}.`
};

// node_modules/@react-aria/toast/dist/nl-NL.mjs
var $949061cb954e8000$exports = {};
$949061cb954e8000$exports = {
  "close": `Sluiten`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} melding`,
    other: () => `${formatter.number(args2.count)} meldingen`
  })}.`
};

// node_modules/@react-aria/toast/dist/pl-PL.mjs
var $8189bed27add1ad3$exports = {};
$8189bed27add1ad3$exports = {
  "close": `Zamknij`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} powiadomienie`,
    few: () => `${formatter.number(args2.count)} powiadomienia`,
    many: () => `${formatter.number(args2.count)} powiadomień`,
    other: () => `${formatter.number(args2.count)} powiadomienia`
  })}.`
};

// node_modules/@react-aria/toast/dist/pt-BR.mjs
var $a361756a93b6e28c$exports = {};
$a361756a93b6e28c$exports = {
  "close": `Fechar`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} notificação`,
    other: () => `${formatter.number(args2.count)} notificações`
  })}.`
};

// node_modules/@react-aria/toast/dist/pt-PT.mjs
var $034c7393857c8db0$exports = {};
$034c7393857c8db0$exports = {
  "close": `Fechar`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} notificação`,
    other: () => `${formatter.number(args2.count)} notificações`
  })}.`
};

// node_modules/@react-aria/toast/dist/ro-RO.mjs
var $e33d3b3868478b04$exports = {};
$e33d3b3868478b04$exports = {
  "close": `Închideţi`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} notificare`,
    other: () => `${formatter.number(args2.count)} notificări`
  })}.`
};

// node_modules/@react-aria/toast/dist/ru-RU.mjs
var $9a7dcb914b29cd9f$exports = {};
$9a7dcb914b29cd9f$exports = {
  "close": `Закрыть`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} уведомление`,
    other: () => `${formatter.number(args2.count)} уведомления`
  })}.`
};

// node_modules/@react-aria/toast/dist/sk-SK.mjs
var $e43d964a0c7f1266$exports = {};
$e43d964a0c7f1266$exports = {
  "close": `Zatvoriť`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} oznámenie`,
    few: () => `${formatter.number(args2.count)} oznámenia`,
    other: () => `${formatter.number(args2.count)} oznámení`
  })}.`
};

// node_modules/@react-aria/toast/dist/sl-SI.mjs
var $0bc56cee3275bcaa$exports = {};
$0bc56cee3275bcaa$exports = {
  "close": `Zapri`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} obvestilo`,
    two: () => `${formatter.number(args2.count)} obvestili`,
    few: () => `${formatter.number(args2.count)} obvestila`,
    other: () => `${formatter.number(args2.count)} obvestil`
  })}.`
};

// node_modules/@react-aria/toast/dist/sr-SP.mjs
var $7dbdd7289c10d2ba$exports = {};
$7dbdd7289c10d2ba$exports = {
  "close": `Zatvori`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} obaveštenje`,
    other: () => `${formatter.number(args2.count)} obaveštenja`
  })}.`
};

// node_modules/@react-aria/toast/dist/sv-SE.mjs
var $ccbe6066c10b1e53$exports = {};
$ccbe6066c10b1e53$exports = {
  "close": `Stäng`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} meddelande`,
    other: () => `${formatter.number(args2.count)} meddelanden`
  })}.`
};

// node_modules/@react-aria/toast/dist/tr-TR.mjs
var $9d503476b9d858b7$exports = {};
$9d503476b9d858b7$exports = {
  "close": `Kapat`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} bildirim`,
    other: () => `${formatter.number(args2.count)} bildirim`
  })}.`
};

// node_modules/@react-aria/toast/dist/uk-UA.mjs
var $32ee419c7b9b7a83$exports = {};
$32ee419c7b9b7a83$exports = {
  "close": `Закрити`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} сповіщення`,
    other: () => `${formatter.number(args2.count)} сповіщення`
  })}.`
};

// node_modules/@react-aria/toast/dist/zh-CN.mjs
var $122525af1cb737c7$exports = {};
$122525af1cb737c7$exports = {
  "close": `关闭`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 个通知`,
    other: () => `${formatter.number(args2.count)} 个通知`
  })}。`
};

// node_modules/@react-aria/toast/dist/zh-TW.mjs
var $52e8b1b00094e5a3$exports = {};
$52e8b1b00094e5a3$exports = {
  "close": `關閉`,
  "notifications": (args2, formatter) => `${formatter.plural(args2.count, {
    one: () => `${formatter.number(args2.count)} 個通知`,
    other: () => `${formatter.number(args2.count)} 個通知`
  })}。`
};

// node_modules/@react-aria/toast/dist/intlStrings.mjs
var $7853651519a70071$exports = {};
$7853651519a70071$exports = {
  "ar-AE": $ff9177efc58547ad$exports,
  "bg-BG": $25eb7c0c0c45e544$exports,
  "cs-CZ": $28feffc3d61a8691$exports,
  "da-DK": $390d441203d25ff4$exports,
  "de-DE": $7063c2d0f14f979a$exports,
  "el-GR": $2dfc1dbb6590af88$exports,
  "en-US": $9a12ff1caae5a7a5$exports,
  "es-ES": $f4095fb5a72adbe6$exports,
  "et-EE": $75bc5191b9d7826a$exports,
  "fi-FI": $e4b9aef18b0db8dc$exports,
  "fr-FR": $888756784d832bd7$exports,
  "he-IL": $6835949b68a1fabf$exports,
  "hr-HR": $87ffcbc0b651e40b$exports,
  "hu-HU": $dc6e3b2813600d69$exports,
  "it-IT": $fe136bcbacfcfa14$exports,
  "ja-JP": $8fb53a929b46df83$exports,
  "ko-KR": $2c38dbfaf041a865$exports,
  "lt-LT": $48f3f33a29908d4c$exports,
  "lv-LV": $9867160d996455a0$exports,
  "nb-NO": $196258ea25c96487$exports,
  "nl-NL": $949061cb954e8000$exports,
  "pl-PL": $8189bed27add1ad3$exports,
  "pt-BR": $a361756a93b6e28c$exports,
  "pt-PT": $034c7393857c8db0$exports,
  "ro-RO": $e33d3b3868478b04$exports,
  "ru-RU": $9a7dcb914b29cd9f$exports,
  "sk-SK": $e43d964a0c7f1266$exports,
  "sl-SI": $0bc56cee3275bcaa$exports,
  "sr-SP": $7dbdd7289c10d2ba$exports,
  "sv-SE": $ccbe6066c10b1e53$exports,
  "tr-TR": $9d503476b9d858b7$exports,
  "uk-UA": $32ee419c7b9b7a83$exports,
  "zh-CN": $122525af1cb737c7$exports,
  "zh-TW": $52e8b1b00094e5a3$exports
};

// node_modules/@react-aria/toast/dist/useToast.mjs
var import_react100 = __toESM(require_react(), 1);
function $parcel$interopDefault8(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
function $d6542812f0669241$export$a407b657d3044108(props, state, ref) {
  let { key, timer, timeout: timeout2, animation } = props.toast;
  (0, import_react100.useEffect)(() => {
    if (!timer) return;
    timer.reset(timeout2);
    return () => {
      timer.pause();
    };
  }, [
    timer,
    timeout2
  ]);
  let [isEntered, setIsEntered] = (0, import_react100.default).useState(false);
  (0, import_react100.useEffect)(() => {
    if (animation === "entering" || animation === "queued") setIsEntered(true);
  }, [
    animation
  ]);
  let titleId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault8($7853651519a70071$exports)), "@react-aria/toast");
  return {
    toastProps: {
      role: "alertdialog",
      "aria-modal": "false",
      "aria-label": props["aria-label"],
      "aria-labelledby": props["aria-labelledby"] || titleId,
      "aria-describedby": props["aria-describedby"] || descriptionId,
      "aria-details": props["aria-details"],
      // Hide toasts that are animating out so VoiceOver doesn't announce them.
      "aria-hidden": animation === "exiting" ? "true" : void 0,
      tabIndex: 0
    },
    contentProps: {
      role: "alert",
      "aria-atomic": "true",
      style: {
        visibility: isEntered || animation === null ? "visible" : "hidden"
      }
    },
    titleProps: {
      id: titleId
    },
    descriptionProps: {
      id: descriptionId
    },
    closeButtonProps: {
      "aria-label": stringFormatter.format("close"),
      onPress: () => state.close(key)
    }
  };
}

// node_modules/@react-aria/toast/dist/useToastRegion.mjs
var import_react102 = __toESM(require_react(), 1);

// node_modules/@react-aria/landmark/dist/useLandmark.mjs
var import_react101 = __toESM(require_react(), 1);
var import_shim2 = __toESM(require_shim(), 1);
var $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION = 1;
var $a86207c5d7f7e1fb$var$landmarkSymbol = Symbol.for("react-aria-landmark-manager");
function $a86207c5d7f7e1fb$var$subscribe(fn2) {
  document.addEventListener("react-aria-landmark-manager-change", fn2);
  return () => document.removeEventListener("react-aria-landmark-manager-change", fn2);
}
function $a86207c5d7f7e1fb$var$getLandmarkManager() {
  if (typeof document === "undefined") return null;
  let instance = document[$a86207c5d7f7e1fb$var$landmarkSymbol];
  if (instance && instance.version >= $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION) return instance;
  document[$a86207c5d7f7e1fb$var$landmarkSymbol] = new $a86207c5d7f7e1fb$var$LandmarkManager();
  document.dispatchEvent(new CustomEvent("react-aria-landmark-manager-change"));
  return document[$a86207c5d7f7e1fb$var$landmarkSymbol];
}
function $a86207c5d7f7e1fb$var$useLandmarkManager() {
  return (0, import_shim2.useSyncExternalStore)($a86207c5d7f7e1fb$var$subscribe, $a86207c5d7f7e1fb$var$getLandmarkManager, $a86207c5d7f7e1fb$var$getLandmarkManager);
}
var $a86207c5d7f7e1fb$var$LandmarkManager = class {
  setupIfNeeded() {
    if (this.isListening) return;
    document.addEventListener("keydown", this.f6Handler, {
      capture: true
    });
    document.addEventListener("focusin", this.focusinHandler, {
      capture: true
    });
    document.addEventListener("focusout", this.focusoutHandler, {
      capture: true
    });
    this.isListening = true;
  }
  teardownIfNeeded() {
    if (!this.isListening || this.landmarks.length > 0 || this.refCount > 0) return;
    document.removeEventListener("keydown", this.f6Handler, {
      capture: true
    });
    document.removeEventListener("focusin", this.focusinHandler, {
      capture: true
    });
    document.removeEventListener("focusout", this.focusoutHandler, {
      capture: true
    });
    this.isListening = false;
  }
  focusLandmark(landmark, direction) {
    var _this_landmarks_find_focus, _this_landmarks_find;
    (_this_landmarks_find = this.landmarks.find((l6) => l6.ref.current === landmark)) === null || _this_landmarks_find === void 0 ? void 0 : (_this_landmarks_find_focus = _this_landmarks_find.focus) === null || _this_landmarks_find_focus === void 0 ? void 0 : _this_landmarks_find_focus.call(_this_landmarks_find, direction);
  }
  /**
  * Return set of landmarks with a specific role.
  */
  getLandmarksByRole(role) {
    return new Set(this.landmarks.filter((l6) => l6.role === role));
  }
  /**
  * Return first landmark with a specific role.
  */
  getLandmarkByRole(role) {
    return this.landmarks.find((l6) => l6.role === role);
  }
  addLandmark(newLandmark) {
    this.setupIfNeeded();
    if (this.landmarks.find((landmark) => landmark.ref === newLandmark.ref) || !newLandmark.ref.current) return;
    if (this.landmarks.filter((landmark) => landmark.role === "main").length > 1) console.error('Page can contain no more than one landmark with the role "main".');
    if (this.landmarks.length === 0) {
      this.landmarks = [
        newLandmark
      ];
      this.checkLabels(newLandmark.role);
      return;
    }
    let start2 = 0;
    let end = this.landmarks.length - 1;
    while (start2 <= end) {
      let mid = Math.floor((start2 + end) / 2);
      let comparedPosition = newLandmark.ref.current.compareDocumentPosition(this.landmarks[mid].ref.current);
      let isNewAfterExisting = Boolean(comparedPosition & Node.DOCUMENT_POSITION_PRECEDING || comparedPosition & Node.DOCUMENT_POSITION_CONTAINS);
      if (isNewAfterExisting) start2 = mid + 1;
      else end = mid - 1;
    }
    this.landmarks.splice(start2, 0, newLandmark);
    this.checkLabels(newLandmark.role);
  }
  updateLandmark(landmark) {
    let index2 = this.landmarks.findIndex((l6) => l6.ref === landmark.ref);
    if (index2 >= 0) {
      this.landmarks[index2] = {
        ...this.landmarks[index2],
        ...landmark
      };
      this.checkLabels(this.landmarks[index2].role);
    }
  }
  removeLandmark(ref) {
    this.landmarks = this.landmarks.filter((landmark) => landmark.ref !== ref);
    this.teardownIfNeeded();
  }
  /**
  * Warn if there are 2+ landmarks with the same role but no label.
  * Labels for landmarks with the same role must also be unique.
  *
  * See https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/.
  */
  checkLabels(role) {
    let landmarksWithRole = this.getLandmarksByRole(role);
    if (landmarksWithRole.size > 1) {
      let duplicatesWithoutLabel = [
        ...landmarksWithRole
      ].filter((landmark) => !landmark.label);
      if (duplicatesWithoutLabel.length > 0) console.warn(`Page contains more than one landmark with the '${role}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `, duplicatesWithoutLabel.map((landmark) => landmark.ref.current));
      else {
        let labels = [
          ...landmarksWithRole
        ].map((landmark) => landmark.label);
        let duplicateLabels = labels.filter((item, index2) => labels.indexOf(item) !== index2);
        duplicateLabels.forEach((label) => {
          console.warn(`Page contains more than one landmark with the '${role}' role and '${label}' label. If two or more landmarks on a page share the same role, they must have unique labels: `, [
            ...landmarksWithRole
          ].filter((landmark) => landmark.label === label).map((landmark) => landmark.ref.current));
        });
      }
    }
  }
  /**
  * Get the landmark that is the closest parent in the DOM.
  * Returns undefined if no parent is a landmark.
  */
  closestLandmark(element2) {
    let landmarkMap = new Map(this.landmarks.map((l6) => [
      l6.ref.current,
      l6
    ]));
    let currentElement = element2;
    while (currentElement && !landmarkMap.has(currentElement) && currentElement !== document.body && currentElement.parentElement) currentElement = currentElement.parentElement;
    return landmarkMap.get(currentElement);
  }
  /**
  * Gets the next landmark, in DOM focus order, or previous if backwards is specified.
  * If last landmark, next should be the first landmark.
  * If not inside a landmark, will return first landmark.
  * Returns undefined if there are no landmarks.
  */
  getNextLandmark(element2, { backward }) {
    var _this_landmarks_nextLandmarkIndex_ref_current;
    let currentLandmark = this.closestLandmark(element2);
    let nextLandmarkIndex = backward ? this.landmarks.length - 1 : 0;
    if (currentLandmark) nextLandmarkIndex = this.landmarks.indexOf(currentLandmark) + (backward ? -1 : 1);
    let wrapIfNeeded = () => {
      if (nextLandmarkIndex < 0) {
        if (!element2.dispatchEvent(new CustomEvent("react-aria-landmark-navigation", {
          detail: {
            direction: "backward"
          },
          bubbles: true,
          cancelable: true
        }))) return true;
        nextLandmarkIndex = this.landmarks.length - 1;
      } else if (nextLandmarkIndex >= this.landmarks.length) {
        if (!element2.dispatchEvent(new CustomEvent("react-aria-landmark-navigation", {
          detail: {
            direction: "forward"
          },
          bubbles: true,
          cancelable: true
        }))) return true;
        nextLandmarkIndex = 0;
      }
      if (nextLandmarkIndex < 0 || nextLandmarkIndex >= this.landmarks.length) return true;
      return false;
    };
    if (wrapIfNeeded()) return void 0;
    let i4 = nextLandmarkIndex;
    while ((_this_landmarks_nextLandmarkIndex_ref_current = this.landmarks[nextLandmarkIndex].ref.current) === null || _this_landmarks_nextLandmarkIndex_ref_current === void 0 ? void 0 : _this_landmarks_nextLandmarkIndex_ref_current.closest("[aria-hidden=true]")) {
      nextLandmarkIndex += backward ? -1 : 1;
      if (wrapIfNeeded()) return void 0;
      if (nextLandmarkIndex === i4) break;
    }
    return this.landmarks[nextLandmarkIndex];
  }
  /**
  * Look at next landmark. If an element was previously focused inside, restore focus there.
  * If not, focus the landmark itself.
  * If no landmarks at all, or none with focusable elements, don't move focus.
  */
  f6Handler(e4) {
    if (e4.key === "F6") {
      let handled = e4.altKey ? this.focusMain() : this.navigate(e4.target, e4.shiftKey);
      if (handled) {
        e4.preventDefault();
        e4.stopPropagation();
      }
    }
  }
  focusMain() {
    let main = this.getLandmarkByRole("main");
    if (main && main.ref.current && document.contains(main.ref.current)) {
      this.focusLandmark(main.ref.current, "forward");
      return true;
    }
    return false;
  }
  navigate(from4, backward) {
    let nextLandmark = this.getNextLandmark(from4, {
      backward
    });
    if (!nextLandmark) return false;
    if (nextLandmark.lastFocused) {
      let lastFocused = nextLandmark.lastFocused;
      if (document.body.contains(lastFocused)) {
        lastFocused.focus();
        return true;
      }
    }
    if (nextLandmark.ref.current && document.contains(nextLandmark.ref.current)) {
      this.focusLandmark(nextLandmark.ref.current, backward ? "backward" : "forward");
      return true;
    }
    return false;
  }
  /**
  * Sets lastFocused for a landmark, if focus is moved within that landmark.
  * Lets the last focused landmark know it was blurred if something else is focused.
  */
  focusinHandler(e4) {
    let currentLandmark = this.closestLandmark(e4.target);
    if (currentLandmark && currentLandmark.ref.current !== e4.target) this.updateLandmark({
      ref: currentLandmark.ref,
      lastFocused: e4.target
    });
    let previousFocusedElement = e4.relatedTarget;
    if (previousFocusedElement) {
      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);
      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();
    }
  }
  /**
  * Track if the focus is lost to the body. If it is, do cleanup on the landmark that last had focus.
  */
  focusoutHandler(e4) {
    let previousFocusedElement = e4.target;
    let nextFocusedElement = e4.relatedTarget;
    if (!nextFocusedElement || nextFocusedElement === document) {
      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);
      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();
    }
  }
  createLandmarkController() {
    let instance = this;
    instance.refCount++;
    instance.setupIfNeeded();
    return {
      navigate(direction, opts) {
        let element2 = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element2, direction === "backward");
      },
      focusNext(opts) {
        let element2 = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element2, false);
      },
      focusPrevious(opts) {
        let element2 = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element2, true);
      },
      focusMain() {
        return instance.focusMain();
      },
      dispose() {
        if (instance) {
          instance.refCount--;
          instance.teardownIfNeeded();
          instance = null;
        }
      }
    };
  }
  registerLandmark(landmark) {
    if (this.landmarks.find((l6) => l6.ref === landmark.ref)) this.updateLandmark(landmark);
    else this.addLandmark(landmark);
    return () => this.removeLandmark(landmark.ref);
  }
  constructor() {
    this.landmarks = [];
    this.isListening = false;
    this.refCount = 0;
    this.version = $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION;
    this.f6Handler = this.f6Handler.bind(this);
    this.focusinHandler = this.focusinHandler.bind(this);
    this.focusoutHandler = this.focusoutHandler.bind(this);
  }
};
function $a86207c5d7f7e1fb$export$4cc632584fd87fae(props, ref) {
  const { role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, focus } = props;
  let manager = $a86207c5d7f7e1fb$var$useLandmarkManager();
  let label = ariaLabel || ariaLabelledby;
  let [isLandmarkFocused, setIsLandmarkFocused] = (0, import_react101.useState)(false);
  let defaultFocus = (0, import_react101.useCallback)(() => {
    setIsLandmarkFocused(true);
  }, [
    setIsLandmarkFocused
  ]);
  let blur = (0, import_react101.useCallback)(() => {
    setIsLandmarkFocused(false);
  }, [
    setIsLandmarkFocused
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (manager) return manager.registerLandmark({
      ref,
      label,
      role,
      focus: focus || defaultFocus,
      blur
    });
  }, [
    manager,
    label,
    ref,
    role,
    focus,
    defaultFocus,
    blur
  ]);
  (0, import_react101.useEffect)(() => {
    var _ref_current;
    if (isLandmarkFocused) (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
  }, [
    isLandmarkFocused,
    ref
  ]);
  return {
    landmarkProps: {
      role,
      tabIndex: isLandmarkFocused ? -1 : void 0,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby
    }
  };
}

// node_modules/@react-aria/toast/dist/useToastRegion.mjs
function $parcel$interopDefault9(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
function $6cc546b19ee7130a$export$b8cbbb20a51697de(props, state, ref) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault9($7853651519a70071$exports)), "@react-aria/toast");
  let { landmarkProps } = (0, $a86207c5d7f7e1fb$export$4cc632584fd87fae)({
    role: "region",
    "aria-label": props["aria-label"] || stringFormatter.format("notifications", {
      count: state.visibleToasts.length
    })
  }, ref);
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    onHoverStart: state.pauseAll,
    onHoverEnd: state.resumeAll
  });
  let toasts = (0, import_react102.useRef)([]);
  let prevVisibleToasts = (0, import_react102.useRef)(state.visibleToasts);
  let focusedToast = (0, import_react102.useRef)(null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (focusedToast.current === -1 || state.visibleToasts.length === 0) {
      toasts.current = [];
      prevVisibleToasts.current = state.visibleToasts;
      return;
    }
    toasts.current = [
      ...ref.current.querySelectorAll('[role="alertdialog"]')
    ];
    if (prevVisibleToasts.current.length === state.visibleToasts.length && state.visibleToasts.every((t4, i4) => t4.key === prevVisibleToasts.current[i4].key)) {
      prevVisibleToasts.current = state.visibleToasts;
      return;
    }
    let allToasts = prevVisibleToasts.current.map((t4, i4) => ({
      ...t4,
      i: i4,
      isRemoved: !state.visibleToasts.some((t22) => t4.key === t22.key)
    }));
    let removedFocusedToastIndex = allToasts.findIndex((t4) => t4.i === focusedToast.current);
    if (removedFocusedToastIndex > -1) {
      let i4 = 0;
      let nextToast;
      let prevToast;
      while (i4 <= removedFocusedToastIndex) {
        if (!allToasts[i4].isRemoved) prevToast = Math.max(0, i4 - 1);
        i4++;
      }
      while (i4 < allToasts.length) {
        if (!allToasts[i4].isRemoved) {
          nextToast = i4 - 1;
          break;
        }
        i4++;
      }
      if (prevToast === void 0 && nextToast === void 0) prevToast = 0;
      if (prevToast >= 0 && prevToast < toasts.current.length) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(toasts.current[prevToast]);
      else if (nextToast >= 0 && nextToast < toasts.current.length) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(toasts.current[nextToast]);
    }
    prevVisibleToasts.current = state.visibleToasts;
  }, [
    state.visibleToasts,
    ref
  ]);
  let lastFocused = (0, import_react102.useRef)(null);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onFocusWithin: (e4) => {
      state.pauseAll();
      lastFocused.current = e4.relatedTarget;
    },
    onBlurWithin: () => {
      state.resumeAll();
      lastFocused.current = null;
    }
  });
  (0, import_react102.useEffect)(() => {
    if (state.visibleToasts.length === 0 && lastFocused.current && document.body.contains(lastFocused.current)) {
      if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "pointer") (0, $7215afc6de606d6b$export$de79e2c695e052f3)(lastFocused.current);
      else lastFocused.current.focus();
      lastFocused.current = null;
    }
  }, [
    ref,
    state.visibleToasts.length
  ]);
  (0, import_react102.useEffect)(() => {
    return () => {
      if (lastFocused.current && document.body.contains(lastFocused.current)) {
        if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "pointer") (0, $7215afc6de606d6b$export$de79e2c695e052f3)(lastFocused.current);
        else lastFocused.current.focus();
        lastFocused.current = null;
      }
    };
  }, [
    ref
  ]);
  return {
    regionProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(landmarkProps, hoverProps, focusWithinProps, {
      tabIndex: -1,
      // Mark the toast region as a "top layer", so that it:
      //   - is not aria-hidden when opening an overlay
      //   - allows focus even outside a containing focus scope
      //   - doesn’t dismiss overlays when clicking on it, even though it is outside
      // @ts-ignore
      "data-react-aria-top-layer": true,
      // listen to focus events separate from focuswithin because that will only fire once
      // and we need to follow all focus changes
      onFocus: (e4) => {
        let target = e4.target.closest('[role="alertdialog"]');
        focusedToast.current = toasts.current.findIndex((t4) => t4 === target);
      },
      onBlur: () => {
        focusedToast.current = -1;
      }
    })
  };
}

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-checkCircle2Icon.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var checkCircle2Icon = (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
  children: [(0, import_jsx_runtime30.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 10
  }), (0, import_jsx_runtime30.jsx)("path", {
    d: "m9 12 2 2 4-4"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-icon-icons-infoIcon.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var infoIcon = (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, {
  children: [(0, import_jsx_runtime31.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 10
  }), (0, import_jsx_runtime31.jsx)("path", {
    d: "M12 16v-4M12 8h.01"
  })]
});

// node_modules/@keystar/ui/dist/keystar-ui-toast.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var import_react_dom5 = __toESM(require_react_dom());
var localizedMessages5 = {
  "ar-AE": {
    "info": `معلومات`,
    "critical": `خطأ`,
    "positive": `تم بنجاح`
  },
  "bg-BG": {
    "info": `Инфо`,
    "critical": `Грешка`,
    "positive": `Успех`
  },
  "cs-CZ": {
    "info": `Informace`,
    "critical": `Chyba`,
    "positive": `Úspěch`
  },
  "da-DK": {
    "info": `Info`,
    "critical": `Fejl`,
    "positive": `Fuldført`
  },
  "de-DE": {
    "info": `Informationen`,
    "critical": `Fehler`,
    "positive": `Erfolg`
  },
  "el-GR": {
    "info": `Πληροφορίες`,
    "critical": `Σφάλμα`,
    "positive": `Επιτυχία`
  },
  "en-US": {
    "info": `Info`,
    "critical": `Error`,
    "positive": `Success`
  },
  "es-ES": {
    "info": `Información`,
    "critical": `Error`,
    "positive": `Éxito`
  },
  "et-EE": {
    "info": `Teave`,
    "critical": `Viga`,
    "positive": `Valmis`
  },
  "fi-FI": {
    "info": `Tiedot`,
    "critical": `Virhe`,
    "positive": `Onnistui`
  },
  "fr-FR": {
    "info": `Infos`,
    "critical": `Erreur`,
    "positive": `Succès`
  },
  "he-IL": {
    "info": `מידע`,
    "critical": `שגיאה`,
    "positive": `הצלחה`
  },
  "hr-HR": {
    "info": `Informacije`,
    "critical": `Pogreška`,
    "positive": `Uspješno`
  },
  "hu-HU": {
    "info": `Információ`,
    "critical": `Hiba`,
    "positive": `Siker`
  },
  "it-IT": {
    "info": `Informazioni`,
    "critical": `Errore`,
    "positive": `Operazione riuscita`
  },
  "ja-JP": {
    "info": `情報`,
    "critical": `エラー`,
    "positive": `成功`
  },
  "ko-KR": {
    "info": `정보`,
    "critical": `오류`,
    "positive": `성공`
  },
  "lt-LT": {
    "info": `Informacija`,
    "critical": `Klaida`,
    "positive": `Sėkmingai`
  },
  "lv-LV": {
    "info": `Informācija`,
    "critical": `Kļūda`,
    "positive": `Izdevās`
  },
  "nb-NO": {
    "info": `Info`,
    "critical": `Feil`,
    "positive": `Vellykket`
  },
  "nl-NL": {
    "info": `Info`,
    "critical": `Fout`,
    "positive": `Geslaagd`
  },
  "pl-PL": {
    "info": `Informacje`,
    "critical": `Błąd`,
    "positive": `Powodzenie`
  },
  "pt-BR": {
    "info": `Informações`,
    "critical": `Erro`,
    "positive": `Sucesso`
  },
  "pt-PT": {
    "info": `Informação`,
    "critical": `Erro`,
    "positive": `Sucesso`
  },
  "ro-RO": {
    "info": `Informaţii`,
    "critical": `Eroare`,
    "positive": `Succes`
  },
  "ru-RU": {
    "info": `Информация`,
    "critical": `Ошибка`,
    "positive": `Успешно`
  },
  "sk-SK": {
    "info": `Informácie`,
    "critical": `Chyba`,
    "positive": `Úspech`
  },
  "sl-SI": {
    "info": `Informacije`,
    "critical": `Napaka`,
    "positive": `Uspešno`
  },
  "sr-SP": {
    "info": `Informacije`,
    "critical": `Greška`,
    "positive": `Uspešno`
  },
  "sv-SE": {
    "info": `Info`,
    "critical": `Fel`,
    "positive": `Lyckades`
  },
  "tr-TR": {
    "info": `Bilgiler`,
    "critical": `Hata`,
    "positive": `Başarılı`
  },
  "uk-UA": {
    "info": `Інформація`,
    "critical": `Помилка`,
    "positive": `Успішно`
  },
  "zh-CN": {
    "info": `信息`,
    "critical": `错误`,
    "positive": `成功`
  },
  "zh-TW": {
    "info": `資訊`,
    "critical": `錯誤`,
    "positive": `成功`
  }
};
var ICONS = {
  info: infoIcon,
  critical: alertTriangleIcon,
  // neutral: infoIcon,
  positive: checkCircle2Icon
};
function Toast(props, ref) {
  const $ = c2(59);
  let t0;
  let state;
  let otherProps;
  if ($[0] !== props) {
    ({
      toast: t0,
      state,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = state;
    $[3] = otherProps;
  } else {
    t0 = $[1];
    state = $[2];
    otherProps = $[3];
  }
  const {
    key,
    animation,
    content: t1
  } = t0;
  const {
    children,
    tone,
    actionLabel,
    onAction,
    shouldCloseOnAction
  } = t1;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  const {
    closeButtonProps,
    titleProps,
    toastProps,
    contentProps
  } = $d6542812f0669241$export$a407b657d3044108(props, state, domRef);
  const styleProps = useStyleProps(otherProps);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages5);
  let t22;
  if ($[4] !== tone || $[5] !== stringFormatter) {
    t22 = tone && tone !== "neutral" ? stringFormatter.format(tone) : null;
    $[4] = tone;
    $[5] = stringFormatter;
    $[6] = t22;
  } else {
    t22 = $[6];
  }
  const iconLabel = t22;
  const icon = tone && tone !== "neutral" ? ICONS[tone] : null;
  let t32;
  if ($[7] !== onAction || $[8] !== shouldCloseOnAction || $[9] !== state || $[10] !== key) {
    t32 = () => {
      if (onAction) {
        onAction();
      }
      if (shouldCloseOnAction) {
        state.close(key);
      }
    };
    $[7] = onAction;
    $[8] = shouldCloseOnAction;
    $[9] = state;
    $[10] = key;
    $[11] = t32;
  } else {
    t32 = $[11];
  }
  const handleAction = t32;
  let t4;
  let t5;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      text: {
        color: "inherit"
      }
    };
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  t4 = t5;
  const slots = t4;
  let t6;
  if ($[13] !== styleProps.className) {
    t6 = classNames(css({
      borderRadius: tokenSchema.size.radius.regular,
      display: "flex",
      margin: tokenSchema.size.space.large,
      maxWidth: tokenSchema.size.container.xsmall,
      minHeight: tokenSchema.size.element.large,
      padding: tokenSchema.size.space.regular,
      paddingInlineStart: tokenSchema.size.space.large,
      pointerEvents: "auto",
      position: "absolute",
      color: tokenSchema.color.foreground.onEmphasis,
      "&[data-tone=neutral]": {
        background: tokenSchema.color.scale.slate9
      },
      "&[data-tone=info]": {
        background: tokenSchema.color.background.accentEmphasis
      },
      "&[data-tone=positive]": {
        background: tokenSchema.color.background.positiveEmphasis
      },
      "&[data-tone=critical]": {
        background: tokenSchema.color.background.criticalEmphasis
      },
      "&[data-animation=entering]": {
        animation: `${slideInAnim} 300ms`
      },
      "&[data-animation=exiting]": {
        animation: `${fadeOutAnim} 300ms forwards`
      }
    }), styleProps.className);
    $[13] = styleProps.className;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  let t7;
  if ($[15] !== styleProps.style || $[16] !== props.toast.priority) {
    t7 = {
      ...styleProps.style,
      zIndex: props.toast.priority
    };
    $[15] = styleProps.style;
    $[16] = props.toast.priority;
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  let t8;
  if ($[18] !== animation || $[19] !== state || $[20] !== key) {
    t8 = () => {
      if (animation === "exiting") {
        state.remove(key);
      }
    };
    $[18] = animation;
    $[19] = state;
    $[20] = key;
    $[21] = t8;
  } else {
    t8 = $[21];
  }
  let t9;
  if ($[22] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = css({
      display: "flex"
    });
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== icon || $[24] !== iconLabel) {
    t10 = icon && (0, import_jsx_runtime32.jsx)(Icon, {
      "aria-label": iconLabel,
      src: icon,
      size: "medium",
      marginTop: "small",
      marginEnd: "regular"
    });
    $[23] = icon;
    $[24] = iconLabel;
    $[25] = t10;
  } else {
    t10 = $[25];
  }
  let t11;
  if ($[26] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = classNames(css({
      alignItems: "center",
      display: "flex",
      columnGap: tokenSchema.size.space.large,
      flex: 1,
      flexWrap: "wrap",
      justifyContent: "flex-end",
      paddingInlineEnd: tokenSchema.size.space.large
    }));
    $[26] = t11;
  } else {
    t11 = $[26];
  }
  let t12;
  if ($[27] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = classNames(css({
      flexGrow: 1,
      paddingBlock: tokenSchema.size.space.regular
    }));
    $[27] = t12;
  } else {
    t12 = $[27];
  }
  let t13;
  if ($[28] !== children) {
    t13 = isReactText(children) ? (0, import_jsx_runtime32.jsx)(Text, {
      children
    }) : children;
    $[28] = children;
    $[29] = t13;
  } else {
    t13 = $[29];
  }
  let t14;
  if ($[30] !== titleProps || $[31] !== t13) {
    t14 = (0, import_jsx_runtime32.jsx)("div", {
      className: t12,
      ...titleProps,
      children: t13
    });
    $[30] = titleProps;
    $[31] = t13;
    $[32] = t14;
  } else {
    t14 = $[32];
  }
  let t15;
  if ($[33] !== actionLabel || $[34] !== handleAction) {
    t15 = actionLabel && (0, import_jsx_runtime32.jsx)(Button, {
      onPress: handleAction,
      static: "light",
      children: actionLabel
    });
    $[33] = actionLabel;
    $[34] = handleAction;
    $[35] = t15;
  } else {
    t15 = $[35];
  }
  let t16;
  if ($[36] !== t14 || $[37] !== t15) {
    t16 = (0, import_jsx_runtime32.jsxs)("div", {
      className: t11,
      children: [t14, t15]
    });
    $[36] = t14;
    $[37] = t15;
    $[38] = t16;
  } else {
    t16 = $[38];
  }
  let t17;
  if ($[39] !== contentProps || $[40] !== t10 || $[41] !== t16) {
    t17 = (0, import_jsx_runtime32.jsxs)("div", {
      ...contentProps,
      className: t9,
      children: [t10, t16]
    });
    $[39] = contentProps;
    $[40] = t10;
    $[41] = t16;
    $[42] = t17;
  } else {
    t17 = $[42];
  }
  let t18;
  if ($[43] === Symbol.for("react.memo_cache_sentinel")) {
    t18 = css({
      borderInlineStart: `${tokenSchema.size.border.regular} solid #fff3`,
      paddingInlineStart: tokenSchema.size.space.regular
    });
    $[43] = t18;
  } else {
    t18 = $[43];
  }
  let t19;
  if ($[44] !== closeButtonProps) {
    t19 = (0, import_jsx_runtime32.jsx)("div", {
      className: t18,
      children: (0, import_jsx_runtime32.jsx)(ClearButton, {
        static: "light",
        ...closeButtonProps
      })
    });
    $[44] = closeButtonProps;
    $[45] = t19;
  } else {
    t19 = $[45];
  }
  let t20;
  if ($[46] !== t17 || $[47] !== t19) {
    t20 = (0, import_jsx_runtime32.jsxs)(SlotProvider, {
      slots,
      children: [t17, t19]
    });
    $[46] = t17;
    $[47] = t19;
    $[48] = t20;
  } else {
    t20 = $[48];
  }
  let t21;
  if ($[49] !== styleProps || $[50] !== toastProps || $[51] !== domRef || $[52] !== tone || $[53] !== t6 || $[54] !== t7 || $[55] !== animation || $[56] !== t8 || $[57] !== t20) {
    t21 = (0, import_jsx_runtime32.jsx)("div", {
      ...styleProps,
      ...toastProps,
      ref: domRef,
      "data-tone": tone,
      className: t6,
      style: t7,
      "data-animation": animation,
      onAnimationEnd: t8,
      children: t20
    });
    $[49] = styleProps;
    $[50] = toastProps;
    $[51] = domRef;
    $[52] = tone;
    $[53] = t6;
    $[54] = t7;
    $[55] = animation;
    $[56] = t8;
    $[57] = t20;
    $[58] = t21;
  } else {
    t21 = $[58];
  }
  return t21;
}
var slideInAnim = keyframes({
  from: {
    transform: `var(--slide-from)`
  },
  to: {
    transform: `var(--slide-to)`
  }
});
var fadeOutAnim = keyframes({
  from: {
    opacity: 1
  },
  to: {
    opacity: 0
  }
});
var _Toast = (0, import_react103.forwardRef)(Toast);
function ToastContainer(props) {
  const $ = c2(11);
  const {
    children,
    state
  } = props;
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const isMobileDevice = useIsMobileDevice();
  const placement = isMobileDevice ? "center" : props.placement || "end";
  const position2 = isMobileDevice ? "bottom" : props.position || "bottom";
  const ref = (0, import_react103.useRef)(null);
  const {
    regionProps
  } = $6cc546b19ee7130a$export$b8cbbb20a51697de(props, state, ref);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      background: "transparent"
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = css({
      display: "flex",
      insetInline: 0,
      outline: "none",
      pointerEvents: "none",
      position: "fixed",
      zIndex: 100,
      "&[data-focus=visible] > :first-child:after": {
        borderRadius: `calc(${tokenSchema.size.radius.regular} + ${tokenSchema.size.alias.focusRingGap})`,
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        content: '""',
        inset: 0,
        margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`,
        pointerEvents: "none",
        position: "absolute"
      },
      "&[data-position=top]": {
        top: 0,
        flexDirection: "column",
        "--slide-from": "translateY(-100%)",
        "--slide-to": "translateY(0)"
      },
      "&[data-position=bottom]": {
        bottom: 0,
        flexDirection: "column-reverse",
        "--slide-from": "translateY(100%)",
        "--slide-to": "translateY(0)"
      },
      "&[data-placement=start]": {
        alignItems: "flex-start",
        "--slide-from": "translateX(-100%)",
        "--slide-to": "translateX(0)",
        "&[data-direction=rtl]": {
          "--slide-from": "translateX(100%)"
        }
      },
      "&[data-placement=center]": {
        alignItems: "center"
      },
      "&[data-placement=end]": {
        alignItems: "flex-end",
        "--slide-from": "translateX(100%)",
        "--slide-to": "translateX(0)",
        "&[data-direction=rtl]": {
          "--slide-from": "translateX(-100%)"
        }
      }
    });
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t22;
  if ($[2] !== regionProps || $[3] !== ref || $[4] !== direction || $[5] !== position2 || $[6] !== placement || $[7] !== children) {
    t22 = (0, import_jsx_runtime32.jsx)(KeystarProvider, {
      UNSAFE_style: t0,
      children: (0, import_jsx_runtime32.jsx)(FocusRing, {
        children: (0, import_jsx_runtime32.jsx)("div", {
          ...regionProps,
          ref,
          "data-direction": direction,
          "data-position": position2,
          "data-placement": placement,
          className: t1,
          children
        })
      })
    });
    $[2] = regionProps;
    $[3] = ref;
    $[4] = direction;
    $[5] = position2;
    $[6] = placement;
    $[7] = children;
    $[8] = t22;
  } else {
    t22 = $[8];
  }
  const contents = t22;
  let t32;
  if ($[9] !== contents) {
    t32 = import_react_dom5.default.createPortal(contents, document.body);
    $[9] = contents;
    $[10] = t32;
  } else {
    t32 = $[10];
  }
  return t32;
}
var globalToastQueue = null;
function getGlobalToastQueue() {
  if (!globalToastQueue) {
    globalToastQueue = new $77b352cf12efcf73$export$f1f8569633bbbec4({
      maxVisibleToasts: 1,
      hasExitAnimation: true
    });
  }
  return globalToastQueue;
}
var toastProviders = /* @__PURE__ */ new Set();
var subscriptions = /* @__PURE__ */ new Set();
function subscribe(fn2) {
  subscriptions.add(fn2);
  return () => subscriptions.delete(fn2);
}
function getActiveToaster() {
  return toastProviders.values().next().value;
}
function useActiveToaster() {
  return (0, import_react103.useSyncExternalStore)(subscribe, getActiveToaster, getActiveToaster);
}
function Toaster(props) {
  const $ = c2(10);
  const ref = (0, import_react103.useRef)();
  toastProviders.add(ref);
  let t0;
  if ($[0] !== ref) {
    t0 = () => () => {
      for (const toast of getGlobalToastQueue().visibleToasts) {
        toast.animation = void 0;
      }
      toastProviders.delete(ref);
      for (const fn2 of subscriptions) {
        fn2();
      }
    };
    $[0] = ref;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  (0, import_react103.useEffect)(t0, t1);
  const activeToaster = useActiveToaster();
  let t22;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = getGlobalToastQueue();
    $[3] = t22;
  } else {
    t22 = $[3];
  }
  const state = $77b352cf12efcf73$export$84726ef35ca2129a(t22);
  if (ref === activeToaster && state.visibleToasts.length > 0) {
    let t32;
    if ($[4] !== state) {
      t32 = state.visibleToasts.map((toast_0) => (0, import_jsx_runtime32.jsx)(_Toast, {
        toast: toast_0,
        state
      }, toast_0.key));
      $[4] = state;
      $[5] = t32;
    } else {
      t32 = $[5];
    }
    let t4;
    if ($[6] !== state || $[7] !== props || $[8] !== t32) {
      t4 = (0, import_jsx_runtime32.jsx)(ToastContainer, {
        state,
        ...props,
        children: t32
      });
      $[6] = state;
      $[7] = props;
      $[8] = t32;
      $[9] = t4;
    } else {
      t4 = $[9];
    }
    return t4;
  }
  return null;
}
function addToast(children, tone, options = {}) {
  if (typeof CustomEvent !== "undefined" && typeof window !== "undefined") {
    let event = new CustomEvent("keystar-ui-toast", {
      cancelable: true,
      bubbles: true,
      detail: {
        children,
        tone,
        options
      }
    });
    let shouldContinue = window.dispatchEvent(event);
    if (!shouldContinue) {
      return () => {
      };
    }
  }
  let value2 = {
    children,
    tone,
    actionLabel: options.actionLabel,
    onAction: options.onAction,
    shouldCloseOnAction: options.shouldCloseOnAction
  };
  warning(typeof options.timeout === "number" && options.timeout >= 5e3, "Timeouts must be at least 5000ms, for accessibility.");
  let timeout2 = options.timeout ? Math.max(options.timeout, 5e3) : void 0;
  let queue = getGlobalToastQueue();
  let key = queue.add(value2, {
    priority: getPriority(tone, options),
    timeout: timeout2,
    onClose: options.onClose
  });
  return () => queue.close(key);
}
var toastQueue = {
  /** Queues a neutral toast. */
  neutral(children, options = {}) {
    return addToast(children, "neutral", options);
  },
  /** Queues a positive toast. */
  positive(children, options = {}) {
    return addToast(children, "positive", options);
  },
  /** Queues a critical toast. */
  critical(children, options = {}) {
    return addToast(children, "critical", options);
  },
  /** Queues an informational toast. */
  info(children, options = {}) {
    return addToast(children, "info", options);
  }
};
var PRIORITY = {
  // actionable toasts gain 4 priority points. make sure critical toasts are
  // always at the top.
  critical: 10,
  positive: 3,
  info: 2,
  neutral: 1
};
function getPriority(tone, options) {
  let priority = PRIORITY[tone] || 1;
  if (options.onAction) {
    priority += 4;
  }
  return priority;
}

// node_modules/lib0/math.js
var floor = Math.floor;
var abs2 = Math.abs;
var log10 = Math.log10;
var min = (a3, b2) => a3 < b2 ? a3 : b2;
var max = (a3, b2) => a3 > b2 ? a3 : b2;
var isNaN2 = Number.isNaN;
var isNegativeZero2 = (n5) => n5 !== 0 ? n5 < 0 : 1 / n5 < 0;

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger2 = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/set.js
var create3 = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i4 = 0; i4 < src.length; i4++) {
    dest.push(src[i4]);
  }
};
var from3 = Array.from;
var some = (arr, f6) => {
  for (let i4 = 0; i4 < arr.length; i4++) {
    if (f6(arr[i4], i4, arr)) {
      return true;
    }
  }
  return false;
};
var isArray = Array.isArray;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint3 = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s4) => s4.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s4) => s4.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s4, separator) => trimLeft(s4.replace(fromCamelCaseRegex, (match2) => `${separator}${toLowerCase(match2)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i4 = 0; i4 < len; i4++) {
    buf[i4] = /** @type {number} */
    encodedString.codePointAt(i4);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length2 = (encoder) => {
  let len = encoder.cpos;
  for (let i4 = 0; i4 < encoder.bufs.length; i4++) {
    len += encoder.bufs[i4].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length2(encoder));
  let curPos = 0;
  for (let i4 = 0; i4 < encoder.bufs.length; i4++) {
    const d5 = encoder.bufs[i4];
    uint8arr.set(d5, curPos);
    curPos += d5.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative2 = isNegativeZero2(num);
  if (isNegative2) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative2 ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i4 = 0; i4 < written; i4++) {
      write(encoder, _strBuffer[i4]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i4 = 0; i4 < len; i4++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i4)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeBinaryEncoder = (encoder, append3) => writeUint8Array(encoder, toUint8Array(append3));
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger2(data) && abs2(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i4 = 0; i4 < data.length; i4++) {
          writeAny(encoder, data[i4]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys3 = Object.keys(data);
        writeVarUint(encoder, keys3.length);
        for (let i4 = 0; i4 < keys3.length; i4++) {
          const key = keys3[i4];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v6) {
    if (this.s === v6) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v6);
      this.s = v6;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v6) {
    if (this.s === v6) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v6;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v6) {
    if (this.diff === v6 - this.s) {
      this.s = v6;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v6 - this.s;
      this.s = v6;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string2) {
    this.s += string2;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string2.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// node_modules/lib0/error.js
var create4 = (s4) => new Error(s4);
var methodUnimplemented = () => {
  throw create4("Method unimplemented");
};
var unexpectedCase = () => {
  throw create4("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create4("Unexpected end of array");
var errorIntegerOutOfRange = create4("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r6 = decoder.arr[decoder.pos++];
    num = num + (r6 & BITS7) * mult;
    mult *= 128;
    if (r6 < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r6 = decoder.arr[decoder.pos++];
  let num = r6 & BITS6;
  let mult = 64;
  const sign = (r6 & BIT7) > 0 ? -1 : 1;
  if ((r6 & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r6 = decoder.arr[decoder.pos++];
    num = num + (r6 & BITS7) * mult;
    mult *= 128;
    if (r6 < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i4 = 0; i4 < len; i4++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i4 = 0; i4 < len; i4++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative2 = isNegativeZero2(this.s);
      this.count = 1;
      if (isNegative2) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/map.js
var create5 = () => /* @__PURE__ */ new Map();
var copy2 = (m3) => {
  const r6 = create5();
  m3.forEach((v6, k2) => {
    r6.set(k2, v6);
  });
  return r6;
};
var setIfUndefined = (map4, key, createT) => {
  let set2 = map4.get(key);
  if (set2 === void 0) {
    map4.set(key, set2 = createT());
  }
  return set2;
};
var map = (m3, f6) => {
  const res = [];
  for (const [key, value2] of m3) {
    res.push(f6(value2, key));
  }
  return res;
};
var any = (m3, f6) => {
  for (const [key, value2] of m3) {
    if (f6(value2, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create5();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f6) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create3
    ).add(f6);
    return f6;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f6) {
    const _f = (...args2) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f6(...args2);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f6) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f6);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from3((this._observers.get(name) || create5()).values()).forEach((f6) => f6(...args2));
  }
  destroy() {
    this._observers = create5();
  }
};
var Observable = class {
  constructor() {
    this._observers = create5();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f6) {
    setIfUndefined(this._observers, name, create3).add(f6);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f6) {
    const _f = (...args2) => {
      this.off(name, _f);
      f6(...args2);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f6) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f6);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from3((this._observers.get(name) || create5()).values()).forEach((f6) => f6(...args2));
  }
  destroy() {
    this._observers = create5();
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var rand = Math.random;
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var oneOf = (arr) => arr[floor(rand() * arr.length)];
var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c6) => (c6 ^ uint32() & 15 >> c6 / 4).toString(16)
);

// node_modules/lib0/promise.js
var create6 = (f6) => (
  /** @type {Promise<T>} */
  new Promise(f6)
);
var all = Promise.all.bind(Promise);

// node_modules/lib0/conditions.js
var undefinedToNull = (v6) => v6 === void 0 ? null : v6;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e4) {
}
var varStorage = _localStorage;
var onChange = (eventHandler) => usePolyfill || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var offChange = (eventHandler) => usePolyfill || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);

// node_modules/lib0/object.js
var assign2 = Object.assign;
var keys = Object.keys;
var forEach = (obj, f6) => {
  for (const key in obj) {
    f6(obj[key], key);
  }
};
var length3 = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f6) => {
  for (const key in obj) {
    if (!f6(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a3, b2) => a3 === b2 || length3(a3) === length3(b2) && every(a3, (val, key) => (val !== void 0 || hasProperty(b2, key)) && b2[key] === val);

// node_modules/lib0/function.js
var callAll = (fs, args2, i4 = 0) => {
  try {
    for (; i4 < fs.length; i4++) {
      fs[i4](...args2);
    }
  } finally {
    if (i4 < fs.length) {
      callAll(fs, args2, i4 + 1);
    }
  }
};
var id = (a3) => a3;
var equalityStrict = (a3, b2) => a3 === b2;
var equalityDeep = (a3, b2) => {
  if (a3 == null || b2 == null) {
    return equalityStrict(a3, b2);
  }
  if (a3.constructor !== b2.constructor) {
    return false;
  }
  if (a3 === b2) {
    return true;
  }
  switch (a3.constructor) {
    case ArrayBuffer:
      a3 = new Uint8Array(a3);
      b2 = new Uint8Array(b2);
    case Uint8Array: {
      if (a3.byteLength !== b2.byteLength) {
        return false;
      }
      for (let i4 = 0; i4 < a3.length; i4++) {
        if (a3[i4] !== b2[i4]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a3.size !== b2.size) {
        return false;
      }
      for (const value2 of a3) {
        if (!b2.has(value2)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a3.size !== b2.size) {
        return false;
      }
      for (const key of a3.keys()) {
        if (!b2.has(key) || !equalityDeep(a3.get(key), b2.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length3(a3) !== length3(b2)) {
        return false;
      }
      for (const key in a3) {
        if (!hasProperty(a3, key) || !equalityDeep(a3[key], b2[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a3.length !== b2.length) {
        return false;
      }
      for (let i4 = 0; i4 < a3.length; i4++) {
        if (!equalityDeep(a3[i4], b2[i4])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value2, options) => options.includes(value2);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create5();
      const pargs = process.argv;
      let currParamName = null;
      for (let i4 = 0; i4 < pargs.length; i4++) {
        const parg = pargs[i4];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create5();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value2] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value2);
          params.set(`-${fromCamelCase(key, "-")}`, value2);
        }
      });
    } else {
      params = create5();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length4) => new Uint8Array(buffer, byteOffset, length4);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s4 = "";
  for (let i4 = 0; i4 < bytes.byteLength; i4++) {
    s4 += fromCharCode(bytes[i4]);
  }
  return btoa(s4);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s4) => {
  const a3 = atob(s4);
  const bytes = createUint8ArrayFromLen(a3.length);
  for (let i4 = 0; i4 < a3.length; i4++) {
    bytes[i4] = a3.charCodeAt(i4);
  }
  return bytes;
};
var fromBase64Node = (s4) => {
  const buf = Buffer.from(s4, "base64");
  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser2 ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser2 ? fromBase64Browser : fromBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create7 = (left, right) => new Pair(left, right);

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var mapToStyleString = (m3) => map(m3, (value2, key) => `${key}:${value2};`).join("");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/eventloop.js
var createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
var Timeout = createTimeoutClass(clearTimeout);
var timeout = (timeout2, callback) => new Timeout(setTimeout(callback, timeout2));
var Interval = createTimeoutClass(clearInterval);
var Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
var Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));

// node_modules/lib0/symbol.js
var create8 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create8();
var UNBOLD = create8();
var BLUE = create8();
var GREY = create8();
var GREEN = create8();
var RED = create8();
var PURPLE = create8();
var ORANGE = create8();
var UNCOLOR = create8();
var computeNoColorLoggingArgs = (args2) => {
  var _a5;
  if (args2.length === 1 && ((_a5 = args2[0]) == null ? void 0 : _a5.constructor) === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i4 = 0;
  for (; i4 < args2.length; i4++) {
    const arg = args2[i4];
    if (arg === void 0) {
      strBuilder.push("undefined");
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var lastLoggingTime = getUnixTime();

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create7("font-weight", "bold"),
  [UNBOLD]: create7("font-weight", "normal"),
  [BLUE]: create7("color", "blue"),
  [GREEN]: create7("color", "green"),
  [GREY]: create7("color", "grey"),
  [RED]: create7("color", "red"),
  [PURPLE]: create7("color", "purple"),
  [ORANGE]: create7("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create7("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  var _a5;
  if (args2.length === 1 && ((_a5 = args2[0]) == null ? void 0 : _a5.constructor) === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create5();
  let logArgs = [];
  let i4 = 0;
  for (; i4 < args2.length; i4++) {
    const arg = args2[i4];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i4 > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i4 > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i4 < args2.length; i4++) {
    const arg = args2[i4];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var warn = (...args2) => {
  console.warn(...computeLoggingArgs(args2));
  args2.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create3();

// node_modules/lib0/iterator.js
var createIterator = (next2) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: next2
});
var iteratorFilter = (iterator, filter2) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter2(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value: value2 } = iterator.next();
  return { done, value: done ? void 0 : fmap(value2) };
});

// node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f6) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i4 = 0; i4 < deletes.length; i4++) {
    const del2 = deletes[i4];
    iterateStructs(transaction, structs, del2.clock, del2.len, f6);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a3, b2) => a3.clock - b2.clock);
    let i4, j3;
    for (i4 = 1, j3 = 1; i4 < dels.length; i4++) {
      const left = dels[j3 - 1];
      const right = dels[i4];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j3 < i4) {
          dels[j3] = right;
        }
        j3++;
      }
    }
    dels.length = j3;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i4 = dssI + 1; i4 < dss.length; i4++) {
          appendTo(dels, dss[i4].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length4) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length4));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i4 = 0; i4 < structs.length; i4++) {
      const struct = structs[i4];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i4 + 1 < structs.length) {
          for (let next2 = structs[i4 + 1]; i4 + 1 < structs.length && next2.deleted; next2 = structs[++i4 + 1]) {
            len += next2.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from3(ds.clients.entries()).sort((a3, b2) => b2[0] - a3[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i4 = 0; i4 < len; i4++) {
      const item = dsitems[i4];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i4 = 0; i4 < numClients; i4++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i5 = 0; i5 < numberOfDeletes; i5++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store2) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i4 = 0; i4 < numClients; i4++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store2.clients.get(client) || [];
    const state = getState(store2, client);
    for (let i5 = 0; i5 < numberOfDeletes; i5++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index2 = findIndexSS(structs, clock);
        let struct = structs[index2];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index2 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index2++;
        }
        while (index2 < structs.length) {
          struct = structs[index2++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index2, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class _Doc extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create6((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
    const provideSyncedPromise = () => create6((resolve) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from3(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f6, origin = null) {
    return transact(this, f6, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type3 = setIfUndefined(this.share, name, () => {
      const t4 = new TypeConstructor();
      t4._integrate(this, null);
      return t4;
    });
    const Constr = type3.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t4 = new TypeConstructor();
        t4._map = type3._map;
        type3._map.forEach(
          /** @param {Item?} n */
          (n5) => {
            for (; n5 !== null; n5 = n5.left) {
              n5.parent = t4;
            }
          }
        );
        t4._start = type3._start;
        for (let n5 = t4._start; n5 !== null; n5 = n5.right) {
          n5.parent = t4;
        }
        t4._length = type3._length;
        this.share.set(name, t4);
        t4._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t4
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type3
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value2, key) => {
      doc2[key] = value2.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from3(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s4) {
    writeVarString(this.restEncoder, s4);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s4) {
    this.stringEncoder.write(s4);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i4 = startNewStructs + 1; i4 < structs.length; i4++) {
    structs[i4].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store2, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store2, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store2).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from3(sm.entries()).sort((a3, b2) => b2[0] - a3[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store2.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create5();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i4 = 0; i4 < numOfStateUpdates; i4++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i5 = 0; i5 < numberOfStructs; i5++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i5] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i5] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // leftd
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i5] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store2, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from3(clientsStructRefs.keys()).sort((a3, b2) => a3 - b2);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c6) => c6 !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store2, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store2);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store2, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store2 = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store2, ss);
  const pending = store2.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store2, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store2.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store2);
  if (store2.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store2.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store2);
    if (dsRest && dsRest2) {
      store2.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store2.pendingDs = dsRest || dsRest2;
    }
  } else {
    store2.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store2.pendingStructs.update
    );
    store2.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i4) => i4 === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i4 = 0; i4 < ssLength; i4++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from3(sv.entries()).sort((a3, b2) => b2[0] - a3[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f6) => eventHandler.l.push(f6);
var removeEventHandlerListener = (eventHandler, f6) => {
  const l6 = eventHandler.l;
  const len = l6.length;
  eventHandler.l = l6.filter((g4) => f6 !== g4);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a3, b2) => a3 === b2 || a3 !== null && b2 !== null && a3.client === b2.client && a3.clock === b2.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type3) => {
  for (const [key, value2] of type3.doc.share.entries()) {
    if (value2 === type3) {
      return key;
    }
  }
  throw unexpectedCase();
};
var isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = /** @type {AbstractType<any>} */
    child.parent._item;
  }
  return false;
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type3, tname, item, assoc = 0) {
    this.type = type3;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type3, index2, assoc = 0) {
    this.type = type3;
    this.index = index2;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type3, index2, assoc = 0) => new AbsolutePosition(type3, index2, assoc);
var createRelativePosition = (type3, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type3._item === null) {
    tname = findRootTypeKey(type3);
  } else {
    typeid = createID(type3._item.id.client, type3._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type3, index2, assoc = 0) => {
  let t4 = type3._start;
  if (assoc < 0) {
    if (index2 === 0) {
      return createRelativePosition(type3, null, assoc);
    }
    index2--;
  }
  while (t4 !== null) {
    if (!t4.deleted && t4.countable) {
      if (t4.length > index2) {
        return createRelativePosition(type3, createID(t4.id.client, t4.id.clock + index2), assoc);
      }
      index2 -= t4.length;
    }
    if (t4.right === null && assoc < 0) {
      return createRelativePosition(type3, t4.lastId, assoc);
    }
    t4 = t4.right;
  }
  return createRelativePosition(type3, null, assoc);
};
var createAbsolutePositionFromRelativePosition = (rpos, doc2) => {
  const store2 = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type3 = null;
  let index2 = 0;
  if (rightID !== null) {
    if (getState(store2, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followRedone(store2, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type3 = /** @type {AbstractType<any>} */
    right.parent;
    if (type3._item === null || !type3._item.deleted) {
      index2 = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n5 = right.left;
      while (n5 !== null) {
        if (!n5.deleted && n5.countable) {
          index2 += n5.length;
        }
        n5 = n5.left;
      }
    }
  } else {
    if (tname !== null) {
      type3 = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store2, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followRedone(store2, typeID);
      if (item instanceof Item && item.content instanceof ContentType) {
        type3 = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index2 = type3._length;
    } else {
      index2 = 0;
    }
  }
  return createAbsolutePosition(type3, index2, rpos.assoc);
};
var compareRelativePositions = (a3, b2) => a3 === b2 || a3 !== null && b2 !== null && a3.tname === b2.tname && compareIDs(a3.item, b2.item) && compareIDs(a3.type, b2.type) && a3.assoc === b2.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var snapshot = (doc2) => createSnapshot(createDeleteSetFromStructStore(doc2.store), getStateVector(doc2.store));
var isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot2) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create3);
  const store2 = transaction.doc.store;
  if (!meta.has(snapshot2)) {
    snapshot2.sv.forEach((clock, client) => {
      if (clock < getState(store2, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {
    });
    meta.add(snapshot2);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store2) => {
  const sm = /* @__PURE__ */ new Map();
  store2.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store2, client) => {
  const structs = store2.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store2, struct) => {
  let structs = store2.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store2.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store2, id2) => {
  const structs = store2.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index2 = findIndexSS(structs, clock);
  const struct = structs[index2];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index2 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index2 + 1;
  }
  return index2;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store2, id2) => {
  const structs = store2.clients.get(id2.client);
  const index2 = findIndexSS(structs, id2.clock);
  const struct = structs[index2];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index2 + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store2, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store2.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f6) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index2 = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index2++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f6(struct);
  } while (index2 < structs.length && structs[index2].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type3, parentSub) => {
  const item = type3._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type3, create3).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i4 = pos;
  for (; i4 > 0; right = left, left = structs[--i4 - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i4;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store2, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store2.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store2, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store2) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store2.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i4) => {
  if (i4 < transactionCleanups.length) {
    const transaction = transactionCleanups[i4];
    const doc2 = transaction.doc;
    const store2 = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events2, type3) => {
          if (type3._dEH.l.length > 0 && (type3._item === null || !type3._item.deleted)) {
            events2 = events2.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events2.forEach((event) => {
              event.currentTarget = type3;
              event._path = null;
            });
            events2.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type3._dEH, events2, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store2, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store2);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store2.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i5 = structs.length - 1; i5 >= firstChangePos; ) {
            i5 -= 1 + tryToMergeWithLefts(structs, i5);
          }
        }
      });
      for (let i5 = mergeStructs.length - 1; i5 >= 0; i5--) {
        const { client, clock } = mergeStructs[i5].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store2.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i4 + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i4 + 1);
      }
    }
  }
};
var transact = (doc2, f6, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f6(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
var StackItem = class {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
};
var clearUndoManagerStackItem = (tr, um, stackItem) => {
  iterateDeletedStructs(tr, stackItem.deletions, (item) => {
    if (item instanceof Item && um.scope.some((type3) => isParentOf(type3, item))) {
      keepItem(item, false);
    }
  });
};
var popStackItem = (undoManager, stack, eventType) => {
  let _tr = null;
  const doc2 = undoManager.doc;
  const scope = undoManager.scope;
  transact(doc2, (transaction) => {
    while (stack.length > 0 && undoManager.currStackItem === null) {
      const store2 = doc2.store;
      const stackItem = (
        /** @type {StackItem} */
        stack.pop()
      );
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
        if (struct instanceof Item) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store2, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type3) => isParentOf(
            type3,
            /** @type {Item} */
            struct
          ))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
        if (struct instanceof Item && scope.some((type3) => isParentOf(type3, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
      });
      for (let i4 = itemsToDelete.length - 1; i4 >= 0; i4--) {
        const item = itemsToDelete[i4];
        if (undoManager.deleteFilter(item)) {
          item.delete(transaction);
          performedChange = true;
        }
      }
      undoManager.currStackItem = performedChange ? stackItem : null;
    }
    transaction.changed.forEach((subProps, type3) => {
      if (subProps.has(null) && type3._searchMarker) {
        type3._searchMarker.length = 0;
      }
    });
    _tr = transaction;
  }, undoManager);
  if (undoManager.currStackItem != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager.emit("stack-item-popped", [{ stackItem: undoManager.currStackItem, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
    undoManager.currStackItem = null;
  }
  return undoManager.currStackItem;
};
var UndoManager = class extends ObservableV2 {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(typeScope, {
    captureTimeout = 500,
    captureTransaction = (_tr) => true,
    deleteFilter = () => true,
    trackedOrigins = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges = false,
    doc: doc2 = (
      /** @type {Doc} */
      isArray(typeScope) ? typeScope[0].doc : typeScope.doc
    )
  } = {}) {
    super();
    this.scope = [];
    this.doc = doc2;
    this.addToScope(typeScope);
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.captureTransaction = captureTransaction;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.currStackItem = null;
    this.lastChange = 0;
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
    this.captureTimeout = captureTimeout;
    this.afterTransactionHandler = (transaction) => {
      if (!this.captureTransaction(transaction) || !this.scope.some((type3) => transaction.changedParentTypes.has(type3)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.clear(false, true);
      }
      const insertions = new DeleteSet();
      transaction.afterState.forEach((endClock, client) => {
        const startClock = transaction.beforeState.get(client) || 0;
        const len = endClock - startClock;
        if (len > 0) {
          addToDeleteSet(insertions, client, startClock, len);
        }
      });
      const now = getUnixTime();
      let didAdd = false;
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction.deleteSet, insertions));
        didAdd = true;
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        /** @param {Item|GC} item */
        (item) => {
          if (item instanceof Item && this.scope.some((type3) => isParentOf(type3, item))) {
            keepItem(item, true);
          }
        }
      );
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
      if (didAdd) {
        this.emit("stack-item-added", changeEvent);
      } else {
        this.emit("stack-item-updated", changeEvent);
      }
    };
    this.doc.on("afterTransaction", this.afterTransactionHandler);
    this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(ytypes) {
    ytypes = isArray(ytypes) ? ytypes : [ytypes];
    ytypes.forEach((ytype) => {
      if (this.scope.every((yt) => yt !== ytype)) {
        if (ytype.doc !== this.doc) warn("[yjs#509] Not same Y.Doc");
        this.scope.push(ytype);
      }
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.trackedOrigins.add(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.trackedOrigins.delete(origin);
  }
  clear(clearUndoStack = true, clearRedoStack = true) {
    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
      this.doc.transact((tr) => {
        if (clearUndoStack) {
          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.undoStack = [];
        }
        if (clearRedoStack) {
          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.redoStack = [];
        }
        this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
      });
    }
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this);
    this.doc.off("afterTransaction", this.afterTransactionHandler);
    super.destroy();
  }
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i4 = 0; i4 < numOfStateUpdates; i4++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i5 = 0; i5 < numberOfStructs; i5++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {
  const encoder = new YEncoder();
  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
  let curr = updateDecoder.curr;
  if (curr !== null) {
    let size3 = 0;
    let currClient = curr.id.client;
    let stopCounting = curr.id.clock !== 0;
    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
    for (; curr !== null; curr = updateDecoder.next()) {
      if (currClient !== curr.id.client) {
        if (currClock !== 0) {
          size3++;
          writeVarUint(encoder.restEncoder, currClient);
          writeVarUint(encoder.restEncoder, currClock);
        }
        currClient = curr.id.client;
        currClock = 0;
        stopCounting = curr.id.clock !== 0;
      }
      if (curr.constructor === Skip) {
        stopCounting = true;
      }
      if (!stopCounting) {
        currClock = curr.id.clock + curr.length;
      }
    }
    if (currClock !== 0) {
      size3++;
      writeVarUint(encoder.restEncoder, currClient);
      writeVarUint(encoder.restEncoder, currClock);
    }
    const enc = createEncoder();
    writeVarUint(enc, size3);
    writeBinaryEncoder(enc, encoder.restEncoder);
    encoder.restEncoder = enc;
    return encoder.toUint8Array();
  } else {
    writeVarUint(encoder.restEncoder, 0);
    return encoder.toUint8Array();
  }
};
var encodeStateVectorFromUpdate = (update) => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next2 = currDecoder.curr; next2 !== null && next2.id.client === firstClient && next2.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next2.constructor !== Skip; next2 = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next2, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i4 = 0; i4 < lazyWriter.clientStructs.length; i4++) {
    const partStructs = lazyWriter.clientStructs[i4];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create4(errorComputeChanges);
      }
      const keys3 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev2 = item.left;
            while (prev2 !== null && this.adds(prev2)) {
              prev2 = prev2.left;
            }
            if (this.deletes(item)) {
              if (prev2 !== null && this.deletes(prev2)) {
                action = "delete";
                oldValue = last(prev2.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev2 !== null && this.deletes(prev2)) {
                action = "update";
                oldValue = last(prev2.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys3.set(key, { action, oldValue });
        }
      });
      this._keys = keys3;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create4(errorComputeChanges);
      }
      const target = this.target;
      const added = create3();
      const deleted = create3();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path.unshift(child._item.parentSub);
    } else {
      let i4 = 0;
      let c6 = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c6 !== child._item && c6 !== null) {
        if (!c6.deleted) {
          i4++;
        }
        c6 = c6.right;
      }
      path.unshift(i4);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p4, index2) {
    p4.marker = true;
    this.p = p4;
    this.index = index2;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p4, index2) => {
  marker.p.marker = false;
  marker.p = p4;
  p4.marker = true;
  marker.index = index2;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p4, index2) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a3, b2) => a3.timestamp < b2.timestamp ? a3 : b2);
    overwriteMarker(marker, p4, index2);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p4, index2);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index2) => {
  if (yarray._start === null || index2 === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a3, b2) => abs2(index2 - a3.index) < abs2(index2 - b2.index) ? a3 : b2);
  let p4 = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p4 = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p4.right !== null && pindex < index2) {
    if (!p4.deleted && p4.countable) {
      if (index2 < pindex + p4.length) {
        break;
      }
      pindex += p4.length;
    }
    p4 = p4.right;
  }
  while (p4.left !== null && pindex > index2) {
    p4 = p4.left;
    if (!p4.deleted && p4.countable) {
      pindex -= p4.length;
    }
  }
  while (p4.left !== null && p4.left.id.client === p4.id.client && p4.left.id.clock + p4.left.length === p4.id.clock) {
    p4 = p4.left;
    if (!p4.deleted && p4.countable) {
      pindex -= p4.length;
    }
  }
  if (marker !== null && abs2(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p4.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p4, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p4, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index2, len) => {
  for (let i4 = searchMarker.length - 1; i4 >= 0; i4--) {
    const m3 = searchMarker[i4];
    if (len > 0) {
      let p4 = m3.p;
      p4.marker = false;
      while (p4 && (p4.deleted || !p4.countable)) {
        p4 = p4.left;
        if (p4 && !p4.deleted && p4.countable) {
          m3.index -= p4.length;
        }
      }
      if (p4 === null || p4.marker === true) {
        searchMarker.splice(i4, 1);
        continue;
      }
      m3.p = p4;
      p4.marker = true;
    }
    if (index2 < m3.index || len > 0 && index2 === m3.index) {
      m3.index = max(index2, m3.index + len);
    }
  }
};
var callTypeObservers = (type3, transaction, event) => {
  const changedType = type3;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type3, () => []).push(event);
    if (type3._item === null) {
      break;
    }
    type3 = /** @type {AbstractType<any>} */
    type3._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y3, item) {
    this.doc = y3;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n5 = this._start;
    while (n5 !== null && n5.deleted) {
      n5 = n5.right;
    }
    return n5;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f6) {
    addEventHandlerListener(this._eH, f6);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f6) {
    addEventHandlerListener(this._dEH, f6);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f6) {
    removeEventHandlerListener(this._eH, f6);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f6) {
    removeEventHandlerListener(this._dEH, f6);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type3, start2, end) => {
  if (start2 < 0) {
    start2 = type3._length + start2;
  }
  if (end < 0) {
    end = type3._length + end;
  }
  let len = end - start2;
  const cs = [];
  let n5 = type3._start;
  while (n5 !== null && len > 0) {
    if (n5.countable && !n5.deleted) {
      const c6 = n5.content.getContent();
      if (c6.length <= start2) {
        start2 -= c6.length;
      } else {
        for (let i4 = start2; i4 < c6.length && len > 0; i4++) {
          cs.push(c6[i4]);
          len--;
        }
        start2 = 0;
      }
    }
    n5 = n5.right;
  }
  return cs;
};
var typeListToArray = (type3) => {
  const cs = [];
  let n5 = type3._start;
  while (n5 !== null) {
    if (n5.countable && !n5.deleted) {
      const c6 = n5.content.getContent();
      for (let i4 = 0; i4 < c6.length; i4++) {
        cs.push(c6[i4]);
      }
    }
    n5 = n5.right;
  }
  return cs;
};
var typeListToArraySnapshot = (type3, snapshot2) => {
  const cs = [];
  let n5 = type3._start;
  while (n5 !== null) {
    if (n5.countable && isVisible(n5, snapshot2)) {
      const c6 = n5.content.getContent();
      for (let i4 = 0; i4 < c6.length; i4++) {
        cs.push(c6[i4]);
      }
    }
    n5 = n5.right;
  }
  return cs;
};
var typeListForEach = (type3, f6) => {
  let index2 = 0;
  let n5 = type3._start;
  while (n5 !== null) {
    if (n5.countable && !n5.deleted) {
      const c6 = n5.content.getContent();
      for (let i4 = 0; i4 < c6.length; i4++) {
        f6(c6[i4], index2++, type3);
      }
    }
    n5 = n5.right;
  }
};
var typeListMap = (type3, f6) => {
  const result = [];
  typeListForEach(type3, (c6, i4) => {
    result.push(f6(c6, i4, type3));
  });
  return result;
};
var typeListCreateIterator = (type3) => {
  let n5 = type3._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n5 !== null && n5.deleted) {
          n5 = n5.right;
        }
        if (n5 === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n5.content.getContent();
        currentContentIndex = 0;
        n5 = n5.right;
      }
      const value2 = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value: value2
      };
    }
  };
};
var typeListGet = (type3, index2) => {
  const marker = findMarker(type3, index2);
  let n5 = type3._start;
  if (marker !== null) {
    n5 = marker.p;
    index2 -= marker.index;
  }
  for (; n5 !== null; n5 = n5.right) {
    if (!n5.deleted && n5.countable) {
      if (index2 < n5.length) {
        return n5.content.getContent()[index2];
      }
      index2 -= n5.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store2 = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store2, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c6) => {
    if (c6 === null) {
      jsonContent.push(c6);
    } else {
      switch (c6.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c6);
          break;
        default:
          packJsonContent();
          switch (c6.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store2, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c6
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store2, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c6
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c6 instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store2, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c6));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create4("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index2, content) => {
  if (index2 > parent._length) {
    throw lengthExceeded();
  }
  if (index2 === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index2, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index2;
  const marker = findMarker(parent, index2);
  let n5 = parent._start;
  if (marker !== null) {
    n5 = marker.p;
    index2 -= marker.index;
    if (index2 === 0) {
      n5 = n5.prev;
      index2 += n5 && n5.countable && !n5.deleted ? n5.length : 0;
    }
  }
  for (; n5 !== null; n5 = n5.right) {
    if (!n5.deleted && n5.countable) {
      if (index2 <= n5.length) {
        if (index2 < n5.length) {
          getItemCleanStart(transaction, createID(n5.id.client, n5.id.clock + index2));
        }
        break;
      }
      index2 -= n5.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n5, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n5 = marker.p;
  if (n5) {
    while (n5.right) {
      n5 = n5.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n5, content);
};
var typeListDelete = (transaction, parent, index2, length4) => {
  if (length4 === 0) {
    return;
  }
  const startIndex = index2;
  const startLength = length4;
  const marker = findMarker(parent, index2);
  let n5 = parent._start;
  if (marker !== null) {
    n5 = marker.p;
    index2 -= marker.index;
  }
  for (; n5 !== null && index2 > 0; n5 = n5.right) {
    if (!n5.deleted && n5.countable) {
      if (index2 < n5.length) {
        getItemCleanStart(transaction, createID(n5.id.client, n5.id.clock + index2));
      }
      index2 -= n5.length;
    }
  }
  while (length4 > 0 && n5 !== null) {
    if (!n5.deleted) {
      if (length4 < n5.length) {
        getItemCleanStart(transaction, createID(n5.id.client, n5.id.clock + length4));
      }
      n5.delete(transaction);
      length4 -= n5.length;
    }
    n5 = n5.right;
  }
  if (length4 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length4
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c6 = parent._map.get(key);
  if (c6 !== void 0) {
    c6.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value2) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value2 == null) {
    content = new ContentAny([value2]);
  } else {
    switch (value2.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value2]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value2
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value2
        );
        break;
      default:
        if (value2 instanceof AbstractType) {
          content = new ContentType(value2);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value2, key) => {
    if (!value2.deleted) {
      res[key] = value2.content.getContent()[value2.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot2) => {
  const res = {};
  parent._map.forEach((value2, key) => {
    let v6 = value2;
    while (v6 !== null && (!snapshot2.sv.has(v6.id.client) || v6.id.clock >= (snapshot2.sv.get(v6.id.client) || 0))) {
      v6 = v6.left;
    }
    if (v6 !== null && isVisible(v6, snapshot2)) {
      res[key] = v6.content.getContent()[v6.length - 1];
    }
  });
  return res;
};
var createMapIterator = (map4) => iteratorFilter(
  map4.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
);
var YArrayEvent = class extends YEvent {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(yarray, transaction) {
    super(yarray, transaction);
    this._transaction = transaction;
  }
};
var YArray = class _YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a3 = new _YArray();
    a3.push(items);
    return a3;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y3, item) {
    super._integrate(y3, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _YArray();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const arr = new _YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index2, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index2,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index2, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index2, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index2, length4);
      });
    } else {
      this._prelimContent.splice(index2, length4);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index2) {
    return typeListGet(this, index2);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start2 = 0, end = this.length) {
    return typeListSlice(this, start2, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c6) => c6 instanceof AbstractType ? c6.toJSON() : c6);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f6) {
    return typeListMap(
      this,
      /** @type {any} */
      f6
    );
  }
  /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f6) {
    typeListForEach(this, f6);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class _YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries2) {
    super();
    this._prelimContent = null;
    if (entries2 === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries2);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y3, item) {
    super._integrate(y3, item);
    this._prelimContent.forEach((value2, key) => {
      this.set(key, value2);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _YMap();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const map4 = new _YMap();
    this.forEach((value2, key) => {
      map4.set(key, value2 instanceof AbstractType ? (
        /** @type {typeof value} */
        value2.clone()
      ) : value2);
    });
    return map4;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map4 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v6 = item.content.getContent()[item.length - 1];
        map4[key] = v6 instanceof AbstractType ? v6.toJSON() : v6;
      }
    });
    return map4;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v6) => v6[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v6) => v6[1].content.getContent()[v6[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v6) => (
        /** @type {any} */
        [v6[0], v6[1].content.getContent()[v6[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f6) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f6(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value2) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value2
        );
      });
    } else {
      this._prelimContent.set(key, value2);
    }
    return value2;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map4) {
          typeMapDelete(transaction, map4, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a3, b2) => a3 === b2 || typeof a3 === "object" && typeof b2 === "object" && a3 && b2 && equalFlat(a3, b2);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index2, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index2;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count) => {
  while (pos.right !== null && count > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
          }
          pos.index += pos.right.length;
          count -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index2, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index2) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index2 - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index2);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value: value2 } = format;
  if (value2 === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value2);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    )) ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) ?? null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text3, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text3.constructor === String ? new ContentString(
    /** @type {string} */
    text3
  ) : text3 instanceof AbstractType ? new ContentType(text3) : new ContentEmbed(text3);
  let { left, right, index: index2 } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index2;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length4, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop: while (currPos.right !== null && (length4 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
    if (!currPos.right.deleted) {
      switch (currPos.right.content.constructor) {
        case ContentFormat: {
          const { key, value: value2 } = (
            /** @type {ContentFormat} */
            currPos.right.content
          );
          const attr = attributes[key];
          if (attr !== void 0) {
            if (equalAttrs(attr, value2)) {
              negatedAttributes.delete(key);
            } else {
              if (length4 === 0) {
                break iterationLoop;
              }
              negatedAttributes.set(key, value2);
            }
            currPos.right.delete(transaction);
          } else {
            currPos.currentAttributes.set(key, value2);
          }
          break;
        }
        default:
          if (length4 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
          }
          length4 -= currPos.right.length;
          break;
      }
    }
    currPos.forward();
  }
  if (length4 > 0) {
    let newlines = "";
    for (; length4 > 0; length4--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start2, curr, startAttributes, currAttributes) => {
  let end = start2;
  const endFormats = create5();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start2 !== end) {
    if (curr === start2) {
      reachedCurr = true;
    }
    if (!start2.deleted) {
      const content = start2.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value: value2 } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = startAttributes.get(key) ?? null;
          if (endFormats.get(key) !== content || startAttrValue === value2) {
            start2.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key) ?? null) === value2 && startAttrValue !== value2) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start2.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start2 = /** @type {Item} */
    start2.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type3) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type3.doc,
    (transaction) => {
      let start2 = (
        /** @type {Item} */
        type3._start
      );
      let end = type3._start;
      let startAttributes = create5();
      const currentAttributes = copy2(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start2, end, startAttributes, currentAttributes);
              startAttributes = copy2(currentAttributes);
              start2 = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t4) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t4, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length4) => {
  const startLength = length4;
  const startAttrs = copy2(currPos.currentAttributes);
  const start2 = currPos.right;
  while (length4 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length4 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
          }
          length4 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start2) {
    cleanupFormattingGap(transaction, start2, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length4);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y3 = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y3, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value2, key) => {
                      if (value2 !== null) {
                        op.attributes[key] = value2;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign2({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op) delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value: value2 } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key) ?? null;
                  if (!equalAttrs(curVal, value2)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value2, oldAttributes.get(key) ?? null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value2;
                    }
                  } else if (value2 !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value2);
                const curVal = currentAttributes.get(key) ?? null;
                if (!equalAttrs(curVal, value2)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value2);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value2)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value2 === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value2;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class _YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string2) {
    super();
    this._pending = string2 !== void 0 ? [() => this.insert(0, string2)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y3, item) {
    super._integrate(y3, item);
    try {
      this._pending.forEach((f6) => f6());
    } catch (e4) {
      console.error(e4);
    }
    this._pending = null;
  }
  _copy() {
    return new _YText();
  }
  /**
   * @return {YText}
   */
  clone() {
    const text3 = new _YText();
    text3.applyDelta(this.toDelta());
    return text3;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n5 = this._start;
    while (n5 !== null) {
      if (!n5.deleted && n5.countable && n5.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n5.content.str;
      }
      n5 = n5.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i4 = 0; i4 < delta.length; i4++) {
          const op = delta[i4];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i4 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot2, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n5 = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value2, key) => {
          addAttributes = true;
          attributes[key] = value2;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n5 !== null) {
        if (isVisible(n5, snapshot2) || prevSnapshot !== void 0 && isVisible(n5, prevSnapshot)) {
          switch (n5.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot2 !== void 0 && !isVisible(n5, snapshot2)) {
                if (cur === void 0 || cur.user !== n5.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n5.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n5, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n5.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n5.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n5.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n5.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value2, key) => {
                  attrs[key] = value2;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n5, snapshot2)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n5.content
                );
              }
              break;
          }
        }
        n5 = n5.right;
      }
      packStr();
    };
    if (snapshot2 || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot2) {
          splitSnapshotAffectedStructs(transaction, snapshot2);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index2, text3, attributes) {
    if (text3.length <= 0) {
      return;
    }
    const y3 = this.doc;
    if (y3 !== null) {
      transact(y3, (transaction) => {
        const pos = findPosition(transaction, this, index2, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v6, k2) => {
            attributes[k2] = v6;
          });
        }
        insertText(transaction, this, pos, text3, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index2, text3, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index2, embed, attributes) {
    const y3 = this.doc;
    if (y3 !== null) {
      transact(y3, (transaction) => {
        const pos = findPosition(transaction, this, index2, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index2, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index2, length4) {
    if (length4 === 0) {
      return;
    }
    const y3 = this.doc;
    if (y3 !== null) {
      transact(y3, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index2, true), length4);
      });
    } else {
      this._pending.push(() => this.delete(index2, length4));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index2, length4, attributes) {
    if (length4 === 0) {
      return;
    }
    const y3 = this.doc;
    if (y3 !== null) {
      transact(y3, (transaction) => {
        const pos = findPosition(transaction, this, index2, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length4, attributes);
      });
    } else {
      this._pending.push(() => this.format(index2, length4, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f6 = () => true) {
    this._filter = f6;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n5 = this._currentNode;
    let type3 = n5 && n5.content && /** @type {any} */
    n5.content.type;
    if (n5 !== null && (!this._firstCall || n5.deleted || !this._filter(type3))) {
      do {
        type3 = /** @type {any} */
        n5.content.type;
        if (!n5.deleted && (type3.constructor === YXmlElement || type3.constructor === YXmlFragment) && type3._start !== null) {
          n5 = type3._start;
        } else {
          while (n5 !== null) {
            if (n5.right !== null) {
              n5 = n5.right;
              break;
            } else if (n5.parent === this._root) {
              n5 = null;
            } else {
              n5 = /** @type {AbstractType<any>} */
              n5.parent._item;
            }
          }
        }
      } while (n5 !== null && (n5.deleted || !this._filter(
        /** @type {ContentType} */
        n5.content.type
      )));
    }
    this._firstCall = false;
    if (n5 === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n5;
    return { value: (
      /** @type {any} */
      n5.content.type
    ), done: false };
  }
};
var YXmlFragment = class _YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y3, item) {
    super._integrate(y3, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new _YXmlFragment();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const el = new _YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter2) {
    return new YXmlTreeWalker(this, filter2);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next2 = iterator.next();
    if (next2.done) {
      return null;
    } else {
      return next2.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from3(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index2, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index2, content);
      });
    } else {
      this._prelimContent.splice(index2, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index2 = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index2 === 0 && ref !== null) {
        throw create4("Reference item not found");
      }
      pc.splice(index2, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index2, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index2, length4);
      });
    } else {
      this._prelimContent.splice(index2, length4);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index2) {
    return typeListGet(this, index2);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start2 = 0, end = this.length) {
    return typeListSlice(this, start2, end);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f6) {
    typeListForEach(this, f6);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class _YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n5 = this._item ? this._item.next : null;
    return n5 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n5.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n5 = this._item ? this._item.prev : null;
    return n5 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n5.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y3, item) {
    super._integrate(y3, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value2, key) => {
      this.setAttribute(key, value2);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _YXmlElement(this.nodeName);
  }
  /**
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new _YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value2, key) => {
      if (typeof value2 === "string") {
        el.setAttribute(key, value2);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys3 = [];
    for (const key in attrs) {
      keys3.push(key);
    }
    keys3.sort();
    const keysLen = keys3.length;
    for (let i4 = 0; i4 < keysLen; i4++) {
      const key = keys3[i4];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot2) {
    return (
      /** @type {any} */
      snapshot2 ? typeMapGetAllSnapshot(this, snapshot2) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value2 = attrs[key];
      if (typeof value2 === "string") {
        dom.setAttribute(key, value2);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class _YXmlHook extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new _YXmlHook(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const el = new _YXmlHook(this.hookName);
    this.forEach((value2, key) => {
      el.set(key, value2);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class _YXmlText extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n5 = this._item ? this._item.next : null;
    return n5 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n5.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n5 = this._item ? this._item.prev : null;
    return n5 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n5.content.type
    ) : null;
  }
  _copy() {
    return new _YXmlText();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const text3 = new _YXmlText();
    text3.applyDelta(this.toDelta());
    return text3;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a3, b2) => a3.key < b2.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a3, b2) => a3.nodeName < b2.nodeName ? -1 : 1);
      let str = "";
      for (let i4 = 0; i4 < nestedNodes.length; i4++) {
        const node2 = nestedNodes[i4];
        str += `<${node2.nodeName}`;
        for (let j3 = 0; j3 < node2.attrs.length; j3++) {
          const attr = node2.attrs[j3];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i4 = nestedNodes.length - 1; i4 >= 0; i4--) {
        str += `</${nestedNodes[i4].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length4) {
    this.id = id2;
    this.length = length4;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store2) {
    return null;
  }
};
var ContentBinary = class _ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class _ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new _ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class _ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class _ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class _ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value2) {
    this.key = key;
    this.value = value2;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new _ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p4 = (
      /** @type {YText} */
      item.parent
    );
    p4._searchMarker = null;
    p4._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class _ContentJSON {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new _ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i4 = offset; i4 < len; i4++) {
      const c6 = this.arr[i4];
      encoder.writeString(c6 === void 0 ? "undefined" : JSON.stringify(c6));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i4 = 0; i4 < len; i4++) {
    const c6 = decoder.readString();
    if (c6 === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c6));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class _ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new _ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new _ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i4 = offset; i4 < len; i4++) {
      const c6 = this.arr[i4];
      encoder.writeAny(c6);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i4 = 0; i4 < len; i4++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class _ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new _ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new _ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "�";
      right.str = "�" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class _ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type3) {
    this.type = type3;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new _ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store2) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store2, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store2, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var followRedone = (store2, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store2, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
var keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = /** @type {AbstractType<any>} */
    item.parent._item;
  }
};
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var isDeletedByUndoStack = (stack, id2) => some(
  stack,
  /** @param {StackItem} s */
  (s4) => isDeleted(s4.deletions, id2)
);
var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
  const doc2 = transaction.doc;
  const store2 = doc2.store;
  const ownClientID = doc2.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction, redone);
  }
  let parentItem = (
    /** @type {AbstractType<any>} */
    item.parent._item
  );
  let left = null;
  let right;
  if (parentItem !== null && parentItem.deleted === true) {
    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
      return null;
    }
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
  }
  const parentType = parentItem === null ? (
    /** @type {AbstractType<any>} */
    item.parent
  ) : (
    /** @type {ContentType} */
    parentItem.content.type
  );
  if (item.parentSub === null) {
    left = item.left;
    right = item;
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
      }
      if (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
      }
      if (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
  } else {
    right = null;
    if (item.right && !ignoreRemoteMapChanges) {
      left = item;
      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
        left = left.right;
        while (left.redone) left = getItemCleanStart(transaction, left.redone);
      }
      if (left && left.right !== null) {
        return null;
      }
    } else {
      left = parentType._map.get(item.parentSub) || null;
    }
  }
  const nextClock = getState(store2, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item(
    nextId,
    left,
    left && left.lastId,
    right,
    right && right.id,
    parentType,
    item.parentSub,
    item.content.copy()
  );
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction, 0);
  return redoneItem;
};
var Item = class _Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store2) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store2, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store2, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store2, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store2, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === _Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === _Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store2, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o3;
        if (left !== null) {
          o3 = left.right;
        } else if (this.parentSub !== null) {
          o3 = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o3 !== null && o3.left !== null) {
            o3 = o3.left;
          }
        } else {
          o3 = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o3 !== null && o3 !== this.right) {
          itemsBeforeOrigin.add(o3);
          conflictingItems.add(o3);
          if (compareIDs(this.origin, o3.origin)) {
            if (o3.id.client < this.id.client) {
              left = o3;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o3.rightOrigin)) {
              break;
            }
          } else if (o3.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o3.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o3.origin))) {
              left = o3;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o3 = o3.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r6;
        if (this.parentSub !== null) {
          r6 = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r6 !== null && r6.left !== null) {
            r6 = r6.left;
          }
        } else {
          r6 = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r6;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n5 = this.right;
    while (n5 !== null && n5.deleted) {
      n5 = n5.right;
    }
    return n5;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n5 = this.left;
    while (n5 !== null && n5.deleted) {
      n5 = n5.left;
    }
    return n5;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store2, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store2);
    if (parentGCd) {
      replaceStruct(store2, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store2) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value2) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value2
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i4 = 0; i4 < clients.length; i4++) {
    const clientID = clients[i4];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder = createEncoder();
  writeVarUint(encoder, len);
  for (let i4 = 0; i4 < len; i4++) {
    const clientID = clients[i4];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint(encoder, clientID);
    writeVarUint(encoder, clock);
    writeVarString(encoder, JSON.stringify(state));
  }
  return toUint8Array(encoder);
};
var applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = createDecoder(update);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder);
  for (let i4 = 0; i4 < len; i4++) {
    const clientID = readVarUint(decoder);
    let clock = readVarUint(decoder);
    const state = JSON.parse(readVarString(decoder));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// node_modules/idb/build/wrap-idb-value.js
var instanceOfAny = (object3, constructors) => constructors.some((c6) => object3 instanceof c6);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var cursorRequestMap = /* @__PURE__ */ new WeakMap();
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error2);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error2 = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error2);
  });
  promise.then((value2) => {
    if (value2 instanceof IDBCursor) {
      cursorRequestMap.set(value2, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error2);
      tx.removeEventListener("abort", error2);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error2 = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error2);
    tx.addEventListener("abort", error2);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value2) {
    target[prop] = value2;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args2) {
      const tx = func.call(unwrap(this), storeNames, ...args2);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args2) {
      func.apply(unwrap(this), args2);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args2) {
    return wrap(func.apply(unwrap(this), args2));
  };
}
function transformCachableValue(value2) {
  if (typeof value2 === "function")
    return wrapFunction(value2);
  if (value2 instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value2);
  if (instanceOfAny(value2, getIdbProxyableTypes()))
    return new Proxy(value2, idbProxyTraps);
  return value2;
}
function wrap(value2) {
  if (value2 instanceof IDBRequest)
    return promisifyRequest(value2);
  if (transformCache.has(value2))
    return transformCache.get(value2);
  const newValue = transformCachableValue(value2);
  if (newValue !== value2) {
    transformCache.set(value2, newValue);
    reverseTransformCache.set(newValue, value2);
  }
  return newValue;
}
var unwrap = (value2) => reverseTransformCache.get(value2);

// node_modules/idb/build/index.js
function openDB(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args2) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args2.shift());
    return (await Promise.all([
      target2[targetFuncName](...args2),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// node_modules/y-provider/dist/index.js
function A2(t4, n5 = "val does not exist") {
  if (t4 == null)
    throw n5 instanceof Error ? n5 : new Error(n5);
}
function x2(t4, n5) {
  if (t4.guid === n5)
    return t4;
  for (const r6 of t4.subdocs) {
    const a3 = x2(r6, n5);
    if (a3)
      return a3;
  }
}
var j2 = (t4, n5, r6 = {}) => {
  let a3 = false;
  const o3 = /* @__PURE__ */ new Map(), f6 = /* @__PURE__ */ new Map(), g4 = /* @__PURE__ */ new Set();
  let y3 = null;
  const { origin: h3 = "lazy-provider" } = r6;
  let b2 = {
    type: "idle"
  }, D2 = 0;
  const v6 = /* @__PURE__ */ new Set(), l6 = (e4) => {
    e4.type === "syncing" ? D2++ : (e4.type === "synced" || e4.type === "error") && D2--, D2 < 0 && console.error(
      "syncingStatus < 0, this should not happen",
      r6.origin
    ), D2 === 0 && (b2 = e4), e4.type !== "synced" && (b2 = e4), D2 === 0 && (a3 ? b2 = {
      type: "synced"
    } : b2 = {
      type: "idle"
    }), v6.forEach((s4) => s4());
  };
  async function S2(e4) {
    const s4 = e4.guid;
    {
      const c6 = s4.startsWith("space:") ? s4.slice(6) : s4, d5 = `${t4.guid}:space:${c6}`, p4 = `space:${c6}`, u4 = await n5.queryDocState(d5), w2 = await n5.queryDocState(p4);
      let U2 = false;
      u4 && u4.missing.length !== 2 && u4.missing[0] !== 0 && u4.missing[1] !== 0 && (applyUpdate(e4, u4.missing, h3), U2 = true), w2 && w2.missing.length !== 2 && w2.missing[0] !== 0 && w2.missing[1] !== 0 && (applyUpdate(e4, w2.missing, h3), U2 = true), U2 && await n5.sendDocUpdate(
        s4,
        encodeStateAsUpdate(
          e4,
          u4 ? u4.state : w2 ? w2.state : void 0
        )
      );
    }
    if (!a3)
      return;
    l6({
      type: "syncing"
    });
    const i4 = await n5.queryDocState(s4, {
      stateVector: encodeStateVector(e4)
    }).then((c6) => (l6({
      type: "synced"
    }), c6)).catch((c6) => {
      throw l6({
        type: "error",
        error: c6
      }), c6;
    });
    o3.set(s4, []), i4 && applyUpdate(e4, i4.missing, h3), a3 && (await n5.sendDocUpdate(
      s4,
      encodeStateAsUpdate(e4, i4 ? i4.state : void 0)
    ), e4.emit("sync", []));
  }
  function M2(e4) {
    const s4 = /* @__PURE__ */ new Set();
    f6.set(e4.guid, s4);
    const i4 = async (d5, p4) => {
      h3 !== p4 && (l6({
        type: "syncing"
      }), n5.sendDocUpdate(e4.guid, d5).then(() => {
        l6({
          type: "synced"
        });
      }).catch((u4) => {
        l6({
          type: "error",
          error: u4
        }), console.error(u4);
      }));
    }, c6 = (d5) => {
      d5.loaded.forEach((p4) => {
        E3(p4).catch(console.error);
      }), d5.removed.forEach((p4) => {
        L2(p4);
      });
    };
    e4.on("update", i4), e4.on("subdocs", c6), s4.add(() => {
      e4.off("update", i4), e4.off("subdocs", c6);
    });
  }
  function V() {
    var s4;
    A2(y3, "abortController should be defined");
    const e4 = (s4 = n5.onDocUpdate) == null ? void 0 : s4.call(n5, (i4, c6) => {
      var p4;
      l6({
        type: "syncing"
      });
      const d5 = x2(t4, i4);
      d5 ? (applyUpdate(d5, c6, h3), o3.has(i4) && ((p4 = o3.get(i4)) == null || p4.forEach((u4) => applyUpdate(d5, u4, h3)), o3.delete(i4))) : (console.warn("doc not found", i4), o3.set(i4, (o3.get(i4) ?? []).concat(c6))), l6({
        type: "synced"
      });
    });
    y3.signal.addEventListener("abort", () => {
      e4 == null || e4();
    });
  }
  async function E3(e4) {
    g4.has(e4.guid) || (g4.add(e4.guid), M2(e4), await S2(e4), await Promise.all(
      [...e4.subdocs].filter((s4) => s4.shouldLoad).map((s4) => E3(s4))
    ));
  }
  function L2(e4) {
    g4.delete(e4.guid);
    const s4 = f6.get(e4.guid);
    s4 && (s4.forEach((i4) => i4()), f6.delete(e4.guid)), e4.subdocs.forEach(L2);
  }
  function $() {
    f6.forEach((e4) => {
      e4.forEach((s4) => s4());
    }), f6.clear(), g4.clear();
  }
  function R2() {
    a3 = true, y3 = new AbortController(), l6({
      type: "syncing"
    }), E3(t4).then(() => {
      l6({
        type: "synced"
      });
    }).catch((e4) => {
      l6({
        type: "error",
        error: e4
      }), console.error(e4);
    }), V();
  }
  async function k2() {
    a3 = false, $(), A2(y3, "abortController should be defined"), y3.abort(), y3 = null;
  }
  const P2 = async (e4) => {
    await S2(e4), await Promise.all(
      [...e4.subdocs.values()].map((s4) => P2(s4))
    );
  };
  return {
    sync: async (e4) => {
      a3 = true;
      try {
        e4 ? await S2(t4) : await P2(t4);
      } finally {
        a3 = false;
      }
    },
    get status() {
      return b2;
    },
    subscribeStatusChange(e4) {
      return v6.add(e4), () => {
        v6.delete(e4);
      };
    },
    get connected() {
      return a3;
    },
    passive: true,
    connect: R2,
    disconnect: k2,
    datasource: n5
  };
};
var C = (t4) => (t4.preventDefault(), t4.returnValue = "Data is not saved. Are you sure you want to leave?");
var B2 = async (t4) => {
  window.addEventListener("beforeunload", C, {
    capture: true
  }), await t4, window.removeEventListener("beforeunload", C, {
    capture: true
  });
};

// node_modules/@toeverything/y-indexeddb/dist/index.js
var m = 1;
var l2 = "affine-local";
function f2(e4) {
  e4.createObjectStore("workspace", { keyPath: "id" }), e4.createObjectStore("milestone", { keyPath: "id" });
}
function E2(e4, n5 = "val does not exist") {
  if (e4 == null)
    throw n5 instanceof Error ? n5 : new Error(n5);
}
function g2(e4) {
  const n5 = new Doc();
  return e4.forEach((a3) => {
    applyUpdate(n5, a3);
  }), encodeStateAsUpdate(n5);
}
var v2 = 500;
var T = ({
  dbName: e4 = l2,
  mergeCount: n5
}) => {
  let a3 = null;
  const t4 = async () => (a3 === null && (a3 = openDB(e4, m, {
    upgrade: f2
  })), a3);
  return {
    ...{
      queryDocState: async (r6, o3) => {
        var i4;
        try {
          const u4 = await (await t4()).transaction("workspace", "readonly").objectStore("workspace").get(r6);
          if (!u4)
            return false;
          const { updates: w2 } = u4, b2 = g2(w2.map(({ update: x3 }) => x3));
          return { missing: o3 != null && o3.stateVector ? diffUpdate(b2, o3 == null ? void 0 : o3.stateVector) : b2, state: encodeStateVectorFromUpdate(b2) };
        } catch (s4) {
          if (!((i4 = s4.message) != null && i4.includes("The database connection is closing.")))
            throw s4;
          return false;
        }
      },
      sendDocUpdate: async (r6, o3) => {
        var i4;
        try {
          const d5 = (await t4()).transaction("workspace", "readwrite").objectStore("workspace"), { updates: u4 } = await d5.get(r6) ?? { updates: [] };
          let w2 = [
            ...u4,
            { timestamp: Date.now(), update: o3 }
          ];
          if (n5 && w2.length >= n5) {
            const b2 = g2(w2.map(({ update: k2 }) => k2));
            w2 = [{ timestamp: Date.now(), update: b2 }];
          }
          await B2(
            d5.put({
              id: r6,
              updates: w2
            })
          );
        } catch (s4) {
          if (!((i4 = s4.message) != null && i4.includes("The database connection is closing.")))
            throw s4;
        }
      }
    },
    disconnect: () => {
      t4().then((r6) => r6.close()).then(() => {
        a3 = null;
      }).catch(console.error);
    },
    cleanup: async () => {
      await (await t4()).clear("workspace");
    }
  };
};
var W2 = (e4, n5 = l2) => {
  const a3 = T({ dbName: n5, mergeCount: v2 });
  let t4 = null;
  const c6 = {
    get status() {
      return E2(t4), t4.status;
    },
    subscribeStatusChange(r6) {
      return E2(t4), t4.subscribeStatusChange(r6);
    },
    connect: () => {
      c6.connected && c6.disconnect(), t4 = j2(e4, a3, { origin: "idb" }), t4.connect();
    },
    disconnect: () => {
      a3 == null || a3.disconnect(), t4 == null || t4.disconnect(), t4 = null;
    },
    cleanup: async () => {
      await (a3 == null ? void 0 : a3.cleanup());
    },
    get connected() {
      return (t4 == null ? void 0 : t4.connected) || false;
    },
    datasource: a3
  };
  return c6;
};

// node_modules/lib0/broadcastchannel.js
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  /**
   * @param {string} room
   */
  constructor(room) {
    this.room = room;
    this.onmessage = null;
    this._onChange = (e4) => e4.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e4.newValue || "") });
    onChange(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(buf) {
    varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
  close() {
    offChange(this._onChange);
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room) => setIfUndefined(channels, room, () => {
  const subs = create3();
  const bc = new BC(room);
  bc.onmessage = (e4) => subs.forEach((sub) => sub(e4.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe2 = (room, f6) => {
  getChannel(room).subs.add(f6);
  return f6;
};
var unsubscribe = (room, f6) => {
  const channel = getChannel(room);
  const unsubscribed = channel.subs.delete(f6);
  if (unsubscribed && channel.subs.size === 0) {
    channel.bc.close();
    channels.delete(room);
  }
  return unsubscribed;
};
var publish = (room, data, origin = null) => {
  const c6 = getChannel(room);
  c6.bc.postMessage(data);
  c6.subs.forEach((sub) => sub(data, origin));
};

// node_modules/y-protocols/sync.js
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder, doc2) => {
  writeVarUint(encoder, messageYjsSyncStep1);
  const sv = encodeStateVector(doc2);
  writeVarUint8Array(encoder, sv);
};
var writeSyncStep2 = (encoder, doc2, encodedStateVector) => {
  writeVarUint(encoder, messageYjsSyncStep2);
  writeVarUint8Array(encoder, encodeStateAsUpdate(doc2, encodedStateVector));
};
var readSyncStep1 = (decoder, encoder, doc2) => writeSyncStep2(encoder, doc2, readVarUint8Array(decoder));
var readSyncStep2 = (decoder, doc2, transactionOrigin) => {
  try {
    applyUpdate(doc2, readVarUint8Array(decoder), transactionOrigin);
  } catch (error2) {
    console.error("Caught error while handling a Yjs update", error2);
  }
};
var writeUpdate = (encoder, update) => {
  writeVarUint(encoder, messageYjsUpdate);
  writeVarUint8Array(encoder, update);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder, encoder, doc2, transactionOrigin) => {
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc2);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc2, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder, doc2, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};

// node_modules/y-protocols/auth.js
var messagePermissionDenied = 0;
var readAuthMessage = (decoder, y3, permissionDeniedHandler2) => {
  switch (readVarUint(decoder)) {
    case messagePermissionDenied:
      permissionDeniedHandler2(y3, readVarString(decoder));
  }
};

// node_modules/lib0/mutex.js
var createMutex = () => {
  let token2 = true;
  return (f6, g4) => {
    if (token2) {
      token2 = false;
      try {
        f6();
      } finally {
        token2 = true;
      }
    } else if (g4 !== void 0) {
      g4();
    }
  };
};

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache3 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache3.has(arg)) {
      return cache3.get(arg);
    }
    var ret = func(arg);
    cache3.set(arg, ret);
    return ret;
  };
};

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 8,
  patch: 1,
  preReleaseTag: null
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value2) {
  return typeof value2 == "object" && value2 !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position2) {
  let lastLineStart = 0;
  let line2 = 1;
  for (const match2 of source.body.matchAll(LineRegExp)) {
    typeof match2.index === "number" || invariant(false);
    if (match2.index >= position2) {
      break;
    }
    lastLineStart = match2.index + match2[0].length;
    line2 += 1;
  }
  return {
    line: line2,
    column: position2 + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(
    location2.source,
    getLocation(location2.source, location2.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i4 = 0; i4 < locationLine.length; i4 += 80) {
      subLines.push(locationLine.slice(i4, i4 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_2, line2]) => line2 !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix4]) => prefix4.length));
  return existingLines.map(([prefix4, line2]) => prefix4.padStart(padLen) + (line2 ? " " + line2 : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args2) {
  const firstArg = args2[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args2[1],
      positions: args2[2],
      path: args2[3],
      originalError: args2[4],
      extensions: args2[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node2) => node2.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node2 of this.nodes) {
        if (node2.loc) {
          output += "\n\n" + printLocation(node2.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location2 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location2);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array2) {
  return array2 === void 0 || array2.length === 0 ? void 0 : array2;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position2, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position2]
  });
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start2, end, line2, column2, value2) {
    this.kind = kind;
    this.start = start2;
    this.end = end;
    this.line = line2;
    this.column = column2;
    this.value = value2;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode2(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i4 = 0; i4 < lines.length; ++i4) {
    var _firstNonEmptyLine;
    const line2 = lines[i4];
    const indent2 = leadingWhitespace(line2);
    if (indent2 === line2.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i4;
    lastNonEmptyLine = i4;
    if (i4 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line2, i4) => i4 === 0 ? line2 : line2.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i4 = 0;
  while (i4 < str.length && isWhiteSpace(str.charCodeAt(i4))) {
    ++i4;
  }
  return i4;
}
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line2) => line2.length === 0 || isWhiteSpace(line2.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token2 = this.token = this.lookahead();
    return token2;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token2 = this.token;
    if (token2.kind !== TokenKind.EOF) {
      do {
        if (token2.next) {
          token2 = token2.next;
        } else {
          const nextToken = readNextToken(this, token2.end);
          token2.next = nextToken;
          nextToken.prev = token2;
          token2 = nextToken;
        }
      } while (token2.kind === TokenKind.COMMENT);
    }
    return token2;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location2) {
  return isLeadingSurrogate(body.charCodeAt(location2)) && isTrailingSurrogate(body.charCodeAt(location2 + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location2) {
  const code = lexer.source.body.codePointAt(location2);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char2 = String.fromCodePoint(code);
    return char2 === '"' ? `'"'` : `"${char2}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start2, end, value2) {
  const line2 = lexer.line;
  const col = 1 + start2 - lexer.lineStart;
  return new Token(kind, start2, end, line2, col, value2);
}
function readNextToken(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start2;
  while (position2 < bodyLength) {
    const code = body.charCodeAt(position2);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position2;
        continue;
      case 10:
        ++position2;
        ++lexer.line;
        lexer.lineStart = position2;
        continue;
      case 13:
        if (body.charCodeAt(position2 + 1) === 10) {
          position2 += 2;
        } else {
          ++position2;
        }
        ++lexer.line;
        lexer.lineStart = position2;
        continue;
      case 35:
        return readComment(lexer, position2);
      case 33:
        return createToken(lexer, TokenKind.BANG, position2, position2 + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position2, position2 + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position2, position2 + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position2, position2 + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position2, position2 + 1);
      case 46:
        if (body.charCodeAt(position2 + 1) === 46 && body.charCodeAt(position2 + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position2, position2 + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position2, position2 + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position2, position2 + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position2, position2 + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position2, position2 + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position2, position2 + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position2, position2 + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position2, position2 + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position2, position2 + 1);
      case 34:
        if (body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
          return readBlockString(lexer, position2);
        }
        return readString(lexer, position2);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position2, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position2);
    }
    throw syntaxError(
      lexer.source,
      position2,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position2) ? `Unexpected character: ${printCodePointAt(lexer, position2)}.` : `Invalid character: ${printCodePointAt(lexer, position2)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start2 + 1;
  while (position2 < bodyLength) {
    const code = body.charCodeAt(position2);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start2,
    position2,
    body.slice(start2 + 1, position2)
  );
}
function readNumber(lexer, start2, firstCode) {
  const body = lexer.source.body;
  let position2 = start2;
  let code = firstCode;
  let isFloat2 = false;
  if (code === 45) {
    code = body.charCodeAt(++position2);
  }
  if (code === 48) {
    code = body.charCodeAt(++position2);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  } else {
    position2 = readDigits(lexer, position2, code);
    code = body.charCodeAt(position2);
  }
  if (code === 46) {
    isFloat2 = true;
    code = body.charCodeAt(++position2);
    position2 = readDigits(lexer, position2, code);
    code = body.charCodeAt(position2);
  }
  if (code === 69 || code === 101) {
    isFloat2 = true;
    code = body.charCodeAt(++position2);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position2);
    }
    position2 = readDigits(lexer, position2, code);
    code = body.charCodeAt(position2);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position2,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position2
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat2 ? TokenKind.FLOAT : TokenKind.INT,
    start2,
    position2,
    body.slice(start2, position2)
  );
}
function readDigits(lexer, start2, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start2,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start2
      )}.`
    );
  }
  const body = lexer.source.body;
  let position2 = start2 + 1;
  while (isDigit(body.charCodeAt(position2))) {
    ++position2;
  }
  return position2;
}
function readString(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start2 + 1;
  let chunkStart = position2;
  let value2 = "";
  while (position2 < bodyLength) {
    const code = body.charCodeAt(position2);
    if (code === 34) {
      value2 += body.slice(chunkStart, position2);
      return createToken(lexer, TokenKind.STRING, start2, position2 + 1, value2);
    }
    if (code === 92) {
      value2 += body.slice(chunkStart, position2);
      const escape2 = body.charCodeAt(position2 + 1) === 117 ? body.charCodeAt(position2 + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position2) : readEscapedUnicodeFixedWidth(lexer, position2) : readEscapedCharacter(lexer, position2);
      value2 += escape2.value;
      position2 += escape2.size;
      chunkStart = position2;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position2, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position2) {
  const body = lexer.source.body;
  let point = 0;
  let size3 = 3;
  while (size3 < 12) {
    const code = body.charCodeAt(position2 + size3++);
    if (code === 125) {
      if (size3 < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size: size3
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid Unicode escape sequence: "${body.slice(
      position2,
      position2 + size3
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position2) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position2 + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position2 + 6) === 92 && body.charCodeAt(position2 + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position2 + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid Unicode escape sequence: "${body.slice(position2, position2 + 6)}".`
  );
}
function read16BitHexCode(body, position2) {
  return readHexDigit(body.charCodeAt(position2)) << 12 | readHexDigit(body.charCodeAt(position2 + 1)) << 8 | readHexDigit(body.charCodeAt(position2 + 2)) << 4 | readHexDigit(body.charCodeAt(position2 + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position2) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position2 + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid character escape sequence: "${body.slice(
      position2,
      position2 + 2
    )}".`
  );
}
function readBlockString(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position2 = start2 + 3;
  let chunkStart = position2;
  let currentLine = "";
  const blockLines = [];
  while (position2 < bodyLength) {
    const code = body.charCodeAt(position2);
    if (code === 34 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
      currentLine += body.slice(chunkStart, position2);
      blockLines.push(currentLine);
      const token2 = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start2,
        position2 + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token2;
    }
    if (code === 92 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34 && body.charCodeAt(position2 + 3) === 34) {
      currentLine += body.slice(chunkStart, position2);
      chunkStart = position2 + 1;
      position2 += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position2);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position2 + 1) === 10) {
        position2 += 2;
      } else {
        ++position2;
      }
      currentLine = "";
      chunkStart = position2;
      lineStart = position2;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position2, "Unterminated string.");
}
function readName(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start2 + 1;
  while (position2 < bodyLength) {
    const code = body.charCodeAt(position2);
    if (isNameContinue(code)) {
      ++position2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start2,
    position2,
    body.slice(start2, position2)
  );
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue(value2, []);
}
function formatValue(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object3, seenValues) {
  const entries2 = Object.entries(object3);
  if (entries2.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object3) + "]";
  }
  const properties = entries2.map(
    ([key, value2]) => key + ": " + formatValue(value2, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array2, seenValues) {
  if (array2.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
  const remaining = array2.length - len;
  const items = [];
  for (let i4 = 0; i4 < len; ++i4) {
    items.push(formatValue(array2[i4], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object3) {
  const tag = Object.prototype.toString.call(object3).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object3.constructor === "function") {
    const name = object3.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value2, constructor) {
    return value2 instanceof constructor;
  } : function instanceOf3(value2, constructor) {
    if (value2 instanceof constructor) {
      return true;
    }
    if (typeof value2 === "object" && value2 !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value2 ? value2[Symbol.toStringTag] : (_value$constructor = value2.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value2);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/graphql/language/parser.mjs
function parse3(source, options) {
  const parser = new Parser2(source, options);
  return parser.parseDocument();
}
var Parser2 = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token2 = this.expectToken(TokenKind.NAME);
    return this.node(token2, {
      kind: Kind.NAME,
      value: token2.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start2 = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start2, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start2, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start2, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start2 = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start2, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start2 = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start2, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start2, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start2, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start2 = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start2, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start2, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token2 = this._lexer.token;
    switch (token2.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.INT,
          value: token2.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.FLOAT,
          value: token2.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token2.value) {
          case "true":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token2, {
              kind: Kind.NULL
            });
          default:
            return this.node(token2, {
              kind: Kind.ENUM,
              value: token2.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token2.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token2);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token2 = this._lexer.token;
    this.advanceLexer();
    return this.node(token2, {
      kind: Kind.STRING,
      value: token2.value,
      block: token2.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start2 = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start2, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives2 = [];
    while (this.peek(TokenKind.AT)) {
      directives2.push(this.parseDirective(isConst));
    }
    return directives2;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start2, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start2 = this._lexer.token;
    let type3;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type3 = this.node(start2, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type3 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start2, {
        kind: Kind.NON_NULL_TYPE,
        type: type3
      });
    }
    return type3;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives2 = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start2, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives: directives2,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start2 = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type3 = this.parseNamedType();
    return this.node(start2, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type3
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives: directives2
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start2, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args2 = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type3 = this.parseTypeReference();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args2,
      type: type3,
      directives: directives2
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type3 = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type: type3,
      defaultValue,
      directives: directives2
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start2, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives2 = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start2, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives: directives2,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives2 = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start2, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives: directives2,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives: directives2
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start2, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives: directives2,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives2 = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives2.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.SCHEMA_EXTENSION,
      directives: directives2,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives2 = this.parseConstDirectives();
    if (directives2.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives: directives2
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives2 = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives2.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives: directives2,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives2 = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives2.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives: directives2,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives: directives2,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args2 = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start2, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args2,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start2 = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start2);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node2) {
    if (this._options.noLocation !== true) {
      node2.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node2;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return token2;
    }
    throw syntaxError(
      this._lexer.source,
      token2.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token2)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value2) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value2) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token2.start,
        `Expected "${value2}", found ${getTokenDesc(token2)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value2) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value2) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token2.start,
      `Unexpected ${getTokenDesc(token2)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token2 = this._lexer.advance();
    if (maxTokens !== void 0 && token2.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token2.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token2) {
  const value2 = token2.value;
  return getTokenKindDesc(token2.kind) + (value2 != null ? ` "${value2}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x3) => `"${x3}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x3) {
  return x3;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map4, fn2) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map4)) {
    result[key] = fn2(map4[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a3, b2) => {
    const distanceDiff = optionsByDistance[a3] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a3, b2);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a3 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a3.length < b2.length) {
      const tmp = a3;
      a3 = b2;
      b2 = tmp;
    }
    const aLength = a3.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j3 = 0; j3 <= bLength; j3++) {
      rows[0][j3] = j3;
    }
    for (let i4 = 1; i4 <= aLength; i4++) {
      const upRow = rows[(i4 - 1) % 3];
      const currentRow = rows[i4 % 3];
      let smallestCell = currentRow[0] = i4;
      for (let j3 = 1; j3 <= bLength; j3++) {
        const cost = a3[i4 - 1] === b2[j3 - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j3] + 1,
          // delete
          currentRow[j3 - 1] + 1,
          // insert
          upRow[j3 - 1] + cost
          // substitute
        );
        if (i4 > 1 && j3 > 1 && a3[i4 - 1] === b2[j3 - 2] && a3[i4 - 2] === b2[j3 - 1]) {
          const doubleDiagonalCell = rows[(i4 - 2) % 3][j3 - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j3] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array2 = new Array(strLength);
  for (let i4 = 0; i4 < strLength; ++i4) {
    array2[i4] = str.charCodeAt(i4);
  }
  return array2;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map4 = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    map4[key] = value2;
  }
  return map4;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys3 = [root];
  let index2 = -1;
  let edits = [];
  let node2 = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys3.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node2 = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node2 = node2.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node2.splice(arrayKey, 1);
              editOffset++;
            } else {
              node2[arrayKey] = editValue;
            }
          }
        } else {
          node2 = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node2)
          );
          for (const [editKey, editValue] of edits) {
            node2[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys3 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys3[index2];
      node2 = parent[key];
      if (node2 === null || node2 === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node2)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode2(node2) || devAssert(false, `Invalid AST Node: ${inspect(node2)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node2, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode2(result)) {
            node2 = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node2]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys: keys3,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node2);
      keys3 = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node2;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print2(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node2) => node2.value
  },
  Variable: {
    leave: (node2) => "$" + node2.name
  },
  // Document
  Document: {
    leave: (node2) => join(node2.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node2) {
      const varDefs = wrap2("(", join(node2.variableDefinitions, ", "), ")");
      const prefix4 = join(
        [
          node2.operation,
          join([node2.name, varDefs]),
          join(node2.directives, " ")
        ],
        " "
      );
      return (prefix4 === "query" ? "" : prefix4 + " ") + node2.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type3, defaultValue, directives: directives2 }) => variable + ": " + type3 + wrap2(" = ", defaultValue) + wrap2(" ", join(directives2, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args2, directives: directives2, selectionSet: selectionSet2 }) {
      const prefix4 = wrap2("", alias, ": ") + name;
      let argsLine = prefix4 + wrap2("(", join(args2, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix4 + wrap2("(\n", indent(join(args2, "\n")), "\n)");
      }
      return join([argsLine, join(directives2, " "), selectionSet2], " ");
    }
  },
  Argument: {
    leave: ({ name, value: value2 }) => name + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives: directives2 }) => "..." + name + wrap2(" ", join(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives: directives2, selectionSet: selectionSet2 }) => join(
      [
        "...",
        wrap2("on ", typeCondition),
        join(directives2, " "),
        selectionSet2
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives: directives2, selectionSet: selectionSet2 }) => (
      // or removed in the future.
      `fragment ${name}${wrap2("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join(directives2, " "), " ")}` + selectionSet2
    )
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value: value2 }) => name + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args2 }) => "@" + name + wrap2("(", join(args2, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type: type3 }) => "[" + type3 + "]"
  },
  NonNullType: {
    leave: ({ type: type3 }) => type3 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives: directives2, operationTypes }) => wrap2("", description, "\n") + join(["schema", join(directives2, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type3 }) => operation + ": " + type3
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives: directives2 }) => wrap2("", description, "\n") + join(["scalar", name, join(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives: directives2, fields }) => wrap2("", description, "\n") + join(
      [
        "type",
        name,
        wrap2("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args2, type: type3, directives: directives2 }) => wrap2("", description, "\n") + name + (hasMultilineItems(args2) ? wrap2("(\n", indent(join(args2, "\n")), "\n)") : wrap2("(", join(args2, ", "), ")")) + ": " + type3 + wrap2(" ", join(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type: type3, defaultValue, directives: directives2 }) => wrap2("", description, "\n") + join(
      [name + ": " + type3, wrap2("= ", defaultValue), join(directives2, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives: directives2, fields }) => wrap2("", description, "\n") + join(
      [
        "interface",
        name,
        wrap2("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives: directives2, types }) => wrap2("", description, "\n") + join(
      ["union", name, join(directives2, " "), wrap2("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives: directives2, values }) => wrap2("", description, "\n") + join(["enum", name, join(directives2, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives: directives2 }) => wrap2("", description, "\n") + join([name, join(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives: directives2, fields }) => wrap2("", description, "\n") + join(["input", name, join(directives2, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args2, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name + (hasMultilineItems(args2) ? wrap2("(\n", indent(join(args2, "\n")), "\n)") : wrap2("(", join(args2, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join(
      ["extend schema", join(directives2, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives: directives2 }) => join(["extend scalar", name, join(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives: directives2, fields }) => join(
      [
        "extend type",
        name,
        wrap2("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives: directives2, fields }) => join(
      [
        "extend interface",
        name,
        wrap2("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives: directives2, types }) => join(
      [
        "extend union",
        name,
        join(directives2, " "),
        wrap2("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives: directives2, values }) => join(["extend enum", name, join(directives2, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives: directives2, fields }) => join(["extend input", name, join(directives2, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x3) => x3).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array2) {
  return wrap2("{\n", indent(join(array2, "\n")), "\n}");
}
function wrap2(start2, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start2 + maybeString + end : "";
}
function indent(str) {
  return wrap2("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node2) => valueFromASTUntyped(node2, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i4 = 1; i4 < name.length; ++i4) {
    if (!isNameContinue(name.charCodeAt(i4))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// node_modules/graphql/type/definition.mjs
function isType(type3) {
  return isScalarType(type3) || isObjectType(type3) || isInterfaceType(type3) || isUnionType(type3) || isEnumType(type3) || isInputObjectType(type3) || isListType(type3) || isNonNullType(type3);
}
function isScalarType(type3) {
  return instanceOf(type3, GraphQLScalarType);
}
function isObjectType(type3) {
  return instanceOf(type3, GraphQLObjectType);
}
function isInterfaceType(type3) {
  return instanceOf(type3, GraphQLInterfaceType);
}
function isUnionType(type3) {
  return instanceOf(type3, GraphQLUnionType);
}
function isEnumType(type3) {
  return instanceOf(type3, GraphQLEnumType);
}
function isInputObjectType(type3) {
  return instanceOf(type3, GraphQLInputObjectType);
}
function isListType(type3) {
  return instanceOf(type3, GraphQLList);
}
function isNonNullType(type3) {
  return instanceOf(type3, GraphQLNonNull);
}
function isInputType(type3) {
  return isScalarType(type3) || isEnumType(type3) || isInputObjectType(type3) || isWrappingType(type3) && isInputType(type3.ofType);
}
function isLeafType(type3) {
  return isScalarType(type3) || isEnumType(type3);
}
function isCompositeType(type3) {
  return isObjectType(type3) || isInterfaceType(type3) || isUnionType(type3);
}
function isAbstractType(type3) {
  return isInterfaceType(type3) || isUnionType(type3);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type3) {
  return isListType(type3) || isNonNullType(type3);
}
function isNullableType(type3) {
  return isType(type3) && !isNonNullType(type3);
}
function getNullableType(type3) {
  if (type3) {
    return isNonNullType(type3) ? type3.ofType : type3;
  }
}
function getNamedType(type3) {
  if (type3) {
    let unwrappedType = type3;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node2, variables) => parseValue2(valueFromASTUntyped(node2, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args2) {
  return keyValMap(
    args2,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(
      this._values.map((enumValue) => [enumValue.value, enumValue])
    );
    this._nameLookup = keyMap(this._values, (value2) => value2.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name) {
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print2(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print2(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value2) => value2.name,
      (value2) => ({
        description: value2.description,
        value: value2.value,
        deprecationReason: value2.deprecationReason,
        extensions: value2.extensions,
        astNode: value2.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value2) => value2.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type3) => schema.isSubType(typeB, type3));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print2(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print2(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print2(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print2(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print2(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args2 = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args2) && !Array.isArray(args2) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args2);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value2, type3) {
  if (isNonNullType(type3)) {
    const astValue = astFromValue(value2, type3.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value2 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value2 === void 0) {
    return null;
  }
  if (isListType(type3)) {
    const itemType = type3.ofType;
    if (isIterableObject(value2)) {
      const valuesNodes = [];
      for (const item of value2) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value2, itemType);
  }
  if (isInputObjectType(type3)) {
    if (!isObjectLike(value2)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type3.getFields())) {
      const fieldValue = astFromValue(value2[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type3)) {
    const serialized = type3.serialize(value2);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type3)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type3 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type3));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type3) {
        if (isScalarType(type3)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type3)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type3)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type3)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type3)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type3)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type3)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type3)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type3)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type3) => "name" in type3 ? type3.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type3) => (
        /* c8 ignore next */
        "description" in type3 ? type3.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type3, { includeDeprecated }) {
        if (isObjectType(type3) || isInterfaceType(type3)) {
          const fields = Object.values(type3.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type3) {
        if (isObjectType(type3) || isInterfaceType(type3)) {
          return type3.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type3, _args, _context, { schema }) {
        if (isAbstractType(type3)) {
          return schema.getPossibleTypes(type3);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type3, { includeDeprecated }) {
        if (isEnumType(type3)) {
          const values = type3.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type3, { includeDeprecated }) {
        if (isInputObjectType(type3)) {
          const values = Object.values(type3.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type3) => "ofType" in type3 ? type3.ofType : void 0
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type3, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type3);
        return valueAST ? print2(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node2) {
  return node2.kind === Kind.OPERATION_DEFINITION || node2.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node2) {
  return node2.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node2) || node2.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node2) {
  return node2.kind === Kind.SCALAR_TYPE_DEFINITION || node2.kind === Kind.OBJECT_TYPE_DEFINITION || node2.kind === Kind.INTERFACE_TYPE_DEFINITION || node2.kind === Kind.UNION_TYPE_DEFINITION || node2.kind === Kind.ENUM_TYPE_DEFINITION || node2.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node2) {
  return node2.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node2);
}
function isTypeExtensionNode(node2) {
  return node2.kind === Kind.SCALAR_TYPE_EXTENSION || node2.kind === Kind.OBJECT_TYPE_EXTENSION || node2.kind === Kind.INTERFACE_TYPE_EXTENSION || node2.kind === Kind.UNION_TYPE_EXTENSION || node2.kind === Kind.ENUM_TYPE_EXTENSION || node2.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node2) {
      for (const definition of node2.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node2) {
      const type3 = context.getParentType();
      if (type3) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node2.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type3, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type3, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type3.name}".` + suggestion,
              {
                nodes: node2
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type3, fieldName) {
  if (!isAbstractType(type3)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type3)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x3) => x3.name);
}
function getSuggestedFieldNames(type3, fieldName) {
  if (isObjectType(type3) || isInterfaceType(type3)) {
    const possibleFieldNames = Object.keys(type3.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node2) {
      const typeCondition = node2.typeCondition;
      if (typeCondition) {
        const type3 = typeFromAST(context.getSchema(), typeCondition);
        if (type3 && !isCompositeType(type3)) {
          const typeStr = print2(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node2) {
      const type3 = typeFromAST(context.getSchema(), node2.typeCondition);
      if (type3 && !isCompositeType(type3)) {
        const typeStr = print2(node2.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node2.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node2.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node2, _key, _parent, _path, ancestors) {
      const name = node2.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node2
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node2
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node2) {
      const fragmentName = node2.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node2.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node2, _1, parent, _2, ancestors) {
      const typeName = node2.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node2
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type3) => type3.name
);
function isSDLNode(value2) {
  return "kind" in value2 && (isTypeSystemDefinitionNode(value2) || isTypeSystemExtensionNode(value2));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node2) {
      operationCount = node2.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node2) {
      if (!node2.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node2
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node2) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node2
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node2
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node2) {
      detectCycleRecursive(node2);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s4) => '"' + s4.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node2 } of usages) {
          const varName = node2.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node2, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node2) {
      variableNameDefined[node2.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node2) {
      operationDefs.push(node2);
      return false;
    },
    FragmentDefinition(node2) {
      fragmentDefs.push(node2);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node2 } of usages) {
          variableNameUsed[node2.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet2) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet2
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet2) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet2
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i4 = 0; i4 < fragmentNames.length; i4++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i4]
      );
      for (let j3 = i4 + 1; j3 < fragmentNames.length; j3++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i4],
          fragmentNames[j3]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i4 = 0; i4 < fields.length; i4++) {
        for (let j3 = i4 + 1; j3 < fields.length; j3++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i4],
            fields[j3]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type22 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type22 && doTypesConflict(type1, type22)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type22
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type22),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value: value2 }) => [name.value, value2]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value2) {
  return print2(sortValueNode(value2));
}
function doTypesConflict(type1, type22) {
  if (isListType(type1)) {
    return isListType(type22) ? doTypesConflict(type1.ofType, type22.ofType) : true;
  }
  if (isListType(type22)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type22) ? doTypesConflict(type1.ofType, type22.ofType) : true;
  }
  if (isNonNullType(type22)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type22)) {
    return type1 !== type22;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet2) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet2);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet2,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet2, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet2, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a3, b2, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a3 < b2 ? [a3, b2] : [b2, a3];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a3, b2, areMutuallyExclusive) {
    const [key1, key2] = a3 < b2 ? [a3, b2] : [b2, a3];
    const map4 = this._data.get(key1);
    if (map4 === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map4.set(key2, areMutuallyExclusive);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node2) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node2
            }
          )
        );
      }
    },
    FragmentSpread(node2) {
      const fragName = node2.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node2
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type3 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type3)) {
      return type3;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node2) {
    const typeName = node2.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node2.kind) {
        const kindStr = extensionKindToTypeName(node2.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node2] : node2
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node2.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type3) {
  if (isScalarType(type3)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type3)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type3)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type3)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type3)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type3)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type3));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print2(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node2) {
      const type3 = context.getType();
      const selectionSet2 = node2.selectionSet;
      if (type3) {
        if (isLeafType(getNamedType(type3))) {
          if (selectionSet2) {
            const fieldName = node2.name.value;
            const typeStr = inspect(type3);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet2
                }
              )
            );
          }
        } else if (!selectionSet2) {
          const fieldName = node2.name.value;
          const typeStr = inspect(type3);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node2
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type3, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type3)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type3)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type3.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type3)) {
    const itemType = type3.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type3)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type3.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type3)) {
    let result;
    try {
      result = type3.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type3));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node2, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node2.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node2
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull2 = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull2 = variableValues[variableName] == null;
    }
    if (isNull2 && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print2(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node2, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node2.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet2) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet2,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node2 of fieldNodes) {
    if (node2.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node2.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet2, fields, visitedFragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node2) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node2, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node2,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type3) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type3) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type3);
  }
  return false;
}
function getFieldEntryKey(node2) {
  return node2.alias ? node2.alias.value : node2.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node2) {
      if (node2.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node2.name ? node2.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node2.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node2) => node2.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node2) => node2.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node2) {
      const directiveName = node2.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node2.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node2.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node2.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node2) {
      if (!("directives" in node2) || !node2.directives) {
        return;
      }
      let seenDirectives;
      if (node2.kind === Kind.SCHEMA_DEFINITION || node2.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node2) || isTypeExtensionNode(node2)) {
        const typeName = node2.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node2.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node2) {
    var _node$values;
    const typeName = node2.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node2.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node2) {
    var _node$fields;
    const typeName = node2.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node2.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type3, fieldName) {
  if (isObjectType(type3) || isInterfaceType(type3) || isInputObjectType(type3)) {
    return type3.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node2) {
      const fragmentName = node2.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node2.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node2.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node2) {
      const fieldName = node2.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node2.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node2.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node2) {
      const operationName = node2.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node2) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node2.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node2) {
    const typeName = node2.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node2.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node2.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node2.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node2) => node2.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node2) => node2.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node2) {
      const type3 = getNullableType(context.getParentInputType());
      if (!isListType(type3)) {
        isValidValueNode(context, node2);
        return false;
      }
    },
    ObjectValue(node2) {
      const type3 = getNamedType(context.getInputType());
      if (!isInputObjectType(type3)) {
        isValidValueNode(context, node2);
        return false;
      }
      const fieldNodeMap = keyMap(node2.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type3.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type3.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node2
              }
            )
          );
        }
      }
    },
    ObjectField(node2) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node2.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node2.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node2
            }
          )
        );
      }
    },
    NullValue(node2) {
      const type3 = context.getInputType();
      if (isNonNullType(type3)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type3)}", found ${print2(node2)}.`,
            {
              nodes: node2
            }
          )
        );
      }
    },
    EnumValue: (node2) => isValidValueNode(context, node2),
    IntValue: (node2) => isValidValueNode(context, node2),
    FloatValue: (node2) => isValidValueNode(context, node2),
    StringValue: (node2) => isValidValueNode(context, node2),
    BooleanValue: (node2) => isValidValueNode(context, node2)
  };
}
function isValidValueNode(context, node2) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type3 = getNamedType(locationType);
  if (!isLeafType(type3)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print2(node2)}.`,
        {
          nodes: node2
        }
      )
    );
    return;
  }
  try {
    const parseResult = type3.parseLiteral(
      node2,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print2(node2)}.`,
          {
            nodes: node2
          }
        )
      );
    }
  } catch (error2) {
    const typeStr = inspect(locationType);
    if (error2 instanceof GraphQLError) {
      context.reportError(error2);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print2(node2)}; ` + error2.message,
          {
            nodes: node2,
            originalError: error2
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node2) {
      const type3 = typeFromAST(context.getSchema(), node2.type);
      if (type3 !== void 0 && !isInputType(type3)) {
        const variableName = node2.variable.name.value;
        const typeName = print2(node2.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node2.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node2, type: type3, defaultValue } of usages) {
          const varName = node2.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type3) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type3,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type3);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node2]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node2) {
      varDefMap[node2.variable.name.value] = node2;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn2) {
  let cache0;
  return function memoized(a1, a22, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache22 = cache1.get(a22);
    if (cache22 === void 0) {
      cache22 = /* @__PURE__ */ new WeakMap();
      cache1.set(a22, cache22);
    }
    let fnResult = cache22.get(a3);
    if (fnResult === void 0) {
      fnResult = fn2(a1, a22, a3);
      cache22.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type3) => type3.name
);

// node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/graphql-tag/lib/index.js
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize(string2) {
  return string2.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition2) {
    if (fragmentDefinition2.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition2.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition2.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition2);
      }
    } else {
      definitions.push(fragmentDefinition2);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc2) {
  var workSet = new Set(doc2.definitions);
  workSet.forEach(function(node2) {
    if (node2.loc)
      delete node2.loc;
    Object.keys(node2).forEach(function(key) {
      var value2 = node2[key];
      if (value2 && typeof value2 === "object") {
        workSet.add(value2);
      }
    });
  });
  var loc = doc2.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc2;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse3(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args2 = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args2[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args2.forEach(function(arg, i4) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i4 + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default2 = gql;

// node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e2 = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError2 = class extends Error {
  constructor(e4, r6, i4, n5, a3, t4, l6) {
    super(e4);
    this.name = "GraphQLError";
    this.message = e4;
    if (a3) {
      this.path = a3;
    }
    if (r6) {
      this.nodes = Array.isArray(r6) ? r6 : [r6];
    }
    if (i4) {
      this.source = i4;
    }
    if (n5) {
      this.positions = n5;
    }
    if (t4) {
      this.originalError = t4;
    }
    var o3 = l6;
    if (!o3 && t4) {
      var u4 = t4.extensions;
      if (u4 && "object" == typeof u4) {
        o3 = u4;
      }
    }
    this.extensions = o3 || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var i3;
var n4;
function error(e4) {
  return new GraphQLError2(`Syntax Error: Unexpected token at ${n4} in ${e4}`);
}
function advance(e4) {
  e4.lastIndex = n4;
  if (e4.test(i3)) {
    return i3.slice(n4, n4 = e4.lastIndex);
  }
}
var a2 = / +(?=[^\s])/y;
function blockString(e4) {
  var r6 = e4.split("\n");
  var i4 = "";
  var n5 = 0;
  var t4 = 0;
  var l6 = r6.length - 1;
  for (var o3 = 0; o3 < r6.length; o3++) {
    a2.lastIndex = 0;
    if (a2.test(r6[o3])) {
      if (o3 && (!n5 || a2.lastIndex < n5)) {
        n5 = a2.lastIndex;
      }
      t4 = t4 || o3;
      l6 = o3;
    }
  }
  for (var u4 = t4; u4 <= l6; u4++) {
    if (u4 !== t4) {
      i4 += "\n";
    }
    i4 += r6[u4].slice(n5).replace(/\\"""/g, '"""');
  }
  return i4;
}
function ignored() {
  for (var e4 = 0 | i3.charCodeAt(n4++); 9 === e4 || 10 === e4 || 13 === e4 || 32 === e4 || 35 === e4 || 44 === e4 || 65279 === e4; e4 = 0 | i3.charCodeAt(n4++)) {
    if (35 === e4) {
      while (10 !== (e4 = i3.charCodeAt(n4++)) && 13 !== e4) {
      }
    }
  }
  n4--;
}
var t3 = /[_A-Za-z]\w*/y;
var l3 = new RegExp("(?:(null|true|false)|\\$(" + t3.source + ')|(-?\\d+)((?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+)?|("""(?:"""|(?:[\\s\\S]*?[^\\\\])"""))|("(?:"|[^\\r\\n]*?[^\\\\]"))|(' + t3.source + "))", "y");
var o2 = function(e4) {
  e4[e4.Const = 1] = "Const";
  e4[e4.Var = 2] = "Var";
  e4[e4.Int = 3] = "Int";
  e4[e4.Float = 4] = "Float";
  e4[e4.BlockString = 5] = "BlockString";
  e4[e4.String = 6] = "String";
  e4[e4.Enum = 7] = "Enum";
  return e4;
}(o2 || {});
var u2 = /\\/;
function value(e4) {
  var r6;
  var a3;
  l3.lastIndex = n4;
  if (91 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    var d5 = [];
    while (93 !== i3.charCodeAt(n4)) {
      d5.push(value(e4));
    }
    n4++;
    ignored();
    return {
      kind: "ListValue",
      values: d5
    };
  } else if (123 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    var v6 = [];
    while (125 !== i3.charCodeAt(n4)) {
      if (null == (r6 = advance(t3))) {
        throw error("ObjectField");
      }
      ignored();
      if (58 !== i3.charCodeAt(n4++)) {
        throw error("ObjectField");
      }
      ignored();
      v6.push({
        kind: "ObjectField",
        name: {
          kind: "Name",
          value: r6
        },
        value: value(e4)
      });
    }
    n4++;
    ignored();
    return {
      kind: "ObjectValue",
      fields: v6
    };
  } else if (null != (a3 = l3.exec(i3))) {
    n4 = l3.lastIndex;
    ignored();
    if (null != (r6 = a3[o2.Const])) {
      return "null" === r6 ? {
        kind: "NullValue"
      } : {
        kind: "BooleanValue",
        value: "true" === r6
      };
    } else if (null != (r6 = a3[o2.Var])) {
      if (e4) {
        throw error("Variable");
      } else {
        return {
          kind: "Variable",
          name: {
            kind: "Name",
            value: r6
          }
        };
      }
    } else if (null != (r6 = a3[o2.Int])) {
      var s4;
      if (null != (s4 = a3[o2.Float])) {
        return {
          kind: "FloatValue",
          value: r6 + s4
        };
      } else {
        return {
          kind: "IntValue",
          value: r6
        };
      }
    } else if (null != (r6 = a3[o2.BlockString])) {
      return {
        kind: "StringValue",
        value: blockString(r6.slice(3, -3)),
        block: true
      };
    } else if (null != (r6 = a3[o2.String])) {
      return {
        kind: "StringValue",
        value: u2.test(r6) ? JSON.parse(r6) : r6.slice(1, -1),
        block: false
      };
    } else if (null != (r6 = a3[o2.Enum])) {
      return {
        kind: "EnumValue",
        value: r6
      };
    }
  }
  throw error("Value");
}
function arguments_(e4) {
  if (40 === i3.charCodeAt(n4)) {
    var r6 = [];
    n4++;
    ignored();
    var a3;
    do {
      if (null == (a3 = advance(t3))) {
        throw error("Argument");
      }
      ignored();
      if (58 !== i3.charCodeAt(n4++)) {
        throw error("Argument");
      }
      ignored();
      r6.push({
        kind: "Argument",
        name: {
          kind: "Name",
          value: a3
        },
        value: value(e4)
      });
    } while (41 !== i3.charCodeAt(n4));
    n4++;
    ignored();
    return r6;
  }
}
function directives(e4) {
  if (64 === i3.charCodeAt(n4)) {
    var r6 = [];
    var a3;
    do {
      n4++;
      if (null == (a3 = advance(t3))) {
        throw error("Directive");
      }
      ignored();
      r6.push({
        kind: "Directive",
        name: {
          kind: "Name",
          value: a3
        },
        arguments: arguments_(e4)
      });
    } while (64 === i3.charCodeAt(n4));
    return r6;
  }
}
function type2() {
  var e4;
  var r6 = 0;
  while (91 === i3.charCodeAt(n4)) {
    r6++;
    n4++;
    ignored();
  }
  if (null == (e4 = advance(t3))) {
    throw error("NamedType");
  }
  ignored();
  var a3 = {
    kind: "NamedType",
    name: {
      kind: "Name",
      value: e4
    }
  };
  do {
    if (33 === i3.charCodeAt(n4)) {
      n4++;
      ignored();
      a3 = {
        kind: "NonNullType",
        type: a3
      };
    }
    if (r6) {
      if (93 !== i3.charCodeAt(n4++)) {
        throw error("NamedType");
      }
      ignored();
      a3 = {
        kind: "ListType",
        type: a3
      };
    }
  } while (r6--);
  return a3;
}
var d2 = new RegExp("(?:(\\.{3})|(" + t3.source + "))", "y");
var v3 = function(e4) {
  e4[e4.Spread = 1] = "Spread";
  e4[e4.Name = 2] = "Name";
  return e4;
}(v3 || {});
function selectionSet() {
  var e4 = [];
  var r6;
  var a3;
  do {
    d2.lastIndex = n4;
    if (null != (a3 = d2.exec(i3))) {
      n4 = d2.lastIndex;
      if (null != a3[v3.Spread]) {
        ignored();
        var l6 = advance(t3);
        if (null != l6 && "on" !== l6) {
          ignored();
          e4.push({
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: l6
            },
            directives: directives(false)
          });
        } else {
          ignored();
          if ("on" === l6) {
            if (null == (l6 = advance(t3))) {
              throw error("NamedType");
            }
            ignored();
          }
          var o3 = directives(false);
          if (123 !== i3.charCodeAt(n4++)) {
            throw error("InlineFragment");
          }
          ignored();
          e4.push({
            kind: "InlineFragment",
            typeCondition: l6 ? {
              kind: "NamedType",
              name: {
                kind: "Name",
                value: l6
              }
            } : void 0,
            directives: o3,
            selectionSet: selectionSet()
          });
        }
      } else if (null != (r6 = a3[v3.Name])) {
        var u4 = void 0;
        ignored();
        if (58 === i3.charCodeAt(n4)) {
          n4++;
          ignored();
          u4 = r6;
          if (null == (r6 = advance(t3))) {
            throw error("Field");
          }
          ignored();
        }
        var s4 = arguments_(false);
        ignored();
        var c6 = directives(false);
        var f6 = void 0;
        if (123 === i3.charCodeAt(n4)) {
          n4++;
          ignored();
          f6 = selectionSet();
        }
        e4.push({
          kind: "Field",
          alias: u4 ? {
            kind: "Name",
            value: u4
          } : void 0,
          name: {
            kind: "Name",
            value: r6
          },
          arguments: s4,
          directives: c6,
          selectionSet: f6
        });
      }
    } else {
      throw error("SelectionSet");
    }
  } while (125 !== i3.charCodeAt(n4));
  n4++;
  ignored();
  return {
    kind: "SelectionSet",
    selections: e4
  };
}
function fragmentDefinition() {
  var e4;
  var r6;
  if (null == (e4 = advance(t3))) {
    throw error("FragmentDefinition");
  }
  ignored();
  if ("on" !== advance(t3)) {
    throw error("FragmentDefinition");
  }
  ignored();
  if (null == (r6 = advance(t3))) {
    throw error("FragmentDefinition");
  }
  ignored();
  var a3 = directives(false);
  if (123 !== i3.charCodeAt(n4++)) {
    throw error("FragmentDefinition");
  }
  ignored();
  return {
    kind: "FragmentDefinition",
    name: {
      kind: "Name",
      value: e4
    },
    typeCondition: {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: r6
      }
    },
    directives: a3,
    selectionSet: selectionSet()
  };
}
var s2 = /(?:query|mutation|subscription|fragment)/y;
function operationDefinition(e4) {
  var r6;
  var a3;
  var l6;
  if (e4) {
    ignored();
    r6 = advance(t3);
    a3 = function variableDefinitions() {
      ignored();
      if (40 === i3.charCodeAt(n4)) {
        var e5 = [];
        n4++;
        ignored();
        var r7;
        do {
          if (36 !== i3.charCodeAt(n4++)) {
            throw error("Variable");
          }
          if (null == (r7 = advance(t3))) {
            throw error("Variable");
          }
          ignored();
          if (58 !== i3.charCodeAt(n4++)) {
            throw error("VariableDefinition");
          }
          ignored();
          var a4 = type2();
          var l7 = void 0;
          if (61 === i3.charCodeAt(n4)) {
            n4++;
            ignored();
            l7 = value(true);
          }
          ignored();
          e5.push({
            kind: "VariableDefinition",
            variable: {
              kind: "Variable",
              name: {
                kind: "Name",
                value: r7
              }
            },
            type: a4,
            defaultValue: l7,
            directives: directives(true)
          });
        } while (41 !== i3.charCodeAt(n4));
        n4++;
        ignored();
        return e5;
      }
    }();
    l6 = directives(false);
  }
  if (123 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    return {
      kind: "OperationDefinition",
      operation: e4 || "query",
      name: r6 ? {
        kind: "Name",
        value: r6
      } : void 0,
      variableDefinitions: a3,
      directives: l6,
      selectionSet: selectionSet()
    };
  }
}
function parse4(e4, r6) {
  i3 = "string" == typeof e4.body ? e4.body : e4;
  n4 = 0;
  return function document2() {
    var e5;
    var r7;
    ignored();
    var a3 = [];
    do {
      if ("fragment" === (e5 = advance(s2))) {
        ignored();
        a3.push(fragmentDefinition());
      } else if (null != (r7 = operationDefinition(e5))) {
        a3.push(r7);
      } else {
        throw error("Document");
      }
    } while (n4 < i3.length);
    return {
      kind: "Document",
      definitions: a3
    };
  }();
}
function mapJoin(e4, r6, i4) {
  var n5 = "";
  for (var a3 = 0; a3 < e4.length; a3++) {
    if (a3) {
      n5 += r6;
    }
    n5 += i4(e4[a3]);
  }
  return n5;
}
function printString2(e4) {
  return JSON.stringify(e4);
}
function printBlockString2(e4) {
  return '"""\n' + e4.replace(/"""/g, '\\"""') + '\n"""';
}
var f3 = "\n";
var g3 = {
  OperationDefinition(e4) {
    var r6 = e4.operation;
    if (e4.name) {
      r6 += " " + e4.name.value;
    }
    if (e4.variableDefinitions && e4.variableDefinitions.length) {
      if (!e4.name) {
        r6 += " ";
      }
      r6 += "(" + mapJoin(e4.variableDefinitions, ", ", g3.VariableDefinition) + ")";
    }
    if (e4.directives && e4.directives.length) {
      r6 += " " + mapJoin(e4.directives, " ", g3.Directive);
    }
    return "query" !== r6 ? r6 + " " + g3.SelectionSet(e4.selectionSet) : g3.SelectionSet(e4.selectionSet);
  },
  VariableDefinition(e4) {
    var r6 = g3.Variable(e4.variable) + ": " + _print(e4.type);
    if (e4.defaultValue) {
      r6 += " = " + _print(e4.defaultValue);
    }
    if (e4.directives && e4.directives.length) {
      r6 += " " + mapJoin(e4.directives, " ", g3.Directive);
    }
    return r6;
  },
  Field(e4) {
    var r6 = e4.alias ? e4.alias.value + ": " + e4.name.value : e4.name.value;
    if (e4.arguments && e4.arguments.length) {
      var i4 = mapJoin(e4.arguments, ", ", g3.Argument);
      if (r6.length + i4.length + 2 > 80) {
        r6 += "(" + (f3 += "  ") + mapJoin(e4.arguments, f3, g3.Argument) + (f3 = f3.slice(0, -2)) + ")";
      } else {
        r6 += "(" + i4 + ")";
      }
    }
    if (e4.directives && e4.directives.length) {
      r6 += " " + mapJoin(e4.directives, " ", g3.Directive);
    }
    if (e4.selectionSet) {
      r6 += " " + g3.SelectionSet(e4.selectionSet);
    }
    return r6;
  },
  StringValue(e4) {
    if (e4.block) {
      return printBlockString2(e4.value).replace(/\n/g, f3);
    } else {
      return printString2(e4.value);
    }
  },
  BooleanValue: (e4) => "" + e4.value,
  NullValue: (e4) => "null",
  IntValue: (e4) => e4.value,
  FloatValue: (e4) => e4.value,
  EnumValue: (e4) => e4.value,
  Name: (e4) => e4.value,
  Variable: (e4) => "$" + e4.name.value,
  ListValue: (e4) => "[" + mapJoin(e4.values, ", ", _print) + "]",
  ObjectValue: (e4) => "{" + mapJoin(e4.fields, ", ", g3.ObjectField) + "}",
  ObjectField: (e4) => e4.name.value + ": " + _print(e4.value),
  Document(e4) {
    if (!e4.definitions || !e4.definitions.length) {
      return "";
    }
    return mapJoin(e4.definitions, "\n\n", _print);
  },
  SelectionSet: (e4) => "{" + (f3 += "  ") + mapJoin(e4.selections, f3, _print) + (f3 = f3.slice(0, -2)) + "}",
  Argument: (e4) => e4.name.value + ": " + _print(e4.value),
  FragmentSpread(e4) {
    var r6 = "..." + e4.name.value;
    if (e4.directives && e4.directives.length) {
      r6 += " " + mapJoin(e4.directives, " ", g3.Directive);
    }
    return r6;
  },
  InlineFragment(e4) {
    var r6 = "...";
    if (e4.typeCondition) {
      r6 += " on " + e4.typeCondition.name.value;
    }
    if (e4.directives && e4.directives.length) {
      r6 += " " + mapJoin(e4.directives, " ", g3.Directive);
    }
    return r6 += " " + g3.SelectionSet(e4.selectionSet);
  },
  FragmentDefinition(e4) {
    var r6 = "fragment " + e4.name.value;
    r6 += " on " + e4.typeCondition.name.value;
    if (e4.directives && e4.directives.length) {
      r6 += " " + mapJoin(e4.directives, " ", g3.Directive);
    }
    return r6 + " " + g3.SelectionSet(e4.selectionSet);
  },
  Directive(e4) {
    var r6 = "@" + e4.name.value;
    if (e4.arguments && e4.arguments.length) {
      r6 += "(" + mapJoin(e4.arguments, ", ", g3.Argument) + ")";
    }
    return r6;
  },
  NamedType: (e4) => e4.name.value,
  ListType: (e4) => "[" + _print(e4.type) + "]",
  NonNullType: (e4) => _print(e4.type) + "!"
};
var _print = (e4) => g3[e4.kind](e4);
function print3(e4) {
  f3 = "\n";
  return g3[e4.kind] ? g3[e4.kind](e4) : "";
}
function valueFromASTUntyped2(e4, r6) {
  switch (e4.kind) {
    case "NullValue":
      return null;
    case "IntValue":
      return parseInt(e4.value, 10);
    case "FloatValue":
      return parseFloat(e4.value);
    case "StringValue":
    case "EnumValue":
    case "BooleanValue":
      return e4.value;
    case "ListValue":
      var i4 = [];
      for (var n5 = 0, a3 = e4.values.length; n5 < a3; n5++) {
        i4.push(valueFromASTUntyped2(e4.values[n5], r6));
      }
      return i4;
    case "ObjectValue":
      var t4 = /* @__PURE__ */ Object.create(null);
      for (var l6 = 0, o3 = e4.fields.length; l6 < o3; l6++) {
        var u4 = e4.fields[l6];
        t4[u4.name.value] = valueFromASTUntyped2(u4.value, r6);
      }
      return t4;
    case "Variable":
      return r6 && r6[e4.name.value];
  }
}

// node_modules/wonka/dist/wonka.mjs
var teardownPlaceholder = () => {
};
var e3 = teardownPlaceholder;
function start(e4) {
  return {
    tag: 0,
    0: e4
  };
}
function push(e4) {
  return {
    tag: 1,
    0: e4
  };
}
var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";
var identity2 = (e4) => e4;
function filter(r6) {
  return (t4) => (i4) => {
    var a3 = e3;
    t4((e4) => {
      if (0 === e4) {
        i4(0);
      } else if (0 === e4.tag) {
        a3 = e4[0];
        i4(e4);
      } else if (!r6(e4[0])) {
        a3(0);
      } else {
        i4(e4);
      }
    });
  };
}
function map3(e4) {
  return (r6) => (t4) => r6((r7) => {
    if (0 === r7 || 0 === r7.tag) {
      t4(r7);
    } else {
      t4(push(e4(r7[0])));
    }
  });
}
function mergeMap(r6) {
  return (t4) => (i4) => {
    var a3 = [];
    var f6 = e3;
    var n5 = false;
    var s4 = false;
    t4((t5) => {
      if (s4) {
      } else if (0 === t5) {
        s4 = true;
        if (!a3.length) {
          i4(0);
        }
      } else if (0 === t5.tag) {
        f6 = t5[0];
      } else {
        n5 = false;
        !function applyInnerSource(r7) {
          var t6 = e3;
          r7((e4) => {
            if (0 === e4) {
              if (a3.length) {
                var r8 = a3.indexOf(t6);
                if (r8 > -1) {
                  (a3 = a3.slice()).splice(r8, 1);
                }
                if (!a3.length) {
                  if (s4) {
                    i4(0);
                  } else if (!n5) {
                    n5 = true;
                    f6(0);
                  }
                }
              }
            } else if (0 === e4.tag) {
              a3.push(t6 = e4[0]);
              t6(0);
            } else if (a3.length) {
              i4(e4);
              t6(0);
            }
          });
        }(r6(t5[0]));
        if (!n5) {
          n5 = true;
          f6(0);
        }
      }
    });
    i4(start((e4) => {
      if (1 === e4) {
        if (!s4) {
          s4 = true;
          f6(1);
        }
        for (var r7 = 0, t5 = a3, i5 = a3.length; r7 < i5; r7++) {
          t5[r7](1);
        }
        a3.length = 0;
      } else {
        if (!s4 && !n5) {
          n5 = true;
          f6(0);
        } else {
          n5 = false;
        }
        for (var l6 = 0, u4 = a3, o3 = a3.length; l6 < o3; l6++) {
          u4[l6](0);
        }
      }
    }));
  };
}
function mergeAll(e4) {
  return mergeMap(identity2)(e4);
}
function merge3(e4) {
  return mergeAll(r4(e4));
}
function onEnd(e4) {
  return (r6) => (t4) => {
    var i4 = false;
    r6((r7) => {
      if (i4) {
      } else if (0 === r7) {
        i4 = true;
        t4(0);
        e4();
      } else if (0 === r7.tag) {
        var a3 = r7[0];
        t4(start((r8) => {
          if (1 === r8) {
            i4 = true;
            a3(1);
            e4();
          } else {
            a3(r8);
          }
        }));
      } else {
        t4(r7);
      }
    });
  };
}
function onPush(e4) {
  return (r6) => (t4) => {
    var i4 = false;
    r6((r7) => {
      if (i4) {
      } else if (0 === r7) {
        i4 = true;
        t4(0);
      } else if (0 === r7.tag) {
        var a3 = r7[0];
        t4(start((e5) => {
          if (1 === e5) {
            i4 = true;
          }
          a3(e5);
        }));
      } else {
        e4(r7[0]);
        t4(r7);
      }
    });
  };
}
function onStart(e4) {
  return (r6) => (t4) => r6((r7) => {
    if (0 === r7) {
      t4(0);
    } else if (0 === r7.tag) {
      t4(r7);
      e4();
    } else {
      t4(r7);
    }
  });
}
function share(r6) {
  var t4 = [];
  var i4 = e3;
  var a3 = false;
  return (e4) => {
    t4.push(e4);
    if (1 === t4.length) {
      r6((e5) => {
        if (0 === e5) {
          for (var r7 = 0, f6 = t4, n5 = t4.length; r7 < n5; r7++) {
            f6[r7](0);
          }
          t4.length = 0;
        } else if (0 === e5.tag) {
          i4 = e5[0];
        } else {
          a3 = false;
          for (var s4 = 0, l6 = t4, u4 = t4.length; s4 < u4; s4++) {
            l6[s4](e5);
          }
        }
      });
    }
    e4(start((r7) => {
      if (1 === r7) {
        var f6 = t4.indexOf(e4);
        if (f6 > -1) {
          (t4 = t4.slice()).splice(f6, 1);
        }
        if (!t4.length) {
          i4(1);
        }
      } else if (!a3) {
        a3 = true;
        i4(0);
      }
    }));
  };
}
function switchMap(r6) {
  return (t4) => (i4) => {
    var a3 = e3;
    var f6 = e3;
    var n5 = false;
    var s4 = false;
    var l6 = false;
    var u4 = false;
    t4((t5) => {
      if (u4) {
      } else if (0 === t5) {
        u4 = true;
        if (!l6) {
          i4(0);
        }
      } else if (0 === t5.tag) {
        a3 = t5[0];
      } else {
        if (l6) {
          f6(1);
          f6 = e3;
        }
        if (!n5) {
          n5 = true;
          a3(0);
        } else {
          n5 = false;
        }
        !function applyInnerSource(e4) {
          l6 = true;
          e4((e5) => {
            if (!l6) {
            } else if (0 === e5) {
              l6 = false;
              if (u4) {
                i4(0);
              } else if (!n5) {
                n5 = true;
                a3(0);
              }
            } else if (0 === e5.tag) {
              s4 = false;
              (f6 = e5[0])(0);
            } else {
              i4(e5);
              if (!s4) {
                f6(0);
              } else {
                s4 = false;
              }
            }
          });
        }(r6(t5[0]));
      }
    });
    i4(start((e4) => {
      if (1 === e4) {
        if (!u4) {
          u4 = true;
          a3(1);
        }
        if (l6) {
          l6 = false;
          f6(1);
        }
      } else {
        if (!u4 && !n5) {
          n5 = true;
          a3(0);
        }
        if (l6 && !s4) {
          s4 = true;
          f6(0);
        }
      }
    }));
  };
}
function take(r6) {
  return (t4) => (i4) => {
    var a3 = e3;
    var f6 = false;
    var n5 = 0;
    t4((e4) => {
      if (f6) {
      } else if (0 === e4) {
        f6 = true;
        i4(0);
      } else if (0 === e4.tag) {
        if (r6 <= 0) {
          f6 = true;
          i4(0);
          e4[0](1);
        } else {
          a3 = e4[0];
        }
      } else if (n5++ < r6) {
        i4(e4);
        if (!f6 && n5 >= r6) {
          f6 = true;
          i4(0);
          a3(1);
        }
      } else {
        i4(e4);
      }
    });
    i4(start((e4) => {
      if (1 === e4 && !f6) {
        f6 = true;
        a3(1);
      } else if (0 === e4 && !f6 && n5 < r6) {
        a3(0);
      }
    }));
  };
}
function takeUntil(r6) {
  return (t4) => (i4) => {
    var a3 = e3;
    var f6 = e3;
    var n5 = false;
    t4((e4) => {
      if (n5) {
      } else if (0 === e4) {
        n5 = true;
        f6(1);
        i4(0);
      } else if (0 === e4.tag) {
        a3 = e4[0];
        r6((e5) => {
          if (0 === e5) {
          } else if (0 === e5.tag) {
            (f6 = e5[0])(0);
          } else {
            n5 = true;
            f6(1);
            a3(1);
            i4(0);
          }
        });
      } else {
        i4(e4);
      }
    });
    i4(start((e4) => {
      if (1 === e4 && !n5) {
        n5 = true;
        a3(1);
        f6(1);
      } else if (!n5) {
        a3(0);
      }
    }));
  };
}
function takeWhile(r6, t4) {
  return (i4) => (a3) => {
    var f6 = e3;
    var n5 = false;
    i4((e4) => {
      if (n5) {
      } else if (0 === e4) {
        n5 = true;
        a3(0);
      } else if (0 === e4.tag) {
        f6 = e4[0];
        a3(e4);
      } else if (!r6(e4[0])) {
        n5 = true;
        if (t4) {
          a3(e4);
        }
        a3(0);
        f6(1);
      } else {
        a3(e4);
      }
    });
  };
}
function lazy(e4) {
  return (r6) => e4()(r6);
}
function fromAsyncIterable(e4) {
  return (r6) => {
    var t4 = e4[asyncIteratorSymbol()] && e4[asyncIteratorSymbol()]() || e4;
    var i4 = false;
    var a3 = false;
    var f6 = false;
    var n5;
    r6(start(async (e5) => {
      if (1 === e5) {
        i4 = true;
        if (t4.return) {
          t4.return();
        }
      } else if (a3) {
        f6 = true;
      } else {
        for (f6 = a3 = true; f6 && !i4; ) {
          if ((n5 = await t4.next()).done) {
            i4 = true;
            if (t4.return) {
              await t4.return();
            }
            r6(0);
          } else {
            try {
              f6 = false;
              r6(push(n5.value));
            } catch (e6) {
              if (t4.throw) {
                if (i4 = !!(await t4.throw(e6)).done) {
                  r6(0);
                }
              } else {
                throw e6;
              }
            }
          }
        }
        a3 = false;
      }
    }));
  };
}
function fromIterable(e4) {
  if (e4[Symbol.asyncIterator]) {
    return fromAsyncIterable(e4);
  }
  return (r6) => {
    var t4 = e4[Symbol.iterator]();
    var i4 = false;
    var a3 = false;
    var f6 = false;
    var n5;
    r6(start((e5) => {
      if (1 === e5) {
        i4 = true;
        if (t4.return) {
          t4.return();
        }
      } else if (a3) {
        f6 = true;
      } else {
        for (f6 = a3 = true; f6 && !i4; ) {
          if ((n5 = t4.next()).done) {
            i4 = true;
            if (t4.return) {
              t4.return();
            }
            r6(0);
          } else {
            try {
              f6 = false;
              r6(push(n5.value));
            } catch (e6) {
              if (t4.throw) {
                if (i4 = !!t4.throw(e6).done) {
                  r6(0);
                }
              } else {
                throw e6;
              }
            }
          }
        }
        a3 = false;
      }
    }));
  };
}
var r4 = fromIterable;
function fromValue(e4) {
  return (r6) => {
    var t4 = false;
    r6(start((i4) => {
      if (1 === i4) {
        t4 = true;
      } else if (!t4) {
        t4 = true;
        r6(push(e4));
        r6(0);
      }
    }));
  };
}
function make(e4) {
  return (r6) => {
    var t4 = false;
    var i4 = e4({
      next(e5) {
        if (!t4) {
          r6(push(e5));
        }
      },
      complete() {
        if (!t4) {
          t4 = true;
          r6(0);
        }
      }
    });
    r6(start((e5) => {
      if (1 === e5 && !t4) {
        t4 = true;
        i4();
      }
    }));
  };
}
function makeSubject() {
  var e4;
  var r6;
  return {
    source: share(make((t4) => {
      e4 = t4.next;
      r6 = t4.complete;
      return teardownPlaceholder;
    })),
    next(r7) {
      if (e4) {
        e4(r7);
      }
    },
    complete() {
      if (r6) {
        r6();
      }
    }
  };
}
var empty = (e4) => {
  var r6 = false;
  e4(start((t4) => {
    if (1 === t4) {
      r6 = true;
    } else if (!r6) {
      r6 = true;
      e4(0);
    }
  }));
};
function fromPromise(e4) {
  return make((r6) => {
    e4.then((e5) => {
      Promise.resolve(e5).then(() => {
        r6.next(e5);
        r6.complete();
      });
    });
    return teardownPlaceholder;
  });
}
function subscribe4(r6) {
  return (t4) => {
    var i4 = e3;
    var a3 = false;
    t4((e4) => {
      if (0 === e4) {
        a3 = true;
      } else if (0 === e4.tag) {
        (i4 = e4[0])(0);
      } else if (!a3) {
        r6(e4[0]);
        i4(0);
      }
    });
    return {
      unsubscribe() {
        if (!a3) {
          a3 = true;
          i4(1);
        }
      }
    };
  };
}
function publish2(e4) {
  subscribe4((e5) => {
  })(e4);
}
function toPromise(r6) {
  return new Promise((t4) => {
    var i4 = e3;
    var a3;
    r6((e4) => {
      if (0 === e4) {
        Promise.resolve(a3).then(t4);
      } else if (0 === e4.tag) {
        (i4 = e4[0])(0);
      } else {
        a3 = e4[0];
        i4(0);
      }
    });
  });
}

// node_modules/@urql/core/dist/urql-core-chunk.mjs
var rehydrateGraphQlError = (r6) => {
  if (r6 && "string" == typeof r6.message && (r6.extensions || "GraphQLError" === r6.name)) {
    return r6;
  } else if ("object" == typeof r6 && "string" == typeof r6.message) {
    return new GraphQLError2(r6.message, r6.nodes, r6.source, r6.positions, r6.path, r6, r6.extensions || {});
  } else {
    return new GraphQLError2(r6);
  }
};
var CombinedError = class extends Error {
  constructor(e4) {
    var r6 = (e4.graphQLErrors || []).map(rehydrateGraphQlError);
    var t4 = ((e5, r7) => {
      var t5 = "";
      if (e5) {
        return `[Network] ${e5.message}`;
      }
      if (r7) {
        for (var a3 = 0, n5 = r7.length; a3 < n5; a3++) {
          if (t5) {
            t5 += "\n";
          }
          t5 += `[GraphQL] ${r7[a3].message}`;
        }
      }
      return t5;
    })(e4.networkError, r6);
    super(t4);
    this.name = "CombinedError";
    this.message = t4;
    this.graphQLErrors = r6;
    this.networkError = e4.networkError;
    this.response = e4.response;
  }
  toString() {
    return this.message;
  }
};
var phash = (e4, r6) => {
  var t4 = 0 | (r6 || 5381);
  for (var a3 = 0, n5 = 0 | e4.length; a3 < n5; a3++) {
    t4 = (t4 << 5) + t4 + e4.charCodeAt(a3);
  }
  return t4;
};
var s3 = /* @__PURE__ */ new Set();
var f4 = /* @__PURE__ */ new WeakMap();
var stringify3 = (e4, r6) => {
  if (null === e4 || s3.has(e4)) {
    return "null";
  } else if ("object" != typeof e4) {
    return JSON.stringify(e4) || "";
  } else if (e4.toJSON) {
    return stringify3(e4.toJSON(), r6);
  } else if (Array.isArray(e4)) {
    var t4 = "[";
    for (var a3 = 0, n5 = e4.length; a3 < n5; a3++) {
      if (t4.length > 1) {
        t4 += ",";
      }
      t4 += stringify3(e4[a3], r6) || "null";
    }
    return t4 += "]";
  } else if (!r6 && (l4 !== NoopConstructor && e4 instanceof l4 || d3 !== NoopConstructor && e4 instanceof d3)) {
    return "null";
  }
  var o3 = Object.keys(e4).sort();
  if (!o3.length && e4.constructor && Object.getPrototypeOf(e4).constructor !== Object.prototype.constructor) {
    var i4 = f4.get(e4) || Math.random().toString(36).slice(2);
    f4.set(e4, i4);
    return stringify3({
      __key: i4
    }, r6);
  }
  s3.add(e4);
  var c6 = "{";
  for (var v6 = 0, p4 = o3.length; v6 < p4; v6++) {
    var u4 = stringify3(e4[o3[v6]], r6);
    if (u4) {
      if (c6.length > 1) {
        c6 += ",";
      }
      c6 += stringify3(o3[v6], r6) + ":" + u4;
    }
  }
  s3.delete(e4);
  return c6 += "}";
};
var extract = (e4, r6, t4) => {
  if (null == t4 || "object" != typeof t4 || t4.toJSON || s3.has(t4)) {
  } else if (Array.isArray(t4)) {
    for (var a3 = 0, n5 = t4.length; a3 < n5; a3++) {
      extract(e4, `${r6}.${a3}`, t4[a3]);
    }
  } else if (t4 instanceof l4 || t4 instanceof d3) {
    e4.set(r6, t4);
  } else {
    s3.add(t4);
    for (var o3 in t4) {
      extract(e4, `${r6}.${o3}`, t4[o3]);
    }
  }
};
var stringifyVariables = (e4, r6) => {
  s3.clear();
  return stringify3(e4, r6 || false);
};
var NoopConstructor = class {
};
var l4 = "undefined" != typeof File ? File : NoopConstructor;
var d3 = "undefined" != typeof Blob ? Blob : NoopConstructor;
var c4 = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var v4 = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g;
var replaceOutsideStrings = (e4, r6) => r6 % 2 == 0 ? e4.replace(v4, "\n") : e4;
var sanitizeDocument = (e4) => e4.split(c4).map(replaceOutsideStrings).join("").trim();
var p2 = /* @__PURE__ */ new Map();
var u3 = /* @__PURE__ */ new Map();
var stringifyDocument = (e4) => {
  var t4;
  if ("string" == typeof e4) {
    t4 = sanitizeDocument(e4);
  } else if (e4.loc && u3.get(e4.__key) === e4) {
    t4 = e4.loc.source.body;
  } else {
    t4 = p2.get(e4) || sanitizeDocument(print3(e4));
    p2.set(e4, t4);
  }
  if ("string" != typeof e4 && !e4.loc) {
    e4.loc = {
      start: 0,
      end: t4.length,
      source: {
        body: t4,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return t4;
};
var hashDocument = (e4) => {
  var r6;
  if (e4.documentId) {
    r6 = phash(e4.documentId);
  } else {
    r6 = phash(stringifyDocument(e4));
    if (e4.definitions) {
      var t4 = getOperationName(e4);
      if (t4) {
        r6 = phash(`
# ${t4}`, r6);
      }
    }
  }
  return r6;
};
var keyDocument = (e4) => {
  var r6;
  var a3;
  if ("string" == typeof e4) {
    r6 = hashDocument(e4);
    a3 = u3.get(r6) || parse4(e4, {
      noLocation: true
    });
  } else {
    r6 = e4.__key || hashDocument(e4);
    a3 = u3.get(r6) || e4;
  }
  if (!a3.loc) {
    stringifyDocument(a3);
  }
  a3.__key = r6;
  u3.set(r6, a3);
  return a3;
};
var createRequest = (e4, r6, t4) => {
  var a3 = r6 || {};
  var n5 = keyDocument(e4);
  var o3 = stringifyVariables(a3, true);
  var i4 = n5.__key;
  if ("{}" !== o3) {
    i4 = phash(o3, i4);
  }
  return {
    key: i4,
    query: n5,
    variables: a3,
    extensions: t4
  };
};
var getOperationName = (e4) => {
  for (var r6 = 0, t4 = e4.definitions.length; r6 < t4; r6++) {
    var n5 = e4.definitions[r6];
    if (n5.kind === e2.OPERATION_DEFINITION) {
      return n5.name ? n5.name.value : void 0;
    }
  }
};
var getOperationType = (e4) => {
  for (var r6 = 0, t4 = e4.definitions.length; r6 < t4; r6++) {
    var n5 = e4.definitions[r6];
    if (n5.kind === e2.OPERATION_DEFINITION) {
      return n5.operation;
    }
  }
};
var makeResult = (e4, r6, t4) => {
  if (!("data" in r6 || "errors" in r6 && Array.isArray(r6.errors))) {
    throw new Error("No Content");
  }
  var a3 = "subscription" === e4.kind;
  return {
    operation: e4,
    data: r6.data,
    error: Array.isArray(r6.errors) ? new CombinedError({
      graphQLErrors: r6.errors,
      response: t4
    }) : void 0,
    extensions: r6.extensions ? {
      ...r6.extensions
    } : void 0,
    hasNext: null == r6.hasNext ? a3 : r6.hasNext,
    stale: false
  };
};
var deepMerge = (e4, r6) => {
  if ("object" == typeof e4 && null != e4) {
    if (Array.isArray(e4)) {
      e4 = [...e4];
      for (var t4 = 0, a3 = r6.length; t4 < a3; t4++) {
        e4[t4] = deepMerge(e4[t4], r6[t4]);
      }
      return e4;
    }
    if (!e4.constructor || e4.constructor === Object) {
      e4 = {
        ...e4
      };
      for (var n5 in r6) {
        e4[n5] = deepMerge(e4[n5], r6[n5]);
      }
      return e4;
    }
  }
  return r6;
};
var mergeResultPatch = (e4, r6, t4, a3) => {
  var n5 = e4.error ? e4.error.graphQLErrors : [];
  var o3 = !!e4.extensions || !!(r6.payload || r6).extensions;
  var i4 = {
    ...e4.extensions,
    ...(r6.payload || r6).extensions
  };
  var s4 = r6.incremental;
  if ("path" in r6) {
    s4 = [r6];
  }
  var f6 = {
    data: e4.data
  };
  if (s4) {
    var _loop = function() {
      var e5 = s4[l6];
      if (Array.isArray(e5.errors)) {
        n5.push(...e5.errors);
      }
      if (e5.extensions) {
        Object.assign(i4, e5.extensions);
        o3 = true;
      }
      var r7 = "data";
      var t5 = f6;
      var d6 = [];
      if (e5.path) {
        d6 = e5.path;
      } else if (a3) {
        var c6 = a3.find((r8) => r8.id === e5.id);
        if (e5.subPath) {
          d6 = [...c6.path, ...e5.subPath];
        } else {
          d6 = c6.path;
        }
      }
      for (var v6 = 0, p4 = d6.length; v6 < p4; r7 = d6[v6++]) {
        t5 = t5[r7] = Array.isArray(t5[r7]) ? [...t5[r7]] : {
          ...t5[r7]
        };
      }
      if (e5.items) {
        var u4 = +r7 >= 0 ? r7 : 0;
        for (var y3 = 0, h3 = e5.items.length; y3 < h3; y3++) {
          t5[u4 + y3] = deepMerge(t5[u4 + y3], e5.items[y3]);
        }
      } else if (void 0 !== e5.data) {
        t5[r7] = deepMerge(t5[r7], e5.data);
      }
    };
    for (var l6 = 0, d5 = s4.length; l6 < d5; l6++) {
      _loop();
    }
  } else {
    f6.data = (r6.payload || r6).data || e4.data;
    n5 = r6.errors || r6.payload && r6.payload.errors || n5;
  }
  return {
    operation: e4.operation,
    data: f6.data,
    error: n5.length ? new CombinedError({
      graphQLErrors: n5,
      response: t4
    }) : void 0,
    extensions: o3 ? i4 : void 0,
    hasNext: null != r6.hasNext ? r6.hasNext : e4.hasNext,
    stale: false
  };
};
var makeErrorResult = (e4, r6, t4) => ({
  operation: e4,
  data: void 0,
  error: new CombinedError({
    networkError: r6,
    response: t4
  }),
  extensions: void 0,
  hasNext: false,
  stale: false
});
function makeFetchBody(e4) {
  var r6 = {
    query: void 0,
    documentId: void 0,
    operationName: getOperationName(e4.query),
    variables: e4.variables || void 0,
    extensions: e4.extensions
  };
  if ("documentId" in e4.query && e4.query.documentId && (!e4.query.definitions || !e4.query.definitions.length)) {
    r6.documentId = e4.query.documentId;
  } else if (!e4.extensions || !e4.extensions.persistedQuery || e4.extensions.persistedQuery.miss) {
    r6.query = stringifyDocument(e4.query);
  }
  return r6;
}
var makeFetchURL = (e4, r6) => {
  var t4 = "query" === e4.kind && e4.context.preferGetMethod;
  if (!t4 || !r6) {
    return e4.context.url;
  }
  var a3 = splitOutSearchParams(e4.context.url);
  for (var n5 in r6) {
    var o3 = r6[n5];
    if (o3) {
      a3[1].set(n5, "object" == typeof o3 ? stringifyVariables(o3) : o3);
    }
  }
  var i4 = a3.join("?");
  if (i4.length > 2047 && "force" !== t4) {
    e4.context.preferGetMethod = false;
    return e4.context.url;
  }
  return i4;
};
var splitOutSearchParams = (e4) => {
  var r6 = e4.indexOf("?");
  return r6 > -1 ? [e4.slice(0, r6), new URLSearchParams(e4.slice(r6 + 1))] : [e4, new URLSearchParams()];
};
var serializeBody = (e4, r6) => {
  if (r6 && !("query" === e4.kind && !!e4.context.preferGetMethod)) {
    var t4 = stringifyVariables(r6);
    var a3 = ((e5) => {
      var r7 = /* @__PURE__ */ new Map();
      if (l4 !== NoopConstructor || d3 !== NoopConstructor) {
        s3.clear();
        extract(r7, "variables", e5);
      }
      return r7;
    })(r6.variables);
    if (a3.size) {
      var n5 = new FormData();
      n5.append("operations", t4);
      n5.append("map", stringifyVariables({
        ...[...a3.keys()].map((e5) => [e5])
      }));
      var o3 = 0;
      for (var i4 of a3.values()) {
        n5.append("" + o3++, i4);
      }
      return n5;
    }
    return t4;
  }
};
var makeFetchOptions = (e4, r6) => {
  var t4 = {
    accept: "subscription" === e4.kind ? "text/event-stream, multipart/mixed" : "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed"
  };
  var a3 = ("function" == typeof e4.context.fetchOptions ? e4.context.fetchOptions() : e4.context.fetchOptions) || {};
  if (a3.headers) {
    if (((e5) => "has" in e5 && !Object.keys(e5).length)(a3.headers)) {
      a3.headers.forEach((e5, r7) => {
        t4[r7] = e5;
      });
    } else if (Array.isArray(a3.headers)) {
      a3.headers.forEach((e5, r7) => {
        if (Array.isArray(e5)) {
          if (t4[e5[0]]) {
            t4[e5[0]] = `${t4[e5[0]]},${e5[1]}`;
          } else {
            t4[e5[0]] = e5[1];
          }
        } else {
          t4[r7] = e5;
        }
      });
    } else {
      for (var n5 in a3.headers) {
        t4[n5.toLowerCase()] = a3.headers[n5];
      }
    }
  }
  var o3 = serializeBody(e4, r6);
  if ("string" == typeof o3 && !t4["content-type"]) {
    t4["content-type"] = "application/json";
  }
  return {
    ...a3,
    method: o3 ? "POST" : "GET",
    body: o3,
    headers: t4
  };
};
var y2 = "undefined" != typeof TextDecoder ? new TextDecoder() : null;
var h2 = /boundary="?([^=";]+)"?/i;
var m2 = /data: ?([^\n]+)/;
var toString = (e4) => "Buffer" === e4.constructor.name ? e4.toString() : y2.decode(e4);
async function* streamBody(e4) {
  if (e4.body[Symbol.asyncIterator]) {
    for await (var r6 of e4.body) {
      yield toString(r6);
    }
  } else {
    var t4 = e4.body.getReader();
    var a3;
    try {
      while (!(a3 = await t4.read()).done) {
        yield toString(a3.value);
      }
    } finally {
      t4.cancel();
    }
  }
}
async function* split(e4, r6) {
  var t4 = "";
  var a3;
  for await (var n5 of e4) {
    t4 += n5;
    while ((a3 = t4.indexOf(r6)) > -1) {
      yield t4.slice(0, a3);
      t4 = t4.slice(a3 + r6.length);
    }
  }
}
async function* fetchOperation(e4, r6, t4) {
  var a3 = true;
  var n5 = null;
  var o3;
  try {
    yield await Promise.resolve();
    var i4 = (o3 = await (e4.context.fetch || fetch)(r6, t4)).headers.get("Content-Type") || "";
    var s4;
    if (/multipart\/mixed/i.test(i4)) {
      s4 = async function* parseMultipartMixed(e5, r7) {
        var t5 = e5.match(h2);
        var a4 = "--" + (t5 ? t5[1] : "-");
        var n6 = true;
        var o4;
        for await (var i5 of split(streamBody(r7), "\r\n" + a4)) {
          if (n6) {
            n6 = false;
            var s5 = i5.indexOf(a4);
            if (s5 > -1) {
              i5 = i5.slice(s5 + a4.length);
            } else {
              continue;
            }
          }
          try {
            yield o4 = JSON.parse(i5.slice(i5.indexOf("\r\n\r\n") + 4));
          } catch (e6) {
            if (!o4) {
              throw e6;
            }
          }
          if (o4 && false === o4.hasNext) {
            break;
          }
        }
        if (o4 && false !== o4.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(i4, o3);
    } else if (/text\/event-stream/i.test(i4)) {
      s4 = async function* parseEventStream(e5) {
        var r7;
        for await (var t5 of split(streamBody(e5), "\n\n")) {
          var a4 = t5.match(m2);
          if (a4) {
            var n6 = a4[1];
            try {
              yield r7 = JSON.parse(n6);
            } catch (e6) {
              if (!r7) {
                throw e6;
              }
            }
            if (r7 && false === r7.hasNext) {
              break;
            }
          }
        }
        if (r7 && false !== r7.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(o3);
    } else if (!/text\//i.test(i4)) {
      s4 = async function* parseJSON(e5) {
        yield JSON.parse(await e5.text());
      }(o3);
    } else {
      s4 = async function* parseMaybeJSON(e5) {
        var r7 = await e5.text();
        try {
          var t5 = JSON.parse(r7);
          if (true) {
            console.warn('Found response with content-type "text/plain" but it had a valid "application/json" response.');
          }
          yield t5;
        } catch (e6) {
          throw new Error(r7);
        }
      }(o3);
    }
    var f6;
    for await (var l6 of s4) {
      if (l6.pending && !n5) {
        f6 = l6.pending;
      } else if (l6.pending) {
        f6 = [...f6, ...l6.pending];
      }
      n5 = n5 ? mergeResultPatch(n5, l6, o3, f6) : makeResult(e4, l6, o3);
      a3 = false;
      yield n5;
      a3 = true;
    }
    if (!n5) {
      yield n5 = makeResult(e4, {}, o3);
    }
  } catch (r7) {
    if (!a3) {
      throw r7;
    }
    yield makeErrorResult(e4, o3 && (o3.status < 200 || o3.status >= 300) && o3.statusText ? new Error(o3.statusText) : r7, o3);
  }
}
function makeFetchSource(e4, r6, t4) {
  var a3;
  if ("undefined" != typeof AbortController) {
    t4.signal = (a3 = new AbortController()).signal;
  }
  return onEnd(() => {
    if (a3) {
      a3.abort();
    }
  })(filter((e5) => !!e5)(fromAsyncIterable(fetchOperation(e4, r6, t4))));
}

// node_modules/@urql/core/dist/urql-core.mjs
var formatNode = (r6) => {
  if ("definitions" in r6) {
    var t4 = [];
    for (var n5 = 0, a3 = r6.definitions.length; n5 < a3; n5++) {
      var i4 = formatNode(r6.definitions[n5]);
      t4.push(i4);
    }
    return {
      ...r6,
      definitions: t4
    };
  }
  if ("directives" in r6 && r6.directives && r6.directives.length) {
    var o3 = [];
    var s4 = {};
    for (var c6 = 0, u4 = r6.directives.length; c6 < u4; c6++) {
      var p4 = r6.directives[c6];
      var d5 = p4.name.value;
      if ("_" !== d5[0]) {
        o3.push(p4);
      } else {
        d5 = d5.slice(1);
      }
      s4[d5] = p4;
    }
    r6 = {
      ...r6,
      directives: o3,
      _directives: s4
    };
  }
  if ("selectionSet" in r6) {
    var v6 = [];
    var l6 = r6.kind === e2.OPERATION_DEFINITION;
    if (r6.selectionSet) {
      for (var f6 = 0, h3 = r6.selectionSet.selections.length; f6 < h3; f6++) {
        var k2 = r6.selectionSet.selections[f6];
        l6 = l6 || k2.kind === e2.FIELD && "__typename" === k2.name.value && !k2.alias;
        var y3 = formatNode(k2);
        v6.push(y3);
      }
      if (!l6) {
        v6.push({
          kind: e2.FIELD,
          name: {
            kind: e2.NAME,
            value: "__typename"
          },
          _generated: true
        });
      }
      return {
        ...r6,
        selectionSet: {
          ...r6.selectionSet,
          selections: v6
        }
      };
    }
  }
  return r6;
};
var I2 = /* @__PURE__ */ new Map();
var formatDocument = (e4) => {
  var t4 = keyDocument(e4);
  var n5 = I2.get(t4.__key);
  if (!n5) {
    I2.set(t4.__key, n5 = formatNode(t4));
    Object.defineProperty(n5, "__key", {
      value: t4.__key,
      enumerable: false
    });
  }
  return n5;
};
function withPromise(e4) {
  var source$ = (r6) => e4(r6);
  source$.toPromise = () => toPromise(take(1)(filter((e5) => !e5.stale && !e5.hasNext)(source$)));
  source$.then = (e5, r6) => source$.toPromise().then(e5, r6);
  source$.subscribe = (e5) => subscribe4(e5)(source$);
  return source$;
}
function makeOperation(e4, r6, t4) {
  return {
    ...r6,
    kind: e4,
    context: r6.context ? {
      ...r6.context,
      ...t4
    } : t4 || r6.context
  };
}
var noop = () => {
};
var fetchExchange = ({ forward: e4, dispatchDebug: r6 }) => (t4) => {
  var n5 = mergeMap((e5) => {
    var n6 = makeFetchBody(e5);
    var a4 = makeFetchURL(e5, n6);
    var i4 = makeFetchOptions(e5, n6);
    r6({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e5,
      data: {
        url: a4,
        fetchOptions: i4
      },
      source: "fetchExchange"
    });
    var s4 = takeUntil(filter((r7) => "teardown" === r7.kind && r7.key === e5.key)(t4))(makeFetchSource(e5, a4, i4));
    if (true) {
      return onPush((t5) => {
        var n7 = !t5.data ? t5.error : void 0;
        r6({
          type: n7 ? "fetchError" : "fetchSuccess",
          message: `A ${n7 ? "failed" : "successful"} fetch response has been returned.`,
          operation: e5,
          data: {
            url: a4,
            fetchOptions: i4,
            value: n7 || t5
          },
          source: "fetchExchange"
        });
      })(s4);
    }
    return s4;
  })(filter((e5) => "teardown" !== e5.kind && ("subscription" !== e5.kind || !!e5.context.fetchSubscriptions))(t4));
  var a3 = e4(filter((e5) => "teardown" === e5.kind || "subscription" === e5.kind && !e5.context.fetchSubscriptions)(t4));
  return merge3([n5, a3]);
};
var composeExchanges = (e4) => ({ client: r6, forward: t4, dispatchDebug: n5 }) => e4.reduceRight((e5, t5) => {
  var a3 = false;
  return t5({
    client: r6,
    forward(r7) {
      if (true) {
        if (a3) {
          throw new Error("forward() must only be called once in each Exchange.");
        }
        a3 = true;
      }
      return share(e5(share(r7)));
    },
    dispatchDebug(e6) {
      n5({
        timestamp: Date.now(),
        source: t5.name,
        ...e6
      });
    }
  });
}, t4);
var fallbackExchange = ({ dispatchDebug: e4 }) => (r6) => {
  if (true) {
    r6 = onPush((r7) => {
      if ("teardown" !== r7.kind && true) {
        var t4 = `No exchange has handled operations of kind "${r7.kind}". Check whether you've added an exchange responsible for these operations.`;
        e4({
          type: "fallbackCatch",
          message: t4,
          operation: r7,
          source: "fallbackExchange"
        });
        console.warn(t4);
      }
    })(r6);
  }
  return filter((e5) => false)(r6);
};
var C2 = function Client(e4) {
  if (!e4.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r6 = 0;
  var t4 = /* @__PURE__ */ new Map();
  var n5 = /* @__PURE__ */ new Map();
  var a3 = /* @__PURE__ */ new Set();
  var i4 = [];
  var o3 = {
    url: e4.url,
    fetchSubscriptions: e4.fetchSubscriptions,
    fetchOptions: e4.fetchOptions,
    fetch: e4.fetch,
    preferGetMethod: e4.preferGetMethod,
    requestPolicy: e4.requestPolicy || "cache-first"
  };
  var s4 = makeSubject();
  function nextOperation(e5) {
    if ("mutation" === e5.kind || "teardown" === e5.kind || !a3.has(e5.key)) {
      if ("teardown" === e5.kind) {
        a3.delete(e5.key);
      } else if ("mutation" !== e5.kind) {
        a3.add(e5.key);
      }
      s4.next(e5);
    }
  }
  var c6 = false;
  function dispatchOperation(e5) {
    if (e5) {
      nextOperation(e5);
    }
    if (!c6) {
      c6 = true;
      while (c6 && (e5 = i4.shift())) {
        nextOperation(e5);
      }
      c6 = false;
    }
  }
  var makeResultSource = (e5) => {
    var r7 = takeUntil(filter((r8) => "teardown" === r8.kind && r8.key === e5.key)(s4.source))(filter((r8) => r8.operation.kind === e5.kind && r8.operation.key === e5.key && (!r8.operation.context._instance || r8.operation.context._instance === e5.context._instance))(O2));
    if ("query" !== e5.kind) {
      r7 = takeWhile((e6) => !!e6.hasNext, true)(r7);
    } else {
      r7 = switchMap((r8) => {
        var t5 = fromValue(r8);
        return r8.stale || r8.hasNext ? t5 : merge3([t5, map3(() => {
          r8.stale = true;
          return r8;
        })(take(1)(filter((r9) => r9.key === e5.key)(s4.source)))]);
      })(r7);
    }
    if ("mutation" !== e5.kind) {
      r7 = onEnd(() => {
        a3.delete(e5.key);
        t4.delete(e5.key);
        n5.delete(e5.key);
        c6 = false;
        for (var r8 = i4.length - 1; r8 >= 0; r8--) {
          if (i4[r8].key === e5.key) {
            i4.splice(r8, 1);
          }
        }
        nextOperation(makeOperation("teardown", e5, e5.context));
      })(onPush((r8) => {
        if (r8.stale) {
          if (!r8.hasNext) {
            a3.delete(e5.key);
          } else {
            for (var n6 = 0; n6 < i4.length; n6++) {
              var o4 = i4[n6];
              if (o4.key === r8.operation.key) {
                a3.delete(o4.key);
                break;
              }
            }
          }
        } else if (!r8.hasNext) {
          a3.delete(e5.key);
        }
        t4.set(e5.key, r8);
      })(r7));
    } else {
      r7 = onStart(() => {
        nextOperation(e5);
      })(r7);
    }
    return share(r7);
  };
  var u4 = this instanceof Client ? this : Object.create(Client.prototype);
  var p4 = Object.assign(u4, {
    suspense: !!e4.suspense,
    operations$: s4.source,
    reexecuteOperation(e5) {
      if ("teardown" === e5.kind) {
        dispatchOperation(e5);
      } else if ("mutation" === e5.kind) {
        i4.push(e5);
        Promise.resolve().then(dispatchOperation);
      } else if (n5.has(e5.key)) {
        var r7 = false;
        for (var t5 = 0; t5 < i4.length; t5++) {
          if (i4[t5].key === e5.key) {
            i4[t5] = e5;
            r7 = true;
          }
        }
        if (!(r7 || a3.has(e5.key) && "network-only" !== e5.context.requestPolicy)) {
          i4.push(e5);
          Promise.resolve().then(dispatchOperation);
        } else {
          a3.delete(e5.key);
          Promise.resolve().then(dispatchOperation);
        }
      }
    },
    createRequestOperation(e5, t5, n6) {
      if (!n6) {
        n6 = {};
      }
      var a4;
      if ("teardown" !== e5 && (a4 = getOperationType(t5.query)) !== e5) {
        throw new Error(`Expected operation of type "${e5}" but found "${a4}"`);
      }
      return makeOperation(e5, t5, {
        _instance: "mutation" === e5 ? r6 = r6 + 1 | 0 : void 0,
        ...o3,
        ...n6,
        requestPolicy: n6.requestPolicy || o3.requestPolicy,
        suspense: n6.suspense || false !== n6.suspense && p4.suspense
      });
    },
    executeRequestOperation(e5) {
      if ("mutation" === e5.kind) {
        return withPromise(makeResultSource(e5));
      }
      return withPromise(lazy(() => {
        var r7 = n5.get(e5.key);
        if (!r7) {
          n5.set(e5.key, r7 = makeResultSource(e5));
        }
        r7 = onStart(() => {
          dispatchOperation(e5);
        })(r7);
        var a4 = t4.get(e5.key);
        if ("query" === e5.kind && a4 && (a4.stale || a4.hasNext)) {
          return switchMap(fromValue)(merge3([r7, filter((r8) => r8 === t4.get(e5.key))(fromValue(a4))]));
        } else {
          return r7;
        }
      }));
    },
    executeQuery(e5, r7) {
      var t5 = p4.createRequestOperation("query", e5, r7);
      return p4.executeRequestOperation(t5);
    },
    executeSubscription(e5, r7) {
      var t5 = p4.createRequestOperation("subscription", e5, r7);
      return p4.executeRequestOperation(t5);
    },
    executeMutation(e5, r7) {
      var t5 = p4.createRequestOperation("mutation", e5, r7);
      return p4.executeRequestOperation(t5);
    },
    readQuery(e5, r7, t5) {
      var n6 = null;
      subscribe4((e6) => {
        n6 = e6;
      })(p4.query(e5, r7, t5)).unsubscribe();
      return n6;
    },
    query: (e5, r7, t5) => p4.executeQuery(createRequest(e5, r7), t5),
    subscription: (e5, r7, t5) => p4.executeSubscription(createRequest(e5, r7), t5),
    mutation: (e5, r7, t5) => p4.executeMutation(createRequest(e5, r7), t5)
  });
  var d5 = noop;
  if (true) {
    var { next: f6, source: x3 } = makeSubject();
    p4.subscribeToDebugTarget = (e5) => subscribe4(e5)(x3);
    d5 = f6;
  }
  var w2 = composeExchanges(e4.exchanges);
  var O2 = share(w2({
    client: p4,
    dispatchDebug: d5,
    forward: fallbackExchange({
      dispatchDebug: d5
    })
  })(s4.source));
  publish2(O2);
  return p4;
};
var Q2 = C2;

// node_modules/urql/dist/urql.es.js
var r5 = __toESM(require_react());
var c5 = {};
var v5 = r5.createContext(c5);
var f5 = v5.Provider;
var l5 = v5.Consumer;
v5.displayName = "UrqlContext";
var useClient = () => {
  var e4 = r5.useContext(v5);
  if (e4 === c5 && true) {
    var t4 = "No client has been specified using urql's Provider. please create a client and add a Provider.";
    console.error(t4);
    throw new Error(t4);
  }
  return e4;
};
var d4 = {
  fetching: false,
  stale: false,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};
var areOperationsEqual = (e4, r6) => e4 === r6 || !(!e4 || !r6 || e4.key !== r6.key);
var computeNextState = (e4, r6) => {
  var t4 = {
    ...e4,
    ...r6,
    data: void 0 !== r6.data || r6.error ? r6.data : e4.data,
    fetching: !!r6.fetching,
    stale: !!r6.stale
  };
  return ((e5, r7) => {
    for (var t5 in e5) {
      if (!(t5 in r7)) {
        return true;
      }
    }
    for (var a3 in r7) {
      if ("operation" === a3 ? !areOperationsEqual(e5[a3], r7[a3]) : e5[a3] !== r7[a3]) {
        return true;
      }
    }
    return false;
  })(e4, t4) ? t4 : e4;
};
var hasDepsChanged = (e4, r6) => {
  for (var t4 = 0, a3 = r6.length; t4 < a3; t4++) {
    if (e4[t4] !== r6[t4]) {
      return true;
    }
  }
  return false;
};
var p3 = r5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function deferDispatch(e4, r6) {
  if (p3 && p3.ReactCurrentOwner && p3.ReactCurrentOwner.current) {
    Promise.resolve(r6).then(e4);
  } else {
    e4(r6);
  }
}
function useMutation(i4) {
  var s4 = r5.useRef(true);
  var o3 = useClient();
  var [c6, v6] = r5.useState(d4);
  var f6 = r5.useCallback((r6, c7) => {
    deferDispatch(v6, {
      ...d4,
      fetching: true
    });
    return toPromise(take(1)(filter((e4) => !e4.hasNext)(onPush((e4) => {
      if (s4.current) {
        deferDispatch(v6, {
          fetching: false,
          stale: e4.stale,
          data: e4.data,
          error: e4.error,
          extensions: e4.extensions,
          operation: e4.operation
        });
      }
    })(o3.executeMutation(createRequest(i4, r6), c7 || {})))));
  }, [o3, i4, v6]);
  r5.useEffect(() => {
    s4.current = true;
    return () => {
      s4.current = false;
    };
  }, []);
  return [c6, f6];
}
function useRequest(t4, a3) {
  var n5 = r5.useRef(void 0);
  return r5.useMemo(() => {
    var r6 = createRequest(t4, a3);
    if (void 0 !== n5.current && n5.current.key === r6.key) {
      return n5.current;
    } else {
      n5.current = r6;
      return r6;
    }
  }, [t4, a3]);
}
var getCacheForClient = (e4) => {
  if (!e4._react) {
    var r6 = /* @__PURE__ */ new Set();
    var t4 = /* @__PURE__ */ new Map();
    if (e4.operations$) {
      subscribe4((e5) => {
        if ("teardown" === e5.kind && r6.has(e5.key)) {
          r6.delete(e5.key);
          t4.delete(e5.key);
        }
      })(e4.operations$);
    }
    e4._react = {
      get: (e5) => t4.get(e5),
      set(e5, a3) {
        r6.delete(e5);
        t4.set(e5, a3);
      },
      dispose(e5) {
        r6.add(e5);
      }
    };
  }
  return e4._react;
};
var isSuspense = (e4, r6) => r6 && void 0 !== r6.suspense ? !!r6.suspense : e4.suspense;
function useQuery(e4) {
  var t4 = useClient();
  var a3 = getCacheForClient(t4);
  var n5 = isSuspense(t4, e4.context);
  var c6 = useRequest(e4.query, e4.variables);
  var v6 = r5.useMemo(() => {
    if (e4.pause) {
      return null;
    }
    var r6 = t4.executeQuery(c6, {
      requestPolicy: e4.requestPolicy,
      ...e4.context
    });
    return n5 ? onPush((e5) => {
      a3.set(c6.key, e5);
    })(r6) : r6;
  }, [a3, t4, c6, n5, e4.pause, e4.requestPolicy, e4.context]);
  var f6 = r5.useCallback((e5, r6) => {
    if (!e5) {
      return {
        fetching: false
      };
    }
    var t5 = a3.get(c6.key);
    if (!t5) {
      var n6;
      var u4 = subscribe4((e6) => {
        t5 = e6;
        if (n6) {
          n6(t5);
        }
      })(takeWhile(() => r6 && !n6 || !t5 || "hasNext" in t5 && t5.hasNext)(e5));
      if (null == t5 && r6) {
        var o3 = new Promise((e6) => {
          n6 = e6;
        });
        a3.set(c6.key, o3);
        throw o3;
      } else {
        u4.unsubscribe();
      }
    } else if (r6 && null != t5 && "then" in t5) {
      throw t5;
    }
    return t5 || {
      fetching: true
    };
  }, [a3, c6]);
  var l6 = [t4, c6, e4.requestPolicy, e4.context, e4.pause];
  var [p4, h3] = r5.useState(() => [v6, computeNextState(d4, f6(v6, n5)), l6]);
  var y3 = p4[1];
  if (v6 !== p4[0] && hasDepsChanged(p4[2], l6)) {
    h3([v6, y3 = computeNextState(p4[1], f6(v6, n5)), l6]);
  }
  r5.useEffect(() => {
    var e5 = p4[0];
    var r6 = p4[2][1];
    var t5 = false;
    var updateResult = (e6) => {
      t5 = true;
      deferDispatch(h3, (r7) => {
        var t6 = computeNextState(r7[1], e6);
        return r7[1] !== t6 ? [r7[0], t6, r7[2]] : r7;
      });
    };
    if (e5) {
      var n6 = subscribe4(updateResult)(onEnd(() => {
        updateResult({
          fetching: false
        });
      })(e5));
      if (!t5) {
        updateResult({
          fetching: true
        });
      }
      return () => {
        a3.dispose(r6.key);
        n6.unsubscribe();
      };
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [a3, p4[0], p4[2][1]]);
  var x3 = r5.useCallback((r6) => {
    var i4 = {
      requestPolicy: e4.requestPolicy,
      ...e4.context,
      ...r6
    };
    deferDispatch(h3, (e5) => [n5 ? onPush((e6) => {
      a3.set(c6.key, e6);
    })(t4.executeQuery(c6, i4)) : t4.executeQuery(c6, i4), e5[1], l6]);
  }, [t4, a3, c6, n5, e4.requestPolicy, e4.context, e4.pause]);
  return [y3, x3];
}

// node_modules/idb-keyval/dist/index.js
function promisifyRequest2(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest2(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get2(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store2) => promisifyRequest2(store2.get(key)));
}
function set(key, value2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    store2.put(value2, key);
    return promisifyRequest2(store2.transaction);
  });
}
function setMany(entries2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    entries2.forEach((entry) => store2.put(entry[1], entry[0]));
    return promisifyRequest2(store2.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    store2.delete(key);
    return promisifyRequest2(store2.transaction);
  });
}
function delMany(keys3, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    keys3.forEach((key) => store2.delete(key));
    return promisifyRequest2(store2.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    store2.clear();
    return promisifyRequest2(store2.transaction);
  });
}
function eachCursor(store2, callback) {
  store2.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest2(store2.transaction);
}
function keys2(customStore = defaultGetStore()) {
  return customStore("readonly", (store2) => {
    if (store2.getAllKeys) {
      return promisifyRequest2(store2.getAllKeys());
    }
    const items = [];
    return eachCursor(store2, (cursor2) => items.push(cursor2.key)).then(() => items);
  });
}
function entries(customStore = defaultGetStore()) {
  return customStore("readonly", (store2) => {
    if (store2.getAll && store2.getAllKeys) {
      return Promise.all([
        promisifyRequest2(store2.getAllKeys()),
        promisifyRequest2(store2.getAll())
      ]).then(([keys3, values]) => keys3.map((key, i4) => [key, values[i4]]));
    }
    const items = [];
    return customStore("readonly", (store3) => eachCursor(store3, (cursor2) => items.push([cursor2.key, cursor2.value])).then(() => items));
  });
}

// node_modules/@keystatic/core/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg2, type3, code, fn2) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg2, type3, code, fn2) : console.error(`[${code}] ${type3}: ${msg2}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
var _a2;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_2, fn2) {
      this._onabort.push(fn2);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a5, _b2;
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn2 of this.signal._onabort) {
        fn2(reason);
      }
      (_b2 = (_a5 = this.signal).onabort) == null ? void 0 : _b2.call(_a5, reason);
    }
  };
  let printACPolyfillWarning = ((_a2 = PROCESS.env) == null ? void 0 : _a2.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE2 = Symbol("type");
var isPosInt = (n5) => n5 && n5 === Math.floor(n5) && n5 > 0 && isFinite(n5);
var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size3) {
    super(size3);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class _Stack {
  constructor(max2, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max2);
    this.length = 0;
  }
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s4 = new _Stack(max2, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s4;
  }
  push(n5) {
    this.heap[this.length++] = n5;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap();
// private constructor
__privateAdd(_Stack, _constructing, false);
var Stack = _Stack;
var _a3, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn;
var _LRUCache = class _LRUCache {
  constructor(options) {
    __privateAdd(this, _LRUCache_instances);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    __privateAdd(this, _max);
    __privateAdd(this, _maxSize);
    __privateAdd(this, _dispose);
    __privateAdd(this, _disposeAfter);
    __privateAdd(this, _fetchMethod);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size);
    __privateAdd(this, _calculatedSize);
    __privateAdd(this, _keyMap);
    __privateAdd(this, _keyList);
    __privateAdd(this, _valList);
    __privateAdd(this, _next);
    __privateAdd(this, _prev);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _free);
    __privateAdd(this, _disposed);
    __privateAdd(this, _sizes);
    __privateAdd(this, _starts);
    __privateAdd(this, _ttls);
    __privateAdd(this, _hasDispose);
    __privateAdd(this, _hasFetchMethod);
    __privateAdd(this, _hasDisposeAfter);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i) => {
    });
    __privateAdd(this, _addItemSize, (_i, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size3, sizeCalculation) => {
      if (size3 || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    /**
     * A String value that is used in the creation of the default string description of an object.
     * Called by the built-in method Object.prototype.toString.
     */
    __publicField(this, _a3, "LRUCache");
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max2 !== 0 && !isPosInt(max2)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max2);
    }
    __privateSet(this, _max, max2);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max2).fill(void 0));
    __privateSet(this, _valList, new Array(max2).fill(void 0));
    __privateSet(this, _next, new UintArray(max2));
    __privateSet(this, _prev, new UintArray(max2));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max2));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg2 = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg2, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c6) {
    return {
      // properties
      starts: __privateGet(c6, _starts),
      ttls: __privateGet(c6, _ttls),
      sizes: __privateGet(c6, _sizes),
      keyMap: __privateGet(c6, _keyMap),
      keyList: __privateGet(c6, _keyList),
      valList: __privateGet(c6, _valList),
      next: __privateGet(c6, _next),
      prev: __privateGet(c6, _prev),
      get head() {
        return __privateGet(c6, _head);
      },
      get tail() {
        return __privateGet(c6, _tail);
      },
      free: __privateGet(c6, _free),
      // methods
      isBackgroundFetch: (p4) => {
        var _a5;
        return __privateMethod(_a5 = c6, _LRUCache_instances, isBackgroundFetch_fn).call(_a5, p4);
      },
      backgroundFetch: (k2, index2, options, context) => {
        var _a5;
        return __privateMethod(_a5 = c6, _LRUCache_instances, backgroundFetch_fn).call(_a5, k2, index2, options, context);
      },
      moveToTail: (index2) => {
        var _a5;
        return __privateMethod(_a5 = c6, _LRUCache_instances, moveToTail_fn).call(_a5, index2);
      },
      indexes: (options) => {
        var _a5;
        return __privateMethod(_a5 = c6, _LRUCache_instances, indexes_fn).call(_a5, options);
      },
      rindexes: (options) => {
        var _a5;
        return __privateMethod(_a5 = c6, _LRUCache_instances, rindexes_fn).call(_a5, options);
      },
      isStale: (index2) => {
        var _a5;
        return __privateGet(_a5 = c6, _isStale).call(_a5, index2);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i4 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i4] !== void 0 && __privateGet(this, _keyList)[i4] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield [__privateGet(this, _keyList)[i4], __privateGet(this, _valList)[i4]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i4 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i4] !== void 0 && __privateGet(this, _keyList)[i4] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield [__privateGet(this, _keyList)[i4], __privateGet(this, _valList)[i4]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i4 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const k2 = __privateGet(this, _keyList)[i4];
      if (k2 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield k2;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i4 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const k2 = __privateGet(this, _keyList)[i4];
      if (k2 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield k2;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i4 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v6 = __privateGet(this, _valList)[i4];
      if (v6 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield __privateGet(this, _valList)[i4];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i4 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v6 = __privateGet(this, _valList)[i4];
      if (v6 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield __privateGet(this, _valList)[i4];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [(_b = Symbol.iterator, _a3 = Symbol.toStringTag, _b)]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn2, getOptions2 = {}) {
    for (const i4 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v6 = __privateGet(this, _valList)[i4];
      const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6) ? v6.__staleWhileFetching : v6;
      if (value2 === void 0)
        continue;
      if (fn2(value2, __privateGet(this, _keyList)[i4], this)) {
        return this.get(__privateGet(this, _keyList)[i4], getOptions2);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn2, thisp = this) {
    for (const i4 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v6 = __privateGet(this, _valList)[i4];
      const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6) ? v6.__staleWhileFetching : v6;
      if (value2 === void 0)
        continue;
      fn2.call(thisp, value2, __privateGet(this, _keyList)[i4], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn2, thisp = this) {
    for (const i4 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v6 = __privateGet(this, _valList)[i4];
      const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6) ? v6.__staleWhileFetching : v6;
      if (value2 === void 0)
        continue;
      fn2.call(thisp, value2, __privateGet(this, _keyList)[i4], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i4 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i4)) {
        this.delete(__privateGet(this, _keyList)[i4]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
   * single key. Always returns stale values, if their info is found in the
   * cache, so be sure to check for expired TTLs if relevant.
   */
  info(key) {
    const i4 = __privateGet(this, _keyMap).get(key);
    if (i4 === void 0)
      return void 0;
    const v6 = __privateGet(this, _valList)[i4];
    const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6) ? v6.__staleWhileFetching : v6;
    if (value2 === void 0)
      return void 0;
    const entry = { value: value2 };
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      const ttl = __privateGet(this, _ttls)[i4];
      const start2 = __privateGet(this, _starts)[i4];
      if (ttl && start2) {
        const remain = ttl - (perf.now() - start2);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (__privateGet(this, _sizes)) {
      entry.size = __privateGet(this, _sizes)[i4];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i4 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i4];
      const v6 = __privateGet(this, _valList)[i4];
      const value2 = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6) ? v6.__staleWhileFetching : v6;
      if (value2 === void 0 || key === void 0)
        continue;
      const entry = { value: value2 };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i4];
        const age = perf.now() - __privateGet(this, _starts)[i4];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i4];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k2, v6, setOptions = {}) {
    var _a5, _b2, _c, _d, _e;
    if (v6 === void 0) {
      this.delete(k2);
      return this;
    }
    const { ttl = this.ttl, start: start2, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size3 = __privateGet(this, _requireSize).call(this, k2, v6, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size3 > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k2);
      return this;
    }
    let index2 = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0) {
      index2 = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index2] = k2;
      __privateGet(this, _valList)[index2] = v6;
      __privateGet(this, _keyMap).set(k2, index2);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index2;
      __privateGet(this, _prev)[index2] = __privateGet(this, _tail);
      __privateSet(this, _tail, index2);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index2, size3, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
      const oldVal = __privateGet(this, _valList)[index2];
      if (v6 !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s4 } = oldVal;
          if (s4 !== void 0 && !noDisposeOnSet) {
            if (__privateGet(this, _hasDispose)) {
              (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, s4, k2, "set");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([s4, k2, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_c = __privateGet(this, _dispose)) == null ? void 0 : _c.call(this, oldVal, k2, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_d = __privateGet(this, _disposed)) == null ? void 0 : _d.push([oldVal, k2, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index2);
        __privateGet(this, _addItemSize).call(this, index2, size3, status);
        __privateGet(this, _valList)[index2] = v6;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index2, ttl, start2);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index2);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_e = __privateGet(this, _disposeAfter)) == null ? void 0 : _e.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a5;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_a5 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a5.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 !== void 0) {
      const v6 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6) && v6.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index2)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index2);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index2);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index2)) {
      return;
    }
    const v6 = __privateGet(this, _valList)[index2];
    return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6) ? v6.__staleWhileFetching : v6;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size: size3 = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size: size3,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0) {
      if (status)
        status.fetch = "miss";
      const p4 = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k2, index2, options, context);
      return p4.__returned = p4;
    } else {
      const v6 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6)) {
        const stale = allowStale && v6.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v6.__staleWhileFetching : v6.__returned = v6;
      }
      const isStale = __privateGet(this, _isStale).call(this, index2);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index2);
        return v6;
      }
      const p4 = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k2, index2, options, context);
      const hasStale = p4.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p4.__staleWhileFetching : p4.__returned = p4;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k2, getOptions2 = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions2;
    const index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 !== void 0) {
      const value2 = __privateGet(this, _valList)[index2];
      const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value2);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index2);
      if (__privateGet(this, _isStale).call(this, index2)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k2);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value2 : void 0;
        } else {
          if (status && allowStale && value2.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value2.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value2.__staleWhileFetching;
        }
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        return value2;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k2) {
    var _a5, _b2, _c, _d;
    let deleted = false;
    if (__privateGet(this, _size) !== 0) {
      const index2 = __privateGet(this, _keyMap).get(k2);
      if (index2 !== void 0) {
        deleted = true;
        if (__privateGet(this, _size) === 1) {
          this.clear();
        } else {
          __privateGet(this, _removeItemSize).call(this, index2);
          const v6 = __privateGet(this, _valList)[index2];
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6)) {
            v6.__abortController.abort(new Error("deleted"));
          } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
            if (__privateGet(this, _hasDispose)) {
              (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v6, k2, "delete");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v6, k2, "delete"]);
            }
          }
          __privateGet(this, _keyMap).delete(k2);
          __privateGet(this, _keyList)[index2] = void 0;
          __privateGet(this, _valList)[index2] = void 0;
          if (index2 === __privateGet(this, _tail)) {
            __privateSet(this, _tail, __privateGet(this, _prev)[index2]);
          } else if (index2 === __privateGet(this, _head)) {
            __privateSet(this, _head, __privateGet(this, _next)[index2]);
          } else {
            const pi = __privateGet(this, _prev)[index2];
            __privateGet(this, _next)[pi] = __privateGet(this, _next)[index2];
            const ni = __privateGet(this, _next)[index2];
            __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index2];
          }
          __privateWrapper(this, _size)._--;
          __privateGet(this, _free).push(index2);
        }
      }
    }
    if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) == null ? void 0 : _c.length)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var _a5, _b2, _c;
    for (const index2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
      const v6 = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6)) {
        v6.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = __privateGet(this, _keyList)[index2];
        if (__privateGet(this, _hasDispose)) {
          (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v6, k2, "delete");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v6, k2, "delete"]);
        }
      }
    }
    __privateGet(this, _keyMap).clear();
    __privateGet(this, _valList).fill(void 0);
    __privateGet(this, _keyList).fill(void 0);
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      __privateGet(this, _ttls).fill(0);
      __privateGet(this, _starts).fill(0);
    }
    if (__privateGet(this, _sizes)) {
      __privateGet(this, _sizes).fill(0);
    }
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateGet(this, _free).length = 0;
    __privateSet(this, _calculatedSize, 0);
    __privateSet(this, _size, 0);
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
      }
    }
  }
};
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_LRUCache_instances = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index2, ttl, start2 = perf.now()) => {
    starts[index2] = ttl !== 0 ? start2 : 0;
    ttls[index2] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t4 = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index2)) {
          this.delete(__privateGet(this, _keyList)[index2]);
        }
      }, ttl + 1);
      if (t4.unref) {
        t4.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index2) => {
    starts[index2] = ttls[index2] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index2) => {
    if (ttls[index2]) {
      const ttl = ttls[index2];
      const start2 = starts[index2];
      if (!ttl || !start2)
        return;
      status.ttl = ttl;
      status.start = start2;
      status.now = cachedNow || getNow();
      const age = status.now - start2;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n5 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n5;
      const t4 = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t4.unref) {
        t4.unref();
      }
    }
    return n5;
  };
  this.getRemainingTTL = (key) => {
    const index2 = __privateGet(this, _keyMap).get(key);
    if (index2 === void 0) {
      return 0;
    }
    const ttl = ttls[index2];
    const start2 = starts[index2];
    if (!ttl || !start2) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start2;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index2) => {
    const s4 = starts[index2];
    const t4 = ttls[index2];
    return !!t4 && !!s4 && (cachedNow || getNow()) - s4 > t4;
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index2) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index2]);
    sizes[index2] = 0;
  });
  __privateSet(this, _requireSize, (k2, v6, size3, sizeCalculation) => {
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6)) {
      return 0;
    }
    if (!isPosInt(size3)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size3 = sizeCalculation(v6, k2);
        if (!isPosInt(size3)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size3;
  });
  __privateSet(this, _addItemSize, (index2, size3, status) => {
    sizes[index2] = size3;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index2];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index2]);
    if (status) {
      status.entrySize = size3;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i4 = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i4)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i4)) {
        yield i4;
      }
      if (i4 === __privateGet(this, _head)) {
        break;
      } else {
        i4 = __privateGet(this, _prev)[i4];
      }
    }
  }
};
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i4 = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i4)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i4)) {
        yield i4;
      }
      if (i4 === __privateGet(this, _tail)) {
        break;
      } else {
        i4 = __privateGet(this, _next)[i4];
      }
    }
  }
};
isValidIndex_fn = function(index2) {
  return index2 !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index2]) === index2;
};
evict_fn = function(free) {
  var _a5, _b2;
  const head = __privateGet(this, _head);
  const k2 = __privateGet(this, _keyList)[head];
  const v6 = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6)) {
    v6.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a5 = __privateGet(this, _dispose)) == null ? void 0 : _a5.call(this, v6, k2, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v6, k2, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k2);
  __privateWrapper(this, _size)._--;
  return head;
};
backgroundFetch_fn = function(k2, index2, options, context) {
  const v6 = index2 === void 0 ? void 0 : __privateGet(this, _valList)[index2];
  if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v6)) {
    return v6;
  }
  const ac = new AC();
  const { signal } = options;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb = (v7, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v7 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p4;
    if (__privateGet(this, _valList)[index2] === p4) {
      if (v7 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
        } else {
          this.delete(k2);
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k2, v7, fetchOpts.options);
      }
    }
    return v7;
  };
  const eb = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p4;
    if (__privateGet(this, _valList)[index2] === p4) {
      const del2 = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del2) {
        this.delete(k2);
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a5;
    const fmp = (_a5 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a5.call(this, k2, v6, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v7) => res(v7 === void 0 ? void 0 : v7), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res(void 0);
        if (options.allowStaleOnFetchAbort) {
          res = (v7) => cb(v7, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p4 = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p4, {
    __abortController: ac,
    __staleWhileFetching: v6,
    __returned: void 0
  });
  if (index2 === void 0) {
    this.set(k2, bf, { ...fetchOpts.options, status: void 0 });
    index2 = __privateGet(this, _keyMap).get(k2);
  } else {
    __privateGet(this, _valList)[index2] = bf;
  }
  return bf;
};
isBackgroundFetch_fn = function(p4) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b2 = p4;
  return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
};
connect_fn = function(p4, n5) {
  __privateGet(this, _prev)[n5] = p4;
  __privateGet(this, _next)[p4] = n5;
};
moveToTail_fn = function(index2) {
  if (index2 !== __privateGet(this, _tail)) {
    if (index2 === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index2]);
    } else {
      __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index2], __privateGet(this, _next)[index2]);
    }
    __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index2);
    __privateSet(this, _tail, index2);
  }
};
var LRUCache = _LRUCache;

// node_modules/partysocket/dist/chunk-TPTC3KUF.mjs
if (!globalThis.EventTarget || !globalThis.Event) {
  console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
}
var ErrorEvent2 = class extends Event {
  constructor(error2, target) {
    super("error", target);
    __publicField(this, "message");
    __publicField(this, "error");
    this.message = error2.message;
    this.error = error2;
  }
};
var CloseEvent = class extends Event {
  constructor(code = 1e3, reason = "", target) {
    super("close", target);
    __publicField(this, "code");
    __publicField(this, "reason");
    __publicField(this, "wasClean", true);
    this.code = code;
    this.reason = reason;
  }
};
var Events = {
  Event,
  ErrorEvent: ErrorEvent2,
  CloseEvent
};
function assert2(condition, msg2) {
  if (!condition) {
    throw new Error(msg2);
  }
}
function cloneEventBrowser(e4) {
  return new e4.constructor(e4.type, e4);
}
function cloneEventNode(e4) {
  if ("data" in e4) {
    const evt2 = new MessageEvent(e4.type, e4);
    return evt2;
  }
  if ("code" in e4 || "reason" in e4) {
    const evt2 = new CloseEvent(
      // @ts-expect-error we need to fix event/listener types
      e4.code || 1999,
      // @ts-expect-error we need to fix event/listener types
      e4.reason || "unknown reason",
      e4
    );
    return evt2;
  }
  if ("error" in e4) {
    const evt2 = new ErrorEvent2(e4.error, e4);
    return evt2;
  }
  const evt = new Event(e4.type, e4);
  return evt;
}
var _a4;
var isNode3 = typeof process !== "undefined" && typeof ((_a4 = process.versions) == null ? void 0 : _a4.node) !== "undefined" && typeof document === "undefined";
var cloneEvent = isNode3 ? cloneEventNode : cloneEventBrowser;
var DEFAULT = {
  maxReconnectionDelay: 1e4,
  minReconnectionDelay: 1e3 + Math.random() * 4e3,
  minUptime: 5e3,
  reconnectionDelayGrowFactor: 1.3,
  connectionTimeout: 4e3,
  maxRetries: Infinity,
  maxEnqueuedMessages: Infinity,
  startClosed: false,
  debug: false
};
var didWarnAboutMissingWebSocket = false;
var ReconnectingWebSocket = class _ReconnectingWebSocket extends EventTarget {
  constructor(url, protocols, options = {}) {
    super();
    __publicField(this, "_ws");
    __publicField(this, "_retryCount", -1);
    __publicField(this, "_uptimeTimeout");
    __publicField(this, "_connectTimeout");
    __publicField(this, "_shouldReconnect", true);
    __publicField(this, "_connectLock", false);
    __publicField(this, "_binaryType", "blob");
    __publicField(this, "_closeCalled", false);
    __publicField(this, "_messageQueue", []);
    __publicField(this, "_url");
    __publicField(this, "_protocols");
    __publicField(this, "_options");
    /**
     * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
     */
    __publicField(this, "onclose", null);
    /**
     * An event listener to be called when an error occurs
     */
    __publicField(this, "onerror", null);
    /**
     * An event listener to be called when a message is received from the server
     */
    __publicField(this, "onmessage", null);
    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data
     */
    __publicField(this, "onopen", null);
    __publicField(this, "_handleOpen", (event) => {
      this._debug("open event");
      const { minUptime = DEFAULT.minUptime } = this._options;
      clearTimeout(this._connectTimeout);
      this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
      assert2(this._ws, "WebSocket is not defined");
      this._ws.binaryType = this._binaryType;
      this._messageQueue.forEach((message) => {
        var _a5;
        return (_a5 = this._ws) == null ? void 0 : _a5.send(message);
      });
      this._messageQueue = [];
      if (this.onopen) {
        this.onopen(event);
      }
      this.dispatchEvent(cloneEvent(event));
    });
    __publicField(this, "_handleMessage", (event) => {
      this._debug("message event");
      if (this.onmessage) {
        this.onmessage(event);
      }
      this.dispatchEvent(cloneEvent(event));
    });
    __publicField(this, "_handleError", (event) => {
      this._debug("error event", event.message);
      this._disconnect(
        void 0,
        event.message === "TIMEOUT" ? "timeout" : void 0
      );
      if (this.onerror) {
        this.onerror(event);
      }
      this._debug("exec error listeners");
      this.dispatchEvent(cloneEvent(event));
      this._connect();
    });
    __publicField(this, "_handleClose", (event) => {
      this._debug("close event");
      this._clearTimeouts();
      if (this._shouldReconnect) {
        this._connect();
      }
      if (this.onclose) {
        this.onclose(event);
      }
      this.dispatchEvent(cloneEvent(event));
    });
    this._url = url;
    this._protocols = protocols;
    this._options = options;
    if (this._options.startClosed) {
      this._shouldReconnect = false;
    }
    this._connect();
  }
  static get CONNECTING() {
    return 0;
  }
  static get OPEN() {
    return 1;
  }
  static get CLOSING() {
    return 2;
  }
  static get CLOSED() {
    return 3;
  }
  get CONNECTING() {
    return _ReconnectingWebSocket.CONNECTING;
  }
  get OPEN() {
    return _ReconnectingWebSocket.OPEN;
  }
  get CLOSING() {
    return _ReconnectingWebSocket.CLOSING;
  }
  get CLOSED() {
    return _ReconnectingWebSocket.CLOSED;
  }
  get binaryType() {
    return this._ws ? this._ws.binaryType : this._binaryType;
  }
  set binaryType(value2) {
    this._binaryType = value2;
    if (this._ws) {
      this._ws.binaryType = value2;
    }
  }
  /**
   * Returns the number or connection retries
   */
  get retryCount() {
    return Math.max(this._retryCount, 0);
  }
  /**
   * The number of bytes of data that have been queued using calls to send() but not yet
   * transmitted to the network. This value resets to zero once all queued data has been sent.
   * This value does not reset to zero when the connection is closed; if you keep calling send(),
   * this will continue to climb. Read only
   */
  get bufferedAmount() {
    const bytes = this._messageQueue.reduce((acc, message) => {
      if (typeof message === "string") {
        acc += message.length;
      } else if (message instanceof Blob) {
        acc += message.size;
      } else {
        acc += message.byteLength;
      }
      return acc;
    }, 0);
    return bytes + (this._ws ? this._ws.bufferedAmount : 0);
  }
  /**
   * The extensions selected by the server. This is currently only the empty string or a list of
   * extensions as negotiated by the connection
   */
  get extensions() {
    return this._ws ? this._ws.extensions : "";
  }
  /**
   * A string indicating the name of the sub-protocol the server selected;
   * this will be one of the strings specified in the protocols parameter when creating the
   * WebSocket object
   */
  get protocol() {
    return this._ws ? this._ws.protocol : "";
  }
  /**
   * The current state of the connection; this is one of the Ready state constants
   */
  get readyState() {
    if (this._ws) {
      return this._ws.readyState;
    }
    return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;
  }
  /**
   * The URL as resolved by the constructor
   */
  get url() {
    return this._ws ? this._ws.url : "";
  }
  /**
   * Whether the websocket object is now in reconnectable state
   */
  get shouldReconnect() {
    return this._shouldReconnect;
  }
  /**
   * Closes the WebSocket connection or connection attempt, if any. If the connection is already
   * CLOSED, this method does nothing
   */
  close(code = 1e3, reason) {
    this._closeCalled = true;
    this._shouldReconnect = false;
    this._clearTimeouts();
    if (!this._ws) {
      this._debug("close enqueued: no ws instance");
      return;
    }
    if (this._ws.readyState === this.CLOSED) {
      this._debug("close: already closed");
      return;
    }
    this._ws.close(code, reason);
  }
  /**
   * Closes the WebSocket connection or connection attempt and connects again.
   * Resets retry counter;
   */
  reconnect(code, reason) {
    this._shouldReconnect = true;
    this._closeCalled = false;
    this._retryCount = -1;
    if (!this._ws || this._ws.readyState === this.CLOSED) {
      this._connect();
    } else {
      this._disconnect(code, reason);
      this._connect();
    }
  }
  /**
   * Enqueue specified data to be transmitted to the server over the WebSocket connection
   */
  send(data) {
    if (this._ws && this._ws.readyState === this.OPEN) {
      this._debug("send", data);
      this._ws.send(data);
    } else {
      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
      if (this._messageQueue.length < maxEnqueuedMessages) {
        this._debug("enqueue", data);
        this._messageQueue.push(data);
      }
    }
  }
  _debug(...args2) {
    if (this._options.debug) {
      console.log.apply(console, ["RWS>", ...args2]);
    }
  }
  _getNextDelay() {
    const {
      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,
      minReconnectionDelay = DEFAULT.minReconnectionDelay,
      maxReconnectionDelay = DEFAULT.maxReconnectionDelay
    } = this._options;
    let delay = 0;
    if (this._retryCount > 0) {
      delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
      if (delay > maxReconnectionDelay) {
        delay = maxReconnectionDelay;
      }
    }
    this._debug("next delay", delay);
    return delay;
  }
  _wait() {
    return new Promise((resolve) => {
      setTimeout(resolve, this._getNextDelay());
    });
  }
  _getNextProtocols(protocolsProvider) {
    if (!protocolsProvider)
      return Promise.resolve(null);
    if (typeof protocolsProvider === "string" || Array.isArray(protocolsProvider)) {
      return Promise.resolve(protocolsProvider);
    }
    if (typeof protocolsProvider === "function") {
      const protocols = protocolsProvider();
      if (!protocols)
        return Promise.resolve(null);
      if (typeof protocols === "string" || Array.isArray(protocols)) {
        return Promise.resolve(protocols);
      }
      if (protocols.then) {
        return protocols;
      }
    }
    throw Error("Invalid protocols");
  }
  _getNextUrl(urlProvider) {
    if (typeof urlProvider === "string") {
      return Promise.resolve(urlProvider);
    }
    if (typeof urlProvider === "function") {
      const url = urlProvider();
      if (typeof url === "string") {
        return Promise.resolve(url);
      }
      if (url.then) {
        return url;
      }
    }
    throw Error("Invalid URL");
  }
  _connect() {
    if (this._connectLock || !this._shouldReconnect) {
      return;
    }
    this._connectLock = true;
    const {
      maxRetries = DEFAULT.maxRetries,
      connectionTimeout = DEFAULT.connectionTimeout
    } = this._options;
    if (this._retryCount >= maxRetries) {
      this._debug("max retries reached", this._retryCount, ">=", maxRetries);
      return;
    }
    this._retryCount++;
    this._debug("connect", this._retryCount);
    this._removeListeners();
    this._wait().then(
      () => Promise.all([
        this._getNextUrl(this._url),
        this._getNextProtocols(this._protocols || null)
      ])
    ).then(([url, protocols]) => {
      if (this._closeCalled) {
        this._connectLock = false;
        return;
      }
      if (!this._options.WebSocket && typeof WebSocket === "undefined" && !didWarnAboutMissingWebSocket) {
        console.error(`‼️ No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`);
        didWarnAboutMissingWebSocket = true;
      }
      const WS = this._options.WebSocket || WebSocket;
      this._debug("connect", { url, protocols });
      this._ws = protocols ? new WS(url, protocols) : new WS(url);
      this._ws.binaryType = this._binaryType;
      this._connectLock = false;
      this._addListeners();
      this._connectTimeout = setTimeout(
        () => this._handleTimeout(),
        connectionTimeout
      );
    }).catch((err) => {
      this._connectLock = false;
      this._handleError(new Events.ErrorEvent(Error(err.message), this));
    });
  }
  _handleTimeout() {
    this._debug("timeout event");
    this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
  }
  _disconnect(code = 1e3, reason) {
    this._clearTimeouts();
    if (!this._ws) {
      return;
    }
    this._removeListeners();
    try {
      this._ws.close(code, reason);
      this._handleClose(new Events.CloseEvent(code, reason, this));
    } catch (error2) {
    }
  }
  _acceptOpen() {
    this._debug("accept open");
    this._retryCount = 0;
  }
  _removeListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("removeListeners");
    this._ws.removeEventListener("open", this._handleOpen);
    this._ws.removeEventListener("close", this._handleClose);
    this._ws.removeEventListener("message", this._handleMessage);
    this._ws.removeEventListener("error", this._handleError);
  }
  _addListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("addListeners");
    this._ws.addEventListener("open", this._handleOpen);
    this._ws.addEventListener("close", this._handleClose);
    this._ws.addEventListener("message", this._handleMessage);
    this._ws.addEventListener("error", this._handleError);
  }
  _clearTimeouts() {
    clearTimeout(this._connectTimeout);
    clearTimeout(this._uptimeTimeout);
  }
};

// node_modules/@keystar/ui/dist/keystar-ui-avatar.js
var import_react104 = __toESM(require_react());
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var Avatar = (0, import_react104.forwardRef)(function Avatar2(props, forwardedRef) {
  const $ = c2(19);
  props = useSlotProps(props, "avatar");
  let t0;
  let otherProps;
  let alt;
  if ($[0] !== props) {
    ({
      alt,
      size: t0,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = otherProps;
    $[3] = alt;
  } else {
    t0 = $[1];
    otherProps = $[2];
    alt = $[3];
  }
  const size3 = t0 === void 0 ? "regular" : t0;
  const styleProps = useStyleProps(otherProps);
  const t1 = size3 === "regular" ? void 0 : size3;
  let t22;
  if ($[4] !== otherProps) {
    t22 = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
    $[4] = otherProps;
    $[5] = t22;
  } else {
    t22 = $[5];
  }
  let t32;
  if ($[6] !== styleProps.className) {
    t32 = classNames(styleProps.className, css({
      alignItems: "center",
      backgroundColor: tokenSchema.color.background.surfaceTertiary,
      borderRadius: "50%",
      display: "inline-flex",
      flexShrink: 0,
      fontSize: "var(--avatar-text-size)",
      height: "var(--avatar-size)",
      justifyContent: "center",
      overflow: "hidden",
      width: "var(--avatar-size)",
      userSelect: "none",
      "--avatar-size": tokenSchema.size.element.regular,
      "--avatar-text-size": tokenSchema.typography.text.regular.size,
      "&[data-size=xsmall]": {
        "--avatar-size": tokenSchema.size.element.xsmall,
        "--avatar-text-size": tokenSchema.typography.text.small.size
      },
      "&[data-size=small]": {
        "--avatar-size": tokenSchema.size.element.small,
        "--avatar-text-size": tokenSchema.typography.text.small.size
      },
      "&[data-size=medium]": {
        "--avatar-size": tokenSchema.size.element.medium,
        "--avatar-text-size": tokenSchema.typography.text.medium.size
      },
      "&[data-size=large]": {
        "--avatar-size": tokenSchema.size.element.large,
        "--avatar-text-size": tokenSchema.typography.text.large.size
      },
      "&[data-size=xlarge]": {
        "--avatar-size": tokenSchema.size.element.xlarge,
        "--avatar-text-size": tokenSchema.typography.text.large.size
      }
    }));
    $[6] = styleProps.className;
    $[7] = t32;
  } else {
    t32 = $[7];
  }
  let t4;
  if ($[8] !== props || $[9] !== size3) {
    t4 = "src" in props ? (0, import_jsx_runtime33.jsx)("div", {
      className: css({
        height: "100%",
        width: "100%"
      }),
      style: {
        backgroundImage: `url(${props.src})`,
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
        backgroundSize: "cover"
      }
    }) : (0, import_jsx_runtime33.jsx)(Text, {
      "aria-hidden": true,
      color: "neutralSecondary",
      weight: "medium",
      UNSAFE_className: css({
        fontSize: "inherit"
      }),
      children: getInitials(props.name, size3)
    });
    $[8] = props;
    $[9] = size3;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== forwardedRef || $[12] !== alt || $[13] !== t1 || $[14] !== styleProps || $[15] !== t22 || $[16] !== t32 || $[17] !== t4) {
    t5 = (0, import_jsx_runtime33.jsx)("div", {
      ref: forwardedRef,
      role: "img",
      "aria-label": alt,
      "data-size": t1,
      ...styleProps,
      ...t22,
      className: t32,
      children: t4
    });
    $[11] = forwardedRef;
    $[12] = alt;
    $[13] = t1;
    $[14] = styleProps;
    $[15] = t22;
    $[16] = t32;
    $[17] = t4;
    $[18] = t5;
  } else {
    t5 = $[18];
  }
  return t5;
});
function getInitials(name, size3) {
  const words = name.split(" ");
  const first = words[0].charAt(0);
  const last2 = words[words.length - 1].charAt(0);
  if (size3 === "xsmall") {
    return `${first}`.toUpperCase();
  }
  return `${first}${last2}`.toUpperCase();
}

// node_modules/@keystatic/core/dist/index-330df5ae.js
var import_react105 = __toESM(require_react(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_cookie = __toESM(require_dist(), 1);
var RouterContext = (0, import_react105.createContext)(null);
function RouterProvider(props) {
  const $ = c(17);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => window.location.href;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [url, setUrl] = (0, import_react105.useState)(t0);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = function navigate2(url_0, replace2) {
      const newUrl = new URL(url_0, window.location.href);
      if (newUrl.origin !== window.location.origin || !newUrl.pathname.startsWith("/keystatic")) {
        window.location.assign(newUrl);
        return;
      }
      window.history[replace2 ? "replaceState" : "pushState"](null, "", newUrl);
      (0, import_react105.startTransition)(() => {
        setUrl(newUrl.toString());
      });
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const navigate = t1;
  let t22;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t22 = function replace2(path) {
      navigate(path, true);
    };
    $[2] = t22;
  } else {
    t22 = $[2];
  }
  const replace_0 = t22;
  let t32;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t32 = function push3(path_0) {
      navigate(path_0, false);
    };
    $[3] = t32;
  } else {
    t32 = $[3];
  }
  const push2 = t32;
  let t4;
  let parsedUrl;
  if ($[4] !== url) {
    parsedUrl = new URL(url);
    const replaced = parsedUrl.pathname.replace(/^\/keystatic\/?/, "");
    t4 = replaced === "" ? [] : replaced.split("/").map(decodeURIComponent);
    $[4] = url;
    $[5] = t4;
    $[6] = parsedUrl;
  } else {
    t4 = $[5];
    parsedUrl = $[6];
  }
  const params2 = t4;
  const t5 = parsedUrl.pathname + parsedUrl.search;
  let t6;
  if ($[7] !== t5 || $[8] !== parsedUrl.pathname || $[9] !== parsedUrl.search || $[10] !== params2) {
    t6 = {
      href: t5,
      pathname: parsedUrl.pathname,
      search: parsedUrl.search,
      replace: replace_0,
      push: push2,
      params: params2
    };
    $[7] = t5;
    $[8] = parsedUrl.pathname;
    $[9] = parsedUrl.search;
    $[10] = params2;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  const router = t6;
  let t7;
  let t8;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => {
      const handleNavigate = () => {
        (0, import_react105.startTransition)(() => {
          setUrl(window.location.href);
        });
      };
      window.addEventListener("popstate", handleNavigate);
      return () => {
        window.removeEventListener("popstate", handleNavigate);
      };
    };
    t8 = [];
    $[12] = t7;
    $[13] = t8;
  } else {
    t7 = $[12];
    t8 = $[13];
  }
  (0, import_react105.useEffect)(t7, t8);
  let t9;
  if ($[14] !== router || $[15] !== props.children) {
    t9 = (0, import_jsx_runtime34.jsx)(RouterContext.Provider, {
      value: router,
      children: props.children
    });
    $[14] = router;
    $[15] = props.children;
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  return t9;
}
function useRouter() {
  const router = (0, import_react105.useContext)(RouterContext);
  if (router == null) {
    throw new Error("useRouter must be used within a RouterProvider");
  }
  return router;
}
function fixPath(path) {
  return path.replace(/^\.?\/+/, "").replace(/\/*$/, "");
}
var collectionPath = /\/\*\*?(?:$|\/)/;
function getConfiguredCollectionPath(config, collection) {
  var _collectionConfig$pat;
  const collectionConfig = config.collections[collection];
  const path = (_collectionConfig$pat = collectionConfig.path) !== null && _collectionConfig$pat !== void 0 ? _collectionConfig$pat : `${collection}/*/`;
  if (!collectionPath.test(path)) {
    throw new Error(`Collection path must end with /* or /** or include /*/ or /**/ but ${collection} has ${path}`);
  }
  return path;
}
function getCollectionPath(config, collection) {
  const configuredPath = getConfiguredCollectionPath(config, collection);
  const path = fixPath(configuredPath.replace(/\*\*?.*$/, ""));
  return path;
}
function getCollectionFormat(config, collection) {
  const collectionConfig = config.collections[collection];
  return getFormatInfo(collectionConfig)(getConfiguredCollectionPath(config, collection));
}
function getSingletonFormat(config, singleton) {
  var _singletonConfig$path;
  const singletonConfig = config.singletons[singleton];
  return getFormatInfo(singletonConfig)((_singletonConfig$path = singletonConfig.path) !== null && _singletonConfig$path !== void 0 ? _singletonConfig$path : `${singleton}/`);
}
function getCollectionItemPath(config, collection, slug) {
  const basePath = getCollectionPath(config, collection);
  const suffix = getCollectionItemSlugSuffix(config, collection);
  return `${basePath}/${slug}${suffix}`;
}
function getEntryDataFilepath(dir, formatInfo) {
  return `${dir}${formatInfo.dataLocation === "index" ? "/index" : ""}${getDataFileExtension(formatInfo)}`;
}
function getSlugGlobForCollection(config, collection) {
  const collectionPath2 = getConfiguredCollectionPath(config, collection);
  return collectionPath2.includes("**") ? "**" : "*";
}
function getCollectionItemSlugSuffix(config, collection) {
  const configuredPath = getConfiguredCollectionPath(config, collection);
  const path = fixPath(configuredPath.replace(/^[^*]+\*\*?/, ""));
  return path ? `/${path}` : "";
}
function getSingletonPath(config, singleton) {
  var _singleton$path, _singleton$path2;
  if ((_singleton$path = config.singletons[singleton].path) !== null && _singleton$path !== void 0 && _singleton$path.includes("*")) {
    throw new Error(`Singleton paths cannot include * but ${singleton} has ${config.singletons[singleton].path}`);
  }
  return fixPath((_singleton$path2 = config.singletons[singleton].path) !== null && _singleton$path2 !== void 0 ? _singleton$path2 : singleton);
}
function getDataFileExtension(formatInfo) {
  return formatInfo.contentField ? formatInfo.contentField.contentExtension : "." + formatInfo.data;
}
function weakMemoize3(func) {
  const cache3 = /* @__PURE__ */ new WeakMap();
  return (arg) => {
    if (cache3.has(arg)) {
      return cache3.get(arg);
    }
    const result = func(arg);
    cache3.set(arg, result);
    return result;
  };
}
function memoize4(func) {
  const cache3 = /* @__PURE__ */ new Map();
  return (arg) => {
    if (cache3.has(arg)) {
      return cache3.get(arg);
    }
    const result = func(arg);
    cache3.set(arg, result);
    return result;
  };
}
var getFormatInfo = weakMemoize3((collectionOrSingleton) => {
  return memoize4((path) => _getFormatInfo(collectionOrSingleton, path));
});
function _getFormatInfo(collectionOrSingleton, path) {
  var _format$data;
  const dataLocation = path.endsWith("/") ? "index" : "outer";
  const {
    schema,
    format = "yaml"
  } = collectionOrSingleton;
  if (typeof format === "string") {
    return {
      dataLocation,
      contentField: void 0,
      data: format
    };
  }
  let contentField;
  if (format.contentField) {
    let field = {
      kind: "object",
      fields: schema
    };
    let path2 = Array.isArray(format.contentField) ? format.contentField : [format.contentField];
    contentField = {
      path: path2,
      contentExtension: getContentExtension(path2, field, () => path2.length === 1 ? path2[0] : JSON.stringify(path2))
    };
  }
  return {
    data: (_format$data = format.data) !== null && _format$data !== void 0 ? _format$data : "yaml",
    contentField,
    dataLocation
  };
}
function getContentExtension(path, schema, debugName) {
  if (path.length === 0) {
    if (schema.kind !== "form" || schema.formKind !== "content") {
      throw new Error(`Content field for ${debugName()} is not a content field`);
    }
    return schema.contentExtension;
  }
  if (schema.kind === "object") {
    return getContentExtension(path.slice(1), schema.fields[path[0]], debugName);
  }
  if (schema.kind === "conditional") {
    if (path[0] !== "value") {
      throw new Error(`Conditional fields referenced in a contentField path must only reference the value field (${debugName()})`);
    }
    let contentExtension;
    const innerPath = path.slice(1);
    for (const value2 of Object.values(schema.values)) {
      const foundContentExtension = getContentExtension(innerPath, value2, debugName);
      if (!contentExtension) {
        contentExtension = foundContentExtension;
        continue;
      }
      if (contentExtension !== foundContentExtension) {
        throw new Error(`contentField ${debugName()} has conflicting content extensions`);
      }
    }
    if (!contentExtension) {
      throw new Error(`contentField ${debugName()} does not point to a content field`);
    }
    return contentExtension;
  }
  throw new Error(`Path specified in contentField ${debugName()} does not point to a content field`);
}
function getPathPrefix(storage) {
  if (storage.kind === "local" || !storage.pathPrefix) {
    return void 0;
  }
  return fixPath(storage.pathPrefix) + "/";
}
async function sha1(content) {
  const hashBuffer = await crypto.subtle.digest("SHA-1", content);
  return bytesToHex(new Uint8Array(hashBuffer));
}
var textEncoder$1 = new TextEncoder();
var blobShaCache = /* @__PURE__ */ new WeakMap();
async function blobSha(contents) {
  const cached = blobShaCache.get(contents);
  if (cached !== void 0) return cached;
  const blobPrefix = textEncoder$1.encode("blob " + contents.length + "\0");
  const array2 = new Uint8Array(blobPrefix.byteLength + contents.byteLength);
  array2.set(blobPrefix, 0);
  array2.set(contents, blobPrefix.byteLength);
  const digestPromise = sha1(array2);
  blobShaCache.set(contents, digestPromise);
  digestPromise.then((digest) => blobShaCache.set(contents, digest));
  return digestPromise;
}
function getTreeNodeAtPath(root, path) {
  const parts = path.split("/");
  let node2 = root.get(parts[0]);
  for (const part of parts.slice(1)) {
    if (!node2) return void 0;
    if (!node2.children) return void 0;
    node2 = node2.children.get(part);
  }
  return node2;
}
function getNodeAtPath(tree2, path) {
  if (path === "") return tree2;
  let node2 = tree2;
  for (const part of path.split("/")) {
    if (!node2.has(part)) {
      node2.set(part, /* @__PURE__ */ new Map());
    }
    const innerNode = node2.get(part);
    assert(innerNode instanceof Map, "expected tree");
    node2 = innerNode;
  }
  return node2;
}
function getFilename(path) {
  return path.replace(/.*\//, "");
}
function getDirname(path) {
  if (!path.includes("/")) return "";
  return path.replace(/\/[^/]+$/, "");
}
function toTreeChanges(changes) {
  const changesRoot = /* @__PURE__ */ new Map();
  for (const deletion of changes.deletions) {
    const parentTree = getNodeAtPath(changesRoot, getDirname(deletion));
    parentTree.set(getFilename(deletion), "delete");
  }
  for (const addition of changes.additions) {
    const parentTree = getNodeAtPath(changesRoot, getDirname(addition.path));
    parentTree.set(getFilename(addition.path), addition.contents);
  }
  return changesRoot;
}
var SPACE_CHAR_CODE = 32;
var space2 = new Uint8Array([SPACE_CHAR_CODE]);
var nullchar = new Uint8Array([0]);
var tree = textEncoder$1.encode("tree ");
function treeSha(children) {
  const entries2 = [...children].map(([name, node2]) => ({
    name,
    sha: node2.entry.sha,
    mode: node2.entry.mode
  }));
  entries2.sort((a3, b2) => {
    const aName = a3.mode === "040000" ? a3.name + "/" : a3.name;
    const bName = b2.mode === "040000" ? b2.name + "/" : b2.name;
    return aName === bName ? 0 : aName < bName ? -1 : 1;
  });
  const treeObject = entries2.flatMap((entry) => {
    const mode = textEncoder$1.encode(entry.mode.replace(/^0/, ""));
    const name = textEncoder$1.encode(entry.name);
    const sha = hexToBytes(entry.sha);
    return [mode, space2, name, nullchar, sha];
  });
  return sha1(concatBytes([tree, textEncoder$1.encode(treeObject.reduce((sum, val) => sum + val.byteLength, 0).toString()), nullchar, ...treeObject]));
}
function concatBytes(byteArrays) {
  const totalLength = byteArrays.reduce((sum, arr) => sum + arr.byteLength, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of byteArrays) {
    result.set(arr, offset);
    offset += arr.byteLength;
  }
  return result;
}
function hexToBytes(str) {
  const bytes = new Uint8Array(str.length / 2);
  for (var i4 = 0; i4 < bytes.byteLength; i4 += 1) {
    const start2 = i4 * 2;
    bytes[i4] = parseInt(str.slice(start2, start2 + 2), 16);
  }
  return bytes;
}
async function createTreeNodeEntry(path, children) {
  const sha = await treeSha(children);
  return {
    path,
    mode: "040000",
    type: "tree",
    sha
  };
}
async function createBlobNodeEntry(path, contents) {
  const sha = "sha" in contents ? contents.sha : await blobSha(contents);
  return {
    path,
    mode: "100644",
    type: "blob",
    sha
  };
}
async function updateTreeWithChanges(tree2, changes) {
  var _await$updateTree;
  const newTree = (_await$updateTree = await updateTree(tree2, toTreeChanges(changes), [])) !== null && _await$updateTree !== void 0 ? _await$updateTree : /* @__PURE__ */ new Map();
  return {
    entries: treeToEntries(newTree),
    sha: await treeSha(newTree !== null && newTree !== void 0 ? newTree : /* @__PURE__ */ new Map())
  };
}
function treeToEntries(tree2) {
  return [...tree2.values()].flatMap((x3) => x3.children ? [x3.entry, ...treeToEntries(x3.children)] : [x3.entry]);
}
async function updateTree(tree2, changedTree, path) {
  const newTree = new Map(tree2);
  for (const [key, value2] of changedTree) {
    if (value2 === "delete") {
      newTree.delete(key);
    }
    if (value2 instanceof Map) {
      var _newTree$get$children, _newTree$get;
      const existingChildren = (_newTree$get$children = (_newTree$get = newTree.get(key)) === null || _newTree$get === void 0 ? void 0 : _newTree$get.children) !== null && _newTree$get$children !== void 0 ? _newTree$get$children : /* @__PURE__ */ new Map();
      const children = await updateTree(existingChildren, value2, path.concat(key));
      if (children === void 0) {
        newTree.delete(key);
        continue;
      }
      const entry = await createTreeNodeEntry(path.concat(key).join("/"), children);
      newTree.set(key, {
        entry,
        children
      });
    }
    if (value2 instanceof Uint8Array || typeof value2 === "object" && "sha" in value2) {
      const entry = await createBlobNodeEntry(path.concat(key).join("/"), value2);
      newTree.set(key, {
        entry
      });
    }
  }
  if (newTree.size === 0) {
    return void 0;
  }
  return newTree;
}
function treeEntriesToTreeNodes(entries2) {
  const root = /* @__PURE__ */ new Map();
  const getChildrenAtPath = (parts) => {
    var _node;
    if (parts.length === 0) {
      return root;
    }
    let node2 = root.get(parts[0]);
    for (const part of parts.slice(1)) {
      if (!node2) return void 0;
      if (!node2.children) return void 0;
      node2 = node2.children.get(part);
    }
    return (_node = node2) === null || _node === void 0 ? void 0 : _node.children;
  };
  for (const entry of entries2) {
    const split2 = entry.path.split("/");
    const children = getChildrenAtPath(split2.slice(0, -1));
    if (children) {
      children.set(split2[split2.length - 1], {
        entry,
        children: entry.type === "tree" ? /* @__PURE__ */ new Map() : void 0
      });
    }
  }
  return root;
}
function weakMemoizeN(fn2) {
  const root = {
    inner: /* @__PURE__ */ new WeakMap()
  };
  return function(...args2) {
    let currentCacheNode = root;
    for (const arg of args2) {
      const {
        inner
      } = currentCacheNode;
      if (!inner.has(arg)) {
        inner.set(arg, {
          inner: /* @__PURE__ */ new WeakMap()
        });
      }
      currentCacheNode = inner.get(arg);
    }
    if (!currentCacheNode.hasOwnProperty("value")) {
      currentCacheNode.value = fn2(...args2);
    }
    return currentCacheNode.value;
  };
}
var LOADING = {
  then() {
  }
};
function isThenable(value2) {
  return value2 && typeof value2.then === "function";
}
function suspendOnData(state) {
  if (state.kind === "error") {
    throw state.error;
  }
  if (state.kind === "loaded") {
    return state.data;
  }
  throw state.promise;
}
function useData(func) {
  const result_0 = (0, import_react105.useMemo)(() => {
    try {
      const result = func();
      if (isThenable(result)) {
        result.then(() => {
        }, () => {
        });
      }
      return {
        kind: "result",
        result
      };
    } catch (error2) {
      return {
        kind: "error",
        error: error2
      };
    }
  }, [func]);
  const [state, setState] = (0, import_react105.useState)(() => {
    return result_0.kind === "result" ? isThenable(result_0.result) ? {
      kind: "loading",
      promise: result_0.result
    } : {
      kind: "loaded",
      data: result_0.result
    } : result_0;
  });
  let stateToReturn = state;
  const resultState = (0, import_react105.useMemo)(() => {
    if (result_0.kind === "error" && (state.kind !== "error" || state.error !== result_0.error)) {
      return {
        kind: "error",
        error: result_0.error
      };
    }
    if (result_0.kind === "result" && !isThenable(result_0.result) && (state.kind !== "loaded" || state.data !== result_0.result)) {
      return {
        kind: "loaded",
        data: result_0.result
      };
    }
  }, [result_0, state]);
  if (resultState && resultState !== state) {
    stateToReturn = resultState;
    setState(resultState);
  }
  (0, import_react105.useEffect)(() => {
    if (result_0.kind === "result" && isThenable(result_0.result)) {
      setState({
        kind: "loading",
        promise: result_0.result
      });
      let isActive = true;
      result_0.result.then((result_1) => {
        if (!isActive) return;
        setState({
          kind: "loaded",
          data: result_1
        });
      }, (error_0) => {
        if (!isActive) return;
        setState({
          kind: "error",
          error: error_0
        });
      });
      return () => {
        isActive = false;
      };
    }
  }, [result_0]);
  return stateToReturn;
}
function mapDataState(state, func) {
  if (state.kind === "error" || state.kind === "loading") {
    return state;
  }
  return {
    kind: "loaded",
    data: func(state.data)
  };
}
function mergeDataStates(input) {
  const entries2 = Object.entries(input);
  for (const [, value2] of entries2) {
    if (value2.kind === "error") {
      return {
        kind: "error",
        error: value2.error
      };
    }
  }
  let promises = [];
  for (const [, value2] of entries2) {
    if (value2.kind === "loading") {
      promises.push(value2.promise);
    }
  }
  if (promises.length) {
    return {
      kind: "loading",
      promise: promiseAllMemoized(...promises)
    };
  }
  return {
    kind: "loaded",
    data: Object.fromEntries(entries2.map(([key, val]) => {
      return [key, val.data];
    }))
  };
}
var promiseAllMemoized = weakMemoizeN((...args2) => {
  return Promise.all(args2);
});
function collectDirectoriesUsedInSchemaInner(schema, directories, seenSchemas) {
  if (seenSchemas.has(schema)) {
    return;
  }
  seenSchemas.add(schema);
  if (schema.kind === "array") {
    return collectDirectoriesUsedInSchemaInner(schema.element, directories, seenSchemas);
  }
  if (schema.kind === "child") {
    return;
  }
  if (schema.kind === "form") {
    if (schema.formKind === "asset" && schema.directory !== void 0) {
      directories.add(fixPath(schema.directory));
    }
    if ((schema.formKind === "content" || schema.formKind === "assets") && schema.directories !== void 0) {
      for (const directory of schema.directories) {
        directories.add(fixPath(directory));
      }
    }
    return;
  }
  if (schema.kind === "object") {
    for (const field of Object.values(schema.fields)) {
      collectDirectoriesUsedInSchemaInner(field, directories, seenSchemas);
    }
    return;
  }
  if (schema.kind === "conditional") {
    for (const innerSchema of Object.values(schema.values)) {
      collectDirectoriesUsedInSchemaInner(innerSchema, directories, seenSchemas);
    }
    return;
  }
  assertNever(schema);
}
function collectDirectoriesUsedInSchema(schema) {
  const directories = /* @__PURE__ */ new Set();
  collectDirectoriesUsedInSchemaInner(schema, directories, /* @__PURE__ */ new Set());
  return directories;
}
function getDirectoriesForTreeKey(schema, directory, slug, format) {
  const directories = [fixPath(directory)];
  if (format.dataLocation === "outer") {
    directories.push(fixPath(directory) + getDataFileExtension(format));
  }
  const toAdd = slug === void 0 ? "" : `/${slug}`;
  for (const directory2 of collectDirectoriesUsedInSchema(schema)) {
    directories.push(directory2 + toAdd);
  }
  return directories;
}
function getTreeKey(directories, tree2) {
  return directories.map((d5) => {
    var _getTreeNodeAtPath;
    return (_getTreeNodeAtPath = getTreeNodeAtPath(tree2, d5)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
  }).join("-");
}
var pkgJson = {
  name: "@keystatic/core",
  version: "0.5.39",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/Thinkmill/keystatic/",
    directory: "packages/keystatic"
  },
  type: "module",
  exports: {
    "./ui": {
      types: "./dist/keystatic-core-ui.js",
      node: {
        "react-server": "./dist/keystatic-core-ui.node.react-server.js",
        "default": "./dist/keystatic-core-ui.node.js"
      },
      "react-server": "./dist/keystatic-core-ui.react-server.js",
      worker: "./dist/keystatic-core-ui.worker.js",
      "default": "./dist/keystatic-core-ui.js"
    },
    ".": {
      types: "./dist/keystatic-core.js",
      node: {
        "react-server": "./dist/keystatic-core.node.react-server.js",
        "default": "./dist/keystatic-core.node.js"
      },
      "react-server": "./dist/keystatic-core.react-server.js",
      worker: "./dist/keystatic-core.worker.js",
      "default": "./dist/keystatic-core.js"
    },
    "./api/utils": {
      types: "./dist/keystatic-core-api-utils.js",
      node: {
        "react-server": "./dist/keystatic-core-api-utils.node.react-server.js",
        "default": "./dist/keystatic-core-api-utils.node.js"
      },
      "react-server": "./dist/keystatic-core-api-utils.react-server.js",
      worker: "./dist/keystatic-core-api-utils.worker.js",
      "default": "./dist/keystatic-core-api-utils.js"
    },
    "./renderer": {
      types: "./dist/keystatic-core-renderer.js",
      node: {
        "react-server": "./dist/keystatic-core-renderer.node.react-server.js",
        "default": "./dist/keystatic-core-renderer.node.js"
      },
      "react-server": "./dist/keystatic-core-renderer.react-server.js",
      worker: "./dist/keystatic-core-renderer.worker.js",
      "default": "./dist/keystatic-core-renderer.js"
    },
    "./api/generic": {
      types: "./dist/keystatic-core-api-generic.js",
      node: {
        "react-server": "./dist/keystatic-core-api-generic.node.react-server.js",
        "default": "./dist/keystatic-core-api-generic.node.js"
      },
      "react-server": "./dist/keystatic-core-api-generic.react-server.js",
      worker: "./dist/keystatic-core-api-generic.worker.js",
      "default": "./dist/keystatic-core-api-generic.js"
    },
    "./reader": {
      types: "./dist/keystatic-core-reader.js",
      node: {
        "react-server": "./dist/keystatic-core-reader.node.react-server.js",
        "default": "./dist/keystatic-core-reader.node.js"
      },
      "react-server": "./dist/keystatic-core-reader.react-server.js",
      worker: "./dist/keystatic-core-reader.worker.js",
      "default": "./dist/keystatic-core-reader.js"
    },
    "./reader/github": {
      types: "./dist/keystatic-core-reader-github.js",
      node: {
        "react-server": "./dist/keystatic-core-reader-github.node.react-server.js",
        "default": "./dist/keystatic-core-reader-github.node.js"
      },
      "react-server": "./dist/keystatic-core-reader-github.react-server.js",
      worker: "./dist/keystatic-core-reader-github.worker.js",
      "default": "./dist/keystatic-core-reader-github.js"
    },
    "./content-components": {
      types: "./dist/keystatic-core-content-components.js",
      node: {
        "react-server": "./dist/keystatic-core-content-components.node.react-server.js",
        "default": "./dist/keystatic-core-content-components.node.js"
      },
      "react-server": "./dist/keystatic-core-content-components.react-server.js",
      worker: "./dist/keystatic-core-content-components.worker.js",
      "default": "./dist/keystatic-core-content-components.js"
    },
    "./component-blocks": {
      types: "./dist/keystatic-core-component-blocks.js",
      node: {
        "react-server": "./dist/keystatic-core-component-blocks.node.react-server.js",
        "default": "./dist/keystatic-core-component-blocks.node.js"
      },
      "react-server": "./dist/keystatic-core-component-blocks.react-server.js",
      worker: "./dist/keystatic-core-component-blocks.worker.js",
      "default": "./dist/keystatic-core-component-blocks.js"
    },
    "./package.json": "./package.json"
  },
  files: [
    "dist"
  ],
  scripts: {
    setup: "ts-gql build && tsx scripts/l10n.cts && tsx scripts/build-prism.cts",
    build: "pnpm run setup && next build",
    dev: "next dev",
    start: "next start"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@braintree/sanitize-url": "^6.0.2",
    "@emotion/css": "^11.9.0",
    "@emotion/weak-memoize": "^0.3.0",
    "@floating-ui/react": "^0.24.0",
    "@internationalized/string": "^3.2.3",
    "@keystar/ui": "workspace:^",
    "@markdoc/markdoc": "^0.4.0",
    "@react-aria/focus": "^3.18.1",
    "@react-aria/i18n": "^3.12.1",
    "@react-aria/interactions": "^3.22.1",
    "@react-aria/label": "^3.7.11",
    "@react-aria/overlays": "^3.23.2",
    "@react-aria/selection": "^3.19.3",
    "@react-aria/utils": "^3.25.1",
    "@react-aria/visually-hidden": "^3.8.15",
    "@react-stately/collections": "^3.10.9",
    "@react-stately/list": "^3.10.8",
    "@react-stately/overlays": "^3.6.10",
    "@react-stately/utils": "^3.10.3",
    "@react-types/shared": "^3.24.1",
    "@sindresorhus/slugify": "^1.1.2",
    "@toeverything/y-indexeddb": "^0.10.0-canary.9",
    "@ts-gql/tag": "^0.7.3",
    "@types/react": "^18.2.8",
    "@urql/core": "^5.0.4",
    "@urql/exchange-auth": "^2.2.0",
    "@urql/exchange-graphcache": "^7.1.2",
    "@urql/exchange-persisted": "^4.3.0",
    cookie: "^1.0.0",
    emery: "^1.4.1",
    "escape-string-regexp": "^4.0.0",
    "fast-deep-equal": "^3.1.3",
    graphql: "^16.6.0",
    "idb-keyval": "^6.2.1",
    ignore: "^5.2.4",
    "is-hotkey": "^0.2.0",
    "js-yaml": "^4.1.0",
    lib0: "^0.2.88",
    "lru-cache": "^10.2.0",
    "match-sorter": "^6.3.1",
    "mdast-util-from-markdown": "^2.0.0",
    "mdast-util-gfm-autolink-literal": "^2.0.0",
    "mdast-util-gfm-strikethrough": "^2.0.0",
    "mdast-util-gfm-table": "^2.0.0",
    "mdast-util-mdx": "^3.0.0",
    "mdast-util-to-markdown": "^2.1.0",
    "micromark-extension-gfm-autolink-literal": "^2.0.0",
    "micromark-extension-gfm-strikethrough": "^2.0.0",
    "micromark-extension-gfm-table": "^2.0.0",
    "micromark-extension-mdxjs": "^3.0.0",
    minimatch: "^9.0.3",
    partysocket: "^0.0.22",
    "prosemirror-commands": "^1.5.1",
    "prosemirror-history": "^1.3.0",
    "prosemirror-keymap": "^1.2.1",
    "prosemirror-model": "^1.19.0",
    "prosemirror-state": "^1.4.2",
    "prosemirror-tables": "^1.3.4",
    "prosemirror-transform": "^1.7.1",
    "prosemirror-view": "^1.30.2",
    "scroll-into-view-if-needed": "^3.0.3",
    slate: "^0.91.4",
    "slate-history": "^0.86.0",
    "slate-react": "^0.91.9",
    superstruct: "^1.0.4",
    "unist-util-visit": "^5.0.0",
    urql: "^4.1.0",
    "y-prosemirror": "^1.2.2",
    "y-protocols": "^1.0.6",
    yjs: "^13.6.11"
  },
  devDependencies: {
    "@internationalized/string-compiler": "^3.2.4",
    "@jest/expect": "^29.7.0",
    "@jest/globals": "^29.7.0",
    "@testing-library/user-event": "^14.4.3",
    "@ts-gql/compiler": "^0.16.7",
    "@ts-gql/eslint-plugin": "^0.9.1",
    "@ts-gql/next": "^17.0.1",
    "@types/is-hotkey": "^0.1.7",
    "@types/js-yaml": "^4.0.5",
    "@types/mdast": "^4.0.3",
    "@types/node": "16.11.13",
    "@types/prismjs": "^1.26.0",
    "@types/react-dom": "^18.0.11",
    "@types/signal-exit": "^3.0.1",
    eslint: "^8.18.0",
    "fast-glob": "^3.2.12",
    "jest-diff": "^29.0.1",
    outdent: "^0.8.0",
    "pretty-format": "^29.0.1",
    prismjs: "^1.29.0",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    "react-element-to-jsx-string": "^15.0.0",
    "resize-observer-polyfill": "^1.5.1",
    "signal-exit": "^3.0.7",
    "slate-hyperscript": "^0.77.0",
    tsx: "^4.8.2",
    typescript: "^5.5.3"
  },
  peerDependencies: {
    react: "^18.2.0",
    "react-dom": "^18.2.0"
  },
  preconstruct: {
    entrypoints: [
      "index.ts",
      "api/generic.ts",
      "api/utils.ts",
      "reader/index.ts",
      "reader/github.ts",
      "renderer.tsx",
      "ui.tsx",
      "component-blocks/index.tsx",
      "content-components.ts"
    ]
  },
  "ts-gql": {
    schema: "./github.graphql",
    mode: "no-transform",
    addTypename: false,
    scalars: {
      GitObjectID: "string"
    }
  },
  imports: {
    "#react-cache-in-react-server": {
      "react-server": "./src/reader/react-server-cache.ts",
      "default": "./src/reader/noop-cache.ts"
    },
    "#sha1": {
      node: "./src/sha1/node.ts",
      "default": "./src/sha1/webcrypto.ts"
    },
    "#webcrypto": {
      node: "./src/api/webcrypto/node.ts",
      "default": "./src/api/webcrypto/default.ts"
    },
    "#api-handler": {
      node: "./src/api/api-node.ts",
      "default": "./src/api/api-noop.ts"
    },
    "#ui": {
      node: "./src/app/ui-empty.tsx",
      worker: "./src/app/ui-empty.tsx",
      "react-server": "./src/app/ui-empty.tsx",
      "default": "./src/app/ui.tsx"
    },
    "#field-ui/*": {
      node: "./src/form/fields/empty-field-ui.tsx",
      worker: "./src/form/fields/empty-field-ui.tsx",
      "react-server": "./src/form/fields/empty-field-ui.tsx",
      "default": "./src/form/fields/*/ui.tsx"
    },
    "#component-block-primitives": {
      node: "./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx",
      worker: "./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx",
      "react-server": "./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx",
      "default": "./src/form/fields/document/DocumentEditor/primitives/index.tsx"
    },
    "#cloud-image-preview": {
      node: "./src/component-blocks/blank-for-react-server.tsx",
      worker: "./src/component-blocks/blank-for-react-server.tsx",
      "react-server": "./src/component-blocks/blank-for-react-server.tsx",
      "default": "./src/component-blocks/cloud-image-preview.tsx"
    },
    "#markdoc": "./src/markdoc.js",
    "#base64": "./src/base64.ts",
    "#react-compiler-runtime": "./src/react-compiler-runtime.ts"
  }
};
function object2(fields, opts) {
  return {
    ...opts,
    kind: "object",
    fields
  };
}
var units = {
  seconds: 60,
  minutes: 60,
  hours: 24,
  days: 7,
  weeks: 4,
  months: 12,
  years: Infinity
};
function formatTimeAgo(targetDate, currentDate, formatter) {
  let duration = (targetDate.getTime() - currentDate.getTime()) / 1e3;
  for (const [name, amount] of Object.entries(units)) {
    if (Math.abs(duration) < amount) {
      return formatter.format(Math.round(duration), name);
    }
    duration /= amount;
  }
  return "unknown";
}
function RelativeTime(props) {
  const $ = c(10);
  const {
    locale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => /* @__PURE__ */ new Date();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [now] = (0, import_react105.useState)(t0);
  let t1;
  let t22;
  if ($[1] !== locale || $[2] !== props.date || $[3] !== now) {
    const formatter = new Intl.RelativeTimeFormat(locale);
    formatter.format(props.date.getTime() - now.getTime(), "second");
    t22 = formatTimeAgo(props.date, now, formatter);
    $[1] = locale;
    $[2] = props.date;
    $[3] = now;
    $[4] = t22;
  } else {
    t22 = $[4];
  }
  t1 = t22;
  const formatted = t1;
  let t32;
  if ($[5] !== props.date) {
    t32 = props.date.toISOString();
    $[5] = props.date;
    $[6] = t32;
  } else {
    t32 = $[6];
  }
  let t4;
  if ($[7] !== t32 || $[8] !== formatted) {
    t4 = (0, import_jsx_runtime34.jsx)("time", {
      dateTime: t32,
      children: formatted
    });
    $[7] = t32;
    $[8] = formatted;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  return t4;
}
function showDraftRestoredToast(savedAt, hasChangedSince) {
  toastQueue.info((0, import_jsx_runtime34.jsxs)(Text, {
    children: ["Restored draft from ", (0, import_jsx_runtime34.jsx)(RelativeTime, {
      date: savedAt
    }), ".", " ", hasChangedSince && (0, import_jsx_runtime34.jsx)(Text, {
      color: "accent",
      children: "Other changes have been made to this entry since the draft. You may want to discard the draft changes."
    })]
  }), {
    timeout: 8e3
  });
}
var store;
function getStore() {
  if (!store) {
    store = createStore("keystatic", "items");
  }
  return store;
}
function setDraft(key, val) {
  return set(key, val, getStore());
}
function delDraft(key) {
  return del(key, getStore());
}
function getDraft(key) {
  return get2(key, getStore());
}
async function clearDrafts() {
  await clear(getStore());
}
function getCollection(config, collection) {
  return config.collections[collection];
}
function getBranchPrefix(config) {
  return config.storage.kind !== "local" ? config.storage.branchPrefix : void 0;
}
function isGitHubConfig(config) {
  return config.storage.kind === "github";
}
function isLocalConfig(config) {
  return config.storage.kind === "local";
}
function isCloudConfig(config) {
  var _config$cloud;
  if (config.storage.kind !== "cloud") return false;
  if (!((_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) || !config.cloud.project.includes("/")) {
    throw new Error(`Keystatic is set to \`storage: { kind: 'cloud' }\` but \`cloud.project\` isn't set.
config({
  storage: { kind: 'cloud' },
  cloud: { project: 'team/project' },
})`);
  }
  return true;
}
function getSplitCloudProject(config) {
  var _config$cloud2;
  if (!((_config$cloud2 = config.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project)) return void 0;
  const [team, project] = config.cloud.project.split("/");
  return {
    team,
    project
  };
}
function getRepoPath(config) {
  return `${config.owner}/${config.name}`;
}
function getRepoUrl(config) {
  return `https://github.com/${getRepoPath(config)}`;
}
function getSlugFromState(collectionConfig, state) {
  const value2 = state[collectionConfig.slugField];
  const field = collectionConfig.schema[collectionConfig.slugField];
  if (field.kind !== "form" || field.formKind !== "slug") {
    throw new Error(`slugField is not a slug field`);
  }
  return field.serializeWithSlug(value2).slug;
}
function getEntriesInCollectionWithTreeKey(config, collection, rootTree) {
  var _getTreeNodeAtPath$ch, _getTreeNodeAtPath;
  const collectionConfig = config.collections[collection];
  const schema = object2(collectionConfig.schema);
  const formatInfo = getCollectionFormat(config, collection);
  const extension = getDataFileExtension(formatInfo);
  const glob = getSlugGlobForCollection(config, collection);
  const collectionPath2 = getCollectionPath(config, collection);
  const directory = (_getTreeNodeAtPath$ch = (_getTreeNodeAtPath = getTreeNodeAtPath(rootTree, collectionPath2)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.children) !== null && _getTreeNodeAtPath$ch !== void 0 ? _getTreeNodeAtPath$ch : /* @__PURE__ */ new Map();
  const entries2 = [];
  const directoriesUsedInSchema = [...collectDirectoriesUsedInSchema(schema)];
  const suffix = getCollectionItemSlugSuffix(config, collection);
  const possibleEntries = new Map(directory);
  if (glob === "**") {
    const handleDirectory = (dir, prefix4) => {
      for (const [key, entry] of dir) {
        if (entry.children) {
          possibleEntries.set(`${prefix4}${key}`, entry);
          handleDirectory(entry.children, `${prefix4}${key}/`);
        } else {
          possibleEntries.set(`${prefix4}${key}`, entry);
        }
      }
    };
    handleDirectory(directory, "");
  }
  for (const [key, entry] of possibleEntries) {
    if (formatInfo.dataLocation === "index") {
      var _actualEntry$children;
      const actualEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config, collection, key));
      if (!(actualEntry !== null && actualEntry !== void 0 && (_actualEntry$children = actualEntry.children) !== null && _actualEntry$children !== void 0 && _actualEntry$children.has("index" + extension))) continue;
      entries2.push({
        key: getTreeKey([actualEntry.entry.path, ...directoriesUsedInSchema.map((x3) => `${x3}/${key}`)], rootTree),
        slug: key,
        sha: actualEntry.children.get("index" + extension).entry.sha
      });
    } else {
      if (suffix) {
        const newEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config, collection, key) + extension);
        if (!newEntry || newEntry.children) continue;
        entries2.push({
          key: getTreeKey([entry.entry.path, getCollectionItemPath(config, collection, key), ...directoriesUsedInSchema.map((x3) => `${x3}/${key}`)], rootTree),
          slug: key,
          sha: newEntry.entry.sha
        });
      }
      if (entry.children || !key.endsWith(extension)) continue;
      const slug = key.slice(0, -extension.length);
      entries2.push({
        key: getTreeKey([entry.entry.path, getCollectionItemPath(config, collection, slug), ...directoriesUsedInSchema.map((x3) => `${x3}/${slug}`)], rootTree),
        slug,
        sha: entry.entry.sha
      });
    }
  }
  return entries2;
}
var KEYSTATIC_CLOUD_API_URL = "https://api.keystatic.cloud";
var PKG_VERSION = pkgJson.version;
var KEYSTATIC_CLOUD_HEADERS = {
  "x-keystatic-version": PKG_VERSION
};
var textEncoder = new TextEncoder();
async function redirectToCloudAuth(from4, config) {
  var _config$cloud3;
  if (!((_config$cloud3 = config.cloud) !== null && _config$cloud3 !== void 0 && _config$cloud3.project)) {
    throw new Error("Not a cloud config");
  }
  const code_verifier = base64UrlEncode(crypto.getRandomValues(new Uint8Array(32)));
  const code_challenge = base64UrlEncode(new Uint8Array(await crypto.subtle.digest("SHA-256", textEncoder.encode(code_verifier))));
  const state = base64UrlEncode(crypto.getRandomValues(new Uint8Array(32)));
  localStorage.setItem("keystatic-cloud-state", JSON.stringify({
    state,
    from: from4,
    code_verifier
  }));
  const url = new URL(`${KEYSTATIC_CLOUD_API_URL}/oauth/authorize`);
  url.searchParams.set("state", state);
  url.searchParams.set("client_id", config.cloud.project);
  url.searchParams.set("redirect_uri", `${window.location.origin}/keystatic/cloud/oauth/callback`);
  url.searchParams.set("response_type", "code");
  url.searchParams.set("code_challenge_method", "S256");
  url.searchParams.set("code_challenge", code_challenge);
  url.searchParams.set("keystatic_version", pkgJson.version);
  window.location.href = url.toString();
}
function useShowRestoredDraftMessage(draft, state, localTreeKey) {
  const $ = c(8);
  let t0;
  if ($[0] !== draft || $[1] !== state || $[2] !== localTreeKey) {
    t0 = () => {
      if (draft && state === draft.state) {
        showDraftRestoredToast(draft.savedAt, localTreeKey !== draft.treeKey);
      }
    };
    $[0] = draft;
    $[1] = state;
    $[2] = localTreeKey;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  const show = $8ae05eaa5c114e9c$export$7f54fc3180508a52(t0);
  let t1;
  let t22;
  if ($[4] !== draft || $[5] !== show) {
    t1 = () => {
      if (draft) {
        show();
      }
    };
    t22 = [draft, show];
    $[4] = draft;
    $[5] = show;
    $[6] = t1;
    $[7] = t22;
  } else {
    t1 = $[6];
    t22 = $[7];
  }
  (0, import_react105.useEffect)(t1, t22);
}
var storedTokenSchema = object({
  token: string(),
  project: string(),
  validUntil: coerce(date(), number(), (val) => new Date(val))
});
function getSyncAuth(config) {
  if (typeof document === "undefined") {
    return null;
  }
  if (config.storage.kind === "github") {
    const cookies = (0, import_cookie.parse)(document.cookie);
    const accessToken = cookies["keystatic-gh-access-token"];
    if (!accessToken) {
      return null;
    }
    return {
      accessToken
    };
  }
  if (config.storage.kind === "cloud") {
    return getCloudAuth(config);
  }
  return null;
}
function getCloudAuth(config) {
  var _config$cloud;
  if (!((_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project)) return null;
  const unparsedTokenData = localStorage.getItem("keystatic-cloud-access-token");
  let tokenData;
  try {
    tokenData = storedTokenSchema.create(JSON.parse(unparsedTokenData));
  } catch (err) {
    return null;
  }
  if (!tokenData || tokenData.validUntil < /* @__PURE__ */ new Date() || tokenData.project !== config.cloud.project) {
    return null;
  }
  return {
    accessToken: tokenData.token
  };
}
var _refreshTokenPromise;
async function getAuth(config) {
  const token2 = getSyncAuth(config);
  if (config.storage.kind === "github" && !token2) {
    if (!_refreshTokenPromise) {
      _refreshTokenPromise = (async () => {
        try {
          const res = await fetch("/api/keystatic/github/refresh-token", {
            method: "POST"
          });
          if (res.status === 200) {
            const cookies = (0, import_cookie.parse)(document.cookie);
            const accessToken = cookies["keystatic-gh-access-token"];
            if (accessToken) {
              return {
                accessToken
              };
            }
          }
        } catch {
        } finally {
          _refreshTokenPromise = void 0;
        }
        return null;
      })();
    }
    return _refreshTokenPromise;
  }
  return token2;
}
var SidebarFooter_viewer = lib_default2`
  fragment SidebarFooter_viewer on User {
    id
    name
    login
    avatarUrl
    databaseId
  }
`;
var ViewerContext = (0, import_react105.createContext)(void 0);
function useViewer() {
  return (0, import_react105.useContext)(ViewerContext);
}
function parseRepoConfig(repo) {
  if (typeof repo === "string") {
    const [owner, name] = repo.split("/");
    return {
      owner,
      name
    };
  }
  return repo;
}
function serializeRepoConfig(repo) {
  if (typeof repo === "string") {
    return repo;
  }
  return `${repo.owner}/${repo.name}`;
}
function assertValidRepoConfig(repo) {
  if (typeof repo === "string") {
    if (!repo.includes("/")) {
      throw new Error(`Invalid repo config: ${repo}. It must be in the form owner/name`);
    }
  }
  if (typeof repo === "object") {
    if (!repo.owner && !repo.name) {
      throw new Error(`Invalid repo config: owner and name are missing`);
    }
    if (!repo.owner) {
      throw new Error(`Invalid repo config: owner is missing`);
    }
    if (!repo.name) {
      throw new Error(`Invalid repo config: name is missing`);
    }
  }
}
function scopeEntriesWithPathPrefix(tree2, config) {
  const prefix4 = getPathPrefix(config.storage);
  if (!prefix4) return tree2;
  const newEntries = [];
  for (const entry of tree2.entries.values()) {
    if (entry.path.startsWith(prefix4)) {
      newEntries.push({
        ...entry,
        path: entry.path.slice(prefix4.length)
      });
    }
  }
  return {
    entries: new Map(newEntries.map((entry) => [entry.path, entry])),
    tree: treeEntriesToTreeNodes(newEntries)
  };
}
var _treeStore;
function getTreeStore() {
  if (!_treeStore) {
    _treeStore = createStore("keystatic-trees", "trees");
  }
  return _treeStore;
}
var _blobStore;
function getBlobStore() {
  if (!_blobStore) {
    _blobStore = createStore("keystatic-blobs", "blobs");
  }
  return _blobStore;
}
function setBlobToPersistedCache(sha, val) {
  return set(sha, val, getBlobStore());
}
async function getBlobFromPersistedCache(sha) {
  const stored = await get2(sha, getBlobStore());
  if (stored instanceof Uint8Array) {
    return stored;
  }
}
var _storedTreeCache;
var treeSchema = array(object({
  path: string(),
  mode: string(),
  sha: string()
}));
function getStoredTrees() {
  if (_storedTreeCache) {
    return _storedTreeCache;
  }
  const cache3 = /* @__PURE__ */ new Map();
  return entries(getTreeStore()).then((entries2) => {
    for (const [sha, tree2] of entries2) {
      if (typeof sha !== "string") continue;
      let parsed;
      try {
        parsed = treeSchema.create(tree2);
      } catch {
        continue;
      }
      cache3.set(sha, parsed);
    }
    _storedTreeCache = cache3;
    return cache3;
  });
}
function constructTreeFromStoredTrees(sha, trees, parentPath = "") {
  const tree2 = /* @__PURE__ */ new Map();
  const storedTree = trees.get(sha);
  if (!storedTree) {
    return;
  }
  for (const entry of storedTree) {
    const innerPath = (parentPath === "" ? "" : parentPath + "/") + entry.path;
    if (entry.mode === "040000") {
      const child = constructTreeFromStoredTrees(entry.sha, trees, innerPath);
      if (child) {
        tree2.set(entry.path, child);
        continue;
      }
      return;
    }
    tree2.set(entry.path, {
      entry: {
        mode: entry.mode,
        path: innerPath,
        sha: entry.sha,
        type: entry.mode === "120000" ? "symlink" : "blob"
      }
    });
  }
  return {
    entry: {
      mode: "040000",
      path: parentPath,
      sha,
      type: "tree"
    },
    children: tree2
  };
}
function getTreeFromPersistedCache(sha) {
  const stored = getStoredTrees();
  if (stored instanceof Map) {
    return constructTreeFromStoredTrees(sha, stored);
  }
  return stored.then((stored2) => constructTreeFromStoredTrees(sha, stored2));
}
async function garbageCollectGitObjects(roots) {
  const treesToDelete = /* @__PURE__ */ new Map();
  const invalidTrees = [];
  for (const [sha, tree2] of await getStoredTrees()) {
    if (typeof sha !== "string") {
      invalidTrees.push(sha);
      continue;
    }
    let parsed;
    try {
      parsed = treeSchema.create(tree2);
    } catch {
      invalidTrees.push(sha);
      continue;
    }
    treesToDelete.set(sha, parsed);
  }
  const allBlobs = await keys2(getBlobStore());
  const blobsToDelete = new Set(allBlobs);
  const queue = new Set(roots);
  for (const sha of queue) {
    if (blobsToDelete.has(sha)) {
      blobsToDelete.delete(sha);
      continue;
    }
    const tree2 = treesToDelete.get(sha);
    if (tree2) {
      for (const entry of tree2) {
        queue.add(entry.sha);
      }
      treesToDelete.delete(sha);
      continue;
    }
  }
  const treeKeysToDelete = [...treesToDelete.keys(), ...invalidTrees];
  await Promise.all([delMany([...blobsToDelete], getBlobStore()), delMany([...treesToDelete.keys(), ...invalidTrees], getTreeStore())]);
  for (const key of treeKeysToDelete) {
    var _storedTreeCache2;
    (_storedTreeCache2 = _storedTreeCache) === null || _storedTreeCache2 === void 0 || _storedTreeCache2.delete(key);
  }
}
function setTreeToPersistedCache(sha, children) {
  const allTrees = [];
  collectTrees(sha, children, allTrees);
  return setMany(allTrees, getTreeStore());
}
function collectTrees(sha, children, allTrees) {
  const entries2 = [];
  for (const [path, entry] of children) {
    entries2.push({
      path: path.replace(/.*\//, ""),
      mode: entry.entry.mode,
      sha: entry.entry.sha
    });
    if (entry.children) {
      collectTrees(entry.entry.sha, entry.children, allTrees);
    }
  }
  allTrees.push([sha, entries2]);
}
async function clearObjectCache() {
  await Promise.all([clear(getBlobStore()), clear(getTreeStore())]);
}
var messageSync$1 = 0;
var messageQueryAwareness = 3;
var messageAwareness$1 = 1;
var messageAuth$1 = 2;
var messageSubDocSync = 4;
var messageHandlers = [];
messageHandlers[messageSync$1] = (encoder, decoder, provider, emitSynced) => {
  writeVarUint(encoder, messageSync$1);
  const syncMessageType = readSyncMessage(decoder, encoder, provider.doc, provider);
  if (emitSynced && syncMessageType === messageYjsSyncStep2 && !provider.synced) {
    provider.synced = true;
  }
};
messageHandlers[messageQueryAwareness] = (encoder, decoder, provider) => {
  writeVarUint(encoder, messageAwareness$1);
  writeVarUint8Array(encoder, encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));
};
messageHandlers[messageAwareness$1] = (encoder, decoder, provider) => {
  applyAwarenessUpdate(provider.awareness, readVarUint8Array(decoder), provider);
};
messageHandlers[messageAuth$1] = (encoder, decoder, provider) => {
  readAuthMessage(decoder, provider.doc, permissionDeniedHandler);
};
messageHandlers[messageSubDocSync] = (encoder, decoder, provider, emitSynced) => {
  const subDocID = readVarString(decoder);
  writeVarUint(encoder, messageSync$1);
  const subDoc = provider.getSubDoc(subDocID);
  if (subDoc) {
    const syncMessageType = readSyncMessage(decoder, encoder, subDoc, provider);
    if (emitSynced && syncMessageType === messageYjsSyncStep2) {
      subDoc.emit("sync", [true]);
    }
  }
};
var reconnectTimeoutBase = 1200;
var maxReconnectTimeout = 2500;
var messageReconnectTimeout = 3e4;
var permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.
${reason}`);
var readMessage = (provider, buf, emitSynced) => {
  const decoder = createDecoder(buf);
  const encoder = createEncoder();
  const messageType = readVarUint(decoder);
  const messageHandler = messageHandlers[messageType];
  if (messageHandler) {
    messageHandler(encoder, decoder, provider, emitSynced, messageType);
  } else {
    console.error("Unable to compute message");
  }
  return encoder;
};
var setupWS = (provider, WS) => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new WS(provider.url);
    websocket.binaryType = "arraybuffer";
    provider.ws = websocket;
    provider.wsconnecting = true;
    provider.wsconnected = false;
    provider.synced = false;
    let authState = {
      kind: "authenticating",
      queue: []
    };
    websocket.onmessage = (event) => {
      provider.wsLastMessageReceived = getUnixTime();
      const bytes = new Uint8Array(event.data);
      if (authState.kind === "authenticating") {
        const decoder = createDecoder(bytes);
        const messageType = readVarInt(decoder);
        if (messageType === messageAuth$1) {
          const authMessageType = readVarInt(decoder);
          if (authMessageType === 2) {
            const queue = authState.queue;
            authState = {
              kind: "authed"
            };
            provider.onConnect(websocket);
            for (const queued of queue) {
              const encoder = readMessage(provider, queued, true);
              if (length2(encoder) > 1) {
                websocket.send(toUint8Array(encoder));
              }
            }
            return;
          }
        }
        authState.queue.push(bytes);
      } else {
        const encoder = readMessage(provider, bytes, true);
        if (length2(encoder) > 1) {
          websocket.send(toUint8Array(encoder));
        }
      }
    };
    websocket.onclose = () => {
      provider.ws = null;
      provider.wsconnecting = false;
      if (provider.wsconnected) {
        provider.wsconnected = false;
        provider.synced = false;
        removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter((client) => client !== provider.doc.clientID), provider);
        provider.onStatus({
          status: "disconnected"
        });
      } else {
        provider.wsUnsuccessfulReconnects++;
      }
      setTimeout(setupWS, min(log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider);
    };
    websocket.onopen = async () => {
      provider.wsLastMessageReceived = getUnixTime();
      const encoder = createEncoder();
      writeVarUint(encoder, messageAuth$1);
      writeVarUint(encoder, 0);
      writeVarString(encoder, await provider.authToken());
      websocket.send(toUint8Array(encoder));
    };
    provider.onStatus({
      status: "connecting"
    });
  }
};
var broadcastMessage = (provider, buf) => {
  if (provider.ws && provider.wsconnected) {
    var _provider$ws;
    (_provider$ws = provider.ws) === null || _provider$ws === void 0 || _provider$ws.send(buf);
  }
  if (provider.bcconnected) {
    provider.mux(() => {
      publish(provider.bcChannel, buf);
    });
  }
};
var _WS, _synced, _resyncInterval, _checkInterval, _bcSubscriber, _beforeUnloadHandler, _awarenessUpdateHandler, _getSubDocUpdateHandler, _updateHandler;
var WebsocketProvider = class {
  constructor(opts) {
    __privateAdd(this, _WS);
    __privateAdd(this, _synced);
    __privateAdd(this, _resyncInterval);
    __privateAdd(this, _checkInterval);
    __privateAdd(this, _bcSubscriber, (data) => {
      this.mux(() => {
        const encoder = readMessage(this, new Uint8Array(data), false);
        if (length2(encoder) > 1) {
          publish(this.bcChannel, toUint8Array(encoder));
        }
      });
    });
    __privateAdd(this, _beforeUnloadHandler, () => {
      removeAwarenessStates(this.awareness, [this.doc.clientID], "window unload");
    });
    __publicField(this, "waitForConnection", (callback, interval) => {
      const ws = this.ws;
      if ((ws === null || ws === void 0 ? void 0 : ws.readyState) === 1) {
        callback(ws);
      } else {
        setTimeout(() => {
          this.waitForConnection(callback, interval);
        }, interval);
      }
    });
    __privateAdd(this, _awarenessUpdateHandler, ({
      added,
      updated,
      removed
    }) => {
      const changedClients = added.concat(updated).concat(removed);
      const encoder = createEncoder();
      writeVarUint(encoder, messageAwareness$1);
      writeVarUint8Array(encoder, encodeAwarenessUpdate(this.awareness, changedClients));
      broadcastMessage(this, toUint8Array(encoder));
    });
    __publicField(this, "send", (message, callback) => {
      this.waitForConnection((ws) => {
        ws.send(message);
        if (typeof callback !== "undefined") {
          callback();
        }
      }, 1e3);
    });
    __privateAdd(this, _getSubDocUpdateHandler, weakMemoize((subDoc) => (update) => {
      const encoder = createEncoder();
      writeVarUint(encoder, messageSubDocSync);
      writeVarString(encoder, subDoc.guid);
      writeUpdate(encoder, update);
      broadcastMessage(this, toUint8Array(encoder));
    }));
    __privateAdd(this, _updateHandler, (update, origin) => {
      if (origin !== this) {
        const encoder = createEncoder();
        writeVarUint(encoder, messageSync$1);
        writeUpdate(encoder, update);
        broadcastMessage(this, toUint8Array(encoder));
      }
    });
    var _opts$WebSocketPolyfi, _opts$onStatus, _opts$onSynced;
    this.bcChannel = opts.url;
    this.url = opts.url;
    this.doc = opts.doc;
    __privateSet(this, _WS, (_opts$WebSocketPolyfi = opts.WebSocketPolyfill) !== null && _opts$WebSocketPolyfi !== void 0 ? _opts$WebSocketPolyfi : WebSocket);
    this.awareness = opts.awareness;
    this.wsconnected = false;
    this.wsconnecting = false;
    this.bcconnected = false;
    this.wsUnsuccessfulReconnects = 0;
    this.mux = createMutex();
    __privateSet(this, _synced, false);
    this.authToken = opts.authToken;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.onStatus = (_opts$onStatus = opts.onStatus) !== null && _opts$onStatus !== void 0 ? _opts$onStatus : () => {
    };
    this.onSynced = (_opts$onSynced = opts.onSynced) !== null && _opts$onSynced !== void 0 ? _opts$onSynced : () => {
    };
    this.shouldConnect = false;
    this.subdocs = /* @__PURE__ */ new Map();
    __privateSet(this, _resyncInterval, null);
    if (opts.resyncInterval !== void 0 && opts.resyncInterval > 0) {
      __privateSet(this, _resyncInterval, setInterval(() => {
        if (this.ws) {
          const encoder = createEncoder();
          writeVarUint(encoder, messageSync$1);
          writeSyncStep1(encoder, opts.doc);
          this.ws.send(toUint8Array(encoder));
        }
      }, opts.resyncInterval));
    }
    this.doc.on("subdocs", ({
      added,
      removed,
      loaded
    }) => {
      added.forEach((subdoc) => {
        this.subdocs.set(subdoc.guid, subdoc);
      });
      removed.forEach((subdoc) => {
        subdoc.off("update", __privateGet(this, _getSubDocUpdateHandler).call(this, subdoc));
        this.subdocs.delete(subdoc.guid);
      });
      loaded.forEach((subdoc) => {
        this.waitForConnection(() => {
          const encoder = createEncoder();
          writeVarUint(encoder, messageSubDocSync);
          writeVarString(encoder, subdoc.guid);
          writeSyncStep1(encoder, subdoc);
          this.send(toUint8Array(encoder), () => {
            subdoc.on("update", __privateGet(this, _getSubDocUpdateHandler).call(this, subdoc));
          });
        }, 1e3);
      });
    });
    this.doc.on("update", __privateGet(this, _updateHandler));
    if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", __privateGet(this, _beforeUnloadHandler));
    }
    opts.awareness.on("update", __privateGet(this, _awarenessUpdateHandler));
    __privateSet(this, _checkInterval, setInterval(() => {
      if (this.wsconnected && messageReconnectTimeout < getUnixTime() - this.wsLastMessageReceived) {
        var _this$ws;
        (_this$ws = this.ws) === null || _this$ws === void 0 || _this$ws.close();
      }
    }, messageReconnectTimeout / 10));
  }
  onConnect(ws) {
    this.wsconnecting = false;
    this.wsconnected = true;
    this.wsUnsuccessfulReconnects = 0;
    this.onStatus({
      status: "connected"
    });
    const encoder = createEncoder();
    writeVarUint(encoder, messageSync$1);
    writeSyncStep1(encoder, this.doc);
    ws.send(toUint8Array(encoder));
    if (this.awareness.getLocalState() !== null) {
      const encoderAwarenessState = createEncoder();
      writeVarUint(encoderAwarenessState, messageAwareness$1);
      writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
      ws.send(toUint8Array(encoderAwarenessState));
    }
  }
  get synced() {
    return __privateGet(this, _synced);
  }
  getSubDoc(id2) {
    return this.subdocs.get(id2);
  }
  set synced(state) {
    if (__privateGet(this, _synced) !== state) {
      __privateSet(this, _synced, state);
      this.onSynced(state);
      this.doc.emit("sync", [state]);
    }
  }
  destroy() {
    if (__privateGet(this, _resyncInterval) !== null) {
      clearInterval(__privateGet(this, _resyncInterval));
    }
    clearInterval(__privateGet(this, _checkInterval));
    this.disconnect();
    if (typeof window !== "undefined") {
      window.removeEventListener("beforeunload", __privateGet(this, _beforeUnloadHandler));
    }
    this.awareness.off("update", __privateGet(this, _awarenessUpdateHandler));
    this.doc.off("update", __privateGet(this, _updateHandler));
  }
  connectBc() {
    if (!this.bcconnected) {
      subscribe2(this.bcChannel, __privateGet(this, _bcSubscriber));
      this.bcconnected = true;
    }
    this.mux(() => {
      const encoderSync = createEncoder();
      writeVarUint(encoderSync, messageSync$1);
      writeSyncStep1(encoderSync, this.doc);
      publish(this.bcChannel, toUint8Array(encoderSync));
      const encoderState = createEncoder();
      writeVarUint(encoderState, messageSync$1);
      writeSyncStep2(encoderState, this.doc);
      publish(this.bcChannel, toUint8Array(encoderState));
      const encoderAwarenessQuery = createEncoder();
      writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
      publish(this.bcChannel, toUint8Array(encoderAwarenessQuery));
      const encoderAwarenessState = createEncoder();
      writeVarUint(encoderAwarenessState, messageAwareness$1);
      writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
      publish(this.bcChannel, toUint8Array(encoderAwarenessState));
    });
  }
  disconnectBc() {
    const encoder = createEncoder();
    writeVarUint(encoder, messageAwareness$1);
    writeVarUint8Array(encoder, encodeAwarenessUpdate(this.awareness, [this.doc.clientID], /* @__PURE__ */ new Map()));
    broadcastMessage(this, toUint8Array(encoder));
    if (this.bcconnected) {
      unsubscribe(this.bcChannel, __privateGet(this, _bcSubscriber));
      this.bcconnected = false;
    }
  }
  disconnect() {
    this.shouldConnect = false;
    this.disconnectBc();
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS(this, __privateGet(this, _WS));
      this.connectBc();
    }
  }
};
_WS = new WeakMap();
_synced = new WeakMap();
_resyncInterval = new WeakMap();
_checkInterval = new WeakMap();
_bcSubscriber = new WeakMap();
_beforeUnloadHandler = new WeakMap();
_awarenessUpdateHandler = new WeakMap();
_getSubDocUpdateHandler = new WeakMap();
_updateHandler = new WeakMap();
var YjsContext = (0, import_react105.createContext)(null);
var messageSync = 0;
var messageAwareness = 1;
var messageAuth = 2;
var messageSyncSubdoc = 4;
var messageChunkStart = 5;
function decodeSentMessage(message) {
  const decoder = createDecoder(message);
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageSync: {
      return {
        kind: "sync"
      };
    }
    case messageSyncSubdoc: {
      return {
        kind: "sync-subdoc"
      };
    }
    case messageAwareness: {
      const awarenessUpdate = readVarUint8Array(decoder);
      const states = [];
      {
        const decoder2 = createDecoder(awarenessUpdate);
        const len = readVarUint(decoder2);
        for (let i4 = 0; i4 < len; i4++) {
          const clientID = readVarUint(decoder2);
          let clock = readVarUint(decoder2);
          const state = JSON.parse(readVarString(decoder2));
          states.push({
            clientID,
            clock,
            state
          });
        }
      }
      return {
        kind: "awareness",
        states
      };
    }
    case messageAuth: {
      return {
        kind: "auth"
      };
    }
  }
}
function decodeMessage(message) {
  const decoder = createDecoder(message);
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageSync: {
      return {
        kind: "sync"
      };
    }
    case messageSyncSubdoc: {
      return {
        kind: "sync-subdoc"
      };
    }
    case messageAwareness: {
      const awarenessUpdate = readVarUint8Array(decoder);
      const states = [];
      {
        const decoder2 = createDecoder(awarenessUpdate);
        const len = readVarUint(decoder2);
        for (let i4 = 0; i4 < len; i4++) {
          const clientID = readVarUint(decoder2);
          let clock = readVarUint(decoder2);
          const state = JSON.parse(readVarString(decoder2));
          states.push({
            clientID,
            clock,
            state
          });
        }
      }
      return {
        kind: "awareness",
        states
      };
    }
    case messageAuth: {
      return {
        kind: "auth"
      };
    }
  }
}
function useYjs() {
  const yjs = (0, import_react105.useContext)(YjsContext);
  if (!yjs) {
    throw new Error("CollabProvider not found");
  }
  if (yjs === "loading") {
    throw new Error("CollabProvider is loading");
  }
  return yjs;
}
function useYjsIfAvailable() {
  return (0, import_react105.useContext)(YjsContext);
}
var enableMessageLogging = false;
var emptyMap = /* @__PURE__ */ new Map();
var AwarenessContext = (0, import_react105.createContext)(emptyMap);
function useAwarenessStates() {
  return (0, import_react105.useContext)(AwarenessContext);
}
var currentAwarenesses = /* @__PURE__ */ new WeakMap();
function CollabProvider(props) {
  var _props$config$cloud;
  const router = useRouter();
  const cloudInfo = useCloudInfo();
  const project = (_props$config$cloud = props.config.cloud) === null || _props$config$cloud === void 0 ? void 0 : _props$config$cloud.project;
  const key = `ks-multiplayer-${project}`;
  const isMultiplayerEnabled = cloudInfo === null ? localStorage.getItem(key) === "true" : cloudInfo.team.multiplayer;
  const yJsInfo = (0, import_react105.useMemo)(() => {
    if (!isMultiplayerEnabled) {
      return;
    }
    const doc2 = new Doc();
    const data = doc2.getMap("data");
    const awareness = new Awareness(doc2);
    const idb = W2(doc2, `keystatic-2-${project}`);
    const provider = new WebsocketProvider({
      doc: doc2,
      url: `wss://live.keystatic.cloud/${project}?v=${PKG_VERSION}`,
      WebSocketPolyfill: class extends ReconnectingWebSocket {
        constructor(url) {
          super(url);
          this.addEventListener("message", (event) => {
            if (event.data instanceof ArrayBuffer && enableMessageLogging) {
              console.log("recv", decodeMessage(new Uint8Array(event.data)));
            }
          });
        }
        send(data2) {
          if (data2 instanceof Uint8Array && enableMessageLogging) {
            console.log("send", decodeSentMessage(data2));
          }
          const CHUNK_MAX_SIZE = 1e6;
          if (data2 instanceof Uint8Array && data2.byteLength > CHUNK_MAX_SIZE) {
            const chunks = Math.ceil(data2.byteLength / CHUNK_MAX_SIZE);
            const encoder = createEncoder();
            writeVarUint(encoder, messageChunkStart);
            writeVarUint(encoder, chunks);
            super.send(toUint8Array(encoder));
            for (let i4 = 0; i4 < chunks; i4++) {
              const start2 = i4 * CHUNK_MAX_SIZE;
              const end = Math.min((i4 + 1) * CHUNK_MAX_SIZE, data2.byteLength);
              super.send(data2.slice(start2, end));
            }
            return;
          }
          super.send(data2);
        }
      },
      awareness,
      authToken: async () => getAuth(props.config).then((auth) => {
        var _auth$accessToken;
        return (_auth$accessToken = auth === null || auth === void 0 ? void 0 : auth.accessToken) !== null && _auth$accessToken !== void 0 ? _auth$accessToken : "";
      })
    });
    return {
      doc: doc2,
      awareness,
      provider,
      data,
      idb
    };
  }, [isMultiplayerEnabled, project, props.config]);
  const currentBranch = useCurrentBranch();
  (0, import_react105.useEffect)(() => {
    yJsInfo === null || yJsInfo === void 0 || yJsInfo.awareness.setLocalStateField("branch", currentBranch);
    yJsInfo === null || yJsInfo === void 0 || yJsInfo.awareness.setLocalStateField("location", router.params.slice(2).join("/"));
  }, [currentBranch, router.params, yJsInfo === null || yJsInfo === void 0 ? void 0 : yJsInfo.awareness]);
  const hasRepo = !!currentBranch;
  (0, import_react105.useEffect)(() => {
    if (hasRepo && yJsInfo) {
      yJsInfo.idb.connect();
      let didConnectToWS = false;
      const remove = yJsInfo.idb.subscribeStatusChange(() => {
        if (yJsInfo.idb.status.type === "synced" || yJsInfo.idb.status.type === "error") {
          remove();
          yJsInfo.provider.connect();
          didConnectToWS = true;
        }
      });
      return () => {
        yJsInfo.idb.disconnect();
        if (didConnectToWS) {
          yJsInfo.provider.disconnect();
        } else {
          remove();
        }
      };
    }
  }, [yJsInfo, hasRepo]);
  (0, import_react105.useEffect)(() => {
    if (cloudInfo === null) return;
    const key_0 = `ks-multiplayer-${project}`;
    if (cloudInfo.team.multiplayer) {
      localStorage.setItem(key_0, "true");
    } else {
      localStorage.removeItem(key_0);
    }
  }, [cloudInfo, project]);
  const awarenessStates = (0, import_react105.useSyncExternalStore)((0, import_react105.useCallback)((onStoreChange) => {
    const awareness_0 = yJsInfo === null || yJsInfo === void 0 ? void 0 : yJsInfo.awareness;
    if (!awareness_0) return () => {
    };
    const fn2 = () => {
      currentAwarenesses.set(awareness_0, new Map(awareness_0.getStates()));
      onStoreChange();
    };
    awareness_0.on("change", fn2);
    return () => {
      currentAwarenesses.set(awareness_0, new Map(awareness_0.getStates()));
      awareness_0.off("change", fn2);
    };
  }, [yJsInfo]), () => {
    var _currentAwarenesses$g;
    if (!(yJsInfo !== null && yJsInfo !== void 0 && yJsInfo.awareness)) return emptyMap;
    return (_currentAwarenesses$g = currentAwarenesses.get(yJsInfo.awareness)) !== null && _currentAwarenesses$g !== void 0 ? _currentAwarenesses$g : emptyMap;
  });
  return (0, import_jsx_runtime34.jsx)(AwarenessContext.Provider, {
    value: awarenessStates !== null && awarenessStates !== void 0 ? awarenessStates : emptyMap,
    children: (0, import_jsx_runtime34.jsx)(YjsContext.Provider, {
      value: yJsInfo === void 0 ? cloudInfo === void 0 ? "loading" : null : yJsInfo,
      children: props.children
    })
  });
}
function EmptyRepo(props) {
  const $ = c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (0, import_jsx_runtime34.jsx)(Flex, {
      justifyContent: "center",
      children: (0, import_jsx_runtime34.jsx)(Heading, {
        children: "Git repo not initialised"
      })
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const t1 = `https://github.com/${props.repo}`;
  let t22;
  if ($[1] !== t1 || $[2] !== props.repo) {
    t22 = (0, import_jsx_runtime34.jsx)(Flex, {
      alignItems: "center",
      justifyContent: "center",
      margin: "xxlarge",
      children: (0, import_jsx_runtime34.jsxs)(Flex, {
        backgroundColor: "surface",
        padding: "large",
        border: "color.alias.borderIdle",
        borderRadius: "medium",
        direction: "column",
        justifyContent: "center",
        gap: "xlarge",
        maxWidth: "scale.4600",
        children: [t0, (0, import_jsx_runtime34.jsxs)(Text, {
          children: ["The Keystatic GitHub App is installed in the GitHub repository", " ", (0, import_jsx_runtime34.jsx)(TextLink3, {
            href: t1,
            children: props.repo
          }), " ", "but the Git repo is not initialised. Please initialise the Git repo before using Keystatic."]
        })]
      })
    });
    $[1] = t1;
    $[2] = props.repo;
    $[3] = t22;
  } else {
    t22 = $[3];
  }
  return t22;
}
function fetchLocalTree(sha) {
  if (treeCache.has(sha)) {
    return treeCache.get(sha);
  }
  const promise = fetch("/api/keystatic/tree", {
    headers: {
      "no-cors": "1"
    }
  }).then((x3) => x3.json()).then(async (entries2) => hydrateTreeCacheWithEntries(entries2));
  treeCache.set(sha, promise);
  return promise;
}
function useSetTreeSha() {
  return (0, import_react105.useContext)(SetTreeShaContext);
}
var SetTreeShaContext = (0, import_react105.createContext)(() => {
  throw new Error("SetTreeShaContext not set");
});
function LocalAppShellProvider(props) {
  const [currentTreeSha, setCurrentTreeSha] = (0, import_react105.useState)("initial");
  const tree2 = useData((0, import_react105.useCallback)(() => fetchLocalTree(currentTreeSha), [currentTreeSha]));
  const allTreeData = (0, import_react105.useMemo)(() => ({
    unscopedDefault: tree2,
    scoped: {
      default: tree2,
      current: tree2,
      merged: mergeDataStates({
        default: tree2,
        current: tree2
      })
    }
  }), [tree2]);
  const changedData = (0, import_react105.useMemo)(() => {
    if (allTreeData.scoped.merged.kind !== "loaded") {
      return {
        collections: /* @__PURE__ */ new Map(),
        singletons: /* @__PURE__ */ new Set()
      };
    }
    return getChangedData(props.config, allTreeData.scoped.merged.data);
  }, [allTreeData, props.config]);
  return (0, import_jsx_runtime34.jsx)(SetTreeShaContext.Provider, {
    value: setCurrentTreeSha,
    children: (0, import_jsx_runtime34.jsx)(ChangedContext.Provider, {
      value: changedData,
      children: (0, import_jsx_runtime34.jsx)(TreeContext.Provider, {
        value: allTreeData,
        children: props.children
      })
    })
  });
}
var cloudInfoSchema = type({
  user: type({
    id: string(),
    name: string(),
    email: string(),
    avatarUrl: optional(string())
  }),
  project: type({
    name: string()
  }),
  team: object({
    name: string(),
    slug: string(),
    images: boolean(),
    multiplayer: boolean()
  })
});
var CloudInfo = (0, import_react105.createContext)(null);
function useCloudInfo() {
  const context = (0, import_react105.useContext)(CloudInfo);
  return context === "unauthorized" ? null : context;
}
function useRawCloudInfo() {
  return (0, import_react105.useContext)(CloudInfo);
}
function CloudInfoProvider(props) {
  const data = useData((0, import_react105.useCallback)(async () => {
    var _props$config$cloud, _getCloudAuth;
    if (!((_props$config$cloud = props.config.cloud) !== null && _props$config$cloud !== void 0 && _props$config$cloud.project)) throw new Error("no cloud project set");
    const token2 = (_getCloudAuth = getCloudAuth(props.config)) === null || _getCloudAuth === void 0 ? void 0 : _getCloudAuth.accessToken;
    if (!token2) {
      return "unauthorized";
    }
    const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/v1/info`, {
      headers: {
        ...KEYSTATIC_CLOUD_HEADERS,
        Authorization: `Bearer ${token2}`
      }
    });
    if (res.status === 401) return "unauthorized";
    return cloudInfoSchema.create(await res.json());
  }, [props.config]));
  return (0, import_jsx_runtime34.jsx)(CloudInfo.Provider, {
    value: data.kind === "loaded" ? data.data : null,
    children: props.children
  });
}
var GitHubAppShellDataContext = (0, import_react105.createContext)(null);
function GitHubAppShellDataProvider(props) {
  var _state$data, _state$data2, _moreRefsState$data, _state$data3;
  const repo = props.config.storage.kind === "github" ? parseRepoConfig(props.config.storage.repo) : {
    name: "repo-name",
    owner: "repo-owner"
  };
  const [state] = useQuery({
    query: props.config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
    variables: repo
  });
  const [cursorState, setCursorState] = (0, import_react105.useState)(null);
  const [moreRefsState] = useQuery({
    query: lib_default2`
      query FetchMoreRefs($owner: String!, $name: String!, $after: String) {
        repository(owner: $owner, name: $name) {
          __typename
          id
          refs(refPrefix: "refs/heads/", first: 100, after: $after) {
            __typename
            nodes {
              ...Ref_base
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }
      }
      ${Ref_base}
    `,
    pause: !((_state$data = state.data) !== null && _state$data !== void 0 && (_state$data = _state$data.repository) !== null && _state$data !== void 0 && (_state$data = _state$data.refs) !== null && _state$data !== void 0 && _state$data.pageInfo.hasNextPage),
    variables: {
      ...repo,
      after: cursorState !== null && cursorState !== void 0 ? cursorState : (_state$data2 = state.data) === null || _state$data2 === void 0 || (_state$data2 = _state$data2.repository) === null || _state$data2 === void 0 || (_state$data2 = _state$data2.refs) === null || _state$data2 === void 0 ? void 0 : _state$data2.pageInfo.endCursor
    }
  });
  const pageInfo = (_moreRefsState$data = moreRefsState.data) === null || _moreRefsState$data === void 0 || (_moreRefsState$data = _moreRefsState$data.repository) === null || _moreRefsState$data === void 0 || (_moreRefsState$data = _moreRefsState$data.refs) === null || _moreRefsState$data === void 0 ? void 0 : _moreRefsState$data.pageInfo;
  if (pageInfo !== null && pageInfo !== void 0 && pageInfo.hasNextPage && pageInfo.endCursor !== cursorState && pageInfo.endCursor) {
    setCursorState(pageInfo.endCursor);
  }
  if ((_state$data3 = state.data) !== null && _state$data3 !== void 0 && (_state$data3 = _state$data3.repository) !== null && _state$data3 !== void 0 && _state$data3.owner && !state.data.repository.defaultBranchRef && !state.fetching && !state.error) {
    return (0, import_jsx_runtime34.jsx)(EmptyRepo, {
      repo: `${state.data.repository.owner.login}/${state.data.repository.name}`
    });
  }
  return (0, import_jsx_runtime34.jsx)(GitHubAppShellDataContext.Provider, {
    value: state,
    children: (0, import_jsx_runtime34.jsx)(ViewerContext.Provider, {
      value: state.data && "viewer" in state.data ? state.data.viewer : void 0,
      children: props.children
    })
  });
}
var writePermissions = /* @__PURE__ */ new Set(["WRITE", "ADMIN", "MAINTAIN"]);
function GitHubAppShellProvider(props) {
  var _repo, _repo3, _repo5, _defaultBranchRef$tar, _currentBranchRef$tar, _repo7, _repo9, _repo10, _repo12, _repo13, _repo14, _repo15, _repo16;
  const router = useRouter();
  const {
    data,
    error: error2
  } = (0, import_react105.useContext)(GitHubAppShellDataContext);
  let repo = data === null || data === void 0 ? void 0 : data.repository;
  if (repo && "viewerPermission" in repo && repo.viewerPermission && !writePermissions.has(repo.viewerPermission) && "forks" in repo) {
    var _repo$forks$nodes$, _repo$forks;
    repo = (_repo$forks$nodes$ = (_repo$forks = repo.forks) === null || _repo$forks === void 0 || (_repo$forks = _repo$forks.nodes) === null || _repo$forks === void 0 ? void 0 : _repo$forks[0]) !== null && _repo$forks$nodes$ !== void 0 ? _repo$forks$nodes$ : repo;
  }
  const defaultBranchRef = (_repo = repo) === null || _repo === void 0 || (_repo = _repo.refs) === null || _repo === void 0 || (_repo = _repo.nodes) === null || _repo === void 0 ? void 0 : _repo.find((x3) => {
    var _repo2;
    return (x3 === null || x3 === void 0 ? void 0 : x3.name) === ((_repo2 = repo) === null || _repo2 === void 0 || (_repo2 = _repo2.defaultBranchRef) === null || _repo2 === void 0 ? void 0 : _repo2.name);
  });
  const currentBranchRef = (_repo3 = repo) === null || _repo3 === void 0 || (_repo3 = _repo3.refs) === null || _repo3 === void 0 || (_repo3 = _repo3.nodes) === null || _repo3 === void 0 ? void 0 : _repo3.find((x_0) => (x_0 === null || x_0 === void 0 ? void 0 : x_0.name) === props.currentBranch);
  (0, import_react105.useEffect)(() => {
    var _repo4;
    if ((_repo4 = repo) !== null && _repo4 !== void 0 && (_repo4 = _repo4.refs) !== null && _repo4 !== void 0 && _repo4.nodes) {
      garbageCollectGitObjects(repo.refs.nodes.map((x_1) => {
        var _x_1$target;
        return (x_1 === null || x_1 === void 0 || (_x_1$target = x_1.target) === null || _x_1$target === void 0 ? void 0 : _x_1$target.__typename) === "Commit" ? x_1.target.tree.oid : void 0;
      }).filter(isDefined));
    }
  }, [(_repo5 = repo) === null || _repo5 === void 0 ? void 0 : _repo5.id]);
  const defaultBranchTreeSha = (_defaultBranchRef$tar = defaultBranchRef === null || defaultBranchRef === void 0 ? void 0 : defaultBranchRef.target.tree.oid) !== null && _defaultBranchRef$tar !== void 0 ? _defaultBranchRef$tar : null;
  const currentBranchTreeSha = (_currentBranchRef$tar = currentBranchRef === null || currentBranchRef === void 0 ? void 0 : currentBranchRef.target.tree.oid) !== null && _currentBranchRef$tar !== void 0 ? _currentBranchRef$tar : null;
  const defaultBranchTree = useGitHubTreeData(defaultBranchTreeSha, props.config);
  const currentBranchTree = useGitHubTreeData(currentBranchTreeSha, props.config);
  const allTreeData = (0, import_react105.useMemo)(() => {
    const scopedDefault = mapDataState(defaultBranchTree, (tree2) => scopeEntriesWithPathPrefix(tree2, props.config));
    const scopedCurrent = mapDataState(currentBranchTree, (tree_0) => scopeEntriesWithPathPrefix(tree_0, props.config));
    return {
      unscopedDefault: currentBranchTree,
      scoped: {
        default: scopedDefault,
        current: scopedCurrent,
        merged: mergeDataStates({
          default: scopedDefault,
          current: scopedCurrent
        })
      }
    };
  }, [currentBranchTree, defaultBranchTree, props.config]);
  const changedData = (0, import_react105.useMemo)(() => {
    if (allTreeData.scoped.merged.kind !== "loaded") {
      return {
        collections: /* @__PURE__ */ new Map(),
        singletons: /* @__PURE__ */ new Set()
      };
    }
    return getChangedData(props.config, allTreeData.scoped.merged.data);
  }, [allTreeData, props.config]);
  (0, import_react105.useEffect)(() => {
    var _error$response, _repo6;
    if ((error2 === null || error2 === void 0 || (_error$response = error2.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
      if (isGitHubConfig(props.config)) {
        window.location.href = `/api/keystatic/github/login?from=${router.params.map(encodeURIComponent).join("/")}`;
      } else {
        redirectToCloudAuth(router.params.map(encodeURIComponent).join("/"), props.config);
      }
    }
    if (!((_repo6 = repo) !== null && _repo6 !== void 0 && _repo6.id) && error2 !== null && error2 !== void 0 && error2.graphQLErrors.some((err) => {
      var _err$originalError, _err$originalError2;
      return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === "NOT_FOUND" || (err === null || err === void 0 || (_err$originalError2 = err.originalError) === null || _err$originalError2 === void 0 ? void 0 : _err$originalError2.type) === "FORBIDDEN";
    })) {
      window.location.href = `/api/keystatic/github/repo-not-found?from=${router.params.map(encodeURIComponent).join("/")}`;
    }
  }, [error2, router, (_repo7 = repo) === null || _repo7 === void 0 ? void 0 : _repo7.id, props.config]);
  const branches = (0, import_react105.useMemo)(() => {
    var _repo8;
    return new Map((_repo8 = repo) === null || _repo8 === void 0 || (_repo8 = _repo8.refs) === null || _repo8 === void 0 || (_repo8 = _repo8.nodes) === null || _repo8 === void 0 ? void 0 : _repo8.flatMap((x_2) => {
      var _x_2$target;
      if ((x_2 === null || x_2 === void 0 || (_x_2$target = x_2.target) === null || _x_2$target === void 0 ? void 0 : _x_2$target.__typename) !== "Commit") {
        return [];
      }
      return [[x_2.name, {
        id: x_2.id,
        commitSha: x_2.target.oid,
        treeSha: x_2.target.tree.oid
      }]];
    }));
  }, [(_repo9 = repo) === null || _repo9 === void 0 || (_repo9 = _repo9.refs) === null || _repo9 === void 0 ? void 0 : _repo9.nodes]);
  const hasWritePermission = !!repo && (props.config.storage.kind === "cloud" || "viewerPermission" in repo && !!((_repo10 = repo) !== null && _repo10 !== void 0 && _repo10.viewerPermission) && writePermissions.has(repo.viewerPermission));
  const repoInfo = (0, import_react105.useMemo)(() => {
    var _repo11;
    if (!(data !== null && data !== void 0 && data.repository) || !((_repo11 = repo) !== null && _repo11 !== void 0 && (_repo11 = _repo11.defaultBranchRef) !== null && _repo11 !== void 0 && _repo11.name)) return null;
    return {
      id: repo.id,
      defaultBranch: repo.defaultBranchRef.name,
      hasWritePermission,
      isPrivate: repo.isPrivate,
      name: repo.name,
      owner: repo.owner.login,
      upstream: {
        name: repo.name,
        owner: repo.owner.login
      }
    };
  }, [data === null || data === void 0 ? void 0 : data.repository, hasWritePermission, (_repo12 = repo) === null || _repo12 === void 0 || (_repo12 = _repo12.defaultBranchRef) === null || _repo12 === void 0 ? void 0 : _repo12.name, (_repo13 = repo) === null || _repo13 === void 0 ? void 0 : _repo13.id, (_repo14 = repo) === null || _repo14 === void 0 ? void 0 : _repo14.isPrivate, (_repo15 = repo) === null || _repo15 === void 0 ? void 0 : _repo15.name, (_repo16 = repo) === null || _repo16 === void 0 ? void 0 : _repo16.owner.login]);
  return (0, import_jsx_runtime34.jsx)(AppShellErrorContext.Provider, {
    value: error2,
    children: (0, import_jsx_runtime34.jsx)(CurrentBranchContext.Provider, {
      value: props.currentBranch,
      children: (0, import_jsx_runtime34.jsx)(BranchesContext.Provider, {
        value: branches,
        children: (0, import_jsx_runtime34.jsx)(RepoInfoContext.Provider, {
          value: repoInfo,
          children: (0, import_jsx_runtime34.jsx)(ChangedContext.Provider, {
            value: changedData,
            children: (0, import_jsx_runtime34.jsx)(TreeContext.Provider, {
              value: allTreeData,
              children: props.config.storage.kind === "cloud" ? (0, import_jsx_runtime34.jsx)(CollabProvider, {
                config: props.config,
                children: props.children
              }) : props.children
            })
          })
        })
      })
    })
  });
}
var AppShellErrorContext = (0, import_react105.createContext)(void 0);
var CurrentBranchContext = (0, import_react105.createContext)("");
function useCurrentBranch() {
  return (0, import_react105.useContext)(CurrentBranchContext);
}
var BranchesContext = (0, import_react105.createContext)(/* @__PURE__ */ new Map());
function useBranches() {
  return (0, import_react105.useContext)(BranchesContext);
}
var RepoInfoContext = (0, import_react105.createContext)(null);
function useRepoInfo() {
  return (0, import_react105.useContext)(RepoInfoContext);
}
var ChangedContext = (0, import_react105.createContext)({
  collections: /* @__PURE__ */ new Map(),
  singletons: /* @__PURE__ */ new Set()
});
var TreeContext = (0, import_react105.createContext)({
  unscopedDefault: {
    kind: "loading",
    promise: LOADING
  },
  scoped: {
    current: {
      kind: "loading",
      promise: LOADING
    },
    default: {
      kind: "loading",
      promise: LOADING
    },
    merged: {
      kind: "loading",
      promise: LOADING
    }
  }
});
function useTree() {
  return (0, import_react105.useContext)(TreeContext).scoped;
}
function useCurrentUnscopedTree() {
  return (0, import_react105.useContext)(TreeContext).unscopedDefault;
}
function useChanged() {
  return (0, import_react105.useContext)(ChangedContext);
}
function useBaseCommit() {
  var _branchInfo$get$commi, _branchInfo$get;
  const branchInfo = useBranches();
  const currentBranch = useCurrentBranch();
  return (_branchInfo$get$commi = (_branchInfo$get = branchInfo.get(currentBranch)) === null || _branchInfo$get === void 0 ? void 0 : _branchInfo$get.commitSha) !== null && _branchInfo$get$commi !== void 0 ? _branchInfo$get$commi : "";
}
var Ref_base = lib_default2`
  fragment Ref_base on Ref {
    id
    name
    target {
      __typename
      id
      oid
      ... on Commit {
        tree {
          id
          oid
        }
      }
    }
  }
`;
var BaseRepo = lib_default2`
  fragment Repo_base on Repository {
    id
    isPrivate
    owner {
      id
      login
    }
    name
    defaultBranchRef {
      id
      name
    }
    refs(refPrefix: "refs/heads/", first: 100) {
      nodes {
        ...Ref_base
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
  ${Ref_base}
`;
var CloudAppShellQuery = lib_default2`
  query CloudAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_base
    }
  }
  ${BaseRepo}
`;
var Repo_ghDirect = lib_default2`
  fragment Repo_ghDirect on Repository {
    id
    ...Repo_base
    viewerPermission
  }
  ${BaseRepo}
`;
var Repo_primary = lib_default2`
  fragment Repo_primary on Repository {
    id
    ...Repo_ghDirect
    forks(affiliations: [OWNER], first: 1) {
      nodes {
        ...Repo_ghDirect
      }
    }
  }
  ${Repo_ghDirect}
`;
var GitHubAppShellQuery = lib_default2`
  query GitHubAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_primary
    }
    viewer {
      ...SidebarFooter_viewer
    }
  }
  ${Repo_primary}
  ${SidebarFooter_viewer}
`;
var treeCache = new LRUCache({
  max: 40
});
async function hydrateTreeCacheWithEntries(entries2) {
  const data = {
    entries: new Map(entries2.map((entry) => [entry.path, entry])),
    tree: treeEntriesToTreeNodes(entries2)
  };
  const sha = await treeSha(data.tree);
  treeCache.set(sha, data);
  return data;
}
function fetchGitHubTreeData(sha, config) {
  const cached = treeCache.get(sha);
  if (cached) return cached;
  const cachedFromPersisted = getTreeFromPersistedCache(sha);
  if (cachedFromPersisted && !(cachedFromPersisted instanceof Promise)) {
    const entries2 = treeToEntries(cachedFromPersisted.children);
    const result = {
      entries: new Map(entries2.map((entry) => [entry.path, entry])),
      tree: cachedFromPersisted.children
    };
    treeCache.set(sha, result);
    return result;
  }
  const promise = (async () => {
    const cached2 = await cachedFromPersisted;
    if (cached2) {
      const entries2 = treeToEntries(cached2.children);
      const result = {
        entries: new Map(entries2.map((entry) => [entry.path, entry])),
        tree: cached2.children
      };
      treeCache.set(sha, result);
      return result;
    }
    const auth = await getAuth(config);
    if (!auth) throw new Error("Not authorized");
    const {
      tree: tree2
    } = await fetch(config.storage.kind === "github" ? `https://api.github.com/repos/${serializeRepoConfig(config.storage.repo)}/git/trees/${sha}?recursive=1` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/trees/${sha}`, {
      headers: {
        Authorization: `Bearer ${auth.accessToken}`,
        ...config.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
      }
    }).then((x3) => x3.json());
    const treeEntries = tree2.map(({
      url,
      size: size3,
      ...rest
    }) => rest);
    await setTreeToPersistedCache(sha, treeEntriesToTreeNodes(treeEntries));
    return hydrateTreeCacheWithEntries(treeEntries);
  })();
  treeCache.set(sha, promise);
  return promise;
}
function useGitHubTreeData(sha, config) {
  return useData((0, import_react105.useCallback)(() => sha ? fetchGitHubTreeData(sha, config) : LOADING, [sha, config]));
}
function getChangedData(config, trees) {
  var _config$collections, _config$singletons;
  return {
    collections: new Map(Object.keys((_config$collections = config.collections) !== null && _config$collections !== void 0 ? _config$collections : {}).map((collection) => {
      const currentBranch = new Map(getEntriesInCollectionWithTreeKey(config, collection, trees.current.tree).map((x3) => [x3.slug, x3.key]));
      const defaultBranch = new Map(getEntriesInCollectionWithTreeKey(config, collection, trees.default.tree).map((x3) => [x3.slug, x3.key]));
      const changed = /* @__PURE__ */ new Set();
      const added = /* @__PURE__ */ new Set();
      for (const [key, entry] of currentBranch) {
        const defaultBranchEntry = defaultBranch.get(key);
        if (defaultBranchEntry === void 0) {
          added.add(key);
          continue;
        }
        if (entry !== defaultBranchEntry) {
          changed.add(key);
        }
      }
      const removed = new Set([...defaultBranch.keys()].filter((key) => !currentBranch.has(key)));
      return [collection, {
        removed,
        added,
        changed,
        totalCount: currentBranch.size
      }];
    })),
    singletons: new Set(Object.keys((_config$singletons = config.singletons) !== null && _config$singletons !== void 0 ? _config$singletons : {}).filter((singleton) => {
      var _getTreeNodeAtPath, _getTreeNodeAtPath2;
      const singletonPath = getSingletonPath(config, singleton);
      return ((_getTreeNodeAtPath = getTreeNodeAtPath(trees.current.tree, singletonPath)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha) !== ((_getTreeNodeAtPath2 = getTreeNodeAtPath(trees.default.tree, singletonPath)) === null || _getTreeNodeAtPath2 === void 0 ? void 0 : _getTreeNodeAtPath2.entry.sha);
    }))
  };
}
var ConfigContext = (0, import_react105.createContext)(null);
function useConfig() {
  const config = (0, import_react105.useContext)(ConfigContext);
  if (!config) {
    throw new Error("ConfigContext.Provider not found");
  }
  return config;
}
var AppStateContext = (0, import_react105.createContext)({
  basePath: "/keystatic"
});
function useAppState() {
  const appState = (0, import_react105.useContext)(AppStateContext);
  if (!appState) {
    throw new Error("AppStateContext.Provider not found");
  }
  return appState;
}
var ContentPanelContext = (0, import_react105.createContext)("mobile");
var ContentPanelProvider = ContentPanelContext.Provider;
function useContentPanelSize() {
  return (0, import_react105.useContext)(ContentPanelContext);
}
function useContentPanelQuery(options) {
  const sizes = ["mobile", "tablet", "desktop", "wide"];
  const size3 = useContentPanelSize();
  const startIndex = "above" in options ? sizes.indexOf(options.above) + 1 : 0;
  const endIndex = "below" in options ? sizes.indexOf(options.below) - 1 : sizes.length - 1;
  const range = sizes.slice(startIndex, endIndex + 1);
  return range.includes(size3);
}
function useContentPanelState(ref) {
  const $ = c(5);
  const [contentSize, setContentSize] = (0, import_react105.useState)("mobile");
  let t0;
  if ($[0] !== ref.current) {
    t0 = () => {
      setContentSize((size3) => {
        const contentPane = ref.current;
        if (!contentPane) {
          return size3;
        }
        if (contentPane.offsetWidth >= breakpoints.wide) {
          return "wide";
        }
        if (contentPane.offsetWidth >= breakpoints.desktop) {
          return "desktop";
        }
        if (contentPane.offsetWidth >= breakpoints.tablet) {
          return "tablet";
        }
        return "mobile";
      });
    };
    $[0] = ref.current;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onResize = t0;
  let t1;
  if ($[2] !== ref || $[3] !== onResize) {
    t1 = {
      ref,
      onResize
    };
    $[2] = ref;
    $[3] = onResize;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  $9daab02d461809db$export$683480f191c0e3ea(t1);
  return contentSize;
}
function focusWithPreviousSelection(editor) {
  const selection = window.getSelection();
  if (selection) {
    selection.removeAllRanges();
    selection.addRange(ReactEditor.toDOMRange(editor, editor.selection));
  }
  ReactEditor.focus(editor);
}
var blockElementSpacing = css({
  marginBlock: "0.75em",
  "&:first-child": {
    marginBlockStart: 0
  },
  "&:last-child": {
    marginBlockEnd: 0
  }
});
var ForceValidationContext = import_react105.default.createContext(false);
ForceValidationContext.Provider;
function useElementWithSetNodes(editor, element2) {
  const [state, setState] = (0, import_react105.useState)({
    element: element2,
    elementWithChanges: element2
  });
  if (state.element !== element2) {
    setState({
      element: element2,
      elementWithChanges: element2
    });
  }
  const elementRef = (0, import_react105.useRef)(element2);
  (0, import_react105.useEffect)(() => {
    elementRef.current = element2;
  });
  const setNodes = (0, import_react105.useCallback)((changesOrCallback) => {
    const currentElement = elementRef.current;
    const changes = typeof changesOrCallback === "function" ? changesOrCallback(currentElement) : changesOrCallback;
    Transforms.setNodes(editor, changes, {
      at: ReactEditor.findPath(editor, currentElement)
    });
    setState({
      element: currentElement,
      elementWithChanges: {
        ...currentElement,
        ...changes
      }
    });
  }, [editor]);
  return [state.elementWithChanges, setNodes];
}
function useEventCallback(callback) {
  const callbackRef = (0, import_react105.useRef)(callback);
  const cb = (0, import_react105.useCallback)((...args2) => {
    return callbackRef.current(...args2);
  }, []);
  (0, import_react105.useEffect)(() => {
    callbackRef.current = callback;
  });
  return cb;
}
function insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes) {
  var _pathRefForEmptyNodeA;
  let pathRefForEmptyNodeAtCursor;
  const entry = Editor.above(editor, {
    match: (node2) => node2.type === "heading" || node2.type === "paragraph"
  });
  if (entry && Node2.string(entry[0]) === "") {
    pathRefForEmptyNodeAtCursor = Editor.pathRef(editor, entry[1]);
  }
  Transforms.insertNodes(editor, nodes);
  let path = (_pathRefForEmptyNodeA = pathRefForEmptyNodeAtCursor) === null || _pathRefForEmptyNodeA === void 0 ? void 0 : _pathRefForEmptyNodeA.unref();
  if (path) {
    Transforms.removeNodes(editor, {
      at: path
    });
    ReactEditor.focus(editor);
  }
}
var tableCellChildren = ["paragraph", "code", "heading", "ordered-list", "unordered-list", "divider", "image"];
var blockquoteChildren = [...tableCellChildren, "table"];
var paragraphLike = [...blockquoteChildren, "blockquote"];
var insideOfLayouts = [...paragraphLike, "component-block"];
function blockContainer(args2) {
  return {
    kind: "blocks",
    allowedChildren: new Set(args2.allowedChildren),
    blockToWrapInlinesIn: args2.allowedChildren[0],
    invalidPositionHandleMode: args2.invalidPositionHandleMode
  };
}
function inlineContainer(args2) {
  return {
    kind: "inlines",
    invalidPositionHandleMode: args2.invalidPositionHandleMode
  };
}
var editorSchema = {
  editor: blockContainer({
    allowedChildren: [...insideOfLayouts, "layout"],
    invalidPositionHandleMode: "move"
  }),
  layout: blockContainer({
    allowedChildren: ["layout-area"],
    invalidPositionHandleMode: "move"
  }),
  "layout-area": blockContainer({
    allowedChildren: insideOfLayouts,
    invalidPositionHandleMode: "unwrap"
  }),
  blockquote: blockContainer({
    allowedChildren: blockquoteChildren,
    invalidPositionHandleMode: "move"
  }),
  paragraph: inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  code: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  divider: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  heading: inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  "component-block": blockContainer({
    allowedChildren: ["component-block-prop", "component-inline-prop"],
    invalidPositionHandleMode: "move"
  }),
  "component-inline-prop": inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  "component-block-prop": blockContainer({
    allowedChildren: insideOfLayouts,
    invalidPositionHandleMode: "unwrap"
  }),
  "ordered-list": blockContainer({
    allowedChildren: ["list-item"],
    invalidPositionHandleMode: "move"
  }),
  "unordered-list": blockContainer({
    allowedChildren: ["list-item"],
    invalidPositionHandleMode: "move"
  }),
  "list-item": blockContainer({
    allowedChildren: ["list-item-content", "ordered-list", "unordered-list"],
    invalidPositionHandleMode: "unwrap"
  }),
  "list-item-content": inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  image: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  table: blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-head", "table-body"]
  }),
  "table-body": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-row"]
  }),
  "table-row": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-cell"]
  }),
  "table-cell": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: tableCellChildren
  }),
  "table-head": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-row"]
  })
};
var inlineContainerTypes = new Set(Object.entries(editorSchema).filter(([, value2]) => value2.kind === "inlines").map(([type3]) => type3));
function isInlineContainer(node2) {
  return node2.type !== void 0 && inlineContainerTypes.has(node2.type);
}
var blockTypes = new Set(Object.keys(editorSchema).filter((x3) => x3 !== "editor"));
function isBlock(node2) {
  return blockTypes.has(node2.type);
}
function getWholeDocumentFeaturesForChildField(editorDocumentFeatures, options) {
  var _options$formatting, _options$formatting2, _options$formatting3, _options$formatting4, _options$formatting5, _options$formatting6, _options$formatting7;
  const inlineMarksFromOptions = (_options$formatting = options.formatting) === null || _options$formatting === void 0 ? void 0 : _options$formatting.inlineMarks;
  const inlineMarks = Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((_mark) => {
    const mark = _mark;
    return [mark, inlineMarksFromOptions === "inherit" || (inlineMarksFromOptions === null || inlineMarksFromOptions === void 0 ? void 0 : inlineMarksFromOptions[mark]) === "inherit" ? editorDocumentFeatures.formatting.inlineMarks[mark] : false];
  }));
  const headingLevels = (_options$formatting2 = options.formatting) === null || _options$formatting2 === void 0 ? void 0 : _options$formatting2.headingLevels;
  return {
    formatting: {
      inlineMarks,
      softBreaks: ((_options$formatting3 = options.formatting) === null || _options$formatting3 === void 0 ? void 0 : _options$formatting3.softBreaks) === "inherit" && editorDocumentFeatures.formatting.softBreaks,
      alignment: {
        center: editorDocumentFeatures.formatting.alignment.center && ((_options$formatting4 = options.formatting) === null || _options$formatting4 === void 0 ? void 0 : _options$formatting4.alignment) === "inherit",
        end: editorDocumentFeatures.formatting.alignment.end && ((_options$formatting5 = options.formatting) === null || _options$formatting5 === void 0 ? void 0 : _options$formatting5.alignment) === "inherit"
      },
      blockTypes: ((_options$formatting6 = options.formatting) === null || _options$formatting6 === void 0 ? void 0 : _options$formatting6.blockTypes) === "inherit" ? editorDocumentFeatures.formatting.blockTypes : {
        blockquote: false,
        code: false
      },
      headings: headingLevels === "inherit" ? editorDocumentFeatures.formatting.headings : {
        levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level) => headingLevels.includes(level)) : [],
        schema: editorDocumentFeatures.formatting.headings.schema
      },
      listTypes: ((_options$formatting7 = options.formatting) === null || _options$formatting7 === void 0 ? void 0 : _options$formatting7.listTypes) === "inherit" ? editorDocumentFeatures.formatting.listTypes : {
        ordered: false,
        unordered: false
      }
    },
    dividers: options.dividers === "inherit" ? editorDocumentFeatures.dividers : false,
    images: options.images === "inherit" && editorDocumentFeatures.images,
    layouts: [],
    links: options.links === "inherit" && editorDocumentFeatures.links,
    tables: options.tables === "inherit" && editorDocumentFeatures.tables
  };
}
function getDocumentFeaturesForChildField(editorDocumentFeatures, options) {
  var _options$formatting8, _options$formatting10, _options$formatting11, _options$formatting12, _options$formatting13, _options$formatting14;
  const inlineMarksFromOptions = (_options$formatting8 = options.formatting) === null || _options$formatting8 === void 0 ? void 0 : _options$formatting8.inlineMarks;
  const inlineMarks = inlineMarksFromOptions === "inherit" ? "inherit" : Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((mark) => {
    return [mark, !!(inlineMarksFromOptions || {})[mark]];
  }));
  if (options.kind === "inline") {
    var _options$formatting9;
    return {
      kind: "inline",
      inlineMarks,
      documentFeatures: {
        links: options.links === "inherit"
      },
      softBreaks: ((_options$formatting9 = options.formatting) === null || _options$formatting9 === void 0 ? void 0 : _options$formatting9.softBreaks) === "inherit"
    };
  }
  const headingLevels = (_options$formatting10 = options.formatting) === null || _options$formatting10 === void 0 ? void 0 : _options$formatting10.headingLevels;
  return {
    kind: "block",
    inlineMarks,
    softBreaks: ((_options$formatting11 = options.formatting) === null || _options$formatting11 === void 0 ? void 0 : _options$formatting11.softBreaks) === "inherit",
    documentFeatures: {
      layouts: [],
      dividers: options.dividers === "inherit" ? editorDocumentFeatures.dividers : false,
      formatting: {
        alignment: ((_options$formatting12 = options.formatting) === null || _options$formatting12 === void 0 ? void 0 : _options$formatting12.alignment) === "inherit" ? editorDocumentFeatures.formatting.alignment : {
          center: false,
          end: false
        },
        blockTypes: ((_options$formatting13 = options.formatting) === null || _options$formatting13 === void 0 ? void 0 : _options$formatting13.blockTypes) === "inherit" ? editorDocumentFeatures.formatting.blockTypes : {
          blockquote: false,
          code: false
        },
        headings: headingLevels === "inherit" ? editorDocumentFeatures.formatting.headings : {
          levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level) => headingLevels.includes(level)) : [],
          schema: editorDocumentFeatures.formatting.headings.schema
        },
        listTypes: ((_options$formatting14 = options.formatting) === null || _options$formatting14 === void 0 ? void 0 : _options$formatting14.listTypes) === "inherit" ? editorDocumentFeatures.formatting.listTypes : {
          ordered: false,
          unordered: false
        }
      },
      links: options.links === "inherit",
      images: options.images === "inherit" ? editorDocumentFeatures.images : false,
      tables: options.tables === "inherit"
    },
    componentBlocks: options.componentBlocks === "inherit"
  };
}
function getSchemaAtPropPathInner(path, value2, schema) {
  if (path.length === 0) {
    return schema;
  }
  if (schema.kind === "child" || schema.kind === "form") {
    return;
  }
  if (schema.kind === "conditional") {
    const key = path.shift();
    if (key === "discriminant") {
      return getSchemaAtPropPathInner(path, value2.discriminant, schema.discriminant);
    }
    if (key === "value") {
      const propVal = schema.values[value2.discriminant];
      return getSchemaAtPropPathInner(path, value2.value, propVal);
    }
    return;
  }
  if (schema.kind === "object") {
    const key = path.shift();
    return getSchemaAtPropPathInner(path, value2[key], schema.fields[key]);
  }
  if (schema.kind === "array") {
    const index2 = path.shift();
    return getSchemaAtPropPathInner(path, value2[index2], schema.element);
  }
  assertNever(schema);
}
function getSchemaAtPropPath(path, value2, props) {
  return getSchemaAtPropPathInner([...path], value2, {
    kind: "object",
    fields: props
  });
}
function getAncestorSchemas(rootSchema, path, value2) {
  const ancestors = [];
  const currentPath = [...path];
  let currentProp = rootSchema;
  let currentValue = value2;
  while (currentPath.length) {
    ancestors.push(currentProp);
    const key = currentPath.shift();
    if (currentProp.kind === "array") {
      currentProp = currentProp.element;
      currentValue = currentValue[key];
    } else if (currentProp.kind === "conditional") {
      currentProp = currentProp.values[value2.discriminant];
      currentValue = currentValue.value;
    } else if (currentProp.kind === "object") {
      currentValue = currentValue[key];
      currentProp = currentProp.fields[key];
    } else if (currentProp.kind === "child" || currentProp.kind === "form") {
      throw new Error(`unexpected prop "${key}"`);
    } else {
      assertNever(currentProp);
    }
  }
  return ancestors;
}
function getPlaceholderTextForPropPath(propPath, fields, formProps) {
  const field = getSchemaAtPropPath(propPath, formProps, fields);
  if ((field === null || field === void 0 ? void 0 : field.kind) === "child" && (field.options.kind === "block" && field.options.editIn !== "modal" || field.options.kind === "inline")) {
    return field.options.placeholder;
  }
  return "";
}
function cloneDescendent(node2) {
  if (Element2.isElement(node2)) {
    return {
      ...node2,
      children: node2.children.map(cloneDescendent)
    };
  }
  return {
    ...node2
  };
}
var allMarks = ["bold", "italic", "underline", "strikethrough", "code", "superscript", "subscript", "keyboard"];
var isElementActive = (editor, format) => {
  const [match2] = Editor.nodes(editor, {
    match: (n5) => n5.type === format
  });
  return !!match2;
};
function clearFormatting(editor) {
  Transforms.unwrapNodes(editor, {
    match: (node2) => node2.type === "heading" || node2.type === "blockquote" || node2.type === "code"
  });
  Transforms.unsetNodes(editor, allMarks, {
    match: Text2.isText
  });
}
function moveChildren(editor, parent, to, shouldMoveNode = () => true) {
  const parentPath = Path.isPath(parent) ? parent : parent[1];
  const parentNode = Path.isPath(parent) ? Node2.get(editor, parentPath) : parent[0];
  if (!isBlock(parentNode)) return;
  for (let i4 = parentNode.children.length - 1; i4 >= 0; i4--) {
    if (shouldMoveNode(parentNode.children[i4], i4)) {
      const childPath = [...parentPath, i4];
      Transforms.moveNodes(editor, {
        at: childPath,
        to
      });
    }
  }
}
function EditorAfterButIgnoringingPointsWithNoContent(editor, at, {
  distance = 1
} = {}) {
  const anchor = Editor.point(editor, at, {
    edge: "end"
  });
  const focus = Editor.end(editor, []);
  const range = {
    anchor,
    focus
  };
  let d5 = 0;
  let target;
  for (const p4 of Editor.positions(editor, {
    at: range
  })) {
    if (d5 > distance) {
      break;
    }
    const node2 = Node2.get(editor, p4.path);
    if (node2.text.length === p4.offset) {
      continue;
    }
    if (d5 !== 0) {
      target = p4;
    }
    d5++;
  }
  return target;
}
function nodeTypeMatcher(...args2) {
  if (args2.length === 1) {
    const type3 = args2[0];
    return (node2) => node2.type === type3;
  }
  const set2 = new Set(args2);
  return (node2) => typeof node2.type === "string" && set2.has(node2.type);
}
function getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) {
  const ancestorComponentProp = Editor.above(editor, {
    match: nodeTypeMatcher("component-block-prop", "component-inline-prop")
  });
  if (ancestorComponentProp) {
    const propPath = ancestorComponentProp[0].propPath;
    const ancestorComponent = Editor.parent(editor, ancestorComponentProp[1]);
    if (ancestorComponent[0].type === "component-block") {
      const component = ancestorComponent[0].component;
      const componentBlock = componentBlocks[component];
      if (componentBlock && propPath) {
        const childField = getSchemaAtPropPath(propPath, ancestorComponent[0].props, componentBlock.schema);
        if ((childField === null || childField === void 0 ? void 0 : childField.kind) === "child") {
          return getDocumentFeaturesForChildField(editorDocumentFeatures, childField.options);
        }
      }
    }
  }
}
var BlockPopoverContext = (0, import_react105.createContext)(null);
function useBlockPopoverContext() {
  const context = (0, import_react105.useContext)(BlockPopoverContext);
  if (!context) {
    throw new Error("useBlockPopoverContext must be used within a BlockPopoverTrigger");
  }
  return context;
}
var typeMatcher = nodeTypeMatcher("code", "component-block", "image", "layout", "link", "table", "heading");
var ActiveBlockPopoverContext = (0, import_react105.createContext)(void 0);
function useActiveBlockPopover() {
  return (0, import_react105.useContext)(ActiveBlockPopoverContext);
}
function ActiveBlockPopoverProvider(props) {
  const nodeWithPopover = Editor.above(props.editor, {
    match: typeMatcher
  });
  return (0, import_jsx_runtime34.jsx)(ActiveBlockPopoverContext.Provider, {
    value: nodeWithPopover === null || nodeWithPopover === void 0 ? void 0 : nodeWithPopover[0],
    children: props.children
  });
}
var BlockPopoverTrigger = ({
  children,
  element: element2
}) => {
  const [trigger2, popover] = children;
  const activePopoverElement = useActiveBlockPopover();
  const triggerRef = (0, import_react105.useRef)(null);
  const state = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: activePopoverElement === element2
  });
  const context = (0, import_react105.useMemo)(() => ({
    state,
    triggerRef
  }), [state, triggerRef]);
  return (0, import_jsx_runtime34.jsxs)(BlockPopoverContext.Provider, {
    value: context,
    children: [(0, import_react105.cloneElement)(trigger2, {
      ref: triggerRef
    }), popover]
  });
};
function BlockPopover(props) {
  const {
    state
  } = useBlockPopoverContext();
  let wrapperRef = (0, import_react105.useRef)(null);
  return (0, import_jsx_runtime34.jsx)(Overlay, {
    isOpen: state.isOpen,
    nodeRef: wrapperRef,
    children: (0, import_jsx_runtime34.jsx)(BlockPopoverWrapper, {
      wrapperRef,
      ...props
    })
  });
}
var BlockPopoverWrapper = ({
  children,
  placement: preferredPlacement = "bottom"
}) => {
  let popoverRef = (0, import_react105.useRef)(null);
  let {
    state,
    triggerRef
  } = useBlockPopoverContext();
  let {
    placement,
    popoverProps
  } = useBlockPopover({
    isNonModal: true,
    isKeyboardDismissDisabled: false,
    placement: preferredPlacement,
    triggerRef,
    popoverRef
  }, state);
  return (0, import_jsx_runtime34.jsx)("div", {
    ref: popoverRef,
    ...popoverProps,
    "data-open": state.isOpen,
    "data-placement": placement,
    contentEditable: false,
    className: css({
      backgroundColor: tokenSchema.color.background.surface,
      // TODO: component token?
      borderRadius: tokenSchema.size.radius.medium,
      // TODO: component token?
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
      boxSizing: "content-box",
      // resolves measurement/scroll issues related to border
      // boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.border.emphasis}`,
      minHeight: tokenSchema.size.element.regular,
      minWidth: tokenSchema.size.element.regular,
      opacity: 0,
      outline: 0,
      pointerEvents: "auto",
      position: "absolute",
      // use filter:drop-shadow instead of box-shadow so the arrow is included
      filter: `drop-shadow(0 1px 4px ${tokenSchema.color.shadow.regular})`,
      // filter bug in safari: https://stackoverflow.com/questions/56478925/safari-drop-shadow-filter-remains-visible-even-with-hidden-element
      willChange: "filter",
      userSelect: "none",
      // placement
      '&[data-placement="top"]': {
        marginBottom: tokenSchema.size.space.regular,
        transform: `translateY(${tokenSchema.size.space.regular})`
      },
      '&[data-placement="bottom"]': {
        marginTop: tokenSchema.size.space.regular,
        transform: `translateY(calc(${tokenSchema.size.space.regular} * -1))`
      },
      '&[data-open="true"]': {
        opacity: 1,
        transform: `translateX(0) translateY(0)`,
        // enter animation
        transition: transition(["opacity", "transform"], {
          easing: "easeOut"
        })
      }
    }),
    children: typeof children === "function" ? children(state.close) : children
  });
};
function useBlockPopover(props, state) {
  var _triggerRef$current2;
  let {
    triggerRef,
    popoverRef,
    isNonModal,
    isKeyboardDismissDisabled,
    ...otherProps
  } = props;
  let [isSticky, setSticky] = (0, import_react105.useState)(false);
  let {
    overlayProps,
    underlayProps
  } = $a11501f3d1d39e6c$export$ea8f71083e90600f({
    isOpen: state.isOpen,
    onClose: state.close,
    shouldCloseOnBlur: true,
    isDismissable: !isNonModal,
    isKeyboardDismissDisabled: false
  }, popoverRef);
  const containerPadding = 8;
  (0, import_react105.useEffect)(() => {
    if (state.isOpen) {
      const checkForStickiness = () => {
        var _popoverRef$current, _triggerRef$current;
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        let popoverRect = (_popoverRef$current = popoverRef.current) === null || _popoverRef$current === void 0 ? void 0 : _popoverRef$current.getBoundingClientRect();
        let triggerRect = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getBoundingClientRect();
        if (popoverRect && triggerRect) {
          setSticky(triggerRect.bottom + popoverRect.height + containerPadding * 2 > vh && triggerRect.top < vh);
        }
      };
      checkForStickiness();
      window.addEventListener("scroll", checkForStickiness);
      return () => {
        checkForStickiness();
        window.removeEventListener("scroll", checkForStickiness);
      };
    }
  }, [popoverRef, triggerRef, state.isOpen]);
  let {
    overlayProps: positionProps,
    arrowProps,
    placement,
    updatePosition
  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1({
    ...otherProps,
    containerPadding,
    shouldFlip: false,
    targetRef: triggerRef,
    overlayRef: popoverRef,
    isOpen: state.isOpen,
    onClose: void 0
  });
  let previousBoundingRect = usePrevious2((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getBoundingClientRect());
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (previousBoundingRect) {
      var _triggerRef$current3;
      const currentBoundingRect = (_triggerRef$current3 = triggerRef.current) === null || _triggerRef$current3 === void 0 ? void 0 : _triggerRef$current3.getBoundingClientRect();
      if (currentBoundingRect) {
        const hasChanged = previousBoundingRect.height !== currentBoundingRect.height || previousBoundingRect.width !== currentBoundingRect.width || previousBoundingRect.x !== currentBoundingRect.x || previousBoundingRect.y !== currentBoundingRect.y;
        if (hasChanged) {
          updatePosition();
        }
      }
    }
  }, [previousBoundingRect, triggerRef, updatePosition]);
  if (positionProps.style) {
    positionProps.style.zIndex = 1;
  }
  if (isSticky) {
    positionProps.style = {
      ...positionProps.style,
      // @ts-expect-error
      maxHeight: null,
      position: "fixed",
      // @ts-expect-error
      top: null,
      bottom: containerPadding
    };
  }
  return {
    arrowProps,
    placement,
    popoverProps: $3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, positionProps),
    underlayProps,
    updatePosition
  };
}
function usePrevious2(value2) {
  const ref = (0, import_react105.useRef)();
  (0, import_react105.useEffect)(() => {
    ref.current = value2;
  });
  return ref.current;
}
var NotEditable = (0, import_react105.forwardRef)(function NotEditable2({
  className,
  ...props
}, ref) {
  return (0, import_jsx_runtime34.jsx)("div", {
    ...props,
    ref,
    className: [css({
      userSelect: "none",
      whiteSpace: "initial"
    }), className].join(" "),
    contentEditable: false
  });
});
function slugify(input) {
  let slug = input.toLowerCase().trim();
  slug = slug.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  slug = slug.replace(/[^a-z0-9\s-]/g, " ").trim();
  slug = slug.replace(/[\s-]+/g, "-");
  return slug;
}
var imageUploadResponse = type({
  src: string(),
  width: number(),
  height: number()
});
function uploadImage(file, config) {
  if (file.size > 1e7) {
    throw new Error("Images must be smaller than 10MB");
  }
  const auth = getCloudAuth(config);
  if (!auth) {
    throw new Error("You must be signed in to upload images");
  }
  const filenameMatch = /(.+)\.(png|jpe?g|gif|webp)$/.exec(file.name);
  if (!filenameMatch) {
    throw new Error("Invalid image type, only PNG, JPEG, GIF, and WebP are supported");
  }
  const filename = slugify(filenameMatch[1]);
  const ext = filenameMatch[2];
  const filenameWithExt = `${filename}.${ext}`;
  const newFile = new File([file], filenameWithExt, {
    type: `image/${filenameWithExt === "jpg" ? "jpeg" : filenameWithExt}`
  });
  const formData = new FormData();
  formData.set("image", newFile, filenameWithExt);
  return (async () => {
    const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/v1/image`, {
      method: "PUT",
      headers: {
        Authorization: `Bearer ${auth.accessToken}`,
        ...KEYSTATIC_CLOUD_HEADERS
      },
      body: formData
    });
    if (!res.ok) {
      throw new Error(`Failed to upload image: ${await res.text()}`);
    }
    const data = await res.json();
    let parsedData;
    try {
      parsedData = imageUploadResponse.create(data);
    } catch {
      throw new Error("Unexpected response from cloud");
    }
    return parsedData;
  })();
}
function parseImageData(data) {
  try {
    const parsed = JSON.parse(data);
    if (typeof parsed === "object" && parsed !== null && "src" in parsed && typeof parsed.src === "string") {
      return {
        src: parsed.src,
        alt: "alt" in parsed && typeof parsed.alt === "string" ? parsed.alt : "",
        height: "height" in parsed && typeof parsed.height === "number" && Number.isInteger(parsed.height) ? parsed.height : void 0,
        width: "width" in parsed && typeof parsed.width === "number" && Number.isInteger(parsed.width) ? parsed.width : void 0
      };
    }
  } catch (err) {
  }
  const pattern = /^\s*!\[(.*)\]\(([a-z0-9_\-/:.]+)\)\s*$/;
  const match2 = data.match(pattern);
  if (match2) {
    return {
      src: match2[2],
      alt: match2[1]
    };
  }
  return {
    src: data,
    alt: ""
  };
}
function useImageDimensions(src) {
  const $ = c(4);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [dimensions, setDimensions] = (0, import_react105.useState)(t0);
  let t1;
  let t22;
  if ($[1] !== src) {
    t1 = () => {
      if (!src || !isValidURL(src)) {
        setDimensions({});
        return;
      }
      let shouldSet;
      shouldSet = true;
      loadImageDimensions(src).then((dimensions_0) => {
        if (shouldSet) {
          setDimensions(dimensions_0);
        }
      });
      return () => {
        shouldSet = false;
      };
    };
    t22 = [src];
    $[1] = src;
    $[2] = t1;
    $[3] = t22;
  } else {
    t1 = $[2];
    t22 = $[3];
  }
  (0, import_react105.useEffect)(t1, t22);
  return dimensions;
}
function loadImageDimensions(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve({
        width: img.width,
        height: img.height
      });
    };
    img.onerror = () => {
      reject();
    };
    img.src = url;
  });
}
var imageDataSchema = type({
  src: string(),
  alt: string(),
  width: number(),
  height: number()
});
async function loadImageData(url, config) {
  const auth = getCloudAuth(config);
  if (auth) {
    const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/v1/image?${new URLSearchParams({
      url
    })}`, {
      headers: {
        Authorization: `Bearer ${auth.accessToken}`,
        ...KEYSTATIC_CLOUD_HEADERS
      }
    });
    if (res.ok) {
      const data = await res.json();
      try {
        return imageDataSchema.create(data);
      } catch {
      }
    }
  }
  return loadImageDimensions(url).then((dimensions) => ({
    src: url,
    alt: "",
    ...dimensions
  }));
}
function ImageDimensionsInput(props) {
  const $ = c(42);
  const dimensions = useImageDimensions(props.src);
  const [constrainProportions, setConstrainProportions] = (0, import_react105.useState)(true);
  const revertLabel = `Revert to original (${dimensions.width} × ${dimensions.height})`;
  const dimensionsMatchOriginal = dimensions.width === props.image.width && dimensions.height === props.image.height;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      maximumFractionDigits: 0
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== constrainProportions || $[2] !== props) {
    t1 = (width) => {
      if (constrainProportions) {
        props.onChange({
          width,
          height: Math.round(width / getAspectRatio(props.image))
        });
      } else {
        props.onChange({
          width
        });
      }
    };
    $[1] = constrainProportions;
    $[2] = props;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t22;
  if ($[4] !== props.image.width || $[5] !== t1) {
    t22 = (0, import_jsx_runtime34.jsx)(NumberField, {
      label: "Width",
      width: "scale.1600",
      formatOptions: t0,
      value: props.image.width,
      onChange: t1
    });
    $[4] = props.image.width;
    $[5] = t1;
    $[6] = t22;
  } else {
    t22 = $[6];
  }
  let t32;
  if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
    t32 = () => {
      setConstrainProportions((state) => !state);
    };
    $[7] = t32;
  } else {
    t32 = $[7];
  }
  const t4 = constrainProportions ? link2Icon : link2OffIcon;
  let t5;
  if ($[8] !== t4) {
    t5 = (0, import_jsx_runtime34.jsx)(Icon, {
      src: t4
    });
    $[8] = t4;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== constrainProportions || $[11] !== t5) {
    t6 = (0, import_jsx_runtime34.jsx)(ToggleButton, {
      isSelected: constrainProportions,
      "aria-label": "Constrain proportions",
      prominence: "low",
      onPress: t32,
      children: t5
    });
    $[10] = constrainProportions;
    $[11] = t5;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  let t7;
  if ($[13] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = (0, import_jsx_runtime34.jsx)(Tooltip, {
      children: "Constrain proportions"
    });
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  let t8;
  if ($[14] !== t6) {
    t8 = (0, import_jsx_runtime34.jsxs)(_TooltipTrigger, {
      children: [t6, t7]
    });
    $[14] = t6;
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = {
      maximumFractionDigits: 0
    };
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  let t10;
  if ($[17] !== constrainProportions || $[18] !== props) {
    t10 = (height) => {
      if (constrainProportions) {
        props.onChange({
          height,
          width: Math.round(height * getAspectRatio(props.image))
        });
      } else {
        props.onChange({
          height
        });
      }
    };
    $[17] = constrainProportions;
    $[18] = props;
    $[19] = t10;
  } else {
    t10 = $[19];
  }
  let t11;
  if ($[20] !== props.image.height || $[21] !== t10) {
    t11 = (0, import_jsx_runtime34.jsx)(NumberField, {
      label: "Height",
      width: "scale.1600",
      formatOptions: t9,
      value: props.image.height,
      onChange: t10
    });
    $[20] = props.image.height;
    $[21] = t10;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  const t12 = dimensionsMatchOriginal || !dimensions.width || !dimensions.height;
  let t13;
  if ($[23] !== props || $[24] !== dimensions.height || $[25] !== dimensions.width) {
    t13 = () => {
      props.onChange({
        height: dimensions.height,
        width: dimensions.width
      });
    };
    $[23] = props;
    $[24] = dimensions.height;
    $[25] = dimensions.width;
    $[26] = t13;
  } else {
    t13 = $[26];
  }
  let t14;
  if ($[27] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = (0, import_jsx_runtime34.jsx)(Icon, {
      src: undo2Icon
    });
    $[27] = t14;
  } else {
    t14 = $[27];
  }
  let t15;
  if ($[28] !== revertLabel || $[29] !== t12 || $[30] !== t13) {
    t15 = (0, import_jsx_runtime34.jsx)(ActionButton, {
      "aria-label": revertLabel,
      isDisabled: t12,
      onPress: t13,
      children: t14
    });
    $[28] = revertLabel;
    $[29] = t12;
    $[30] = t13;
    $[31] = t15;
  } else {
    t15 = $[31];
  }
  let t16;
  if ($[32] !== revertLabel) {
    t16 = (0, import_jsx_runtime34.jsx)(Tooltip, {
      maxWidth: "100%",
      children: revertLabel
    });
    $[32] = revertLabel;
    $[33] = t16;
  } else {
    t16 = $[33];
  }
  let t17;
  if ($[34] !== t15 || $[35] !== t16) {
    t17 = (0, import_jsx_runtime34.jsxs)(_TooltipTrigger, {
      children: [t15, t16]
    });
    $[34] = t15;
    $[35] = t16;
    $[36] = t17;
  } else {
    t17 = $[36];
  }
  let t18;
  if ($[37] !== t22 || $[38] !== t8 || $[39] !== t11 || $[40] !== t17) {
    t18 = (0, import_jsx_runtime34.jsxs)(HStack, {
      gap: "regular",
      alignItems: "end",
      children: [t22, t8, t11, t17]
    });
    $[37] = t22;
    $[38] = t8;
    $[39] = t11;
    $[40] = t17;
    $[41] = t18;
  } else {
    t18 = $[41];
  }
  return t18;
}
var emptyImageData = {
  src: "",
  alt: ""
};
var ALLOWED_IMAGE_EXTENSIONS = ["jpeg", "jpg", "png", "gif", "webp"];
var ACCEPTED_TYPES = ALLOWED_IMAGE_EXTENSIONS.map((ext) => `image/${ext}`);
function UploadImageButton(props) {
  var _config$cloud;
  const $ = c(12);
  let styleProps;
  if ($[0] !== props) {
    const {
      onUploaded,
      ...t02
    } = props;
    styleProps = t02;
    $[0] = props;
    $[1] = styleProps;
  } else {
    styleProps = $[1];
  }
  const config = useConfig();
  const [isUploading, setIsUploading] = (0, import_react105.useState)(false);
  if (!((_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project)) {
    return null;
  }
  let t0;
  if ($[2] !== config || $[3] !== props) {
    t0 = async (items) => {
      const files = Array.from(items || []);
      if (files[0]) {
        setIsUploading(true);
        try {
          const result = await uploadImage(files[0], config);
          props.onUploaded({
            ...result,
            alt: ""
          });
          setIsUploading(false);
        } catch (t12) {
          const err = t12;
          setIsUploading(false);
          toastQueue.critical(err.message);
        }
      }
    };
    $[2] = config;
    $[3] = props;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  const t1 = isUploading ? "Uploading…" : "Upload";
  let t22;
  if ($[5] !== isUploading || $[6] !== styleProps || $[7] !== t1) {
    t22 = (0, import_jsx_runtime34.jsx)(ActionButton, {
      isDisabled: isUploading,
      ...styleProps,
      children: t1
    });
    $[5] = isUploading;
    $[6] = styleProps;
    $[7] = t1;
    $[8] = t22;
  } else {
    t22 = $[8];
  }
  let t32;
  if ($[9] !== t0 || $[10] !== t22) {
    t32 = (0, import_jsx_runtime34.jsx)(_FileTrigger, {
      acceptedFileTypes: ACCEPTED_TYPES,
      onSelect: t0,
      children: t22
    });
    $[9] = t0;
    $[10] = t22;
    $[11] = t32;
  } else {
    t32 = $[11];
  }
  return t32;
}
function ImageDialog(props) {
  const $ = c(45);
  const {
    image,
    onCancel,
    onChange: onChange2,
    onClose
  } = props;
  const [state, setState] = (0, import_react105.useState)(image !== null && image !== void 0 ? image : emptyImageData);
  const [status, setStatus] = (0, import_react105.useState)(image ? "good" : "");
  const formId = useId();
  const imageLibraryURL = useImageLibraryURL();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (event) => {
      event.preventDefault();
      const text3 = event.clipboardData.getData("text/plain");
      setState(parseImageData(text3));
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const onPaste = t0;
  const config = useConfig();
  const hasSetFields = !!(state.alt || state.width || state.height);
  let t1;
  let t22;
  if ($[1] !== state.src || $[2] !== hasSetFields || $[3] !== config) {
    t1 = () => {
      if (!state.src) {
        setStatus("");
        return;
      }
      if (!isValidURL(state.src)) {
        return;
      }
      if (hasSetFields) {
        setStatus("good");
        return;
      }
      setStatus("loading");
      loadImageData(state.src, config).then((newData) => {
        setState((state_0) => ({
          ...state_0,
          ...newData
        }));
        setStatus("good");
      }).catch(() => {
        setStatus("error");
      });
    };
    t22 = [config, hasSetFields, state.src];
    $[1] = state.src;
    $[2] = hasSetFields;
    $[3] = config;
    $[4] = t1;
    $[5] = t22;
  } else {
    t1 = $[4];
    t22 = $[5];
  }
  (0, import_react105.useEffect)(t1, t22);
  let t32;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t32 = (0, import_jsx_runtime34.jsx)(Heading, {
      children: "Cloud image"
    });
    $[6] = t32;
  } else {
    t32 = $[6];
  }
  let t4;
  if ($[7] !== status || $[8] !== onChange2 || $[9] !== state || $[10] !== onClose) {
    t4 = (e4) => {
      e4.preventDefault();
      if (status !== "good") {
        return;
      }
      onChange2(state);
      onClose();
    };
    $[7] = status;
    $[8] = onChange2;
    $[9] = state;
    $[10] = onClose;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (e_0) => {
      if (e_0.code === "Backspace" || e_0.code === "Delete") {
        setState(emptyImageData);
      } else {
        e_0.continuePropagation();
      }
    };
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== imageLibraryURL) {
    t6 = (0, import_jsx_runtime34.jsxs)(Text, {
      children: ["Copy an image URL from the", " ", (0, import_jsx_runtime34.jsx)(TextLink3, {
        prominence: "high",
        href: imageLibraryURL,
        target: "_blank",
        rel: "noreferrer",
        children: "Image Library"
      }), " ", "and paste it into this field."]
    });
    $[13] = imageLibraryURL;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  let t7;
  if ($[15] !== status || $[16] !== state) {
    t7 = status === "loading" ? (0, import_jsx_runtime34.jsx)(Flex, {
      height: "element.regular",
      width: "element.regular",
      alignItems: "center",
      justifyContent: "center",
      children: (0, import_jsx_runtime34.jsx)(ProgressCircle, {
        size: "small",
        "aria-label": "Checking…",
        isIndeterminate: true
      })
    }) : state.src ? (0, import_jsx_runtime34.jsx)(ClearButton, {
      onPress: () => setState(emptyImageData),
      preventFocus: true
    }) : null;
    $[15] = status;
    $[16] = state;
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  let t8;
  if ($[18] !== state.src || $[19] !== t6 || $[20] !== t7) {
    t8 = (0, import_jsx_runtime34.jsx)(TextField, {
      label: "Image URL",
      flex: true,
      autoFocus: true,
      onPaste,
      onKeyDown: t5,
      value: state.src,
      description: t6,
      endElement: t7
    });
    $[18] = state.src;
    $[19] = t6;
    $[20] = t7;
    $[21] = t8;
  } else {
    t8 = $[21];
  }
  let t9;
  if ($[22] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = (0, import_jsx_runtime34.jsx)(UploadImageButton, {
      onUploaded: (data) => {
        setState(data);
      }
    });
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== t8) {
    t10 = (0, import_jsx_runtime34.jsxs)(HStack, {
      alignItems: "end",
      gap: "medium",
      children: [t8, t9]
    });
    $[23] = t8;
    $[24] = t10;
  } else {
    t10 = $[24];
  }
  let t11;
  if ($[25] !== status || $[26] !== state) {
    t11 = status === "good" ? (0, import_jsx_runtime34.jsxs)(import_jsx_runtime34.Fragment, {
      children: [(0, import_jsx_runtime34.jsx)(TextArea, {
        label: "Alt text",
        value: state.alt,
        onChange: (alt) => setState((state_1) => ({
          ...state_1,
          alt
        }))
      }), (0, import_jsx_runtime34.jsx)(ImageDimensionsInput, {
        src: state.src,
        image: state,
        onChange: (dimensions) => {
          setState((state_2) => ({
            ...state_2,
            ...dimensions
          }));
        }
      })]
    }) : null;
    $[25] = status;
    $[26] = state;
    $[27] = t11;
  } else {
    t11 = $[27];
  }
  let t12;
  if ($[28] !== formId || $[29] !== t4 || $[30] !== t10 || $[31] !== t11) {
    t12 = (0, import_jsx_runtime34.jsx)(Content, {
      children: (0, import_jsx_runtime34.jsxs)(VStack, {
        elementType: "form",
        id: formId,
        gap: "xlarge",
        onSubmit: t4,
        children: [t10, t11]
      })
    });
    $[28] = formId;
    $[29] = t4;
    $[30] = t10;
    $[31] = t11;
    $[32] = t12;
  } else {
    t12 = $[32];
  }
  let t13;
  if ($[33] !== onCancel) {
    t13 = (0, import_jsx_runtime34.jsx)(Button, {
      onPress: onCancel,
      children: "Cancel"
    });
    $[33] = onCancel;
    $[34] = t13;
  } else {
    t13 = $[34];
  }
  const t14 = status !== "good";
  const t15 = image ? "Done" : "Insert";
  let t16;
  if ($[35] !== formId || $[36] !== t14 || $[37] !== t15) {
    t16 = (0, import_jsx_runtime34.jsx)(Button, {
      prominence: "high",
      type: "submit",
      form: formId,
      isDisabled: t14,
      children: t15
    });
    $[35] = formId;
    $[36] = t14;
    $[37] = t15;
    $[38] = t16;
  } else {
    t16 = $[38];
  }
  let t17;
  if ($[39] !== t13 || $[40] !== t16) {
    t17 = (0, import_jsx_runtime34.jsxs)(ButtonGroup, {
      children: [t13, t16]
    });
    $[39] = t13;
    $[40] = t16;
    $[41] = t17;
  } else {
    t17 = $[41];
  }
  let t18;
  if ($[42] !== t12 || $[43] !== t17) {
    t18 = (0, import_jsx_runtime34.jsxs)(Dialog, {
      children: [t32, t12, t17]
    });
    $[42] = t12;
    $[43] = t17;
    $[44] = t18;
  } else {
    t18 = $[44];
  }
  return t18;
}
function Placeholder(props) {
  const $ = c(26);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      defaultOpen: false
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const state = $fc909762b330b746$export$61c6a8c84e605fb6(t0);
  const {
    open
  } = state;
  let t1;
  let t22;
  if ($[1] !== props.selected || $[2] !== open) {
    t1 = () => {
      if (props.selected) {
        open();
      }
    };
    t22 = [props.selected, open];
    $[1] = props.selected;
    $[2] = open;
    $[3] = t1;
    $[4] = t22;
  } else {
    t1 = $[3];
    t22 = $[4];
  }
  (0, import_react105.useEffect)(t1, t22);
  let t32;
  if ($[5] !== state || $[6] !== props) {
    t32 = () => {
      state.close();
      props.onRemove();
    };
    $[5] = state;
    $[6] = props;
    $[7] = t32;
  } else {
    t32 = $[7];
  }
  const closeAndCleanup = t32;
  let t4;
  if ($[8] !== state) {
    t4 = () => state.open();
    $[8] = state;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  let t5;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime34.jsx)(Icon, {
      src: imageIcon
    });
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  const t6 = state.isOpen ? "" : "(click to configure)";
  let t7;
  if ($[11] !== t6) {
    t7 = (0, import_jsx_runtime34.jsxs)(Text, {
      children: ["Cloud image", t6]
    });
    $[11] = t6;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  let t8;
  if ($[13] !== t4 || $[14] !== t7) {
    t8 = (0, import_jsx_runtime34.jsxs)(Flex, {
      alignItems: "center",
      backgroundColor: "surface",
      borderRadius: "regular",
      gap: "regular",
      height: "element.large",
      paddingX: "large",
      onClick: t4,
      children: [t5, t7]
    });
    $[13] = t4;
    $[14] = t7;
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] !== state || $[17] !== props || $[18] !== closeAndCleanup) {
    t9 = state.isOpen && (0, import_jsx_runtime34.jsx)(ImageDialog, {
      onChange: props.onChange,
      onCancel: closeAndCleanup,
      onClose: state.close
    });
    $[16] = state;
    $[17] = props;
    $[18] = closeAndCleanup;
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  let t10;
  if ($[20] !== closeAndCleanup || $[21] !== t9) {
    t10 = (0, import_jsx_runtime34.jsx)(DialogContainer, {
      onDismiss: closeAndCleanup,
      children: t9
    });
    $[20] = closeAndCleanup;
    $[21] = t9;
    $[22] = t10;
  } else {
    t10 = $[22];
  }
  let t11;
  if ($[23] !== t8 || $[24] !== t10) {
    t11 = (0, import_jsx_runtime34.jsxs)(NotEditable, {
      children: [t8, t10]
    });
    $[23] = t8;
    $[24] = t10;
    $[25] = t11;
  } else {
    t11 = $[25];
  }
  return t11;
}
function ImagePreview(t0) {
  const $ = c(38);
  const {
    image,
    onChange: onChange2,
    onRemove,
    selected
  } = t0;
  const t1 = selected ? "accent" : "surface";
  const t22 = selected ? "color.alias.borderFocused" : "neutral";
  let t32;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t32 = {
      maxHeight: 368
    };
    $[0] = t32;
  } else {
    t32 = $[0];
  }
  let t4;
  if ($[1] !== image.src) {
    t4 = imageWithTransforms({
      source: image.src,
      height: 736,
      width: 1468
    });
    $[1] = image.src;
    $[2] = t4;
  } else {
    t4 = $[2];
  }
  let t5;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      objectFit: "contain"
    };
    $[3] = t5;
  } else {
    t5 = $[3];
  }
  let t6;
  if ($[4] !== image.alt || $[5] !== t4) {
    t6 = (0, import_jsx_runtime34.jsx)(Flex, {
      backgroundColor: "canvas",
      justifyContent: "center",
      UNSAFE_style: t32,
      children: (0, import_jsx_runtime34.jsx)("img", {
        alt: image.alt,
        src: t4,
        style: t5
      })
    });
    $[4] = image.alt;
    $[5] = t4;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  const t7 = selected ? "color.alias.borderFocused" : "neutral";
  let t8;
  if ($[7] !== image.alt) {
    t8 = image.alt ? (0, import_jsx_runtime34.jsx)(Text, {
      truncate: 2,
      children: image.alt
    }) : null;
    $[7] = image.alt;
    $[8] = t8;
  } else {
    t8 = $[8];
  }
  let t9;
  if ($[9] !== image.width || $[10] !== image.height) {
    t9 = (0, import_jsx_runtime34.jsxs)(Text, {
      color: "neutralTertiary",
      size: "small",
      children: [image.width, " × ", image.height]
    });
    $[9] = image.width;
    $[10] = image.height;
    $[11] = t9;
  } else {
    t9 = $[11];
  }
  let t10;
  if ($[12] !== t8 || $[13] !== t9) {
    t10 = (0, import_jsx_runtime34.jsxs)(VStack, {
      flex: "1",
      gap: "medium",
      justifyContent: "center",
      children: [t8, t9]
    });
    $[12] = t8;
    $[13] = t9;
    $[14] = t10;
  } else {
    t10 = $[14];
  }
  let t11;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = (0, import_jsx_runtime34.jsx)(ActionButton, {
      children: (0, import_jsx_runtime34.jsx)(Icon, {
        src: pencilIcon
      })
    });
    $[15] = t11;
  } else {
    t11 = $[15];
  }
  let t12;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = (0, import_jsx_runtime34.jsxs)(_TooltipTrigger, {
      children: [t11, (0, import_jsx_runtime34.jsx)(Tooltip, {
        children: "Edit Image Options"
      })]
    });
    $[16] = t12;
  } else {
    t12 = $[16];
  }
  let t13;
  if ($[17] !== image || $[18] !== onChange2) {
    t13 = (0, import_jsx_runtime34.jsxs)(_DialogTrigger, {
      children: [t12, (onClose) => (0, import_jsx_runtime34.jsx)(ImageDialog, {
        image,
        onChange: onChange2,
        onCancel: onClose,
        onClose
      })]
    });
    $[17] = image;
    $[18] = onChange2;
    $[19] = t13;
  } else {
    t13 = $[19];
  }
  let t14;
  if ($[20] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = (0, import_jsx_runtime34.jsx)(Icon, {
      src: trash2Icon
    });
    $[20] = t14;
  } else {
    t14 = $[20];
  }
  let t15;
  if ($[21] !== onRemove) {
    t15 = (0, import_jsx_runtime34.jsx)(ActionButton, {
      onPress: onRemove,
      children: t14
    });
    $[21] = onRemove;
    $[22] = t15;
  } else {
    t15 = $[22];
  }
  let t16;
  if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = (0, import_jsx_runtime34.jsx)(Tooltip, {
      children: "Remove Image"
    });
    $[23] = t16;
  } else {
    t16 = $[23];
  }
  let t17;
  if ($[24] !== t15) {
    t17 = (0, import_jsx_runtime34.jsxs)(_TooltipTrigger, {
      children: [t15, t16]
    });
    $[24] = t15;
    $[25] = t17;
  } else {
    t17 = $[25];
  }
  let t18;
  if ($[26] !== t13 || $[27] !== t17) {
    t18 = (0, import_jsx_runtime34.jsxs)(HStack, {
      gap: "regular",
      children: [t13, t17]
    });
    $[26] = t13;
    $[27] = t17;
    $[28] = t18;
  } else {
    t18 = $[28];
  }
  let t19;
  if ($[29] !== t7 || $[30] !== t10 || $[31] !== t18) {
    t19 = (0, import_jsx_runtime34.jsxs)(HStack, {
      padding: "large",
      gap: "xlarge",
      borderTop: t7,
      children: [t10, t18]
    });
    $[29] = t7;
    $[30] = t10;
    $[31] = t18;
    $[32] = t19;
  } else {
    t19 = $[32];
  }
  let t20;
  if ($[33] !== t1 || $[34] !== t22 || $[35] !== t6 || $[36] !== t19) {
    t20 = (0, import_jsx_runtime34.jsx)(import_jsx_runtime34.Fragment, {
      children: (0, import_jsx_runtime34.jsx)(NotEditable, {
        children: (0, import_jsx_runtime34.jsxs)(VStack, {
          backgroundColor: t1,
          borderRadius: "medium",
          border: t22,
          overflow: "hidden",
          children: [t6, t19]
        })
      })
    });
    $[33] = t1;
    $[34] = t22;
    $[35] = t6;
    $[36] = t19;
    $[37] = t20;
  } else {
    t20 = $[37];
  }
  return t20;
}
function handleFile(file, config) {
  try {
    const result = uploadImage(file, config);
    toastQueue.info("Uploading image…");
    return result.then((data) => {
      toastQueue.positive("Image uploaded");
      return {
        ...data,
        alt: ""
      };
    });
  } catch (err) {
    toastQueue.critical(err.message);
    return false;
  }
}
function CloudImagePreviewForNewEditor(props) {
  var _props$value$width, _props$value$height;
  const $ = c(14);
  if (!props.value.src) {
    let t02;
    if ($[0] !== props.onChange || $[1] !== props.onRemove || $[2] !== props.isSelected) {
      t02 = (0, import_jsx_runtime34.jsx)(Placeholder, {
        onChange: props.onChange,
        onRemove: props.onRemove,
        selected: props.isSelected
      });
      $[0] = props.onChange;
      $[1] = props.onRemove;
      $[2] = props.isSelected;
      $[3] = t02;
    } else {
      t02 = $[3];
    }
    return t02;
  }
  const t0 = (_props$value$width = props.value.width) !== null && _props$value$width !== void 0 ? _props$value$width : void 0;
  const t1 = (_props$value$height = props.value.height) !== null && _props$value$height !== void 0 ? _props$value$height : void 0;
  let t22;
  if ($[4] !== props.value.src || $[5] !== props.value.alt || $[6] !== t0 || $[7] !== t1) {
    t22 = {
      src: props.value.src,
      alt: props.value.alt,
      width: t0,
      height: t1
    };
    $[4] = props.value.src;
    $[5] = props.value.alt;
    $[6] = t0;
    $[7] = t1;
    $[8] = t22;
  } else {
    t22 = $[8];
  }
  let t32;
  if ($[9] !== t22 || $[10] !== props.onChange || $[11] !== props.onRemove || $[12] !== props.isSelected) {
    t32 = (0, import_jsx_runtime34.jsx)(ImagePreview, {
      image: t22,
      onChange: props.onChange,
      onRemove: props.onRemove,
      selected: props.isSelected
    });
    $[9] = t22;
    $[10] = props.onChange;
    $[11] = props.onRemove;
    $[12] = props.isSelected;
    $[13] = t32;
  } else {
    t32 = $[13];
  }
  return t32;
}
function imageWithTransforms(options) {
  let {
    fit = "scale-down",
    source,
    height,
    width
  } = options;
  if (!/^https?:\/\/[^\.]+\.keystatic\.net/.test(source)) {
    return source;
  }
  return `${source}?` + new URLSearchParams({
    fit,
    height: height.toString(),
    width: width.toString()
  }).toString();
}
function isValidURL(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}
function useImageLibraryURL() {
  const config = useConfig();
  const split2 = getSplitCloudProject(config);
  if (!split2) {
    return "https://keystatic.cloud/";
  }
  return `https://keystatic.cloud/teams/${split2.team}/project/${split2.project}/images`;
}
function getAspectRatio(state) {
  if (!state.width || !state.height) return 1;
  return state.width / state.height;
}
var cloudImageToolbarIcon = imageIcon;
var FieldDataError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "FieldDataError";
  }
};
function assertRequired(value2, validation, label) {
  if (value2 === null && validation !== null && validation !== void 0 && validation.isRequired) {
    throw new FieldDataError(`${label} is required`);
  }
}
function basicFormFieldWithSimpleReaderParse(config) {
  return {
    kind: "form",
    Input: config.Input,
    defaultValue: config.defaultValue,
    parse: config.parse,
    serialize: config.serialize,
    validate: config.validate,
    reader: {
      parse(value2) {
        return config.validate(config.parse(value2));
      }
    },
    label: config.label
  };
}
function areArraysEqual(a3, b2) {
  return a3.length === b2.length && a3.every((x3, i4) => x3 === b2[i4]);
}
function normalizeTextBasedOnInlineMarksAndSoftBreaks([node2, path], editor, inlineMarks, softBreaks) {
  const marksToRemove = Object.keys(node2).filter((x3) => x3 !== "text" && x3 !== "insertMenu" && inlineMarks[x3] !== true);
  if (marksToRemove.length) {
    Transforms.unsetNodes(editor, marksToRemove, {
      at: path
    });
    return true;
  }
  if (!softBreaks) {
    const hasSoftBreaks = node2.text.includes("\n");
    if (hasSoftBreaks) {
      const [parentNode] = Editor.parent(editor, path);
      if (parentNode.type !== "code") {
        for (const position2 of Editor.positions(editor, {
          at: path
        })) {
          const character2 = Node2.get(editor, position2.path).text[position2.offset];
          if (character2 === "\n") {
            Transforms.delete(editor, {
              at: position2
            });
            return true;
          }
        }
      }
    }
  }
  return false;
}
function normalizeInlineBasedOnLinks([node2, path], editor, links) {
  if (node2.type === "link" && !links) {
    Transforms.insertText(editor, ` (${node2.href})`, {
      at: Editor.end(editor, path)
    });
    Transforms.unwrapNodes(editor, {
      at: path
    });
    return true;
  }
  return false;
}
function normalizeElementBasedOnDocumentFeatures([node2, path], editor, {
  formatting,
  dividers,
  layouts,
  links,
  images,
  tables
}) {
  if (node2.type === "heading" && (!formatting.headings.levels.length || !formatting.headings.levels.includes(node2.level)) || node2.type === "ordered-list" && !formatting.listTypes.ordered || node2.type === "unordered-list" && !formatting.listTypes.unordered || node2.type === "code" && !formatting.blockTypes.code || node2.type === "blockquote" && !formatting.blockTypes.blockquote || node2.type === "image" && !images || node2.type === "table" && !tables || node2.type === "layout" && (layouts.length === 0 || !layouts.some((layout) => areArraysEqual(layout, node2.layout)))) {
    Transforms.unwrapNodes(editor, {
      at: path
    });
    return true;
  }
  if ((node2.type === "paragraph" || node2.type === "heading") && (!formatting.alignment.center && node2.textAlign === "center" || !formatting.alignment.end && node2.textAlign === "end" || "textAlign" in node2 && node2.textAlign !== "center" && node2.textAlign !== "end")) {
    Transforms.unsetNodes(editor, "textAlign", {
      at: path
    });
    return true;
  }
  if (node2.type === "divider" && !dividers) {
    Transforms.removeNodes(editor, {
      at: path
    });
    return true;
  }
  return normalizeInlineBasedOnLinks([node2, path], editor, links);
}
function withDocumentFeaturesNormalization(documentFeatures, editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([node2, path]) => {
    if (Text2.isText(node2)) {
      normalizeTextBasedOnInlineMarksAndSoftBreaks([node2, path], editor, documentFeatures.formatting.inlineMarks, documentFeatures.formatting.softBreaks);
    } else if (Element2.isElement(node2)) {
      normalizeElementBasedOnDocumentFeatures([node2, path], editor, documentFeatures);
    }
    normalizeNode([node2, path]);
  };
  return editor;
}
function CollabAddToPathProvider(props) {
  const yjsInfo = useYjsIfAvailable();
  const cloudInfo = useCloudInfo();
  const router = useRouter();
  const awarenessStates = useAwarenessStates();
  const avatarsAtPath = (0, import_react105.useMemo)(() => {
    if (!yjsInfo || yjsInfo === "loading" || !cloudInfo) {
      return [];
    }
    const avatars = [];
    for (const [clientId, val] of awarenessStates) {
      if (clientId === yjsInfo.awareness.clientID || !val.user || router.href !== `/keystatic/branch/${val.branch}/${val.location}` || !Array.isArray(val.path) || !areArraysEqual(val.path, props.path)) {
        continue;
      }
      avatars.push(val.user);
    }
    return avatars;
  }, [yjsInfo, cloudInfo, awarenessStates, router.href, props.path]);
  return (0, import_jsx_runtime34.jsxs)("div", {
    "data-ks-path": JSON.stringify(props.path),
    onFocus: (e4) => {
      if (e4.target.closest("[data-ks-path]") === e4.currentTarget) {
        if (yjsInfo && yjsInfo !== "loading") {
          yjsInfo.awareness.setLocalStateField("path", props.path);
        }
      }
    },
    children: [!!avatarsAtPath.length && (0, import_jsx_runtime34.jsx)("div", {
      className: css({
        position: "relative",
        width: "100%",
        height: 0
      }),
      children: (0, import_jsx_runtime34.jsx)("div", {
        className: css({
          position: "absolute",
          top: 0,
          right: 0,
          display: "flex",
          gap: "0.5em"
        }),
        children: avatarsAtPath.map((avatar, i4) => (0, import_jsx_runtime34.jsx)(Avatar, {
          size: "xsmall",
          src: avatar.avatarUrl,
          name: avatar.name
        }, i4))
      })
    }), props.children]
  });
}
function AddToPathProvider(props) {
  const $ = c(9);
  const path = (0, import_react105.useContext)(PathContext);
  const config = useConfig();
  let t0;
  let t1;
  if ($[0] !== path || $[1] !== props.part) {
    t1 = path.concat(props.part);
    $[0] = path;
    $[1] = props.part;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  t0 = t1;
  const newPath = t0;
  let t22;
  if ($[3] !== newPath || $[4] !== props.children) {
    t22 = (0, import_jsx_runtime34.jsx)(PathContext.Provider, {
      value: newPath,
      children: props.children
    });
    $[3] = newPath;
    $[4] = props.children;
    $[5] = t22;
  } else {
    t22 = $[5];
  }
  const inner = t22;
  if (config.storage.kind === "cloud") {
    let t32;
    if ($[6] !== newPath || $[7] !== inner) {
      t32 = (0, import_jsx_runtime34.jsx)(CollabAddToPathProvider, {
        path: newPath,
        children: inner
      });
      $[6] = newPath;
      $[7] = inner;
      $[8] = t32;
    } else {
      t32 = $[8];
    }
    return t32;
  }
  return inner;
}
var SlugFieldContext = (0, import_react105.createContext)(void 0);
var SlugFieldProvider = SlugFieldContext.Provider;
var PathContext = (0, import_react105.createContext)([]);
var PathContextProvider = PathContext.Provider;
function validateText(val, min2, max2, fieldLabel, slugInfo, pattern) {
  if (val.length < min2) {
    if (min2 === 1) {
      return `${fieldLabel} must not be empty`;
    } else {
      return `${fieldLabel} must be at least ${min2} characters long`;
    }
  }
  if (val.length > max2) {
    return `${fieldLabel} must be no longer than ${max2} characters`;
  }
  if (pattern && !pattern.regex.test(val)) {
    return pattern.message || `${fieldLabel} must match the pattern ${pattern.regex}`;
  }
  if (slugInfo) {
    if (val === "") {
      return `${fieldLabel} must not be empty`;
    }
    if (val === "..") {
      return `${fieldLabel} must not be ..`;
    }
    if (val === ".") {
      return `${fieldLabel} must not be .`;
    }
    if (slugInfo.glob === "**") {
      const split2 = val.split("/");
      if (split2.some((s4) => s4 === "..")) {
        return `${fieldLabel} must not contain ..`;
      }
      if (split2.some((s4) => s4 === ".")) {
        return `${fieldLabel} must not be .`;
      }
    }
    if ((slugInfo.glob === "*" ? /[\\/]/ : /[\\]/).test(val)) {
      return `${fieldLabel} must not contain slashes`;
    }
    if (/^\s|\s$/.test(val)) {
      return `${fieldLabel} must not start or end with spaces`;
    }
    if (slugInfo.slugs.has(val)) {
      return `${fieldLabel} must be unique`;
    }
  }
}
function TextFieldInput(props) {
  const $ = c(15);
  const TextFieldComponent = props.multiline ? TextArea : TextField;
  const [blurred, setBlurred] = (0, import_react105.useState)(false);
  const slugContext = (0, import_react105.useContext)(SlugFieldContext);
  const path = (0, import_react105.useContext)(PathContext);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => setBlurred(true);
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const t1 = props.min > 0;
  let t22;
  if ($[1] !== props || $[2] !== blurred || $[3] !== path || $[4] !== slugContext) {
    t22 = props.forceValidation || blurred ? validateText(props.value, props.min, props.max, props.label, path.length === 1 && (slugContext === null || slugContext === void 0 ? void 0 : slugContext.field) === path[0] ? slugContext : void 0, props.pattern) : void 0;
    $[1] = props;
    $[2] = blurred;
    $[3] = path;
    $[4] = slugContext;
    $[5] = t22;
  } else {
    t22 = $[5];
  }
  let t32;
  if ($[6] !== TextFieldComponent || $[7] !== props.label || $[8] !== props.description || $[9] !== props.autoFocus || $[10] !== props.value || $[11] !== props.onChange || $[12] !== t1 || $[13] !== t22) {
    t32 = (0, import_jsx_runtime34.jsx)(TextFieldComponent, {
      label: props.label,
      description: props.description,
      autoFocus: props.autoFocus,
      value: props.value,
      onChange: props.onChange,
      onBlur: t0,
      isRequired: t1,
      errorMessage: t22
    });
    $[6] = TextFieldComponent;
    $[7] = props.label;
    $[8] = props.description;
    $[9] = props.autoFocus;
    $[10] = props.value;
    $[11] = props.onChange;
    $[12] = t1;
    $[13] = t22;
    $[14] = t32;
  } else {
    t32 = $[14];
  }
  return t32;
}
function parseAsNormalField(value2) {
  if (value2 === void 0) {
    return "";
  }
  if (typeof value2 !== "string") {
    throw new FieldDataError("Must be a string");
  }
  return value2;
}
var emptySet = /* @__PURE__ */ new Set();
function text2({
  label,
  defaultValue = "",
  validation: {
    length: {
      max: max2 = Infinity,
      min: min2 = 0
    } = {},
    pattern,
    isRequired
  } = {},
  description,
  multiline = false
}) {
  min2 = Math.max(isRequired ? 1 : 0, min2);
  function validate2(value2, slugField) {
    const message = validateText(value2, min2, max2, label, slugField, pattern);
    if (message !== void 0) {
      throw new FieldDataError(message);
    }
    return value2;
  }
  return {
    kind: "form",
    formKind: "slug",
    label,
    Input(props) {
      return (0, import_jsx_runtime34.jsx)(TextFieldInput, {
        label,
        description,
        min: min2,
        max: max2,
        multiline,
        pattern,
        ...props
      });
    },
    defaultValue() {
      return typeof defaultValue === "string" ? defaultValue : defaultValue();
    },
    parse(value2, args2) {
      if ((args2 === null || args2 === void 0 ? void 0 : args2.slug) !== void 0) {
        return args2.slug;
      }
      return parseAsNormalField(value2);
    },
    serialize(value2) {
      return {
        value: value2 === "" ? void 0 : value2
      };
    },
    serializeWithSlug(value2) {
      return {
        slug: value2,
        value: void 0
      };
    },
    reader: {
      parse(value2) {
        const parsed = parseAsNormalField(value2);
        return validate2(parsed, void 0);
      },
      parseWithSlug(_value, args2) {
        validate2(parseAsNormalField(args2.slug), {
          glob: args2.glob,
          slugs: emptySet
        });
        return null;
      }
    },
    validate(value2, args2) {
      return validate2(value2, args2 === null || args2 === void 0 ? void 0 : args2.slugField);
    }
  };
}

export {
  c,
  c2,
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c,
  $8ae05eaa5c114e9c$export$7f54fc3180508a52,
  $1dbecbe27a04f9af$export$14d238f342723f25,
  $bdb11010cef70236$export$f680877a34711e37,
  $bdb11010cef70236$export$b4cc09c592e8fdb8,
  $ff5963eb1fccf552$export$e08e3b67e392101e,
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f,
  $7215afc6de606d6b$export$de79e2c695e052f3,
  $c87311424ea30a05$export$9ac100e40613ea10,
  $c87311424ea30a05$export$e1865c3bedcd822b,
  $c87311424ea30a05$export$78551043582a6a98,
  $c87311424ea30a05$export$a11b0059900ceec8,
  $ea8dcbcb9ea1b556$export$9a302a45f65d0572,
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7,
  $ea8dcbcb9ea1b556$export$bdc77b0c0a3a85d6,
  $ea8dcbcb9ea1b556$export$7e924b3091a3bd18,
  $313b98861ee5dd6c$export$d6875122194c7b44,
  $df56164dff5785e2$export$4338b53315abf666,
  $4f58c5f72bcf79f7$export$496315a1608d9602,
  $9daab02d461809db$export$683480f191c0e3ea,
  $e7801be82b4b2a53$export$4debdb1a3f0fa79e,
  $cc38e7bd3fc7b213$export$2bb74740c4e19def,
  $62d8ded9296f3872$export$cfa2225e87938781,
  $ef06256079686ba0$export$f8aeda7b10753fa1,
  $e9faafb641e167db$export$90fc3a17d93f704c,
  $2f04cbc44ee30ce0$export$53a0910f038337bd,
  $2f04cbc44ee30ce0$export$c826860796309d1b,
  $99facab73266f662$export$5add1d006293d136,
  $26f7f3da73fcd9d6$export$7717c92ee915373e,
  $458b0a5536c1a7cf$export$40bfa8c7b0832715,
  $9446cca9a3875146$export$7d15b64cf5a3a4c4,
  $18f2051aff69b9bf$export$43bb16f9c6d9e3f7,
  $fca6afa0e843324b$export$f12b703ca79dfbb1,
  $325a3faab7a68acd$export$a16aca283550c30d,
  $bb77f239b46e8c72$export$3274cf84b703fff,
  $f6c31cce2adf654f$export$45712eceda6fad21,
  $f1ab8c75478c6f73$export$3351871ee4b288b8,
  $a1ea59d68270f0dd$export$f8168d8dd8fd66e6,
  $507fabe10e71c6fb$export$b9b3dfddab17db27,
  $507fabe10e71c6fb$export$630ff653c5ada6a9,
  $507fabe10e71c6fb$export$8397ddfc504fdb9a,
  $507fabe10e71c6fb$export$98e20ec92f614cfe,
  $9ab94262bd0047c7$export$420e68273165f4ec,
  $6179b936705e76d3$export$ae780daf29e6d456,
  $46d819fcbaf35654$export$8f71654801c2f7cd,
  $e8a7022cf87cba2a$export$36da96379f79f245,
  $8a26561d2877236e$export$c24ed0104d07eab9,
  $6a99195332edec8b$export$80f3e147d781571c,
  $9bf71ea28793e738$export$20e40289641fbbb6,
  $9bf71ea28793e738$export$2d6ec8fc375ceafa,
  $9bf71ea28793e738$export$c5251b9e124bf29,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  $907718708eab68af$export$1a38b4ad7f578e1d,
  $e6afbd83fe6ebbd2$export$4c014de7c8940b4c,
  $83013635b024ae3d$export$eac1895992b9f3d6,
  $628037886ba31236$export$f9d5c8beee7d008d,
  $5c3e21d68f1c4674$export$a966af930f325cab,
  $5c3e21d68f1c4674$export$439d29a4e110a164,
  $86ea4cb521eb2e37$export$2317d149ed6f78c4,
  $5e3802645cc19319$export$1c3ebcada18427bf,
  $96b38030c423d352$export$574e9b0fb070c3b0,
  $8ac8429251c45e4b$export$dbc0f175b25fb0fb,
  injectGlobal,
  css,
  assert,
  assertNever,
  isString,
  typedKeys,
  tokenSchema,
  transition,
  resetClassName,
  classNames,
  ClassList,
  breakpoints,
  breakpointQueries$1,
  containerQueries,
  useBreakpoint,
  onlyStyleProps,
  toDataAttributes,
  FocusRing,
  useIsMobileDevice,
  useMediaQuery,
  useStyleProps,
  forwardRefWithAs,
  useProvider,
  useProviderProps,
  KeystarProvider,
  ClientSideOnlyDocumentElement,
  useSlotProps,
  SlotProvider,
  ClearSlots,
  Content,
  Footer,
  $701a24aa0da5b062$export$ea18c227d4417cc3,
  $298d61e98472621b$export$dcf14c9974fe2767,
  useHasChild,
  isReactText,
  useId,
  useIsMounted,
  usePrevious,
  Heading,
  Text,
  Kbd,
  Prose,
  useProseStyleProps,
  $d191a55c9702f145$export$8467354a121f1b9f,
  $2baaea4c71418dea$export$294aa081a6c6f55d,
  ProgressCircle,
  xIcon,
  Icon,
  $3017fa7ffdddec74$export$8042c6c013fd5226,
  ButtonGroup,
  Button,
  actionButtonClassList,
  ActionButton,
  ClearButton,
  FieldButton,
  useFieldButton,
  ToggleButton,
  $f4b273590fab9f93$export$52210f68a14655d0,
  Box,
  Divider,
  minmax,
  Flex,
  Grid,
  ScrollView,
  VStack,
  HStack,
  TextLink3 as TextLink,
  $e93e671b31057976$export$b8473d3665f3a75a,
  $e5be200c675c3b3a$export$dad6ae84456c676a,
  $e5be200c675c3b3a$export$a763b9476acd3eb,
  $e5be200c675c3b3a$export$fc1a364ae1f3ff10,
  $e5be200c675c3b3a$export$75ee7c75d68f5b0e,
  $2d73ec29415bd339$export$712718f7aec83d5,
  alertTriangleIcon,
  FieldLabel,
  FieldMessage,
  FieldPrimitive,
  Field,
  validateFieldProps,
  TextFieldPrimitive,
  validateTextFieldProps,
  TextField,
  TextArea,
  $319e236875307eab$export$a9b970dcc4ae71a9,
  minusIcon,
  Blanket,
  Transition,
  Popover,
  Tray,
  $fc909762b330b746$export$61c6a8c84e605fb6,
  Tooltip,
  _TooltipTrigger,
  InsertionIndicatorPrimitive,
  useDragAndDrop,
  chevronDownIcon,
  plusIcon,
  imageIcon,
  $40df3f8667284809$export$d55e7ee900f34e93,
  Dialog,
  AlertDialog,
  DialogContainer,
  useDialogContainer,
  _DialogTrigger,
  isPlainObject,
  createEditor,
  Element2 as Element,
  Editor,
  Node2 as Node,
  Operation,
  Path,
  Point,
  Range,
  Text2,
  Transforms,
  ReactEditor,
  useSlateStatic,
  useSelected,
  useSlate,
  Editable,
  Slate,
  withReact,
  pencilIcon,
  trash2Icon,
  NumberField,
  checkCircle2Icon,
  infoIcon,
  Toaster,
  toastQueue,
  min,
  max,
  create3 as create,
  methodUnimplemented,
  unexpectedCase,
  create5 as create2,
  setIfUndefined,
  keys,
  oneOf,
  isBrowser2 as isBrowser,
  doc,
  timeout,
  iterateDeletedStructs,
  isDeleted,
  createDeleteSet,
  Doc,
  createID,
  findRootTypeKey,
  isParentOf,
  RelativePosition,
  createRelativePositionFromJSON,
  createRelativePositionFromTypeIndex,
  createAbsolutePositionFromRelativePosition,
  compareRelativePositions,
  Snapshot,
  createSnapshot,
  snapshot,
  UndoManager,
  AbstractType,
  typeListToArraySnapshot,
  YArray,
  YMap,
  YText,
  YXmlFragment,
  YXmlElement,
  YXmlText,
  ContentFormat,
  ContentString,
  ContentType,
  Item,
  createMutex,
  weakMemoize,
  lib_default2 as lib_default,
  e2 as e,
  valueFromASTUntyped2 as valueFromASTUntyped,
  filter,
  map3 as map,
  mergeMap,
  merge3 as merge,
  onStart,
  share,
  take,
  takeUntil,
  r4 as r,
  makeSubject,
  empty,
  fromPromise,
  toPromise,
  stringifyVariables,
  stringifyDocument,
  createRequest,
  makeErrorResult,
  formatDocument,
  makeOperation,
  fetchExchange,
  Q2 as Q,
  f5 as f,
  useClient,
  useMutation,
  useQuery,
  LRUCache,
  Avatar,
  RouterProvider,
  useRouter,
  fixPath,
  getCollectionPath,
  getCollectionFormat,
  getSingletonFormat,
  getCollectionItemPath,
  getEntryDataFilepath,
  getSlugGlobForCollection,
  getSingletonPath,
  getDataFileExtension,
  getPathPrefix,
  blobSha,
  getTreeNodeAtPath,
  treeSha,
  updateTreeWithChanges,
  LOADING,
  suspendOnData,
  useData,
  collectDirectoriesUsedInSchema,
  getDirectoriesForTreeKey,
  getTreeKey,
  object2 as object,
  setDraft,
  delDraft,
  getDraft,
  clearDrafts,
  getCollection,
  getBranchPrefix,
  isGitHubConfig,
  isLocalConfig,
  isCloudConfig,
  getRepoUrl,
  getSlugFromState,
  getEntriesInCollectionWithTreeKey,
  KEYSTATIC_CLOUD_API_URL,
  KEYSTATIC_CLOUD_HEADERS,
  redirectToCloudAuth,
  useShowRestoredDraftMessage,
  getSyncAuth,
  getCloudAuth,
  getAuth,
  useViewer,
  parseRepoConfig,
  serializeRepoConfig,
  assertValidRepoConfig,
  scopeEntriesWithPathPrefix,
  setBlobToPersistedCache,
  getBlobFromPersistedCache,
  clearObjectCache,
  useYjs,
  useYjsIfAvailable,
  useAwarenessStates,
  useSetTreeSha,
  LocalAppShellProvider,
  useCloudInfo,
  useRawCloudInfo,
  CloudInfoProvider,
  GitHubAppShellDataContext,
  GitHubAppShellDataProvider,
  GitHubAppShellProvider,
  AppShellErrorContext,
  useCurrentBranch,
  useBranches,
  useRepoInfo,
  useTree,
  useCurrentUnscopedTree,
  useChanged,
  useBaseCommit,
  Ref_base,
  CloudAppShellQuery,
  GitHubAppShellQuery,
  hydrateTreeCacheWithEntries,
  fetchGitHubTreeData,
  ConfigContext,
  useConfig,
  AppStateContext,
  useAppState,
  ContentPanelProvider,
  useContentPanelSize,
  useContentPanelQuery,
  useContentPanelState,
  focusWithPreviousSelection,
  blockElementSpacing,
  useElementWithSetNodes,
  useEventCallback,
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading,
  editorSchema,
  isInlineContainer,
  isBlock,
  getWholeDocumentFeaturesForChildField,
  getDocumentFeaturesForChildField,
  getSchemaAtPropPath,
  getAncestorSchemas,
  getPlaceholderTextForPropPath,
  cloneDescendent,
  allMarks,
  isElementActive,
  clearFormatting,
  moveChildren,
  EditorAfterButIgnoringingPointsWithNoContent,
  nodeTypeMatcher,
  getAncestorComponentChildFieldDocumentFeatures,
  useActiveBlockPopover,
  ActiveBlockPopoverProvider,
  BlockPopoverTrigger,
  BlockPopover,
  NotEditable,
  parseImageData,
  loadImageData,
  ImageDimensionsInput,
  emptyImageData,
  UploadImageButton,
  handleFile,
  CloudImagePreviewForNewEditor,
  useImageLibraryURL,
  cloudImageToolbarIcon,
  FieldDataError,
  assertRequired,
  basicFormFieldWithSimpleReaderParse,
  areArraysEqual,
  normalizeTextBasedOnInlineMarksAndSoftBreaks,
  normalizeInlineBasedOnLinks,
  normalizeElementBasedOnDocumentFeatures,
  withDocumentFeaturesNormalization,
  AddToPathProvider,
  SlugFieldContext,
  SlugFieldProvider,
  PathContext,
  PathContextProvider,
  validateText,
  text2 as text
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

partysocket/dist/chunk-TPTC3KUF.mjs:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/
//# sourceMappingURL=chunk-XHUR5DH2.js.map
