'use client';
export { Item } from '@react-stately/collections';
import { useBreadcrumbItem, useBreadcrumbs } from '@react-aria/breadcrumbs';
import { mergeProps, useObjectRef, useValueEffect, useResizeObserver, useLayoutEffect } from '@react-aria/utils';
import { useRef, Fragment, forwardRef, Children, useState, useCallback, createElement, isValidElement } from 'react';
import { ActionButton } from '@keystar/ui/button';
import { useProviderProps } from '@keystar/ui/core';
import { Icon } from '@keystar/ui/icon';
import { folderClosedIcon } from '@keystar/ui/icon/icons/folderClosedIcon';
import { folderOpenIcon } from '@keystar/ui/icon/icons/folderOpenIcon';
import { MenuTrigger, Menu } from '@keystar/ui/menu';
import { ClassList, toDataAttributes, classNames, css, tokenSchema, FocusRing, useStyleProps } from '@keystar/ui/style';
import { c } from './react-compiler-runtime-19061925.js';
import { useLocale } from '@react-aria/i18n';
import { useHover } from '@react-aria/interactions';
import { chevronRightIcon } from '@keystar/ui/icon/icons/chevronRightIcon';
import { chevronLeftIcon } from '@keystar/ui/icon/icons/chevronLeftIcon';
import { jsx, jsxs } from 'react/jsx-runtime';

const breadcrumbsClassList = new ClassList('Breadcrumbs', ['item', 'link', 'list', 'separator']);
function BreadcrumbItem(props) {
  const $ = c(26);
  const {
    children,
    isCurrent,
    isDisabled,
    isMenu,
    size: t0
  } = props;
  const size = t0 === undefined ? "regular" : t0;
  const {
    direction
  } = useLocale();
  const ref = useRef(null);
  const ElementType = props.href ? "a" : "span";
  let t1;
  if ($[0] !== props || $[1] !== ElementType) {
    t1 = {
      ...props,
      elementType: ElementType
    };
    $[0] = props;
    $[1] = ElementType;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let {
    itemProps
  } = useBreadcrumbItem(t1, ref);
  const {
    hoverProps,
    isHovered
  } = useHover(props);
  let t2;
  t2 = direction === "rtl" ? chevronLeftIcon : chevronRightIcon;
  const icon = t2;
  if (isMenu) {
    let t3;
    if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
      t3 = {};
      $[3] = t3;
    } else {
      t3 = $[3];
    }
    itemProps = t3;
  }
  let t3;
  if ($[4] !== itemProps || $[5] !== hoverProps) {
    t3 = mergeProps(itemProps, hoverProps);
    $[4] = itemProps;
    $[5] = hoverProps;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  const t4 = size !== "regular" ? size : undefined;
  const t5 = isHovered ? "hover" : undefined;
  let t6;
  if ($[7] !== t4 || $[8] !== t5) {
    t6 = toDataAttributes({
      size: t4,
      interaction: t5
    });
    $[7] = t4;
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== isHovered) {
    t7 = classNames(breadcrumbsClassList.element("link"), css({
      color: tokenSchema.color.foreground.neutral,
      cursor: "default",
      fontSize: tokenSchema.typography.text.regular.size,
      fontFamily: tokenSchema.typography.fontFamily.base,
      fontWeight: tokenSchema.typography.fontWeight.medium,
      outline: 0,
      MozOsxFontSmoothing: "auto",
      WebkitFontSmoothing: "auto",
      "&[data-size=small]": {
        fontSize: tokenSchema.typography.text.small.size
      },
      "&[data-size=medium]": {
        fontSize: tokenSchema.typography.text.medium.size
      },
      "&[data-size=large]": {
        fontSize: tokenSchema.typography.text.large.size
      },
      "&:not([aria-current=page])": {
        "&:not([aria-disabled=true])": {
          cursor: "pointer"
        },
        "&[data-interaction=hover]": {
          color: tokenSchema.color.foreground.neutralEmphasis,
          textDecoration: "underline"
        },
        "&[data-focus=visible]": {
          color: tokenSchema.color.foreground.neutralEmphasis,
          textDecoration: "underline",
          textDecorationStyle: "double"
        },
        "&[aria-disabled=true]": {
          color: tokenSchema.color.alias.foregroundDisabled
        }
      },
      "&[aria-current=page]": {
        color: tokenSchema.color.foreground.neutralEmphasis,
        fontWeight: tokenSchema.typography.fontWeight.semibold,
        overflow: "hidden",
        textOverflow: "ellipsis"
      }
    }), {
      "is-hovered": isHovered
    });
    $[10] = isHovered;
    $[11] = t7;
  } else {
    t7 = $[11];
  }
  let t8;
  if ($[12] !== ElementType || $[13] !== t3 || $[14] !== t6 || $[15] !== ref || $[16] !== t7 || $[17] !== children) {
    t8 = /*#__PURE__*/jsx(FocusRing, {
      children: /*#__PURE__*/jsx(ElementType, {
        ...t3,
        ...t6,
        ref: ref,
        className: t7,
        children: children
      })
    });
    $[12] = ElementType;
    $[13] = t3;
    $[14] = t6;
    $[15] = ref;
    $[16] = t7;
    $[17] = children;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] !== isCurrent || $[20] !== isDisabled || $[21] !== icon) {
    t9 = !isCurrent && /*#__PURE__*/jsx(Icon, {
      src: icon,
      color: isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary",
      marginX: "small",
      UNSAFE_className: breadcrumbsClassList.element("separator")
    });
    $[19] = isCurrent;
    $[20] = isDisabled;
    $[21] = icon;
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== t8 || $[24] !== t9) {
    t10 = /*#__PURE__*/jsxs(Fragment, {
      children: [t8, t9]
    });
    $[23] = t8;
    $[24] = t9;
    $[25] = t10;
  } else {
    t10 = $[25];
  }
  return t10;
}

const MIN_VISIBLE_ITEMS = 1;
const MAX_VISIBLE_ITEMS = 4;
function Breadcrumbs(props, ref) {
  props = useProviderProps(props);
  let {
    children,
    showRoot,
    size = 'regular',
    isDisabled,
    onAction,
    ...otherProps
  } = props;

  // Not using React.Children.toArray because it mutates the key prop.
  let childArray = [];
  Children.forEach(children, child => {
    if ( /*#__PURE__*/isValidElement(child)) {
      childArray.push(child);
    }
  });
  let domRef = useObjectRef(ref);
  let listRef = useRef(null);
  let [menuIsOpen, setMenuOpen] = useState(false);
  let [visibleItems, setVisibleItems] = useValueEffect(childArray.length);
  let {
    navProps
  } = useBreadcrumbs(props);
  let styleProps = useStyleProps(otherProps);
  let updateOverflow = useCallback(() => {
    let computeVisibleItems = visibleItems_0 => {
      // refs may be null at runtime
      let currListRef = listRef.current;
      if (!currListRef) {
        return visibleItems_0;
      }
      let listItems = Array.from(currListRef.children);
      if (listItems.length <= 0) {
        return visibleItems_0;
      }
      let containerWidth = currListRef.offsetWidth;
      let isShowingMenu = childArray.length > visibleItems_0;
      let calculatedWidth = 0;
      let newVisibleItems = 0;
      let maxVisibleItems = MAX_VISIBLE_ITEMS;
      if (showRoot) {
        calculatedWidth += listItems.shift().offsetWidth;
        newVisibleItems++;
      }
      if (isShowingMenu) {
        calculatedWidth += listItems.shift().offsetWidth;
        maxVisibleItems--;
      }
      if (showRoot && calculatedWidth >= containerWidth) {
        newVisibleItems--;
      }
      if (listItems.length > 0) {
        // Ensure the last breadcrumb isn't truncated when we measure it.
        let last = listItems.pop();
        last.style.overflow = 'visible';
        calculatedWidth += last.offsetWidth;
        if (calculatedWidth < containerWidth) {
          newVisibleItems++;
        }
        last.style.overflow = '';
      }
      for (let breadcrumb of listItems.reverse()) {
        calculatedWidth += breadcrumb.offsetWidth;
        if (calculatedWidth < containerWidth) {
          newVisibleItems++;
        }
      }
      return Math.max(MIN_VISIBLE_ITEMS, Math.min(maxVisibleItems, newVisibleItems));
    };
    setVisibleItems(function* () {
      // Update to show all items.
      yield childArray.length;

      // Measure, and update to show the items that fit.
      let newVisibleItems_0 = computeVisibleItems(childArray.length);
      yield newVisibleItems_0;

      // If the number of items is less than the number of children,
      // then update again to ensure that the menu fits.
      if (newVisibleItems_0 < childArray.length && newVisibleItems_0 > 1) {
        yield computeVisibleItems(newVisibleItems_0);
      }
    });
  }, [childArray.length, setVisibleItems, showRoot]);
  useResizeObserver({
    ref: domRef,
    onResize: updateOverflow
  });
  let lastChildren = useRef(null);
  useLayoutEffect(() => {
    if (children !== lastChildren.current) {
      lastChildren.current = children;
      updateOverflow();
    }
  });
  let contents = childArray;
  if (childArray.length > visibleItems) {
    var _selectedItem$key;
    let selectedItem = childArray[childArray.length - 1];
    let selectedKey = (_selectedItem$key = selectedItem.key) !== null && _selectedItem$key !== void 0 ? _selectedItem$key : childArray.length - 1;
    let onMenuAction = key => {
      // Don't fire onAction when clicking on the last item
      if (key !== selectedKey && onAction) {
        onAction(key);
      }
    };
    let menuItem = /*#__PURE__*/jsx(BreadcrumbItem, {
      isMenu: true,
      children: /*#__PURE__*/jsxs(MenuTrigger, {
        onOpenChange: setMenuOpen,
        children: [/*#__PURE__*/jsx(ActionButton, {
          "aria-label": "\u2026",
          prominence: "low",
          isDisabled: isDisabled,
          children: /*#__PURE__*/jsx(Icon, {
            src: menuIsOpen ? folderOpenIcon : folderClosedIcon
          })
        }), /*#__PURE__*/jsx(Menu, {
          selectionMode: "single",
          selectedKeys: [selectedKey],
          onAction: onMenuAction,
          children: childArray
        })]
      })
    }, "menu");
    contents = [menuItem];
    let breadcrumbs = [...childArray];
    let endItems = visibleItems;
    if (showRoot && visibleItems > 1) {
      let rootItem = breadcrumbs.shift();
      if (rootItem) {
        contents.unshift(rootItem);
      }
      endItems--;
    }
    contents.push(...breadcrumbs.slice(-endItems));
  }
  let lastIndex = contents.length - 1;
  let breadcrumbItems = contents.map((child_0, index) => {
    var _child_0$key;
    let isCurrent = index === lastIndex;
    let key_0 = (_child_0$key = child_0.key) !== null && _child_0$key !== void 0 ? _child_0$key : index;
    let onPress = () => {
      if (onAction) {
        onAction(key_0);
      }
    };
    return /*#__PURE__*/jsx("li", {
      className: classNames(breadcrumbsClassList.element('item'), css({
        alignItems: 'center',
        display: 'inline-flex',
        whiteSpace: 'nowrap',
        '&:last-child': {
          overflow: 'hidden'
        }
      })),
      children: /*#__PURE__*/createElement(BreadcrumbItem, {
        ...child_0.props,
        isCurrent: isCurrent,
        isDisabled: isDisabled,
        key: key_0,
        onPress: onPress,
        size: size
      }, child_0.props.children)
    }, index);
  });
  return /*#__PURE__*/jsx("nav", {
    ...navProps,
    ...styleProps,
    ref: domRef,
    className: classNames(breadcrumbsClassList.element('root'), styleProps.className),
    children: /*#__PURE__*/jsx("ul", {
      ref: listRef,
      className: classNames(breadcrumbsClassList.element('list'), css({
        display: 'flex',
        height: tokenSchema.size.element.regular,
        justifyContent: 'flex-start'
      })),
      children: breadcrumbItems
    })
  });
}

// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref

/**
 * Breadcrumbs show hierarchy and navigational context for a user's location
 * within an application.
 */
const _Breadcrumbs = /*#__PURE__*/forwardRef(Breadcrumbs);

export { _Breadcrumbs as Breadcrumbs };
