'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useObjectRef, useValueEffect, useLayoutEffect, useResizeObserver, filterDOMProps, mergeProps } from '@react-aria/utils';
import { forwardRef, useRef, useState, useEffect } from 'react';
import { useProvider, useProviderProps, KeystarProvider } from '@keystar/ui/core';
import { useSlotProps, SlotProvider } from '@keystar/ui/slots';
import { useStyleProps, toDataAttributes, classNames, css, tokenSchema, ClassList, transition, FocusRing } from '@keystar/ui/style';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useButton, useToggleButton } from '@react-aria/button';
import { useLocalizedStringFormatter } from '@react-aria/i18n';
import { useHover } from '@react-aria/interactions';
import { useLink } from '@react-aria/link';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { ProgressCircle } from './keystar-ui-progress.js';
import { xIcon } from '@keystar/ui/icon/icons/xIcon';
import { Icon } from '@keystar/ui/icon';
import { useToggleState } from '@react-stately/toggle';

function getCheckForOverflow(domRef, orientation, _scale, setHasOverflow, _children) {
  return () => {
    let computeHasOverflow = () => {
      if (domRef.current && orientation === 'horizontal') {
        let buttonGroupChildren = Array.from(domRef.current.children);
        let maxX = domRef.current.offsetWidth + 1; // + 1 to account for rounding errors
        // If any buttons have negative X positions (align="end") or extend beyond
        // the width of the button group (align="start"), then switch to vertical.
        if (buttonGroupChildren.some(child => child.offsetLeft < 0 || child.offsetLeft + child.offsetWidth > maxX)) {
          return true;
        }
        return false;
      }
    };
    if (orientation === 'horizontal') {
      setHasOverflow(function* () {
        // Force to horizontal for measurement.
        yield false;

        // Measure, and update if there is overflow.
        yield computeHasOverflow();
      });
    }
  };
}

/**
 * Handles overflow for a grouping of buttons whose actions are related to each
 * other.
 */
const ButtonGroup = /*#__PURE__*/forwardRef(function ButtonGroup(props, forwardedRef) {
  const $ = c(37);
  const {
    scale
  } = useProvider();
  props = useProviderProps(props);
  props = useSlotProps(props, "buttonGroup");
  let t0;
  let t1;
  let otherProps;
  let children;
  let isDisabled;
  if ($[0] !== props) {
    ({
      align: t0,
      children,
      isDisabled,
      orientation: t1,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = otherProps;
    $[4] = children;
    $[5] = isDisabled;
  } else {
    t0 = $[1];
    t1 = $[2];
    otherProps = $[3];
    children = $[4];
    isDisabled = $[5];
  }
  const align = t0 === undefined ? "start" : t0;
  const orientation = t1 === undefined ? "horizontal" : t1;
  const styleProps = useStyleProps(otherProps);
  const domRef = useObjectRef(forwardedRef);
  const [hasOverflow, setHasOverflow] = useValueEffect(false);
  let t2;
  let t3;
  if ($[6] !== domRef || $[7] !== orientation || $[8] !== scale || $[9] !== setHasOverflow || $[10] !== children) {
    t3 = getCheckForOverflow(domRef, orientation, scale, setHasOverflow);
    $[6] = domRef;
    $[7] = orientation;
    $[8] = scale;
    $[9] = setHasOverflow;
    $[10] = children;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  t2 = t3;
  const checkForOverflow = t2;
  let t4;
  let t5;
  if ($[12] !== checkForOverflow) {
    t4 = () => {
      checkForOverflow();
    };
    t5 = [checkForOverflow];
    $[12] = checkForOverflow;
    $[13] = t4;
    $[14] = t5;
  } else {
    t4 = $[13];
    t5 = $[14];
  }
  useLayoutEffect(t4, t5);
  const parent = useRef();
  let t6;
  if ($[15] !== domRef.current) {
    t6 = () => {
      if (domRef.current) {
        parent.current = domRef.current.parentElement;
      }
    };
    $[15] = domRef.current;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  useLayoutEffect(t6);
  let t7;
  if ($[17] !== parent || $[18] !== checkForOverflow) {
    t7 = {
      ref: parent,
      onResize: checkForOverflow
    };
    $[17] = parent;
    $[18] = checkForOverflow;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  useResizeObserver(t7);
  let t8;
  if ($[20] !== otherProps) {
    t8 = filterDOMProps(otherProps);
    $[20] = otherProps;
    $[21] = t8;
  } else {
    t8 = $[21];
  }
  const t9 = hasOverflow ? "vertical" : orientation;
  let t10;
  if ($[22] !== align || $[23] !== t9) {
    t10 = toDataAttributes({
      align,
      orientation: t9
    });
    $[22] = align;
    $[23] = t9;
    $[24] = t10;
  } else {
    t10 = $[24];
  }
  let t11;
  if ($[25] !== styleProps.className) {
    t11 = classNames(styleProps.className, css({
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      position: "relative",
      "&[data-orientation=\"horizontal\"]": {
        "&[data-align=\"center\"]": {
          justifyContent: "center"
        },
        "&[data-align=\"end\"]": {
          justifyContent: "flex-end"
        }
      },
      "&[data-orientation=\"vertical\"]": {
        flexDirection: "column",
        "&[data-align=\"center\"]": {
          alignItems: "center"
        },
        "&[data-align=\"end\"]": {
          alignItems: "flex-end"
        }
      }
    }));
    $[25] = styleProps.className;
    $[26] = t11;
  } else {
    t11 = $[26];
  }
  let t12;
  if ($[27] !== isDisabled || $[28] !== children) {
    t12 = /*#__PURE__*/jsx(KeystarProvider, {
      isDisabled: isDisabled,
      children: children
    });
    $[27] = isDisabled;
    $[28] = children;
    $[29] = t12;
  } else {
    t12 = $[29];
  }
  let t13;
  if ($[30] !== t8 || $[31] !== t10 || $[32] !== styleProps || $[33] !== domRef || $[34] !== t11 || $[35] !== t12) {
    t13 = /*#__PURE__*/jsx("div", {
      ...t8,
      ...t10,
      ...styleProps,
      ref: domRef,
      className: t11,
      children: t12
    });
    $[30] = t8;
    $[31] = t10;
    $[32] = styleProps;
    $[33] = domRef;
    $[34] = t11;
    $[35] = t12;
    $[36] = t13;
  } else {
    t13 = $[36];
  }
  return t13;
});

const localizedMessages = {
  "ar-AE": {
    "pending": `قيد الانتظار`
  },
  "bg-BG": {
    "pending": `недовършено`
  },
  "cs-CZ": {
    "pending": `čeká na vyřízení`
  },
  "da-DK": {
    "pending": `afventende`
  },
  "de-DE": {
    "pending": `Ausstehend`
  },
  "el-GR": {
    "pending": `σε εκκρεμότητα`
  },
  "en-US": {
    "pending": `pending`
  },
  "es-ES": {
    "pending": `pendiente`
  },
  "et-EE": {
    "pending": `ootel`
  },
  "fi-FI": {
    "pending": `odottaa`
  },
  "fr-FR": {
    "pending": `En attente`
  },
  "he-IL": {
    "pending": `ממתין ל`
  },
  "hr-HR": {
    "pending": `u tijeku`
  },
  "hu-HU": {
    "pending": `függőben levő`
  },
  "it-IT": {
    "pending": `in sospeso`
  },
  "ja-JP": {
    "pending": `保留`
  },
  "ko-KR": {
    "pending": `보류 중`
  },
  "lt-LT": {
    "pending": `laukiama`
  },
  "lv-LV": {
    "pending": `gaida`
  },
  "nb-NO": {
    "pending": `avventer`
  },
  "nl-NL": {
    "pending": `in behandeling`
  },
  "pl-PL": {
    "pending": `oczekujące`
  },
  "pt-BR": {
    "pending": `pendente`
  },
  "pt-PT": {
    "pending": `pendente`
  },
  "ro-RO": {
    "pending": `în așteptare`
  },
  "ru-RU": {
    "pending": `в ожидании`
  },
  "sk-SK": {
    "pending": `čakajúce`
  },
  "sl-SI": {
    "pending": `v teku`
  },
  "sr-SP": {
    "pending": `nerešeno`
  },
  "sv-SE": {
    "pending": `väntande`
  },
  "tr-TR": {
    "pending": `beklemede`
  },
  "uk-UA": {
    "pending": `в очікуванні`
  },
  "zh-CN": {
    "pending": `待处理`
  },
  "zh-TW": {
    "pending": `待處理`
  }
};

const buttonClassList = new ClassList('Button', ['icon', 'text']);
function useButtonStyles(props, state) {
  const {
    prominence = 'default',
    tone = prominence === 'high' ? 'accent' : 'neutral'
  } = props;
  const {
    isHovered,
    isPending,
    isPressed
  } = state;
  const styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      hovered: isHovered || undefined,
      pending: isPending || undefined,
      pressed: isPressed || undefined,
      prominence: prominence === 'default' ? undefined : prominence,
      tone: tone,
      static: props.static
    }),
    style: styleProps.style,
    className: classNames(buttonClassList.element('root'), css({
      alignItems: 'center',
      borderRadius: tokenSchema.size.radius.full,
      cursor: 'default',
      display: 'inline-flex',
      flexShrink: 0,
      fontSize: tokenSchema.typography.text.regular.size,
      fontWeight: tokenSchema.typography.fontWeight.medium,
      height: tokenSchema.size.element.regular,
      justifyContent: 'center',
      minWidth: tokenSchema.size.element.regular,
      outline: 0,
      paddingInline: tokenSchema.size.space.medium,
      position: 'relative',
      transitionDuration: '130ms',
      transitionProperty: 'background, border-color, box-shadow, color, ',
      transitionTimingFunction: 'ease-out',
      userSelect: 'none',
      // indicate when external link? e.g. `&[href^=http]`
      'a&': {
        cursor: 'pointer'
      },
      '&:disabled, &[aria-disabled]': {
        cursor: 'default'
      },
      // inherit text styles from parent
      [buttonClassList.selector('text', 'descendant')]: {
        fontSize: 'inherit',
        fontWeight: 'inherit',
        marginInline: tokenSchema.size.space.regular
      },
      [`&[data-pending] ${buttonClassList.selector('text')}`]: {
        opacity: 0
      },
      // special size for button icons. otherwise they appear too "thin"
      // beside the bold text
      [buttonClassList.selector('icon', 'descendant')]: {
        height: tokenSchema.size.scale[225],
        width: tokenSchema.size.scale[225]
      },
      [`&[data-pending] ${buttonClassList.selector('icon')}`]: {
        opacity: 0
      },
      // focus ring
      '--focus-ring-color': tokenSchema.color.alias.focusRing,
      '&[data-static=light]': {
        '--focus-ring-color': '#fff'
      },
      '&[data-static=dark]': {
        '--focus-ring-color': '#000'
      },
      '&::after': {
        borderRadius: tokenSchema.size.radius.full,
        content: '""',
        inset: 0,
        pointerEvents: 'none',
        position: 'absolute',
        transition: transition(['box-shadow', 'margin'], {
          easing: 'easeOut'
        })
      },
      '&[data-focus=visible]::after': {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`,
        margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`
      },
      // PROMINENCE: default
      '&:not([data-prominence])': {
        backgroundColor: tokenSchema.color.scale.slate4,
        color: tokenSchema.color.foreground.neutralEmphasis,
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.scale.slate5
        },
        '&[data-pressed]': {
          backgroundColor: tokenSchema.color.scale.slate6
        },
        // tones
        '&[data-tone=accent]': {
          color: tokenSchema.color.foreground.accent
        },
        '&[data-tone=critical]': {
          color: tokenSchema.color.foreground.critical
        },
        // states
        '&:disabled, &[aria-disabled=true]': {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        '&[data-static=light]': {
          backgroundColor: '#ffffff12',
          color: '#fff',
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: '#ffffff1a'
          },
          '&[data-pressed]': {
            backgroundColor: '#ffffff26'
          },
          '&:disabled, &[aria-disabled]': {
            backgroundColor: '#ffffff1a',
            color: '#ffffff8c'
          }
        },
        '&[data-static=dark]': {
          backgroundColor: '#00000012',
          color: '#000',
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: '#0000001a'
          },
          '&[data-pressed]': {
            backgroundColor: '#00000026'
          },
          '&:disabled, &[aria-disabled]': {
            backgroundColor: '#0000001a',
            color: '#0000008c'
          }
        }
      },
      // PROMINENCE: high
      '&[data-prominence=high]': {
        backgroundColor: tokenSchema.color.scale.slate10,
        color: tokenSchema.color.foreground.inverse,
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.scale.slate11
        },
        '&[data-pressed]': {
          backgroundColor: tokenSchema.color.scale.slate11
        },
        // NOTE: "neutral" tone invalid for "high" prominence
        '&[data-tone=accent]': {
          backgroundColor: tokenSchema.color.scale.indigo9,
          color: tokenSchema.color.foreground.onEmphasis,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.indigo10
          },
          '&[data-pressed]': {
            backgroundColor: tokenSchema.color.scale.indigo11
          }
        },
        '&[data-tone=critical]': {
          backgroundColor: tokenSchema.color.scale.red9,
          color: tokenSchema.color.foreground.onEmphasis,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.red10
          },
          '&[data-pressed]': {
            backgroundColor: tokenSchema.color.scale.red11
          }
        },
        // tone selector to increase specificity
        '&[data-tone]:disabled, &[data-tone][aria-disabled=true]': {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        '&[data-static=light]': {
          backgroundColor: '#ffffffe6',
          color: '#000',
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: '#fff'
          },
          '&[data-pressed]': {
            backgroundColor: '#fff'
          },
          '&:disabled, &[aria-disabled]': {
            backgroundColor: '#ffffff1a',
            color: '#ffffff8c'
          }
        },
        '&[data-static=dark]': {
          backgroundColor: '#000000e6',
          color: '#fff',
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: '#000'
          },
          '&[data-pressed]': {
            backgroundColor: '#000'
          },
          '&:disabled, &[aria-disabled]': {
            backgroundColor: '#0000001a',
            color: '#0000008c'
          }
        }
      },
      // PROMINENCE: low
      '&[data-prominence=low]': {
        color: tokenSchema.color.foreground.neutral,
        // neutral interactions
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.foreground.neutralEmphasis
        },
        '&[data-pressed]': {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // tones
        '&[data-tone=accent]': {
          color: tokenSchema.color.foreground.accent,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.indigo3
          },
          '&[data-pressed]': {
            backgroundColor: tokenSchema.color.scale.indigo4
          }
        },
        '&[data-tone=critical]': {
          color: tokenSchema.color.foreground.critical,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.red3
          },
          '&[data-pressed]': {
            backgroundColor: tokenSchema.color.scale.red4
          }
        },
        '&:disabled, &[aria-disabled=true]': {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        '&[data-static=light]': {
          color: '#fff',
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: '#ffffff1a'
          },
          '&[data-pressed]': {
            backgroundColor: '#ffffff26'
          },
          '&:disabled, &[aria-disabled]': {
            color: '#ffffff8c'
          }
        },
        '&[data-static=dark]': {
          color: '#000',
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: '#0000001a'
          },
          '&[data-pressed]': {
            backgroundColor: '#00000026'
          },
          '&:disabled, &[aria-disabled]': {
            color: '#0000008c'
          }
        }
      }
    }), styleProps.className)
  };
}

const Button = /*#__PURE__*/forwardRef(function Button(props, forwardedRef) {
  const $ = c(14);
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const children = useButtonChildren(props);
  const domRef = useObjectRef(forwardedRef);
  if ("href" in props && props.href) {
    const t0 = domRef;
    let t1;
    if ($[0] !== t0 || $[1] !== props || $[2] !== children) {
      t1 = /*#__PURE__*/jsx(LinkButton$1, {
        ref: t0,
        ...props,
        children: children
      });
      $[0] = t0;
      $[1] = props;
      $[2] = children;
      $[3] = t1;
    } else {
      t1 = $[3];
    }
    let t2;
    if ($[4] !== props.autoFocus || $[5] !== t1) {
      t2 = /*#__PURE__*/jsx(FocusRing, {
        autoFocus: props.autoFocus,
        children: t1
      });
      $[4] = props.autoFocus;
      $[5] = t1;
      $[6] = t2;
    } else {
      t2 = $[6];
    }
    return t2;
  }
  const t0 = domRef;
  let t1;
  if ($[7] !== t0 || $[8] !== props || $[9] !== children) {
    t1 = /*#__PURE__*/jsx(BaseButton$1, {
      ref: t0,
      ...props,
      children: children
    });
    $[7] = t0;
    $[8] = props;
    $[9] = children;
    $[10] = t1;
  } else {
    t1 = $[10];
  }
  let t2;
  if ($[11] !== props.autoFocus || $[12] !== t1) {
    t2 = /*#__PURE__*/jsx(FocusRing, {
      autoFocus: props.autoFocus,
      children: t1
    });
    $[11] = props.autoFocus;
    $[12] = t1;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  return t2;
});

// Variants
// -----------------------------------------------------------------------------

/** @private Forked variant where an "href" is provided. */
const LinkButton$1 = /*#__PURE__*/forwardRef(function Button(props, forwardedRef) {
  const $ = c(23);
  let isDisabled;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      isDisabled,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = otherProps;
    $[3] = children;
  } else {
    isDisabled = $[1];
    otherProps = $[2];
    children = $[3];
  }
  const domRef = useObjectRef(forwardedRef);
  let t0;
  if ($[4] !== props) {
    t0 = {
      elementType: "a",
      ...props
    };
    $[4] = props;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const {
    buttonProps,
    isPressed
  } = useButton(t0, domRef);
  const {
    linkProps
  } = useLink(props, domRef);
  let t1;
  if ($[6] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[6] = isDisabled;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t1);
  let t2;
  if ($[8] !== isHovered || $[9] !== isPressed) {
    t2 = {
      isHovered,
      isPressed
    };
    $[8] = isHovered;
    $[9] = isPressed;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const styleProps = useButtonStyles(props, t2);
  let t3;
  if ($[11] !== otherProps) {
    t3 = filterDOMProps(otherProps);
    $[11] = otherProps;
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  let t4;
  if ($[13] !== buttonProps || $[14] !== linkProps || $[15] !== hoverProps || $[16] !== styleProps) {
    t4 = mergeProps(buttonProps, linkProps, hoverProps, styleProps);
    $[13] = buttonProps;
    $[14] = linkProps;
    $[15] = hoverProps;
    $[16] = styleProps;
    $[17] = t4;
  } else {
    t4 = $[17];
  }
  let t5;
  if ($[18] !== t3 || $[19] !== t4 || $[20] !== domRef || $[21] !== children) {
    t5 = /*#__PURE__*/jsx("a", {
      ...t3,
      ...t4,
      ref: domRef,
      children: children
    });
    $[18] = t3;
    $[19] = t4;
    $[20] = domRef;
    $[21] = children;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  return t5;
});

/** @private Forked variant where an "href" is NOT provided. */
const BaseButton$1 = /*#__PURE__*/forwardRef(function Button(props, forwardedRef) {
  const $ = c(39);
  let t0;
  if ($[0] !== props) {
    t0 = disablePendingProps(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  props = t0;
  let isDisabled;
  let isPending;
  let otherProps;
  let children;
  if ($[2] !== props) {
    ({
      children,
      isDisabled,
      isPending,
      ...otherProps
    } = props);
    $[2] = props;
    $[3] = isDisabled;
    $[4] = isPending;
    $[5] = otherProps;
    $[6] = children;
  } else {
    isDisabled = $[3];
    isPending = $[4];
    otherProps = $[5];
    children = $[6];
  }
  const [isProgressVisible, setIsProgressVisible] = useState(false);
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const domRef = useObjectRef(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = useButton(props, domRef);
  let t1;
  if ($[7] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[7] = isDisabled;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t1);
  let t2;
  if ($[9] !== isHovered || $[10] !== isProgressVisible || $[11] !== isPressed) {
    t2 = {
      isHovered,
      isPending: isProgressVisible,
      isPressed
    };
    $[9] = isHovered;
    $[10] = isProgressVisible;
    $[11] = isPressed;
    $[12] = t2;
  } else {
    t2 = $[12];
  }
  const styleProps = useButtonStyles(props, t2);
  let t3;
  let t4;
  if ($[13] !== isPending) {
    t3 = () => {
      let timeout;
      if (isPending) {
        timeout = setTimeout(() => {
          setIsProgressVisible(true);
        }, 1000);
      } else {
        setIsProgressVisible(false);
      }
      return () => {
        clearTimeout(timeout);
      };
    };
    t4 = [isPending];
    $[13] = isPending;
    $[14] = t3;
    $[15] = t4;
  } else {
    t3 = $[14];
    t4 = $[15];
  }
  useEffect(t3, t4);
  let t5;
  let t6;
  let t7;
  let t8;
  if ($[16] !== isPending || $[17] !== domRef || $[18] !== styleProps || $[19] !== otherProps || $[20] !== buttonProps || $[21] !== hoverProps) {
    const pendingProps = isPending ? {
      onClick: e => e.preventDefault()
    } : {
      onClick: () => {}
    };
    t5 = domRef;
    t6 = styleProps;
    if ($[26] !== otherProps) {
      t7 = filterDOMProps(otherProps, {
        propNames: new Set(["form"])
      });
      $[26] = otherProps;
      $[27] = t7;
    } else {
      t7 = $[27];
    }
    t8 = mergeProps(buttonProps, hoverProps, pendingProps);
    $[16] = isPending;
    $[17] = domRef;
    $[18] = styleProps;
    $[19] = otherProps;
    $[20] = buttonProps;
    $[21] = hoverProps;
    $[22] = t5;
    $[23] = t6;
    $[24] = t7;
    $[25] = t8;
  } else {
    t5 = $[22];
    t6 = $[23];
    t7 = $[24];
    t8 = $[25];
  }
  const t9 = isPending ? "true" : undefined;
  let t10;
  if ($[28] !== isProgressVisible || $[29] !== stringFormatter) {
    t10 = isProgressVisible && /*#__PURE__*/jsx(ProgressCircle, {
      "aria-atomic": "false",
      "aria-live": "assertive",
      "aria-label": stringFormatter.format("pending"),
      isIndeterminate: true,
      size: "small",
      UNSAFE_style: {
        position: "absolute"
      }
    });
    $[28] = isProgressVisible;
    $[29] = stringFormatter;
    $[30] = t10;
  } else {
    t10 = $[30];
  }
  let t11;
  if ($[31] !== t5 || $[32] !== t6 || $[33] !== t7 || $[34] !== t8 || $[35] !== t9 || $[36] !== children || $[37] !== t10) {
    t11 = /*#__PURE__*/jsxs("button", {
      ref: t5,
      ...t6,
      ...t7,
      ...t8,
      "aria-disabled": t9,
      children: [children, t10]
    });
    $[31] = t5;
    $[32] = t6;
    $[33] = t7;
    $[34] = t8;
    $[35] = t9;
    $[36] = children;
    $[37] = t10;
    $[38] = t11;
  } else {
    t11 = $[38];
  }
  return t11;
});

// Utils
// -----------------------------------------------------------------------------

function disablePendingProps(props) {
  // disallow interaction while the button is pending
  if (props.isPending) {
    props = {
      ...props
    };
    props.onKeyDown = undefined;
    props.onKeyUp = undefined;
    props.onPress = undefined;
    props.onPressChange = undefined;
    props.onPressEnd = undefined;
    props.onPressStart = undefined;
    props.onPressUp = undefined;
  }
  return props;
}
const useButtonChildren = props => {
  const $ = c(4);
  const {
    children
  } = props;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      UNSAFE_className: buttonClassList.element("icon")
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = {
      icon: t1,
      text: {
        color: "inherit",
        overflow: "unset",
        trim: false,
        UNSAFE_className: buttonClassList.element("text")
      }
    };
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t0 = t2;
  const slots = t0;
  let t3;
  if ($[2] !== children) {
    t3 = /*#__PURE__*/jsx(SlotProvider, {
      slots: slots,
      children: isReactText(children) ? /*#__PURE__*/jsx(Text, {
        children: children
      }) : children
    });
    $[2] = children;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  return t3;
};

const actionButtonClassList = new ClassList('ActionButton', ['icon', 'text']);
function useActionButtonStyles(props, state) {
  const {
    prominence = 'default'
  } = props;
  const {
    isHovered,
    isPressed
  } = state;
  const isSelected = 'isSelected' in props && props.isSelected || state.isSelected;
  const styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      interaction: isPressed ? 'press' : isHovered ? 'hover' : undefined,
      prominence: prominence === 'default' ? undefined : prominence,
      selected: isSelected || undefined,
      static: props.static
    }),
    style: styleProps.style,
    className: classNames(actionButtonClassList.element('root'), css({
      alignItems: 'center',
      borderColor: 'transparent',
      borderRadius: tokenSchema.size.radius.regular,
      borderStyle: 'solid',
      borderWidth: tokenSchema.size.border.regular,
      cursor: 'default',
      display: 'inline-flex',
      flexShrink: 0,
      fontWeight: tokenSchema.typography.fontWeight.regular,
      height: tokenSchema.size.element.regular,
      justifyContent: 'center',
      minWidth: tokenSchema.size.element.regular,
      outline: 0,
      paddingInline: tokenSchema.size.space.regular,
      position: 'relative',
      transitionDuration: '130ms',
      transitionProperty: 'background, border-color, box-shadow, color',
      transitionTimingFunction: 'ease-out',
      userSelect: 'none',
      // indicate when external link? e.g. `&[href^=http]`
      'a&': {
        cursor: 'pointer'
      },
      // CONTENTS
      [actionButtonClassList.selector('text', 'descendant')]: {
        fontWeight: 'inherit',
        marginInline: tokenSchema.size.space.small,
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
      },
      // FOCUS RING
      '--focus-ring-color': tokenSchema.color.alias.focusRing,
      '&[data-static]': {
        '--focus-ring-color': 'currentColor'
      },
      '&::after': {
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        pointerEvents: 'none',
        position: 'absolute',
        transition: transition(['box-shadow', 'margin'], {
          easing: 'easeOut'
        })
      },
      '&[data-focus=visible]::after': {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`
      },
      // PROMINENCE

      // prominence: default
      '&:not([data-prominence])': {
        backgroundColor: tokenSchema.color.alias.backgroundIdle,
        borderColor: tokenSchema.color.alias.borderIdle,
        color: tokenSchema.color.alias.foregroundIdle,
        // interactions
        '&[data-interaction=hover]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          borderColor: tokenSchema.color.alias.borderHovered,
          // boxShadow: `${tokenSchema.size.shadow.small} ${tokenSchema.color.shadow.regular}`,
          color: tokenSchema.color.alias.foregroundHovered
        },
        '&[data-interaction=press]': {
          backgroundColor: tokenSchema.color.alias.backgroundPressed,
          borderColor: tokenSchema.color.alias.borderPressed,
          color: tokenSchema.color.alias.foregroundPressed
        },
        // states
        '&[data-selected]': {
          backgroundColor: tokenSchema.color.foreground.neutralSecondary,
          borderColor: tokenSchema.color.foreground.neutralSecondary,
          color: tokenSchema.color.foreground.inverse,
          '&[data-interaction=hover]': {
            backgroundColor: tokenSchema.color.foreground.neutral,
            borderColor: tokenSchema.color.foreground.neutral
          },
          '&[data-interaction=press]': {
            backgroundColor: tokenSchema.color.foreground.neutralEmphasis,
            borderColor: tokenSchema.color.foreground.neutralEmphasis
          }
        },
        '&:disabled, &[aria-disabled=true], &[data-disabled=true]': {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          borderColor: 'transparent',
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        '&[data-static]': {
          backgroundColor: 'transparent'
        },
        '&[data-static=light]': {
          borderColor: '#fff6',
          color: '#fff',
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: '#ffffff1a',
            borderColor: '#ffffff8c'
          },
          '&[data-interaction=press]': {
            backgroundColor: '#ffffff26',
            borderColor: '#ffffffb3'
          },
          '&:disabled, &[aria-disabled]': {
            borderColor: '#ffffff40',
            color: '#ffffff8c'
          }
        },
        '&[data-static=dark]': {
          borderColor: '#0006',
          color: '#000',
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: '#0000001a',
            borderColor: '#0000008c'
          },
          '&[data-interaction=press]': {
            backgroundColor: '#00000026',
            borderColor: '#000000b3'
          },
          '&:disabled, &[aria-disabled]': {
            borderColor: '#00000040',
            color: '#0000008c'
          }
        }
      },
      // prominence: low
      '&[data-prominence=low]': {
        color: tokenSchema.color.foreground.neutral,
        // interactions
        '&[data-interaction=hover]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.alias.foregroundHovered
        },
        '&[data-interaction=press]': {
          backgroundColor: tokenSchema.color.alias.backgroundPressed,
          color: tokenSchema.color.alias.foregroundPressed
        },
        // states
        '&[data-selected]': {
          backgroundColor: tokenSchema.color.foreground.neutralSecondary,
          borderColor: tokenSchema.color.foreground.neutralSecondary,
          color: tokenSchema.color.foreground.inverse,
          '&[data-interaction=hover]': {
            backgroundColor: tokenSchema.color.foreground.neutral,
            borderColor: tokenSchema.color.foreground.neutral
          },
          '&[data-interaction=press]': {
            backgroundColor: tokenSchema.color.foreground.neutralEmphasis,
            borderColor: tokenSchema.color.foreground.neutralEmphasis
          }
        },
        '&:disabled, &[aria-disabled=true], &[data-disabled=true]': {
          borderColor: 'transparent',
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        '&[data-static=light]': {
          color: '#fff',
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: '#ffffff1a'
          },
          '&[data-interaction=press]': {
            backgroundColor: '#ffffff26'
          },
          '&:disabled, &[aria-disabled]': {
            color: '#ffffff8c'
          }
        },
        '&[data-static=dark]': {
          color: '#000',
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: '#0000001a'
          },
          '&[data-interaction=press]': {
            backgroundColor: '#00000026'
          },
          '&:disabled, &[aria-disabled]': {
            color: '#0000008c'
          }
        }
      }
    }), styleProps.className)
  };
}

/**
 * Action buttons allow users to perform an action. They’re used for similar,
 * task-based options within a workflow, and are ideal for interfaces where
 * buttons aren’t meant to draw a lot of attention.
 */
const ActionButton = /*#__PURE__*/forwardRef(function ActionButton(props, forwardedRef) {
  const $ = c(14);
  const domRef = useObjectRef(forwardedRef);
  const children = useActionButtonChildren(props);
  if ("href" in props && props.href) {
    const t0 = domRef;
    let t1;
    if ($[0] !== t0 || $[1] !== props || $[2] !== children) {
      t1 = /*#__PURE__*/jsx(LinkButton, {
        ref: t0,
        ...props,
        children: children
      });
      $[0] = t0;
      $[1] = props;
      $[2] = children;
      $[3] = t1;
    } else {
      t1 = $[3];
    }
    let t2;
    if ($[4] !== props.autoFocus || $[5] !== t1) {
      t2 = /*#__PURE__*/jsx(FocusRing, {
        autoFocus: props.autoFocus,
        children: t1
      });
      $[4] = props.autoFocus;
      $[5] = t1;
      $[6] = t2;
    } else {
      t2 = $[6];
    }
    return t2;
  }
  const t0 = domRef;
  let t1;
  if ($[7] !== t0 || $[8] !== props || $[9] !== children) {
    t1 = /*#__PURE__*/jsx(BaseButton, {
      ref: t0,
      ...props,
      children: children
    });
    $[7] = t0;
    $[8] = props;
    $[9] = children;
    $[10] = t1;
  } else {
    t1 = $[10];
  }
  let t2;
  if ($[11] !== props.autoFocus || $[12] !== t1) {
    t2 = /*#__PURE__*/jsx(FocusRing, {
      autoFocus: props.autoFocus,
      children: t1
    });
    $[11] = props.autoFocus;
    $[12] = t1;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  return t2;
});

// Variants
// -----------------------------------------------------------------------------

/** @private Forked variant where an "href" is provided. */
const LinkButton = /*#__PURE__*/forwardRef(function LinkActionButton(props, forwardedRef) {
  const $ = c(23);
  let isDisabled;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      isDisabled,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = otherProps;
    $[3] = children;
  } else {
    isDisabled = $[1];
    otherProps = $[2];
    children = $[3];
  }
  const domRef = useObjectRef(forwardedRef);
  let t0;
  if ($[4] !== props) {
    t0 = {
      elementType: "a",
      ...props
    };
    $[4] = props;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const {
    buttonProps,
    isPressed
  } = useButton(t0, domRef);
  const {
    linkProps
  } = useLink(props, domRef);
  let t1;
  if ($[6] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[6] = isDisabled;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t1);
  let t2;
  if ($[8] !== isHovered || $[9] !== isPressed) {
    t2 = {
      isHovered,
      isPressed
    };
    $[8] = isHovered;
    $[9] = isPressed;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const styleProps = useActionButtonStyles(props, t2);
  let t3;
  if ($[11] !== otherProps) {
    t3 = filterDOMProps(otherProps);
    $[11] = otherProps;
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  let t4;
  if ($[13] !== buttonProps || $[14] !== linkProps || $[15] !== hoverProps || $[16] !== styleProps) {
    t4 = mergeProps(buttonProps, linkProps, hoverProps, styleProps);
    $[13] = buttonProps;
    $[14] = linkProps;
    $[15] = hoverProps;
    $[16] = styleProps;
    $[17] = t4;
  } else {
    t4 = $[17];
  }
  let t5;
  if ($[18] !== t3 || $[19] !== t4 || $[20] !== domRef || $[21] !== children) {
    t5 = /*#__PURE__*/jsx("a", {
      ...t3,
      ...t4,
      ref: domRef,
      children: children
    });
    $[18] = t3;
    $[19] = t4;
    $[20] = domRef;
    $[21] = children;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  return t5;
});

/** @private Forked variant where an "href" is NOT provided. */
const BaseButton = /*#__PURE__*/forwardRef(function BaseActionButton(props, forwardedRef) {
  const $ = c(20);
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  let isDisabled;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      isDisabled,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = otherProps;
    $[3] = children;
  } else {
    isDisabled = $[1];
    otherProps = $[2];
    children = $[3];
  }
  const domRef = useObjectRef(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = useButton(props, domRef);
  let t0;
  if ($[4] !== isDisabled) {
    t0 = {
      isDisabled
    };
    $[4] = isDisabled;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t0);
  let t1;
  if ($[6] !== isHovered || $[7] !== isPressed) {
    t1 = {
      isHovered,
      isPressed
    };
    $[6] = isHovered;
    $[7] = isPressed;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const styleProps = useActionButtonStyles(props, t1);
  let t2;
  if ($[9] !== otherProps) {
    t2 = filterDOMProps(otherProps, {
      propNames: new Set(["form"])
    });
    $[9] = otherProps;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  let t3;
  if ($[11] !== buttonProps || $[12] !== hoverProps) {
    t3 = mergeProps(buttonProps, hoverProps);
    $[11] = buttonProps;
    $[12] = hoverProps;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  let t4;
  if ($[14] !== domRef || $[15] !== styleProps || $[16] !== t2 || $[17] !== t3 || $[18] !== children) {
    t4 = /*#__PURE__*/jsx("button", {
      ref: domRef,
      ...styleProps,
      ...t2,
      ...t3,
      children: children
    });
    $[14] = domRef;
    $[15] = styleProps;
    $[16] = t2;
    $[17] = t3;
    $[18] = children;
    $[19] = t4;
  } else {
    t4 = $[19];
  }
  return t4;
});

// Utils
// -----------------------------------------------------------------------------

let iconClassName = actionButtonClassList.element('icon');
let textClassName = actionButtonClassList.element('text');
const useActionButtonChildren = (props, alternateSlots) => {
  const $ = c(13);
  const {
    children
  } = props;
  let t0;
  const t1 = alternateSlots === null || alternateSlots === void 0 ? void 0 : alternateSlots.icon;
  let t2;
  if ($[0] !== t1) {
    t2 = {
      UNSAFE_className: iconClassName,
      ...t1
    };
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const t3 = alternateSlots === null || alternateSlots === void 0 ? void 0 : alternateSlots.text;
  let t4;
  if ($[2] !== t3) {
    t4 = {
      color: "inherit",
      overflow: "unset",
      trim: false,
      UNSAFE_className: textClassName,
      ...t3
    };
    $[2] = t3;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] !== alternateSlots || $[5] !== t2 || $[6] !== t4) {
    t5 = {
      ...alternateSlots,
      icon: t2,
      text: t4
    };
    $[4] = alternateSlots;
    $[5] = t2;
    $[6] = t4;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  t0 = t5;
  const slots = t0;
  let t6;
  if ($[8] !== children) {
    t6 = isReactText(children) ? /*#__PURE__*/jsx(Text, {
      children: children
    }) : children;
    $[8] = children;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== slots || $[11] !== t6) {
    t7 = /*#__PURE__*/jsx(SlotProvider, {
      slots: slots,
      children: t6
    });
    $[10] = slots;
    $[11] = t6;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  return t7;
};

/**
 * A clear button is a button that is typically found on search fields and is
 * used to clear the current search query. This can be useful if the user has
 * entered a search query by mistake, or if they want to start over with a new
 * search.
 */
const ClearButton = /*#__PURE__*/forwardRef(function ClearButton(props, forwardedRef) {
  const $ = c(28);
  let t0;
  let preventFocus;
  let isDisabled;
  let otherProps;
  let autoFocus;
  if ($[0] !== props) {
    ({
      autoFocus,
      isDisabled,
      preventFocus,
      elementType: t0,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = preventFocus;
    $[3] = isDisabled;
    $[4] = otherProps;
    $[5] = autoFocus;
  } else {
    t0 = $[1];
    preventFocus = $[2];
    isDisabled = $[3];
    otherProps = $[4];
    autoFocus = $[5];
  }
  const elementType = t0 === undefined ? preventFocus ? "div" : "button" : t0;
  const domRef = useObjectRef(forwardedRef);
  let t1;
  if ($[6] !== props || $[7] !== elementType) {
    t1 = {
      ...props,
      elementType
    };
    $[6] = props;
    $[7] = elementType;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  let {
    buttonProps,
    isPressed
  } = useButton(t1, domRef);
  let t2;
  if ($[9] !== isDisabled) {
    t2 = {
      isDisabled
    };
    $[9] = isDisabled;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t2);
  let t3;
  if ($[11] !== isHovered || $[12] !== isPressed) {
    t3 = {
      isHovered,
      isPressed
    };
    $[11] = isHovered;
    $[12] = isPressed;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  const styleProps = useClearButtonStyles(otherProps, t3);
  if (preventFocus) {
    let _buttonProps;
    if ($[14] !== buttonProps) {
      const {
        tabIndex,
        ...t4
      } = buttonProps;
      _buttonProps = t4;
      $[14] = buttonProps;
      $[15] = _buttonProps;
    } else {
      _buttonProps = $[15];
    }
    buttonProps = _buttonProps;
  }
  const ElementType = elementType;
  let t4;
  if ($[16] !== buttonProps || $[17] !== hoverProps) {
    t4 = mergeProps(buttonProps, hoverProps);
    $[16] = buttonProps;
    $[17] = hoverProps;
    $[18] = t4;
  } else {
    t4 = $[18];
  }
  let t5;
  if ($[19] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /*#__PURE__*/jsx(Icon, {
      src: xIcon
    });
    $[19] = t5;
  } else {
    t5 = $[19];
  }
  let t6;
  if ($[20] !== ElementType || $[21] !== styleProps || $[22] !== t4 || $[23] !== domRef) {
    t6 = /*#__PURE__*/jsx(ElementType, {
      ...styleProps,
      ...t4,
      ref: domRef,
      children: t5
    });
    $[20] = ElementType;
    $[21] = styleProps;
    $[22] = t4;
    $[23] = domRef;
    $[24] = t6;
  } else {
    t6 = $[24];
  }
  let t7;
  if ($[25] !== autoFocus || $[26] !== t6) {
    t7 = /*#__PURE__*/jsx(FocusRing, {
      autoFocus: autoFocus,
      children: t6
    });
    $[25] = autoFocus;
    $[26] = t6;
    $[27] = t7;
  } else {
    t7 = $[27];
  }
  return t7;
});
function useClearButtonStyles(props, state) {
  const $ = c(14);
  const {
    isPressed,
    isHovered
  } = state;
  const styleProps = useStyleProps(props);
  let t0;
  let t1;
  let t2;
  if ($[0] !== styleProps || $[1] !== isPressed || $[2] !== isHovered || $[3] !== props.static) {
    const clearButtonStyles = css({
      alignItems: "center",
      borderRadius: "100%",
      color: tokenSchema.color.foreground.neutralSecondary,
      display: "flex",
      height: tokenSchema.size.element.regular,
      justifyContent: "center",
      outline: 0,
      position: "relative",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      }),
      width: tokenSchema.size.element.regular,
      "--focus-ring-color": tokenSchema.color.alias.focusRing,
      "&[data-static]": {
        "--focus-ring-color": "currentColor"
      },
      "&::after": {
        borderRadius: `inherit`,
        content: "\"\"",
        inset: 0,
        pointerEvents: "none",
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      "&[data-focus=visible]::after": {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`,
        margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`
      },
      "&[data-interaction=hover]": {
        color: tokenSchema.color.foreground.neutral
      },
      "&[data-interaction=press]": {
        color: tokenSchema.color.foreground.neutralEmphasis
      },
      "&:disabled, &[aria-disabled]": {
        color: tokenSchema.color.alias.foregroundDisabled
      },
      "&[data-static=light]": {
        color: "#fff",
        "&[data-interaction=hover], &[data-focus=\"visible\"]": {
          backgroundColor: "#ffffff1a"
        },
        "&[data-interaction=press]": {
          backgroundColor: "#ffffff26"
        },
        "&:disabled, &[aria-disabled]": {
          backgroundColor: "#ffffff1a",
          color: "#ffffff8c"
        }
      },
      "&[data-static=dark]": {
        color: "#000",
        "&[data-interaction=hover], &[data-focus=\"visible\"]": {
          backgroundColor: "#0000001a"
        },
        "&[data-interaction=press]": {
          backgroundColor: "#00000026"
        },
        "&:disabled, &[aria-disabled]": {
          backgroundColor: "#0000001a",
          color: "#0000008c"
        }
      }
    });
    t0 = styleProps;
    const t3 = isPressed ? "press" : isHovered ? "hover" : undefined;
    if ($[7] !== props.static || $[8] !== t3) {
      t1 = toDataAttributes({
        static: props.static,
        interaction: t3
      });
      $[7] = props.static;
      $[8] = t3;
      $[9] = t1;
    } else {
      t1 = $[9];
    }
    t2 = classNames(clearButtonStyles, styleProps.className);
    $[0] = styleProps;
    $[1] = isPressed;
    $[2] = isHovered;
    $[3] = props.static;
    $[4] = t0;
    $[5] = t1;
    $[6] = t2;
  } else {
    t0 = $[4];
    t1 = $[5];
    t2 = $[6];
  }
  let t3;
  if ($[10] !== t0 || $[11] !== t1 || $[12] !== t2) {
    t3 = {
      ...t0,
      ...t1,
      className: t2
    };
    $[10] = t0;
    $[11] = t1;
    $[12] = t2;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  return t3;
}

const FieldButton = /*#__PURE__*/forwardRef(function FieldButton(props, forwardedRef) {
  const $ = c(23);
  props = useSlotProps(props, "button");
  const {
    elementType: t0,
    isDisabled,
    autoFocus,
    isActive
  } = props;
  const ElementType = t0 === undefined ? "button" : t0;
  const domRef = useObjectRef(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = useButton(props, domRef);
  let t1;
  if ($[0] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[0] = isDisabled;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t1);
  const t2 = isActive !== null && isActive !== void 0 ? isActive : isPressed;
  let t3;
  if ($[2] !== isHovered || $[3] !== t2) {
    t3 = {
      isHovered,
      isPressed: t2
    };
    $[2] = isHovered;
    $[3] = t2;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  const {
    children,
    styleProps
  } = useFieldButton(props, t3);
  let t4;
  if ($[5] !== buttonProps || $[6] !== hoverProps) {
    t4 = mergeProps(buttonProps, hoverProps);
    $[5] = buttonProps;
    $[6] = hoverProps;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== styleProps.className) {
    t5 = classNames(css({
      justifyContent: "space-between",
      textAlign: "start"
    }), styleProps.className);
    $[8] = styleProps.className;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== styleProps.style) {
    t6 = {
      ...styleProps.style,
      boxShadow: "none"
    };
    $[10] = styleProps.style;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== ElementType || $[13] !== styleProps || $[14] !== t4 || $[15] !== domRef || $[16] !== t5 || $[17] !== t6 || $[18] !== children) {
    t7 = /*#__PURE__*/jsx(ElementType, {
      ...styleProps,
      ...t4,
      ref: domRef,
      className: t5,
      style: t6,
      children: children
    });
    $[12] = ElementType;
    $[13] = styleProps;
    $[14] = t4;
    $[15] = domRef;
    $[16] = t5;
    $[17] = t6;
    $[18] = children;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  let t8;
  if ($[20] !== autoFocus || $[21] !== t7) {
    t8 = /*#__PURE__*/jsx(FocusRing, {
      autoFocus: autoFocus,
      children: t7
    });
    $[20] = autoFocus;
    $[21] = t7;
    $[22] = t8;
  } else {
    t8 = $[22];
  }
  return t8;
});

// Utils
// -----------------------------------------------------------------------------

function useFieldButton(props, state) {
  const $ = c(7);
  const {
    isHovered,
    isPressed
  } = state;
  let t0;
  if ($[0] !== isHovered || $[1] !== isPressed) {
    t0 = {
      isHovered,
      isPressed
    };
    $[0] = isHovered;
    $[1] = isPressed;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const styleProps = useActionButtonStyles(props, t0);
  let t1;
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = {
      text: {
        flex: true
      }
    };
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  t1 = t2;
  const slots = t1;
  const children = useActionButtonChildren(props, slots);
  let t3;
  if ($[4] !== children || $[5] !== styleProps) {
    t3 = {
      children,
      styleProps
    };
    $[4] = children;
    $[5] = styleProps;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  return t3;
}

const ToggleButton = /*#__PURE__*/forwardRef(function ToggleButton(props, forwardedRef) {
  const $ = c(23);
  let isDisabled;
  let otherProps;
  if ($[0] !== props) {
    ({
      isDisabled,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = otherProps;
  } else {
    isDisabled = $[1];
    otherProps = $[2];
  }
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const children = useActionButtonChildren(props);
  const domRef = useObjectRef(forwardedRef);
  const state = useToggleState(props);
  const {
    buttonProps,
    isPressed
  } = useToggleButton(props, state, domRef);
  let t0;
  if ($[3] !== isDisabled) {
    t0 = {
      isDisabled
    };
    $[3] = isDisabled;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t0);
  let t1;
  if ($[5] !== isHovered || $[6] !== isPressed || $[7] !== state.isSelected) {
    t1 = {
      isHovered,
      isPressed,
      isSelected: state.isSelected
    };
    $[5] = isHovered;
    $[6] = isPressed;
    $[7] = state.isSelected;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const styleProps = useActionButtonStyles(props, t1);
  let t2;
  if ($[9] !== buttonProps || $[10] !== hoverProps) {
    t2 = mergeProps(buttonProps, hoverProps);
    $[9] = buttonProps;
    $[10] = hoverProps;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  let t3;
  if ($[12] !== otherProps) {
    t3 = filterDOMProps(otherProps);
    $[12] = otherProps;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  let t4;
  if ($[14] !== domRef || $[15] !== styleProps || $[16] !== t2 || $[17] !== t3 || $[18] !== children) {
    t4 = /*#__PURE__*/jsx("button", {
      ref: domRef,
      ...styleProps,
      ...t2,
      ...t3,
      children: children
    });
    $[14] = domRef;
    $[15] = styleProps;
    $[16] = t2;
    $[17] = t3;
    $[18] = children;
    $[19] = t4;
  } else {
    t4 = $[19];
  }
  let t5;
  if ($[20] !== props.autoFocus || $[21] !== t4) {
    t5 = /*#__PURE__*/jsx(FocusRing, {
      autoFocus: props.autoFocus,
      children: t4
    });
    $[20] = props.autoFocus;
    $[21] = t4;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  return t5;
});

export { ActionButton, Button, ButtonGroup, ClearButton, FieldButton, ToggleButton, actionButtonClassList, buttonClassList, useFieldButton };
