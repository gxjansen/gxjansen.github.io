'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { mergeProps, filterDOMProps } from '@react-aria/utils';
import React, { useContext } from 'react';
import { jsx } from 'react/jsx-runtime';
import { useStyleProps } from '@keystar/ui/style';
import { forwardRefWithAs } from '@keystar/ui/utils/ts';

let SlotContext = /*#__PURE__*/React.createContext({});

/**
 * Merge component props with ancestral slot props. With the exception of "id",
 * consumer props are overriden by slot props, while event handlers will be
 * chained so all are called.
 */
function useSlotProps(props, defaultSlot) {
  let slot = props.slot || defaultSlot;
  let {
    [slot]: slotProps = {}
  } = useContext(SlotContext);
  return mergeProps(props, mergeProps(slotProps, {
    id: props.id
  }));
}

/**
 * Not really "slots" like web components, more like "prop portalling" or
 * something. Default and override the props of descendent components.
 *
 * @example
 * <SlotProvider slots={{ text: { size: 'small' } }}>
 *   {children}
 * </SlotProvider>
 */
const SlotProvider = props => {
  const $ = c(6);
  const {
    children,
    slots
  } = props;
  const parentSlots = useContext(SlotContext);
  let t0;
  let t1;
  if ($[0] !== parentSlots || $[1] !== slots) {
    t1 = Object.keys(parentSlots).concat(Object.keys(slots)).reduce((obj, key) => ({
      ...obj,
      [key]: mergeProps(parentSlots[key], slots[key])
    }), {});
    $[0] = parentSlots;
    $[1] = slots;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  t0 = t1;
  const value = t0;
  let t2;
  if ($[3] !== value || $[4] !== children) {
    t2 = /*#__PURE__*/jsx(SlotContext.Provider, {
      value: value,
      children: children
    });
    $[3] = value;
    $[4] = children;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
};

// MAYBE: "preserve" some props?
// e.g. <ClearSlots preserve={{ slotName: true }} />
const ClearSlots = t0 => {
  const $ = c(3);
  const {
    children
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {};
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== children) {
    t2 = /*#__PURE__*/jsx(SlotContext.Provider, {
      value: t1,
      children: children
    });
    $[1] = children;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
};

/** A block of content within a container. */
const Content = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, 'content');
  let {
    elementType: Element = 'section',
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return /*#__PURE__*/jsx(Element, {
    ...filterDOMProps(otherProps),
    ...styleProps,
    ref: ref,
    children: /*#__PURE__*/jsx(ClearSlots, {
      children: children
    })
  });
});

/** A footer within a container. */
const Footer = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, 'footer');
  let {
    elementType: Element = 'footer',
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return /*#__PURE__*/jsx(Element, {
    ...filterDOMProps(otherProps),
    ...styleProps,
    ref: ref,
    children: children
  });
});

/** A header within a container. */
const Header = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, 'header');
  let {
    elementType: Element = 'header',
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return /*#__PURE__*/jsx(Element, {
    ...filterDOMProps(otherProps),
    ...styleProps,
    ref: ref,
    children: children
  });
});

export { ClearSlots, Content, Footer, Header, SlotProvider, useSlotProps };
