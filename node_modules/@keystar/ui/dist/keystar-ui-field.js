'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useField } from '@react-aria/label';
import { Flex } from '@keystar/ui/layout';
import { css, tokenSchema, useStyleProps } from '@keystar/ui/style';
import { useTextStyles, Text } from '@keystar/ui/typography';
import { forwardRef, useId } from 'react';
import { useLocalizedStringFormatter } from '@react-aria/i18n';
import { forwardRefWithAs } from '@keystar/ui/utils/ts';
import { jsxs, jsx } from 'react/jsx-runtime';
import { alertTriangleIcon } from '@keystar/ui/icon/icons/alertTriangleIcon';
import { Icon } from '@keystar/ui/icon';
import { SlotProvider } from './keystar-ui-slots.js';

const localizedMessages = {
  "ar-AE": {
    "(optional)": `(اختياري)`,
    "(required)": `(مطلوب)`
  },
  "bg-BG": {
    "(optional)": `(незадължително)`,
    "(required)": `(задължително)`
  },
  "cs-CZ": {
    "(optional)": `(volitelně)`,
    "(required)": `(požadováno)`
  },
  "da-DK": {
    "(optional)": `(valgfrit)`,
    "(required)": `(obligatorisk)`
  },
  "de-DE": {
    "(optional)": `(optional)`,
    "(required)": `(erforderlich)`
  },
  "el-GR": {
    "(optional)": `(προαιρετικό)`,
    "(required)": `(απαιτείται)`
  },
  "en-US": {
    "(optional)": `(optional)`,
    "(required)": `(required)`
  },
  "es-ES": {
    "(optional)": `(opcional)`,
    "(required)": `(necesario)`
  },
  "et-EE": {
    "(optional)": `(valikuline)`,
    "(required)": `(nõutav)`
  },
  "fi-FI": {
    "(optional)": `(valinnainen)`,
    "(required)": `(pakollinen)`
  },
  "fr-FR": {
    "(optional)": `(facultatif)`,
    "(required)": `(requis)`
  },
  "he-IL": {
    "(optional)": `(אופציונלי)`,
    "(required)": `(נדרש)`
  },
  "hr-HR": {
    "(optional)": `(opcionalno)`,
    "(required)": `(obvezno)`
  },
  "hu-HU": {
    "(optional)": `(opcionális)`,
    "(required)": `(kötelező)`
  },
  "it-IT": {
    "(optional)": `(facoltativo)`,
    "(required)": `(obbligatorio)`
  },
  "ja-JP": {
    "(optional)": `（オプション）`,
    "(required)": `（必須）`
  },
  "ko-KR": {
    "(optional)": `(선택 사항)`,
    "(required)": `(필수 사항)`
  },
  "lt-LT": {
    "(optional)": `(pasirenkama)`,
    "(required)": `(privaloma)`
  },
  "lv-LV": {
    "(optional)": `(neobligāti)`,
    "(required)": `(obligāti)`
  },
  "nb-NO": {
    "(optional)": `(valgfritt)`,
    "(required)": `(obligatorisk)`
  },
  "nl-NL": {
    "(optional)": `(optioneel)`,
    "(required)": `(vereist)`
  },
  "pl-PL": {
    "(optional)": `(opcjonalne)`,
    "(required)": `(wymagane)`
  },
  "pt-BR": {
    "(optional)": `(opcional)`,
    "(required)": `(obrigatório)`
  },
  "pt-PT": {
    "(optional)": `(opcional)`,
    "(required)": `(obrigatório)`
  },
  "ro-RO": {
    "(optional)": `(opţional)`,
    "(required)": `(obligatoriu)`
  },
  "ru-RU": {
    "(optional)": `(дополнительно)`,
    "(required)": `(обязательно)`
  },
  "sk-SK": {
    "(optional)": `(nepovinné)`,
    "(required)": `(povinné)`
  },
  "sl-SI": {
    "(optional)": `(opcijsko)`,
    "(required)": `(obvezno)`
  },
  "sr-SP": {
    "(optional)": `(opciono)`,
    "(required)": `(obavezno)`
  },
  "sv-SE": {
    "(optional)": `(valfritt)`,
    "(required)": `(krävs)`
  },
  "tr-TR": {
    "(optional)": `(isteğe bağlı)`,
    "(required)": `(gerekli)`
  },
  "uk-UA": {
    "(optional)": `(необов’язково)`,
    "(required)": `(обов’язково)`
  },
  "zh-CN": {
    "(optional)": `（可选）`,
    "(required)": `（必填）`
  },
  "zh-TW": {
    "(optional)": `(選填)`,
    "(required)": `(必填)`
  }
};

const FieldLabel = forwardRefWithAs(function FieldLabel({
  children,
  elementType: ElementType = 'label',
  isRequired,
  supplementRequiredState,
  ...labelProps
}, forwardedRef) {
  const styleProps = useTextStyles({
    color: 'neutral',
    size: 'regular',
    trim: true,
    weight: 'medium',
    UNSAFE_className: css({
      cursor: 'default'
    })
  });
  return /*#__PURE__*/jsxs(ElementType, {
    ref: forwardedRef,
    ...labelProps,
    ...styleProps,
    children: [children, isRequired && /*#__PURE__*/jsx(Asterisk, {
      supplementRequiredState: supplementRequiredState
    })]
  });
});

/**
 * Display a required indicator for monitor users.
 *
 * In cases that don't include a semantic element for user input, describe the
 * required state for users of assistive technology.
 */
// NOTE: ideally this would be handled with the `aria-required` attribute, but
// that's not appropriate on buttons:
// > The attribute "aria-required" is not supported by the role button.
//
// It could go on the listbox, but the current implementation doesn't render the
// listbox until the dialog is open...
function Asterisk(t0) {
  const $ = c(6);
  const {
    supplementRequiredState
  } = t0;
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let t1;
  if ($[0] !== supplementRequiredState || $[1] !== stringFormatter) {
    t1 = supplementRequiredState ? stringFormatter.format("(required)") : undefined;
    $[0] = supplementRequiredState;
    $[1] = stringFormatter;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /*#__PURE__*/jsx("span", {
      "aria-hidden": true,
      className: css({
        color: tokenSchema.color.foreground.critical,
        fontSize: tokenSchema.typography.text.large.size,
        lineHeight: 1,
        paddingInlineStart: "0.125em"
      }),
      children: "*"
    });
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t1) {
    t3 = /*#__PURE__*/jsx("span", {
      "aria-label": t1,
      children: t2
    });
    $[4] = t1;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
}

const FieldMessage = props => {
  const $ = c(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      marginTop: "calc(var(--icon-offset) * -1)"
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      "--icon-offset": `calc(${tokenSchema.size.icon.regular} - ${tokenSchema.typography.text.small.size})`
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /*#__PURE__*/jsx(Icon, {
      src: alertTriangleIcon,
      color: "critical"
    });
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = css({
      paddingTop: "var(--icon-offset)"
    });
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== props) {
    t4 = /*#__PURE__*/jsxs(Flex, {
      gap: "regular",
      UNSAFE_className: t0,
      UNSAFE_style: t1,
      children: [t2, /*#__PURE__*/jsx(Text, {
        color: "critical",
        size: "small",
        UNSAFE_className: t3,
        ...props
      })]
    });
    $[4] = props;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  return t4;
};

const FieldPrimitive = /*#__PURE__*/forwardRef(function FieldPrimitive(props, forwardedRef) {
  const $ = c(30);
  const {
    children,
    contextualHelp,
    isRequired,
    label,
    labelElementType,
    labelProps,
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    supplementRequiredState
  } = props;
  const styleProps = useStyleProps(props);
  const contextualHelpId = useId();
  labelProps === null || labelProps === void 0 || labelProps.id;
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = css({
      marginBottom: tokenSchema.typography.text.regular.capheightTrim,
      marginTop: tokenSchema.typography.text.regular.baselineTrim
    });
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const t2 = labelProps !== null && labelProps !== void 0 && labelProps.id ? `${labelProps.id} ${contextualHelpId}` : undefined;
  let t3;
  if ($[1] !== contextualHelpId || $[2] !== t2) {
    t3 = {
      button: {
        UNSAFE_className: t1,
        id: contextualHelpId,
        "aria-labelledby": t2
      }
    };
    $[1] = contextualHelpId;
    $[2] = t2;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  t0 = t3;
  const contextualHelpSlots = t0;
  let t4;
  bb0: {
    if (!label) {
      t4 = null;
      break bb0;
    }
    let t5;
    if ($[4] !== labelElementType || $[5] !== isRequired || $[6] !== supplementRequiredState || $[7] !== labelProps || $[8] !== label) {
      t5 = /*#__PURE__*/jsx(FieldLabel, {
        elementType: labelElementType,
        isRequired: isRequired,
        supplementRequiredState: supplementRequiredState,
        ...labelProps,
        children: label
      });
      $[4] = labelElementType;
      $[5] = isRequired;
      $[6] = supplementRequiredState;
      $[7] = labelProps;
      $[8] = label;
      $[9] = t5;
    } else {
      t5 = $[9];
    }
    const labelUI = t5;
    if (contextualHelp) {
      let t6;
      if ($[10] !== contextualHelpSlots || $[11] !== contextualHelp) {
        t6 = /*#__PURE__*/jsx(SlotProvider, {
          slots: contextualHelpSlots,
          children: contextualHelp
        });
        $[10] = contextualHelpSlots;
        $[11] = contextualHelp;
        $[12] = t6;
      } else {
        t6 = $[12];
      }
      let t7;
      if ($[13] !== labelUI || $[14] !== t6) {
        t7 = /*#__PURE__*/jsxs(Flex, {
          gap: "small",
          alignItems: "center",
          children: [labelUI, t6]
        });
        $[13] = labelUI;
        $[14] = t6;
        $[15] = t7;
      } else {
        t7 = $[15];
      }
      t4 = t7;
      break bb0;
    }
    t4 = labelUI;
  }
  let t5;
  if ($[16] !== description || $[17] !== descriptionProps) {
    t5 = description && /*#__PURE__*/jsx(Text, {
      ...descriptionProps,
      size: "small",
      color: "neutralSecondary",
      children: description
    });
    $[16] = description;
    $[17] = descriptionProps;
    $[18] = t5;
  } else {
    t5 = $[18];
  }
  let t6;
  if ($[19] !== errorMessage || $[20] !== errorMessageProps) {
    t6 = errorMessage && /*#__PURE__*/jsx(FieldMessage, {
      ...errorMessageProps,
      children: errorMessage
    });
    $[19] = errorMessage;
    $[20] = errorMessageProps;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  let t7;
  if ($[22] !== forwardedRef || $[23] !== styleProps.className || $[24] !== styleProps.style || $[25] !== t4 || $[26] !== t5 || $[27] !== children || $[28] !== t6) {
    t7 = /*#__PURE__*/jsxs(Flex, {
      ref: forwardedRef,
      direction: "column",
      gap: "medium",
      minWidth: 0,
      UNSAFE_className: styleProps.className,
      UNSAFE_style: styleProps.style,
      children: [t4, t5, children, t6]
    });
    $[22] = forwardedRef;
    $[23] = styleProps.className;
    $[24] = styleProps.style;
    $[25] = t4;
    $[26] = t5;
    $[27] = children;
    $[28] = t6;
    $[29] = t7;
  } else {
    t7 = $[29];
  }
  return t7;
});

/**
 * Provides the accessibility implementation for input fields. Fields accept
 * user input, gain context from their label, and may display a description or
 * error message.
 */
const Field = props => {
  const $ = c(44);
  let isRequired;
  let errorMessage;
  let isDisabled;
  let isReadOnly;
  let label;
  let description;
  let otherProps;
  let children;
  if ($[0] !== props) {
    ({
      children,
      description,
      errorMessage,
      isDisabled,
      isReadOnly,
      isRequired,
      label,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isRequired;
    $[2] = errorMessage;
    $[3] = isDisabled;
    $[4] = isReadOnly;
    $[5] = label;
    $[6] = description;
    $[7] = otherProps;
    $[8] = children;
  } else {
    isRequired = $[1];
    errorMessage = $[2];
    isDisabled = $[3];
    isReadOnly = $[4];
    label = $[5];
    description = $[6];
    otherProps = $[7];
    children = $[8];
  }
  const {
    labelProps,
    fieldProps,
    descriptionProps,
    errorMessageProps
  } = useField(props);
  const t0 = isRequired || undefined;
  const t1 = errorMessage ? true : undefined;
  let T0;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  if ($[9] !== fieldProps || $[10] !== isDisabled || $[11] !== isReadOnly || $[12] !== t0 || $[13] !== t1 || $[14] !== isRequired || $[15] !== label || $[16] !== labelProps || $[17] !== description || $[18] !== descriptionProps || $[19] !== errorMessage || $[20] !== errorMessageProps || $[21] !== otherProps || $[22] !== children) {
    const renderProps = {
      ...fieldProps,
      disabled: isDisabled,
      readOnly: isReadOnly,
      "aria-required": t0,
      "aria-invalid": t1
    };
    T0 = FieldPrimitive;
    t2 = isRequired;
    t3 = label;
    t4 = labelProps;
    t5 = description;
    t6 = descriptionProps;
    t7 = errorMessage;
    t8 = errorMessageProps;
    t9 = otherProps;
    t10 = children(renderProps);
    $[9] = fieldProps;
    $[10] = isDisabled;
    $[11] = isReadOnly;
    $[12] = t0;
    $[13] = t1;
    $[14] = isRequired;
    $[15] = label;
    $[16] = labelProps;
    $[17] = description;
    $[18] = descriptionProps;
    $[19] = errorMessage;
    $[20] = errorMessageProps;
    $[21] = otherProps;
    $[22] = children;
    $[23] = T0;
    $[24] = t2;
    $[25] = t3;
    $[26] = t4;
    $[27] = t5;
    $[28] = t6;
    $[29] = t7;
    $[30] = t8;
    $[31] = t9;
    $[32] = t10;
  } else {
    T0 = $[23];
    t2 = $[24];
    t3 = $[25];
    t4 = $[26];
    t5 = $[27];
    t6 = $[28];
    t7 = $[29];
    t8 = $[30];
    t9 = $[31];
    t10 = $[32];
  }
  let t11;
  if ($[33] !== T0 || $[34] !== t2 || $[35] !== t3 || $[36] !== t4 || $[37] !== t5 || $[38] !== t6 || $[39] !== t7 || $[40] !== t8 || $[41] !== t9 || $[42] !== t10) {
    t11 = /*#__PURE__*/jsx(T0, {
      isRequired: t2,
      label: t3,
      labelProps: t4,
      description: t5,
      descriptionProps: t6,
      errorMessage: t7,
      errorMessageProps: t8,
      ...t9,
      children: t10
    });
    $[33] = T0;
    $[34] = t2;
    $[35] = t3;
    $[36] = t4;
    $[37] = t5;
    $[38] = t6;
    $[39] = t7;
    $[40] = t8;
    $[41] = t9;
    $[42] = t10;
    $[43] = t11;
  } else {
    t11 = $[43];
  }
  return t11;
};

/**
 * Add `validationState` when `errorMessage` is provided. Used by
 * "@react-aria/*" hooks to determine aria attributes.
 */
function validateFieldProps(props) {
  if (props.errorMessage) {
    return Object.assign({}, {
      validationState: 'invalid'
    }, props);
  }
  return props;
}

export { Field, FieldLabel, FieldMessage, FieldPrimitive, validateFieldProps };
