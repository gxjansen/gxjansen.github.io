'use client';
import { getChildNodes, getItemCount } from '@react-stately/collections';
export { Item, Section } from '@react-stately/collections';
import { c } from './react-compiler-runtime-19061925.js';
import { useCollator, useLocale } from '@react-aria/i18n';
import { isFocusVisible, usePress, useHover } from '@react-aria/interactions';
import { useSelectableCollection, useSelectableItem } from '@react-aria/selection';
import { mergeProps } from '@react-aria/utils';
import { useTreeState } from '@react-stately/tree';
import React, { useRef, useId, useEffect, useCallback, createContext, useContext } from 'react';
import { Icon } from '@keystar/ui/icon';
import { chevronLeftIcon } from '@keystar/ui/icon/icons/chevronLeftIcon';
import { chevronRightIcon } from '@keystar/ui/icon/icons/chevronRightIcon';
import { dotIcon } from '@keystar/ui/icon/icons/dotIcon';
import { SlotProvider } from '@keystar/ui/slots';
import { useStyleProps, classNames, css, tokenSchema, toDataAttributes } from '@keystar/ui/style';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';

class TreeKeyboardDelegate {
  constructor(collator, collection, disabledKeys) {
    this.collator = collator;
    this.collection = collection;
    this.disabledKeys = disabledKeys;
  }
  getKeyAbove(key) {
    let {
      collection,
      disabledKeys
    } = this;
    let keyBefore = collection.getKeyBefore(key);
    while (keyBefore !== null) {
      let item = collection.getItem(keyBefore);
      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !disabledKeys.has(item.key)) {
        return keyBefore;
      }
      keyBefore = collection.getKeyBefore(keyBefore);
    }
    return null;
  }
  getKeyBelow(key) {
    let {
      collection,
      disabledKeys
    } = this;
    let keyBelow = collection.getKeyAfter(key);
    while (keyBelow !== null) {
      let item = collection.getItem(keyBelow);
      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !disabledKeys.has(item.key)) {
        return keyBelow;
      }
      keyBelow = collection.getKeyAfter(keyBelow);
    }
    return null;
  }
  getFirstKey() {
    let {
      collection,
      disabledKeys
    } = this;
    let key = collection.getFirstKey();
    while (key !== null) {
      let item = collection.getItem(key);
      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !disabledKeys.has(item.key)) {
        return key;
      }
      key = collection.getKeyAfter(key);
    }
    return null;
  }
  getLastKey() {
    let {
      collection,
      disabledKeys
    } = this;
    let key = collection.getLastKey();
    while (key !== null) {
      let item = collection.getItem(key);
      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !disabledKeys.has(item.key)) {
        return key;
      }
      key = collection.getKeyBefore(key);
    }
    return null;
  }
  getKeyForSearch(search, fromKey = this.getFirstKey()) {
    let {
      collator,
      collection
    } = this;
    let key = fromKey;
    while (key !== null) {
      let item = collection.getItem(key);
      if (item !== null && item !== void 0 && item.textValue && collator.compare(search, item.textValue.slice(0, search.length)) === 0) {
        return key;
      }
      key = this.getKeyBelow(key);
    }
    return null;
  }
}

const TreeContext = /*#__PURE__*/createContext(null);
function useTreeContext() {
  const context = useContext(TreeContext);
  if (context === null) {
    throw new Error("NavTree: missing context");
  }
  return context;
}
function NavTree(props) {
  const $ = c(46);
  let selectedKey;
  let otherProps;
  let onAction;
  let onSelectionChange;
  if ($[0] !== props) {
    ({
      onAction,
      onSelectionChange,
      selectedKey,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = selectedKey;
    $[2] = otherProps;
    $[3] = onAction;
    $[4] = onSelectionChange;
  } else {
    selectedKey = $[1];
    otherProps = $[2];
    onAction = $[3];
    onSelectionChange = $[4];
  }
  const ref = useRef(null);
  const styleProps = useStyleProps(props);
  let t0;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const [selectedAncestralKeys, setSelectedAncestralKeys] = React.useState(t0);
  let t1;
  bb0: {
    if (selectedKey) {
      let t2;
      if ($[6] !== selectedKey) {
        t2 = new Set([selectedKey]);
        $[6] = selectedKey;
        $[7] = t2;
      } else {
        t2 = $[7];
      }
      const selectedKeys = t2;
      let t3;
      if ($[8] !== selectedKeys) {
        t3 = {
          selectedKeys,
          selectionMode: "single"
        };
        $[8] = selectedKeys;
        $[9] = t3;
      } else {
        t3 = $[9];
      }
      t1 = t3;
      break bb0;
    }
    let t2;
    if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = {};
      $[10] = t2;
    } else {
      t2 = $[10];
    }
    t1 = t2;
  }
  const selectionProps = t1;
  let t2;
  if ($[11] !== otherProps || $[12] !== selectionProps) {
    t2 = {
      ...otherProps,
      ...selectionProps
    };
    $[11] = otherProps;
    $[12] = selectionProps;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  const state = useTreeState(t2);
  let t3;
  if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      usage: "search",
      sensitivity: "base"
    };
    $[14] = t3;
  } else {
    t3 = $[14];
  }
  const collator = useCollator(t3);
  let t4;
  let t5;
  if ($[15] !== collator || $[16] !== state.collection || $[17] !== state.disabledKeys) {
    t5 = new TreeKeyboardDelegate(collator, state.collection, state.disabledKeys);
    $[15] = collator;
    $[16] = state.collection;
    $[17] = state.disabledKeys;
    $[18] = t5;
  } else {
    t5 = $[18];
  }
  t4 = t5;
  const keyboardDelegate = t4;
  let t6;
  if ($[19] !== props || $[20] !== keyboardDelegate || $[21] !== ref || $[22] !== state.selectionManager) {
    t6 = {
      ...props,
      allowsTabNavigation: true,
      keyboardDelegate,
      ref,
      selectionManager: state.selectionManager
    };
    $[19] = props;
    $[20] = keyboardDelegate;
    $[21] = ref;
    $[22] = state.selectionManager;
    $[23] = t6;
  } else {
    t6 = $[23];
  }
  const {
    collectionProps
  } = useSelectableCollection(t6);
  const id = useId();
  let t7;
  let t8;
  if ($[24] !== id || $[25] !== onAction || $[26] !== onSelectionChange || $[27] !== selectedAncestralKeys) {
    t8 = {
      id,
      onAction,
      onSelectionChange,
      selectedAncestralKeys
    };
    $[24] = id;
    $[25] = onAction;
    $[26] = onSelectionChange;
    $[27] = selectedAncestralKeys;
    $[28] = t8;
  } else {
    t8 = $[28];
  }
  t7 = t8;
  const context = t7;
  let t9;
  let t10;
  if ($[29] !== state.selectionManager.firstSelectedKey || $[30] !== state.collection) {
    t9 = () => {
      if (state.selectionManager.firstSelectedKey) {
        const item = state.collection.getItem(state.selectionManager.firstSelectedKey);
        if (item) {
          const ancestors = getAncestors(state.collection, item);
          setSelectedAncestralKeys(ancestors.map(item_0 => item_0.key));
        }
      }
    };
    t10 = [state.collection, state.selectionManager.firstSelectedKey];
    $[29] = state.selectionManager.firstSelectedKey;
    $[30] = state.collection;
    $[31] = t9;
    $[32] = t10;
  } else {
    t9 = $[31];
    t10 = $[32];
  }
  useEffect(t9, t10);
  let t11;
  if ($[33] !== styleProps.className) {
    t11 = classNames(styleProps.className, css({
      outline: "none"
    }));
    $[33] = styleProps.className;
    $[34] = t11;
  } else {
    t11 = $[34];
  }
  let t12;
  if ($[35] !== state) {
    t12 = resolveTreeNodes({
      nodes: state.collection,
      state
    });
    $[35] = state;
    $[36] = t12;
  } else {
    t12 = $[36];
  }
  let t13;
  if ($[37] !== collectionProps || $[38] !== styleProps || $[39] !== t11 || $[40] !== ref || $[41] !== t12) {
    t13 = /*#__PURE__*/jsx("div", {
      ...collectionProps,
      ...styleProps,
      className: t11,
      ref: ref,
      role: "treegrid",
      children: t12
    });
    $[37] = collectionProps;
    $[38] = styleProps;
    $[39] = t11;
    $[40] = ref;
    $[41] = t12;
    $[42] = t13;
  } else {
    t13 = $[42];
  }
  let t14;
  if ($[43] !== context || $[44] !== t13) {
    t14 = /*#__PURE__*/jsx(TreeContext.Provider, {
      value: context,
      children: t13
    });
    $[43] = context;
    $[44] = t13;
    $[45] = t14;
  } else {
    t14 = $[45];
  }
  return t14;
}
function resolveTreeNodes({
  nodes,
  state
}) {
  return Array.from(nodes).map(node => {
    let Comp = node.type === 'section' ? TreeSection : TreeItem;
    return /*#__PURE__*/jsx(Comp, {
      node: node,
      state: state
    }, node.key);
  });
}

// TODO: review accessibility
function TreeSection(t0) {
  const $ = c(11);
  const {
    node,
    state
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = css({
      paddingBlock: tokenSchema.size.space.medium,
      paddingInline: tokenSchema.size.space.medium
    });
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== node.rendered) {
    t2 = /*#__PURE__*/jsx("div", {
      role: "rowgroup",
      children: /*#__PURE__*/jsx("div", {
        role: "row",
        children: /*#__PURE__*/jsx("div", {
          role: "columnheader",
          "aria-sort": "none",
          children: /*#__PURE__*/jsx(Text, {
            casing: "uppercase",
            size: "small",
            color: "neutralSecondary",
            weight: "medium",
            UNSAFE_className: t1,
            children: node.rendered
          })
        })
      })
    });
    $[1] = node.rendered;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== node || $[4] !== state) {
    t3 = resolveTreeNodes({
      nodes: getChildNodes(node, state.collection),
      state
    });
    $[3] = node;
    $[4] = state;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== t3) {
    t4 = /*#__PURE__*/jsx("div", {
      role: "rowgroup",
      children: t3
    });
    $[6] = t3;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t2 || $[9] !== t4) {
    t5 = /*#__PURE__*/jsxs(Fragment, {
      children: [t2, t4]
    });
    $[8] = t2;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}
function TreeItem({
  node,
  state
}) {
  let ref = useRef(null);
  let {
    direction
  } = useLocale();
  let {
    itemProps,
    isExpanded,
    isPressed,
    isHovered,
    isFocused,
    isSelectedAncestor
  } = useTreeItem({
    node
  }, state, ref);
  let isRtl = direction === 'rtl';
  let contents = isReactText(node.rendered) ? /*#__PURE__*/jsx(Text, {
    children: node.rendered
  }) : node.rendered;
  let itemClassName = css({
    color: tokenSchema.color.alias.foregroundIdle,
    cursor: 'default',
    fontWeight: tokenSchema.typography.fontWeight.medium,
    position: 'relative',
    outline: 'none',
    padding: tokenSchema.size.alias.focusRing,
    paddingInlineStart: tokenSchema.size.space.regular
  });
  let itemStyle = useCallback((...selectors) => selectors.map(selector => `.${itemClassName}${selector}`).join(', '), [itemClassName]);
  return /*#__PURE__*/jsxs(SlotProvider, {
    slots: {
      button: {
        isHidden: !(isFocused && isFocusVisible()) && !isHovered,
        elementType: 'span',
        marginStart: 'auto',
        prominence: 'low'
      },
      text: {
        color: 'inherit',
        truncate: true,
        weight: 'inherit'
      }
    },
    children: [/*#__PURE__*/jsx("div", {
      ...itemProps,
      ...toDataAttributes({
        selectedAncestor: isSelectedAncestor || undefined,
        hovered: isHovered || undefined,
        pressed: isPressed || undefined,
        focused: isFocused ? isFocusVisible() ? 'visible' : 'true' : undefined
      }),
      ref: ref,
      role: "row",
      className: itemClassName,
      children: /*#__PURE__*/jsxs("div", {
        role: "gridcell",
        className: css({
          alignItems: 'center',
          // borderRadius: `calc(${tokenSchema.size.radius.regular} + ${tokenSchema.size.alias.focusRing})`,
          borderRadius: tokenSchema.size.radius.regular,
          display: 'flex',
          gap: tokenSchema.size.space.small,
          minHeight: tokenSchema.size.element.regular,
          paddingInlineStart: `calc(${tokenSchema.size.space.regular} * var(--inset))`,
          '[role=rowgroup] &': {
            paddingInlineStart: `calc(${tokenSchema.size.space.regular} * calc(var(--inset) - 1))`
          },
          // interaction states
          [itemStyle('[data-hovered] > &')]: {
            backgroundColor: tokenSchema.color.alias.backgroundHovered,
            color: tokenSchema.color.alias.foregroundHovered
          },
          [itemStyle('[data-pressed] > &')]: {
            backgroundColor: tokenSchema.color.alias.backgroundPressed,
            color: tokenSchema.color.alias.foregroundPressed
          },
          [itemStyle('[data-focused=visible] > &')]: {
            outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`
          },
          // indicate when a collapsed item contains the selected item, so
          // that the user always knows where they are in the tree
          [itemStyle('[data-selected-ancestor=true][aria-expanded=false] > &')]: {
            '&::before': {
              backgroundColor: tokenSchema.color.background.accentEmphasis,
              borderRadius: tokenSchema.size.space.small,
              content: '""',
              insetBlockStart: `50%`,
              insetInlineStart: 0,
              marginBlockStart: `calc(${tokenSchema.size.space.medium} / 2 * -1)`,
              position: 'absolute',
              height: tokenSchema.size.space.medium,
              width: tokenSchema.size.space.small
            }
          },
          // selected item
          [itemStyle('[aria-current=page] > &')]: {
            backgroundColor: tokenSchema.color.alias.backgroundHovered,
            color: tokenSchema.color.alias.foregroundHovered,
            fontWeight: tokenSchema.typography.fontWeight.semibold,
            '&::before': {
              backgroundColor: tokenSchema.color.background.accentEmphasis,
              borderRadius: tokenSchema.size.space.small,
              content: '""',
              insetBlock: tokenSchema.size.space.small,
              insetInlineStart: 0,
              position: 'absolute',
              width: tokenSchema.size.space.small
            }
          },
          [itemStyle('[aria-current=page][data-hovered] > &')]: {
            backgroundColor: tokenSchema.color.alias.backgroundPressed
          }
        }),
        style: {
          // @ts-expect-error
          '--inset': node.level + 1
        },
        children: [node.hasChildNodes ? /*#__PURE__*/jsx(Icon, {
          src: isRtl ? chevronLeftIcon : chevronRightIcon,
          color: "neutralTertiary",
          UNSAFE_style: {
            transform: `rotate(${isExpanded ? isRtl ? -90 : 90 : 0}deg)`
          }
        }) : /*#__PURE__*/jsx(Icon, {
          src: dotIcon,
          color: "neutralTertiary"
        }), contents]
      })
    }), isExpanded && resolveTreeNodes({
      nodes: getChildNodes(node, state.collection),
      state
    })]
  });
}
/**
 * Provides the behavior and accessibility implementation for an item within a tree.
 * @param props - Props for the tree item.
 * @param state - State of the parent list, as returned by `useTreeState`.
 * @param ref - The ref attached to the tree element.
 */
function useTreeItem(props, state, ref) {
  const $ = c(55);
  const {
    node,
    isVirtualized
  } = props;
  const {
    selectionManager
  } = state;
  const treeData = useTreeContext();
  const {
    direction
  } = useLocale();
  let t0;
  if ($[0] !== state.expandedKeys || $[1] !== node.key) {
    t0 = state.expandedKeys.has(node.key);
    $[0] = state.expandedKeys;
    $[1] = node.key;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const isExpanded = t0;
  let t1;
  if ($[3] !== treeData || $[4] !== node) {
    t1 = treeData === null || treeData === void 0 ? void 0 : treeData.selectedAncestralKeys.includes(node.key);
    $[3] = treeData;
    $[4] = node;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const isSelectedAncestor = t1;
  let t2;
  if ($[6] !== treeData.onAction || $[7] !== treeData.onSelectionChange || $[8] !== node || $[9] !== state || $[10] !== isExpanded) {
    t2 = e => {
      var _treeData$onAction;
      (_treeData$onAction = treeData.onAction) === null || _treeData$onAction === void 0 || _treeData$onAction.call(treeData, node.key);
      if (node.hasChildNodes) {
        if (e.altKey) {
          const descendants = getDescendantNodes(node, state.collection);
          const newKeys = new Set(state.expandedKeys);
          for (const descendant of descendants) {
            if (isExpanded) {
              newKeys.delete(descendant.key);
            } else {
              newKeys.add(descendant.key);
            }
          }
          state.setExpandedKeys(newKeys);
        } else {
          state.toggleKey(node.key);
        }
      } else {
        var _treeData$onSelection;
        (_treeData$onSelection = treeData.onSelectionChange) === null || _treeData$onSelection === void 0 || _treeData$onSelection.call(treeData, node.key);
      }
    };
    $[6] = treeData.onAction;
    $[7] = treeData.onSelectionChange;
    $[8] = node;
    $[9] = state;
    $[10] = isExpanded;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  const onPress = t2;
  let t3;
  if ($[12] !== node.key || $[13] !== selectionManager || $[14] !== ref || $[15] !== isVirtualized) {
    t3 = {
      key: node.key,
      selectionManager,
      ref,
      isVirtualized,
      shouldSelectOnPressUp: true
    };
    $[12] = node.key;
    $[13] = selectionManager;
    $[14] = ref;
    $[15] = isVirtualized;
    $[16] = t3;
  } else {
    t3 = $[16];
  }
  const t4 = useSelectableItem(t3);
  let itemStates;
  let selectableItemProps;
  if ($[17] !== t4) {
    ({
      itemProps: selectableItemProps,
      ...itemStates
    } = t4);
    $[17] = t4;
    $[18] = itemStates;
    $[19] = selectableItemProps;
  } else {
    itemStates = $[18];
    selectableItemProps = $[19];
  }
  let t5;
  if ($[20] !== onPress || $[21] !== itemStates.isDisabled) {
    t5 = {
      onPress,
      isDisabled: itemStates.isDisabled
    };
    $[20] = onPress;
    $[21] = itemStates.isDisabled;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  const {
    pressProps
  } = usePress(t5);
  let t6;
  if ($[23] !== itemStates.isDisabled) {
    t6 = {
      isDisabled: itemStates.isDisabled
    };
    $[23] = itemStates.isDisabled;
    $[24] = t6;
  } else {
    t6 = $[24];
  }
  const {
    isHovered,
    hoverProps
  } = useHover(t6);
  let t7;
  if ($[25] !== ref.current || $[26] !== node || $[27] !== isExpanded || $[28] !== state || $[29] !== selectionManager || $[30] !== direction) {
    t7 = e_0 => {
      if (!ref.current || !e_0.currentTarget.contains(e_0.target)) {
        return;
      }
      const handleArrowBackward = () => {
        if (node.hasChildNodes && isExpanded) {
          if (e_0.altKey) {
            const expandedKeys = new Set(state.expandedKeys);
            for (const descendant_0 of getDescendantNodes(node, state.collection)) {
              expandedKeys.delete(descendant_0.key);
            }
            state.setExpandedKeys(expandedKeys);
          } else {
            state.toggleKey(node.key);
          }
        } else {
          if (node !== null && node !== void 0 && node.parentKey) {
            const parentNode = state.collection.getItem(node.parentKey);
            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === "item") {
              selectionManager.setFocusedKey(node.parentKey);
            }
          }
        }
      };
      const handleArrowForward = () => {
        if (node.hasChildNodes && !isExpanded) {
          if (e_0.altKey) {
            const expandedKeys_0 = new Set(state.expandedKeys);
            for (const descendant_1 of getDescendantNodes(node, state.collection)) {
              expandedKeys_0.add(descendant_1.key);
            }
            state.setExpandedKeys(expandedKeys_0);
          } else {
            state.toggleKey(node.key);
          }
        } else {
          if (node.hasChildNodes) {
            const firstChild = state.collection.getKeyAfter(node.key);
            if (firstChild) {
              selectionManager.setFocusedKey(firstChild);
            }
          }
        }
      };
      bb87: switch (e_0.key) {
        case "ArrowLeft":
          {
            e_0.preventDefault();
            if (direction === "rtl") {
              handleArrowForward();
            } else {
              handleArrowBackward();
            }
            break bb87;
          }
        case "ArrowRight":
          {
            e_0.preventDefault();
            if (direction === "rtl") {
              handleArrowBackward();
            } else {
              handleArrowForward();
            }
          }
      }
    };
    $[25] = ref.current;
    $[26] = node;
    $[27] = isExpanded;
    $[28] = state;
    $[29] = selectionManager;
    $[30] = direction;
    $[31] = t7;
  } else {
    t7 = $[31];
  }
  const onKeyDownCapture = t7;
  let t8;
  if ($[32] !== selectableItemProps || $[33] !== pressProps || $[34] !== hoverProps) {
    t8 = mergeProps(selectableItemProps, pressProps, hoverProps);
    $[32] = selectableItemProps;
    $[33] = pressProps;
    $[34] = hoverProps;
    $[35] = t8;
  } else {
    t8 = $[35];
  }
  const t9 = node.textValue || undefined;
  const t10 = itemStates.isDisabled || undefined;
  const t11 = node.level + 1;
  const t12 = node.hasChildNodes ? isExpanded : undefined;
  const t13 = itemStates.isSelected ? "page" : undefined;
  let itemProps;
  if ($[36] !== t8 || $[37] !== onKeyDownCapture || $[38] !== t9 || $[39] !== t10 || $[40] !== t11 || $[41] !== t12 || $[42] !== t13 || $[43] !== isVirtualized || $[44] !== state || $[45] !== node) {
    itemProps = {
      ...t8,
      onKeyDownCapture,
      "aria-label": t9,
      "aria-disabled": t10,
      "aria-level": t11,
      "aria-expanded": t12,
      "aria-current": t13
    };
    if (isVirtualized) {
      var _state$collection$get;
      const index = Number((_state$collection$get = state.collection.getItem(node.key)) === null || _state$collection$get === void 0 ? void 0 : _state$collection$get.index);
      itemProps["aria-posinset"] = Number.isNaN(index) ? undefined : index + 1;
      let t14;
      if ($[47] !== state.collection) {
        t14 = getItemCount(state.collection);
        $[47] = state.collection;
        $[48] = t14;
      } else {
        t14 = $[48];
      }
      itemProps["aria-setsize"] = t14;
    }
    $[36] = t8;
    $[37] = onKeyDownCapture;
    $[38] = t9;
    $[39] = t10;
    $[40] = t11;
    $[41] = t12;
    $[42] = t13;
    $[43] = isVirtualized;
    $[44] = state;
    $[45] = node;
    $[46] = itemProps;
  } else {
    itemProps = $[46];
  }
  const t14 = node.hasChildNodes && isExpanded;
  let t15;
  if ($[49] !== itemProps || $[50] !== itemStates || $[51] !== t14 || $[52] !== isSelectedAncestor || $[53] !== isHovered) {
    t15 = {
      itemProps,
      ...itemStates,
      isExpanded: t14,
      isSelectedAncestor,
      isHovered
    };
    $[49] = itemProps;
    $[50] = itemStates;
    $[51] = t14;
    $[52] = isSelectedAncestor;
    $[53] = isHovered;
    $[54] = t15;
  } else {
    t15 = $[54];
  }
  return t15;
}

/** Get descendants that contain children, inclusive of the root node. */
function getDescendantNodes(node, collection, depth = Infinity) {
  const descendants = new Set();
  if (depth === 0 || !node.hasChildNodes) {
    return descendants;
  }
  descendants.add(node);
  for (let child of getChildNodes(node, collection)) {
    const childDescendants = getDescendantNodes(child, collection, depth - 1);
    for (let descendant of childDescendants) {
      descendants.add(descendant);
    }
  }
  return descendants;
}
function getAncestors(collection, node) {
  let parents = [];
  while (((_node = node) === null || _node === void 0 ? void 0 : _node.parentKey) != null) {
    var _node;
    // @ts-expect-error if there's a `parentKey`, there's a parent...
    node = collection.getItem(node.parentKey);
    parents.unshift(node);
  }
  return parents;
}

export { NavTree };
