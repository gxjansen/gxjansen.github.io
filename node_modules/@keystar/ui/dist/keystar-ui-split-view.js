'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useStyleProps, classNames, css, transition, tokenSchema } from '@keystar/ui/style';
import { useIsMounted, useId } from '@keystar/ui/utils';
import { useLocale } from '@react-aria/i18n';
import { useUpdateEffect, filterDOMProps } from '@react-aria/utils';
import { clamp } from '@react-stately/utils';
import { createContext, useContext, useState, useRef, useEffect, forwardRef } from 'react';
import { jsxs, jsx } from 'react/jsx-runtime';

const SplitViewContext = /*#__PURE__*/createContext({
  activity: undefined,
  id: '',
  isCollapsed: undefined
});

/** @private */
const SplitViewProvider = SplitViewContext.Provider;

/** @private */
function useSplitView() {
  return useContext(SplitViewContext);
}

let currentState = null;
let element = null;
function getCursorStyle(state, isReversed) {
  switch (state) {
    case 'horizontal':
      return 'ew-resize';
    case 'horizontal-max':
      return isReversed ? 'e-resize' : 'w-resize';
    case 'horizontal-min':
      return isReversed ? 'w-resize' : 'e-resize';
  }
}
function resetGlobalCursorStyle() {
  if (element !== null) {
    document.head.removeChild(element);
    currentState = null;
    element = null;
  }
}
function setGlobalCursorStyle(state, isReversed) {
  if (currentState === state) {
    return;
  }
  currentState = state;
  const style = getCursorStyle(state, isReversed);
  if (element === null) {
    element = document.createElement('style');
    document.head.appendChild(element);
  }
  element.innerHTML = `*{cursor: ${style}!important;}`;
}

// Credit: https://github.com/bvaughn/react-resizable-panels/blob/main/packages/react-resizable-panels/src/PanelGroup.ts

// SplitView might be rendering in a server-side environment where
// `localStorage` is not available or on a browser with cookies/storage
// disabled. In either case, this function avoids accessing `localStorage` until
// needed, and avoids throwing user-visible errors.
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== 'undefined') {
      // Bypass this check for future calls
      storageObject.getItem = name => {
        return localStorage.getItem(name);
      };
      storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    } else {
      throw new Error('localStorage not supported in this environment');
    }
  } catch (error) {
    console.error(error);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {};
  }
}
const defaultStorage = {
  getItem: name => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};

function getPosition(e) {
  if (isMouseEvent(e)) {
    return e.clientX;
  } else if (isTouchEvent(e)) {
    return e.touches[0].clientX;
  }
  return 0;
}
function getPercentage(value, min, max) {
  return Math.round((value - min) / (max - min) * 100);
}
function getPrimaryPaneId(id) {
  return `primary-pane-${id}`;
}
function getSecondaryPaneId(id) {
  return `secondary-pane-${id}`;
}
function getResizeHandleId(id) {
  return `resize-handle-${id}`;
}
function getPrimaryPane(id) {
  return document.getElementById(getPrimaryPaneId(id));
}
function getSecondaryPane(id) {
  return document.getElementById(getSecondaryPaneId(id));
}
function getResizeHandle(id) {
  return document.getElementById(getResizeHandleId(id));
}
function px(value) {
  return `${value}px`;
}
function isMouseEvent(event) {
  return event.type.startsWith('mouse');
}
function isTouchEvent(event) {
  return event.type.startsWith('touch');
}

const MAX_WIDTH_PROP = '--primary-pane-max-width';
const MAX_WIDTH_VAR = `var(${MAX_WIDTH_PROP})`;
const MIN_WIDTH_PROP = '--primary-pane-min-width';
const MIN_WIDTH_VAR = `var(${MIN_WIDTH_PROP})`;
const WIDTH_PROP = '--primary-pane-width';
const WIDTH_VAR = `var(${WIDTH_PROP})`;
const SNAP_REGION_PX = 32;
const KEYBOARD_ARROW_STEPS = 10;
function SplitView(props) {
  const $ = c(62);
  const {
    autoSaveId,
    children,
    defaultSize,
    isCollapsed,
    minSize,
    maxSize,
    onCollapseChange,
    onResize,
    storage: t0
  } = props;
  const storage = t0 === undefined ? defaultStorage : t0;
  const [startPane, endPane] = children;
  const getIsMounted = useIsMounted();
  const id = useId(props.id);
  const {
    direction
  } = useLocale();
  const styleProps = useStyleProps(props);
  const [isReversed, setReversed] = useState(false);
  const [isDragging, setDragging] = useState(false);
  const [handleIsFocused, setHandleFocus] = useState(false);
  let t1;
  if ($[0] !== defaultSize || $[1] !== autoSaveId || $[2] !== storage) {
    t1 = () => {
      let size = defaultSize;
      if (autoSaveId) {
        const savedSize = storage.getItem(autoSaveId);
        if (savedSize) {
          size = Number.parseInt(savedSize);
        }
      }
      return size;
    };
    $[0] = defaultSize;
    $[1] = autoSaveId;
    $[2] = storage;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const [size_0, setSize] = useState(t1);
  const wrapperRef = useRef(null);
  const offsetRef = useRef(0);
  const moveRef = useRef(0);
  let t2;
  let t3;
  if ($[4] !== id || $[5] !== direction) {
    t2 = () => {
      const resizeHandle = getResizeHandle(id);
      const primaryPane = getPrimaryPane(id);
      const secondaryPane = getSecondaryPane(id);
      setReversed(direction === "rtl" ? (resizeHandle === null || resizeHandle === void 0 ? void 0 : resizeHandle.previousElementSibling) === primaryPane : (resizeHandle === null || resizeHandle === void 0 ? void 0 : resizeHandle.previousElementSibling) === secondaryPane);
    };
    t3 = [direction, id];
    $[4] = id;
    $[5] = direction;
    $[6] = t2;
    $[7] = t3;
  } else {
    t2 = $[6];
    t3 = $[7];
  }
  useEffect(t2, t3);
  let t4;
  if ($[8] !== onResize || $[9] !== size_0) {
    t4 = () => onResize === null || onResize === void 0 ? void 0 : onResize(size_0);
    $[8] = onResize;
    $[9] = size_0;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== size_0) {
    t5 = [size_0];
    $[11] = size_0;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  useUpdateEffect(t4, t5);
  let t6;
  if ($[13] !== size_0 || $[14] !== autoSaveId || $[15] !== storage) {
    t6 = () => {
      var _wrapperRef$current;
      (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 || _wrapperRef$current.style.setProperty(WIDTH_PROP, px(size_0));
      moveRef.current = size_0;
      if (autoSaveId) {
        storage.setItem(autoSaveId, px(size_0));
      }
    };
    $[13] = size_0;
    $[14] = autoSaveId;
    $[15] = storage;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  let t7;
  if ($[17] !== autoSaveId || $[18] !== onResize || $[19] !== size_0 || $[20] !== storage) {
    t7 = [autoSaveId, onResize, size_0, storage];
    $[17] = autoSaveId;
    $[18] = onResize;
    $[19] = size_0;
    $[20] = storage;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  useEffect(t6, t7);
  let t8;
  let t9;
  if ($[22] !== id || $[23] !== isCollapsed || $[24] !== isReversed || $[25] !== size_0 || $[26] !== defaultSize || $[27] !== minSize || $[28] !== maxSize || $[29] !== onCollapseChange) {
    t8 = () => {
      const wrapper = wrapperRef.current;
      const resizeHandle_0 = getResizeHandle(id);
      const primaryPane_0 = getPrimaryPane(id);
      if (!wrapper || !resizeHandle_0 || !primaryPane_0) {
        return;
      }
      let collapseRequested;
      collapseRequested = false;
      const collapseAllowed = typeof isCollapsed === "boolean";
      const onMove = e => {
        e.preventDefault();
        let delta = getPosition(e) - offsetRef.current;
        if (isReversed) {
          delta = delta * -1;
        }
        let nextWidth = size_0 + delta;
        if (Math.abs(nextWidth - defaultSize) < SNAP_REGION_PX / 2) {
          nextWidth = defaultSize;
        }
        if (collapseAllowed) {
          collapseRequested = nextWidth <= minSize / 2;
        }
        if (collapseRequested) {
          primaryPane_0.style.setProperty("width", "0px");
          moveRef.current = size_0;
        } else {
          moveRef.current = nextWidth;
          primaryPane_0.style.removeProperty("width");
        }
        wrapper.style.setProperty(WIDTH_PROP, px(moveRef.current));
        let cursorStyle = "horizontal";
        if (moveRef.current < minSize) {
          cursorStyle = "horizontal-min";
        }
        if (moveRef.current > maxSize) {
          cursorStyle = "horizontal-max";
        }
        setGlobalCursorStyle(cursorStyle, isReversed);
      };
      const stopDragging = () => {
        resizeHandle_0.blur();
        setDragging(false);
        resetGlobalCursorStyle();
        if (collapseRequested) {
          onCollapseChange === null || onCollapseChange === void 0 || onCollapseChange(!isCollapsed);
          primaryPane_0.style.removeProperty("width");
        } else {
          setSize(clamp(moveRef.current, minSize, maxSize));
        }
        collapseRequested = false;
        document.body.removeEventListener("mousemove", onMove);
        document.body.removeEventListener("touchmove", onMove);
        window.removeEventListener("mouseup", stopDragging);
        window.removeEventListener("touchend", stopDragging);
      };
      const startDragging = e_0 => {
        if ("button" in e_0 && e_0.button !== 0) {
          return;
        }
        if ("touches" in e_0 && e_0.touches.length !== 1) {
          return;
        }
        setDragging(true);
        offsetRef.current = getPosition(e_0);
        document.body.addEventListener("mousemove", onMove);
        document.body.addEventListener("touchmove", onMove);
        window.addEventListener("mouseup", stopDragging);
        window.addEventListener("touchend", stopDragging);
      };
      const onKeyDown = e_1 => {
        if (e_1.defaultPrevented) {
          return;
        }
        const step = Math.round((maxSize - minSize) / KEYBOARD_ARROW_STEPS);
        const increment = () => setSize(size_1 => Math.min(size_1 + step, maxSize));
        const decrement = () => setSize(size_2 => Math.max(size_2 - step, minSize));
        bb104: switch (e_1.key) {
          case "Enter":
            {
              if (collapseAllowed) {
                e_1.preventDefault();
                onCollapseChange === null || onCollapseChange === void 0 || onCollapseChange(!isCollapsed);
              }
              break bb104;
            }
          case "Home":
            {
              e_1.preventDefault();
              setSize(minSize);
              break bb104;
            }
          case "End":
            {
              e_1.preventDefault();
              setSize(maxSize);
              break bb104;
            }
          case "ArrowLeft":
            {
              e_1.preventDefault();
              if (isReversed) {
                increment();
              } else {
                decrement();
              }
              break bb104;
            }
          case "ArrowRight":
            {
              e_1.preventDefault();
              if (isReversed) {
                decrement();
              } else {
                increment();
              }
            }
        }
      };
      const options = {
        passive: true
      };
      const onDoubleClick = e_2 => {
        if (e_2.clientX === offsetRef.current) {
          setSize(defaultSize);
        }
      };
      resizeHandle_0.addEventListener("contextmenu", stopDragging);
      resizeHandle_0.addEventListener("dblclick", onDoubleClick);
      resizeHandle_0.addEventListener("keydown", onKeyDown);
      resizeHandle_0.addEventListener("mousedown", startDragging, options);
      resizeHandle_0.addEventListener("touchstart", startDragging, options);
      return () => {
        resizeHandle_0.removeEventListener("contextmenu", stopDragging);
        resizeHandle_0.removeEventListener("dblclick", onDoubleClick);
        resizeHandle_0.removeEventListener("keydown", onKeyDown);
        resizeHandle_0.removeEventListener("mousedown", startDragging);
        resizeHandle_0.removeEventListener("touchstart", startDragging);
      };
    };
    t9 = [maxSize, minSize, defaultSize, id, isReversed, size_0, onCollapseChange, isCollapsed];
    $[22] = id;
    $[23] = isCollapsed;
    $[24] = isReversed;
    $[25] = size_0;
    $[26] = defaultSize;
    $[27] = minSize;
    $[28] = maxSize;
    $[29] = onCollapseChange;
    $[30] = t8;
    $[31] = t9;
  } else {
    t8 = $[30];
    t9 = $[31];
  }
  useEffect(t8, t9);
  const t10 = !getIsMounted() ? "initializing" : isDragging ? "pointer" : handleIsFocused ? "keyboard" : undefined;
  let t11;
  if ($[32] !== id || $[33] !== isCollapsed || $[34] !== t10) {
    t11 = {
      id,
      isCollapsed,
      activity: t10
    };
    $[32] = id;
    $[33] = isCollapsed;
    $[34] = t10;
    $[35] = t11;
  } else {
    t11 = $[35];
  }
  let t12;
  if ($[36] !== props) {
    t12 = filterDOMProps(props);
    $[36] = props;
    $[37] = t12;
  } else {
    t12 = $[37];
  }
  let t13;
  if ($[38] !== minSize || $[39] !== maxSize || $[40] !== defaultSize || $[41] !== styleProps.className) {
    t13 = classNames(css({
      display: "flex",
      height: "100%",
      width: "100%",
      overflow: "hidden",
      [MIN_WIDTH_PROP]: px(minSize),
      [MAX_WIDTH_PROP]: px(maxSize),
      [WIDTH_PROP]: px(defaultSize)
    }), styleProps.className);
    $[38] = minSize;
    $[39] = maxSize;
    $[40] = defaultSize;
    $[41] = styleProps.className;
    $[42] = t13;
  } else {
    t13 = $[42];
  }
  let t14;
  if ($[43] !== size_0 || $[44] !== minSize || $[45] !== maxSize) {
    t14 = getPercentage(size_0, minSize, maxSize);
    $[43] = size_0;
    $[44] = minSize;
    $[45] = maxSize;
    $[46] = t14;
  } else {
    t14 = $[46];
  }
  let t15;
  let t16;
  if ($[47] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = () => setHandleFocus(false);
    t16 = () => setHandleFocus(true);
    $[47] = t15;
    $[48] = t16;
  } else {
    t15 = $[47];
    t16 = $[48];
  }
  let t17;
  if ($[49] !== t14) {
    t17 = /*#__PURE__*/jsx(SplitViewResizeHandle, {
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": t14,
      onBlur: t15,
      onFocus: t16
    });
    $[49] = t14;
    $[50] = t17;
  } else {
    t17 = $[50];
  }
  let t18;
  if ($[51] !== styleProps || $[52] !== t12 || $[53] !== wrapperRef || $[54] !== t13 || $[55] !== startPane || $[56] !== t17 || $[57] !== endPane) {
    t18 = /*#__PURE__*/jsxs("div", {
      ...styleProps,
      ...t12,
      ref: wrapperRef,
      className: t13,
      children: [startPane, t17, endPane]
    });
    $[51] = styleProps;
    $[52] = t12;
    $[53] = wrapperRef;
    $[54] = t13;
    $[55] = startPane;
    $[56] = t17;
    $[57] = endPane;
    $[58] = t18;
  } else {
    t18 = $[58];
  }
  let t19;
  if ($[59] !== t11 || $[60] !== t18) {
    t19 = /*#__PURE__*/jsx(SplitViewProvider, {
      value: t11,
      children: t18
    });
    $[59] = t11;
    $[60] = t18;
    $[61] = t19;
  } else {
    t19 = $[61];
  }
  return t19;
}

// Styled components
// -----------------------------------------------------------------------------

const SplitPanePrimary = /*#__PURE__*/forwardRef(function SplitPanePrimary(props, forwardedRef) {
  const $ = c(15);
  const {
    activity,
    id,
    isCollapsed
  } = useSplitView();
  const styleProps = useStyleProps(props);
  let t0;
  if ($[0] !== props) {
    t0 = filterDOMProps(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== id) {
    t1 = getPrimaryPaneId(id);
    $[2] = id;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const t2 = isCollapsed || undefined;
  let t3;
  if ($[4] !== styleProps.className) {
    t3 = classNames(css({
      containerType: "inline-size",
      overflow: "hidden",
      width: `clamp(${MIN_WIDTH_VAR},${WIDTH_VAR},${MAX_WIDTH_VAR})`,
      maxWidth: `calc(100% - 100px)`,
      "&[data-split-view-collapsed]": {
        visibility: "hidden",
        width: 0
      },
      "&:not([data-split-view-activity])": {
        transition: transition("width")
      },
      "&[data-split-view-activity=pointer]": {
        pointerEvents: "none"
      }
    }), styleProps.className);
    $[4] = styleProps.className;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== styleProps || $[7] !== t0 || $[8] !== forwardedRef || $[9] !== t1 || $[10] !== activity || $[11] !== t2 || $[12] !== t3 || $[13] !== props.children) {
    t4 = /*#__PURE__*/jsx("div", {
      ...styleProps,
      ...t0,
      ref: forwardedRef,
      id: t1,
      "data-split-pane": "primary",
      "data-split-view-activity": activity,
      "data-split-view-collapsed": t2,
      className: t3,
      children: props.children
    });
    $[6] = styleProps;
    $[7] = t0;
    $[8] = forwardedRef;
    $[9] = t1;
    $[10] = activity;
    $[11] = t2;
    $[12] = t3;
    $[13] = props.children;
    $[14] = t4;
  } else {
    t4 = $[14];
  }
  return t4;
});
const SplitPaneSecondary = /*#__PURE__*/forwardRef(function SplitPaneSecondary(props, forwardedRef) {
  const $ = c(14);
  const {
    id,
    activity
  } = useSplitView();
  const styleProps = useStyleProps(props);
  let t0;
  if ($[0] !== props) {
    t0 = filterDOMProps(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== id) {
    t1 = getSecondaryPaneId(id);
    $[2] = id;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== styleProps.className) {
    t2 = classNames(css({
      containerType: "inline-size",
      flex: `1 1 0`,
      minWidth: `100px`,
      overflow: "hidden",
      "&[data-split-view-activity=pointer]": {
        pointerEvents: "none"
      }
    }), styleProps.className);
    $[4] = styleProps.className;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== styleProps || $[7] !== t0 || $[8] !== forwardedRef || $[9] !== t1 || $[10] !== activity || $[11] !== t2 || $[12] !== props.children) {
    t3 = /*#__PURE__*/jsx("div", {
      ...styleProps,
      ...t0,
      ref: forwardedRef,
      id: t1,
      "data-split-pane": "secondary",
      "data-split-view-activity": activity,
      className: t2,
      children: props.children
    });
    $[6] = styleProps;
    $[7] = t0;
    $[8] = forwardedRef;
    $[9] = t1;
    $[10] = activity;
    $[11] = t2;
    $[12] = props.children;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  return t3;
});
const SplitViewResizeHandle = /*#__PURE__*/forwardRef(function SplitViewResizeHandle(props, forwardedRef) {
  const $ = c(12);
  const {
    activity,
    id,
    isCollapsed
  } = useSplitView();
  let t0;
  if ($[0] !== id) {
    t0 = getPrimaryPaneId(id);
    $[0] = id;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== id) {
    t1 = getResizeHandleId(id);
    $[2] = id;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const t2 = isCollapsed || undefined;
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = css({
      backgroundColor: tokenSchema.color.border.muted,
      boxSizing: "border-box",
      cursor: "ew-resize",
      flexShrink: 0,
      outline: 0,
      position: "relative",
      touchAction: "none",
      transition: transition("background-color"),
      userSelect: "none",
      width: tokenSchema.size.border.regular,
      zIndex: 1,
      "&[data-split-view-collapsed]:not([data-split-view-activity])": visuallyHiddenStyles,
      "&::before": {
        content: "\"\"",
        position: "absolute",
        inset: `calc(${tokenSchema.size.space.small} * -1)`
      },
      "&::after": {
        backgroundColor: tokenSchema.color.alias.backgroundHovered,
        content: "\"\"",
        insetBlock: 0,
        insetInline: `calc(${tokenSchema.size.border.medium} * -1)`,
        opacity: 0,
        position: "absolute",
        transition: transition("opacity")
      },
      "&:hover": {
        backgroundColor: tokenSchema.color.border.neutral,
        transitionDelay: tokenSchema.animation.duration.regular,
        "&::after": {
          opacity: 1,
          transitionDelay: tokenSchema.animation.duration.regular
        }
      },
      "&[data-split-view-activity=pointer]::after, &[data-split-view-activity=keyboard]::after": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        insetInline: `calc(${tokenSchema.size.border.regular} * -1)`,
        opacity: 1
      }
    });
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== props || $[6] !== forwardedRef || $[7] !== t0 || $[8] !== t1 || $[9] !== activity || $[10] !== t2) {
    t4 = /*#__PURE__*/jsx("div", {
      ...props,
      ref: forwardedRef,
      "aria-controls": t0,
      "aria-label": "Resize",
      "aria-orientation": "vertical",
      id: t1,
      role: "separator",
      tabIndex: 0,
      "data-split-view-resize-handle": true,
      "data-split-view-activity": activity,
      "data-split-view-collapsed": t2,
      className: t3
    });
    $[5] = props;
    $[6] = forwardedRef;
    $[7] = t0;
    $[8] = t1;
    $[9] = activity;
    $[10] = t2;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  return t4;
});
const visuallyHiddenStyles = {
  border: 0,
  clip: 'rect(0 0 0 0)',
  clipPath: 'inset(50%)',
  height: '1px',
  margin: '-1px',
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  width: '1px',
  whiteSpace: 'nowrap'
};

export { SplitPanePrimary, SplitPaneSecondary, SplitView };
