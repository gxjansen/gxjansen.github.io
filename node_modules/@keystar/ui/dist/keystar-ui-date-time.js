'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { createCalendar } from '@internationalized/date';
import { useDateSegment, useDisplayNames, useDateField, useDatePicker, useDateRangePicker, useTimeField } from '@react-aria/datepicker';
import { useDateFormatter, useLocale } from '@react-aria/i18n';
import { useDateFieldState, useDatePickerState, useDateRangePickerState, useTimeFieldState } from '@react-stately/datepicker';
import React, { forwardRef, useRef, useState, useImperativeHandle } from 'react';
import { useProviderProps } from '@keystar/ui/core';
import { FieldPrimitive } from '@keystar/ui/field';
import { useObjectRef, mergeProps, useLayoutEffect } from '@react-aria/utils';
import { useFocusRing, createFocusManager } from '@react-aria/focus';
import { css, classNames, tokenSchema, toDataAttributes, ClassList, useIsMobileDevice, transition } from '@keystar/ui/style';
import { jsx, jsxs } from 'react/jsx-runtime';
import { Text } from '@keystar/ui/typography';
import { useHover } from '@react-aria/interactions';
import { FieldButton } from '@keystar/ui/button';
import { Calendar, RangeCalendar } from '@keystar/ui/calendar';
import { Icon } from '@keystar/ui/icon';
import { calendarDaysIcon } from '@keystar/ui/icon/icons/calendarDaysIcon';
import { useDialog } from '@react-aria/dialog';
import { Popover, Tray } from '@keystar/ui/overlays';

const Input = /*#__PURE__*/forwardRef(function Input(props, forwardedRef) {
  const $ = c(17);
  const inputRef = useObjectRef(forwardedRef);
  const {
    children,
    disableFocusRing,
    fieldProps,
    isDisabled,
    validationState
  } = props;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      isTextInput: true,
      within: true
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const {
    focusProps,
    isFocusVisible,
    isFocused
  } = useFocusRing(t0);
  const isInvalid = validationState === "invalid" && !isDisabled;
  const t1 = isFocusVisible && !disableFocusRing;
  let t2;
  if ($[1] !== isDisabled || $[2] !== isInvalid || $[3] !== isFocused || $[4] !== t1) {
    t2 = {
      isDisabled,
      isInvalid,
      isFocused,
      isFocusVisible: t1
    };
    $[1] = isDisabled;
    $[2] = isInvalid;
    $[3] = isFocused;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const styleProps = useInputStyles(props, t2);
  let t3;
  if ($[6] !== fieldProps || $[7] !== focusProps) {
    t3 = mergeProps(fieldProps, focusProps);
    $[6] = fieldProps;
    $[7] = focusProps;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = css({
      alignItems: "center",
      display: "inline-flex",
      height: "100%",
      overflowX: "auto",
      scrollbarWidth: "none",
      msOverflowStyle: "none"
    });
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  let t5;
  if ($[10] !== inputRef || $[11] !== children) {
    t5 = /*#__PURE__*/jsx("div", {
      role: "presentation",
      className: t4,
      ref: inputRef,
      children: children
    });
    $[10] = inputRef;
    $[11] = children;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== t3 || $[14] !== styleProps || $[15] !== t5) {
    t6 = /*#__PURE__*/jsx("div", {
      role: "presentation",
      ...t3,
      ...styleProps,
      children: t5
    });
    $[13] = t3;
    $[14] = styleProps;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  return t6;
});
function useInputStyles(props, state) {
  let className = classNames(css({
    backgroundColor: tokenSchema.color.background.canvas,
    border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
    borderRadius: tokenSchema.size.radius.regular,
    cursor: 'text',
    height: tokenSchema.size.element.regular,
    lineHeight: tokenSchema.typography.lineheight.small,
    outline: 0,
    overflow: 'visible',
    paddingBlock: tokenSchema.size.space.small,
    paddingInline: tokenSchema.size.space.medium,
    position: 'relative',
    textIndent: 0,
    verticalAlign: 'top',
    minWidth: tokenSchema.size.scale[2000],
    width: '100%',
    '&[data-invalid]': {
      borderColor: tokenSchema.color.alias.borderInvalid
    },
    '&[data-focused]': {
      borderColor: tokenSchema.color.alias.borderFocused
    },
    '&[data-focus-visible]': {
      boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
    },
    '&[data-disabled]': {
      backgroundColor: tokenSchema.color.alias.backgroundDisabled,
      borderColor: 'transparent'
    }
  }), props.className);
  return {
    ...toDataAttributes(state, {
      omitFalsyValues: true,
      trimBooleanKeys: true
    }),
    className,
    style: props.style
  };
}

const segmentClassList = new ClassList('InputSegment', ['editable']);
function InputSegment(t0) {
  const $ = c(10);
  let segment;
  let state;
  let otherProps;
  if ($[0] !== t0) {
    ({
      segment,
      state,
      ...otherProps
    } = t0);
    $[0] = t0;
    $[1] = segment;
    $[2] = state;
    $[3] = otherProps;
  } else {
    segment = $[1];
    state = $[2];
    otherProps = $[3];
  }
  if (segment.type === "literal") {
    let t1;
    if ($[4] !== segment) {
      t1 = /*#__PURE__*/jsx(LiteralSegment, {
        segment: segment
      });
      $[4] = segment;
      $[5] = t1;
    } else {
      t1 = $[5];
    }
    return t1;
  }
  let t1;
  if ($[6] !== segment || $[7] !== state || $[8] !== otherProps) {
    t1 = /*#__PURE__*/jsx(EditableSegment, {
      segment: segment,
      state: state,
      ...otherProps
    });
    $[6] = segment;
    $[7] = state;
    $[8] = otherProps;
    $[9] = t1;
  } else {
    t1 = $[9];
  }
  return t1;
}

/** A separator, e.g. punctuation like "/" or "." */
function LiteralSegment({
  segment
}) {
  return /*#__PURE__*/jsx(Text, {
    elementType: "span",
    "aria-hidden": "true",
    trim: false,
    UNSAFE_className: css({
      color: tokenSchema.color.foreground.neutral,
      userSelect: 'none',
      whiteSpace: 'pre',
      [`${segmentClassList.selector('editable')}[data-placeholder] ~ &`]: {
        color: tokenSchema.color.foreground.neutralTertiary
      }
    }),
    "data-testid": segment.type === 'literal' ? undefined : segment.type,
    children: segment.text
  });
}
function EditableSegment(t0) {
  const $ = c(15);
  const {
    segment,
    state
  } = t0;
  const ref = useRef(null);
  const {
    segmentProps
  } = useDateSegment(segment, state, ref);
  const styleProps = useEditableSectionStyles(segment);
  let t1;
  if ($[0] !== styleProps.style || $[1] !== segmentProps.style) {
    t1 = {
      ...styleProps.style,
      ...segmentProps.style
    };
    $[0] = styleProps.style;
    $[1] = segmentProps.style;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const t2 = !segment.isPlaceholder;
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = css({
      display: "block",
      fontStyle: "italic",
      height: "0",
      pointerEvents: "none",
      textAlign: "center",
      visibility: "hidden",
      width: "100%",
      "&[data-hidden=false]": {
        height: "auto",
        visibility: "visible"
      }
    });
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== t2 || $[5] !== segment.placeholder) {
    t4 = /*#__PURE__*/jsx("span", {
      "aria-hidden": "true",
      "data-hidden": t2,
      className: t3,
      children: segment.placeholder
    });
    $[4] = t2;
    $[5] = segment.placeholder;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const t5 = !segment.isPlaceholder && segment.text;
  let t6;
  if ($[7] !== segmentProps || $[8] !== styleProps || $[9] !== t1 || $[10] !== ref || $[11] !== segment.type || $[12] !== t4 || $[13] !== t5) {
    t6 = /*#__PURE__*/jsxs("div", {
      ...segmentProps,
      ...styleProps,
      style: t1,
      ref: ref,
      "data-testid": segment.type,
      children: [t4, t5]
    });
    $[7] = segmentProps;
    $[8] = styleProps;
    $[9] = t1;
    $[10] = ref;
    $[11] = segment.type;
    $[12] = t4;
    $[13] = t5;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  return t6;
}
function useEditableSectionStyles(segment) {
  return {
    ...toDataAttributes({
      placeholder: segment.isPlaceholder,
      readonly: !segment.isEditable
    }, {
      omitFalsyValues: true
    }),
    className: classNames(css({
      borderRadius: tokenSchema.size.radius.small,
      color: tokenSchema.color.foreground.neutral,
      paddingInline: tokenSchema.size.space.xsmall,
      // text styles
      fontFamily: tokenSchema.typography.fontFamily.base,
      fontSize: tokenSchema.typography.text.regular.size,
      fontVariantNumeric: 'tabular-nums',
      fontWeight: tokenSchema.typography.fontWeight.regular,
      lineHeight: tokenSchema.typography.lineheight.small,
      whiteSpace: 'nowrap',
      MozOsxFontSmoothing: 'auto',
      WebkitFontSmoothing: 'auto',
      '[dir=ltr] &': {
        textAlign: 'right'
      },
      '[dir=rtl] &': {
        textAlign: 'left'
      },
      '&[data-placeholder]': {
        color: tokenSchema.color.foreground.neutralTertiary
      },
      '&:focus': {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        color: tokenSchema.color.foreground.onEmphasis,
        outline: 'none'
      }
    }), segmentClassList.element('editable')),
    style: {
      minWidth: segment.maxValue != null ? String(segment.maxValue).length + 'ch' : undefined
    }
  };
}

function useFormatHelpText(props) {
  const $ = c(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      dateStyle: "short"
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const formatter = useDateFormatter(t0);
  const displayNames = useDisplayNames();
  let t1;
  bb0: {
    if (props.description) {
      t1 = props.description;
      break bb0;
    }
    if (props.showFormatHelpText) {
      let t2;
      if ($[1] !== formatter || $[2] !== displayNames) {
        let t3;
        if ($[4] !== displayNames) {
          t3 = s => {
            if (s.type === "literal") {
              return s.value;
            }
            return displayNames.of(s.type);
          };
          $[4] = displayNames;
          $[5] = t3;
        } else {
          t3 = $[5];
        }
        t2 = formatter.formatToParts(new Date()).map(t3).join(" ");
        $[1] = formatter;
        $[2] = displayNames;
        $[3] = t2;
      } else {
        t2 = $[3];
      }
      t1 = t2;
      break bb0;
    }
    t1 = "";
  }
  return t1;
}
function useVisibleMonths(maxVisibleMonths) {
  const $ = c(6);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = getVisibleMonths();
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [visibleMonths, setVisibleMonths] = useState(t0);
  let t1;
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      const onResize = () => setVisibleMonths(getVisibleMonths());
      onResize();
      window.addEventListener("resize", onResize);
      return () => {
        window.removeEventListener("resize", onResize);
      };
    };
    t2 = [];
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  useLayoutEffect(t1, t2);
  let t3;
  if ($[3] !== visibleMonths || $[4] !== maxVisibleMonths) {
    t3 = Math.min(visibleMonths, maxVisibleMonths, 3);
    $[3] = visibleMonths;
    $[4] = maxVisibleMonths;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return Math.max(1, t3);
}

// these calculations are brittle, they depend on styling decisions in both:
// - the `CalendarBase` component, from "@keystar/ui/calendar"
// - the `DatePickerPopover` component
function getVisibleMonths() {
  if (typeof window === 'undefined') {
    return 1;
  }
  let monthWidth = 248;
  let gap = 16;
  let dialogPadding = 20;
  return Math.floor((window.innerWidth - dialogPadding * 2) / (monthWidth + gap));
}
function useFocusManagerRef(ref) {
  const $ = c(2);
  const domRef = useObjectRef(ref);
  let t0;
  if ($[0] !== domRef) {
    t0 = () => ({
      ...domRef.current,
      focus() {
        createFocusManager(domRef).focusFirst({
          tabbable: true
        });
      }
    });
    $[0] = domRef;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  useImperativeHandle(ref, t0);
  return domRef;
}

function DateField(props, ref) {
  const $ = c(27);
  props = useProviderProps(props);
  const {
    autoFocus,
    isDisabled,
    isReadOnly,
    isRequired
  } = props;
  const domRef = useFocusManagerRef(ref);
  const {
    locale
  } = useLocale();
  let t0;
  if ($[0] !== props || $[1] !== locale) {
    t0 = {
      ...props,
      locale,
      createCalendar
    };
    $[0] = props;
    $[1] = locale;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let state;
  state = useDateFieldState(t0);
  const fieldRef = useRef(null);
  const inputRef = useRef(null);
  let t1;
  if ($[3] !== props || $[4] !== inputRef) {
    t1 = {
      ...props,
      inputRef
    };
    $[3] = props;
    $[4] = inputRef;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let {
    descriptionProps,
    errorMessageProps,
    fieldProps,
    inputProps,
    labelProps
  } = useDateField(t1, state, fieldRef);
  const description = useFormatHelpText(props);
  if (description && !props.description) {
    let _descriptionProps;
    if ($[6] !== descriptionProps) {
      const {
        id,
        ...t2
      } = descriptionProps;
      _descriptionProps = t2;
      $[6] = descriptionProps;
      $[7] = _descriptionProps;
    } else {
      _descriptionProps = $[7];
    }
    descriptionProps = _descriptionProps;
  }
  if (props.errorMessage) {
    state = {
      ...state,
      validationState: "invalid"
    };
  }
  const t2 = state;
  const t3 = state.segments.map((segment, i) => /*#__PURE__*/jsx(InputSegment, {
    segment: segment,
    state: state,
    isDisabled: isDisabled,
    isReadOnly: isReadOnly,
    isRequired: isRequired
  }, i));
  let t4;
  if ($[8] !== inputProps || $[9] !== inputRef) {
    t4 = /*#__PURE__*/jsx("input", {
      ...inputProps,
      ref: inputRef
    });
    $[8] = inputProps;
    $[9] = inputRef;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== fieldRef || $[12] !== fieldProps || $[13] !== isDisabled || $[14] !== autoFocus || $[15] !== t2.validationState || $[16] !== t3 || $[17] !== t4) {
    t5 = /*#__PURE__*/jsxs(Input, {
      ref: fieldRef,
      fieldProps: fieldProps,
      isDisabled: isDisabled,
      autoFocus: autoFocus,
      validationState: t2.validationState,
      children: [t3, t4]
    });
    $[11] = fieldRef;
    $[12] = fieldProps;
    $[13] = isDisabled;
    $[14] = autoFocus;
    $[15] = t2.validationState;
    $[16] = t3;
    $[17] = t4;
    $[18] = t5;
  } else {
    t5 = $[18];
  }
  let t6;
  if ($[19] !== props || $[20] !== domRef || $[21] !== description || $[22] !== labelProps || $[23] !== descriptionProps || $[24] !== errorMessageProps || $[25] !== t5) {
    t6 = /*#__PURE__*/jsx(FieldPrimitive, {
      ...props,
      ref: domRef,
      description: description,
      labelElementType: "span",
      labelProps: labelProps,
      descriptionProps: descriptionProps,
      errorMessageProps: errorMessageProps,
      children: t5
    });
    $[19] = props;
    $[20] = domRef;
    $[21] = description;
    $[22] = labelProps;
    $[23] = descriptionProps;
    $[24] = errorMessageProps;
    $[25] = t5;
    $[26] = t6;
  } else {
    t6 = $[26];
  }
  return t6;
}

// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref

/**
 * DateFields allow users to enter and edit date and time values using a keyboard.
 * Each part of a date value is displayed in an individually editable segment.
 */
const _DateField = /*#__PURE__*/React.forwardRef(DateField);

/** @private for internal use only. */
function DatePickerField(props) {
  const $ = c(22);
  const {
    isDisabled,
    isReadOnly,
    isRequired,
    rangeFieldType
  } = props;
  const fieldRef = useRef(null);
  const inputRef = useRef(null);
  const {
    locale
  } = useLocale();
  let t0;
  if ($[0] !== props || $[1] !== locale) {
    t0 = {
      ...props,
      locale,
      createCalendar
    };
    $[0] = props;
    $[1] = locale;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const state = useDateFieldState(t0);
  let t1;
  if ($[3] !== props || $[4] !== inputRef) {
    t1 = {
      ...props,
      inputRef
    };
    $[3] = props;
    $[4] = inputRef;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const {
    fieldProps,
    inputProps
  } = useDateField(t1, state, fieldRef);
  const t2 = props["data-testid"];
  let t3;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = css({
      display: "flex",
      "&[data-range=start]": {
        paddingInlineEnd: tokenSchema.size.space.regular
      },
      "&[data-range=end]": {
        paddingInlineStart: tokenSchema.size.space.regular
      }
    });
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  let t4;
  if ($[7] !== state || $[8] !== isDisabled || $[9] !== isReadOnly || $[10] !== isRequired) {
    t4 = state.segments.map((segment, i) => /*#__PURE__*/jsx(InputSegment, {
      segment: segment,
      state: state,
      isDisabled: isDisabled,
      isReadOnly: isReadOnly,
      isRequired: isRequired
    }, i));
    $[7] = state;
    $[8] = isDisabled;
    $[9] = isReadOnly;
    $[10] = isRequired;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] !== inputProps || $[13] !== inputRef) {
    t5 = /*#__PURE__*/jsx("input", {
      ...inputProps,
      ref: inputRef
    });
    $[12] = inputProps;
    $[13] = inputRef;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  let t6;
  if ($[15] !== fieldProps || $[16] !== t2 || $[17] !== rangeFieldType || $[18] !== fieldRef || $[19] !== t4 || $[20] !== t5) {
    t6 = /*#__PURE__*/jsxs("div", {
      ...fieldProps,
      "data-testid": t2,
      "data-range": rangeFieldType,
      className: t3,
      ref: fieldRef,
      children: [t4, t5]
    });
    $[15] = fieldProps;
    $[16] = t2;
    $[17] = rangeFieldType;
    $[18] = fieldRef;
    $[19] = t4;
    $[20] = t5;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  return t6;
}

function DatePickerPopover(t0) {
  const $ = c(21);
  let props;
  let state;
  if ($[0] !== t0) {
    ({
      state,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = props;
    $[2] = state;
  } else {
    props = $[1];
    state = $[2];
  }
  const scrollRef = useRef(null);
  const {
    direction
  } = useLocale();
  const isMobile = useIsMobileDevice();
  const {
    dialogProps
  } = useDialog(props.dialogProps, scrollRef);
  let t1;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = css({
      display: "flex",
      justifyContent: "center",
      maxHeight: "inherit",
      outline: 0,
      overflowY: "auto",
      WebkitOverflowScrolling: "touch"
    });
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = css({
      paddingInline: tokenSchema.size.space.medium,
      paddingTop: tokenSchema.size.space.medium,
      "&::after": {
        content: "\"\"",
        display: "block",
        height: tokenSchema.size.space.medium
      }
    });
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== props.children) {
    t3 = /*#__PURE__*/jsx("div", {
      className: t2,
      children: props.children
    });
    $[5] = props.children;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  let t4;
  if ($[7] !== scrollRef || $[8] !== dialogProps || $[9] !== t3) {
    t4 = /*#__PURE__*/jsx("div", {
      ref: scrollRef,
      className: t1,
      ...dialogProps,
      children: t3
    });
    $[7] = scrollRef;
    $[8] = dialogProps;
    $[9] = t3;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  const content = t4;
  let overlay;
  if (isMobile) {
    let t5;
    if ($[11] !== state || $[12] !== content) {
      t5 = /*#__PURE__*/jsx(Tray, {
        state: state,
        children: content
      });
      $[11] = state;
      $[12] = content;
      $[13] = t5;
    } else {
      t5 = $[13];
    }
    overlay = t5;
  } else {
    const t5 = direction === "rtl" ? "bottom right" : "bottom left";
    let t6;
    if ($[14] !== t5 || $[15] !== scrollRef || $[16] !== props.shouldFlip || $[17] !== props.triggerRef || $[18] !== state || $[19] !== content) {
      t6 = /*#__PURE__*/jsx(Popover, {
        hideArrow: true,
        placement: t5,
        scrollRef: scrollRef,
        shouldFlip: props.shouldFlip,
        state: state,
        triggerRef: props.triggerRef,
        children: content
      });
      $[14] = t5;
      $[15] = scrollRef;
      $[16] = props.shouldFlip;
      $[17] = props.triggerRef;
      $[18] = state;
      $[19] = content;
      $[20] = t6;
    } else {
      t6 = $[20];
    }
    overlay = t6;
  }
  return overlay;
}

function DatePicker(props, forwardedRef) {
  const $ = c(62);
  props = useProviderProps(props);
  const {
    autoFocus,
    isDisabled,
    isReadOnly,
    maxVisibleMonths: t0,
    pageBehavior
  } = props;
  const maxVisibleMonths = t0 === undefined ? 1 : t0;
  let t1;
  if ($[0] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[0] = isDisabled;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t1);
  const triggerRef = useRef(null);
  const domRef = useFocusManagerRef(forwardedRef);
  let state = useDatePickerState(props);
  if (props.errorMessage) {
    let t2;
    if ($[2] !== state) {
      t2 = {
        ...state,
        validationState: "invalid"
      };
      $[2] = state;
      $[3] = t2;
    } else {
      t2 = $[3];
    }
    state = t2;
  }
  let {
    buttonProps,
    calendarProps,
    descriptionProps,
    dialogProps,
    errorMessageProps,
    fieldProps,
    groupProps,
    labelProps
  } = useDatePicker(props, state, triggerRef);
  let t2;
  if ($[4] !== autoFocus) {
    t2 = {
      within: true,
      isTextInput: true,
      autoFocus
    };
    $[4] = autoFocus;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const {
    isFocused,
    isFocusVisible,
    focusProps
  } = useFocusRing(t2);
  let t3;
  if ($[6] !== autoFocus) {
    t3 = {
      within: false,
      isTextInput: false,
      autoFocus
    };
    $[6] = autoFocus;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  const {
    isFocused: isFocusedButton,
    focusProps: focusPropsButton
  } = useFocusRing(t3);
  const description = useFormatHelpText(props);
  if (description && !props.description) {
    let _descriptionProps;
    if ($[8] !== descriptionProps) {
      const {
        id,
        ...t4
      } = descriptionProps;
      _descriptionProps = t4;
      $[8] = descriptionProps;
      $[9] = _descriptionProps;
    } else {
      _descriptionProps = $[9];
    }
    descriptionProps = _descriptionProps;
  }
  const visibleMonths = useVisibleMonths(maxVisibleMonths);
  const t4 = isFocusVisible && !isFocusedButton;
  const t5 = state.validationState === "invalid";
  let t6;
  if ($[10] !== isHovered || $[11] !== isFocused || $[12] !== t4 || $[13] !== isDisabled || $[14] !== isReadOnly || $[15] !== t5) {
    t6 = {
      isHovered,
      isFocused,
      isFocusVisible: t4,
      isDisabled,
      isReadOnly,
      isInvalid: t5
    };
    $[10] = isHovered;
    $[11] = isFocused;
    $[12] = t4;
    $[13] = isDisabled;
    $[14] = isReadOnly;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  const styleProps = usePickerStyles(t6);
  let t7;
  if ($[17] !== groupProps || $[18] !== hoverProps || $[19] !== focusProps) {
    t7 = mergeProps(groupProps, hoverProps, focusProps);
    $[17] = groupProps;
    $[18] = hoverProps;
    $[19] = focusProps;
    $[20] = t7;
  } else {
    t7 = $[20];
  }
  let t8;
  if ($[21] !== fieldProps) {
    t8 = /*#__PURE__*/jsx(DatePickerField, {
      ...fieldProps,
      "data-testid": "date-field"
    });
    $[21] = fieldProps;
    $[22] = t8;
  } else {
    t8 = $[22];
  }
  let t9;
  if ($[23] !== isDisabled || $[24] !== state.validationState || $[25] !== styleProps.input || $[26] !== t8) {
    t9 = /*#__PURE__*/jsx(Input, {
      isDisabled: isDisabled,
      validationState: state.validationState,
      disableFocusRing: true,
      ...styleProps.input,
      children: t8
    });
    $[23] = isDisabled;
    $[24] = state.validationState;
    $[25] = styleProps.input;
    $[26] = t8;
    $[27] = t9;
  } else {
    t9 = $[27];
  }
  let t10;
  if ($[28] !== buttonProps || $[29] !== focusPropsButton) {
    t10 = mergeProps(buttonProps, focusPropsButton);
    $[28] = buttonProps;
    $[29] = focusPropsButton;
    $[30] = t10;
  } else {
    t10 = $[30];
  }
  const t11 = isDisabled || isReadOnly;
  let t12;
  if ($[31] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = /*#__PURE__*/jsx(Icon, {
      src: calendarDaysIcon
    });
    $[31] = t12;
  } else {
    t12 = $[31];
  }
  let t13;
  if ($[32] !== t10 || $[33] !== styleProps.button || $[34] !== state.validationState || $[35] !== t11) {
    t13 = /*#__PURE__*/jsx(FieldButton, {
      ...t10,
      ...styleProps.button,
      validationState: state.validationState,
      isDisabled: t11,
      children: t12
    });
    $[32] = t10;
    $[33] = styleProps.button;
    $[34] = state.validationState;
    $[35] = t11;
    $[36] = t13;
  } else {
    t13 = $[36];
  }
  let t14;
  if ($[37] !== calendarProps || $[38] !== visibleMonths || $[39] !== pageBehavior) {
    t14 = /*#__PURE__*/jsx(Calendar, {
      ...calendarProps,
      visibleMonths: visibleMonths,
      pageBehavior: pageBehavior
    });
    $[37] = calendarProps;
    $[38] = visibleMonths;
    $[39] = pageBehavior;
    $[40] = t14;
  } else {
    t14 = $[40];
  }
  let t15;
  if ($[41] !== dialogProps || $[42] !== props.shouldFlip || $[43] !== state || $[44] !== triggerRef || $[45] !== t14) {
    t15 = /*#__PURE__*/jsx(DatePickerPopover, {
      dialogProps: dialogProps,
      shouldFlip: props.shouldFlip,
      state: state,
      triggerRef: triggerRef,
      children: t14
    });
    $[41] = dialogProps;
    $[42] = props.shouldFlip;
    $[43] = state;
    $[44] = triggerRef;
    $[45] = t14;
    $[46] = t15;
  } else {
    t15 = $[46];
  }
  let t16;
  if ($[47] !== t7 || $[48] !== styleProps.root || $[49] !== triggerRef || $[50] !== t9 || $[51] !== t13 || $[52] !== t15) {
    t16 = /*#__PURE__*/jsxs("div", {
      ...t7,
      ...styleProps.root,
      ref: triggerRef,
      children: [t9, t13, t15]
    });
    $[47] = t7;
    $[48] = styleProps.root;
    $[49] = triggerRef;
    $[50] = t9;
    $[51] = t13;
    $[52] = t15;
    $[53] = t16;
  } else {
    t16 = $[53];
  }
  let t17;
  if ($[54] !== props || $[55] !== domRef || $[56] !== description || $[57] !== labelProps || $[58] !== descriptionProps || $[59] !== errorMessageProps || $[60] !== t16) {
    t17 = /*#__PURE__*/jsx(FieldPrimitive, {
      ...props,
      ref: domRef,
      description: description,
      labelElementType: "span",
      labelProps: labelProps,
      descriptionProps: descriptionProps,
      errorMessageProps: errorMessageProps,
      children: t16
    });
    $[54] = props;
    $[55] = domRef;
    $[56] = description;
    $[57] = labelProps;
    $[58] = descriptionProps;
    $[59] = errorMessageProps;
    $[60] = t16;
    $[61] = t17;
  } else {
    t17 = $[61];
  }
  return t17;
}

// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref

/**
 * DatePickers combine a DateField and a Calendar popover to allow users to
 * enter or select a date and time value.
 */
const _DatePicker = /*#__PURE__*/React.forwardRef(DatePicker);
function usePickerStyles(state) {
  let root = {
    ...toDataAttributes(state, {
      omitFalsyValues: true,
      trimBooleanKeys: true
    }),
    className: css({
      borderRadius: tokenSchema.size.radius.regular,
      display: 'flex',
      position: 'relative',
      '&::after': {
        borderRadius: `inherit`,
        content: '""',
        inset: tokenSchema.size.border.regular,
        margin: 0,
        pointerEvents: 'none',
        position: 'absolute',
        transition: transition(['box-shadow', 'margin'], {
          easing: 'easeOut'
        })
      },
      '&[data-focus-visible]::after': {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`
      }
    })
  };
  let input = {
    className: css({
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      borderInlineEndWidth: 0,
      [`.${root.className}[data-focused] &`]: {
        borderColor: tokenSchema.color.alias.borderFocused
      }
    })
  };
  let button = {
    UNSAFE_className: css({
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      [`.${root.className}[data-read-only] &`]: {
        borderColor: tokenSchema.color.alias.borderIdle
      },
      [`.${root.className}[data-invalid] &`]: {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [`.${root.className}[data-focused] &`]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [`.${root.className}[data-disabled] &`]: {
        borderColor: 'transparent'
      }
    })
  };
  return {
    button,
    input,
    root
  };
}

function DateRangePicker(props, forwardedRef) {
  const $ = c(66);
  props = useProviderProps(props);
  const {
    autoFocus,
    isDisabled,
    isReadOnly,
    maxVisibleMonths: t0,
    pageBehavior
  } = props;
  const maxVisibleMonths = t0 === undefined ? 1 : t0;
  let t1;
  if ($[0] !== isDisabled) {
    t1 = {
      isDisabled
    };
    $[0] = isDisabled;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t1);
  const triggerRef = useRef(null);
  const domRef = useFocusManagerRef(forwardedRef);
  let state = useDateRangePickerState(props);
  if (props.errorMessage) {
    let t2;
    if ($[2] !== state) {
      t2 = {
        ...state,
        validationState: "invalid"
      };
      $[2] = state;
      $[3] = t2;
    } else {
      t2 = $[3];
    }
    state = t2;
  }
  let {
    buttonProps,
    calendarProps,
    descriptionProps,
    dialogProps,
    endFieldProps,
    errorMessageProps,
    groupProps,
    labelProps,
    startFieldProps
  } = useDateRangePicker(props, state, triggerRef);
  let t2;
  if ($[4] !== autoFocus) {
    t2 = {
      within: true,
      isTextInput: true,
      autoFocus
    };
    $[4] = autoFocus;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const {
    isFocused,
    isFocusVisible,
    focusProps
  } = useFocusRing(t2);
  let t3;
  if ($[6] !== autoFocus) {
    t3 = {
      within: false,
      isTextInput: false,
      autoFocus
    };
    $[6] = autoFocus;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  const {
    isFocused: isFocusedButton,
    focusProps: focusPropsButton
  } = useFocusRing(t3);
  const description = useFormatHelpText(props);
  if (description && !props.description) {
    let _descriptionProps;
    if ($[8] !== descriptionProps) {
      const {
        id,
        ...t4
      } = descriptionProps;
      _descriptionProps = t4;
      $[8] = descriptionProps;
      $[9] = _descriptionProps;
    } else {
      _descriptionProps = $[9];
    }
    descriptionProps = _descriptionProps;
  }
  const visibleMonths = useVisibleMonths(maxVisibleMonths);
  const t4 = isFocusVisible && !isFocusedButton;
  const t5 = state.validationState === "invalid";
  let t6;
  if ($[10] !== isHovered || $[11] !== isFocused || $[12] !== t4 || $[13] !== isDisabled || $[14] !== isReadOnly || $[15] !== t5) {
    t6 = {
      isHovered,
      isFocused,
      isFocusVisible: t4,
      isDisabled,
      isReadOnly,
      isInvalid: t5
    };
    $[10] = isHovered;
    $[11] = isFocused;
    $[12] = t4;
    $[13] = isDisabled;
    $[14] = isReadOnly;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  const styleProps = usePickerStyles(t6);
  let t7;
  if ($[17] !== groupProps || $[18] !== hoverProps || $[19] !== focusProps) {
    t7 = mergeProps(groupProps, hoverProps, focusProps);
    $[17] = groupProps;
    $[18] = hoverProps;
    $[19] = focusProps;
    $[20] = t7;
  } else {
    t7 = $[20];
  }
  let t8;
  if ($[21] !== startFieldProps) {
    t8 = /*#__PURE__*/jsx(DatePickerField, {
      rangeFieldType: "start",
      "data-testid": "start-date",
      ...startFieldProps
    });
    $[21] = startFieldProps;
    $[22] = t8;
  } else {
    t8 = $[22];
  }
  let t9;
  if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = /*#__PURE__*/jsx(Text, {
      "aria-hidden": "true",
      trim: false,
      children: "\u2014"
    });
    $[23] = t9;
  } else {
    t9 = $[23];
  }
  let t10;
  if ($[24] !== endFieldProps) {
    t10 = /*#__PURE__*/jsx(DatePickerField, {
      rangeFieldType: "end",
      "data-testid": "end-date",
      ...endFieldProps
    });
    $[24] = endFieldProps;
    $[25] = t10;
  } else {
    t10 = $[25];
  }
  let t11;
  if ($[26] !== isDisabled || $[27] !== state.validationState || $[28] !== styleProps.input || $[29] !== t8 || $[30] !== t10) {
    t11 = /*#__PURE__*/jsxs(Input, {
      isDisabled: isDisabled,
      validationState: state.validationState,
      disableFocusRing: true,
      ...styleProps.input,
      children: [t8, t9, t10]
    });
    $[26] = isDisabled;
    $[27] = state.validationState;
    $[28] = styleProps.input;
    $[29] = t8;
    $[30] = t10;
    $[31] = t11;
  } else {
    t11 = $[31];
  }
  let t12;
  if ($[32] !== buttonProps || $[33] !== focusPropsButton) {
    t12 = mergeProps(buttonProps, focusPropsButton);
    $[32] = buttonProps;
    $[33] = focusPropsButton;
    $[34] = t12;
  } else {
    t12 = $[34];
  }
  const t13 = isDisabled || isReadOnly;
  let t14;
  if ($[35] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = /*#__PURE__*/jsx(Icon, {
      src: calendarDaysIcon
    });
    $[35] = t14;
  } else {
    t14 = $[35];
  }
  let t15;
  if ($[36] !== t12 || $[37] !== styleProps.button || $[38] !== state.validationState || $[39] !== t13) {
    t15 = /*#__PURE__*/jsx(FieldButton, {
      ...t12,
      ...styleProps.button,
      validationState: state.validationState,
      isDisabled: t13,
      children: t14
    });
    $[36] = t12;
    $[37] = styleProps.button;
    $[38] = state.validationState;
    $[39] = t13;
    $[40] = t15;
  } else {
    t15 = $[40];
  }
  let t16;
  if ($[41] !== calendarProps || $[42] !== visibleMonths || $[43] !== pageBehavior) {
    t16 = /*#__PURE__*/jsx(RangeCalendar, {
      ...calendarProps,
      visibleMonths: visibleMonths,
      pageBehavior: pageBehavior
    });
    $[41] = calendarProps;
    $[42] = visibleMonths;
    $[43] = pageBehavior;
    $[44] = t16;
  } else {
    t16 = $[44];
  }
  let t17;
  if ($[45] !== dialogProps || $[46] !== props.shouldFlip || $[47] !== state || $[48] !== triggerRef || $[49] !== t16) {
    t17 = /*#__PURE__*/jsx(DatePickerPopover, {
      dialogProps: dialogProps,
      shouldFlip: props.shouldFlip,
      state: state,
      triggerRef: triggerRef,
      children: t16
    });
    $[45] = dialogProps;
    $[46] = props.shouldFlip;
    $[47] = state;
    $[48] = triggerRef;
    $[49] = t16;
    $[50] = t17;
  } else {
    t17 = $[50];
  }
  let t18;
  if ($[51] !== t7 || $[52] !== styleProps.root || $[53] !== triggerRef || $[54] !== t11 || $[55] !== t15 || $[56] !== t17) {
    t18 = /*#__PURE__*/jsxs("div", {
      ...t7,
      ...styleProps.root,
      ref: triggerRef,
      children: [t11, t15, t17]
    });
    $[51] = t7;
    $[52] = styleProps.root;
    $[53] = triggerRef;
    $[54] = t11;
    $[55] = t15;
    $[56] = t17;
    $[57] = t18;
  } else {
    t18 = $[57];
  }
  let t19;
  if ($[58] !== props || $[59] !== domRef || $[60] !== description || $[61] !== labelProps || $[62] !== descriptionProps || $[63] !== errorMessageProps || $[64] !== t18) {
    t19 = /*#__PURE__*/jsx(FieldPrimitive, {
      ...props,
      ref: domRef,
      description: description,
      labelElementType: "span",
      labelProps: labelProps,
      descriptionProps: descriptionProps,
      errorMessageProps: errorMessageProps,
      children: t18
    });
    $[58] = props;
    $[59] = domRef;
    $[60] = description;
    $[61] = labelProps;
    $[62] = descriptionProps;
    $[63] = errorMessageProps;
    $[64] = t18;
    $[65] = t19;
  } else {
    t19 = $[65];
  }
  return t19;
}

// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref

/**
 * DateRangePickers combine two DateFields and a RangeCalendar popover to allow users
 * to enter or select a date and time range.
 */
const _DateRangePicker = /*#__PURE__*/React.forwardRef(DateRangePicker);

function TimeField(props, ref) {
  const $ = c(17);
  props = useProviderProps(props);
  const {
    autoFocus,
    isDisabled,
    isReadOnly,
    isRequired
  } = props;
  const domRef = useFocusManagerRef(ref);
  const {
    locale
  } = useLocale();
  let t0;
  if ($[0] !== props || $[1] !== locale) {
    t0 = {
      ...props,
      locale
    };
    $[0] = props;
    $[1] = locale;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let state;
  state = useTimeFieldState(t0);
  const inputRef = useRef(null);
  const {
    labelProps,
    fieldProps,
    descriptionProps,
    errorMessageProps
  } = useTimeField(props, state, inputRef);
  if (props.errorMessage) {
    state = {
      ...state,
      validationState: "invalid"
    };
  }
  const t1 = state;
  const t2 = state.segments.map((segment, i) => /*#__PURE__*/jsx(InputSegment, {
    segment: segment,
    state: state,
    isDisabled: isDisabled,
    isReadOnly: isReadOnly,
    isRequired: isRequired
  }, i));
  let t3;
  if ($[3] !== inputRef || $[4] !== fieldProps || $[5] !== isDisabled || $[6] !== autoFocus || $[7] !== t1.validationState || $[8] !== t2) {
    t3 = /*#__PURE__*/jsx(Input, {
      ref: inputRef,
      fieldProps: fieldProps,
      isDisabled: isDisabled,
      autoFocus: autoFocus,
      validationState: t1.validationState,
      children: t2
    });
    $[3] = inputRef;
    $[4] = fieldProps;
    $[5] = isDisabled;
    $[6] = autoFocus;
    $[7] = t1.validationState;
    $[8] = t2;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== props || $[11] !== domRef || $[12] !== labelProps || $[13] !== descriptionProps || $[14] !== errorMessageProps || $[15] !== t3) {
    t4 = /*#__PURE__*/jsx(FieldPrimitive, {
      ...props,
      ref: domRef,
      labelProps: labelProps,
      descriptionProps: descriptionProps,
      errorMessageProps: errorMessageProps,
      children: t3
    });
    $[10] = props;
    $[11] = domRef;
    $[12] = labelProps;
    $[13] = descriptionProps;
    $[14] = errorMessageProps;
    $[15] = t3;
    $[16] = t4;
  } else {
    t4 = $[16];
  }
  return t4;
}

// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref

/**
 * TimeFields allow users to enter and edit time values using a keyboard.
 * Each part of the time is displayed in an individually editable segment.
 */
const _TimeField = /*#__PURE__*/React.forwardRef(TimeField);

export { _DateField as DateField, _DatePicker as DatePicker, _DateRangePicker as DateRangePicker, _TimeField as TimeField };
