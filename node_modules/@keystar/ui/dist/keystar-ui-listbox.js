export { Item, Section } from '@react-stately/collections';
import { Icon } from '@keystar/ui/icon';
import { checkIcon } from '@keystar/ui/icon/icons/checkIcon';
import { ClearSlots, SlotProvider } from '@keystar/ui/slots';
import { tokenSchema, css, toDataAttributes, classNames, useStyleProps } from '@keystar/ui/style';
import { forwardRefWithAs } from '@keystar/ui/utils/ts';
import { jsx, jsxs } from 'react/jsx-runtime';
import { c } from './react-compiler-runtime-19061925.js';
import { useListState } from '@react-stately/list';
import { mergeProps, useObjectRef } from '@react-aria/utils';
import { createContext, useContext, useRef, Fragment, forwardRef } from 'react';
import { useFocusRing, FocusScope } from '@react-aria/focus';
import { useOption, useListBoxSection, useListBox } from '@react-aria/listbox';
import { useLocale, useLocalizedStringFormatter } from '@react-aria/i18n';
import { useVirtualizerItem, layoutInfoToStyle, Virtualizer, VirtualizerItem } from '@react-aria/virtualizer';
import { useProvider } from '@keystar/ui/core';
import { ProgressCircle } from '@keystar/ui/progress';
import { assert } from 'emery';
import { Rect, LayoutInfo } from '@react-stately/virtualizer';
import { ListLayout } from '@react-stately/layout';
import { useHover, isFocusVisible } from '@react-aria/interactions';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { Divider } from '@keystar/ui/layout';

// TODO: the styling is a mess. I need to clean it up.

/** Common list item component for menus and pickers. */
const ListItem = forwardRefWithAs(function ListItem(props, forwardedRef) {
  let {
    children,
    elementType: ElementType = 'div',
    descriptionProps,
    keyboardShortcutProps,
    labelProps,
    isFocused,
    isHovered,
    isPressed,
    isSelected,
    ...otherProps
  } = props;
  let gridGutter = tokenSchema.size.space.regular;
  let contentGutter = tokenSchema.size.space.medium;
  let focusIndicatorWidth = tokenSchema.size.space.xsmall;
  let gridClassname = css({
    display: 'grid',
    // listboxes (options) have selection indicators at the end, whilst menus have them at the start
    gridTemplateAreas: '". icon text . kbd checkmark ." ". icon description . kbd checkmark ."',
    gridTemplateColumns: `${gridGutter} auto 1fr ${contentGutter} auto ${tokenSchema.size.icon.regular} ${gridGutter}`,
    gridTemplateRows: '1fr auto',
    borderRadius: tokenSchema.size.radius.small,
    paddingBlock: tokenSchema.size.space.regular
  });
  let rootClassname = css({
    cursor: 'default',
    color: tokenSchema.color.alias.foregroundIdle,
    display: 'block',
    outline: 0,
    position: 'relative',
    paddingInline: tokenSchema.size.space.small,
    // indicate when external link? e.g. `&[href^=http]`
    'a&': {
      cursor: 'pointer'
    },
    '& .list-item-text': {
      marginBlock: `calc((${tokenSchema.size.icon.regular} - ${tokenSchema.typography.text.regular.capheight}) / 2)`
    },
    [`&:not([aria-disabled=true])`]: {
      '& .list-item-checkmark': {
        stroke: tokenSchema.color.alias.foregroundSelected
      },
      '& .list-item-icon': {
        color: tokenSchema.color.foreground.neutralSecondary
      }
    },
    // standard menu items: no selection indicator
    [`&[role=menuitem] .${gridClassname}`]: {
      gridTemplateAreas: '". icon text . kbd ." ". icon description . kbd ."',
      gridTemplateColumns: `${gridGutter} auto 1fr ${contentGutter} auto ${gridGutter}`
    },
    [[
    // selectable menu items: selection indicator at the start
    `&[role=menuitemcheckbox] .${gridClassname}, &[role=menuitemradio] .${gridClassname}`,
    // menus with _any_ selectable items must make space for the selection indicator
    `[data-selection=single] &[role=menuitem] .${gridClassname}, [data-selection=multiple] &[role=menuitem] .${gridClassname}`].join(', ')]: {
      gridTemplateAreas: '". checkmark icon text . kbd ." ". checkmark icon description . kbd ."',
      gridTemplateColumns: `${tokenSchema.size.space.small} ${tokenSchema.size.icon.medium} auto 1fr ${contentGutter} auto ${gridGutter}`
    },
    // hover
    [`&[aria-disabled=false]:hover .${gridClassname}, &[data-hovered] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered,
      color: tokenSchema.color.alias.foregroundHovered
    },
    // focus
    [`&[aria-disabled=false]:focus .${gridClassname}, &[data-focused] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered,
      color: tokenSchema.color.alias.foregroundHovered
    },
    // emphasise icons during interaction
    '&[aria-disabled=false]:hover .list-item-icon, &[data-hovered] .list-item-icon, &[aria-disabled=false]:focus .list-item-icon, &[data-focused] .list-item-icon': {
      color: tokenSchema.color.alias.foregroundIdle
    },
    // emphasise `kbd` during interaction
    '&[aria-disabled=false]:hover kbd, &[data-hovered] kbd, &[aria-disabled=false]:focus kbd, &[data-focused] kbd': {
      color: tokenSchema.color.alias.foregroundIdle
    },
    // press
    [`&[aria-disabled=false]:active .${gridClassname}, &[data-pressed] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundPressed,
      color: tokenSchema.color.alias.foregroundPressed
    },
    // focus indicator
    '&[data-focused]': {
      // [`& .${gridClassname}`]: {
      //   backgroundColor: tokenSchema.color.alias.backgroundSelected,
      // },
      '&::before': {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        borderRadius: focusIndicatorWidth,
        content: '""',
        insetBlock: tokenSchema.size.space.xsmall,
        insetInlineStart: 0,
        position: 'absolute',
        width: focusIndicatorWidth
      }
    },
    // disabled
    '&[aria-disabled=true]': {
      color: tokenSchema.color.alias.foregroundDisabled,
      '& kbd': {
        color: 'currentColor'
      },
      '& .list-item-checkmark': {
        stroke: 'currentColor'
      }
    }
  });
  const slots = {
    text: {
      ...labelProps,
      color: 'inherit',
      gridArea: 'text',
      // weight: 'medium',
      UNSAFE_className: 'list-item-text'
    },
    icon: {
      gridArea: 'icon',
      marginEnd: 'regular',
      UNSAFE_className: 'list-item-icon'
    },
    description: {
      color: 'neutralSecondary',
      gridArea: 'description',
      marginY: 'small',
      size: 'small',
      ...descriptionProps
    },
    kbd: {
      UNSAFE_className: css({
        alignItems: 'center',
        color: tokenSchema.color.foreground.neutralTertiary,
        display: 'flex',
        gridArea: 'kbd',
        height: tokenSchema.size.icon.regular
      }),
      ...keyboardShortcutProps
    }
  };
  return /*#__PURE__*/jsx(ElementType
  // NOTE: disabled and selected states should be stored against aria attributes
  , {
    ...toDataAttributes({
      focused: isFocused || undefined,
      hovered: isHovered || undefined,
      pressed: isPressed || undefined
    }),
    ...otherProps,
    ref: forwardedRef,
    className: classNames(rootClassname),
    children: /*#__PURE__*/jsx("div", {
      className: gridClassname,
      children: /*#__PURE__*/jsx(ClearSlots, {
        children: /*#__PURE__*/jsxs(SlotProvider, {
          slots: slots,
          children: [children, isSelected && /*#__PURE__*/jsx(Icon, {
            src: checkIcon,
            slot: "checkmark",
            strokeScaling: false,
            gridArea: "checkmark",
            UNSAFE_className: "list-item-checkmark"
          })]
        })
      })
    })
  });
});

const localizedMessages = {
  "ar-AE": {
    "loading": `جارٍ التحميل...`,
    "loadingMore": `جارٍ تحميل المزيد...`
  },
  "bg-BG": {
    "loading": `Зареждане...`,
    "loadingMore": `Зареждане на още...`
  },
  "cs-CZ": {
    "loading": `Načítání...`,
    "loadingMore": `Načítání dalších...`
  },
  "da-DK": {
    "loading": `Indlæser ...`,
    "loadingMore": `Indlæser flere ...`
  },
  "de-DE": {
    "loading": `Laden...`,
    "loadingMore": `Mehr laden ...`
  },
  "el-GR": {
    "loading": `Φόρτωση...`,
    "loadingMore": `Φόρτωση περισσότερων...`
  },
  "en-US": {
    "loading": `Loading…`,
    "loadingMore": `Loading more…`
  },
  "es-ES": {
    "loading": `Cargando…`,
    "loadingMore": `Cargando más…`
  },
  "et-EE": {
    "loading": `Laadimine...`,
    "loadingMore": `Laadi rohkem...`
  },
  "fi-FI": {
    "loading": `Ladataan…`,
    "loadingMore": `Ladataan lisää…`
  },
  "fr-FR": {
    "loading": `Chargement...`,
    "loadingMore": `Chargement supplémentaire...`
  },
  "he-IL": {
    "loading": `טוען...`,
    "loadingMore": `טוען עוד...`
  },
  "hr-HR": {
    "loading": `Učitavam...`,
    "loadingMore": `Učitavam još...`
  },
  "hu-HU": {
    "loading": `Betöltés folyamatban…`,
    "loadingMore": `Továbbiak betöltése folyamatban…`
  },
  "it-IT": {
    "loading": `Caricamento...`,
    "loadingMore": `Caricamento altri...`
  },
  "ja-JP": {
    "loading": `読み込み中...`,
    "loadingMore": `さらに読み込み中...`
  },
  "ko-KR": {
    "loading": `로드 중`,
    "loadingMore": `추가 로드 중`
  },
  "lt-LT": {
    "loading": `Įkeliama...`,
    "loadingMore": `Įkeliama daugiau...`
  },
  "lv-LV": {
    "loading": `Notiek ielāde...`,
    "loadingMore": `Tiek ielādēts vēl...`
  },
  "nb-NO": {
    "loading": `Laster inn ...`,
    "loadingMore": `Laster inn flere ...`
  },
  "nl-NL": {
    "loading": `Laden...`,
    "loadingMore": `Meer laden...`
  },
  "pl-PL": {
    "loading": `Ładowanie...`,
    "loadingMore": `Wczytywanie większej liczby...`
  },
  "pt-BR": {
    "loading": `Carregando...`,
    "loadingMore": `Carregando mais...`
  },
  "pt-PT": {
    "loading": `A carregar...`,
    "loadingMore": `A carregar mais...`
  },
  "ro-RO": {
    "loading": `Se încarcă...`,
    "loadingMore": `Se încarcă mai multe...`
  },
  "ru-RU": {
    "loading": `Загрузка...`,
    "loadingMore": `Дополнительная загрузка...`
  },
  "sk-SK": {
    "loading": `Načítava sa...`,
    "loadingMore": `Načítava sa viac...`
  },
  "sl-SI": {
    "loading": `Nalaganje...`,
    "loadingMore": `Nalaganje več vsebine...`
  },
  "sr-SP": {
    "loading": `Učitavam...`,
    "loadingMore": `Učitavam još...`
  },
  "sv-SE": {
    "loading": `Läser in...`,
    "loadingMore": `Läser in mer...`
  },
  "tr-TR": {
    "loading": `Yükleniyor...`,
    "loadingMore": `Daha fazla yükleniyor...`
  },
  "uk-UA": {
    "loading": `Завантаження…`,
    "loadingMore": `Завантаження інших об’єктів...`
  },
  "zh-CN": {
    "loading": `正在加载...`,
    "loadingMore": `正在加载更多...`
  },
  "zh-T": {
    "loading": `正在載入`,
    "loadingMore": `正在載入更多…`
  }
};

const ListBoxContext = /*#__PURE__*/createContext(null);
function useListBoxContext() {
  const context = useContext(ListBoxContext);
  assert(!!context, "ListBoxContext is missing");
  return context;
}

class ListBoxLayout extends ListLayout {
  isLoading = false;
  constructor(opts) {
    super(opts);
    this.placeholderHeight = opts.placeholderHeight;
    this.padding = opts.padding;
  }
  update(invalidationContext) {
    var _invalidationContext$;
    this.isLoading = ((_invalidationContext$ = invalidationContext.layoutOptions) === null || _invalidationContext$ === void 0 ? void 0 : _invalidationContext$.isLoading) || false;
    super.update(invalidationContext);
  }
  buildCollection() {
    let nodes = super.buildCollection(this.padding);
    let y = this.contentSize.height;
    if (this.isLoading) {
      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, 40);
      let loader = new LayoutInfo('loader', 'loader', rect);
      let node = {
        layoutInfo: loader,
        validRect: loader.rect
      };
      nodes.push(node);
      this.layoutNodes.set(loader.key, node);
      y = loader.rect.maxY;
    }
    if (nodes.length === 0) {
      var _this$placeholderHeig;
      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, (_this$placeholderHeig = this.placeholderHeight) !== null && _this$placeholderHeig !== void 0 ? _this$placeholderHeig : this.virtualizer.visibleRect.height);
      let placeholder = new LayoutInfo('placeholder', 'placeholder', rect);
      let node = {
        layoutInfo: placeholder,
        validRect: placeholder.rect
      };
      nodes.push(node);
      this.layoutNodes.set(placeholder.key, node);
      y = placeholder.rect.maxY;
    }
    this.contentSize.height = y + this.padding;
    return nodes;
  }
  buildSection(node, x, y) {
    var _section$children;
    // Synthesize a collection node for the header.
    let headerNode = {
      type: 'header',
      key: node.key + ':header',
      parentKey: node.key,
      value: null,
      level: node.level,
      hasChildNodes: false,
      childNodes: [],
      rendered: node.rendered,
      textValue: node.textValue
    };

    // Build layout node for it and adjust y offset of section children.
    let header = this.buildSectionHeader(headerNode, x, y);
    header.node = headerNode;
    header.layoutInfo.parentKey = node.key;
    this.layoutNodes.set(headerNode.key, header);
    y += header.layoutInfo.rect.height;
    let section = super.buildSection(node, x, y);
    (_section$children = section.children) === null || _section$children === void 0 || _section$children.unshift(header);
    return section;
  }
}

/** @private */
function ListBoxOption(props) {
  const $ = c(29);
  const {
    item,
    shouldSelectOnPressUp,
    shouldFocusOnHover,
    shouldUseVirtualFocus
  } = props;
  const {
    rendered,
    key
  } = item;
  const {
    state
  } = useListBoxContext();
  const ref = useRef(null);
  const t0 = item["aria-label"];
  let t1;
  if ($[0] !== t0 || $[1] !== key || $[2] !== shouldSelectOnPressUp || $[3] !== shouldFocusOnHover || $[4] !== shouldUseVirtualFocus) {
    t1 = {
      "aria-label": t0,
      key,
      shouldSelectOnPressUp,
      shouldFocusOnHover,
      isVirtualized: true,
      shouldUseVirtualFocus
    };
    $[0] = t0;
    $[1] = key;
    $[2] = shouldSelectOnPressUp;
    $[3] = shouldFocusOnHover;
    $[4] = shouldUseVirtualFocus;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const {
    optionProps,
    labelProps,
    descriptionProps,
    isSelected,
    isDisabled,
    isFocused,
    isPressed
  } = useOption(t1, state, ref);
  let t2;
  if ($[6] !== props || $[7] !== isDisabled) {
    t2 = {
      ...props,
      isDisabled
    };
    $[6] = props;
    $[7] = isDisabled;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t2);
  const {
    isFocusVisible: isFocusVisible$1,
    focusProps
  } = useFocusRing();
  let t3;
  if ($[9] !== rendered) {
    t3 = isReactText(rendered) ? /*#__PURE__*/jsx(Text, {
      children: rendered
    }) : rendered;
    $[9] = rendered;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  const contents = t3;
  let t4;
  if ($[11] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = isFocusVisible();
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  const isKeyboardModality = t4;
  const t5 = shouldUseVirtualFocus ? isFocused && isKeyboardModality : isFocusVisible$1;
  const t6 = isHovered && !shouldFocusOnHover || isFocused && !isKeyboardModality;
  let t7;
  if ($[12] !== shouldFocusOnHover || $[13] !== hoverProps) {
    t7 = shouldFocusOnHover ? {} : hoverProps;
    $[12] = shouldFocusOnHover;
    $[13] = hoverProps;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] !== optionProps || $[16] !== focusProps || $[17] !== t7) {
    t8 = mergeProps(optionProps, focusProps, t7);
    $[15] = optionProps;
    $[16] = focusProps;
    $[17] = t7;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] !== descriptionProps || $[20] !== labelProps || $[21] !== t5 || $[22] !== t6 || $[23] !== t8 || $[24] !== isPressed || $[25] !== isSelected || $[26] !== ref || $[27] !== contents) {
    t9 = /*#__PURE__*/jsx(ListItem, {
      descriptionProps: descriptionProps,
      labelProps: labelProps,
      isFocused: t5,
      isHovered: t6,
      ...t8,
      isPressed: isPressed,
      isSelected: isSelected,
      ref: ref,
      children: contents
    });
    $[19] = descriptionProps;
    $[20] = labelProps;
    $[21] = t5;
    $[22] = t6;
    $[23] = t8;
    $[24] = isPressed;
    $[25] = isSelected;
    $[26] = ref;
    $[27] = contents;
    $[28] = t9;
  } else {
    t9 = $[28];
  }
  return t9;
}

/** @private */
function ListBoxSection(props) {
  const $ = c(32);
  const {
    children,
    layoutInfo,
    headerLayoutInfo,
    virtualizer,
    item
  } = props;
  const t0 = item["aria-label"];
  let t1;
  if ($[0] !== item.rendered || $[1] !== t0) {
    t1 = {
      heading: item.rendered,
      "aria-label": t0
    };
    $[0] = item.rendered;
    $[1] = t0;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const {
    headingProps,
    groupProps
  } = useListBoxSection(t1);
  const headerRef = useRef(null);
  let t2;
  if ($[3] !== headerLayoutInfo || $[4] !== virtualizer || $[5] !== headerRef) {
    t2 = {
      layoutInfo: headerLayoutInfo,
      virtualizer,
      ref: headerRef
    };
    $[3] = headerLayoutInfo;
    $[4] = virtualizer;
    $[5] = headerRef;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  useVirtualizerItem(t2);
  const {
    direction
  } = useLocale();
  const {
    state
  } = useListBoxContext();
  let t3;
  if ($[7] !== headerLayoutInfo || $[8] !== direction) {
    t3 = layoutInfoToStyle(headerLayoutInfo, direction);
    $[7] = headerLayoutInfo;
    $[8] = direction;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== state.collection || $[11] !== item.key) {
    t4 = item.key !== state.collection.getFirstKey() && /*#__PURE__*/jsx(Divider, {
      role: "presentation",
      elementType: "div",
      size: "medium",
      UNSAFE_className: css({
        margin: tokenSchema.size.space.medium
      })
    });
    $[10] = state.collection;
    $[11] = item.key;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  let t5;
  if ($[13] !== item.rendered || $[14] !== headingProps) {
    t5 = item.rendered && /*#__PURE__*/jsx(Text, {
      ...headingProps,
      casing: "uppercase",
      color: "neutralSecondary",
      size: "small",
      weight: "medium",
      UNSAFE_className: css({
        padding: tokenSchema.size.space.medium
      }),
      children: item.rendered
    });
    $[13] = item.rendered;
    $[14] = headingProps;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== headerRef || $[17] !== t3 || $[18] !== t4 || $[19] !== t5) {
    t6 = /*#__PURE__*/jsxs("div", {
      role: "presentation",
      ref: headerRef,
      style: t3,
      children: [t4, t5]
    });
    $[16] = headerRef;
    $[17] = t3;
    $[18] = t4;
    $[19] = t5;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  let t7;
  if ($[21] !== layoutInfo || $[22] !== direction) {
    t7 = layoutInfoToStyle(layoutInfo, direction);
    $[21] = layoutInfo;
    $[22] = direction;
    $[23] = t7;
  } else {
    t7 = $[23];
  }
  let t8;
  if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = classNames(css({}), "ListBoxSection");
    $[24] = t8;
  } else {
    t8 = $[24];
  }
  let t9;
  if ($[25] !== groupProps || $[26] !== t7 || $[27] !== children) {
    t9 = /*#__PURE__*/jsx("div", {
      ...groupProps,
      style: t7,
      className: t8,
      children: children
    });
    $[25] = groupProps;
    $[26] = t7;
    $[27] = children;
    $[28] = t9;
  } else {
    t9 = $[28];
  }
  let t10;
  if ($[29] !== t6 || $[30] !== t9) {
    t10 = /*#__PURE__*/jsxs(Fragment, {
      children: [t6, t9]
    });
    $[29] = t6;
    $[30] = t9;
    $[31] = t10;
  } else {
    t10 = $[31];
  }
  return t10;
}

/** @private */
function useListBoxLayout() {
  const $ = c(5);
  const {
    scale
  } = useProvider();
  let t0;
  const t1 = scale === "large" ? 48 : 32;
  const t2 = scale === "large" ? 33 : 26;
  const t3 = scale === "large" ? 5 : 4;
  const t4 = scale === "large" ? 48 : 32;
  let t5;
  if ($[0] !== t1 || $[1] !== t2 || $[2] !== t3 || $[3] !== t4) {
    t5 = new ListBoxLayout({
      estimatedRowHeight: t1,
      estimatedHeadingHeight: t2,
      padding: t3,
      placeholderHeight: t4
    });
    $[0] = t1;
    $[1] = t2;
    $[2] = t3;
    $[3] = t4;
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  t0 = t5;
  const layout = t0;
  return layout;
}

/** @private */
function ListBoxBase(props, forwardedRef) {
  const $ = c(39);
  const {
    layout,
    state,
    shouldFocusOnHover: t0,
    shouldUseVirtualFocus: t1,
    domProps: t2,
    isLoading,
    showLoadingSpinner: t3,
    onScroll,
    renderEmptyState
  } = props;
  const shouldFocusOnHover = t0 === undefined ? false : t0;
  const shouldUseVirtualFocus = t1 === undefined ? false : t1;
  let t4;
  if ($[0] !== t2) {
    t4 = t2 === undefined ? {} : t2;
    $[0] = t2;
    $[1] = t4;
  } else {
    t4 = $[1];
  }
  const domProps = t4;
  const showLoadingSpinner = t3 === undefined ? isLoading : t3;
  let t5;
  if ($[2] !== props || $[3] !== layout) {
    t5 = {
      ...props,
      layoutDelegate: layout,
      isVirtualized: true
    };
    $[2] = props;
    $[3] = layout;
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  const {
    listBoxProps
  } = useListBox(t5, state, forwardedRef);
  const styleProps = useStyleProps(props);
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let t6;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = (parent, reusableView, children, renderChildren) => {
      if (reusableView.viewType === "section") {
        var _children$find;
        return /*#__PURE__*/jsx(ListBoxSection, {
          item: reusableView.content,
          layoutInfo: reusableView.layoutInfo,
          virtualizer: reusableView.virtualizer,
          headerLayoutInfo: (_children$find = children.find(c => c.viewType === "header")) === null || _children$find === void 0 ? void 0 : _children$find.layoutInfo,
          children: renderChildren(children.filter(c_0 => c_0.viewType === "item"))
        }, reusableView.key);
      }
      return /*#__PURE__*/jsx(VirtualizerItem, {
        layoutInfo: reusableView.layoutInfo,
        virtualizer: reusableView.virtualizer,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
        children: reusableView.rendered
      }, reusableView.key);
    };
    $[5] = t6;
  } else {
    t6 = $[5];
  }
  const renderWrapper = t6;
  const focusedKey = state.selectionManager.focusedKey;
  let t7;
  let t8;
  if ($[6] !== focusedKey) {
    t8 = focusedKey != null ? new Set([focusedKey]) : null;
    $[6] = focusedKey;
    $[7] = t8;
  } else {
    t8 = $[7];
  }
  t7 = t8;
  const persistedKeys = t7;
  let t9;
  if ($[8] !== state || $[9] !== renderEmptyState || $[10] !== shouldFocusOnHover || $[11] !== shouldUseVirtualFocus) {
    t9 = {
      state,
      renderEmptyState,
      shouldFocusOnHover,
      shouldUseVirtualFocus
    };
    $[8] = state;
    $[9] = renderEmptyState;
    $[10] = shouldFocusOnHover;
    $[11] = shouldUseVirtualFocus;
    $[12] = t9;
  } else {
    t9 = $[12];
  }
  let t10;
  if ($[13] !== listBoxProps || $[14] !== domProps) {
    t10 = mergeProps(listBoxProps, domProps);
    $[13] = listBoxProps;
    $[14] = domProps;
    $[15] = t10;
  } else {
    t10 = $[15];
  }
  const t11 = !!props.autoFocus;
  let t12;
  let t13;
  if ($[16] !== showLoadingSpinner) {
    t13 = {
      isLoading: showLoadingSpinner
    };
    $[16] = showLoadingSpinner;
    $[17] = t13;
  } else {
    t13 = $[17];
  }
  t12 = t13;
  let t14;
  if ($[18] !== shouldUseVirtualFocus || $[19] !== state.collection.size || $[20] !== stringFormatter || $[21] !== props) {
    t14 = (type, item) => {
      if (type === "item") {
        return /*#__PURE__*/jsx(ListBoxOption, {
          item: item,
          shouldUseVirtualFocus: shouldUseVirtualFocus
        });
      } else {
        if (type === "loader") {
          return /*#__PURE__*/jsx("div", {
            role: "option",
            style: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              height: "100%"
            },
            children: /*#__PURE__*/jsx(ProgressCircle, {
              isIndeterminate: true,
              size: "small",
              "aria-label": state.collection.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
            })
          });
        } else {
          if (type === "placeholder") {
            const emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
            if (emptyState == null) {
              return null;
            }
            return /*#__PURE__*/jsx("div", {
              role: "option",
              children: emptyState
            });
          }
        }
      }
    };
    $[18] = shouldUseVirtualFocus;
    $[19] = state.collection.size;
    $[20] = stringFormatter;
    $[21] = props;
    $[22] = t14;
  } else {
    t14 = $[22];
  }
  let t15;
  if ($[23] !== styleProps || $[24] !== t10 || $[25] !== forwardedRef || $[26] !== persistedKeys || $[27] !== t11 || $[28] !== layout || $[29] !== t12 || $[30] !== state.collection || $[31] !== props.isLoading || $[32] !== props.onLoadMore || $[33] !== onScroll || $[34] !== t14) {
    t15 = /*#__PURE__*/jsx(FocusScope, {
      children: /*#__PURE__*/jsx(Virtualizer, {
        ...styleProps,
        ...t10,
        ref: forwardedRef,
        persistedKeys: persistedKeys,
        autoFocus: t11,
        scrollDirection: "vertical",
        layout: layout,
        layoutOptions: t12,
        collection: state.collection,
        renderWrapper: renderWrapper,
        isLoading: props.isLoading,
        onLoadMore: props.onLoadMore,
        onScroll: onScroll,
        children: t14
      })
    });
    $[23] = styleProps;
    $[24] = t10;
    $[25] = forwardedRef;
    $[26] = persistedKeys;
    $[27] = t11;
    $[28] = layout;
    $[29] = t12;
    $[30] = state.collection;
    $[31] = props.isLoading;
    $[32] = props.onLoadMore;
    $[33] = onScroll;
    $[34] = t14;
    $[35] = t15;
  } else {
    t15 = $[35];
  }
  let t16;
  if ($[36] !== t9 || $[37] !== t15) {
    t16 = /*#__PURE__*/jsx(ListBoxContext.Provider, {
      value: t9,
      children: t15
    });
    $[36] = t9;
    $[37] = t15;
    $[38] = t16;
  } else {
    t16 = $[38];
  }
  return t16;
}

// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref
const _ListBoxBase = /*#__PURE__*/forwardRef(ListBoxBase);

function ListBox(props, forwardedRef) {
  const $ = c(5);
  const domRef = useObjectRef(forwardedRef);
  const state = useListState(props);
  const layout = useListBoxLayout();
  let t0;
  if ($[0] !== props || $[1] !== domRef || $[2] !== state || $[3] !== layout) {
    t0 = /*#__PURE__*/jsx(_ListBoxBase, {
      ...props,
      ref: domRef,
      state: state,
      layout: layout
    });
    $[0] = props;
    $[1] = domRef;
    $[2] = state;
    $[3] = layout;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
}

// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref

/**
 * A list of options that can allow selection of one or more.
 */
const _ListBox = /*#__PURE__*/forwardRef(ListBox);

const listStyles = css({
  borderRadius: 'inherit',
  maxHeight: 'inherit',
  // maxWidth: tokenSchema.size.dialog.small,
  outline: 0,
  overflowY: 'auto',
  paddingBlock: tokenSchema.size.space.small,
  userSelect: 'none'
});

export { _ListBox as ListBox, _ListBoxBase as ListBoxBase, ListItem, listStyles, useListBoxLayout };
