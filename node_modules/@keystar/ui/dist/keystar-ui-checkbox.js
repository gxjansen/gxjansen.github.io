'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useCheckboxGroupItem, useCheckbox, useCheckboxGroup } from '@react-aria/checkbox';
import { useToggleState } from '@react-stately/toggle';
import React, { useContext, useRef, forwardRef } from 'react';
import { Icon } from '@keystar/ui/icon';
import { checkIcon } from '@keystar/ui/icon/icons/checkIcon';
import { minusIcon } from '@keystar/ui/icon/icons/minusIcon';
import { SlotProvider } from '@keystar/ui/slots';
import { ClassList, tokenSchema, useStyleProps, css, classNames, FocusRing, transition, toDataAttributes } from '@keystar/ui/style';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useCheckboxGroupState } from '@react-stately/checkbox';
import { useProviderProps } from '@keystar/ui/core';
import { validateFieldProps, FieldPrimitive } from '@keystar/ui/field';

const CheckboxGroupContext = /*#__PURE__*/React.createContext(null);

const checkboxClassList = new ClassList('Checkbox', ['indicator']);
function Checkbox(props) {
  const $ = c(3);
  const groupState = useContext(CheckboxGroupContext);
  let t0;
  if ($[0] !== groupState || $[1] !== props) {
    t0 = groupState ? /*#__PURE__*/jsx(CheckboxInGroup, {
      groupState: groupState,
      ...props
    }) : /*#__PURE__*/jsx(CheckboxAlone, {
      ...props
    });
    $[0] = groupState;
    $[1] = props;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
function CheckboxInGroup(t0) {
  const $ = c(9);
  let props;
  let groupState;
  if ($[0] !== t0) {
    ({
      groupState,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = props;
    $[2] = groupState;
  } else {
    props = $[1];
    groupState = $[2];
  }
  const inputRef = useRef(null);
  let t1;
  if ($[3] !== props) {
    t1 = {
      ...props,
      value: props.value
    };
    $[3] = props;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const {
    inputProps
  } = useCheckboxGroupItem(t1, groupState.state, inputRef);
  let t2;
  if ($[5] !== inputRef || $[6] !== inputProps || $[7] !== props) {
    t2 = /*#__PURE__*/jsx(CheckboxInner, {
      inputRef: inputRef,
      inputProps: inputProps,
      ...props
    });
    $[5] = inputRef;
    $[6] = inputProps;
    $[7] = props;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  return t2;
}
function CheckboxAlone(props) {
  const $ = c(4);
  const inputRef = useRef(null);
  const {
    inputProps
  } = useCheckbox(props, useToggleState(props), inputRef);
  let t0;
  if ($[0] !== inputRef || $[1] !== inputProps || $[2] !== props) {
    t0 = /*#__PURE__*/jsx(CheckboxInner, {
      inputRef: inputRef,
      inputProps: inputProps,
      ...props
    });
    $[0] = inputRef;
    $[1] = inputProps;
    $[2] = props;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}
function CheckboxInner(props) {
  const $ = c(37);
  let t0;
  let t1;
  let otherProps;
  let inputProps;
  let inputRef;
  let autoFocus;
  let prominence;
  let children;
  if ($[0] !== props) {
    ({
      autoFocus,
      children,
      inputProps,
      inputRef,
      isDisabled: t0,
      isIndeterminate: t1,
      prominence,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = otherProps;
    $[4] = inputProps;
    $[5] = inputRef;
    $[6] = autoFocus;
    $[7] = prominence;
    $[8] = children;
  } else {
    t0 = $[1];
    t1 = $[2];
    otherProps = $[3];
    inputProps = $[4];
    inputRef = $[5];
    autoFocus = $[6];
    prominence = $[7];
    children = $[8];
  }
  const isDisabled = t0 === undefined ? false : t0;
  const isIndeterminate = t1 === undefined ? false : t1;
  const styleProps = useStyleProps(otherProps);
  let slots;
  let t2;
  let t3;
  if ($[9] !== isDisabled || $[10] !== styleProps.className) {
    const labelClassName = css({
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      paddingInlineEnd: tokenSchema.size.space.large,
      paddingBlock: tokenSchema.size.space.regular,
      position: "relative",
      userSelect: "none"
    });
    let t4;
    let t5;
    if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
      t5 = {
        text: {
          color: "inherit"
        },
        description: {
          color: "neutralTertiary"
        }
      };
      $[14] = t5;
    } else {
      t5 = $[14];
    }
    t4 = t5;
    slots = t4;
    t2 = isDisabled;
    t3 = classNames(styleProps.className, labelClassName);
    $[9] = isDisabled;
    $[10] = styleProps.className;
    $[11] = slots;
    $[12] = t2;
    $[13] = t3;
  } else {
    slots = $[11];
    t2 = $[12];
    t3 = $[13];
  }
  let t4;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = classNames(css({
      position: "absolute",
      zIndex: 1,
      inset: 0,
      insetInlineStart: `calc(${tokenSchema.size.space.regular} * -1)`,
      opacity: 0.0001
    }));
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  let t5;
  if ($[16] !== inputProps || $[17] !== inputRef) {
    t5 = /*#__PURE__*/jsx("input", {
      ...inputProps,
      ref: inputRef,
      className: t4
    });
    $[16] = inputProps;
    $[17] = inputRef;
    $[18] = t5;
  } else {
    t5 = $[18];
  }
  let t6;
  if ($[19] !== autoFocus || $[20] !== t5) {
    t6 = /*#__PURE__*/jsx(FocusRing, {
      autoFocus: autoFocus,
      children: t5
    });
    $[19] = autoFocus;
    $[20] = t5;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  let t7;
  if ($[22] !== isIndeterminate || $[23] !== prominence) {
    t7 = /*#__PURE__*/jsx(Indicator, {
      isIndeterminate: isIndeterminate,
      prominence: prominence
    });
    $[22] = isIndeterminate;
    $[23] = prominence;
    $[24] = t7;
  } else {
    t7 = $[24];
  }
  let t8;
  if ($[25] !== children) {
    t8 = children && /*#__PURE__*/jsx(Content, {
      children: isReactText(children) ? /*#__PURE__*/jsx(Text, {
        children: children
      }) : children
    });
    $[25] = children;
    $[26] = t8;
  } else {
    t8 = $[26];
  }
  let t9;
  if ($[27] !== slots || $[28] !== t8) {
    t9 = /*#__PURE__*/jsx(SlotProvider, {
      slots: slots,
      children: t8
    });
    $[27] = slots;
    $[28] = t8;
    $[29] = t9;
  } else {
    t9 = $[29];
  }
  let t10;
  if ($[30] !== t2 || $[31] !== t3 || $[32] !== styleProps.style || $[33] !== t6 || $[34] !== t7 || $[35] !== t9) {
    t10 = /*#__PURE__*/jsxs("label", {
      "data-disabled": t2,
      className: t3,
      style: styleProps.style,
      children: [t6, t7, t9]
    });
    $[30] = t2;
    $[31] = t3;
    $[32] = styleProps.style;
    $[33] = t6;
    $[34] = t7;
    $[35] = t9;
    $[36] = t10;
  } else {
    t10 = $[36];
  }
  return t10;
}

// Styled components
// -----------------------------------------------------------------------------

let sizeToken = tokenSchema.size.element.xsmall;
const Indicator = props => {
  let {
    isIndeterminate,
    prominence
  } = props;
  return /*#__PURE__*/jsx("span", {
    "data-prominence": prominence,
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      borderRadius: tokenSchema.size.radius.small,
      color: tokenSchema.color.foreground.inverse,
      display: 'flex',
      flexShrink: 0,
      justifyContent: 'center',
      alignItems: 'center',
      position: 'relative',
      height: sizeToken,
      width: sizeToken,
      // marginBlock: `calc((${tokenSchema.size.element.regular} - ${tokenSchema.typography.text.regular.size}) / 2)`,

      // prominence
      '--selected-idle-bg': tokenSchema.color.scale.indigo9,
      '--selected-hover-bg': tokenSchema.color.scale.indigo10,
      '--selected-pressed-bg': tokenSchema.color.scale.indigo11,
      '&[data-prominence=low]': {
        '--selected-idle-bg': tokenSchema.color.scale.slate9,
        '--selected-hover-bg': tokenSchema.color.scale.slate10,
        '--selected-pressed-bg': tokenSchema.color.scale.slate11
      },
      // indicator icons
      [checkboxClassList.selector('indicator')]: {
        opacity: 0,
        transform: `scale(0) translate3d(0, 0, 0)`,
        transition: transition(['opacity', 'transform']),
        willChange: 'opacity, transform'
      },
      // focus ring
      '::after': {
        borderRadius: `calc(${tokenSchema.size.alias.focusRingGap} + ${tokenSchema.size.radius.small})`,
        content: '""',
        inset: 0,
        margin: 0,
        position: 'absolute',
        transition: transition(['box-shadow', 'margin'], {
          easing: 'easeOut'
        })
      },
      'input[type="checkbox"][data-focus=visible] + &::after': {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // border / background
      '&::before': {
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.scale.slate8}`,
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        position: 'absolute',
        transition: transition(['border-color', 'border-width'])
      },
      'input[type="checkbox"]:disabled + &': {
        color: tokenSchema.color.alias.foregroundDisabled,
        '&::before': {
          backgroundColor: tokenSchema.color.alias.borderDisabled,
          borderColor: tokenSchema.color.alias.borderDisabled
        }
      },
      'input[type="checkbox"]:enabled:hover + &::before': {
        borderColor: tokenSchema.color.scale.slate9
      },
      'input[type="checkbox"]:enabled:active + &::before': {
        borderColor: tokenSchema.color.scale.slate10
      },
      // checked states
      'input[type="checkbox"]:checked + &, input[type="checkbox"]:indeterminate + &': {
        '&::before': {
          borderWidth: `calc(${sizeToken} / 2)`
        },
        [checkboxClassList.selector('indicator')]: {
          opacity: 1,
          transform: `scale(1)`
        }
      },
      'input[type="checkbox"]:enabled:checked + &::before, input[type="checkbox"]:enabled:indeterminate + &::before': {
        borderColor: 'var(--selected-idle-bg)'
      },
      'input[type="checkbox"]:enabled:checked:hover + &::before, input[type="checkbox"]:enabled:indeterminate:hover + &::before': {
        borderColor: 'var(--selected-hover-bg)'
      },
      'input[type="checkbox"]:enabled:checked:active + &::before, input[type="checkbox"]:enabled:indeterminate:active + &::before': {
        borderColor: 'var(--selected-pressed-bg)'
      }
    })),
    children: /*#__PURE__*/jsx("span", {
      className: checkboxClassList.element('indicator'),
      children: /*#__PURE__*/jsx(Icon, {
        size: "small",
        src: isIndeterminate ? minusIcon : checkIcon,
        strokeScaling: false
      })
    })
  });
};
const Content = props => {
  const $ = c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = classNames(css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: "grid",
      gap: tokenSchema.size.space.large,
      paddingTop: `calc((${sizeToken} - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      "input[type=\"checkbox\"]:hover ~ &": {
        color: tokenSchema.color.alias.foregroundHovered
      },
      "input[type=\"checkbox\"]:disabled ~ &": {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    }));
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /*#__PURE__*/jsx("div", {
      className: t0,
      ...props
    });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};

/**
 * A checkbox group allows users to select one or more items from a list of
 * choices.
 */
const CheckboxGroup = /*#__PURE__*/forwardRef(function CheckboxGroup(props, forwardedRef) {
  const $ = c(22);
  props = useProviderProps(props);
  let t0;
  if ($[0] !== props) {
    t0 = validateFieldProps(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  props = t0;
  const {
    children,
    orientation: t1,
    validationState
  } = props;
  const orientation = t1 === undefined ? "vertical" : t1;
  const state = useCheckboxGroupState(props);
  const {
    labelProps,
    groupProps,
    descriptionProps,
    errorMessageProps
  } = useCheckboxGroup(props, state);
  let t2;
  if ($[2] !== orientation) {
    t2 = toDataAttributes({
      orientation
    });
    $[2] = orientation;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = classNames(css({
      display: "flex",
      "&[data-orientation=\"vertical\"]": {
        flexDirection: "column"
      }
    }));
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== validationState || $[6] !== state) {
    t4 = {
      validationState,
      state
    };
    $[5] = validationState;
    $[6] = state;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t4 || $[9] !== children) {
    t5 = /*#__PURE__*/jsx(CheckboxGroupContext.Provider, {
      value: t4,
      children: children
    });
    $[8] = t4;
    $[9] = children;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== groupProps || $[12] !== t2 || $[13] !== t5) {
    t6 = /*#__PURE__*/jsx("div", {
      ...groupProps,
      ...t2,
      className: t3,
      children: t5
    });
    $[11] = groupProps;
    $[12] = t2;
    $[13] = t5;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  let t7;
  if ($[15] !== props || $[16] !== forwardedRef || $[17] !== labelProps || $[18] !== descriptionProps || $[19] !== errorMessageProps || $[20] !== t6) {
    t7 = /*#__PURE__*/jsx(FieldPrimitive, {
      ...props,
      ref: forwardedRef,
      labelElementType: "span",
      labelProps: labelProps,
      descriptionProps: descriptionProps,
      errorMessageProps: errorMessageProps,
      supplementRequiredState: true,
      children: t6
    });
    $[15] = props;
    $[16] = forwardedRef;
    $[17] = labelProps;
    $[18] = descriptionProps;
    $[19] = errorMessageProps;
    $[20] = t6;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  return t7;
});

export { Checkbox, CheckboxGroup };
