'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useTooltip, useTooltipTrigger } from '@react-aria/tooltip';
import { mergeProps, mergeRefs, useObjectRef, filterDOMProps } from '@react-aria/utils';
import React, { forwardRef, useContext, useRef } from 'react';
import { DirectionIndicator, Overlay } from '@keystar/ui/overlays';
import { SlotProvider } from '@keystar/ui/slots';
import { tokenSchema, useStyleProps, toDataAttributes, classNames, css, transition } from '@keystar/ui/style';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { useOverlayPosition } from '@react-aria/overlays';
import { jsx, jsxs } from 'react/jsx-runtime';
import { FocusableProvider } from '@react-aria/focus';
import { useTooltipTriggerState } from '@react-stately/tooltip';

const TooltipContext = /*#__PURE__*/React.createContext({});

const Tooltip = /*#__PURE__*/forwardRef(function Tooltip(props, forwardedRef) {
  var _triggerRef, _state, _tone;
  const $ = c(61);
  const t0 = useContext(TooltipContext);
  let contextualProps;
  let state;
  let tooltipRef;
  let triggerRef;
  if ($[0] !== t0) {
    const {
      state: t1,
      targetRef: t2,
      overlayRef: t3,
      crossOffset,
      offset,
      ...t4
    } = t0;
    state = t1;
    triggerRef = t2;
    tooltipRef = t3;
    contextualProps = t4;
    $[0] = t0;
    $[1] = contextualProps;
    $[2] = state;
    $[3] = tooltipRef;
    $[4] = triggerRef;
  } else {
    contextualProps = $[1];
    state = $[2];
    tooltipRef = $[3];
    triggerRef = $[4];
  }
  let t1;
  if ($[5] !== props || $[6] !== contextualProps) {
    t1 = mergeProps(props, contextualProps);
    $[5] = props;
    $[6] = contextualProps;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  props = t1;
  let otherProps;
  let isOpen;
  let tone;
  if ($[8] !== props) {
    ({
      isOpen,
      tone,
      ...otherProps
    } = props);
    $[8] = props;
    $[9] = otherProps;
    $[10] = isOpen;
    $[11] = tone;
  } else {
    otherProps = $[9];
    isOpen = $[10];
    tone = $[11];
  }
  const targetGapToken = tokenSchema.size.space.regular;
  const {
    tooltipProps
  } = useTooltip(contextualProps, state);
  const styleProps = useStyleProps(otherProps);
  const ref = useRef(null);
  let t2;
  if ($[12] !== tooltipRef || $[13] !== forwardedRef) {
    t2 = tooltipRef ? mergeRefs(tooltipRef, forwardedRef) : forwardedRef;
    $[12] = tooltipRef;
    $[13] = forwardedRef;
    $[14] = t2;
  } else {
    t2 = $[14];
  }
  const overlayRef = useObjectRef(t2);
  const targetRef = (_triggerRef = triggerRef) !== null && _triggerRef !== void 0 ? _triggerRef : ref;
  let t3;
  let t4;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      icon: {
        size: "small",
        color: "inherit"
      },
      text: {
        size: "small",
        color: "inherit"
      },
      kbd: {
        size: "small",
        color: "inherit"
      }
    };
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  t3 = t4;
  const slots = t3;
  const preferredPlacement = contextualProps.placement || "top";
  const t5 = (_state = state) === null || _state === void 0 ? void 0 : _state.isOpen;
  let t6;
  if ($[16] !== contextualProps || $[17] !== preferredPlacement || $[18] !== t5 || $[19] !== overlayRef || $[20] !== targetRef) {
    t6 = {
      ...contextualProps,
      placement: preferredPlacement,
      isOpen: t5,
      overlayRef,
      targetRef
    };
    $[16] = contextualProps;
    $[17] = preferredPlacement;
    $[18] = t5;
    $[19] = overlayRef;
    $[20] = targetRef;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  const {
    overlayProps,
    arrowProps,
    placement: resolvedPlacement
  } = useOverlayPosition(t6);
  const t7 = resolvedPlacement || preferredPlacement;
  let placement;
  let t8;
  let t9;
  let t10;
  if ($[22] !== t7 || $[23] !== overlayProps || $[24] !== tooltipProps || $[25] !== otherProps || $[26] !== isOpen || $[27] !== tone) {
    placement = t7.split(" ")[0];
    if ($[32] !== overlayProps || $[33] !== tooltipProps) {
      t8 = mergeProps(overlayProps, tooltipProps);
      $[32] = overlayProps;
      $[33] = tooltipProps;
      $[34] = t8;
    } else {
      t8 = $[34];
    }
    if ($[35] !== otherProps) {
      t9 = filterDOMProps(otherProps);
      $[35] = otherProps;
      $[36] = t9;
    } else {
      t9 = $[36];
    }
    t10 = toDataAttributes({
      placement,
      tone,
      open: isOpen || undefined
    });
    $[22] = t7;
    $[23] = overlayProps;
    $[24] = tooltipProps;
    $[25] = otherProps;
    $[26] = isOpen;
    $[27] = tone;
    $[28] = placement;
    $[29] = t8;
    $[30] = t9;
    $[31] = t10;
  } else {
    placement = $[28];
    t8 = $[29];
    t9 = $[30];
    t10 = $[31];
  }
  let t11;
  if ($[37] !== styleProps.className) {
    t11 = classNames(css({
      backgroundColor: tokenSchema.color.background.inverse,
      color: tokenSchema.color.foreground.inverse,
      borderRadius: tokenSchema.size.radius.small,
      maxWidth: tokenSchema.size.alias.singleLineWidth,
      minHeight: tokenSchema.size.element.small,
      paddingBlock: tokenSchema.size.space.regular,
      paddingInline: tokenSchema.size.space.regular,
      opacity: 0,
      pointerEvents: "none",
      transition: transition(["opacity", "transform"]),
      userSelect: "none",
      "&[data-tone=\"accent\"]": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      "&[data-tone=\"critical\"]": {
        backgroundColor: tokenSchema.color.background.criticalEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      "&[data-tone=\"positive\"]": {
        backgroundColor: tokenSchema.color.background.positiveEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      "&[data-placement=\"top\"]": {
        marginBottom: targetGapToken,
        transform: `translateY(calc(${targetGapToken} * 0.5))`
      },
      "&[data-placement=\"bottom\"]": {
        marginTop: targetGapToken,
        transform: `translateY(calc(${targetGapToken} * -0.5))`
      },
      "&[data-placement=\"left\"], [dir=ltr] &[data-placement=\"start\"], [dir=rtl] &[data-placement=\"end\"]": {
        marginRight: targetGapToken,
        transform: `translateX(calc(${targetGapToken} * 0.5))`
      },
      "&[data-placement=\"right\"], [dir=ltr] &[data-placement=\"end\"], [dir=rtl] &[data-placement=\"start\"]": {
        marginLeft: targetGapToken,
        transform: `translateX(calc(${targetGapToken} * -0.5))`
      },
      "&[data-open=\"true\"]": {
        opacity: 1,
        transform: `translate(0)`
      }
    }), styleProps.className);
    $[37] = styleProps.className;
    $[38] = t11;
  } else {
    t11 = $[38];
  }
  let t12;
  if ($[39] !== overlayProps.style || $[40] !== tooltipProps.style || $[41] !== styleProps.style) {
    t12 = {
      ...overlayProps.style,
      ...tooltipProps.style,
      ...styleProps.style
    };
    $[39] = overlayProps.style;
    $[40] = tooltipProps.style;
    $[41] = styleProps.style;
    $[42] = t12;
  } else {
    t12 = $[42];
  }
  let t13;
  if ($[43] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = css({
      alignItems: "center",
      boxSizing: "border-box",
      display: "flex",
      gap: tokenSchema.size.space.small
    });
    $[43] = t13;
  } else {
    t13 = $[43];
  }
  let t14;
  if ($[44] !== props.children) {
    t14 = props.children && (isReactText(props.children) ? /*#__PURE__*/jsx(Text, {
      children: props.children
    }) : props.children);
    $[44] = props.children;
    $[45] = t14;
  } else {
    t14 = $[45];
  }
  let t15;
  if ($[46] !== t14) {
    t15 = /*#__PURE__*/jsx("div", {
      className: t13,
      children: /*#__PURE__*/jsx(SlotProvider, {
        slots: slots,
        children: t14
      })
    });
    $[46] = t14;
    $[47] = t15;
  } else {
    t15 = $[47];
  }
  const t16 = toneToFill[(_tone = tone) !== null && _tone !== void 0 ? _tone : "neutral"];
  const t17 = placement;
  let t18;
  if ($[48] !== arrowProps || $[49] !== t16 || $[50] !== t17) {
    t18 = /*#__PURE__*/jsx(DirectionIndicator, {
      ...arrowProps,
      fill: t16,
      placement: t17,
      size: "xsmall"
    });
    $[48] = arrowProps;
    $[49] = t16;
    $[50] = t17;
    $[51] = t18;
  } else {
    t18 = $[51];
  }
  let t19;
  if ($[52] !== t8 || $[53] !== t9 || $[54] !== t10 || $[55] !== overlayRef || $[56] !== t11 || $[57] !== t12 || $[58] !== t15 || $[59] !== t18) {
    t19 = /*#__PURE__*/jsxs("div", {
      ...t8,
      ...t9,
      ...t10,
      ref: overlayRef,
      className: t11,
      style: t12,
      children: [t15, t18]
    });
    $[52] = t8;
    $[53] = t9;
    $[54] = t10;
    $[55] = overlayRef;
    $[56] = t11;
    $[57] = t12;
    $[58] = t15;
    $[59] = t18;
    $[60] = t19;
  } else {
    t19 = $[60];
  }
  return t19;
});
const toneToFill = {
  accent: 'accent',
  critical: 'critical',
  neutral: 'inverse',
  positive: 'positive'
};

const MOUSE_REST_TIMEOUT = 600;
function TooltipTrigger(props) {
  const $ = c(32);
  let isDisabled;
  let triggerMode;
  let children;
  let otherProps;
  if ($[0] !== props) {
    ({
      children,
      isDisabled,
      trigger: triggerMode,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = isDisabled;
    $[2] = triggerMode;
    $[3] = children;
    $[4] = otherProps;
  } else {
    isDisabled = $[1];
    triggerMode = $[2];
    children = $[3];
    otherProps = $[4];
  }
  const targetRef = useRef(null);
  const overlayRef = useRef(null);
  let t0;
  if ($[5] !== isDisabled || $[6] !== triggerMode || $[7] !== props) {
    t0 = {
      isDisabled,
      delay: MOUSE_REST_TIMEOUT,
      trigger: triggerMode,
      ...props
    };
    $[5] = isDisabled;
    $[6] = triggerMode;
    $[7] = props;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  const state = useTooltipTriggerState(t0);
  let t1;
  if ($[9] !== isDisabled || $[10] !== triggerMode) {
    t1 = {
      isDisabled,
      trigger: triggerMode
    };
    $[9] = isDisabled;
    $[10] = triggerMode;
    $[11] = t1;
  } else {
    t1 = $[11];
  }
  const {
    triggerProps,
    tooltipProps
  } = useTooltipTrigger(t1, state, targetRef);
  let t2;
  if ($[12] !== children) {
    t2 = React.Children.toArray(children);
    $[12] = children;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  const [triggerElement, tooltipElement] = t2;
  let t3;
  if ($[14] !== overlayRef || $[15] !== targetRef || $[16] !== state || $[17] !== otherProps || $[18] !== tooltipProps) {
    t3 = {
      overlayRef,
      targetRef,
      state,
      ...otherProps,
      ...tooltipProps
    };
    $[14] = overlayRef;
    $[15] = targetRef;
    $[16] = state;
    $[17] = otherProps;
    $[18] = tooltipProps;
    $[19] = t3;
  } else {
    t3 = $[19];
  }
  let t4;
  if ($[20] !== state.isOpen || $[21] !== overlayRef || $[22] !== tooltipElement) {
    t4 = /*#__PURE__*/jsx(Overlay, {
      isOpen: state.isOpen,
      nodeRef: overlayRef,
      children: tooltipElement
    });
    $[20] = state.isOpen;
    $[21] = overlayRef;
    $[22] = tooltipElement;
    $[23] = t4;
  } else {
    t4 = $[23];
  }
  let t5;
  if ($[24] !== t3 || $[25] !== t4) {
    t5 = /*#__PURE__*/jsx(TooltipContext.Provider, {
      value: t3,
      children: t4
    });
    $[24] = t3;
    $[25] = t4;
    $[26] = t5;
  } else {
    t5 = $[26];
  }
  let t6;
  if ($[27] !== triggerProps || $[28] !== targetRef || $[29] !== triggerElement || $[30] !== t5) {
    t6 = /*#__PURE__*/jsxs(FocusableProvider, {
      ...triggerProps,
      ref: targetRef,
      children: [triggerElement, t5]
    });
    $[27] = triggerProps;
    $[28] = targetRef;
    $[29] = triggerElement;
    $[30] = t5;
    $[31] = t6;
  } else {
    t6 = $[31];
  }
  return t6;
}

// Support TooltipTrigger inside components using CollectionBuilder.
TooltipTrigger.getCollectionNode = function* (props) {
  // Children.toArray mutates the key prop, use Children.forEach instead.
  let childArray = [];
  React.Children.forEach(props.children, child => {
    if ( /*#__PURE__*/React.isValidElement(child)) {
      childArray.push(child);
    }
  });
  let [trigger, tooltip] = childArray;
  yield {
    element: trigger,
    wrapper: element => /*#__PURE__*/jsxs(TooltipTrigger, {
      ...props,
      children: [element, tooltip]
    }, element.key)
  };
};

/**
 * TooltipTrigger wraps around a trigger element and a Tooltip. It handles opening and closing
 * the Tooltip when the user hovers over or focuses the trigger, and positioning the Tooltip
 * relative to the trigger.
 */
// We don't want getCollectionNode to show up in the type definition
let _TooltipTrigger = TooltipTrigger;

export { Tooltip, _TooltipTrigger as TooltipTrigger };
