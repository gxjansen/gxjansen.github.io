'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useStyleProps, filterStyleProps, toDataAttributes, transition, classNames, css, tokenSchema, breakpointQueries, breakpoints } from '@keystar/ui/style';
import { jsx, jsxs } from 'react/jsx-runtime';
import { Overlay as Overlay$1, useModalOverlay, usePopover, DismissButton } from '@react-aria/overlays';
import { useObjectRef, useViewportSize } from '@react-aria/utils';
import { useState, useRef, useLayoutEffect, forwardRef } from 'react';
import { TOKEN_PREFIX } from '@keystar/ui/primitives';
import { KeystarProvider } from '@keystar/ui/core';
import { c as cloneValidElement } from './children-f7c17978.js';

/**
 * A low-level utility component that covers the underlying interface while an
 * overlay component is open.
 */
function Blanket(props) {
  const $ = c(18);
  let otherProps;
  let isTransparent;
  let isOpen;
  if ($[0] !== props) {
    ({
      isOpen,
      isTransparent,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = isTransparent;
    $[3] = isOpen;
  } else {
    otherProps = $[1];
    isTransparent = $[2];
    isOpen = $[3];
  }
  const styleProps = useStyleProps(otherProps);
  let t0;
  if ($[4] !== otherProps) {
    t0 = filterStyleProps(otherProps);
    $[4] = otherProps;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  const t1 = isTransparent ? "transparent" : "translucent";
  const t2 = isOpen || undefined;
  let t3;
  if ($[6] !== t1 || $[7] !== t2) {
    t3 = toDataAttributes({
      fill: t1,
      open: t2
    });
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = transition("opacity", {
      easing: "easeOut",
      duration: "regular",
      delay: "short"
    });
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  let t5;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = [t4, transition("visibility", {
      delay: "regular",
      duration: 0,
      easing: "linear"
    })];
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== styleProps.className) {
    t6 = classNames(css({
      inset: 0,
      opacity: 0,
      overflow: "hidden",
      pointerEvents: "none",
      position: "fixed",
      visibility: "hidden",
      zIndex: 1,
      "&[data-fill=\"translucent\"]": {
        backgroundColor: "#0006",
        transition: t5.join(", ")
      },
      "&[data-open=\"true\"]": {
        opacity: 1,
        pointerEvents: "auto",
        visibility: "visible",
        transition: transition("opacity", {
          easing: "easeIn"
        })
      }
    }), styleProps.className);
    $[11] = styleProps.className;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  let t7;
  if ($[13] !== t0 || $[14] !== t3 || $[15] !== styleProps || $[16] !== t6) {
    t7 = /*#__PURE__*/jsx("div", {
      ...t0,
      ...t3,
      ...styleProps,
      className: t6
    });
    $[13] = t0;
    $[14] = t3;
    $[15] = styleProps;
    $[16] = t6;
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  return t7;
}

function DirectionIndicator(t0) {
  const $ = c(25);
  let fill;
  let placement;
  let size;
  let props;
  let stroke;
  if ($[0] !== t0) {
    ({
      fill,
      placement,
      size,
      stroke,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = fill;
    $[2] = placement;
    $[3] = size;
    $[4] = props;
    $[5] = stroke;
  } else {
    fill = $[1];
    placement = $[2];
    size = $[3];
    props = $[4];
    stroke = $[5];
  }
  let t1;
  if ($[6] !== fill || $[7] !== placement || $[8] !== size) {
    t1 = toDataAttributes({
      fill,
      placement,
      size
    });
    $[6] = fill;
    $[7] = placement;
    $[8] = size;
    $[9] = t1;
  } else {
    t1 = $[9];
  }
  let t2;
  if ($[10] !== props.className) {
    t2 = classNames(css({
      height: "var(--size)",
      position: "absolute",
      width: "var(--size)",
      "&[data-fill=\"surface\"]": {
        fill: tokenSchema.color.background.surface
      },
      "&[data-fill=\"inverse\"]": {
        fill: tokenSchema.color.background.inverse
      },
      "&[data-fill=\"accent\"]": {
        fill: tokenSchema.color.background.accentEmphasis
      },
      "&[data-fill=\"critical\"]": {
        fill: tokenSchema.color.background.criticalEmphasis
      },
      "&[data-fill=\"positive\"]": {
        fill: tokenSchema.color.background.positiveEmphasis
      },
      "&[data-size=\"xsmall\"]": {
        "--size": tokenSchema.size.element.xsmall
      },
      "&[data-size=\"small\"]": {
        "--size": tokenSchema.size.element.small
      },
      "&[data-size=\"regular\"]": {
        "--size": tokenSchema.size.element.regular
      },
      "&[data-placement=\"top\"], &[data-placement=\"bottom\"]": {
        left: "50%",
        transform: "translateX(-50%)"
      },
      "&[data-placement=\"top\"]": {
        top: "100%"
      },
      "&[data-placement=\"bottom\"]": {
        bottom: "100%"
      },
      "&[data-placement=\"left\"], &[data-placement=\"right\"], &[data-placement=\"start\"], &[data-placement=\"end\"]": {
        top: "50%",
        transform: "translateY(-50%)"
      },
      "&[data-placement=\"left\"]": {
        left: "100%"
      },
      "&[data-placement=\"right\"]": {
        right: "100%"
      },
      "&[data-placement=\"start\"]": {
        insetInlineStart: "100%"
      },
      "&[data-placement=\"end\"]": {
        insetInlineEnd: "100%"
      }
    }), props.className);
    $[10] = props.className;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  let t3;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = css({
      "&[data-placement=\"top\"]": {
        transform: "rotate(180deg)"
      },
      "&[data-placement=\"left\"], [dir=ltr] &[data-placement=\"start\"], [dir=rtl] &[data-placement=\"end\"]": {
        transform: "rotate(90deg)"
      },
      "&[data-placement=\"right\"], [dir=ltr] &[data-placement=\"end\"], [dir=rtl] &[data-placement=\"start\"]": {
        transform: "rotate(270deg)"
      }
    });
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  let t4;
  if ($[13] !== stroke) {
    t4 = stroke && /*#__PURE__*/jsx("path", {
      fill: stroke,
      d: "M23.7,27.1L17,19.9C16.5,19.3,15.8,19,15,19s-1.6,0.3-2.1,0.9l-6.6,7.2C5.3,28.1,3.4,29,2,29h26 C26.7,29,24.6,28.1,23.7,27.1z"
    });
    $[13] = stroke;
    $[14] = t4;
  } else {
    t4 = $[14];
  }
  let t5;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /*#__PURE__*/jsx("path", {
      d: "M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"
    });
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== placement || $[17] !== t4) {
    t6 = /*#__PURE__*/jsxs("svg", {
      "data-placement": placement,
      viewBox: "0 0 30 30",
      className: t3,
      children: [t4, t5]
    });
    $[16] = placement;
    $[17] = t4;
    $[18] = t6;
  } else {
    t6 = $[18];
  }
  let t7;
  if ($[19] !== props || $[20] !== t1 || $[21] !== placement || $[22] !== t2 || $[23] !== t6) {
    t7 = /*#__PURE__*/jsx("span", {
      ...props,
      ...t1,
      "data-placement": placement,
      className: t2,
      children: t6
    });
    $[19] = props;
    $[20] = t1;
    $[21] = placement;
    $[22] = t2;
    $[23] = t6;
    $[24] = t7;
  } else {
    t7 = $[24];
  }
  return t7;
}

const forceReflow = node => node.scrollTop;

/**
 * A low-level utility component for implementing transitions, which
 * safely unmount children _after_ their animation has completed.
 */
const Transition = function Transition(props) {
  const $ = c(3);
  const {
    isOpen
  } = useTransition(props);
  if (!isOpen) {
    return null;
  }
  let t0;
  if ($[0] !== isOpen || $[1] !== props) {
    var _cloneValidElement;
    t0 = (_cloneValidElement = cloneValidElement(props.children, {
      isOpen: isOpen === "mounting" ? false : props.isOpen
    })) !== null && _cloneValidElement !== void 0 ? _cloneValidElement : props.children;
    $[0] = isOpen;
    $[1] = props;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
};
function useTransition(props) {
  const $ = c(22);
  const {
    isOpen: isOpenProp,
    nodeRef,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting
  } = props;
  const [isOpen, setIsOpen] = useState(isOpenProp ? "mounting" : false);
  if (isOpenProp && !isOpen) {
    setIsOpen("mounting");
  }
  const hasCalledCompletedCallback = useRef(false);
  let t0;
  if ($[0] !== isOpenProp || $[1] !== isOpen || $[2] !== onEntered || $[3] !== onExited || $[4] !== onEnter || $[5] !== nodeRef.current || $[6] !== onEntering || $[7] !== onExit || $[8] !== onExiting) {
    t0 = () => {
      if (!hasCalledCompletedCallback.current && isOpenProp === isOpen) {
        hasCalledCompletedCallback.current = true;
        if (isOpenProp) {
          onEntered === null || onEntered === void 0 || onEntered();
        } else {
          onExited === null || onExited === void 0 || onExited();
        }
      }
      if (isOpenProp === isOpen) {
        return;
      }
      hasCalledCompletedCallback.current = false;
      if (isOpenProp) {
        onEnter === null || onEnter === void 0 || onEnter();
        if (nodeRef.current) {
          forceReflow(nodeRef.current);
        }
        setIsOpen(true);
        onEntering === null || onEntering === void 0 || onEntering();
      } else {
        onExit === null || onExit === void 0 || onExit();
        onExiting === null || onExiting === void 0 || onExiting();
        const id = setTimeout(() => {
          setIsOpen(false);
        }, 320);
        return () => clearTimeout(id);
      }
    };
    $[0] = isOpenProp;
    $[1] = isOpen;
    $[2] = onEntered;
    $[3] = onExited;
    $[4] = onEnter;
    $[5] = nodeRef.current;
    $[6] = onEntering;
    $[7] = onExit;
    $[8] = onExiting;
    $[9] = t0;
  } else {
    t0 = $[9];
  }
  let t1;
  if ($[10] !== isOpenProp || $[11] !== isOpen || $[12] !== nodeRef || $[13] !== onEnter || $[14] !== onEntering || $[15] !== onExit || $[16] !== onExiting || $[17] !== onEntered || $[18] !== onExited) {
    t1 = [isOpenProp, isOpen, nodeRef, onEnter, onEntering, onExit, onExiting, onEntered, onExited];
    $[10] = isOpenProp;
    $[11] = isOpen;
    $[12] = nodeRef;
    $[13] = onEnter;
    $[14] = onEntering;
    $[15] = onExit;
    $[16] = onExiting;
    $[17] = onEntered;
    $[18] = onExited;
    $[19] = t1;
  } else {
    t1 = $[19];
  }
  useLayoutEffect(t0, t1);
  let t2;
  if ($[20] !== isOpen) {
    t2 = {
      isOpen,
      setIsOpen
    };
    $[20] = isOpen;
    $[21] = t2;
  } else {
    t2 = $[21];
  }
  return t2;
}

const Overlay = /*#__PURE__*/forwardRef(function Overlay(props, forwardedRef) {
  const $ = c(10);
  const {
    isOpen
  } = useTransition(props);
  if (!isOpen) {
    return null;
  }
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      background: "transparent",
      isolation: "isolate"
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== isOpen || $[2] !== props) {
    var _cloneValidElement;
    t1 = (_cloneValidElement = cloneValidElement(props.children, {
      isOpen: isOpen === "mounting" ? false : props.isOpen
    })) !== null && _cloneValidElement !== void 0 ? _cloneValidElement : props.children;
    $[1] = isOpen;
    $[2] = props;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== forwardedRef || $[5] !== t1) {
    t2 = /*#__PURE__*/jsx(KeystarProvider, {
      ref: forwardedRef,
      UNSAFE_style: t0,
      isDisabled: false,
      children: t1
    });
    $[4] = forwardedRef;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== props.container || $[8] !== t2) {
    t3 = /*#__PURE__*/jsx(Overlay$1, {
      portalContainer: props.container,
      children: t2
    });
    $[7] = props.container;
    $[8] = t2;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  return t3;
});

/**
 * A low-level utility component for implementing things like dialogs and
 * popovers, in a layer above the page.
 */
const Modal = /*#__PURE__*/forwardRef(function Modal(props, forwardedRef) {
  const $ = c(14);
  let children;
  let otherProps;
  let state;
  if ($[0] !== props) {
    ({
      children,
      state,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = children;
    $[2] = otherProps;
    $[3] = state;
  } else {
    children = $[1];
    otherProps = $[2];
    state = $[3];
  }
  const wrapperRef = useRef(null);
  let t0;
  if ($[4] !== forwardedRef || $[5] !== props || $[6] !== wrapperRef || $[7] !== children) {
    t0 = /*#__PURE__*/jsx(ModalWrapper, {
      ref: forwardedRef,
      ...props,
      wrapperRef: wrapperRef,
      children: children
    });
    $[4] = forwardedRef;
    $[5] = props;
    $[6] = wrapperRef;
    $[7] = children;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  let t1;
  if ($[9] !== otherProps || $[10] !== state.isOpen || $[11] !== wrapperRef || $[12] !== t0) {
    t1 = /*#__PURE__*/jsx(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: t0
    });
    $[9] = otherProps;
    $[10] = state.isOpen;
    $[11] = wrapperRef;
    $[12] = t0;
    $[13] = t1;
  } else {
    t1 = $[13];
  }
  return t1;
});
const MAX_HEIGHT_VAR = `--${TOKEN_PREFIX}-visual-viewport-height`;
const ModalWrapper = /*#__PURE__*/forwardRef(function ModalWrapper(props, forwardedRef) {
  const $ = c(27);
  const {
    type,
    children,
    state,
    isOpen,
    wrapperRef
  } = props;
  const domRef = useObjectRef(forwardedRef);
  const {
    modalProps,
    underlayProps
  } = useModalOverlay(props, state, domRef);
  const styleProps = useStyleProps(props);
  const viewport = useViewportSize();
  let t0;
  if ($[0] !== underlayProps || $[1] !== isOpen) {
    t0 = /*#__PURE__*/jsx(Blanket, {
      ...underlayProps,
      isOpen: isOpen
    });
    $[0] = underlayProps;
    $[1] = isOpen;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = css({
      alignItems: "center",
      boxSizing: "border-box",
      display: "flex",
      insetBlockStart: 0,
      insetInlineStart: 0,
      justifyContent: "center",
      pointerEvents: "none",
      position: "fixed",
      width: "100vw",
      zIndex: 2
    });
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const t2 = `${viewport.height}px`;
  let t3;
  if ($[4] !== t2) {
    t3 = {
      [MAX_HEIGHT_VAR]: t2,
      height: `var(${MAX_HEIGHT_VAR})`
    };
    $[4] = t2;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== isOpen || $[7] !== type) {
    t4 = toDataAttributes({
      open: isOpen,
      type
    });
    $[6] = isOpen;
    $[7] = type;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  let t5;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = transition("opacity", {
      easing: "easeIn"
    });
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = [t5, transition("transform", {
      delay: "short",
      duration: 0,
      easing: "linear"
    })];
    $[10] = t6;
  } else {
    t6 = $[10];
  }
  let t7;
  if ($[11] !== styleProps.className) {
    t7 = classNames(styleProps.className, css({
      backgroundColor: tokenSchema.color.background.surface,
      borderRadius: tokenSchema.size.radius.large,
      boxShadow: `${tokenSchema.size.shadow.large} ${tokenSchema.color.shadow.emphasis}`,
      maxHeight: `calc(var(${MAX_HEIGHT_VAR}) * 0.9)`,
      maxWidth: "90vw",
      opacity: 0,
      outline: 0,
      pointerEvents: "auto",
      transform: `translateY(${tokenSchema.size.space.large})`,
      zIndex: 2,
      transition: t6.join(", "),
      "&[data-type=\"fullscreen\"]": {
        position: "fixed",
        inset: tokenSchema.size.space.xxlarge,
        maxWidth: "none",
        maxHeight: "none",
        width: `calc(100% - calc(2 * ${tokenSchema.size.space.xxlarge}))`,
        height: `calc(100% - calc(2 * ${tokenSchema.size.space.xxlarge}))`
      },
      "&[data-open=\"true\"]": {
        opacity: 1,
        transform: `translateY(0)`,
        transition: transition(["opacity", "transform"], {
          easing: "easeOut"
        })
      }
    }));
    $[11] = styleProps.className;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  let t8;
  if ($[13] !== modalProps || $[14] !== t4 || $[15] !== styleProps || $[16] !== domRef || $[17] !== t7 || $[18] !== children) {
    t8 = /*#__PURE__*/jsx("div", {
      ...modalProps,
      ...t4,
      ...styleProps,
      ref: domRef,
      className: t7,
      children: children
    });
    $[13] = modalProps;
    $[14] = t4;
    $[15] = styleProps;
    $[16] = domRef;
    $[17] = t7;
    $[18] = children;
    $[19] = t8;
  } else {
    t8 = $[19];
  }
  let t9;
  if ($[20] !== t3 || $[21] !== t8) {
    t9 = /*#__PURE__*/jsx("div", {
      className: t1,
      style: t3,
      children: t8
    });
    $[20] = t3;
    $[21] = t8;
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== wrapperRef || $[24] !== t0 || $[25] !== t9) {
    t10 = /*#__PURE__*/jsxs("div", {
      ref: wrapperRef,
      children: [t0, t9]
    });
    $[23] = wrapperRef;
    $[24] = t0;
    $[25] = t9;
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  return t10;
});

/**
 * A low-level utility component for implementing things like info dialogs,
 * menus and pickers.
 */
const Popover = /*#__PURE__*/forwardRef(function Popover(props, forwardedRef) {
  const $ = c(14);
  let children;
  let otherProps;
  let state;
  if ($[0] !== props) {
    ({
      children,
      state,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = children;
    $[2] = otherProps;
    $[3] = state;
  } else {
    children = $[1];
    otherProps = $[2];
    state = $[3];
  }
  const wrapperRef = useRef(null);
  let t0;
  if ($[4] !== forwardedRef || $[5] !== props || $[6] !== wrapperRef || $[7] !== children) {
    t0 = /*#__PURE__*/jsx(PopoverWrapper, {
      ref: forwardedRef,
      ...props,
      wrapperRef: wrapperRef,
      children: children
    });
    $[4] = forwardedRef;
    $[5] = props;
    $[6] = wrapperRef;
    $[7] = children;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  let t1;
  if ($[9] !== otherProps || $[10] !== state.isOpen || $[11] !== wrapperRef || $[12] !== t0) {
    t1 = /*#__PURE__*/jsx(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: t0
    });
    $[9] = otherProps;
    $[10] = state.isOpen;
    $[11] = wrapperRef;
    $[12] = t0;
    $[13] = t1;
  } else {
    t1 = $[13];
  }
  return t1;
});
const PopoverWrapper = /*#__PURE__*/forwardRef(function PopoverWrapper(props, forwardedRef) {
  const $ = c(35);
  const {
    children,
    isOpen,
    hideArrow,
    isNonModal,
    state,
    wrapperRef
  } = props;
  const popoverRef = useObjectRef(forwardedRef);
  let t0;
  if ($[0] !== props || $[1] !== popoverRef) {
    t0 = {
      ...props,
      containerPadding: 8,
      popoverRef,
      maxHeight: null
    };
    $[0] = props;
    $[1] = popoverRef;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const {
    popoverProps,
    arrowProps,
    underlayProps,
    placement
  } = usePopover(t0, state);
  const t1 = placement;
  let t2;
  if ($[3] !== props || $[4] !== t1) {
    t2 = {
      ...props,
      placement: t1
    };
    $[3] = props;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const styleProps = usePopoverStyles(t2);
  let t3;
  if ($[6] !== isNonModal || $[7] !== underlayProps || $[8] !== isOpen) {
    t3 = !isNonModal && /*#__PURE__*/jsx(Blanket, {
      isTransparent: true,
      ...underlayProps,
      isOpen: isOpen
    });
    $[6] = isNonModal;
    $[7] = underlayProps;
    $[8] = isOpen;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== styleProps.style || $[11] !== popoverProps.style) {
    t4 = {
      ...styleProps.style,
      ...popoverProps.style
    };
    $[10] = styleProps.style;
    $[11] = popoverProps.style;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  let t5;
  if ($[13] !== isNonModal || $[14] !== state) {
    t5 = !isNonModal && /*#__PURE__*/jsx(DismissButton, {
      onDismiss: state.close
    });
    $[13] = isNonModal;
    $[14] = state;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== hideArrow || $[17] !== placement || $[18] !== arrowProps) {
    t6 = hideArrow ? null : /*#__PURE__*/jsx(DirectionIndicator, {
      ...arrowProps,
      fill: "surface",
      stroke: tokenSchema.color.border.emphasis,
      placement: placement,
      size: "regular"
    });
    $[16] = hideArrow;
    $[17] = placement;
    $[18] = arrowProps;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  let t7;
  if ($[20] !== state.close) {
    t7 = /*#__PURE__*/jsx(DismissButton, {
      onDismiss: state.close
    });
    $[20] = state.close;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  let t8;
  if ($[22] !== styleProps || $[23] !== popoverProps || $[24] !== t4 || $[25] !== popoverRef || $[26] !== t5 || $[27] !== t6 || $[28] !== children || $[29] !== t7) {
    t8 = /*#__PURE__*/jsxs("div", {
      ...styleProps,
      ...popoverProps,
      style: t4,
      ref: popoverRef,
      role: "presentation",
      children: [t5, t6, children, t7]
    });
    $[22] = styleProps;
    $[23] = popoverProps;
    $[24] = t4;
    $[25] = popoverRef;
    $[26] = t5;
    $[27] = t6;
    $[28] = children;
    $[29] = t7;
    $[30] = t8;
  } else {
    t8 = $[30];
  }
  let t9;
  if ($[31] !== wrapperRef || $[32] !== t3 || $[33] !== t8) {
    t9 = /*#__PURE__*/jsxs("div", {
      ref: wrapperRef,
      children: [t3, t8]
    });
    $[31] = wrapperRef;
    $[32] = t3;
    $[33] = t8;
    $[34] = t9;
  } else {
    t9 = $[34];
  }
  return t9;
});

// Utils
// -----------------------------------------------------------------------------

function usePopoverStyles(props) {
  const $ = c(19);
  const {
    hideArrow,
    isOpen,
    placement
  } = props;
  const consumerStyleProps = useStyleProps(props);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = transition("opacity", {
      easing: "easeIn"
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [t0, transition("transform", {
      delay: "short",
      duration: 0,
      easing: "linear"
    })];
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  let t3;
  if ($[2] !== hideArrow || $[3] !== isOpen || $[4] !== placement || $[5] !== consumerStyleProps.className) {
    const popoverStyles = css({
      backgroundColor: tokenSchema.color.background.surface,
      borderRadius: tokenSchema.size.radius.medium,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
      boxSizing: "content-box",
      opacity: 0,
      outline: 0,
      pointerEvents: "auto",
      position: "absolute",
      filter: `drop-shadow(0 1px 4px ${tokenSchema.color.shadow.regular})`,
      willChange: "filter, transform",
      transition: t1.join(", "),
      "&[data-placement=top]": {
        marginTop: tokenSchema.size.space.regular
      },
      "&[data-placement=bottom]": {
        marginBottom: tokenSchema.size.space.regular
      },
      "&[data-placement=left]": {
        marginLeft: tokenSchema.size.space.regular
      },
      "&[data-placement=right]": {
        marginRight: tokenSchema.size.space.regular
      },
      "&[data-open]": {
        opacity: 1,
        transition: transition(["opacity", "transform"], {
          easing: "easeOut"
        })
      },
      "&[data-placement=top][data-open]": {
        transform: `translateY(calc(${"var(--popover-offset)"} * -1))`
      },
      "&[data-placement=bottom][data-open]": {
        transform: `translateY(${"var(--popover-offset)"})`
      },
      "&[data-placement=left][data-open]": {
        transform: `translateX(calc(${"var(--popover-offset)"} * -1))`
      },
      "&[data-placement=right][data-open]": {
        transform: `translateX(${"var(--popover-offset)"})`
      }
    });
    const t4 = !hideArrow || undefined;
    const t5 = isOpen || undefined;
    if ($[8] !== t4 || $[9] !== placement || $[10] !== t5) {
      t2 = toDataAttributes({
        arrow: t4,
        placement,
        open: t5
      });
      $[8] = t4;
      $[9] = placement;
      $[10] = t5;
      $[11] = t2;
    } else {
      t2 = $[11];
    }
    t3 = classNames(popoverStyles, consumerStyleProps.className);
    $[2] = hideArrow;
    $[3] = isOpen;
    $[4] = placement;
    $[5] = consumerStyleProps.className;
    $[6] = t2;
    $[7] = t3;
  } else {
    t2 = $[6];
    t3 = $[7];
  }
  const t4 = hideArrow ? tokenSchema.size.space.regular : tokenSchema.size.space.large;
  let t5;
  if ($[12] !== t4 || $[13] !== consumerStyleProps.style) {
    t5 = {
      "--popover-offset": t4,
      ...consumerStyleProps.style
    };
    $[12] = t4;
    $[13] = consumerStyleProps.style;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  let t6;
  if ($[15] !== t2 || $[16] !== t3 || $[17] !== t5) {
    t6 = {
      ...t2,
      className: t3,
      style: t5
    };
    $[15] = t2;
    $[16] = t3;
    $[17] = t5;
    $[18] = t6;
  } else {
    t6 = $[18];
  }
  return t6;
}

/**
 * A low-level utility component for implementing things like info dialogs,
 * menus and pickers. They should only ever be displayed on devices with small
 * screens, for interfaces where popovers wouldn't be appropriate.
 */
const Tray = /*#__PURE__*/forwardRef(function Tray(props, forwardedRef) {
  const $ = c(14);
  let children;
  let otherProps;
  let state;
  if ($[0] !== props) {
    ({
      children,
      state,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = children;
    $[2] = otherProps;
    $[3] = state;
  } else {
    children = $[1];
    otherProps = $[2];
    state = $[3];
  }
  const wrapperRef = useRef(null);
  let t0;
  if ($[4] !== forwardedRef || $[5] !== props || $[6] !== wrapperRef || $[7] !== children) {
    t0 = /*#__PURE__*/jsx(TrayWrapper, {
      ref: forwardedRef,
      ...props,
      wrapperRef: wrapperRef,
      children: children
    });
    $[4] = forwardedRef;
    $[5] = props;
    $[6] = wrapperRef;
    $[7] = children;
    $[8] = t0;
  } else {
    t0 = $[8];
  }
  let t1;
  if ($[9] !== otherProps || $[10] !== state.isOpen || $[11] !== wrapperRef || $[12] !== t0) {
    t1 = /*#__PURE__*/jsx(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: t0
    });
    $[9] = otherProps;
    $[10] = state.isOpen;
    $[11] = wrapperRef;
    $[12] = t0;
    $[13] = t1;
  } else {
    t1 = $[13];
  }
  return t1;
});
let TrayWrapper = /*#__PURE__*/forwardRef(function TrayWrapper(props, forwardedRef) {
  let {
    children,
    state,
    isFixedHeight,
    isOpen,
    wrapperRef
  } = props;
  let domRef = useObjectRef(forwardedRef);
  let {
    modalProps,
    underlayProps
  } = useModalOverlay({
    ...props,
    isDismissable: true
  }, state, domRef);
  let styleProps = useStyleProps(props);

  // TODO: move to CSS' dynamic viewport units, when possible:
  // @see https://caniuse.com/viewport-unit-variants
  // ---------------------------------------------------------------------------
  // On mobile browsers, vh units are fixed based on the maximum height of the
  // screen. However, when you scroll, the toolbar and address bar shrink,
  // making the viewport resize. The visual viewport also shrinks when the
  // keyboard is displayed.
  let viewport = useViewportSize();

  // Attach Transition's nodeRef to outer most wrapper for node.reflow:
  // https://github.com/reactjs/react-transition-group/blob/c89f807067b32eea6f68fd6c622190d88ced82e2/src/Transition.js#L231
  return /*#__PURE__*/jsxs("div", {
    ref: wrapperRef,
    children: [/*#__PURE__*/jsx(Blanket, {
      ...underlayProps,
      isOpen: isOpen
    }), /*#__PURE__*/jsx("div", {
      className: css({
        boxSizing: 'border-box',
        display: 'flex',
        insetBlockStart: 0,
        insetInlineStart: 0,
        justifyContent: 'center',
        pointerEvents: 'none',
        position: 'fixed',
        height: '100vh',
        width: '100%',
        zIndex: 2 // above blanket
      }),
      style: {
        height: viewport.height
      },
      children: /*#__PURE__*/jsx("div", {
        ...modalProps,
        ...toDataAttributes({
          open: isOpen,
          fillScreen: isFixedHeight || undefined
        }),
        ref: domRef,
        style: Object.assign({}, isFixedHeight ? {
          height: `calc(${viewport.height}px - ${tokenSchema.size.space.xxlarge})`,
          top: tokenSchema.size.space.xxlarge
        } : {}, {
          maxHeight: `calc(${viewport.height}px - ${tokenSchema.size.space.xxlarge})`,
          paddingBottom: `max(calc(100vh - ${viewport.height}px), env(safe-area-inset-bottom))`
        }, styleProps.style),
        className: classNames(styleProps.className, css({
          backgroundColor: tokenSchema.color.background.surface,
          // TODO: component token?
          bottom: 0,
          maxWidth: '100vw',
          opacity: 0,
          outline: 0,
          pointerEvents: 'auto',
          position: 'absolute',
          transform: 'translateY(100%)',
          // initialise with offset
          width: '100%',
          zIndex: 2,
          // above blanket

          // NOTE: trays shouldn't be used for larger screens, but in case
          // they are we need to tweak the appearance.
          [breakpointQueries.above.mobile]: {
            borderStartStartRadius: tokenSchema.size.radius.medium,
            // TODO: component token?
            borderStartEndRadius: tokenSchema.size.radius.medium,
            // TODO: component token?
            maxWidth: breakpoints.tablet
          },
          // exit animation
          transition: transition(['opacity', 'transform'], {
            easing: 'easeIn'
          }),
          '&[data-open="true"]': {
            opacity: 1,
            transform: `translateY(0)`,
            // enter animation
            transition: transition(['opacity', 'transform'], {
              easing: 'easeOut',
              delay: 'short'
            })
          }
        })),
        children: children
      })
    })]
  });
});

export { Blanket, DirectionIndicator, Modal, Overlay, Popover, Transition, Tray };
