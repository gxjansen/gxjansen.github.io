'use client';
export { Item } from '@react-stately/collections';
import { c } from './react-compiler-runtime-19061925.js';
import { useActionGroup, useActionGroupItem } from '@react-aria/actiongroup';
import { FocusScope } from '@react-aria/focus';
import { PressResponder } from '@react-aria/interactions';
import { useObjectRef, useValueEffect, useResizeObserver, useLayoutEffect, filterDOMProps, mergeProps, useId } from '@react-aria/utils';
import { useListState } from '@react-stately/list';
import { forwardRef, useRef, useMemo, useCallback, useState } from 'react';
import { actionButtonClassList, ActionButton } from '@keystar/ui/button';
import { useProviderProps, KeystarProvider } from '@keystar/ui/core';
import { chevronDownIcon } from '@keystar/ui/icon/icons/chevronDownIcon';
import { moreHorizontalIcon } from '@keystar/ui/icon/icons/moreHorizontalIcon';
import { Icon } from '@keystar/ui/icon';
import { MenuTrigger, Menu, Item } from '@keystar/ui/menu';
import { Text, Kbd } from '@keystar/ui/typography';
import { Tooltip, TooltipTrigger } from '@keystar/ui/tooltip';
import { useSlotProps, SlotProvider, ClearSlots } from '@keystar/ui/slots';
import { useStyleProps, classNames, css, toDataAttributes, tokenSchema } from '@keystar/ui/style';
import { isReactText } from '@keystar/ui/utils';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';

function ActionGroup(props, forwardedRef) {
  props = useProviderProps(props);
  props = useSlotProps(props, 'actionGroup');
  let {
    density,
    prominence,
    isJustified,
    isDisabled,
    orientation = 'horizontal',
    overflowMode = 'wrap',
    onAction,
    buttonLabelBehavior,
    summaryIcon,
    ...otherProps
  } = props;

  // High prominence buttons should be used sparingly and in isolation, so they
  // are not supported in groups.
  prominence = prominence === 'low' ? 'low' : 'default';
  let domRef = useObjectRef(forwardedRef);
  let wrapperRef = useRef(null);
  let state = useListState({
    ...props,
    suppressTextValueWarning: true
  });
  let {
    actionGroupProps
  } = useActionGroup(props, state, domRef);
  let providerProps = {
    isDisabled
  };
  let styleProps = useStyleProps(props);

  // Only hide button text if every item contains more than just plain text (we assume an icon).
  let isIconCollapsible = useMemo(() => [...state.collection].every(item => typeof item.rendered !== 'string'), [state.collection]);
  let [{
    visibleItems,
    hideButtonText,
    isMeasuring
  }, setVisibleItems] = useValueEffect({
    visibleItems: state.collection.size,
    hideButtonText: buttonLabelBehavior === 'hide' && isIconCollapsible,
    isMeasuring: false
  });
  let selectionMode = state.selectionManager.selectionMode;
  let updateOverflow = useCallback(() => {
    if (overflowMode === 'wrap') {
      return;
    }
    if (orientation === 'vertical' && selectionMode !== 'none') {
      // Collapsing vertical action groups with selection is currently unsupported.
      return;
    }
    let computeVisibleItems = visibleItems_0 => {
      if (domRef.current && wrapperRef.current) {
        let listItems = Array.from(domRef.current.children);
        let containerSize = orientation === 'horizontal' ? wrapperRef.current.getBoundingClientRect().width : wrapperRef.current.getBoundingClientRect().height;
        let isShowingMenu = visibleItems_0 < state.collection.size;
        let calculatedSize = 0;
        let newVisibleItems = 0;
        if (isShowingMenu) {
          let item_0 = listItems.pop();
          if (item_0) {
            calculatedSize += orientation === 'horizontal' ? outerWidth(item_0, false, true) : outerHeight(item_0, false, true);
          }
        }
        for (let [i, item_1] of listItems.entries()) {
          calculatedSize += orientation === 'horizontal' ? outerWidth(item_1, i === 0, i === listItems.length - 1) : outerHeight(item_1, i === 0, i === listItems.length - 1);
          if (Math.round(calculatedSize) <= Math.round(containerSize)) {
            newVisibleItems++;
          } else {
            break;
          }
        }

        // If selection is enabled, and not all of the items fit, collapse all of them into a dropdown
        // immediately rather than having some visible and some not.
        if (selectionMode !== 'none' && newVisibleItems < state.collection.size) {
          return 0;
        }
        return newVisibleItems;
      }
      return visibleItems_0;
    };
    setVisibleItems(function* () {
      let hideButtonText_0 = buttonLabelBehavior === 'hide' && isIconCollapsible;

      // Update to show all items.
      yield {
        visibleItems: state.collection.size,
        hideButtonText: hideButtonText_0,
        isMeasuring: true
      };

      // Measure, and update to show the items that fit.
      let newVisibleItems_0 = computeVisibleItems(state.collection.size);
      let isMeasuring_0 = newVisibleItems_0 < state.collection.size && newVisibleItems_0 > 0;

      // If not all of the buttons fit, and buttonLabelBehavior is 'collapse', then first try hiding
      // the button text and only showing icons. Only if that still doesn't fit collapse into a menu.
      if (newVisibleItems_0 < state.collection.size && buttonLabelBehavior === 'collapse' && isIconCollapsible) {
        yield {
          visibleItems: state.collection.size,
          hideButtonText: true,
          isMeasuring: true
        };
        newVisibleItems_0 = computeVisibleItems(state.collection.size);
        isMeasuring_0 = newVisibleItems_0 < state.collection.size && newVisibleItems_0 > 0;
        hideButtonText_0 = true;
      }
      yield {
        visibleItems: newVisibleItems_0,
        hideButtonText: hideButtonText_0,
        isMeasuring: isMeasuring_0
      };

      // If the number of items is less than the number of children,
      // then update again to ensure that the menu fits.
      if (isMeasuring_0) {
        yield {
          visibleItems: computeVisibleItems(newVisibleItems_0),
          hideButtonText: hideButtonText_0,
          isMeasuring: false
        };
      }
    });
  }, [domRef, state.collection, setVisibleItems, overflowMode, selectionMode, buttonLabelBehavior, isIconCollapsible, orientation]);

  // Watch the parent element for size changes. Watching only the action group itself may not work
  // in all scenarios because it may not shrink when available space is reduced.
  let parentRef = useMemo(() => ({
    get current() {
      var _wrapperRef$current;
      return (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.parentElement;
    }
  }), [wrapperRef]);
  useResizeObserver({
    ref: overflowMode !== 'wrap' ? parentRef : undefined,
    onResize: updateOverflow
  });
  useLayoutEffect(updateOverflow, [updateOverflow, state.collection]);
  let children = [...state.collection];
  let menuItem = null;
  let menuProps = {};

  // If there are no visible items, don't apply any props to the action group container
  // and pass all aria labeling props through to the menu button.
  if (overflowMode === 'collapse' && visibleItems === 0) {
    menuProps = filterDOMProps(props, {
      labelable: true
    });
    actionGroupProps = {};
  }
  if (overflowMode === 'collapse' && visibleItems < state.collection.size) {
    let menuChildren = children.slice(visibleItems);
    children = children.slice(0, visibleItems);
    menuItem = /*#__PURE__*/jsx(ActionGroupMenu, {
      ...menuProps,
      items: menuChildren,
      prominence: prominence,
      onAction: onAction,
      isDisabled: isDisabled,
      state: state,
      summaryIcon: summaryIcon,
      hideButtonText: hideButtonText,
      isOnlyItem: visibleItems === 0,
      orientation: orientation
    });
  }
  let style = {
    ...styleProps.style,
    // While measuring, take up as much space as possible.
    flexBasis: isMeasuring ? '100%' : undefined
  };
  return /*#__PURE__*/jsx(FocusScope, {
    children: /*#__PURE__*/jsx("div", {
      ...styleProps,
      style: style,
      className: classNames(css({
        display: 'flex',
        minWidth: 0
      }), styleProps.className),
      ref: wrapperRef,
      children: /*#__PURE__*/jsx("div", {
        ...actionGroupProps,
        ...toDataAttributes({
          overflow: overflowMode,
          prominence,
          justified: isJustified && !isMeasuring || undefined,
          compact: density === 'compact' || undefined,
          vertical: orientation === 'vertical' || undefined
        }),
        ref: domRef,
        className: classNames(css({
          display: 'flex',
          // NOTE: prefer `gap` but it breaks the measurement/collapse logic, so we use margin instead.
          margin: `calc(var(--action-item-gap) / -2)`,
          minWidth: 0,
          width: 'calc(100% + var(--action-item-gap) + 1px)',
          '--action-item-gap': tokenSchema.size.space.regular,
          [actionButtonClassList.selector('root', 'child')]: {
            margin: `calc(var(--action-item-gap) / 2)`
          },
          // wrap
          '&[data-overflow=wrap]': {
            flexWrap: 'wrap'
          },
          // justified
          '&[data-justified]': {
            [actionButtonClassList.selector('root', 'child')]: {
              flexGrow: 1
            }
          },
          // compact
          '&[data-compact]:not([data-prominence=low])': {
            '--action-item-gap': 0,
            // gap: 0,

            [actionButtonClassList.selector('root', 'child')]: {
              borderRadius: 0,
              '&:first-of-type': {
                borderTopLeftRadius: tokenSchema.size.radius.regular,
                borderBottomLeftRadius: tokenSchema.size.radius.regular
              },
              '&:last-of-type': {
                borderTopRightRadius: tokenSchema.size.radius.regular,
                borderBottomRightRadius: tokenSchema.size.radius.regular
              },
              '&:not(:last-of-type)': {
                marginRight: `calc(${tokenSchema.size.border.regular} * -1)`
              },
              '&[data-interaction=hover], &[data-focus=visible], &[data-interaction=press]': {
                zIndex: 1
              },
              '&[data-selected]': {
                zIndex: 2
              }
            }
          },
          '&[data-compact][data-prominence=low]': {
            '--action-item-gap': tokenSchema.size.space.small
          }
        }), otherProps.UNSAFE_className),
        children: /*#__PURE__*/jsxs(KeystarProvider, {
          ...providerProps,
          children: [children.map(item_2 => /*#__PURE__*/jsx(ActionGroupItem, {
            onAction: onAction,
            prominence: prominence,
            isDisabled: isDisabled,
            item: item_2,
            state: state,
            hideButtonText: hideButtonText,
            orientation: orientation
          }, item_2.key)), menuItem]
        })
      })
    })
  });
}

// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref

/** Group related action buttons together. */
const _ActionGroup = /*#__PURE__*/forwardRef(ActionGroup);
function ActionGroupItem(t0) {
  const $ = c(58);
  let {
    item,
    state,
    isDisabled,
    onAction,
    hideButtonText,
    orientation,
    prominence
  } = t0;
  const ref = useRef(null);
  let t1;
  if ($[0] !== item.key) {
    t1 = {
      key: item.key
    };
    $[0] = item.key;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let {
    buttonProps
  } = useActionGroupItem(t1, state);
  let t2;
  if ($[2] !== isDisabled || $[3] !== state || $[4] !== item) {
    t2 = isDisabled || state.disabledKeys.has(item.key);
    $[2] = isDisabled;
    $[3] = state;
    $[4] = item;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  isDisabled = t2;
  let t3;
  if ($[6] !== state.selectionManager || $[7] !== item.key) {
    t3 = state.selectionManager.isSelected(item.key);
    $[6] = state.selectionManager;
    $[7] = item.key;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const isSelected = t3;
  const domProps = filterDOMProps(item.props);
  if (onAction && !isDisabled) {
    let t4;
    if ($[9] !== onAction || $[10] !== item.key) {
      t4 = () => onAction(item.key);
      $[9] = onAction;
      $[10] = item.key;
      $[11] = t4;
    } else {
      t4 = $[11];
    }
    let t5;
    if ($[12] !== t4 || $[13] !== buttonProps) {
      t5 = mergeProps(buttonProps, {
        onPress: t4
      });
      $[12] = t4;
      $[13] = buttonProps;
      $[14] = t5;
    } else {
      t5 = $[14];
    }
    buttonProps = t5;
  }
  const textId = useId();
  const kbdId = useId();
  const [textContent, setTextContent] = useState("");
  const [kbdContent, setKbdContent] = useState("");
  let t4;
  if ($[15] !== hideButtonText || $[16] !== textId || $[17] !== kbdId) {
    t4 = () => {
      if (hideButtonText) {
        var _document$getElementB, _document$getElementB2;
        setTextContent((_document$getElementB = document.getElementById(textId)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.textContent);
        setKbdContent((_document$getElementB2 = document.getElementById(kbdId)) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.textContent);
      }
    };
    $[15] = hideButtonText;
    $[16] = textId;
    $[17] = kbdId;
    $[18] = t4;
  } else {
    t4 = $[18];
  }
  let t5;
  if ($[19] !== hideButtonText || $[20] !== item.rendered || $[21] !== textId || $[22] !== kbdId) {
    t5 = [hideButtonText, item.rendered, textId, kbdId];
    $[19] = hideButtonText;
    $[20] = item.rendered;
    $[21] = textId;
    $[22] = kbdId;
    $[23] = t5;
  } else {
    t5 = $[23];
  }
  useLayoutEffect(t4, t5);
  const t6 = mergeProps(buttonProps, domProps);
  const t7 = hideButtonText ? kbdId : undefined;
  let t8;
  if ($[24] !== t7) {
    t8 = {
      id: t7,
      isHidden: true
    };
    $[24] = t7;
    $[25] = t8;
  } else {
    t8 = $[25];
  }
  const t9 = hideButtonText ? textId : undefined;
  let t10;
  if ($[26] !== t9 || $[27] !== hideButtonText) {
    t10 = {
      id: t9,
      isHidden: hideButtonText
    };
    $[26] = t9;
    $[27] = hideButtonText;
    $[28] = t10;
  } else {
    t10 = $[28];
  }
  let t11;
  if ($[29] !== t8 || $[30] !== t10) {
    t11 = {
      kbd: t8,
      text: t10
    };
    $[29] = t8;
    $[30] = t10;
    $[31] = t11;
  } else {
    t11 = $[31];
  }
  let t12;
  if ($[32] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = classNames(css({
      flexShrink: 0
    }));
    $[32] = t12;
  } else {
    t12 = $[32];
  }
  const t13 = item["aria-label"];
  const t14 = item["aria-label"] == null && hideButtonText ? textId : undefined;
  let t15;
  if ($[33] !== item.props || $[34] !== item.rendered || $[35] !== prominence || $[36] !== ref || $[37] !== isSelected || $[38] !== isDisabled || $[39] !== t13 || $[40] !== t14) {
    t15 = /*#__PURE__*/jsx(ActionButton, {
      ...item.props,
      prominence: prominence,
      ref: ref,
      UNSAFE_className: t12,
      isSelected: isSelected,
      isDisabled: isDisabled,
      "aria-label": t13,
      "aria-labelledby": t14,
      children: item.rendered
    });
    $[33] = item.props;
    $[34] = item.rendered;
    $[35] = prominence;
    $[36] = ref;
    $[37] = isSelected;
    $[38] = isDisabled;
    $[39] = t13;
    $[40] = t14;
    $[41] = t15;
  } else {
    t15 = $[41];
  }
  let t16;
  if ($[42] !== t11 || $[43] !== t15) {
    t16 = /*#__PURE__*/jsx(ClearSlots, {
      children: /*#__PURE__*/jsx(SlotProvider, {
        slots: t11,
        children: t15
      })
    });
    $[42] = t11;
    $[43] = t15;
    $[44] = t16;
  } else {
    t16 = $[44];
  }
  let t17;
  if ($[45] !== t6 || $[46] !== t16) {
    t17 = /*#__PURE__*/jsx(PressResponder, {
      ...t6,
      children: t16
    });
    $[45] = t6;
    $[46] = t16;
    $[47] = t17;
  } else {
    t17 = $[47];
  }
  let button = t17;
  if (hideButtonText && textContent) {
    const t18 = orientation === "vertical" ? "end" : "top";
    let t19;
    if ($[48] !== kbdContent || $[49] !== textContent) {
      t19 = /*#__PURE__*/jsx(Tooltip, {
        children: kbdContent ? /*#__PURE__*/jsxs(Fragment, {
          children: [/*#__PURE__*/jsx(Text, {
            children: textContent
          }), /*#__PURE__*/jsx(Kbd, {
            children: kbdContent
          })]
        }) : textContent
      });
      $[48] = kbdContent;
      $[49] = textContent;
      $[50] = t19;
    } else {
      t19 = $[50];
    }
    let t20;
    if ($[51] !== t18 || $[52] !== button || $[53] !== t19) {
      t20 = /*#__PURE__*/jsxs(TooltipTrigger, {
        placement: t18,
        children: [button, t19]
      });
      $[51] = t18;
      $[52] = button;
      $[53] = t19;
      $[54] = t20;
    } else {
      t20 = $[54];
    }
    button = t20;
  }
  if (item.wrapper) {
    let t18;
    if ($[55] !== item || $[56] !== button) {
      t18 = item.wrapper(button);
      $[55] = item;
      $[56] = button;
      $[57] = t18;
    } else {
      t18 = $[57];
    }
    button = t18;
  }
  return button;
}
function ActionGroupMenu({
  hideButtonText,
  isDisabled,
  isOnlyItem,
  items,
  onAction,
  orientation,
  prominence,
  state,
  summaryIcon,
  ...otherProps
}) {
  // Use the key of the first item within the menu as the key of the button.
  // The key must actually exist in the collection for focus to work correctly.
  let key = items[0].key;
  let {
    buttonProps
  } = useActionGroupItem({
    key
  }, state);

  // The menu button shouldn't act like an actual action group item.
  delete buttonProps.onPress;
  delete buttonProps.role;
  delete buttonProps['aria-checked'];

  // If no aria-label or aria-labelledby is given, provide a default one.
  let ariaLabel = otherProps['aria-label'] || (otherProps['aria-labelledby'] ? undefined : '…');
  let ariaLabelledby = otherProps['aria-labelledby'];
  let textId = useId();
  let id = useId();

  // Summary icon only applies when selection is enabled.
  if (state.selectionManager.selectionMode === 'none') {
    summaryIcon = null;
  }

  // If there is a selection, show the selected state on the menu button.
  let isSelected = state.selectionManager.selectionMode !== 'none' && items.some(i => state.selectionManager.isSelected(i.key));

  // If single selection and empty selection is not allowed, swap the contents of the button to the selected item (like a Picker).
  if (!summaryIcon && state.selectionManager.selectionMode === 'single' && state.selectionManager.disallowEmptySelection && state.selectionManager.firstSelectedKey != null) {
    let selectedItem = state.collection.getItem(state.selectionManager.firstSelectedKey);
    if (selectedItem) {
      var _ariaLabelledby;
      summaryIcon = selectedItem.rendered;
      if (isReactText(summaryIcon)) {
        summaryIcon = /*#__PURE__*/jsx(Text, {
          children: summaryIcon
        });
      }
      ariaLabelledby = `${(_ariaLabelledby = ariaLabelledby) !== null && _ariaLabelledby !== void 0 ? _ariaLabelledby : id} ${textId}`;
    }
  }
  if (summaryIcon) {
    // If there's a custom summary icon, also add a chevron.
    summaryIcon = /*#__PURE__*/jsxs(Fragment, {
      children: [summaryIcon, /*#__PURE__*/jsx(Icon, {
        src: chevronDownIcon
      })]
    });
  }
  return (
    /*#__PURE__*/
    // Use a PressResponder to send DOM props through.
    jsxs(MenuTrigger, {
      align: isOnlyItem ? 'start' : 'end',
      direction: orientation === 'vertical' ? 'end' : 'bottom',
      children: [/*#__PURE__*/jsx(SlotProvider, {
        slots: {
          text: {
            id: hideButtonText ? textId : undefined,
            isHidden: hideButtonText
          }
        },
        children: /*#__PURE__*/jsx(PressResponder, {
          ...buttonProps,
          children: /*#__PURE__*/jsx(ActionButton, {
            ...otherProps,
            id: id,
            prominence: prominence,
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledby,
            isDisabled: isDisabled,
            isSelected: isSelected,
            children: summaryIcon || /*#__PURE__*/jsx(Icon, {
              src: moreHorizontalIcon
            })
          })
        })
      }), /*#__PURE__*/jsx(Menu, {
        items: items,
        disabledKeys: state.disabledKeys,
        selectionMode: state.selectionManager.selectionMode,
        selectedKeys: state.selectionManager.selectedKeys,
        disallowEmptySelection: state.selectionManager.disallowEmptySelection,
        onSelectionChange: keys => state.selectionManager.setSelectedKeys(keys),
        onAction: onAction,
        children: node => /*#__PURE__*/jsx(Item, {
          ...node.props,
          textValue: node.textValue,
          children: node.rendered
        })
      })]
    })
  );
}
function outerWidth(element, ignoreLeftMargin, ignoreRightMargin) {
  let style = window.getComputedStyle(element);
  return element.offsetWidth + (ignoreLeftMargin ? 0 : toNumber(style.marginLeft)) + (ignoreRightMargin ? 0 : toNumber(style.marginRight));
}
function outerHeight(element, ignoreTopMargin, ignoreBottomMargin) {
  let style = window.getComputedStyle(element);
  return element.offsetHeight + (ignoreTopMargin ? 0 : toNumber(style.marginTop)) + (ignoreBottomMargin ? 0 : toNumber(style.marginBottom));
}
function toNumber(value) {
  let parsed = parseInt(value, 10);
  return isNaN(parsed) ? 0 : parsed;
}

export { _ActionGroup as ActionGroup };
