'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { ListKeyboardDelegate, useSelectableCollection } from '@react-aria/selection';
import { chain, mergeProps, filterDOMProps, isMac } from '@react-aria/utils';
import { useListState } from '@react-stately/list';
import { useRef, useEffect, forwardRef, useState, useImperativeHandle, Fragment, useId, createContext, useContext } from 'react';
import { useListBoxLayout, ListBoxBase, listStyles } from '@keystar/ui/listbox';
export { Item, Section } from '@keystar/ui/listbox';
import { jsx } from 'react/jsx-runtime';
import { useFloating, hide, offset, shift, limitShift, flip, size, FloatingPortal, autoUpdate } from '@floating-ui/react';
import { useStyleProps, classNames, css, tokenSchema, onlyStyleProps } from '@keystar/ui/style';
import { FocusScope, createFocusManager } from '@react-aria/focus';
import { useLocale } from '@react-aria/i18n';
import { PressResponder } from '@react-aria/interactions';
import { assertNever, assert } from 'emery';
import { ActionButton, ToggleButton } from '@keystar/ui/button';
import { HStack } from '@keystar/ui/layout';

function EditorListbox(props) {
  var _scrollRef;
  const $ = c(23);
  let scrollRef;
  let listenerRef;
  let onEscape;
  let otherProps;
  if ($[0] !== props) {
    ({
      listenerRef,
      onEscape,
      scrollRef,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = scrollRef;
    $[2] = listenerRef;
    $[3] = onEscape;
    $[4] = otherProps;
  } else {
    scrollRef = $[1];
    listenerRef = $[2];
    onEscape = $[3];
    otherProps = $[4];
  }
  const state = useListState(props);
  const layout = useListBoxLayout();
  const listboxRef = useRef(null);
  let t0;
  t0 = new ListKeyboardDelegate({
    collection: state.collection,
    ref: listboxRef,
    layoutDelegate: layout
  });
  const delegate = t0;
  const {
    collectionProps
  } = useSelectableCollection({
    keyboardDelegate: delegate,
    ref: listenerRef,
    scrollRef: (_scrollRef = scrollRef) !== null && _scrollRef !== void 0 ? _scrollRef : listboxRef,
    selectionManager: state.selectionManager,
    disallowEmptySelection: true,
    disallowTypeAhead: true,
    isVirtualized: true,
    shouldFocusWrap: true
  });
  let t1;
  if ($[5] !== state.selectionManager || $[6] !== props.onAction || $[7] !== onEscape) {
    t1 = e => {
      bb8: switch (e.key) {
        case "Enter":
          {
            var _props$onAction;
            state.selectionManager.select(state.selectionManager.focusedKey);
            (_props$onAction = props.onAction) === null || _props$onAction === void 0 || _props$onAction.call(props, state.selectionManager.focusedKey);
            break bb8;
          }
        case "Escape":
          {
            var _onEscape;
            (_onEscape = onEscape) === null || _onEscape === void 0 || _onEscape();
          }
      }
    };
    $[5] = state.selectionManager;
    $[6] = props.onAction;
    $[7] = onEscape;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  const onKeyDown = t1;
  let t2;
  if ($[9] !== onKeyDown || $[10] !== collectionProps.onKeyDown) {
    t2 = chain(onKeyDown, collectionProps.onKeyDown);
    $[9] = onKeyDown;
    $[10] = collectionProps.onKeyDown;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  const keydownListener = t2;
  let t3;
  if ($[12] !== listenerRef.current || $[13] !== keydownListener) {
    t3 = () => {
      const domNode = listenerRef.current;
      domNode === null || domNode === void 0 || domNode.addEventListener("keydown", keydownListener);
      return () => domNode === null || domNode === void 0 ? void 0 : domNode.removeEventListener("keydown", keydownListener);
    };
    $[12] = listenerRef.current;
    $[13] = keydownListener;
    $[14] = t3;
  } else {
    t3 = $[14];
  }
  let t4;
  if ($[15] !== keydownListener || $[16] !== listenerRef) {
    t4 = [keydownListener, listenerRef];
    $[15] = keydownListener;
    $[16] = listenerRef;
    $[17] = t4;
  } else {
    t4 = $[17];
  }
  useEffect(t3, t4);
  let t5;
  if ($[18] !== listboxRef || $[19] !== layout || $[20] !== state || $[21] !== otherProps) {
    t5 = /*#__PURE__*/jsx(ListBoxBase, {
      ref: listboxRef,
      layout: layout,
      state: state,
      autoFocus: "first",
      shouldUseVirtualFocus: true,
      shouldFocusWrap: true,
      UNSAFE_className: listStyles,
      ...otherProps
    });
    $[18] = listboxRef;
    $[19] = layout;
    $[20] = state;
    $[21] = otherProps;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  return t5;
}

const EditorPopover = /*#__PURE__*/forwardRef(function EditorPopover(props, forwardedRef) {
  const $ = c(23);
  props = useDefaultProps(props);
  const {
    children,
    reference,
    placement,
    portal
  } = props;
  const Wrapper = portal ? FloatingPortal : Fragment;
  const styleProps = useStyleProps(props);
  const [floating, setFloating] = useState(null);
  let t0;
  if ($[0] !== props) {
    t0 = getMiddleware(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const middleware = t0;
  let t1;
  if ($[2] !== reference || $[3] !== floating) {
    t1 = {
      reference,
      floating
    };
    $[2] = reference;
    $[3] = floating;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== t1 || $[6] !== middleware || $[7] !== placement) {
    t2 = {
      elements: t1,
      middleware,
      placement,
      whileElementsMounted: autoUpdate
    };
    $[5] = t1;
    $[6] = middleware;
    $[7] = placement;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const {
    floatingStyles,
    context,
    update
  } = useFloating(t2);
  let t3;
  let t4;
  if ($[9] !== context || $[10] !== update) {
    t3 = () => ({
      context,
      update
    });
    t4 = [context, update];
    $[9] = context;
    $[10] = update;
    $[11] = t3;
    $[12] = t4;
  } else {
    t3 = $[11];
    t4 = $[12];
  }
  useImperativeHandle(forwardedRef, t3, t4);
  let t5;
  if ($[13] !== floatingStyles || $[14] !== styleProps.style) {
    t5 = {
      ...floatingStyles,
      ...styleProps.style
    };
    $[13] = floatingStyles;
    $[14] = styleProps.style;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== styleProps || $[17] !== t5 || $[18] !== children) {
    t6 = /*#__PURE__*/jsx(DialogElement, {
      ref: setFloating,
      ...styleProps,
      style: t5,
      children: children
    });
    $[16] = styleProps;
    $[17] = t5;
    $[18] = children;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  let t7;
  if ($[20] !== Wrapper || $[21] !== t6) {
    t7 = /*#__PURE__*/jsx(Wrapper, {
      children: t6
    });
    $[20] = Wrapper;
    $[21] = t6;
    $[22] = t7;
  } else {
    t7 = $[22];
  }
  return t7;
});

// Utils
// ------------------------------

function useDefaultProps(props) {
  return Object.assign({}, {
    adaptToBoundary: 'flip',
    placement: 'bottom',
    portal: true
  }, props);
}
const DEFAULT_OFFSET = 8;

/**
 * Watch for values returned from other middlewares and apply the appropriate
 * styles to the floating element.
 */
function applyStyles() {
  return {
    name: 'applyStyles',
    async fn(state) {
      let {
        elements,
        middlewareData
      } = state;
      if (middlewareData.hide) {
        Object.assign(elements.floating.style, {
          visibility: middlewareData.hide.referenceHidden ? 'hidden' : 'visible'
        });
      }
      return {};
    }
  };
}
function getMiddleware(props) {
  const {
    adaptToBoundary,
    boundary
  } = props;

  // simulate clipping for portaled popovers
  let portalMiddlewares = [...(props.portal ? [hide({
    boundary
  })] : []), applyStyles()];

  // stick to the boundary
  if (adaptToBoundary === 'stick') {
    return [offset(DEFAULT_OFFSET), shift({
      boundary,
      crossAxis: true,
      padding: DEFAULT_OFFSET,
      limiter: limitShift({
        offset: ({
          rects,
          middlewareData,
          placement
        }) => {
          var _middlewareData$offse, _middlewareData$offse2;
          return {
            crossAxis: rects.floating.height + ((_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) === null || _middlewareData$offse2 === void 0 ? void 0 : _middlewareData$offse2.y) !== null && _middlewareData$offse !== void 0 ? _middlewareData$offse : 0) * (placement === 'top' ? -1 : 1)
          };
        }
      })
    }), ...portalMiddlewares];
  }

  // stretch to fill
  if (adaptToBoundary === 'stretch') {
    return [offset(DEFAULT_OFFSET), flip({
      boundary,
      padding: DEFAULT_OFFSET
    }), size({
      apply({
        elements,
        availableHeight
      }) {
        Object.assign(elements.floating.style, {
          maxHeight: `${availableHeight}px`
        });
      },
      boundary,
      padding: DEFAULT_OFFSET
    }), ...portalMiddlewares];
  }

  // default: flip
  return [offset(DEFAULT_OFFSET), flip({
    boundary,
    padding: DEFAULT_OFFSET
  }), shift({
    padding: DEFAULT_OFFSET
  }), ...portalMiddlewares];
}

// Styled components
// ------------------------------

const DialogElement = /*#__PURE__*/forwardRef(function DialogElement(props, forwardedRef) {
  const $ = c(6);
  let t0;
  if ($[0] !== props.className) {
    t0 = classNames(css({
      backgroundColor: tokenSchema.color.background.surface,
      borderRadius: tokenSchema.size.radius.medium,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
      boxShadow: `${tokenSchema.size.shadow.medium} ${tokenSchema.color.shadow.regular}`,
      boxSizing: "content-box",
      minHeight: tokenSchema.size.element.regular,
      minWidth: tokenSchema.size.element.regular,
      outline: 0
    }), props.className);
    $[0] = props.className;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== forwardedRef || $[3] !== props || $[4] !== t0) {
    t1 = /*#__PURE__*/jsx("div", {
      role: "dialog",
      ref: forwardedRef,
      ...props,
      className: t0
    });
    $[2] = forwardedRef;
    $[3] = props;
    $[4] = t0;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  return t1;
});

const EditorToolbarContext = /*#__PURE__*/createContext(null);
function useToolbarContext() {
  const $ = c(2);
  const context = useContext(EditorToolbarContext);
  if (context == null) {
    throw new Error("useToolbarContext must be used within a EditorToolbar");
  }
  let t0;
  if ($[0] !== context) {
    t0 = {
      state: context
    };
    $[0] = context;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function EditorToolbar(props) {
  const $ = c(7);
  const {
    children
  } = props;
  const ref = useRef(null);
  const {
    state,
    toolbarProps
  } = useToolbar(props, ref);
  let t0;
  if ($[0] !== ref || $[1] !== toolbarProps || $[2] !== children) {
    t0 = /*#__PURE__*/jsx(FocusScope, {
      children: /*#__PURE__*/jsx(HStack, {
        alignItems: "center",
        gap: "regular",
        ref: ref,
        ...toolbarProps,
        children: children
      })
    });
    $[0] = ref;
    $[1] = toolbarProps;
    $[2] = children;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  let t1;
  if ($[4] !== state || $[5] !== t0) {
    t1 = /*#__PURE__*/jsx(EditorToolbarContext.Provider, {
      value: state,
      children: t0
    });
    $[4] = state;
    $[5] = t0;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  return t1;
}

// =============================================================================
// Group
// =============================================================================

const GroupSelectionContext = /*#__PURE__*/createContext(null);
function useGroupSelectionContext() {
  const $ = c(3);
  const context = useContext(GroupSelectionContext);
  assert(context !== null, "An `EditorToolbarItem` is only valid inside an `EditorToolbarGroup` with a `selectionMode` of \"single\" or \"multiple\". When no selection is needed, use `EditorToolbarButton` instead.");
  const disabledKeys = useSetFromIterable(context.disabledKeys);
  let t0;
  if ($[0] !== context || $[1] !== disabledKeys) {
    t0 = {
      ...context,
      disabledKeys
    };
    $[0] = context;
    $[1] = disabledKeys;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}
function useSelectionItem(props) {
  const $ = c(37);
  const context = useGroupSelectionContext();
  if (context.selectionMode === "single") {
    const {
      disabledKeys,
      value,
      onChange
    } = context;
    let t0;
    if ($[0] !== disabledKeys || $[1] !== props.value) {
      t0 = disabledKeys.has(props.value);
      $[0] = disabledKeys;
      $[1] = props.value;
      $[2] = t0;
    } else {
      t0 = $[2];
    }
    const isDisabled = t0;
    const isSelected = value === props.value;
    let t1;
    if ($[3] !== props) {
      t1 = filterDOMProps(props, {
        labelable: true
      });
      $[3] = props;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    let t2;
    if ($[5] !== isDisabled || $[6] !== onChange || $[7] !== props.value) {
      t2 = () => {
        if (isDisabled) {
          return;
        }
        onChange(props.value);
      };
      $[5] = isDisabled;
      $[6] = onChange;
      $[7] = props.value;
      $[8] = t2;
    } else {
      t2 = $[8];
    }
    let t3;
    if ($[9] !== t1 || $[10] !== isSelected || $[11] !== t2) {
      t3 = {
        ...t1,
        role: "radio",
        "aria-checked": isSelected,
        onPress: t2
      };
      $[9] = t1;
      $[10] = isSelected;
      $[11] = t2;
      $[12] = t3;
    } else {
      t3 = $[12];
    }
    let t4;
    if ($[13] !== isDisabled || $[14] !== isSelected || $[15] !== t3) {
      t4 = {
        isDisabled,
        isSelected,
        buttonProps: t3
      };
      $[13] = isDisabled;
      $[14] = isSelected;
      $[15] = t3;
      $[16] = t4;
    } else {
      t4 = $[16];
    }
    return t4;
  }
  if (context.selectionMode === "multiple") {
    const {
      disabledKeys: disabledKeys_0,
      value: value_0,
      onChange: onChange_0
    } = context;
    let t0;
    if ($[17] !== disabledKeys_0 || $[18] !== props.value) {
      t0 = disabledKeys_0.has(props.value);
      $[17] = disabledKeys_0;
      $[18] = props.value;
      $[19] = t0;
    } else {
      t0 = $[19];
    }
    const isDisabled_0 = t0;
    let t1;
    if ($[20] !== value_0 || $[21] !== props.value) {
      t1 = value_0.includes(props.value);
      $[20] = value_0;
      $[21] = props.value;
      $[22] = t1;
    } else {
      t1 = $[22];
    }
    const isSelected_0 = t1;
    let t2;
    if ($[23] !== props) {
      t2 = filterDOMProps(props, {
        labelable: true
      });
      $[23] = props;
      $[24] = t2;
    } else {
      t2 = $[24];
    }
    let t3;
    if ($[25] !== isDisabled_0 || $[26] !== onChange_0 || $[27] !== props.value) {
      t3 = () => {
        if (isDisabled_0) {
          return;
        }
        onChange_0(props.value);
      };
      $[25] = isDisabled_0;
      $[26] = onChange_0;
      $[27] = props.value;
      $[28] = t3;
    } else {
      t3 = $[28];
    }
    let t4;
    if ($[29] !== t2 || $[30] !== isSelected_0 || $[31] !== t3) {
      t4 = {
        ...t2,
        role: "checkbox",
        "aria-checked": isSelected_0,
        onPress: t3
      };
      $[29] = t2;
      $[30] = isSelected_0;
      $[31] = t3;
      $[32] = t4;
    } else {
      t4 = $[32];
    }
    let t5;
    if ($[33] !== isDisabled_0 || $[34] !== isSelected_0 || $[35] !== t4) {
      t5 = {
        isDisabled: isDisabled_0,
        isSelected: isSelected_0,
        buttonProps: t4
      };
      $[33] = isDisabled_0;
      $[34] = isSelected_0;
      $[35] = t4;
      $[36] = t5;
    } else {
      t5 = $[36];
    }
    return t5;
  }
  assertNever(context);
}
function EditorToolbarGroup(props) {
  const $ = c(9);
  if (props.selectionMode === "single") {
    let t0;
    if ($[0] !== props) {
      t0 = /*#__PURE__*/jsx(EditorSingleSelectionGroup, {
        ...props
      });
      $[0] = props;
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    return t0;
  }
  if (props.selectionMode === "multiple") {
    let t0;
    if ($[2] !== props) {
      t0 = /*#__PURE__*/jsx(EditorMultipleSelectionGroup, {
        ...props
      });
      $[2] = props;
      $[3] = t0;
    } else {
      t0 = $[3];
    }
    return t0;
  }
  let t0;
  if ($[4] !== props) {
    t0 = filterPropsWithLabelWarning(props);
    $[4] = props;
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  let t1;
  if ($[6] !== t0 || $[7] !== props.children) {
    t1 = /*#__PURE__*/jsx(HStack, {
      gap: "xsmall",
      role: "group",
      ...t0,
      children: props.children
    });
    $[6] = t0;
    $[7] = props.children;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  return t1;
}
/** @private SINGLE selection */
function EditorSingleSelectionGroup(props) {
  const $ = c(11);
  let children;
  let context;
  if ($[0] !== props) {
    ({
      children,
      ...context
    } = props);
    $[0] = props;
    $[1] = children;
    $[2] = context;
  } else {
    children = $[1];
    context = $[2];
  }
  let t0;
  if ($[3] !== props) {
    t0 = filterPropsWithLabelWarning(props);
    $[3] = props;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  let t1;
  if ($[5] !== t0 || $[6] !== children) {
    t1 = /*#__PURE__*/jsx(HStack, {
      gap: "xsmall",
      role: "radiogroup",
      ...t0,
      children: children
    });
    $[5] = t0;
    $[6] = children;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  let t2;
  if ($[8] !== context || $[9] !== t1) {
    t2 = /*#__PURE__*/jsx(GroupSelectionContext.Provider, {
      value: context,
      children: t1
    });
    $[8] = context;
    $[9] = t1;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  return t2;
}
/** @private MULTI selection */
function EditorMultipleSelectionGroup(props) {
  const $ = c(11);
  let children;
  let context;
  if ($[0] !== props) {
    ({
      children,
      ...context
    } = props);
    $[0] = props;
    $[1] = children;
    $[2] = context;
  } else {
    children = $[1];
    context = $[2];
  }
  let t0;
  if ($[3] !== props) {
    t0 = filterPropsWithLabelWarning(props);
    $[3] = props;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  let t1;
  if ($[5] !== t0 || $[6] !== children) {
    t1 = /*#__PURE__*/jsx(HStack, {
      gap: "xsmall",
      role: "group",
      ...t0,
      children: children
    });
    $[5] = t0;
    $[6] = children;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  let t2;
  if ($[8] !== context || $[9] !== t1) {
    t2 = /*#__PURE__*/jsx(GroupSelectionContext.Provider, {
      value: context,
      children: t1
    });
    $[8] = context;
    $[9] = t1;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  return t2;
}

// =============================================================================
// Item
// =============================================================================

/** A toolbar item may be a checkbox/radio/toggle button, depending on context. */
function EditorToolbarItem(props) {
  const $ = c(13);
  const {
    isDisabled,
    isSelected,
    buttonProps
  } = useSelectionItem(props);
  let t0;
  if ($[0] !== props || $[1] !== isDisabled) {
    t0 = {
      ...props,
      isDisabled
    };
    $[0] = props;
    $[1] = isDisabled;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const {
    itemProps
  } = useToolbarItem(t0);
  let t1;
  if ($[3] !== buttonProps || $[4] !== itemProps) {
    t1 = mergeProps(buttonProps, itemProps);
    $[3] = buttonProps;
    $[4] = itemProps;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== isDisabled || $[7] !== isSelected || $[8] !== props.children) {
    t2 = /*#__PURE__*/jsx(ActionButton, {
      prominence: "low",
      isDisabled: isDisabled,
      isSelected: isSelected,
      children: props.children
    });
    $[6] = isDisabled;
    $[7] = isSelected;
    $[8] = props.children;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  let t3;
  if ($[10] !== t1 || $[11] !== t2) {
    t3 = /*#__PURE__*/jsx(PressResponder, {
      ...t1,
      children: t2
    });
    $[10] = t1;
    $[11] = t2;
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  return t3;
}
function EditorToolbarButton(props) {
  const $ = c(5);
  const {
    itemProps
  } = useToolbarItem(props);
  let t0;
  if ($[0] !== props) {
    t0 = /*#__PURE__*/jsx(ToggleButton, {
      prominence: "low",
      ...props
    });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== itemProps || $[3] !== t0) {
    t1 = /*#__PURE__*/jsx(PressResponder, {
      ...itemProps,
      children: t0
    });
    $[2] = itemProps;
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}
function EditorToolbarSeparator() {
  const $ = c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /*#__PURE__*/jsx("div", {
      role: "separator",
      "aria-orientation": "vertical",
      className: css({
        alignSelf: "center",
        backgroundColor: tokenSchema.color.border.muted,
        flexShrink: 0,
        height: tokenSchema.size.icon.regular,
        width: tokenSchema.size.border.regular
      })
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}

// =============================================================================
// Utils
// =============================================================================

function filterPropsWithLabelWarning(props) {
  let {
    'aria-labelledby': ariaLabelledby,
    'aria-label': ariaLabel
  } = props;
  if (!ariaLabelledby && !ariaLabel) {
    console.warn('You must specify an aria-label or aria-labelledby attribute for accessibility.');
  }
  return {
    ...onlyStyleProps(props),
    ...filterDOMProps(props, {
      labelable: true
    })
  };
}
function useToolbarItem(props) {
  const $ = c(11);
  const {
    isDisabled
  } = props;
  const {
    state
  } = useToolbarContext();
  const {
    lastFocusedId,
    setLastFocusedId
  } = state;
  const id = useId();
  const tabIndex = lastFocusedId === id || lastFocusedId == null ? 0 : -1;
  let t0;
  let t1;
  if ($[0] !== id || $[1] !== isDisabled || $[2] !== setLastFocusedId) {
    t0 = () => {
      const reset = lastId => lastId === id ? null : lastId;
      if (isDisabled) {
        setLastFocusedId(reset);
      }
      return () => {
        setLastFocusedId(reset);
      };
    };
    t1 = [id, isDisabled, setLastFocusedId];
    $[0] = id;
    $[1] = isDisabled;
    $[2] = setLastFocusedId;
    $[3] = t0;
    $[4] = t1;
  } else {
    t0 = $[3];
    t1 = $[4];
  }
  useEffect(t0, t1);
  let t2;
  if ($[5] !== setLastFocusedId || $[6] !== id) {
    t2 = () => {
      setLastFocusedId(id);
    };
    $[5] = setLastFocusedId;
    $[6] = id;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  let t3;
  if ($[8] !== tabIndex || $[9] !== t2) {
    t3 = {
      itemProps: {
        tabIndex,
        onFocus: t2
      }
    };
    $[8] = tabIndex;
    $[9] = t2;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  return t3;
}
function useToolbar(props, ref) {
  const $ = c(15);
  const [lastFocusedId, setLastFocusedId] = useState(null);
  const {
    direction
  } = useLocale();
  let t0;
  if ($[0] !== ref) {
    t0 = createFocusManager(ref, {
      wrap: true
    });
    $[0] = ref;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const focusManager = t0;
  const isRtl = direction === "rtl";
  let t1;
  if ($[2] !== focusManager || $[3] !== isRtl) {
    t1 = e => {
      if (!e.currentTarget.contains(e.target)) {
        return;
      }
      const accept = node => {
        var _node$parentElement, _node$parentElement2;
        const isFirstChild = ((_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.firstElementChild) === node;
        const isGroupChild = /group/.test(((_node$parentElement2 = node.parentElement) === null || _node$parentElement2 === void 0 ? void 0 : _node$parentElement2.role) || "");
        return !isGroupChild || isFirstChild;
      };
      const options = (isMac() ? e.altKey : e.ctrlKey) ? {
        accept
      } : {};
      bb31: switch (e.key) {
        case "Home":
          {
            e.preventDefault();
            e.stopPropagation();
            focusManager.focusFirst();
            break bb31;
          }
        case "End":
          {
            e.preventDefault();
            e.stopPropagation();
            focusManager.focusLast();
            break bb31;
          }
        case "ArrowRight":
        case "ArrowDown":
          {
            e.preventDefault();
            e.stopPropagation();
            if (e.key === "ArrowRight" && isRtl) {
              focusManager.focusPrevious(options);
            } else {
              focusManager.focusNext(options);
            }
            break bb31;
          }
        case "ArrowLeft":
        case "ArrowUp":
          {
            e.preventDefault();
            e.stopPropagation();
            if (e.key === "ArrowLeft" && isRtl) {
              focusManager.focusNext(options);
            } else {
              focusManager.focusPrevious(options);
            }
          }
      }
    };
    $[2] = focusManager;
    $[3] = isRtl;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const onKeyDown = t1;
  let t2;
  if ($[5] !== props) {
    t2 = filterPropsWithLabelWarning(props);
    $[5] = props;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== t2 || $[8] !== onKeyDown) {
    t3 = {
      ...t2,
      onKeyDown,
      role: "toolbar",
      "aria-orientation": "horizontal"
    };
    $[7] = t2;
    $[8] = onKeyDown;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  let t5;
  if ($[10] !== lastFocusedId) {
    t5 = {
      lastFocusedId,
      setLastFocusedId
    };
    $[10] = lastFocusedId;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  t4 = t5;
  let t6;
  if ($[12] !== t3 || $[13] !== t4) {
    t6 = {
      toolbarProps: t3,
      state: t4
    };
    $[12] = t3;
    $[13] = t4;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  return t6;
}
function useSetFromIterable(value) {
  const $ = c(2);
  let t0;
  let t1;
  if ($[0] !== value) {
    t1 = value == null ? new Set() : new Set(value);
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  return t0;
}

export { EditorListbox, EditorPopover, EditorToolbar, EditorToolbarButton, EditorToolbarGroup, EditorToolbarItem, EditorToolbarSeparator };
