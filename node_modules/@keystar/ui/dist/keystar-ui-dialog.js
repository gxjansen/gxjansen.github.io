'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useObjectRef, mergeProps, chain, useEffectEvent } from '@react-aria/utils';
import React, { forwardRef, useContext, useRef, useMemo, useState, isValidElement, Children, useEffect, Fragment } from 'react';
import { ActionButton, Button, ButtonGroup } from '@keystar/ui/button';
import { SlotProvider, Content } from '@keystar/ui/slots';
import { ClassList, toDataAttributes, classNames, css, tokenSchema, useStyleProps, breakpointQueries, useMediaQuery } from '@keystar/ui/style';
import { Text, Heading } from '@keystar/ui/typography';
import { useHasChild, isReactText } from '@keystar/ui/utils';
import { useDialog } from '@react-aria/dialog';
import { useLocalizedStringFormatter } from '@react-aria/i18n';
import { xIcon } from '@keystar/ui/icon/icons/xIcon';
import { Icon } from '@keystar/ui/icon';
import { Grid } from '@keystar/ui/layout';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useOverlayTriggerState } from '@react-stately/overlays';
import { Modal, Popover, Tray } from '@keystar/ui/overlays';
import { assert, assertNever } from 'emery';
import { PressResponder } from '@react-aria/interactions';
import { useOverlayTrigger } from '@react-aria/overlays';

const DialogContext = /*#__PURE__*/React.createContext(null);

const localizedMessages = {
  "ar-AE": {
    "alert": `تنبيه`,
    "dismiss": `تجاهل`
  },
  "bg-BG": {
    "alert": `Сигнал`,
    "dismiss": `Отхвърляне`
  },
  "cs-CZ": {
    "alert": `Výstraha`,
    "dismiss": `Odstranit`
  },
  "da-DK": {
    "alert": `Advarsel`,
    "dismiss": `Luk`
  },
  "de-DE": {
    "alert": `Warnhinweis`,
    "dismiss": `Schließen`
  },
  "el-GR": {
    "alert": `Ειδοποίηση`,
    "dismiss": `Απόρριψη`
  },
  "en-US": {
    "alert": `Alert`,
    "dismiss": `Dismiss`
  },
  "es-ES": {
    "alert": `Alerta`,
    "dismiss": `Descartar`
  },
  "et-EE": {
    "alert": `Teade`,
    "dismiss": `Lõpeta`
  },
  "fi-FI": {
    "alert": `Hälytys`,
    "dismiss": `Hylkää`
  },
  "fr-FR": {
    "alert": `Alerte`,
    "dismiss": `Rejeter`
  },
  "he-IL": {
    "alert": `התראה`,
    "dismiss": `התעלם`
  },
  "hr-HR": {
    "alert": `Upozorenje`,
    "dismiss": `Odbaci`
  },
  "hu-HU": {
    "alert": `Figyelmeztetés`,
    "dismiss": `Elutasítás`
  },
  "it-IT": {
    "alert": `Avviso`,
    "dismiss": `Ignora`
  },
  "ja-JP": {
    "alert": `アラート`,
    "dismiss": `閉じる`
  },
  "ko-KR": {
    "alert": `경고`,
    "dismiss": `무시`
  },
  "lt-LT": {
    "alert": `Įspėjimas`,
    "dismiss": `Atmesti`
  },
  "lv-LV": {
    "alert": `Brīdinājums`,
    "dismiss": `Nerādīt`
  },
  "nb-NO": {
    "alert": `Varsel`,
    "dismiss": `Lukk`
  },
  "nl-NL": {
    "alert": `Melding`,
    "dismiss": `Negeren`
  },
  "pl-PL": {
    "alert": `Ostrzeżenie`,
    "dismiss": `Zignoruj`
  },
  "pt-BR": {
    "alert": `Alerta`,
    "dismiss": `Descartar`
  },
  "pt-PT": {
    "alert": `Alerta`,
    "dismiss": `Dispensar`
  },
  "ro-RO": {
    "alert": `Alertă`,
    "dismiss": `Revocare`
  },
  "ru-RU": {
    "alert": `Предупреждение`,
    "dismiss": `Пропустить`
  },
  "sk-SK": {
    "alert": `Upozornenie`,
    "dismiss": `Zrušiť`
  },
  "sl-SI": {
    "alert": `Opozorilo`,
    "dismiss": `Opusti`
  },
  "sr-SP": {
    "alert": `Upozorenje`,
    "dismiss": `Odbaci`
  },
  "sv-SE": {
    "alert": `Varning`,
    "dismiss": `Avvisa`
  },
  "tr-TR": {
    "alert": `Uyarı`,
    "dismiss": `Kapat`
  },
  "uk-UA": {
    "alert": `Сигнал тривоги`,
    "dismiss": `Скасувати`
  },
  "zh-CN": {
    "alert": `警报`,
    "dismiss": `取消`
  },
  "zh-T": {
    "alert": `警示`,
    "dismiss": `關閉`
  }
};

const dialogClassList = new ClassList('Dialog', ['root', 'grid', 'heading', 'header', 'footer', 'button-group']);

/**
 * Dialogs are windows containing contextual information, tasks, or workflows
 * that appear over the user interface. Depending on the kind of dialog, further
 * interactions may be blocked until the dialog is closed.
 */
const Dialog = /*#__PURE__*/forwardRef(function Dialog(props, forwardedRef) {
  let {
    type = 'modal',
    ...contextProps
  } = useContext(DialogContext) || {};
  let {
    children,
    isDismissable = contextProps.isDismissable,
    onDismiss = contextProps.onClose,
    size
  } = props;
  let stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let domRef = useObjectRef(forwardedRef);
  let gridRef = useRef(null);
  let {
    dialogProps,
    titleProps
  } = useDialog(mergeProps(contextProps, props), domRef);

  // analyse children to determine grid areas. need a unique identifier for each slot.
  // const headingSize = type === 'popover' ? 'small' : 'regular';
  const headingSize = 'regular';
  let hasHeading = useHasChild(dialogClassList.selector('heading'), gridRef);
  let hasHeader = useHasChild(dialogClassList.selector('header'), gridRef);
  let hasFooter = useHasChild(dialogClassList.selector('footer'), gridRef);
  let hasButtonGroup = useHasChild(dialogClassList.selector('button-group'), gridRef);
  let slots = useMemo(() => ({
    heading: {
      ...toDataAttributes({
        hasHeader
      }),
      UNSAFE_className: classNames(dialogClassList.element('heading'), getHeadingStyles()),
      elementType: 'h2',
      size: headingSize,
      // FIXME: declared as const—shouldn't need this weirdness.
      ...titleProps
    },
    header: {
      // ...toDataAttributes({ hasHeading }),
      UNSAFE_className: classNames(dialogClassList.element('header'), getHeaderStyles())
    },
    content: {
      ...toDataAttributes({
        hasHeader: hasHeader || hasHeading || undefined,
        hasFooter: hasFooter || hasButtonGroup && type !== 'fullscreen' || undefined
      }),
      UNSAFE_className: getContentStyles()
    },
    footer: {
      UNSAFE_className: classNames(dialogClassList.element('footer'), getFooterStyles())
    },
    buttonGroup: {
      ...toDataAttributes({
        hasFooter
      }),
      UNSAFE_className: classNames(dialogClassList.element('button-group'), getButtonGroupStyles()),
      align: 'end'
    }
  }), [hasButtonGroup, hasFooter, hasHeader, hasHeading, headingSize, titleProps, type]);
  const sizeVariant = getSizeVariant(type, size);
  const dialogStyleProps = useDialogStyleProps(props, {
    type,
    size: sizeVariant
  });
  const gridStyleProps = useGridStyleProps({
    isDismissable,
    size: sizeVariant
  });
  return /*#__PURE__*/jsx("section", {
    ...dialogStyleProps,
    ...dialogProps,
    ref: domRef,
    children: /*#__PURE__*/jsxs(Grid, {
      ref: gridRef,
      ...gridStyleProps,
      children: [/*#__PURE__*/jsx(SlotProvider, {
        slots: slots,
        children: children
      }), isDismissable && /*#__PURE__*/jsx(ActionButton, {
        prominence: "low",
        "aria-label": stringFormatter.format('dismiss'),
        onPress: onDismiss,
        gridArea: "closeButton",
        UNSAFE_className: css({
          placeSelf: 'flex-start end',
          paddingInline: 0,
          marginBlock: `calc((${tokenSchema.size.element.regular} - ${tokenSchema.typography.heading[headingSize].capheight}) / 2 * -1)`,
          marginInlineEnd: `calc(${tokenSchema.size.space.medium} * -1)`,
          marginInlineStart: tokenSchema.size.space.regular
        }),
        children: /*#__PURE__*/jsx(Icon, {
          src: xIcon,
          size: "medium"
        })
      })]
    })
  });
});

// Utils
// =============================================================================

function getSizeVariant(type, size) {
  if (type === 'fullscreen') {
    return 'fullscreen';
  }
  if (type === 'popover') {
    return size || 'xsmall';
  }
  return size || 'medium';
}

// Styles
// =============================================================================

function useDialogStyleProps(props, t0) {
  const $ = c(8);
  const {
    size,
    type
  } = t0;
  const styleProps = useStyleProps(props);
  const t1 = type === "tray" ? undefined : size;
  let t2;
  if ($[0] !== t1) {
    t2 = toDataAttributes({
      size: t1
    });
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] !== styleProps.className) {
    t3 = classNames(dialogClassList.element("root"), css({
      display: "flex",
      maxHeight: "inherit",
      maxWidth: "100%",
      outline: 0,
      width: "var(--dialog-width)",
      "--dialog-width": "fit-content",
      "&[data-size=\"xsmall\"]": {
        "--dialog-width": tokenSchema.size.dialog.xsmall
      },
      "&[data-size=\"small\"]": {
        "--dialog-width": tokenSchema.size.dialog.small
      },
      "&[data-size=\"medium\"]": {
        "--dialog-width": tokenSchema.size.dialog.medium
      },
      "&[data-size=\"large\"]": {
        "--dialog-width": tokenSchema.size.dialog.large
      },
      "&[data-size=\"fullscreen\"]": {
        maxHeight: "none",
        maxWidth: "none",
        height: "100%",
        "--dialog-width": "100%"
      }
    }), styleProps.className);
    $[2] = styleProps.className;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== t2 || $[5] !== styleProps || $[6] !== t3) {
    t4 = {
      ...t2,
      ...styleProps,
      className: t3
    };
    $[4] = t2;
    $[5] = styleProps;
    $[6] = t3;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  return t4;
}
function useGridStyleProps({
  isDismissable,
  size
}) {
  // NOTE: it's very tempting to use "gap" here but don't! It stops the grid
  // areas from collapsing, even when hidden or omitted.
  let gridStyles = css({
    display: 'grid',
    padding: tokenSchema.size.space.xxlarge,
    gridTemplateColumns: 'auto minmax(0, 1fr) auto',
    gridTemplateRows: 'auto minmax(0, 1fr) auto',
    gridTemplateAreas: `"heading header header"
      "content content content"
      "footer footer buttonGroup"`,
    width: '100%',
    '&[data-dismissable]': {
      gridTemplateColumns: 'auto minmax(0, 1fr) auto auto',
      gridTemplateAreas: `"heading header header closeButton"
        "content content content content"
        "footer footer footer footer"`,
      // slot styles
      [dialogClassList.selector('button-group')]: {
        display: 'none'
      }
    },
    // MOBILE SPECIFIC
    [breakpointQueries.below.tablet]: {
      padding: tokenSchema.size.space.xlarge,
      gridTemplateRows: 'auto auto minmax(0, 1fr) auto',
      gridTemplateAreas: `"heading heading heading"
      "header header header"
        "content content content"
        "footer footer buttonGroup"`,
      '&[data-dismissable]': {
        gridTemplateAreas: `"heading heading closeButton"
          "header header header"
            "content content content"
            "footer footer buttonGroup"`
      }
    },
    // TABLET & ABOVE
    [breakpointQueries.above.mobile]: {
      '&[data-size="fullscreen"]': {
        gridTemplateAreas: `"heading header buttonGroup"
          "content content content"
          "footer footer footer"`
      }
    }
  });
  return {
    ...toDataAttributes({
      dismissable: isDismissable || undefined,
      size
    }),
    UNSAFE_className: classNames(dialogClassList.element('grid'), gridStyles)
  };
}

// Slots
// -----------------------------------------------------------------------------

function getHeadingStyles() {
  return css({
    alignSelf: 'center',
    gridArea: 'heading',
    paddingBottom: tokenSchema.size.space.large,
    [breakpointQueries.above.mobile]: {
      paddingBottom: tokenSchema.size.space.xlarge
    },
    '&[data-has-header=false]': {
      gridArea: 'heading-start / heading-start / header-end / header-end'
    }
  });
}
function getHeaderStyles() {
  return css({
    alignItems: 'center',
    boxSizing: 'border-box',
    display: 'flex',
    gridArea: 'header',
    minWidth: 'fit-content',
    outline: 0,
    paddingBottom: tokenSchema.size.space.large,
    [breakpointQueries.above.mobile]: {
      justifyContent: 'flex-end',
      paddingBottom: tokenSchema.size.space.xlarge
    }
  });
}
function getContentStyles() {
  return css({
    gridArea: 'content',
    overflowX: 'hidden',
    overflowY: 'auto',
    WebkitOverflowScrolling: 'touch',
    // fixes two issues:
    // - focus rings get clipped by overflow: auto
    // - trimmed text (capsize) creates unwanted scrollbars
    padding: tokenSchema.size.space.regular,
    margin: `calc(${tokenSchema.size.space.regular} * -1)`
  });
}
function getButtonGroupStyles() {
  return css({
    gridArea: 'buttonGroup',
    minWidth: 0,
    marginInlineStart: tokenSchema.size.space.regular,
    paddingTop: tokenSchema.size.space.large,
    [breakpointQueries.above.mobile]: {
      paddingTop: tokenSchema.size.space.xlarge
    },
    [`${dialogClassList.selector('root')}:not([data-size=fullscreen]) &[data-has-footer=false]`]: {
      gridArea: 'footer-start / footer-start / buttonGroup-end / buttonGroup-end'
    },
    // correct consumer error; hide the button group when the dialog is dismissable
    [`${dialogClassList.selector('root')}[data-dismissable] &`]: {
      display: 'none'
    }
  });
}
function getFooterStyles() {
  return css({
    alignItems: 'center',
    display: 'flex',
    flexWrap: 'wrap',
    gridArea: 'footer',
    minWidth: 0,
    paddingTop: tokenSchema.size.space.large,
    [breakpointQueries.above.mobile]: {
      paddingTop: tokenSchema.size.space.xlarge
    }
  });
}

/**
 * AlertDialogs are a specific type of Dialog. They display important
 * information that users need to acknowledge.
 */
const AlertDialog = /*#__PURE__*/forwardRef(function AlertDialog(props, forwardedRef) {
  const $ = c(58);
  const {
    onClose: t0
  } = useContext(DialogContext) || {};
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === undefined ? () => {} : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onClose = t1;
  let t2;
  let t3;
  let t4;
  let otherProps;
  let title;
  let children;
  let cancelLabel;
  let autoFocusButton;
  let secondaryActionLabel;
  let isSecondaryActionDisabled;
  let tone;
  let isPrimaryActionDisabled;
  let primaryActionLabel;
  if ($[2] !== props) {
    ({
      autoFocusButton,
      cancelLabel,
      children,
      isPrimaryActionDisabled,
      isSecondaryActionDisabled,
      onCancel: t2,
      onPrimaryAction: t3,
      onSecondaryAction: t4,
      primaryActionLabel,
      secondaryActionLabel,
      title,
      tone,
      ...otherProps
    } = props);
    $[2] = props;
    $[3] = t2;
    $[4] = t3;
    $[5] = t4;
    $[6] = otherProps;
    $[7] = title;
    $[8] = children;
    $[9] = cancelLabel;
    $[10] = autoFocusButton;
    $[11] = secondaryActionLabel;
    $[12] = isSecondaryActionDisabled;
    $[13] = tone;
    $[14] = isPrimaryActionDisabled;
    $[15] = primaryActionLabel;
  } else {
    t2 = $[3];
    t3 = $[4];
    t4 = $[5];
    otherProps = $[6];
    title = $[7];
    children = $[8];
    cancelLabel = $[9];
    autoFocusButton = $[10];
    secondaryActionLabel = $[11];
    isSecondaryActionDisabled = $[12];
    tone = $[13];
    isPrimaryActionDisabled = $[14];
    primaryActionLabel = $[15];
  }
  let t5;
  if ($[16] !== t2) {
    t5 = t2 === undefined ? () => {} : t2;
    $[16] = t2;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  const onCancel = t5;
  let t6;
  if ($[18] !== t3) {
    t6 = t3 === undefined ? () => {} : t3;
    $[18] = t3;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  const onPrimaryAction = t6;
  let t7;
  if ($[20] !== t4) {
    t7 = t4 === undefined ? () => {} : t4;
    $[20] = t4;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  const onSecondaryAction = t7;
  const styleProps = useStyleProps(otherProps);
  let t8;
  if ($[22] !== title) {
    t8 = /*#__PURE__*/jsx(Heading, {
      children: title
    });
    $[22] = title;
    $[23] = t8;
  } else {
    t8 = $[23];
  }
  let t9;
  if ($[24] !== children) {
    t9 = /*#__PURE__*/jsx(Content, {
      children: isReactText(children) ? /*#__PURE__*/jsx(Text, {
        children: children
      }) : children
    });
    $[24] = children;
    $[25] = t9;
  } else {
    t9 = $[25];
  }
  let t10;
  if ($[26] !== cancelLabel || $[27] !== onClose || $[28] !== onCancel || $[29] !== autoFocusButton || $[30] !== secondaryActionLabel) {
    t10 = cancelLabel && /*#__PURE__*/jsx(Button, {
      onPress: () => chain(onClose(), onCancel()),
      autoFocus: autoFocusButton === "cancel",
      prominence: secondaryActionLabel ? "low" : undefined,
      children: cancelLabel
    });
    $[26] = cancelLabel;
    $[27] = onClose;
    $[28] = onCancel;
    $[29] = autoFocusButton;
    $[30] = secondaryActionLabel;
    $[31] = t10;
  } else {
    t10 = $[31];
  }
  let t11;
  if ($[32] !== secondaryActionLabel || $[33] !== onClose || $[34] !== onSecondaryAction || $[35] !== autoFocusButton || $[36] !== isSecondaryActionDisabled) {
    t11 = secondaryActionLabel && /*#__PURE__*/jsx(Button, {
      onPress: () => chain(onClose(), onSecondaryAction()),
      autoFocus: autoFocusButton === "secondary",
      isDisabled: isSecondaryActionDisabled,
      children: secondaryActionLabel
    });
    $[32] = secondaryActionLabel;
    $[33] = onClose;
    $[34] = onSecondaryAction;
    $[35] = autoFocusButton;
    $[36] = isSecondaryActionDisabled;
    $[37] = t11;
  } else {
    t11 = $[37];
  }
  let t12;
  if ($[38] !== onClose || $[39] !== onPrimaryAction) {
    t12 = () => chain(onClose(), onPrimaryAction());
    $[38] = onClose;
    $[39] = onPrimaryAction;
    $[40] = t12;
  } else {
    t12 = $[40];
  }
  const t13 = autoFocusButton === "primary";
  let t14;
  if ($[41] !== tone || $[42] !== t12 || $[43] !== isPrimaryActionDisabled || $[44] !== t13 || $[45] !== primaryActionLabel) {
    t14 = /*#__PURE__*/jsx(Button, {
      prominence: "high",
      tone: tone,
      onPress: t12,
      isDisabled: isPrimaryActionDisabled,
      autoFocus: t13,
      children: primaryActionLabel
    });
    $[41] = tone;
    $[42] = t12;
    $[43] = isPrimaryActionDisabled;
    $[44] = t13;
    $[45] = primaryActionLabel;
    $[46] = t14;
  } else {
    t14 = $[46];
  }
  let t15;
  if ($[47] !== t10 || $[48] !== t11 || $[49] !== t14) {
    t15 = /*#__PURE__*/jsxs(ButtonGroup, {
      align: "end",
      children: [t10, t11, t14]
    });
    $[47] = t10;
    $[48] = t11;
    $[49] = t14;
    $[50] = t15;
  } else {
    t15 = $[50];
  }
  let t16;
  if ($[51] !== forwardedRef || $[52] !== styleProps.className || $[53] !== styleProps.style || $[54] !== t8 || $[55] !== t9 || $[56] !== t15) {
    t16 = /*#__PURE__*/jsxs(Dialog, {
      role: "alertdialog",
      ref: forwardedRef,
      size: "small",
      UNSAFE_className: styleProps.className,
      UNSAFE_style: styleProps.style,
      children: [t8, t9, t15]
    });
    $[51] = forwardedRef;
    $[52] = styleProps.className;
    $[53] = styleProps.style;
    $[54] = t8;
    $[55] = t9;
    $[56] = t15;
    $[57] = t16;
  } else {
    t16 = $[57];
  }
  return t16;
});

/**
 * A DialogContainer accepts a single Dialog as a child, and manages showing and hiding
 * it in a modal. Useful in cases where there is no trigger element
 * or when the trigger unmounts while the dialog is open.
 */
function DialogContainer(props) {
  const $ = c(18);
  const {
    children,
    type: t0,
    onDismiss,
    isDismissable,
    isKeyboardDismissDisabled
  } = props;
  const type = t0 === undefined ? "modal" : t0;
  const child = /*#__PURE__*/isValidElement(children) ? children : null;
  const [lastChild, setLastChild] = useState(child);
  if (child && child !== lastChild) {
    setLastChild(child);
  }
  let t1;
  if ($[0] !== type || $[1] !== onDismiss || $[2] !== isDismissable) {
    t1 = {
      type,
      onClose: onDismiss,
      isDismissable
    };
    $[0] = type;
    $[1] = onDismiss;
    $[2] = isDismissable;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const context = t1;
  const t2 = !!child;
  let t3;
  if ($[4] !== onDismiss) {
    t3 = isOpen => {
      if (!isOpen) {
        onDismiss();
      }
    };
    $[4] = onDismiss;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== t2 || $[7] !== t3) {
    t4 = {
      isOpen: t2,
      onOpenChange: t3
    };
    $[6] = t2;
    $[7] = t3;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const state = useOverlayTriggerState(t4);
  let t5;
  if ($[9] !== context || $[10] !== lastChild) {
    t5 = /*#__PURE__*/jsx(DialogContext.Provider, {
      value: context,
      children: lastChild
    });
    $[9] = context;
    $[10] = lastChild;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  let t6;
  if ($[12] !== state || $[13] !== type || $[14] !== isDismissable || $[15] !== isKeyboardDismissDisabled || $[16] !== t5) {
    t6 = /*#__PURE__*/jsx(Modal, {
      state: state,
      type: type,
      isDismissable: isDismissable,
      isKeyboardDismissDisabled: isKeyboardDismissDisabled,
      children: t5
    });
    $[12] = state;
    $[13] = type;
    $[14] = isDismissable;
    $[15] = isKeyboardDismissDisabled;
    $[16] = t5;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  return t6;
}

/** A dialog may be abstracted from its trigger; this hook provides access to context. */
function useDialogContainer() {
  const $ = c(2);
  const context = useContext(DialogContext);
  assert(!!context, "Cannot call `useDialogContext` outside of `<DialogTrigger>` or `<DialogContainer>`.");
  let t0;
  if ($[0] !== context) {
    t0 = {
      type: context.type,
      dismiss() {
        context.onClose();
      }
    };
    $[0] = context;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}

function DialogTrigger(props) {
  let {
    children,
    type = 'modal',
    mobileType = type === 'popover' ? 'modal' : type,
    hideArrow,
    targetRef,
    isDismissable,
    isKeyboardDismissDisabled,
    ...positionProps
  } = props;
  if (!Array.isArray(children) || children.length > 2) {
    throw new Error('DialogTrigger must have exactly 2 children');
  }
  // if a function is passed as the second child, it won't appear in toArray
  let [trigger, content] = children;

  // On small devices, show a modal or tray instead of a popover.
  let isMobile = useMediaQuery(breakpointQueries.below.tablet);
  if (isMobile) {
    // handle cases where desktop popovers need a close button for the mobile modal view
    if (type !== 'modal' && mobileType === 'modal') {
      isDismissable = true;
    }
    type = mobileType;
  }
  let state = useOverlayTriggerState(props);
  let wasOpen = useRef(false);
  wasOpen.current = state.isOpen;
  let isExiting = useRef(false);
  let onExiting = () => isExiting.current = true;
  let onExited = () => isExiting.current = false;
  const onUnmount = useEffectEvent(() => {
    if ((wasOpen.current || isExiting.current) && type !== 'popover' && type !== 'tray') {
      console.warn('A DialogTrigger unmounted while open. This is likely due to being placed within a trigger that unmounts or inside a conditional. Consider using a DialogContainer instead.');
    }
  });

  // eslint-disable-next-line arrow-body-style
  useEffect(() => {
    return onUnmount;
  }, [onUnmount]);
  if (type === 'popover') {
    return /*#__PURE__*/jsx(PopoverTrigger, {
      ...positionProps,
      state: state,
      targetRef: targetRef,
      trigger: trigger,
      content: content,
      isKeyboardDismissDisabled: isKeyboardDismissDisabled,
      hideArrow: hideArrow
    });
  }
  let renderOverlay = () => {
    switch (type) {
      case 'fullscreen':
      case 'modal':
        return /*#__PURE__*/jsx(Modal, {
          state: state,
          isDismissable: type === 'modal' ? isDismissable : false,
          type: type,
          isKeyboardDismissDisabled: isKeyboardDismissDisabled,
          onExiting: onExiting,
          onExited: onExited,
          children: typeof content === 'function' ? content(state.close) : content
        });
      case 'tray':
        return /*#__PURE__*/jsx(Tray, {
          state: state,
          isKeyboardDismissDisabled: isKeyboardDismissDisabled,
          children: typeof content === 'function' ? content(state.close) : content
        });
    }
    assertNever(type);
  };
  return /*#__PURE__*/jsx(DialogTriggerBase, {
    type: type,
    state: state,
    isDismissable: isDismissable,
    trigger: trigger,
    overlay: renderOverlay()
  });
}

// Support DialogTrigger inside components using CollectionBuilder.
DialogTrigger.getCollectionNode = function* (props) {
  // @ts-ignore
  let [trigger] = Children.toArray(props.children);
  let [, content] = props.children;
  yield {
    element: trigger,
    wrapper: element => /*#__PURE__*/jsxs(DialogTrigger, {
      ...props,
      children: [element, content]
    }, element.key)
  };
};

/**
 * DialogTrigger serves as a wrapper around a Dialog and its associated trigger, linking the Dialog's
 * open state with the trigger's press state. Additionally, it allows you to customize the type and
 * positioning of the Dialog.
 */

// We don't want getCollectionNode to show up in the type definition
let _DialogTrigger = DialogTrigger;
function PopoverTrigger(t0) {
  const $ = c(26);
  let state;
  let targetRef;
  let content;
  let props;
  let hideArrow;
  let trigger;
  if ($[0] !== t0) {
    ({
      state,
      targetRef,
      trigger,
      content,
      hideArrow,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = state;
    $[2] = targetRef;
    $[3] = content;
    $[4] = props;
    $[5] = hideArrow;
    $[6] = trigger;
  } else {
    state = $[1];
    targetRef = $[2];
    content = $[3];
    props = $[4];
    hideArrow = $[5];
    trigger = $[6];
  }
  const triggerRef = useRef(null);
  let t1;
  if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      type: "dialog"
    };
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const {
    triggerProps,
    overlayProps
  } = useOverlayTrigger(t1, state, triggerRef);
  const t2 = targetRef ? undefined : triggerRef;
  let t3;
  if ($[8] !== triggerProps || $[9] !== t2) {
    t3 = {
      ...triggerProps,
      ref: t2
    };
    $[8] = triggerProps;
    $[9] = t2;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  const triggerPropsWithRef = t3;
  const t4 = targetRef || triggerRef;
  let t5;
  if ($[11] !== content || $[12] !== state) {
    t5 = typeof content === "function" ? content(state.close) : content;
    $[11] = content;
    $[12] = state;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  let t6;
  if ($[14] !== props || $[15] !== hideArrow || $[16] !== t4 || $[17] !== state || $[18] !== t5) {
    t6 = /*#__PURE__*/jsx(Popover, {
      ...props,
      hideArrow: hideArrow,
      triggerRef: t4,
      state: state,
      children: t5
    });
    $[14] = props;
    $[15] = hideArrow;
    $[16] = t4;
    $[17] = state;
    $[18] = t5;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  const overlay = t6;
  let t7;
  if ($[20] !== state || $[21] !== triggerPropsWithRef || $[22] !== overlayProps || $[23] !== trigger || $[24] !== overlay) {
    t7 = /*#__PURE__*/jsx(DialogTriggerBase, {
      type: "popover",
      state: state,
      triggerProps: triggerPropsWithRef,
      dialogProps: overlayProps,
      trigger: trigger,
      overlay: overlay
    });
    $[20] = state;
    $[21] = triggerPropsWithRef;
    $[22] = overlayProps;
    $[23] = trigger;
    $[24] = overlay;
    $[25] = t7;
  } else {
    t7 = $[25];
  }
  return t7;
}
function DialogTriggerBase(t0) {
  const $ = c(22);
  const {
    type,
    state,
    isDismissable,
    dialogProps: t1,
    triggerProps: t2,
    overlay,
    trigger
  } = t0;
  let t3;
  if ($[0] !== t1) {
    t3 = t1 === undefined ? {} : t1;
    $[0] = t1;
    $[1] = t3;
  } else {
    t3 = $[1];
  }
  const dialogProps = t3;
  let t4;
  if ($[2] !== t2) {
    t4 = t2 === undefined ? {} : t2;
    $[2] = t2;
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  const triggerProps = t4;
  let t5;
  if ($[4] !== type || $[5] !== state.close || $[6] !== isDismissable || $[7] !== dialogProps) {
    t5 = {
      type,
      onClose: state.close,
      isDismissable,
      ...dialogProps
    };
    $[4] = type;
    $[5] = state.close;
    $[6] = isDismissable;
    $[7] = dialogProps;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  const context = t5;
  let t6;
  if ($[9] !== state.open || $[10] !== triggerProps) {
    t6 = mergeProps(triggerProps, {
      onPress: state.open
    });
    $[9] = state.open;
    $[10] = triggerProps;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  const t7 = state.isOpen && type !== "modal" && type !== "fullscreen";
  let t8;
  if ($[12] !== t6 || $[13] !== t7 || $[14] !== trigger) {
    t8 = /*#__PURE__*/jsx(PressResponder, {
      ...t6,
      isPressed: t7,
      children: trigger
    });
    $[12] = t6;
    $[13] = t7;
    $[14] = trigger;
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] !== context || $[17] !== overlay) {
    t9 = /*#__PURE__*/jsx(DialogContext.Provider, {
      value: context,
      children: overlay
    });
    $[16] = context;
    $[17] = overlay;
    $[18] = t9;
  } else {
    t9 = $[18];
  }
  let t10;
  if ($[19] !== t8 || $[20] !== t9) {
    t10 = /*#__PURE__*/jsxs(Fragment, {
      children: [t8, t9]
    });
    $[19] = t8;
    $[20] = t9;
    $[21] = t10;
  } else {
    t10 = $[21];
  }
  return t10;
}

export { AlertDialog, Dialog, DialogContainer, _DialogTrigger as DialogTrigger, useDialogContainer };
