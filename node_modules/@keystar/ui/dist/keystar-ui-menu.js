'use client';
import { getChildNodes } from '@react-stately/collections';
export { Item, Section } from '@react-stately/collections';
import { c } from './react-compiler-runtime-19061925.js';
import { useLocalizedStringFormatter } from '@react-aria/i18n';
import { mergeProps, useObjectRef, useSyncRef, filterDOMProps } from '@react-aria/utils';
import React, { useContext, useRef, Fragment, forwardRef } from 'react';
import { useMenuItem, useMenuSection, useMenu, useMenuTrigger } from '@react-aria/menu';
import { useTreeState } from '@react-stately/tree';
import { ListItem, listStyles } from '@keystar/ui/listbox';
import { css, tokenSchema, useStyleProps, classNames, useIsMobileDevice } from '@keystar/ui/style';
import { useFocusRing } from '@react-aria/focus';
import { useHover, PressResponder } from '@react-aria/interactions';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useSeparator } from '@react-aria/separator';
import { Divider } from '@keystar/ui/layout';
import { useMenuTriggerState } from '@react-stately/menu';
import { Tray, Popover } from '@keystar/ui/overlays';
import { SlotProvider, useSlotProps } from '@keystar/ui/slots';
import { ActionButton } from '@keystar/ui/button';
import { Icon } from '@keystar/ui/icon';
import { moreHorizontalIcon } from '@keystar/ui/icon/icons/moreHorizontalIcon';

const localizedMessages = {
  "ar-AE": {
    "moreActions": `المزيد من الإجراءات`
  },
  "bg-BG": {
    "moreActions": `Повече действия`
  },
  "cs-CZ": {
    "moreActions": `Další akce`
  },
  "da-DK": {
    "moreActions": `Flere handlinger`
  },
  "de-DE": {
    "moreActions": `Mehr Aktionen`
  },
  "el-GR": {
    "moreActions": `Περισσότερες ενέργειες`
  },
  "en-US": {
    "moreActions": `More actions`
  },
  "es-ES": {
    "moreActions": `Más acciones`
  },
  "et-EE": {
    "moreActions": `Veel toiminguid`
  },
  "fi-FI": {
    "moreActions": `Lisää toimintoja`
  },
  "fr-FR": {
    "moreActions": `Autres actions`
  },
  "he-IL": {
    "moreActions": `פעולות נוספות`
  },
  "hr-HR": {
    "moreActions": `Dodatne radnje`
  },
  "hu-HU": {
    "moreActions": `További lehetőségek`
  },
  "it-IT": {
    "moreActions": `Altre azioni`
  },
  "ja-JP": {
    "moreActions": `その他のアクション`
  },
  "ko-KR": {
    "moreActions": `기타 작업`
  },
  "lt-LT": {
    "moreActions": `Daugiau veiksmų`
  },
  "lv-LV": {
    "moreActions": `Citas darbības`
  },
  "nb-NO": {
    "moreActions": `Flere handlinger`
  },
  "nl-NL": {
    "moreActions": `Meer handelingen`
  },
  "pl-PL": {
    "moreActions": `Więcej akcji`
  },
  "pt-BR": {
    "moreActions": `Mais ações`
  },
  "pt-PT": {
    "moreActions": `Mais ações`
  },
  "ro-RO": {
    "moreActions": `Mai multe acțiuni`
  },
  "ru-RU": {
    "moreActions": `Дополнительные действия`
  },
  "sk-SK": {
    "moreActions": `Ďalšie akcie`
  },
  "sl-SI": {
    "moreActions": `Več možnosti`
  },
  "sr-SP": {
    "moreActions": `Dodatne radnje`
  },
  "sv-SE": {
    "moreActions": `Fler åtgärder`
  },
  "tr-TR": {
    "moreActions": `Daha fazla eylem`
  },
  "uk-UA": {
    "moreActions": `Більше дій`
  },
  "zh-CN": {
    "moreActions": `更多操作`
  },
  "zh-TW": {
    "moreActions": `更多動作`
  }
};

const MenuContext = /*#__PURE__*/React.createContext({});
function useMenuContext() {
  return useContext(MenuContext);
}

/** @private */
function MenuItem(props) {
  const $ = c(34);
  const {
    item,
    state,
    isVirtualized
  } = props;
  const {
    onClose,
    closeOnSelect
  } = useMenuContext();
  const {
    rendered,
    key
  } = item;
  let t0;
  if ($[0] !== state.selectionManager || $[1] !== key) {
    t0 = state.selectionManager.isSelected(key);
    $[0] = state.selectionManager;
    $[1] = key;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const isSelected = t0;
  let t1;
  if ($[3] !== state.selectionManager || $[4] !== key) {
    t1 = state.selectionManager.isDisabled(key);
    $[3] = state.selectionManager;
    $[4] = key;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const isDisabled = t1;
  const ref = useRef(null);
  const t2 = item["aria-label"];
  let t3;
  if ($[6] !== isSelected || $[7] !== isDisabled || $[8] !== t2 || $[9] !== key || $[10] !== onClose || $[11] !== closeOnSelect || $[12] !== isVirtualized) {
    t3 = {
      isSelected,
      isDisabled,
      "aria-label": t2,
      key,
      onClose,
      closeOnSelect,
      isVirtualized
    };
    $[6] = isSelected;
    $[7] = isDisabled;
    $[8] = t2;
    $[9] = key;
    $[10] = onClose;
    $[11] = closeOnSelect;
    $[12] = isVirtualized;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  const {
    menuItemProps,
    labelProps,
    descriptionProps,
    keyboardShortcutProps
  } = useMenuItem(t3, state, ref);
  let t4;
  if ($[14] !== isDisabled) {
    t4 = {
      isDisabled
    };
    $[14] = isDisabled;
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  const {
    hoverProps,
    isHovered
  } = useHover(t4);
  const {
    focusProps,
    isFocusVisible
  } = useFocusRing();
  let t5;
  if ($[16] !== rendered) {
    t5 = isReactText(rendered) ? /*#__PURE__*/jsx(Text, {
      children: rendered
    }) : rendered;
    $[16] = rendered;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  const contents = t5;
  const role = state.selectionManager.disabledBehavior === "selection" && state.disabledKeys.has(key) ? "menuitem" : undefined;
  let t6;
  if ($[18] !== role || $[19] !== menuItemProps || $[20] !== hoverProps || $[21] !== focusProps) {
    t6 = mergeProps(menuItemProps, {
      role
    }, hoverProps, focusProps);
    $[18] = role;
    $[19] = menuItemProps;
    $[20] = hoverProps;
    $[21] = focusProps;
    $[22] = t6;
  } else {
    t6 = $[22];
  }
  const t7 = item.props.href ? "a" : "div";
  let t8;
  if ($[23] !== t6 || $[24] !== t7 || $[25] !== descriptionProps || $[26] !== keyboardShortcutProps || $[27] !== labelProps || $[28] !== isHovered || $[29] !== isFocusVisible || $[30] !== isSelected || $[31] !== ref || $[32] !== contents) {
    t8 = /*#__PURE__*/jsx(ListItem, {
      ...t6,
      elementType: t7,
      descriptionProps: descriptionProps,
      keyboardShortcutProps: keyboardShortcutProps,
      labelProps: labelProps,
      isHovered: isHovered,
      isFocused: isFocusVisible,
      isSelected: isSelected,
      ref: ref,
      children: contents
    });
    $[23] = t6;
    $[24] = t7;
    $[25] = descriptionProps;
    $[26] = keyboardShortcutProps;
    $[27] = labelProps;
    $[28] = isHovered;
    $[29] = isFocusVisible;
    $[30] = isSelected;
    $[31] = ref;
    $[32] = contents;
    $[33] = t8;
  } else {
    t8 = $[33];
  }
  return t8;
}

/** @private */
function MenuSection(props) {
  const $ = c(29);
  const {
    item,
    state
  } = props;
  const t0 = item["aria-label"];
  let t1;
  if ($[0] !== item.rendered || $[1] !== t0) {
    t1 = {
      heading: item.rendered,
      "aria-label": t0
    };
    $[0] = item.rendered;
    $[1] = t0;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const {
    itemProps,
    headingProps,
    groupProps
  } = useMenuSection(t1);
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = {};
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const {
    separatorProps
  } = useSeparator(t2);
  let t3;
  if ($[4] !== state.collection || $[5] !== item.key || $[6] !== separatorProps) {
    t3 = item.key !== state.collection.getFirstKey() && /*#__PURE__*/jsx(Divider, {
      ...separatorProps,
      marginY: "small"
    });
    $[4] = state.collection;
    $[5] = item.key;
    $[6] = separatorProps;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  let t4;
  if ($[8] !== item.rendered || $[9] !== headingProps) {
    t4 = item.rendered && /*#__PURE__*/jsx(Text, {
      casing: "uppercase",
      size: "small",
      color: "neutralSecondary",
      weight: "medium",
      UNSAFE_className: css({
        paddingBlock: tokenSchema.size.space.regular,
        paddingInline: tokenSchema.size.space.medium
      }),
      ...headingProps,
      children: item.rendered
    });
    $[8] = item.rendered;
    $[9] = headingProps;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== item || $[12] !== state.collection) {
    t5 = getChildNodes(item, state.collection);
    $[11] = item;
    $[12] = state.collection;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  let t6;
  if ($[14] !== t5) {
    t6 = [...t5];
    $[14] = t5;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  let t7;
  if ($[16] !== state || $[17] !== t6) {
    t7 = t6.map(node => {
      let item_0 = /*#__PURE__*/jsx(MenuItem, {
        item: node,
        state: state
      }, node.key);
      if (node.wrapper) {
        item_0 = node.wrapper(item_0);
      }
      return item_0;
    });
    $[16] = state;
    $[17] = t6;
    $[18] = t7;
  } else {
    t7 = $[18];
  }
  let t8;
  if ($[19] !== groupProps || $[20] !== t7) {
    t8 = /*#__PURE__*/jsx("div", {
      ...groupProps,
      children: t7
    });
    $[19] = groupProps;
    $[20] = t7;
    $[21] = t8;
  } else {
    t8 = $[21];
  }
  let t9;
  if ($[22] !== itemProps || $[23] !== t4 || $[24] !== t8) {
    t9 = /*#__PURE__*/jsxs("div", {
      ...itemProps,
      children: [t4, t8]
    });
    $[22] = itemProps;
    $[23] = t4;
    $[24] = t8;
    $[25] = t9;
  } else {
    t9 = $[25];
  }
  let t10;
  if ($[26] !== t3 || $[27] !== t9) {
    t10 = /*#__PURE__*/jsxs(Fragment, {
      children: [t3, t9]
    });
    $[26] = t3;
    $[27] = t9;
    $[28] = t10;
  } else {
    t10 = $[28];
  }
  return t10;
}

function Menu(props, forwardedRef) {
  const $ = c(19);
  const contextProps = useContext(MenuContext);
  let t0;
  if ($[0] !== contextProps || $[1] !== props) {
    t0 = mergeProps(contextProps, props);
    $[0] = contextProps;
    $[1] = props;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] !== t0) {
    t1 = {
      ...t0
    };
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const completeProps = t1;
  const domRef = useObjectRef(forwardedRef);
  const state = useTreeState(completeProps);
  const {
    menuProps
  } = useMenu(completeProps, state, domRef);
  const styleProps = useStyleProps(completeProps);
  useSyncRef(contextProps, domRef);
  let t2;
  if ($[5] !== styleProps.className) {
    t2 = classNames(listStyles, styleProps.className);
    $[5] = styleProps.className;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== state.collection) {
    t3 = [...state.collection];
    $[7] = state.collection;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== state || $[10] !== t3) {
    t4 = t3.map(item => {
      if (item.type === "section") {
        return /*#__PURE__*/jsx(MenuSection, {
          item: item,
          state: state
        }, item.key);
      }
      let menuItem = /*#__PURE__*/jsx(MenuItem, {
        item: item,
        state: state
      }, item.key);
      if (item.wrapper) {
        menuItem = item.wrapper(menuItem);
      }
      return menuItem;
    });
    $[9] = state;
    $[10] = t3;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] !== menuProps || $[13] !== styleProps || $[14] !== domRef || $[15] !== t2 || $[16] !== state.selectionManager.selectionMode || $[17] !== t4) {
    t5 = /*#__PURE__*/jsx("div", {
      ...menuProps,
      ...styleProps,
      ref: domRef,
      className: t2,
      "data-selection": state.selectionManager.selectionMode,
      children: t4
    });
    $[12] = menuProps;
    $[13] = styleProps;
    $[14] = domRef;
    $[15] = t2;
    $[16] = state.selectionManager.selectionMode;
    $[17] = t4;
    $[18] = t5;
  } else {
    t5 = $[18];
  }
  return t5;
}

/**
 * Menus display a list of actions or options that a user can choose.
 */
// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref
const _Menu = /*#__PURE__*/React.forwardRef(Menu);

/**
 * The MenuTrigger serves as a wrapper around a Menu and its associated trigger,
 * linking the Menu's open state with the trigger's press state.
 */
const MenuTrigger = /*#__PURE__*/forwardRef(function MenuTrigger(props, forwardedRef) {
  const $ = c(39);
  const triggerRef = useRef(null);
  const domRef = useObjectRef(forwardedRef);
  const menuTriggerRef = domRef || triggerRef;
  const menuRef = useRef(null);
  const {
    children,
    align: t0,
    shouldFlip: t1,
    direction: t2,
    closeOnSelect,
    trigger: t3
  } = props;
  const align = t0 === undefined ? "start" : t0;
  const shouldFlip = t1 === undefined ? true : t1;
  const direction = t2 === undefined ? "bottom" : t2;
  const trigger = t3 === undefined ? "press" : t3;
  let t4;
  if ($[0] !== children) {
    t4 = React.Children.toArray(children);
    $[0] = children;
    $[1] = t4;
  } else {
    t4 = $[1];
  }
  const [menuTrigger, menu] = t4;
  const state = useMenuTriggerState(props);
  let t5;
  if ($[2] !== trigger) {
    t5 = {
      trigger
    };
    $[2] = trigger;
    $[3] = t5;
  } else {
    t5 = $[3];
  }
  const {
    menuTriggerProps,
    menuProps
  } = useMenuTrigger(t5, state, menuTriggerRef);
  let initialPlacement;
  bb0: switch (direction) {
    case "left":
    case "right":
    case "start":
    case "end":
      {
        initialPlacement = `${direction} ${align === "end" ? "bottom" : "top"}`;
        break bb0;
      }
    case "bottom":
    case "top":
    default:
      {
        initialPlacement = `${direction} ${align}`;
      }
  }
  const isMobile = useIsMobileDevice();
  const t6 = state.focusStrategy || true;
  let t7;
  if ($[4] !== isMobile) {
    t7 = isMobile ? {
      width: "100%",
      maxHeight: "inherit"
    } : {
      maxWidth: tokenSchema.size.dialog.xsmall
    };
    $[4] = isMobile;
    $[5] = t7;
  } else {
    t7 = $[5];
  }
  let t8;
  if ($[6] !== menuProps || $[7] !== menuRef || $[8] !== state.close || $[9] !== closeOnSelect || $[10] !== t6 || $[11] !== t7) {
    t8 = {
      ...menuProps,
      ref: menuRef,
      onClose: state.close,
      closeOnSelect,
      autoFocus: t6,
      UNSAFE_style: t7
    };
    $[6] = menuProps;
    $[7] = menuRef;
    $[8] = state.close;
    $[9] = closeOnSelect;
    $[10] = t6;
    $[11] = t7;
    $[12] = t8;
  } else {
    t8 = $[12];
  }
  const menuContext = t8;
  let overlay;
  if (isMobile) {
    let t9;
    if ($[13] !== state || $[14] !== menu) {
      t9 = /*#__PURE__*/jsx(Tray, {
        state: state,
        children: menu
      });
      $[13] = state;
      $[14] = menu;
      $[15] = t9;
    } else {
      t9 = $[15];
    }
    overlay = t9;
  } else {
    let t9;
    if ($[16] !== state || $[17] !== menuTriggerRef || $[18] !== menuRef || $[19] !== initialPlacement || $[20] !== shouldFlip || $[21] !== menu) {
      t9 = /*#__PURE__*/jsx(Popover, {
        state: state,
        triggerRef: menuTriggerRef,
        scrollRef: menuRef,
        placement: initialPlacement,
        hideArrow: true,
        shouldFlip: shouldFlip,
        children: menu
      });
      $[16] = state;
      $[17] = menuTriggerRef;
      $[18] = menuRef;
      $[19] = initialPlacement;
      $[20] = shouldFlip;
      $[21] = menu;
      $[22] = t9;
    } else {
      t9 = $[22];
    }
    overlay = t9;
  }
  const t9 = trigger === "longPress";
  let t10;
  if ($[23] !== t9) {
    t10 = {
      actionButton: {
        holdAffordance: t9
      }
    };
    $[23] = t9;
    $[24] = t10;
  } else {
    t10 = $[24];
  }
  let t11;
  if ($[25] !== menuTriggerProps || $[26] !== menuTriggerRef || $[27] !== state.isOpen || $[28] !== menuTrigger) {
    t11 = /*#__PURE__*/jsx(PressResponder, {
      ...menuTriggerProps,
      ref: menuTriggerRef,
      isPressed: state.isOpen,
      children: menuTrigger
    });
    $[25] = menuTriggerProps;
    $[26] = menuTriggerRef;
    $[27] = state.isOpen;
    $[28] = menuTrigger;
    $[29] = t11;
  } else {
    t11 = $[29];
  }
  let t12;
  if ($[30] !== t10 || $[31] !== t11) {
    t12 = /*#__PURE__*/jsx(SlotProvider, {
      slots: t10,
      children: t11
    });
    $[30] = t10;
    $[31] = t11;
    $[32] = t12;
  } else {
    t12 = $[32];
  }
  let t13;
  if ($[33] !== menuContext || $[34] !== overlay) {
    t13 = /*#__PURE__*/jsx(MenuContext.Provider, {
      value: menuContext,
      children: overlay
    });
    $[33] = menuContext;
    $[34] = overlay;
    $[35] = t13;
  } else {
    t13 = $[35];
  }
  let t14;
  if ($[36] !== t12 || $[37] !== t13) {
    t14 = /*#__PURE__*/jsxs(Fragment, {
      children: [t12, t13]
    });
    $[36] = t12;
    $[37] = t13;
    $[38] = t14;
  } else {
    t14 = $[38];
  }
  return t14;
});

function ActionMenu(props, ref) {
  const $ = c(24);
  props = useSlotProps(props, "actionMenu");
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let buttonProps;
  if ($[0] !== props || $[1] !== stringFormatter) {
    buttonProps = filterDOMProps(props, {
      labelable: true
    });
    if (buttonProps["aria-label"] === undefined) {
      let t0;
      if ($[3] !== stringFormatter) {
        t0 = stringFormatter.format("moreActions");
        $[3] = stringFormatter;
        $[4] = t0;
      } else {
        t0 = $[4];
      }
      buttonProps["aria-label"] = t0;
    }
    $[0] = props;
    $[1] = stringFormatter;
    $[2] = buttonProps;
  } else {
    buttonProps = $[2];
  }
  let t0;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /*#__PURE__*/jsx(Icon, {
      src: moreHorizontalIcon
    });
    $[5] = t0;
  } else {
    t0 = $[5];
  }
  let t1;
  if ($[6] !== ref || $[7] !== props || $[8] !== buttonProps) {
    t1 = /*#__PURE__*/jsx(ActionButton, {
      ref: ref,
      ...props,
      ...buttonProps,
      children: t0
    });
    $[6] = ref;
    $[7] = props;
    $[8] = buttonProps;
    $[9] = t1;
  } else {
    t1 = $[9];
  }
  let t2;
  if ($[10] !== props.children || $[11] !== props.items || $[12] !== props.disabledKeys || $[13] !== props.onAction) {
    t2 = /*#__PURE__*/jsx(_Menu, {
      children: props.children,
      items: props.items,
      disabledKeys: props.disabledKeys,
      onAction: props.onAction
    });
    $[10] = props.children;
    $[11] = props.items;
    $[12] = props.disabledKeys;
    $[13] = props.onAction;
    $[14] = t2;
  } else {
    t2 = $[14];
  }
  let t3;
  if ($[15] !== props.isOpen || $[16] !== props.defaultOpen || $[17] !== props.onOpenChange || $[18] !== props.align || $[19] !== props.direction || $[20] !== props.shouldFlip || $[21] !== t1 || $[22] !== t2) {
    t3 = /*#__PURE__*/jsxs(MenuTrigger, {
      isOpen: props.isOpen,
      defaultOpen: props.defaultOpen,
      onOpenChange: props.onOpenChange,
      align: props.align,
      direction: props.direction,
      shouldFlip: props.shouldFlip,
      children: [t1, t2]
    });
    $[15] = props.isOpen;
    $[16] = props.defaultOpen;
    $[17] = props.onOpenChange;
    $[18] = props.align;
    $[19] = props.direction;
    $[20] = props.shouldFlip;
    $[21] = t1;
    $[22] = t2;
    $[23] = t3;
  } else {
    t3 = $[23];
  }
  return t3;
}

/**
 * ActionMenu combines an ActionButton with a Menu for simple "more actions" use cases.
 */
const _ActionMenu = /*#__PURE__*/forwardRef(ActionMenu);

export { _ActionMenu as ActionMenu, _Menu as Menu, MenuTrigger };
