'use client';
import { useTableState, useTableColumnResizeState, Column } from '@react-stately/table';
export { Cell, Row, TableBody, TableHeader } from '@react-stately/table';
import { assert } from 'emery';
import React, { createContext, useContext, useRef, useState, useEffect, useMemo, useCallback, Children, cloneElement } from 'react';
import { useButton } from '@react-aria/button';
import { FocusRing, useFocusRing, FocusScope } from '@react-aria/focus';
import { useLocalizedStringFormatter, useLocale } from '@react-aria/i18n';
import { getInteractionModality, useHover, usePress } from '@react-aria/interactions';
import { ListKeyboardDelegate } from '@react-aria/selection';
import { useTableColumnResize, useTable, useTableRowGroup, useTableColumnHeader, useTableHeaderRow, useTableRow, useTableCell, useTableSelectionCheckbox, useTableSelectAllCheckbox } from '@react-aria/table';
import { useObjectRef, mergeProps, useLoadMore, scrollIntoView, scrollIntoViewport } from '@react-aria/utils';
import { setScrollLeft, ScrollView, VirtualizerItem, layoutInfoToStyle } from '@react-aria/virtualizer';
import { useVisuallyHidden, VisuallyHidden } from '@react-aria/visually-hidden';
import { Rect, LayoutInfo, useVirtualizerState } from '@react-stately/virtualizer';
import { Checkbox } from '@keystar/ui/checkbox';
import { Icon } from '@keystar/ui/icon';
import { gripVerticalIcon } from '@keystar/ui/icon/icons/gripVerticalIcon';
import { ProgressCircle } from '@keystar/ui/progress';
import { SlotProvider } from '@keystar/ui/slots';
import { ClassList, css, tokenSchema, classNames, transition, useStyleProps, toDataAttributes, FocusRing as FocusRing$1 } from '@keystar/ui/style';
import { TooltipTrigger, Tooltip } from '@keystar/ui/tooltip';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { c } from './react-compiler-runtime-19061925.js';
import { Flex } from '@keystar/ui/layout';
import { arrowUpIcon } from '@keystar/ui/icon/icons/arrowUpIcon';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { InsertionIndicatorPrimitive } from '@keystar/ui/drag-and-drop';
import { useUNSTABLE_PortalContext } from '@react-aria/overlays';
import ReactDOM from 'react-dom';
import { TableLayout } from '@react-stately/layout';

const TableContext = /*#__PURE__*/createContext(null);
function useTableContext() {
  const context = useContext(TableContext);
  if (context === null) {
    throw new Error("TableContext not found");
  }
  return context;
}
const VirtualizerContext = /*#__PURE__*/createContext(null);
function useVirtualizerContext() {
  const context = useContext(VirtualizerContext);
  if (context === null) {
    throw new Error("VirtualizerContext not found");
  }
  return context;
}
const TableRowContext = /*#__PURE__*/createContext(null);
function useTableRowContext() {
  const context = useContext(TableRowContext);
  if (context === null) {
    throw new Error("TableRowContext not found");
  }
  return context;
}

const tableViewClassList = new ClassList('TableView', ['cell', 'cell-wrapper', 'row', 'body', 'header']);
const SortIndicator = () => {
  const $ = c(2);
  const labelHeight = tokenSchema.typography.text.regular.capheight;
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      alignItems: "center",
      display: "flex",
      flexShrink: 0,
      gridArea: "sort-indicator",
      height: labelHeight,
      justifyContent: "center",
      marginInline: tokenSchema.size.space.small,
      opacity: 0,
      position: "relative",
      transition: transition(["opacity", "transform"], {
        easing: "easeOut"
      }),
      width: labelHeight,
      svg: {
        position: "absolute"
      },
      "[aria-sort=\"ascending\"] &, [aria-sort=\"descending\"] &": {
        opacity: 1
      },
      "[aria-sort=\"descending\"] &": {
        transform: "rotate(180deg)"
      }
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /*#__PURE__*/jsx("span", {
      "aria-hidden": "true",
      className: t0,
      children: /*#__PURE__*/jsx(Icon, {
        src: arrowUpIcon
      })
    });
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
};

// ============================================================================
// CLASSES
// ============================================================================

// TODO: review styles
const tableClassname = css({
  display: 'flex',
  flexDirection: 'column',
  isolation: 'isolate',
  minHeight: 0,
  minWidth: 0,
  outline: 'none',
  position: 'relative',
  userSelect: 'none'
});

// Row group (head/body/foot)
// ----------------------------------------------------------------------------

const headerWrapperClassname = css({
  boxSizing: 'content-box',
  // keep aligned with the border of the body
  borderLeft: `${tokenSchema.size.border.regular} solid transparent`,
  borderRight: `${tokenSchema.size.border.regular} solid transparent`
});
const headerClassname = classNames(tableViewClassList.element('header'), css({
  boxSizing: 'border-box'
}));
const bodyClassname = classNames(tableViewClassList.element('body'), css({
  backgroundColor: tokenSchema.color.background.canvas,
  border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
  borderRadius: tokenSchema.size.radius.medium,
  /* Fix scrollbars on iOS with sticky row headers */
  transform: 'translate3d(0, 0, 0)'
}));

// resizing
const columnResizerClassname = css({
  blockSize: '100%',
  boxSizing: 'border-box',
  display: 'flex',
  flexShrink: 0,
  inlineSize: 21,
  insetInlineEnd: -10,
  justifyContent: 'center',
  outline: 0,
  position: 'absolute',
  userSelect: 'none',
  '&::after': {
    backgroundColor: tokenSchema.color.border.neutral,
    blockSize: '100%',
    boxSizing: 'border-box',
    content: '""',
    display: 'block',
    inlineSize: 1
  }
});
const columnResizerPlaceholderClassname = css({
  blockSize: '100%',
  boxSizing: 'border-box',
  flex: '0 0 auto',
  flexShrink: 0,
  inlineSize: 10,
  userSelect: 'none'
});
const columnResizeIndicatorClassname = css({
  backgroundColor: tokenSchema.color.background.accentEmphasis,
  display: 'none',
  flexShrink: 0,
  height: '100%',
  insetInlineEnd: 0,
  pointerEvents: 'none',
  position: 'absolute',
  top: 1,
  width: 2,
  zIndex: 3,
  '&[data-resizing=true]': {
    display: 'block'
  }
});
const bodyResizeIndicatorClassname = css({
  backgroundColor: tokenSchema.color.background.accentEmphasis,
  display: 'none',
  height: '100%',
  position: 'absolute',
  top: 0,
  width: 2
});

// utilities
const centeredWrapperClassname = css({
  alignItems: 'center',
  display: 'flex',
  height: '100%',
  justifyContent: 'center',
  width: '100%'
});

// Row
// ----------------------------------------------------------------------------

const rowClassname = css({
  boxSizing: 'border-box',
  display: 'flex',
  position: 'relative',
  outline: 0,
  // separators
  [`${tableViewClassList.selector('body')} &::after`]: {
    content: '""',
    boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.border.muted}`,
    position: 'absolute',
    inset: 0,
    pointerEvents: 'none',
    zIndex: 2
  },
  '&[data-flush-with-container-bottom]::after': {
    display: 'none'
  },
  // selection
  '&[aria-selected="true"]::after': {
    boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.alias.backgroundSelectedHovered}`
  },
  '&[data-next-selected="true"]::after': {
    boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.alias.backgroundSelectedHovered}`
  },
  // prominence
  [`${tableViewClassList.selector('root')}:not([data-prominence="low"]) &`]: {
    '&:first-child': {
      borderStartStartRadius: `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`,
      borderStartEndRadius: `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`
    },
    '&:last-child': {
      borderEndStartRadius: `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`,
      borderEndEndRadius: `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`
    }
  },
  // focus indicator
  '&[data-focus-visible]': {
    '&::before': {
      backgroundColor: tokenSchema.color.background.accentEmphasis,
      borderRadius: tokenSchema.size.space.small,
      content: '""',
      insetInlineStart: tokenSchema.size.space.xsmall,
      marginBlock: tokenSchema.size.space.xsmall,
      marginInlineEnd: `calc(${tokenSchema.size.space.small} * -1)`,
      position: 'sticky',
      width: tokenSchema.size.space.small,
      zIndex: 4
    }
  },
  // interactions
  [`&[data-hovered=true] ${tableViewClassList.selector('cell')}`]: {
    backgroundColor: tokenSchema.color.scale.slate2
  },
  [`&[data-pressed=true] ${tableViewClassList.selector('cell')}`]: {
    backgroundColor: tokenSchema.color.scale.slate3
    // backgroundColor: tokenSchema.color.alias.backgroundPressed,
  },
  [`&[data-disabled] ${tableViewClassList.selector('cell')}`]: {
    color: tokenSchema.color.alias.foregroundDisabled
  },
  // selected
  [`&[aria-selected="true"] ${tableViewClassList.selector('cell')}`]: {
    backgroundColor: tokenSchema.color.alias.backgroundSelected
  },
  [`&[aria-selected="true"][data-hovered=true] ${tableViewClassList.selector('cell')}`]: {
    backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
  }
});
const rowDragPreviewClassname = css({
  backgroundColor: tokenSchema.color.background.canvas,
  border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderSelected}`,
  borderRadius: tokenSchema.size.radius.small,
  paddingInline: tokenSchema.size.space.medium,
  position: 'relative',
  outline: 0,
  width: tokenSchema.size.alias.singleLineWidth,
  // indicate that multiple items are being dragged by implying a stack
  '&[data-multi=true]::after': {
    backgroundColor: 'inherit',
    border: 'inherit',
    borderRadius: 'inherit',
    content: '" "',
    display: 'block',
    height: '100%',
    insetBlockStart: tokenSchema.size.space.small,
    insetInlineStart: tokenSchema.size.space.small,
    position: 'absolute',
    width: '100%',
    zIndex: -1
  }
});

// Cell
// ----------------------------------------------------------------------------

// FIXME: review these styles. many may not be necessary. def get rid of the
// root selectors, and pass data-attributes onto elements directly
const commonCellStyles = css({
  boxSizing: 'border-box',
  cursor: 'default',
  display: 'flex',
  height: '100%',
  justifyContent: 'flex-start',
  minWidth: 0,
  outline: 0,
  paddingInline: tokenSchema.size.space.medium,
  position: 'relative',
  textAlign: 'start',
  // focus ring
  '&[data-focus=visible]': {
    borderRadius: tokenSchema.size.radius.small,
    inset: 0,
    outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`,
    outlineOffset: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`,
    position: 'absolute'
  },
  // density
  paddingBlock: tokenSchema.size.space.regular,
  '&[data-density="compact"]': {
    paddingBlock: tokenSchema.size.space.small
  },
  '&[data-density="spacious"]': {
    paddingBlock: tokenSchema.size.space.medium
  },
  // alignment
  '&[data-align="end"]': {
    justifyContent: 'flex-end',
    textAlign: 'end'
  },
  '&[data-align="center"]': {
    justifyContent: 'center',
    textAlign: 'center'
  },
  // overflow mode
  '&[data-overflow-mode="truncate"]': {
    alignItems: 'center'
  }
});
const cellWrapperClassname = css({
  [`${tableViewClassList.selector('body')} &`]: {
    backgroundColor: tokenSchema.color.background.canvas
  }
});

// data-attributes
// - align
// - hide-header
// - show-divider
const cellClassname = classNames(tableViewClassList.element('cell'), commonCellStyles, css({
  color: tokenSchema.color.foreground.neutral
}));
// TODO: assess styles
css({
  // color: tokenSchema.color.foreground.neutral,
  // fontFamily: tokenSchema.typography.fontFamily.base,
  // fontSize: tokenSchema.typography.text.regular.size,
  minWidth: 0,
  flex: 1
});
const headerCellClassname = classNames(commonCellStyles, css({
  alignItems: 'center',
  backgroundColor: tokenSchema.color.background.surface,
  color: tokenSchema.color.foreground.neutralSecondary,
  minWidth: 0,
  flex: 1,
  // SORTABLE
  ['&[aria-sort]']: {
    display: 'grid',
    gridTemplateAreas: '". sort-indicator"',
    '&[data-align="end"]': {
      gridTemplateAreas: '"sort-indicator ."'
    },
    '&[data-hovered=true]': {
      color: tokenSchema.color.foreground.neutralEmphasis
    }
  }
}));
const dragCellClassname = css({
  paddingInlineStart: tokenSchema.size.space.regular,
  paddingInlineEnd: 0
});
const checkboxCellClassname = css({
  paddingBlock: 0,
  paddingInlineEnd: tokenSchema.size.space.regular,
  label: {
    paddingInlineEnd: tokenSchema.size.space.regular,
    paddingBlock: tokenSchema.size.space.regular
  },
  '&[data-density="compact"]': {
    paddingBlock: 0,
    label: {
      paddingBlock: tokenSchema.size.space.small
    }
  },
  '&[data-density="spacious"]': {
    paddingBlock: 0,
    label: {
      paddingBlock: tokenSchema.size.space.medium
    }
  }
});

function DragPreview(props) {
  const $ = c(13);
  const {
    itemText,
    itemCount,
    height,
    maxWidth
  } = props;
  const isDraggingMultiple = itemCount > 1;
  let t0;
  if ($[0] !== height || $[1] !== maxWidth) {
    t0 = {
      height,
      maxWidth
    };
    $[0] = height;
    $[1] = maxWidth;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] !== itemText) {
    t1 = /*#__PURE__*/jsx(Text, {
      children: itemText
    });
    $[3] = itemText;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== isDraggingMultiple || $[6] !== itemCount) {
    t2 = isDraggingMultiple && /*#__PURE__*/jsx(Flex, {
      alignItems: "center",
      backgroundColor: "accentEmphasis",
      borderRadius: "small",
      gridArea: "badge",
      justifyContent: "center",
      minWidth: "element.small",
      padding: "small",
      children: /*#__PURE__*/jsx(Text, {
        align: "center",
        color: "inverse",
        size: "small",
        weight: "medium",
        children: itemCount
      })
    });
    $[5] = isDraggingMultiple;
    $[6] = itemCount;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  let t3;
  if ($[8] !== isDraggingMultiple || $[9] !== t0 || $[10] !== t1 || $[11] !== t2) {
    t3 = /*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      justifyContent: "space-between",
      "data-multi": isDraggingMultiple,
      UNSAFE_className: rowDragPreviewClassname,
      UNSAFE_style: t0,
      children: [t1, t2]
    });
    $[8] = isDraggingMultiple;
    $[9] = t0;
    $[10] = t1;
    $[11] = t2;
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  return t3;
}

function InsertionIndicator(props) {
  var _Number, _rowProps$style, _Number2, _rowProps$style2;
  let {
    rowProps,
    target,
    visibleRect
  } = props;
  let {
    dropState,
    dragAndDropHooks
  } = useTableContext();
  let ref = useRef(null);
  assert(!!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDropIndicator), 'dragAndDropHooks.useDropIndicator is not defined.');
  assert(!!dropState, 'dropState is not defined.');

  // if the indicator is rendered dnd hooks are defined
  // eslint-disable-next-line react-compiler/react-compiler
  let {
    dropIndicatorProps
  } = dragAndDropHooks.useDropIndicator(props, dropState, ref);
  let {
    visuallyHiddenProps
  } = useVisuallyHidden();
  let isDropTarget = dropState && dropState.isDropTarget(target);
  if (!isDropTarget && dropIndicatorProps['aria-hidden']) {
    return null;
  }
  let rowTop = (_Number = Number(rowProps === null || rowProps === void 0 || (_rowProps$style = rowProps.style) === null || _rowProps$style === void 0 ? void 0 : _rowProps$style.top)) !== null && _Number !== void 0 ? _Number : 0;
  let rowHeight = (_Number2 = Number(rowProps === null || rowProps === void 0 || (_rowProps$style2 = rowProps.style) === null || _rowProps$style2 === void 0 ? void 0 : _rowProps$style2.height)) !== null && _Number2 !== void 0 ? _Number2 : 0;
  return /*#__PURE__*/jsx("div", {
    style: {
      left: visibleRect.x,
      position: 'absolute',
      top: rowTop + (target.dropPosition === 'after' ? rowHeight : 0),
      width: visibleRect.width,
      zIndex: 4
    },
    role: "row",
    "aria-hidden": dropIndicatorProps['aria-hidden'],
    children: /*#__PURE__*/jsx(InsertionIndicatorPrimitive, {
      role: "gridcell",
      isDropTarget: isDropTarget,
      children: /*#__PURE__*/jsx("div", {
        ...visuallyHiddenProps,
        role: "button",
        ...dropIndicatorProps,
        ref: ref
      })
    })
  });
}

const localizedMessages = {
  "ar-AE": {
    "collapse": `طي`,
    "columnResizer": `أداة تغيير حجم العمود`,
    "drag": `سحب`,
    "expand": `مد`,
    "loading": `جارٍ التحميل...`,
    "loadingMore": `جارٍ تحميل المزيد...`,
    "resizeColumn": `تغيير حجم العمود`,
    "sortAscending": `فرز بترتيب تصاعدي`,
    "sortDescending": `فرز بترتيب تنازلي`
  },
  "bg-BG": {
    "collapse": `Свиване`,
    "columnResizer": `Преоразмеряване на колони`,
    "drag": `Плъзнете`,
    "expand": `Разширяване`,
    "loading": `Зареждане...`,
    "loadingMore": `Зареждане на още...`,
    "resizeColumn": `Преоразмеряване на колона`,
    "sortAscending": `Възходящо сортиране`,
    "sortDescending": `Низходящо сортиране `
  },
  "cs-CZ": {
    "collapse": `Zmenšit`,
    "columnResizer": `Změna velikosti sloupce`,
    "drag": `Přetáhnout`,
    "expand": `Roztáhnout`,
    "loading": `Načítání...`,
    "loadingMore": `Načítání dalších...`,
    "resizeColumn": `Změnit velikost sloupce`,
    "sortAscending": `Seřadit vzestupně`,
    "sortDescending": `Seřadit sestupně`
  },
  "da-DK": {
    "collapse": `Skjul`,
    "columnResizer": `Kolonneændring`,
    "drag": `Træk`,
    "expand": `Udvid`,
    "loading": `Indlæser ...`,
    "loadingMore": `Indlæser flere ...`,
    "resizeColumn": `Tilpas størrelse på kolonne`,
    "sortAscending": `Sorter stigende`,
    "sortDescending": `Sorter faldende`
  },
  "de-DE": {
    "collapse": `Reduzieren`,
    "columnResizer": `Spaltenanpassung`,
    "drag": `Ziehen`,
    "expand": `Erweitern`,
    "loading": `Laden...`,
    "loadingMore": `Mehr laden ...`,
    "resizeColumn": `Spaltengröße ändern`,
    "sortAscending": `Aufsteigend sortieren`,
    "sortDescending": `Absteigend sortieren`
  },
  "el-GR": {
    "collapse": `Σύμπτυξη`,
    "columnResizer": `Αλλαγή μεγέθους στήλης`,
    "drag": `Μεταφορά`,
    "expand": `Ανάπτυξη`,
    "loading": `Φόρτωση...`,
    "loadingMore": `Φόρτωση περισσότερων...`,
    "resizeColumn": `Αλλαγή μεγέθους στήλης`,
    "sortAscending": `Ταξινόμηση κατά αύξουσα σειρά`,
    "sortDescending": `Ταξινόμηση κατά φθίνουσα σειρά`
  },
  "en-US": {
    "loading": `Loading…`,
    "loadingMore": `Loading more…`,
    "sortAscending": `Sort Ascending`,
    "sortDescending": `Sort Descending`,
    "resizeColumn": `Resize column`,
    "columnResizer": `Column resizer`,
    "drag": `Drag`,
    "expand": `Expand`,
    "collapse": `Collapse`
  },
  "es-ES": {
    "collapse": `Contraer`,
    "columnResizer": `Redimensionador de columnas`,
    "drag": `Arrastrar`,
    "expand": `Ampliar`,
    "loading": `Cargando…`,
    "loadingMore": `Cargando más…`,
    "resizeColumn": `Cambiar el tamaño de la columna`,
    "sortAscending": `Orden de subida`,
    "sortDescending": `Orden de bajada`
  },
  "et-EE": {
    "collapse": `Ahenda`,
    "columnResizer": `Veeru suuruse muutja`,
    "drag": `Lohista`,
    "expand": `Laienda`,
    "loading": `Laadimine...`,
    "loadingMore": `Laadi rohkem...`,
    "resizeColumn": `Muuda veeru suurust`,
    "sortAscending": `Sordi kasvavalt`,
    "sortDescending": `Sordi kahanevalt`
  },
  "fi-FI": {
    "collapse": `Pienennä`,
    "columnResizer": `Sarakekoon muuttaja`,
    "drag": `Vedä`,
    "expand": `Laajenna`,
    "loading": `Ladataan…`,
    "loadingMore": `Ladataan lisää…`,
    "resizeColumn": `Muuta sarakkeen kokoa`,
    "sortAscending": `Lajittelujärjestys: nouseva`,
    "sortDescending": `Lajittelujärjestys: laskeva`
  },
  "fr-FR": {
    "collapse": `Réduire`,
    "columnResizer": `Redimensionnement de colonne`,
    "drag": `Faire glisser`,
    "expand": `Développer`,
    "loading": `Chargement...`,
    "loadingMore": `Chargement supplémentaire...`,
    "resizeColumn": `Redimensionner la colonne`,
    "sortAscending": `Trier par ordre croissant`,
    "sortDescending": `Trier par ordre décroissant`
  },
  "he-IL": {
    "collapse": `כווץ`,
    "columnResizer": `שינוי גודל עמודה`,
    "drag": `גרור`,
    "expand": `הרחב`,
    "loading": `טוען...`,
    "loadingMore": `טוען עוד...`,
    "resizeColumn": `שנה את גודל העמודה`,
    "sortAscending": `מיין בסדר עולה`,
    "sortDescending": `מיין בסדר יורד`
  },
  "hr-HR": {
    "collapse": `Sažmi`,
    "columnResizer": `Alat za promjenu veličine stupca`,
    "drag": `Povucite`,
    "expand": `Proširi`,
    "loading": `Učitavam...`,
    "loadingMore": `Učitavam još...`,
    "resizeColumn": `Promijeni veličinu stupca`,
    "sortAscending": `Sortiraj uzlazno`,
    "sortDescending": `Sortiraj silazno`
  },
  "hu-HU": {
    "collapse": `Összecsukás`,
    "columnResizer": `Oszlopátméretező`,
    "drag": `Húzás`,
    "expand": `Kibontás`,
    "loading": `Betöltés folyamatban…`,
    "loadingMore": `Továbbiak betöltése folyamatban…`,
    "resizeColumn": `Oszlop átméretezése`,
    "sortAscending": `Növekvő rendezés`,
    "sortDescending": `Csökkenő rendezés`
  },
  "it-IT": {
    "collapse": `Comprimi`,
    "columnResizer": `Ridimensionamento colonne`,
    "drag": `Trascina`,
    "expand": `Espandi`,
    "loading": `Caricamento...`,
    "loadingMore": `Caricamento altri...`,
    "resizeColumn": `Ridimensiona colonna`,
    "sortAscending": `Ordinamento crescente`,
    "sortDescending": `Ordinamento decrescente`
  },
  "ja-JP": {
    "collapse": `折りたたむ`,
    "columnResizer": `列リサイザー`,
    "drag": `ドラッグ`,
    "expand": `展開`,
    "loading": `読み込み中...`,
    "loadingMore": `さらに読み込み中...`,
    "resizeColumn": `列幅を変更`,
    "sortAscending": `昇順に並べ替え`,
    "sortDescending": `降順に並べ替え`
  },
  "ko-KR": {
    "collapse": `접기`,
    "columnResizer": `열 크기 조정기`,
    "drag": `드래그`,
    "expand": `펼치기`,
    "loading": `로드 중`,
    "loadingMore": `추가 로드 중`,
    "resizeColumn": `열 크기 조정`,
    "sortAscending": `오름차순 정렬`,
    "sortDescending": `내림차순 정렬`
  },
  "lt-LT": {
    "collapse": `Sutraukti`,
    "columnResizer": `Stulpelio dydžio keitiklis`,
    "drag": `Vilkti`,
    "expand": `Išskleisti`,
    "loading": `Įkeliama...`,
    "loadingMore": `Įkeliama daugiau...`,
    "resizeColumn": `Keisti stulpelio dydį`,
    "sortAscending": `Rikiuoti didėjimo tvarka`,
    "sortDescending": `Rikiuoti mažėjimo tvarka`
  },
  "lv-LV": {
    "collapse": `Sakļaut`,
    "columnResizer": `Kolonnas izmēru mainītājs`,
    "drag": `Vilkšana`,
    "expand": `Izvērst`,
    "loading": `Notiek ielāde...`,
    "loadingMore": `Tiek ielādēts vēl...`,
    "resizeColumn": `Mainīt kolonnas lielumu`,
    "sortAscending": `Kārtot augošā secībā`,
    "sortDescending": `Kārtot dilstošā secībā`
  },
  "nb-NO": {
    "collapse": `Skjul`,
    "columnResizer": `Størrelsesendring av kolonne`,
    "drag": `Dra`,
    "expand": `Utvid`,
    "loading": `Laster inn ...`,
    "loadingMore": `Laster inn flere ...`,
    "resizeColumn": `Endre størrelse på kolonne`,
    "sortAscending": `Sorter stigende`,
    "sortDescending": `Sorter synkende`
  },
  "nl-NL": {
    "collapse": `Samenvouwen`,
    "columnResizer": `Groottewijziging van kolom`,
    "drag": `Slepen`,
    "expand": `Uitvouwen`,
    "loading": `Laden...`,
    "loadingMore": `Meer laden...`,
    "resizeColumn": `Kolomgrootte wijzigen`,
    "sortAscending": `Oplopend sorteren`,
    "sortDescending": `Aflopend sorteren`
  },
  "pl-PL": {
    "collapse": `Zwiń`,
    "columnResizer": `Narzędzie zmiany rozmiaru kolumny`,
    "drag": `Przeciągnij`,
    "expand": `Rozwiń`,
    "loading": `Ładowanie...`,
    "loadingMore": `Wczytywanie większej liczby...`,
    "resizeColumn": `Zmień rozmiar kolumny`,
    "sortAscending": `Sortuj rosnąco`,
    "sortDescending": `Sortuj malejąco`
  },
  "pt-BR": {
    "collapse": `Recolher`,
    "columnResizer": `Redimensionamento de colunas`,
    "drag": `Arraste`,
    "expand": `Expandir`,
    "loading": `Carregando...`,
    "loadingMore": `Carregando mais...`,
    "resizeColumn": `Redimensionar coluna`,
    "sortAscending": `Ordenar por ordem crescente`,
    "sortDescending": `Ordenar por ordem decrescente`
  },
  "pt-PT": {
    "collapse": `Colapsar`,
    "columnResizer": `Redimensionador de coluna`,
    "drag": `Arrastar`,
    "expand": `Expandir`,
    "loading": `A carregar...`,
    "loadingMore": `A carregar mais...`,
    "resizeColumn": `Redimensionar coluna`,
    "sortAscending": `Ordenar por ordem ascendente`,
    "sortDescending": `Ordenar por ordem decrescente`
  },
  "ro-RO": {
    "collapse": `Restrângeți`,
    "columnResizer": `Instrument redimensionare coloane`,
    "drag": `Trageți`,
    "expand": `Extindeți`,
    "loading": `Se încarcă...`,
    "loadingMore": `Se încarcă mai multe...`,
    "resizeColumn": `Redimensionați coloana`,
    "sortAscending": `Sortați crescător`,
    "sortDescending": `Sortați descrescător`
  },
  "ru-RU": {
    "collapse": `Свернуть`,
    "columnResizer": `Средство изменения размера столбцов`,
    "drag": `Перетаскивание`,
    "expand": `Развернуть`,
    "loading": `Загрузка...`,
    "loadingMore": `Дополнительная загрузка...`,
    "resizeColumn": `Изменить размер столбца`,
    "sortAscending": `Сортировать по возрастанию`,
    "sortDescending": `Сортировать по убыванию`
  },
  "sk-SK": {
    "collapse": `Zbaliť`,
    "columnResizer": `Nástroj na zmenu veľkosti stĺpcov`,
    "drag": `Presunúť`,
    "expand": `Rozbaliť`,
    "loading": `Načítava sa...`,
    "loadingMore": `Načítava sa viac...`,
    "resizeColumn": `Zmeniť veľkosť stĺpca`,
    "sortAscending": `Zoradiť vzostupne`,
    "sortDescending": `Zoradiť zostupne`
  },
  "sl-SI": {
    "collapse": `Strni`,
    "columnResizer": `Prilagojevalnik velikosti stolpcev`,
    "drag": `Povleci`,
    "expand": `Razširi`,
    "loading": `Nalaganje...`,
    "loadingMore": `Nalaganje več vsebine...`,
    "resizeColumn": `Spremeni velikost stolpca`,
    "sortAscending": `Razvrsti naraščajoče`,
    "sortDescending": `Razvrsti padajoče`
  },
  "sr-SP": {
    "collapse": `Sažmi`,
    "columnResizer": `Alat za promenu veličine kolone`,
    "drag": `Prevuci`,
    "expand": `Proširi`,
    "loading": `Učitavam...`,
    "loadingMore": `Učitavam još...`,
    "resizeColumn": `Promeni veličinu kolone`,
    "sortAscending": `Sortiraj po rastućem redosledu`,
    "sortDescending": `Sortiraj po opadajućem redosledu`
  },
  "sv-SE": {
    "collapse": `Dölj`,
    "columnResizer": `Ändra storlek på kolumn`,
    "drag": `Dra`,
    "expand": `Expandera`,
    "loading": `Läser in...`,
    "loadingMore": `Läser in mer...`,
    "resizeColumn": `Ändra storlek på kolumn`,
    "sortAscending": `Sortera i stigande ordning`,
    "sortDescending": `Sortera i fallande ordning`
  },
  "tr-TR": {
    "collapse": `Daralt`,
    "columnResizer": `Yeniden sütun boyutlandırıcı`,
    "drag": `Sürükle`,
    "expand": `Genişlet`,
    "loading": `Yükleniyor...`,
    "loadingMore": `Daha fazla yükleniyor...`,
    "resizeColumn": `Sütunu yeniden boyutlandır`,
    "sortAscending": `Artan Sıralama`,
    "sortDescending": `Azalan Sıralama`
  },
  "uk-UA": {
    "collapse": `Згорнути`,
    "columnResizer": `Засіб змінення розміру стовпця`,
    "drag": `Перетягнути`,
    "expand": `Розгорнути`,
    "loading": `Завантаження…`,
    "loadingMore": `Завантаження інших об’єктів...`,
    "resizeColumn": `Змінити розмір стовпця`,
    "sortAscending": `Сортувати за зростанням`,
    "sortDescending": `Сортувати за спаданням`
  },
  "zh-CN": {
    "collapse": `折叠`,
    "columnResizer": `列尺寸调整器`,
    "drag": `拖动`,
    "expand": `扩展`,
    "loading": `正在加载...`,
    "loadingMore": `正在加载更多...`,
    "resizeColumn": `调整列大小`,
    "sortAscending": `升序排序`,
    "sortDescending": `降序排序`
  },
  "zh-TW": {
    "collapse": `收合`,
    "columnResizer": `欄大小調整器`,
    "drag": `拖曳`,
    "expand": `展開`,
    "loading": `正在載入`,
    "loadingMore": `正在載入更多…`,
    "resizeColumn": `調整欄大小`,
    "sortAscending": `升序排序`,
    "sortDescending": `降序排序`
  }
};

const CURSORS = {
  ew: 'col-resize',
  w: 'w-resize',
  e: 'e-resize'
};
const ResizeStateContext = /*#__PURE__*/createContext(null);
function useResizeStateContext() {
  const context = useContext(ResizeStateContext);
  if (context === null) {
    throw new Error("ResizeStateContext not found");
  }
  return context;
}
function Resizer(props, forwardedRef) {
  const $ = c(29);
  const {
    column,
    showResizer
  } = props;
  const {
    isEmpty,
    onFocusedResizer
  } = useTableContext();
  const layout = useContext(ResizeStateContext);
  useVirtualizerContext();
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const {
    direction
  } = useLocale();
  const [isPointerDown, setIsPointerDown] = useState(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      const setDown = e => {
        if (e.pointerType === "mouse") {
          setIsPointerDown(true);
        }
      };
      const setUp = e_0 => {
        if (e_0.pointerType === "mouse") {
          setIsPointerDown(false);
        }
      };
      document.addEventListener("pointerdown", setDown, {
        capture: true
      });
      document.addEventListener("pointerup", setUp, {
        capture: true
      });
      return () => {
        document.removeEventListener("pointerdown", setDown, {
          capture: true
        });
        document.removeEventListener("pointerup", setUp, {
          capture: true
        });
      };
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  const domRef = useObjectRef(forwardedRef);
  let t2;
  if ($[2] !== stringFormatter || $[3] !== isEmpty || $[4] !== props) {
    t2 = mergeProps(props, {
      "aria-label": stringFormatter.format("columnResizer"),
      isDisabled: isEmpty
    });
    $[2] = stringFormatter;
    $[3] = isEmpty;
    $[4] = props;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const {
    inputProps,
    resizerProps
  } = useTableColumnResize(t2, layout, domRef);
  const isEResizable = layout.getColumnMinWidth(column.key) >= layout.getColumnWidth(column.key);
  const isWResizable = layout.getColumnMaxWidth(column.key) <= layout.getColumnWidth(column.key);
  const isResizing = layout.resizingColumn === column.key;
  let cursor;
  if (isEResizable) {
    cursor = direction === "rtl" ? CURSORS.w : CURSORS.e;
  } else {
    if (isWResizable) {
      cursor = direction === "rtl" ? CURSORS.e : CURSORS.w;
    } else {
      cursor = CURSORS.ew;
    }
  }
  const t3 = showResizer ? undefined : "none";
  let t4;
  if ($[6] !== resizerProps.style || $[7] !== t3 || $[8] !== cursor) {
    t4 = {
      ...resizerProps.style,
      height: "100%",
      display: t3,
      cursor
    };
    $[6] = resizerProps.style;
    $[7] = t3;
    $[8] = cursor;
    $[9] = t4;
  } else {
    t4 = $[9];
  }
  const style = t4;
  let t5;
  if ($[10] !== onFocusedResizer || $[11] !== inputProps) {
    t5 = mergeProps(inputProps, {
      onFocus: onFocusedResizer
    });
    $[10] = onFocusedResizer;
    $[11] = inputProps;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== domRef || $[14] !== t5) {
    t6 = /*#__PURE__*/jsx("input", {
      ref: domRef,
      ...t5
    });
    $[13] = domRef;
    $[14] = t5;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  let t7;
  if ($[16] !== resizerProps || $[17] !== style || $[18] !== t6) {
    t7 = /*#__PURE__*/jsx(FocusRing, {
      within: true,
      focusRingClass: "focus-ring",
      children: /*#__PURE__*/jsx("div", {
        ...resizerProps,
        role: "presentation",
        style: style,
        className: columnResizerClassname,
        children: t6
      })
    });
    $[16] = resizerProps;
    $[17] = style;
    $[18] = t6;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  let t8;
  if ($[20] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /*#__PURE__*/jsx("div", {
      "aria-hidden": true,
      role: "presentation",
      className: columnResizerPlaceholderClassname
    });
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  const t9 = isResizing && isPointerDown;
  let t10;
  if ($[21] !== cursor) {
    t10 = /*#__PURE__*/jsx("div", {
      style: {
        bottom: 0,
        cursor,
        left: 0,
        position: "fixed",
        right: 0,
        top: 0
      }
    });
    $[21] = cursor;
    $[22] = t10;
  } else {
    t10 = $[22];
  }
  let t11;
  if ($[23] !== t9 || $[24] !== t10) {
    t11 = /*#__PURE__*/jsx(CursorOverlay, {
      show: t9,
      children: t10
    });
    $[23] = t9;
    $[24] = t10;
    $[25] = t11;
  } else {
    t11 = $[25];
  }
  let t12;
  if ($[26] !== t7 || $[27] !== t11) {
    t12 = /*#__PURE__*/jsxs(Fragment, {
      children: [t7, t8, t11]
    });
    $[26] = t7;
    $[27] = t11;
    $[28] = t12;
  } else {
    t12 = $[28];
  }
  return t12;
}
function CursorOverlay(props) {
  const $ = c(4);
  const {
    show,
    children
  } = props;
  const {
    getContainer
  } = useUNSTABLE_PortalContext();
  let t0;
  if ($[0] !== show || $[1] !== getContainer || $[2] !== children) {
    var _getContainer;
    t0 = show ? /*#__PURE__*/ReactDOM.createPortal(children, (_getContainer = getContainer === null || getContainer === void 0 ? void 0 : getContainer()) !== null && _getContainer !== void 0 ? _getContainer : document.body) : null;
    $[0] = show;
    $[1] = getContainer;
    $[2] = children;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}
const _Resizer = /*#__PURE__*/React.forwardRef(Resizer);

class TableViewLayout extends TableLayout {
  isLoading = false;
  buildCollection() {
    let loadingState = this.collection.body.props.loadingState;
    this.isLoading = loadingState === 'loading' || loadingState === 'loadingMore';
    return super.buildCollection();
  }
  buildColumn(node, x, y) {
    let res = super.buildColumn(node, x, y);
    res.layoutInfo.allowOverflow = true; // for resizer nubbin
    return res;
  }
  buildBody() {
    let node = super.buildBody(0);
    let {
      children,
      layoutInfo
    } = node;
    let width = node.layoutInfo.rect.width;
    if (this.isLoading) {
      // Add some margin around the loader to ensure that scrollbars don't flicker in and out.
      let rect = new Rect(40, (children === null || children === void 0 ? void 0 : children.length) === 0 ? 40 : layoutInfo.rect.maxY, (width || this.virtualizer.visibleRect.width) - 80, (children === null || children === void 0 ? void 0 : children.length) === 0 ? this.virtualizer.visibleRect.height - 80 : 60);
      let loader = new LayoutInfo('loader', 'loader', rect);
      loader.parentKey = layoutInfo.key;
      loader.isSticky = (children === null || children === void 0 ? void 0 : children.length) === 0;
      let node = {
        layoutInfo: loader,
        validRect: loader.rect
      };
      children === null || children === void 0 || children.push(node);
      this.layoutNodes.set(loader.key, node);
      layoutInfo.rect.height = loader.rect.maxY;
      width = Math.max(width, rect.width);
    } else if ((children === null || children === void 0 ? void 0 : children.length) === 0) {
      let rect = new Rect(40, 40, this.virtualizer.visibleRect.width - 80, this.virtualizer.visibleRect.height - 80);
      let empty = new LayoutInfo('empty', 'empty', rect);
      empty.parentKey = layoutInfo.key;
      empty.isSticky = true;
      let node = {
        layoutInfo: empty,
        validRect: empty.rect
      };
      children.push(node);
      layoutInfo.rect.height = empty.rect.maxY;
      width = Math.max(width, rect.width);
    }
    return node;
  }
  buildRow(node, x, y) {
    let res = super.buildRow(node, x, y);
    res.layoutInfo.rect.height += 1; // for bottom border
    return res;
  }
  buildCell(node, x, y) {
    var _node$column;
    let res = super.buildCell(node, x, y);
    if ((_node$column = node.column) !== null && _node$column !== void 0 && _node$column.props.hideHeader) {
      res.layoutInfo.allowOverflow = true;
    }
    return res;
  }
  getEstimatedRowHeight() {
    return super.getEstimatedRowHeight() + 1; // for bottom border
  }
  isStickyColumn(node) {
    var _node$props, _node$props2;
    return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.isDragButtonCell) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.isSelectionCell);
  }
  getDropTargetFromPoint(x, y, isValidDropTarget) {
    var _this$virtualizer$lay;
    // Offset for height of header row
    let headerRowHeight = (_this$virtualizer$lay = this.virtualizer.layout.getVisibleLayoutInfos(new Rect(x, y, 1, 1)).find(info => info.type === 'headerrow')) === null || _this$virtualizer$lay === void 0 ? void 0 : _this$virtualizer$lay.rect.height;
    if (headerRowHeight) {
      y -= headerRowHeight;
    }
    return super.getDropTargetFromPoint(x, y, isValidDropTarget);
  }
}

// Constants

const DEFAULT_HEADER_HEIGHT = 36;
const DEFAULT_HIDE_HEADER_CELL_WIDTH = 36;
const SELECTION_CELL_DEFAULT_WIDTH = 36;
const DRAG_BUTTON_CELL_DEFAULT_WIDTH = 20;
const ROW_HEIGHTS = {
  compact: 28,
  regular: 36,
  spacious: 44
};

// Main

function TableView(props) {
  var _dropState, _droppableCollection, _dragAndDropHooks$isV, _props$onResize, _dragAndDropHooks$isV2, _dragAndDropHooks$isV3;
  let {
    density = 'regular',
    prominence = 'default',
    dragAndDropHooks,
    onAction,
    onResizeEnd: propsOnResizeEnd,
    onResizeStart: propsOnResizeStart,
    overflowMode = 'truncate'
  } = props;
  let isTableDraggable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollectionState);
  let isTableDroppable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollectionState);
  let dragHooksProvided = useRef(isTableDraggable);
  let dropHooksProvided = useRef(isTableDroppable);
  let state = useTableState({
    ...props,
    showSelectionCheckboxes: true,
    showDragButtons: isTableDraggable,
    selectionBehavior: 'toggle'
  });
  useEffect(() => {
    if (dragHooksProvided.current !== isTableDraggable) {
      console.warn('Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.');
    }
    if (dropHooksProvided.current !== isTableDroppable) {
      console.warn('Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.');
    }
    if ('expandedKeys' in state && (isTableDraggable || isTableDroppable)) {
      console.warn('Drag and drop is not yet fully supported with expandable rows and may produce unexpected results.');
    }
  }, [isTableDraggable, isTableDroppable, state]);

  // Starts when the user selects resize from the menu, ends when resizing ends
  // used to control the visibility of the resizer Nubbin
  let [isInResizeMode, setIsInResizeMode] = useState(false);
  // Starts when the resizer is actually moved
  // entering resizing/exiting resizing doesn't trigger a render
  // with table layout, so we need to track it here
  let [, setIsResizing] = useState(false);

  // TODO: support consumer provided ref
  // let domRef = useObjectRef(forwardedRef);
  let domRef = useRef(null);
  let headerRef = useRef(null);
  let bodyRef = useRef(null);
  let styleProps = useStyleProps(props);
  let layout = useMemo(() => new TableViewLayout({
    // If props.overflowMode is wrap, then use estimated heights based on scale, otherwise use fixed heights.
    rowHeight: props.overflowMode === 'wrap' ? undefined : ROW_HEIGHTS[density],
    estimatedRowHeight: props.overflowMode === 'wrap' ? ROW_HEIGHTS[density] : undefined,
    headingHeight: props.overflowMode === 'wrap' ? undefined : DEFAULT_HEADER_HEIGHT,
    estimatedHeadingHeight: props.overflowMode === 'wrap' ? DEFAULT_HEADER_HEIGHT : undefined
  }), [props.overflowMode, density]);
  let dragState = undefined;
  let preview = useRef(null);
  if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollection && dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollectionState) {
    dragState = dragAndDropHooks.useDraggableCollectionState({
      collection: state.collection,
      selectionManager: state.selectionManager,
      preview
    });
    dragAndDropHooks.useDraggableCollection({}, dragState, domRef);
  }
  let DragPreview$1 = dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.DragPreview;
  let dropState = undefined;
  let droppableCollection = undefined;
  let isRootDropTarget = false;
  if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollection && dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollectionState) {
    dropState = dragAndDropHooks.useDroppableCollectionState({
      collection: state.collection,
      selectionManager: state.selectionManager
    });
    droppableCollection = dragAndDropHooks.useDroppableCollection({
      keyboardDelegate: new ListKeyboardDelegate({
        collection: state.collection,
        disabledKeys: state.selectionManager.disabledKeys,
        ref: domRef,
        layoutDelegate: layout
      }),
      dropTargetDelegate: layout
    }, dropState, domRef);
    isRootDropTarget = dropState.isDropTarget({
      type: 'root'
    });
  }
  let {
    gridProps
  } = useTable({
    ...props,
    isVirtualized: true,
    layoutDelegate: layout,
    onRowAction: onAction !== null && onAction !== void 0 ? onAction : props.onRowAction,
    scrollRef: bodyRef
  }, state, domRef);
  let [headerMenuOpen, setHeaderMenuOpen] = useState(false);
  let [headerRowHovered, setHeaderRowHovered] = useState(false);

  // This overrides collection view's renderWrapper to support DOM hierarchy.
  let renderWrapper = useCallback((parent, reusableView, children, renderChildren) => {
    if (reusableView.viewType === 'rowgroup') {
      return /*#__PURE__*/jsx(TableBody, {
        layoutInfo: reusableView.layoutInfo,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo
        // Override the default role="rowgroup" with role="presentation",
        // in favor or adding role="rowgroup" to the ScrollView with
        // ref={bodyRef} in the TableVirtualizer below.
        ,
        role: "presentation",
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === 'header') {
      return /*#__PURE__*/jsx(TableHead, {
        layoutInfo: reusableView.layoutInfo,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === 'row') {
      return /*#__PURE__*/jsx(TableRow, {
        item: reusableView.content,
        layoutInfo: reusableView.layoutInfo,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === 'headerrow') {
      return /*#__PURE__*/jsx(TableHeaderRow, {
        onHoverChange: setHeaderRowHovered,
        // @ts-expect-error
        layoutInfo: reusableView.layoutInfo,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
        item: reusableView.content,
        children: renderChildren(children)
      }, reusableView.key);
    }
    return /*#__PURE__*/jsx(TableCellWrapper, {
      // @ts-expect-error
      layoutInfo: reusableView.layoutInfo,
      virtualizer: reusableView.virtualizer,
      parent: parent,
      children: reusableView.rendered
    }, reusableView.key);
  }, []);
  let renderView = useCallback((type, item) => {
    switch (type) {
      case 'header':
      case 'rowgroup':
      case 'section':
      case 'row':
      case 'headerrow':
        return null;
      case 'cell':
        {
          if (item.props.isSelectionCell) {
            return /*#__PURE__*/jsx(TableCheckboxCell, {
              cell: item
            });
          }
          if (item.props.isDragButtonCell) {
            return /*#__PURE__*/jsx(TableDragCell, {
              cell: item
            });
          }
          return /*#__PURE__*/jsx(TableCell, {
            cell: item
          });
        }
      case 'placeholder':
        return /*#__PURE__*/jsx("div", {
          role: "gridcell",
          "aria-colindex": item.index && item.index + 1,
          "aria-colspan": item.colspan && item.colspan > 1 ? item.colspan : undefined
        });
      case 'column':
        if (item.props.isSelectionCell) {
          return /*#__PURE__*/jsx(TableSelectAllCell, {
            column: item
          });
        }
        if (item.props.isDragButtonCell) {
          return /*#__PURE__*/jsx(TableDragHeaderCell, {
            column: item
          });
        }

        // TODO: consider this case, what if we have hidden headers and a empty table
        if (item.props.hideHeader) {
          return /*#__PURE__*/jsxs(TooltipTrigger, {
            placement: "top",
            trigger: "focus",
            children: [/*#__PURE__*/jsx(TableColumnHeader, {
              column: item
            }), /*#__PURE__*/jsx(Tooltip, {
              children: item.rendered
            })]
          });
        }

        // NOTE: don't allow resizing on the last column, it creates a weird UX
        // where the combined column width can be less than the table
        if (item.props.allowsResizing && !!item.nextKey) {
          return /*#__PURE__*/jsx(ResizableTableColumnHeader, {
            column: item
          });
        }
        return /*#__PURE__*/jsx(TableColumnHeader, {
          column: item
        });
      case 'loader':
        return /*#__PURE__*/jsx(LoadingState, {});
      case 'empty':
        {
          return /*#__PURE__*/jsx(EmptyState, {});
        }
      default:
        {
          return null;
        }
    }
  }, []);
  let [isVerticalScrollbarVisible, setVerticalScollbarVisible] = useState(false);
  let [isHorizontalScrollbarVisible, setHorizontalScollbarVisible] = useState(false);
  let viewport = useRef({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  let onVisibleRectChange = useCallback(rect => {
    if (viewport.current.width === rect.width && viewport.current.height === rect.height) {
      return;
    }
    viewport.current = rect;
    if (bodyRef.current) {
      setVerticalScollbarVisible(bodyRef.current.clientWidth + 2 < bodyRef.current.offsetWidth);
      setHorizontalScollbarVisible(bodyRef.current.clientHeight + 2 < bodyRef.current.offsetHeight);
    }
  }, []);
  let {
    isFocusVisible,
    focusProps
  } = useFocusRing();
  let isEmpty = state.collection.size === 0;
  let onFocusedResizer = () => {
    if (bodyRef.current && headerRef.current) {
      bodyRef.current.scrollLeft = headerRef.current.scrollLeft;
    }
  };
  let onResizeStart = useCallback(widths => {
    setIsResizing(true);
    propsOnResizeStart === null || propsOnResizeStart === void 0 || propsOnResizeStart(widths);
  }, [setIsResizing, propsOnResizeStart]);
  let onResizeEnd = useCallback(widths_0 => {
    setIsInResizeMode(false);
    setIsResizing(false);
    propsOnResizeEnd === null || propsOnResizeEnd === void 0 || propsOnResizeEnd(widths_0);
  }, [propsOnResizeEnd, setIsInResizeMode, setIsResizing]);
  let focusedKey = state.selectionManager.focusedKey;
  let dropTargetKey = null;
  if (((_dropState = dropState) === null || _dropState === void 0 || (_dropState = _dropState.target) === null || _dropState === void 0 ? void 0 : _dropState.type) === 'item') {
    dropTargetKey = dropState.target.key;
    if (dropState.target.dropPosition === 'before' && dropTargetKey !== state.collection.getFirstKey()) {
      // Normalize to the "after" drop position since we only render those in the DOM.
      // The exception to this is for the first row in the table, where we also render the "before" position.
      dropTargetKey = state.collection.getKeyBefore(dropTargetKey);
    }
  }
  let persistedKeys = useMemo(() => {
    return new Set([focusedKey, dropTargetKey].filter(k => k !== null));
  }, [focusedKey, dropTargetKey]);
  let mergedProps = mergeProps(isTableDroppable ? (_droppableCollection = droppableCollection) === null || _droppableCollection === void 0 ? void 0 : _droppableCollection.collectionProps : {}, gridProps, focusProps);
  if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && (_dragAndDropHooks$isV = dragAndDropHooks.isVirtualDragging) !== null && _dragAndDropHooks$isV !== void 0 && _dragAndDropHooks$isV.call(dragAndDropHooks)) {
    delete mergedProps.tabIndex;
  }
  let cosmeticConfig = {
    density,
    overflowMode,
    prominence
  };
  return /*#__PURE__*/jsxs(TableContext.Provider, {
    value: {
      cosmeticConfig,
      dragAndDropHooks,
      dragState,
      dropState,
      headerMenuOpen,
      headerRowHovered,
      isEmpty,
      isInResizeMode,
      isTableDraggable,
      isTableDroppable,
      layout,
      onFocusedResizer,
      onResize: (_props$onResize = props.onResize) !== null && _props$onResize !== void 0 ? _props$onResize : () => {},
      onResizeEnd,
      onResizeStart,
      renderEmptyState: props.renderEmptyState,
      setHeaderMenuOpen,
      setIsInResizeMode,
      state
    },
    children: [/*#__PURE__*/jsx(TableVirtualizer, {
      ...mergedProps,
      ...styleProps,
      ...toDataAttributes({
        ...cosmeticConfig,
        scrollbar: isVerticalScrollbarVisible && isHorizontalScrollbarVisible ? 'both' : isVerticalScrollbarVisible ? 'vertical' : isHorizontalScrollbarVisible ? 'horizontal' : undefined
      }),
      className: classNames(tableClassname, styleProps.className),
      tableState: state,
      cosmeticConfig: cosmeticConfig,
      layout: layout,
      collection: state.collection,
      persistedKeys: persistedKeys,
      renderView: renderView
      // @ts-expect-error
      ,
      renderWrapper: renderWrapper,
      onVisibleRectChange: onVisibleRectChange,
      domRef: domRef,
      headerRef: headerRef,
      bodyRef: bodyRef,
      isFocusVisible: isFocusVisible,
      isVirtualDragging: (_dragAndDropHooks$isV2 = dragAndDropHooks === null || dragAndDropHooks === void 0 || (_dragAndDropHooks$isV3 = dragAndDropHooks.isVirtualDragging) === null || _dragAndDropHooks$isV3 === void 0 ? void 0 : _dragAndDropHooks$isV3.call(dragAndDropHooks)) !== null && _dragAndDropHooks$isV2 !== void 0 ? _dragAndDropHooks$isV2 : false,
      isRootDropTarget: isRootDropTarget
    }), DragPreview$1 && isTableDraggable && /*#__PURE__*/jsx(DragPreview$1, {
      ref: preview,
      children: () => {
        var _dragState, _dragState$draggingKe, _dragState2, _bodyRef$current, _state$collection$get, _state$collection, _dragState3;
        if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.renderPreview && (_dragState = dragState) !== null && _dragState !== void 0 && _dragState.draggingKeys) {
          return dragAndDropHooks.renderPreview(dragState.draggingKeys, dragState.draggedKey);
        }
        let itemCount = (_dragState$draggingKe = (_dragState2 = dragState) === null || _dragState2 === void 0 ? void 0 : _dragState2.draggingKeys.size) !== null && _dragState$draggingKe !== void 0 ? _dragState$draggingKe : 0;
        let maxWidth = bodyRef === null || bodyRef === void 0 || (_bodyRef$current = bodyRef.current) === null || _bodyRef$current === void 0 ? void 0 : _bodyRef$current.getBoundingClientRect().width;
        let height = ROW_HEIGHTS[density];
        let itemText = (_state$collection$get = (_state$collection = state.collection).getTextValue) === null || _state$collection$get === void 0 ? void 0 : _state$collection$get.call(_state$collection, (_dragState3 = dragState) === null || _dragState3 === void 0 ? void 0 : _dragState3.draggedKey);
        return /*#__PURE__*/jsx(DragPreview, {
          itemText: itemText,
          itemCount: itemCount,
          height: height,
          maxWidth: maxWidth
        });
      }
    })]
  });
}
function TableVirtualizer(props) {
  var _layout$getLayoutInfo;
  let {
    cosmeticConfig,
    tableState,
    layout,
    collection,
    persistedKeys,
    renderView,
    renderWrapper,
    domRef,
    bodyRef,
    headerRef,
    onVisibleRectChange: onVisibleRectChangeProp,
    isFocusVisible,
    isVirtualDragging,
    isRootDropTarget,
    ...otherProps
  } = props;
  let {
    direction
  } = useLocale();
  let loadingState = collection.body.props.loadingState;
  let isLoading = loadingState === 'loading' || loadingState === 'loadingMore';
  let onLoadMore = collection.body.props.onLoadMore;
  let [tableWidth, setTableWidth] = useState(0);
  const slots = useMemo(() => {
    return {
      text: {
        truncate: cosmeticConfig.overflowMode === 'truncate'
      }
    };
  }, [cosmeticConfig.overflowMode]);
  const getDefaultWidth = useCallback(({
    props: {
      hideHeader,
      isSelectionCell,
      showDivider,
      isDragButtonCell
    }
  }) => {
    if (hideHeader) {
      let width = DEFAULT_HIDE_HEADER_CELL_WIDTH;
      return showDivider ? width + 1 : width;
    } else if (isSelectionCell) {
      return SELECTION_CELL_DEFAULT_WIDTH;
    } else if (isDragButtonCell) {
      return DRAG_BUTTON_CELL_DEFAULT_WIDTH;
    }
  }, []);
  const getDefaultMinWidth = useCallback(({
    props: {
      hideHeader: hideHeader_0,
      isSelectionCell: isSelectionCell_0,
      showDivider: showDivider_0,
      isDragButtonCell: isDragButtonCell_0
    }
  }) => {
    if (hideHeader_0) {
      let width_0 = DEFAULT_HIDE_HEADER_CELL_WIDTH;
      return showDivider_0 ? width_0 + 1 : width_0;
    } else if (isSelectionCell_0) {
      return SELECTION_CELL_DEFAULT_WIDTH;
    } else if (isDragButtonCell_0) {
      return DRAG_BUTTON_CELL_DEFAULT_WIDTH;
    }
    return 75;
  }, []);
  let columnResizeState = useTableColumnResizeState({
    tableWidth,
    getDefaultWidth,
    getDefaultMinWidth
  }, tableState);
  let state = useVirtualizerState({
    layout,
    collection,
    renderView,
    onVisibleRectChange(rect) {
      if (bodyRef.current) {
        bodyRef.current.scrollTop = rect.y;
        setScrollLeft(bodyRef.current, direction, rect.x);
      }
    },
    persistedKeys,
    layoutOptions: useMemo(() => ({
      columnWidths: columnResizeState.columnWidths
    }), [columnResizeState.columnWidths])
  });
  useLoadMore({
    isLoading,
    onLoadMore,
    scrollOffset: 1
  }, bodyRef);
  let onVisibleRectChange = useCallback(rect_0 => {
    state.setVisibleRect(rect_0);
  }, [state]);
  let onVisibleRectChangeMemo = useCallback(rect_1 => {
    setTableWidth(rect_1.width);
    onVisibleRectChange(rect_1);
    onVisibleRectChangeProp(rect_1);
  }, [onVisibleRectChange, onVisibleRectChangeProp]);

  // this effect runs whenever the contentSize changes, it doesn't matter what the content size is
  // only that it changes in a resize, and when that happens, we want to sync the body to the
  // header scroll position
  useEffect(() => {
    if (getInteractionModality() === 'keyboard' && bodyRef.current && domRef.current && headerRef.current && headerRef.current.contains(document.activeElement) && document.activeElement instanceof HTMLElement) {
      scrollIntoView(headerRef.current, document.activeElement);
      scrollIntoViewport(document.activeElement, {
        containingElement: domRef.current
      });
      bodyRef.current.scrollLeft = headerRef.current.scrollLeft;
    }
  }, [state.contentSize, headerRef, bodyRef, domRef]);
  let headerHeight = ((_layout$getLayoutInfo = layout.getLayoutInfo('header')) === null || _layout$getLayoutInfo === void 0 ? void 0 : _layout$getLayoutInfo.rect.height) || 0;

  // Sync the scroll position from the table body to the header container.
  let onScroll = useCallback(() => {
    if (bodyRef.current && headerRef.current) {
      headerRef.current.scrollLeft = bodyRef.current.scrollLeft;
    }
  }, [bodyRef, headerRef]);
  let resizerPosition = columnResizeState.resizingColumn != null ? layout.getLayoutInfo(columnResizeState.resizingColumn).rect.maxX - 2 : 0;

  // minimize re-render caused on Resizers by memoing this
  let resizingColumnWidth = columnResizeState.resizingColumn != null ? columnResizeState.getColumnWidth(columnResizeState.resizingColumn) : 0;
  let resizingColumn = useMemo(() => ({
    width: resizingColumnWidth,
    key: columnResizeState.resizingColumn
  }), [resizingColumnWidth, columnResizeState.resizingColumn]);
  if (isVirtualDragging) {
    delete otherProps.tabIndex;
  }
  let firstColumn = collection.columns[0];
  let scrollPadding = 0;
  if (firstColumn.props.isSelectionCell || firstColumn.props.isDragButtonCell) {
    scrollPadding = columnResizeState.getColumnWidth(firstColumn.key);
  }

  // @ts-expect-error `renderWrapper` will be defined
  let visibleViews = renderChildren(null, state.visibleViews, renderWrapper);
  return /*#__PURE__*/jsx(VirtualizerContext.Provider, {
    value: resizingColumn,
    children: /*#__PURE__*/jsx(FocusScope, {
      children: /*#__PURE__*/jsxs("div", {
        ...otherProps,
        ref: domRef,
        children: [/*#__PURE__*/jsx("div", {
          role: "presentation",
          className: headerWrapperClassname,
          style: {
            height: headerHeight,
            overflow: 'hidden',
            position: 'relative',
            willChange: state.isScrolling ? 'scroll-position' : undefined,
            scrollPaddingInlineStart: scrollPadding
          },
          ref: headerRef,
          children: /*#__PURE__*/jsx(ResizeStateContext.Provider, {
            value: columnResizeState,
            children: visibleViews[0]
          })
        }), /*#__PURE__*/jsx(SlotProvider, {
          slots: slots,
          children: /*#__PURE__*/jsxs(ScrollView, {
            "data-focus": isFocusVisible ? 'visible' : undefined,
            className: bodyClassname
            //  Firefox and Chrome make generic elements using CSS overflow 'scroll' or 'auto' tabbable,
            //  including them within the accessibility tree, which breaks the table structure in Firefox.
            //  Using tabIndex={-1} prevents the ScrollView from being tabbable, and using role="rowgroup"
            //  here and role="presentation" on the table body content fixes the table structure.
            ,
            role: "rowgroup",
            tabIndex: isVirtualDragging ? undefined : -1,
            style: {
              flex: 1,
              scrollPaddingInlineStart: scrollPadding
            },
            innerStyle: {
              overflow: 'visible'
            },
            ref: bodyRef,
            contentSize: state.contentSize,
            onVisibleRectChange: onVisibleRectChangeMemo,
            onScrollStart: state.startScrolling,
            onScrollEnd: state.endScrolling,
            onScroll: onScroll,
            children: [visibleViews[1], /*#__PURE__*/jsx("div", {
              className: bodyResizeIndicatorClassname,
              style: {
                [direction === 'ltr' ? 'left' : 'right']: `${resizerPosition}px`,
                height: `${Math.max(state.virtualizer.contentSize.height, state.virtualizer.visibleRect.height)}px`,
                display: columnResizeState.resizingColumn ? 'block' : 'none'
              }
            })]
          })
        })]
      })
    })
  });
}

// Styled components
// ------------------------------

function renderChildren(parent, views, renderWrapper) {
  return views.map(view => {
    return renderWrapper(parent, view, view.children ? Array.from(view.children) : [], childViews => renderChildren(view, childViews, renderWrapper));
  });
}
function useStyle(layoutInfo, parent) {
  let {
    direction
  } = useLocale();
  let style = layoutInfoToStyle(layoutInfo, direction, parent);
  if (style.overflow === 'hidden') {
    style.overflow = 'visible'; // needed to support position: sticky
  }
  return style;
}
function TableHead({
  children,
  layoutInfo,
  parent,
  ...otherProps
}) {
  let {
    rowGroupProps
  } = useTableRowGroup();
  let style = useStyle(layoutInfo, parent);
  return /*#__PURE__*/jsx("div", {
    ...rowGroupProps,
    ...otherProps,
    className: headerClassname,
    style: style,
    children: children
  });
}
function TableDragHeaderCell(props) {
  let {
    column
  } = props;
  let ref = useRef(null);
  let {
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = useTableColumnHeader({
    node: column,
    isVirtualized: true
  }, state, ref);
  let stringFormatter = useLocalizedStringFormatter(localizedMessages);
  return /*#__PURE__*/jsx(FocusRing$1, {
    children: /*#__PURE__*/jsx("div", {
      ...columnHeaderProps,
      ref: ref,
      className: headerCellClassname,
      style: {
        padding: 0,
        height: 'inherit'
      },
      children: /*#__PURE__*/jsx(VisuallyHidden, {
        children: stringFormatter.format('drag')
      })
    })
  });
}
function TableBody({
  children,
  layoutInfo,
  parent,
  ...otherProps
}) {
  let {
    rowGroupProps
  } = useTableRowGroup();
  let style = useStyle(layoutInfo, parent);
  return /*#__PURE__*/jsx("div", {
    ...rowGroupProps,
    ...otherProps,
    style: style,
    children: children
  });
}
function TableHeaderRow(props) {
  let ref = useRef(null);
  let {
    state
  } = useTableContext();
  let {
    hoverProps
  } = useHover(props);
  let {
    rowProps
  } = useTableHeaderRow({
    node: props.item,
    isVirtualized: true
  }, state, ref);
  // let styleProps = useRowHeaderStyleProps(props);

  return /*#__PURE__*/jsx("div", {
    className: rowClassname,
    ...mergeProps(rowProps, hoverProps),
    ref: ref,
    children: props.children
  });
}
function TableColumnHeader(props) {
  let {
    column
  } = props;
  let columnProps = column.props;
  let ref = useRef(null);
  let {
    cosmeticConfig,
    isEmpty,
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = useTableColumnHeader({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    hoverProps,
    isHovered
  } = useHover({
    ...props,
    isDisabled: isEmpty || !columnProps.allowsSorting
  });
  let slots = useMemo(() => {
    return {
      text: {
        color: 'inherit',
        weight: 'medium',
        truncate: true
      }
    };
  }, []);
  return /*#__PURE__*/jsx(FocusRing$1, {
    children: /*#__PURE__*/jsxs("div", {
      ...mergeProps(columnHeaderProps, hoverProps),
      ...toDataAttributes({
        align: columnProps.align,
        isHovered,
        overflowMode: 'truncate',
        prominence: cosmeticConfig.prominence
      }, {
        omitFalsyValues: true,
        trimBooleanKeys: true
      }),
      className: headerCellClassname,
      ref: ref,
      children: [/*#__PURE__*/jsx(SlotProvider, {
        slots: slots,
        children: columnProps.hideHeader ? /*#__PURE__*/jsx(VisuallyHidden, {
          children: column.rendered
        }) : isReactText(column.rendered) ? /*#__PURE__*/jsx(Text, {
          children: column.rendered
        }) : column.rendered
      }), columnProps.allowsSorting && /*#__PURE__*/jsx(SortIndicator, {})]
    })
  });
}
function ResizableTableColumnHeader(props) {
  var _state$sortDescriptor, _state$sortDescriptor2;
  let {
    column
  } = props;
  let ref = useRef(null);
  let triggerRef = useRef(null);
  let resizingRef = useRef(null);
  let {
    state,
    onResizeStart,
    onResize,
    onResizeEnd,
    headerRowHovered,
    isEmpty
  } = useTableContext();
  let columnResizeState = useResizeStateContext();
  let {
    pressProps,
    isPressed
  } = usePress({
    isDisabled: isEmpty
  });
  let {
    columnHeaderProps
  } = useTableColumnHeader({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    hoverProps,
    isHovered
  } = useHover({
    ...props,
    isDisabled: isEmpty
  });
  let slots = useMemo(() => {
    return {
      text: {
        color: 'inherit',
        weight: 'medium',
        truncate: true
      }
    };
  }, []);
  let resizingColumn = columnResizeState.resizingColumn;
  let showResizer = !isEmpty && (headerRowHovered && getInteractionModality() !== 'keyboard' || resizingColumn != null);
  let alignment = 'start';
  if (column.props.align === 'center' || column.colspan && column.colspan > 1) {
    alignment = 'center';
  } else if (column.props.align === 'end') {
    alignment = 'end';
  }
  return /*#__PURE__*/jsx(FocusRing$1, {
    children: /*#__PURE__*/jsxs("div", {
      ...toDataAttributes({
        align: alignment,
        sortable: column.props.allowsSorting,
        resizable: column.props.allowsResizing,
        interaction: isPressed ? 'press' : isHovered ? 'hover' : undefined,
        sort: ((_state$sortDescriptor = state.sortDescriptor) === null || _state$sortDescriptor === void 0 ? void 0 : _state$sortDescriptor.column) === column.key ? (_state$sortDescriptor2 = state.sortDescriptor) === null || _state$sortDescriptor2 === void 0 ? void 0 : _state$sortDescriptor2.direction : undefined
      }, {
        omitFalsyValues: true,
        trimBooleanKeys: true
      }),
      ...mergeProps(columnHeaderProps, pressProps, hoverProps),
      ref: ref,
      className: headerCellClassname,
      children: [/*#__PURE__*/jsx(SlotProvider, {
        slots: slots,
        children: column.props.hideHeader ? /*#__PURE__*/jsx(VisuallyHidden, {
          children: column.rendered
        }) : isReactText(column.rendered) ? /*#__PURE__*/jsx(Text, {
          children: column.rendered
        }) : column.rendered
      }), column.props.allowsSorting && /*#__PURE__*/jsx(SortIndicator, {}), /*#__PURE__*/jsx(_Resizer, {
        ref: resizingRef,
        column: column,
        showResizer: showResizer,
        onResizeStart: onResizeStart,
        onResize: onResize,
        onResizeEnd: onResizeEnd,
        triggerRef: triggerRef
      }), /*#__PURE__*/jsx("div", {
        "aria-hidden": true,
        "data-visible": resizingColumn != null,
        "data-resizing": resizingColumn === column.key,
        className: columnResizeIndicatorClassname
      })]
    })
  });
}
function TableRow(props) {
  var _state$collection$row, _draggableItem, _draggableItem2, _dragAndDropHooks$isV4, _droppableItem, _droppableItem2, _layout$virtualizer2, _dropIndicator, _dropIndicator2, _layout$virtualizer3;
  let {
    item,
    children,
    layoutInfo,
    parent,
    ...otherProps
  } = props;
  let ref = useRef(null);
  let {
    state,
    layout,
    dragAndDropHooks,
    isTableDraggable,
    isTableDroppable,
    dragState,
    dropState
  } = useTableContext();
  let {
    rowProps,
    hasAction,
    allowsSelection
  } = useTableRow({
    node: item,
    isVirtualized: true,
    shouldSelectOnPressUp: isTableDraggable
  }, state, ref);
  let isSelected = state.selectionManager.isSelected(item.key);
  let isDisabled = state.selectionManager.isDisabled(item.key);
  let isInteractive = !isDisabled && (hasAction || allowsSelection || isTableDraggable);
  let isDroppable = isTableDroppable && !isDisabled;
  let {
    pressProps,
    isPressed
  } = usePress({
    isDisabled: !isInteractive
  });

  // The row should show the focus background style when any cell inside it is focused.
  // If the row itself is focused, then it should have a blue focus indicator on the left.
  let {
    isFocusVisible: isFocusVisibleWithin,
    focusProps: focusWithinProps
  } = useFocusRing({
    within: true
  });
  let {
    isFocusVisible,
    focusProps
  } = useFocusRing();
  let {
    hoverProps,
    isHovered
  } = useHover({
    isDisabled: !isInteractive
  });
  let isFirstRow = ((_state$collection$row = state.collection.rows.find(row => row.level === 1)) === null || _state$collection$row === void 0 ? void 0 : _state$collection$row.key) === item.key;
  let isLastRow = item.nextKey == null;
  // Figure out if the TableView content is equal or greater in height to the container. If so, we'll need to round the bottom
  // border corners of the last row when selected.
  let isFlushWithContainerBottom = false;
  if (isLastRow) {
    var _layout$getContentSiz, _layout$virtualizer;
    if (((_layout$getContentSiz = layout.getContentSize()) === null || _layout$getContentSiz === void 0 ? void 0 : _layout$getContentSiz.height) >= ((_layout$virtualizer = layout.virtualizer) === null || _layout$virtualizer === void 0 ? void 0 : _layout$virtualizer.visibleRect.height)) {
      isFlushWithContainerBottom = true;
    }
  }
  let draggableItem = null;
  if (isTableDraggable) {
    assert(!!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableItem));
    assert(!!dragState);
    draggableItem = dragAndDropHooks.useDraggableItem({
      key: item.key,
      hasDragButton: true
    }, dragState);
    if (isDisabled) {
      draggableItem = null;
    }
  }
  let droppableItem = null;
  let isDropTarget = false;
  let dropIndicator = null;
  let dropIndicatorRef = useRef(null);
  if (isTableDroppable) {
    assert(!!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableItem));
    assert(!!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDropIndicator));
    assert(!!dropState);
    let target = {
      type: 'item',
      key: item.key,
      dropPosition: 'on'
    };
    isDropTarget = dropState.isDropTarget(target);
    droppableItem = dragAndDropHooks.useDroppableItem({
      target
    }, dropState, dropIndicatorRef);
    dropIndicator = dragAndDropHooks.useDropIndicator({
      target
    }, dropState, dropIndicatorRef);
  }
  let dragButtonRef = useRef(null);
  let {
    buttonProps: dragButtonProps
  } = useButton({
    ...((_draggableItem = draggableItem) === null || _draggableItem === void 0 ? void 0 : _draggableItem.dragButtonProps),
    elementType: 'div'
  }, dragButtonRef);
  let style = useStyle(layoutInfo, parent);
  let mergedRowProps = mergeProps(rowProps, otherProps, {
    style
  }, focusWithinProps, focusProps, hoverProps, pressProps, (_draggableItem2 = draggableItem) === null || _draggableItem2 === void 0 ? void 0 : _draggableItem2.dragProps);
  // Remove tab index from list row if performing a screenreader drag. This
  // prevents TalkBack from focusing the row, allowing for single swipe
  // navigation between row drop indicator
  if (dragAndDropHooks !== null && dragAndDropHooks !== void 0 && (_dragAndDropHooks$isV4 = dragAndDropHooks.isVirtualDragging) !== null && _dragAndDropHooks$isV4 !== void 0 && _dragAndDropHooks$isV4.call(dragAndDropHooks)) {
    delete mergedRowProps.tabIndex;
  }
  let dropProps = isDroppable ? (_droppableItem = droppableItem) === null || _droppableItem === void 0 ? void 0 : _droppableItem.dropProps : {
    'aria-hidden': (_droppableItem2 = droppableItem) === null || _droppableItem2 === void 0 ? void 0 : _droppableItem2.dropProps['aria-hidden']
  };
  let {
    visuallyHiddenProps
  } = useVisuallyHidden();
  return /*#__PURE__*/jsxs(TableRowContext.Provider, {
    value: {
      dragButtonProps,
      dragButtonRef,
      isHovered,
      isFocusVisibleWithin
    },
    children: [isTableDroppable && isFirstRow && /*#__PURE__*/jsx(InsertionIndicator, {
      rowProps: mergedRowProps,
      visibleRect: (_layout$virtualizer2 = layout.virtualizer) === null || _layout$virtualizer2 === void 0 ? void 0 : _layout$virtualizer2.visibleRect,
      target: {
        key: item.key,
        type: 'item',
        dropPosition: 'before'
      }
    }, `${item.key}-before`), isTableDroppable && !((_dropIndicator = dropIndicator) !== null && _dropIndicator !== void 0 && _dropIndicator.isHidden) && /*#__PURE__*/jsx("div", {
      role: "row",
      ...visuallyHiddenProps,
      children: /*#__PURE__*/jsx("div", {
        role: "gridcell",
        children: /*#__PURE__*/jsx("div", {
          role: "button",
          ...((_dropIndicator2 = dropIndicator) === null || _dropIndicator2 === void 0 ? void 0 : _dropIndicator2.dropIndicatorProps),
          ref: dropIndicatorRef
        })
      })
    }), /*#__PURE__*/jsx("div", {
      ...mergeProps(mergedRowProps, dropProps),
      ...toDataAttributes({
        isDisabled,
        isDropTarget,
        isFocusVisible,
        isFocusVisibleWithin,
        isFlushWithContainerBottom,
        isFirstRow,
        isLastRow,
        isHovered,
        isPressed,
        isSelected,
        isNextSelected: item.nextKey && state.selectionManager.isSelected(item.nextKey)
      }, {
        omitFalsyValues: true,
        trimBooleanKeys: true
      }),
      ref: ref,
      className: rowClassname,
      children: children
    }), isTableDroppable && /*#__PURE__*/jsx(InsertionIndicator, {
      rowProps: mergedRowProps,
      visibleRect: (_layout$virtualizer3 = layout.virtualizer) === null || _layout$virtualizer3 === void 0 ? void 0 : _layout$virtualizer3.visibleRect,
      target: {
        key: item.key,
        type: 'item',
        dropPosition: 'after'
      }
    }, `${item.key}-after`)]
  });
}
function TableDragCell(props) {
  let {
    cell
  } = props;
  let ref = useRef(null);
  let {
    cosmeticConfig,
    state,
    isTableDraggable
  } = useTableContext();
  let isDisabled = cell.parentKey && state.selectionManager.isDisabled(cell.parentKey);
  let {
    gridCellProps
  } = useTableCell({
    node: cell,
    isVirtualized: true
  }, state, ref);
  return /*#__PURE__*/jsx(FocusRing$1, {
    children: /*#__PURE__*/jsx("div", {
      ...gridCellProps,
      ...toDataAttributes({
        ...cosmeticConfig,
        isDisabled
      }, {
        omitFalsyValues: true,
        trimBooleanKeys: true
      }),
      ref: ref,
      className: classNames(cellClassname, dragCellClassname),
      children: isTableDraggable && !isDisabled && /*#__PURE__*/jsx(DragButton, {})
    })
  });
}
function DragButton() {
  let {
    dragButtonProps,
    dragButtonRef,
    isFocusVisibleWithin,
    isHovered
  } = useTableRowContext();
  let {
    visuallyHiddenProps
  } = useVisuallyHidden();
  return /*#__PURE__*/jsx(FocusRing$1, {
    children: /*#__PURE__*/jsx("div", {
      ...dragButtonProps,
      className: css({
        borderRadius: tokenSchema.size.radius.xsmall,
        display: 'flex',
        justifyContent: 'center',
        outline: 0,
        padding: 0,
        height: tokenSchema.size.icon.regular,
        width: 10,
        // magic number specific to this icon. minimizing space taken by drag handle

        '&[data-focus=visible]': {
          outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`
        }
      }),
      style: !isFocusVisibleWithin && !isHovered ? visuallyHiddenProps.style : {},
      ref: dragButtonRef,
      draggable: "true",
      children: /*#__PURE__*/jsx(Icon, {
        src: gripVerticalIcon,
        color: "neutral"
      })
    })
  });
}
function TableCell({
  cell
}) {
  var _cell$column, _cell$column2, _cell$column3, _cell$column4;
  let {
    cosmeticConfig,
    state
  } = useTableContext();
  let ref = useRef(null);
  let {
    gridCellProps
  } = useTableCell({
    node: cell,
    isVirtualized: true
  }, state, ref);
  let {
    id,
    ...otherGridCellProps
  } = gridCellProps;
  return /*#__PURE__*/jsx(FocusRing$1, {
    children: /*#__PURE__*/jsx("div", {
      ...otherGridCellProps,
      ...toDataAttributes({
        ...cosmeticConfig,
        align: (_cell$column = cell.column) === null || _cell$column === void 0 ? void 0 : _cell$column.props.align,
        hideHeader: (_cell$column2 = cell.column) === null || _cell$column2 === void 0 ? void 0 : _cell$column2.props.hideHeader,
        showDivider: ((_cell$column3 = cell.column) === null || _cell$column3 === void 0 ? void 0 : _cell$column3.props.showDivider) && ((_cell$column4 = cell.column) === null || _cell$column4 === void 0 ? void 0 : _cell$column4.nextKey) !== null
      }),
      "aria-labelledby": id,
      ref: ref,
      className: cellClassname,
      children: typeof cell.rendered === 'boolean' || cell.rendered == null ? null : /*#__PURE__*/jsx(CellContents, {
        id: id,
        children: isReactText(cell.rendered) ? /*#__PURE__*/jsx(Text, {
          children: cell.rendered
        }) : cell.rendered
      })
    })
  });
}
function CellContents(props) {
  const {
    children,
    ...attributes
  } = props;
  const slots = useMemo(() => ({
    text: {
      color: 'inherit'
    }
  }), []);
  const element = Children.only(children);
  return /*#__PURE__*/jsx(SlotProvider, {
    slots: slots,
    children: /*#__PURE__*/cloneElement(element, mergeProps(element.props, attributes))
  });
}
function TableCellWrapper(props) {
  let {
    layoutInfo,
    virtualizer,
    parent,
    children
  } = props;
  let {
    isTableDroppable,
    dropState
  } = useTableContext();
  let isDropTarget = false;
  let isRootDroptarget = false;
  if (isTableDroppable) {
    assert(!!dropState);
    let key = parent.content.key;
    if (key) {
      isDropTarget = dropState.isDropTarget({
        type: 'item',
        dropPosition: 'on',
        key: key
      });
    }
    isRootDroptarget = dropState.isDropTarget({
      type: 'root'
    });
  }
  return /*#__PURE__*/jsx(VirtualizerItem, {
    layoutInfo: layoutInfo,
    virtualizer: virtualizer,
    parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo
    // only when !layoutInfo.estimatedSize???
    ,
    className: cellWrapperClassname,
    "data-droptarget": isDropTarget || isRootDroptarget,
    children: children
  });
}
function TableCheckboxCell({
  cell
}) {
  let ref = useRef(null);
  let {
    cosmeticConfig,
    state
  } = useTableContext();
  // The TableCheckbox should always render its disabled status if the row is disabled, regardless of disabledBehavior,
  // but the cell itself should not render its disabled styles if disabledBehavior="selection" because the row might have actions on it.
  let isSelectionDisabled = state.disabledKeys.has(cell.parentKey);
  let isDisabled = state.selectionManager.isDisabled(cell.parentKey);
  let {
    gridCellProps
  } = useTableCell({
    node: cell,
    isVirtualized: true
  }, state, ref);
  let {
    checkboxProps
  } = useTableSelectionCheckbox({
    key: cell.parentKey
  }, state);
  return /*#__PURE__*/jsx("div", {
    ...toDataAttributes({
      ...cosmeticConfig,
      isDisabled
    }, {
      trimBooleanKeys: true,
      omitFalsyValues: true
    }),
    className: classNames(cellClassname, checkboxCellClassname),
    ref: ref,
    ...gridCellProps,
    children: /*#__PURE__*/jsx(Checkbox, {
      ...checkboxProps,
      isDisabled: isSelectionDisabled
    })
  });
}
function TableSelectAllCell({
  column
}) {
  let ref = useRef(null);
  let {
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = useTableColumnHeader({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    checkboxProps
  } = useTableSelectAllCheckbox(state);
  // FIXME
  // let styleProps = useSelectionCellStyleProps();

  return /*#__PURE__*/jsx("div", {
    className: classNames(cellClassname, checkboxCellClassname, headerCellClassname),
    ref: ref,
    ...columnHeaderProps,
    children: state.selectionManager.selectionMode === 'single' ? /*#__PURE__*/jsx(VisuallyHidden, {
      children: checkboxProps['aria-label']
    }) : /*#__PURE__*/jsx(Checkbox, {
      ...checkboxProps
    })
  });
}
function LoadingState() {
  let {
    state
  } = useTableContext();
  let stringFormatter = useLocalizedStringFormatter(localizedMessages);
  return /*#__PURE__*/jsx(CenteredWrapper, {
    children: /*#__PURE__*/jsx(ProgressCircle, {
      isIndeterminate: true,
      "aria-label": state.collection.size > 0 ? stringFormatter.format('loadingMore') : stringFormatter.format('loading')
    })
  });
}
function EmptyState() {
  let {
    renderEmptyState
  } = useTableContext();
  let emptyState = renderEmptyState ? renderEmptyState() : null;
  if (emptyState == null) {
    return null;
  }
  return /*#__PURE__*/jsx(CenteredWrapper, {
    children: emptyState
  });
}
function CenteredWrapper({
  children
}) {
  let {
    state
  } = useTableContext();
  let rowProps = {
    'aria-rowindex': state.collection.headerRows.length + state.collection.size + 1
  };
  return /*#__PURE__*/jsx("div", {
    role: "row",
    ...rowProps,
    className: centeredWrapperClassname,
    children: /*#__PURE__*/jsx("div", {
      role: "rowheader",
      "aria-colspan": state.collection.columns.length,
      children: children
    })
  });
}

// Override TS for Column to support Keystar UI specific props.
const VoussoirColumn = Column;

export { VoussoirColumn as Column, TableView };
