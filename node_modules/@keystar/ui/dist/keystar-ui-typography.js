'use client';
import { useVisuallyHidden } from '@react-aria/visually-hidden';
export { VisuallyHidden } from '@react-aria/visually-hidden';
import { createContext, useContext, useMemo, forwardRef, useSyncExternalStore } from 'react';
import { useSlotProps } from '@keystar/ui/slots';
import { forwardRefWithAs } from '@keystar/ui/utils/ts';
import { c } from './react-compiler-runtime-19061925.js';
import { ClassList, tokenSchema, maybeTokenByKey, css, useStyleProps, useResponsiveRange, filterStyleProps, toDataAttributes, classNames } from '@keystar/ui/style';
import { isReactText } from '@keystar/ui/utils';
import { jsx, jsxs } from 'react/jsx-runtime';
import { filterDOMProps, isMac } from '@react-aria/utils';
import { warning, assert, isInteger } from 'emery';
import { useNumberFormatter } from '@react-aria/i18n';

const HeadingContext = /*#__PURE__*/createContext(undefined);
function useHeadingContext() {
  return useContext(HeadingContext);
}

// 'medium' is arbitrary, we just want the shape
/**
 * Using [capsize](https://seek-oss.github.io/capsize/), get the leading-trim
 * styles for a text element.
 */
function getTrimStyles(fontDefinition) {
  const {
    capheightTrim: marginBottom,
    baselineTrim: marginTop
  } = fontDefinition;
  return {
    display: 'block',
    lineHeight: fontDefinition.lineheight,
    '::before': {
      content: '" "',
      display: 'table',
      marginBottom
    },
    '::after': {
      content: '" "',
      display: 'table',
      marginTop
    }
  };
}

const TextContext = /*#__PURE__*/createContext(undefined);
function useTextContext() {
  return useContext(TextContext);
}

const textClassList = new ClassList('Text');
function useTextStyles(props) {
  const $ = c(30);
  const prevContext = useTextContext();
  let t0;
  let t1;
  let size;
  let color;
  let weight;
  let align;
  let variant;
  let casing;
  let otherProps;
  let UNSAFE_className;
  if ($[0] !== props) {
    ({
      align,
      casing,
      overflow: t0,
      size,
      color,
      trim: t1,
      variant,
      weight,
      UNSAFE_className,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = size;
    $[4] = color;
    $[5] = weight;
    $[6] = align;
    $[7] = variant;
    $[8] = casing;
    $[9] = otherProps;
    $[10] = UNSAFE_className;
  } else {
    t0 = $[1];
    t1 = $[2];
    size = $[3];
    color = $[4];
    weight = $[5];
    align = $[6];
    variant = $[7];
    casing = $[8];
    otherProps = $[9];
    UNSAFE_className = $[10];
  }
  const overflow = t0 === undefined ? "breakword" : t0;
  const trim = t1 === undefined ? !prevContext : t1;
  const fontDefinition = tokenSchema.typography.text[size];
  let t2;
  let t3;
  let t4;
  if ($[11] !== trim || $[12] !== fontDefinition || $[13] !== color || $[14] !== weight || $[15] !== align || $[16] !== variant || $[17] !== casing || $[18] !== overflow || $[19] !== otherProps) {
    const trimStyles = trim ? getTrimStyles(fontDefinition) : null;
    const styles = [{
      color: maybeTokenByKey("color.foreground", color),
      fontFamily: tokenSchema.typography.fontFamily.base,
      fontSize: fontDefinition.size,
      fontVariantNumeric: variant,
      fontWeight: weight === "inherit" ? undefined : tokenSchema.typography.fontWeight[weight],
      minWidth: 0,
      textAlign: align ? alignmentMap[align] : undefined,
      textTransform: casing
    }, textOptimizationStyles, overflow && overflowMap[overflow], trimStyles];
    t4 = useStyleProps;
    t3 = otherProps;
    t2 = css(styles);
    $[11] = trim;
    $[12] = fontDefinition;
    $[13] = color;
    $[14] = weight;
    $[15] = align;
    $[16] = variant;
    $[17] = casing;
    $[18] = overflow;
    $[19] = otherProps;
    $[20] = t2;
    $[21] = t3;
    $[22] = t4;
  } else {
    t2 = $[20];
    t3 = $[21];
    t4 = $[22];
  }
  let t5;
  if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = textClassList.element("root");
    $[23] = t5;
  } else {
    t5 = $[23];
  }
  let t6;
  if ($[24] !== t2 || $[25] !== UNSAFE_className) {
    t6 = [t2, UNSAFE_className, t5];
    $[24] = t2;
    $[25] = UNSAFE_className;
    $[26] = t6;
  } else {
    t6 = $[26];
  }
  let t7;
  if ($[27] !== t3 || $[28] !== t6) {
    t7 = {
      ...t3,
      UNSAFE_className: t6
    };
    $[27] = t3;
    $[28] = t6;
    $[29] = t7;
  } else {
    t7 = $[29];
  }
  return t4(t7);
}

// Constants
// ----------------------------------------------------------------------------

const textOptimizationStyles = {
  MozOsxFontSmoothing: 'auto',
  WebkitFontSmoothing: 'auto'
};
const alignmentMap = {
  start: 'start',
  center: 'center',
  end: 'end',
  FORCE_left: 'left',
  FORCE_right: 'right'
};
const overflowMap = {
  unset: {},
  nowrap: {
    whiteSpace: 'nowrap'
  },
  breakword: {
    // hyphens: 'auto', // too eager
    overflowWrap: 'break-word'
  }
};

const headingClassList = new ClassList('Heading');
function useHeadingStyles(t0) {
  const $ = c(19);
  let size;
  let align;
  let otherProps;
  let UNSAFE_className;
  if ($[0] !== t0) {
    ({
      align,
      size,
      UNSAFE_className,
      ...otherProps
    } = t0);
    $[0] = t0;
    $[1] = size;
    $[2] = align;
    $[3] = otherProps;
    $[4] = UNSAFE_className;
  } else {
    size = $[1];
    align = $[2];
    otherProps = $[3];
    UNSAFE_className = $[4];
  }
  const fontDefinition = tokenSchema.typography.heading[size];
  let t1;
  let t2;
  let t3;
  if ($[5] !== fontDefinition || $[6] !== size || $[7] !== align || $[8] !== otherProps) {
    const trimStyles = getTrimStyles(fontDefinition);
    const styles = [{
      color: tokenSchema.color.foreground.neutralEmphasis,
      fontSize: fontDefinition.size,
      fontFamily: tokenSchema.typography.fontFamily.base,
      fontWeight: sizeToWeight[size],
      textAlign: align
    }, textOptimizationStyles, trimStyles];
    t3 = useStyleProps;
    t2 = otherProps;
    t1 = css(styles);
    $[5] = fontDefinition;
    $[6] = size;
    $[7] = align;
    $[8] = otherProps;
    $[9] = t1;
    $[10] = t2;
    $[11] = t3;
  } else {
    t1 = $[9];
    t2 = $[10];
    t3 = $[11];
  }
  let t4;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = headingClassList.element("root");
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  let t5;
  if ($[13] !== t1 || $[14] !== UNSAFE_className) {
    t5 = [t1, UNSAFE_className, t4];
    $[13] = t1;
    $[14] = UNSAFE_className;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== t2 || $[17] !== t5) {
    t6 = {
      ...t2,
      UNSAFE_className: t5
    };
    $[16] = t2;
    $[17] = t5;
    $[18] = t6;
  } else {
    t6 = $[18];
  }
  return t3(t6);
}
const sizeToWeight = {
  small: tokenSchema.typography.fontWeight.semibold,
  regular: tokenSchema.typography.fontWeight.bold,
  medium: tokenSchema.typography.fontWeight.medium,
  large: tokenSchema.typography.fontWeight.bold
};

/** @private Truncate text with an ellipsis after the specified number of lines */
function Truncate(t0) {
  const $ = c(11);
  let lines;
  let title;
  let props;
  if ($[0] !== t0) {
    ({
      lines,
      title,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = lines;
    $[2] = title;
    $[3] = props;
  } else {
    lines = $[1];
    title = $[2];
    props = $[3];
  }
  const className = useTruncateStyles(typeof lines === "boolean" ? 1 : lines);
  let t1;
  if ($[4] !== title || $[5] !== props) {
    var _title;
    t1 = (_title = title) !== null && _title !== void 0 ? _title : isReactText(props.children) ? props.children.toString() : undefined;
    $[4] = title;
    $[5] = props;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  let t2;
  if ($[7] !== className || $[8] !== t1 || $[9] !== props) {
    t2 = /*#__PURE__*/jsx("span", {
      className: className,
      title: t1,
      ...props
    });
    $[7] = className;
    $[8] = t1;
    $[9] = props;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  return t2;
}
function useTruncateStyles(lineClamp) {
  return css({
    display: '-webkit-box',
    WebkitLineClamp: lineClamp,
    textOverflow: 'ellipsis',
    WebkitBoxOrient: 'vertical',
    overflow: 'hidden'
  });
}

function useVisuallyHiddenRange(range) {
  const matchedBreakpoints = useResponsiveRange();
  const {
    visuallyHiddenProps
  } = useVisuallyHidden();
  if (range && matchedBreakpoints(range)) {
    return visuallyHiddenProps;
  }
}

const sizeToElement = {
  small: 'h4',
  regular: 'h3',
  medium: 'h2',
  large: 'h1'
};
const filterOptions$1 = {
  propNames: new Set(['aria-hidden'])
};

/** A typographic device used to communicate levels of hierarchy between text. */
const Heading = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, 'heading');
  const {
    children,
    size = 'regular',
    truncate,
    elementType: ElementType = sizeToElement[size],
    ...otherProps
  } = props;
  const styleProps = useHeadingStyles({
    size,
    ...props
  });
  const headingContext = useMemo(() => ({
    size
  }), [size]);
  const visuallyHiddenProps = useVisuallyHiddenRange(props.visuallyHidden);

  // element preparation
  const content = truncate ? /*#__PURE__*/jsx(Truncate, {
    lines: truncate,
    children: children
  }) : children;
  return /*#__PURE__*/jsx(HeadingContext.Provider, {
    value: headingContext,
    children: /*#__PURE__*/jsx(ElementType, {
      ref: ref,
      ...filterDOMProps(otherProps, filterOptions$1),
      ...styleProps,
      ...visuallyHiddenProps,
      children: content
    })
  });
});

const filterOptions = {
  propNames: new Set(['aria-hidden', 'role'])
};
const Text = forwardRefWithAs((props, forwardedRef) => {
  var _prevContext$color, _prevContext$size, _prevContext$weight;
  props = useSlotProps(props, 'text');
  const headingContext = useHeadingContext();
  const prevContext = useTextContext();
  validateProps$1(props, prevContext);

  // warn and bail if consumer tries to do something dodgy
  warning(!headingContext, 'The `Text` component is not supported within `Heading` components.');
  if (headingContext) {
    return /*#__PURE__*/jsx("span", {
      children: props.children
    });
  }
  const {
    children,
    color = (_prevContext$color = prevContext === null || prevContext === void 0 ? void 0 : prevContext.color) !== null && _prevContext$color !== void 0 ? _prevContext$color : 'neutral',
    elementType: ElementType = 'span',
    size = (_prevContext$size = prevContext === null || prevContext === void 0 ? void 0 : prevContext.size) !== null && _prevContext$size !== void 0 ? _prevContext$size : 'regular',
    trim = !prevContext,
    truncate,
    visuallyHidden,
    weight = (_prevContext$weight = prevContext === null || prevContext === void 0 ? void 0 : prevContext.weight) !== null && _prevContext$weight !== void 0 ? _prevContext$weight : 'regular',
    ...otherProps
  } = props;
  const styleProps = useTextStyles({
    color,
    size,
    trim,
    weight,
    ...otherProps
  });
  const visuallyHiddenProps = useVisuallyHiddenRange(visuallyHidden);

  // element preparation
  const content = truncate ? /*#__PURE__*/jsx(Truncate, {
    lines: truncate,
    children: children
  }) : children;
  const element = /*#__PURE__*/jsx(ElementType, {
    ref: forwardedRef,
    ...filterDOMProps(otherProps, filterOptions),
    ...styleProps,
    ...visuallyHiddenProps,
    children: content
  });

  // avoid unnecessary re-renders
  const nextContext = useMemo(() => ({
    size,
    color,
    weight
  }), [size, color, weight]);

  // avoid nested providers
  if (prevContext || visuallyHidden) {
    return element;
  }
  return /*#__PURE__*/jsx(TextContext.Provider, {
    value: nextContext,
    children: element
  });
});
function validateProps$1(props, context) {
  assert(!context || !props.align, 'The "align" prop is unsupported on nested Text.');
  assert(!context || !props.trim, 'The "trim" prop is unsupported on nested Text.');
}

/**
 * A utility component for displaying emoji characters accessibly. Emojis can
 * add playfulness to your interface, but require formatting to ensure that they
 * are accessible for all users.
 */
const Emoji = /*#__PURE__*/forwardRef(function Emoji(props, forwardedRef) {
  const $ = c(13);
  let otherProps;
  let label;
  let symbol;
  if ($[0] !== props) {
    ({
      label,
      symbol,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = label;
    $[3] = symbol;
  } else {
    otherProps = $[1];
    label = $[2];
    symbol = $[3];
  }
  const styleProps = useStyleProps(otherProps);
  const t0 = label ? undefined : true;
  let t1;
  if ($[4] !== otherProps) {
    t1 = filterDOMProps(otherProps);
    $[4] = otherProps;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== t0 || $[7] !== label || $[8] !== forwardedRef || $[9] !== styleProps || $[10] !== t1 || $[11] !== symbol) {
    t2 = /*#__PURE__*/jsx("span", {
      "aria-hidden": t0,
      "aria-label": label,
      ref: forwardedRef,
      role: "img",
      ...styleProps,
      ...t1,
      children: symbol
    });
    $[6] = t0;
    $[7] = label;
    $[8] = forwardedRef;
    $[9] = styleProps;
    $[10] = t1;
    $[11] = symbol;
    $[12] = t2;
  } else {
    t2 = $[12];
  }
  return t2;
});

function noopSubscribe() {
  return () => {};
}
function useIsMac() {
  const $ = c(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => false;
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return useSyncExternalStore(noopSubscribe, isMac, t0);
}
/** Represents text that specifies a keyboard command. */
const Kbd = /*#__PURE__*/forwardRef(function Kbd(props, forwardedRef) {
  const $ = c(25);
  props = useSlotProps(props, "kbd");
  let otherProps;
  let alt;
  let meta;
  let shift;
  let children;
  if ($[0] !== props) {
    ({
      alt,
      meta,
      shift,
      children,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = alt;
    $[3] = meta;
    $[4] = shift;
    $[5] = children;
  } else {
    otherProps = $[1];
    alt = $[2];
    meta = $[3];
    shift = $[4];
    children = $[5];
  }
  let t0;
  if ($[6] !== otherProps) {
    t0 = {
      casing: "full-width",
      color: "neutral",
      size: "regular",
      weight: "regular",
      ...otherProps
    };
    $[6] = otherProps;
    $[7] = t0;
  } else {
    t0 = $[7];
  }
  const styleProps = useTextStyles(t0);
  const isMac = useIsMac();
  let t1;
  let t2;
  if ($[8] !== isMac) {
    t2 = isMac ? {
      alt: "\u2325",
      meta: "\u2318",
      shift: "\u21E7"
    } : {
      alt: "Alt",
      meta: "Ctrl",
      shift: "Shift"
    };
    $[8] = isMac;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  const SYSTEM_KEYS = t2;
  const t3 = alt && SYSTEM_KEYS.alt;
  const t4 = shift && SYSTEM_KEYS.shift;
  const t5 = meta && SYSTEM_KEYS.meta;
  let t6;
  if ($[10] !== t3 || $[11] !== t4 || $[12] !== t5 || $[13] !== isMac) {
    const keys = [t3, t4, t5].filter(Boolean);
    t6 = joinModifierKeys(keys, isMac);
    $[10] = t3;
    $[11] = t4;
    $[12] = t5;
    $[13] = isMac;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  t1 = t6;
  const modifiers = t1;
  let t7;
  if ($[15] !== otherProps) {
    t7 = filterDOMProps(otherProps);
    $[15] = otherProps;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  let t8;
  if ($[17] !== children) {
    t8 = /*#__PURE__*/jsx(Char, {
      children: children
    });
    $[17] = children;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] !== t7 || $[20] !== styleProps || $[21] !== forwardedRef || $[22] !== modifiers || $[23] !== t8) {
    t9 = /*#__PURE__*/jsxs("kbd", {
      ...t7,
      ...styleProps,
      dir: "ltr",
      ref: forwardedRef,
      children: [modifiers, t8]
    });
    $[19] = t7;
    $[20] = styleProps;
    $[21] = forwardedRef;
    $[22] = modifiers;
    $[23] = t8;
    $[24] = t9;
  } else {
    t9 = $[24];
  }
  return t9;
});

/**
 * NOTE: The 'full-width' text-transform has limited support.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform#browser_compatibility
 * This hack ensures that single character shortcuts are visually aligned when
 * stacked, like when end-aligned in menu items, without needing to use a
 * monospace font.
 */
function Char(props) {
  const $ = c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      display: "inline-block",
      minWidth: "1em",
      textAlign: "center"
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /*#__PURE__*/jsx("span", {
      className: t0,
      ...props
    });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
}
function joinModifierKeys(modifiers, isMac) {
  if (modifiers.length === 0) {
    return '';
  }
  let delimiter = isMac ? '' : '+';
  return modifiers.join(delimiter) + delimiter;
}

const Numeral = /*#__PURE__*/forwardRef(function Numeral(props, forwardedRef) {
  const $ = c(15);
  props = useDerivedProps(props);
  validateProps(props);
  let t0;
  if ($[0] !== props) {
    t0 = optionsByFormat(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const formatter = useNumberFormatter(t0);
  let value;
  let textProps;
  if ($[2] !== props) {
    const {
      abbreviate,
      format,
      value: t1,
      ...t2
    } = props;
    value = t1;
    textProps = t2;
    $[2] = props;
    $[3] = value;
    $[4] = textProps;
  } else {
    value = $[3];
    textProps = $[4];
  }
  const headingContext = useHeadingContext();
  let t1;
  if ($[5] !== formatter || $[6] !== value) {
    t1 = formatter.format(value);
    $[5] = formatter;
    $[6] = value;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const formattedText = t1;
  if (headingContext) {
    let t2;
    if ($[8] !== forwardedRef || $[9] !== formattedText) {
      t2 = /*#__PURE__*/jsx("span", {
        ref: forwardedRef,
        children: formattedText
      });
      $[8] = forwardedRef;
      $[9] = formattedText;
      $[10] = t2;
    } else {
      t2 = $[10];
    }
    return t2;
  }
  let t2;
  if ($[11] !== forwardedRef || $[12] !== textProps || $[13] !== formattedText) {
    t2 = /*#__PURE__*/jsx(Text, {
      ref: forwardedRef,
      ...textProps,
      children: formattedText
    });
    $[11] = forwardedRef;
    $[12] = textProps;
    $[13] = formattedText;
    $[14] = t2;
  } else {
    t2 = $[14];
  }
  return t2;
});

// Utils
// ----------------------------------------------------------------------------

function getFormat(props) {
  const {
    format,
    currency,
    unit
  } = props;
  if (format) {
    return format;
  }
  if (currency) {
    return 'currency';
  }
  if (unit) {
    return 'unit';
  }
  return 'decimal';
}
function useDerivedProps(props) {
  return {
    ...props,
    format: getFormat(props)
  };
}
function toFractionDigits(precision) {
  return Array.isArray(precision) ? precision : [precision, precision];
}
function optionsByFormat(props) {
  const {
    abbreviate,
    format,
    precision,
    currency,
    unit
  } = props;
  const notation = abbreviate ? 'compact' : undefined;
  const [minimumFractionDigits, maximumFractionDigits] = toFractionDigits(precision);
  const common = {
    maximumFractionDigits,
    minimumFractionDigits,
    notation,
    compactDisplay: abbreviate === 'long' ? 'long' : 'short'
  };
  switch (format) {
    case 'currency':
      return {
        ...common,
        style: 'currency',
        currency,
        currencyDisplay: 'narrowSymbol'
      };
    case 'percent':
      return {
        ...common,
        style: 'percent'
      };
    case 'unit':
      return {
        ...common,
        style: 'unit',
        unit,
        unitDisplay: 'narrow'
      };
    default:
      return common;
  }
}
function validateProps(props) {
  const {
    format,
    currency,
    precision,
    unit
  } = props;
  assert(currency ? format === 'currency' : true, 'When format is "currency", the currency property must be provided.');
  assert(unit ? format === 'unit' : true, 'When format is "unit", the unit property must be provided.');
  assert(!(currency && unit), 'Formatting of "currency" and "unit" cannot be combined.');
  if (precision) {
    assert(Array.isArray(precision) ? precision.every(isInteger) : isInteger(precision), 'Precision must be an integer, or an integer tuple for min/max.');
  }
}

/** A typographic component that adds styles for rendering remote HTML content. */
const Prose = forwardRefWithAs((props, ref) => {
  const {
    children,
    elementType: ElementType = 'div',
    ...otherProps
  } = props;
  const styleProps = useProseStyleProps(otherProps);
  return /*#__PURE__*/jsx(ElementType, {
    ref: ref,
    ...filterStyleProps(otherProps),
    ...styleProps,
    children: children
  });
});
function useProseStyleProps(props) {
  const $ = c(11);
  let t0;
  let otherProps;
  if ($[0] !== props) {
    ({
      size: t0,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = otherProps;
  } else {
    t0 = $[1];
    otherProps = $[2];
  }
  const size = t0 === undefined ? "medium" : t0;
  const styleProps = useStyleProps(otherProps);
  let t1;
  if ($[3] !== size) {
    t1 = toDataAttributes({
      size
    });
    $[3] = size;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== styleProps.className) {
    t2 = classNames(css({
      color: tokenSchema.color.foreground.neutral,
      fontFamily: tokenSchema.typography.fontFamily.base,
      height: "100%",
      maxWidth: "100%",
      minHeight: 0,
      minWidth: 0,
      position: "relative",
      overflowWrap: "break-word",
      whiteSpace: "break-spaces",
      fontVariantLigatures: "none",
      fontFeatureSettings: "\"liga\" 0",
      MozOsxFontSmoothing: "auto",
      WebkitFontSmoothing: "auto",
      "&[data-size=\"small\"]": {
        fontSize: tokenSchema.typography.text.small.size,
        lineHeight: 1.6
      },
      "&[data-size=\"regular\"]": {
        fontSize: tokenSchema.typography.text.regular.size,
        lineHeight: 1.5
      },
      "&[data-size=\"medium\"]": {
        fontSize: tokenSchema.typography.text.medium.size,
        lineHeight: 1.5
      },
      "&[data-size=\"large\"]": {
        fontSize: tokenSchema.typography.text.large.size,
        lineHeight: 1.4
      },
      "& :is(blockquote, p, pre, ol, ul, table)": {
        marginBlock: "0.75em",
        ":first-child": {
          marginTop: 0
        },
        ":last-child": {
          marginBottom: 0
        }
      },
      "ol, ul": {
        paddingInlineStart: "1em"
      },
      "ol ol, ul ul, ol ul, ul ol": {
        marginBlock: 0
      },
      "li :is(blockquote, p, pre, ol, ul, table)": {
        marginBottom: 0
      },
      blockquote: {
        borderInlineStart: `${tokenSchema.size.border.large} solid ${tokenSchema.color.foreground.neutral}`,
        marginInline: 0,
        paddingInlineStart: "1em"
      },
      hr: {
        backgroundColor: tokenSchema.color.alias.borderIdle,
        border: 0,
        borderRadius: tokenSchema.size.border.medium,
        height: tokenSchema.size.border.medium,
        marginBlock: "1.5em"
      },
      img: {
        height: "auto",
        maxWidth: "100%"
      },
      strong: {
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      a: {
        color: tokenSchema.color.foreground.accent
      },
      pre: {
        backgroundColor: tokenSchema.color.background.surface,
        borderRadius: tokenSchema.size.radius.medium,
        color: tokenSchema.color.foreground.neutralEmphasis,
        fontFamily: tokenSchema.typography.fontFamily.code,
        fontSize: "0.85em",
        lineHeight: tokenSchema.typography.lineheight.medium,
        minWidth: 0,
        maxWidth: "100%",
        overflow: "auto",
        padding: tokenSchema.size.space.medium,
        whiteSpace: "pre-wrap"
      },
      "pre > code": {
        fontFamily: "inherit"
      },
      "& :not(pre) > code": {
        backgroundColor: tokenSchema.color.background.accent,
        borderRadius: tokenSchema.size.radius.small,
        color: tokenSchema.color.foreground.neutralEmphasis,
        display: "inline-block",
        fontSize: "0.85em",
        fontFamily: tokenSchema.typography.fontFamily.code,
        paddingInline: tokenSchema.size.space.small
      },
      "& :is(h1, h2, h3, h4, h5, h6)": {
        color: tokenSchema.color.foreground.neutralEmphasis,
        lineHeight: 1.25,
        marginTop: "1.5em",
        marginBottom: "0.67em",
        ":first-child": {
          marginTop: 0
        },
        ":last-child": {
          marginBottom: 0
        }
      },
      h1: {
        fontSize: "2em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h2: {
        fontSize: "1.5em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h3: {
        fontSize: "1.25em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h4: {
        fontSize: "1.1em",
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      h5: {
        fontSize: "1em",
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      h6: {
        fontSize: "0.9em",
        fontWeight: tokenSchema.typography.fontWeight.semibold,
        letterSpacing: "0.0125em"
      },
      ...getListStyles()
    }), styleProps.className);
    $[5] = styleProps.className;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== styleProps || $[8] !== t1 || $[9] !== t2) {
    t3 = {
      ...styleProps,
      ...t1,
      className: t2
    };
    $[7] = styleProps;
    $[8] = t1;
    $[9] = t2;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  return t3;
}
function getListStyles() {
  let styles = {};
  let listDepth = 10;
  const orderedListStyles = ['lower-roman', 'decimal', 'lower-alpha'];
  const unorderedListStyles = ['square', 'disc', 'circle'];
  while (listDepth--) {
    let arr = Array.from({
      length: listDepth
    });
    if (arr.length) {
      styles[arr.map(() => `ol`).join(' ')] = {
        listStyle: orderedListStyles[listDepth % 3]
      };
      styles[arr.map(() => `ul`).join(' ')] = {
        listStyle: unorderedListStyles[listDepth % 3]
      };
    }
  }
  return styles;
}

export { Emoji, Heading, Kbd, Numeral, Prose, Text, headingClassList, textClassList, useHeadingContext, useProseStyleProps, useTextContext, useTextStyles };
