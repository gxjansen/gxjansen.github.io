'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useHover } from '@react-aria/interactions';
import { useSwitch } from '@react-aria/switch';
import { useToggleState } from '@react-stately/toggle';
import { forwardRef, useRef } from 'react';
import { useProviderProps } from '@keystar/ui/core';
import { SlotProvider } from '@keystar/ui/slots';
import { useStyleProps, css, tokenSchema, toDataAttributes, classNames, transition, FocusRing } from '@keystar/ui/style';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { jsx, jsxs } from 'react/jsx-runtime';

/**
 * Switches allow users to turn an individual option on or off.
 * They are usually used to activate or deactivate a specific setting.
 */
const Switch = /*#__PURE__*/forwardRef(function Switch(props, forwardedRef) {
  const $ = c(23);
  props = useProviderProps(props);
  let otherProps;
  let autoFocus;
  let children;
  if ($[0] !== props) {
    ({
      autoFocus,
      children,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = autoFocus;
    $[3] = children;
  } else {
    otherProps = $[1];
    autoFocus = $[2];
    children = $[3];
  }
  const inputRef = useRef(null);
  const state = useToggleState(props);
  const {
    inputProps
  } = useSwitch(props, state, inputRef);
  const styleProps = useSwitchStyles(otherProps);
  let t0;
  let t1;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      text: {
        color: "inherit"
      },
      description: {
        color: "neutralTertiary"
      }
    };
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  t0 = t1;
  const slots = t0;
  let t2;
  if ($[5] !== styleProps.input || $[6] !== inputProps || $[7] !== inputRef) {
    t2 = /*#__PURE__*/jsx("input", {
      ...styleProps.input,
      ...inputProps,
      ref: inputRef
    });
    $[5] = styleProps.input;
    $[6] = inputProps;
    $[7] = inputRef;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== autoFocus || $[10] !== t2) {
    t3 = /*#__PURE__*/jsx(FocusRing, {
      autoFocus: autoFocus,
      children: t2
    });
    $[9] = autoFocus;
    $[10] = t2;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  let t4;
  if ($[12] !== styleProps.indicator) {
    t4 = /*#__PURE__*/jsx("span", {
      ...styleProps.indicator
    });
    $[12] = styleProps.indicator;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== children || $[15] !== styleProps) {
    t5 = children && /*#__PURE__*/jsx(SlotProvider, {
      slots: slots,
      children: /*#__PURE__*/jsx("span", {
        ...styleProps.content,
        children: isReactText(children) ? /*#__PURE__*/jsx(Text, {
          children: children
        }) : children
      })
    });
    $[14] = children;
    $[15] = styleProps;
    $[16] = t5;
  } else {
    t5 = $[16];
  }
  let t6;
  if ($[17] !== styleProps.label || $[18] !== forwardedRef || $[19] !== t3 || $[20] !== t4 || $[21] !== t5) {
    t6 = /*#__PURE__*/jsxs("label", {
      ...styleProps.label,
      ref: forwardedRef,
      children: [t3, t4, t5]
    });
    $[17] = styleProps.label;
    $[18] = forwardedRef;
    $[19] = t3;
    $[20] = t4;
    $[21] = t5;
    $[22] = t6;
  } else {
    t6 = $[22];
  }
  return t6;
});
function useSwitchStyles(props) {
  let {
    isDisabled = false,
    prominence,
    size,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let {
    hoverProps,
    isHovered
  } = useHover({
    isDisabled
  });
  let labelClassName = css({
    alignItems: 'flex-start',
    display: 'inline-flex',
    gap: tokenSchema.size.space.regular,
    position: 'relative',
    userSelect: 'none',
    '--track-background-color': tokenSchema.color.background.accentEmphasis,
    '--track-height': tokenSchema.size.element.small,
    '--track-width': tokenSchema.size.element.large,
    '&[data-size="small"]': {
      '--track-height': tokenSchema.size.element.xsmall,
      '--track-width': tokenSchema.size.element.regular
    },
    '&[data-prominence="low"]': {
      '--track-background-color': tokenSchema.color.background.inverse
    }
  });
  let labelStyleProps = {
    ...styleProps,
    ...hoverProps,
    ...toDataAttributes({
      disabled: isDisabled || undefined,
      hovered: isHovered || undefined,
      prominence,
      size
    }),
    className: classNames(labelClassName, styleProps.className)
  };
  let inputStyleProps = {
    className: css({
      position: 'absolute',
      zIndex: 1,
      inset: `calc(${tokenSchema.size.space.regular} * -1)`,
      // expand hit area
      opacity: 0.0001
    })
  };
  let contentStyleProps = {
    className: css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: 'grid',
      paddingTop: `calc((var(--track-height) - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      gap: tokenSchema.size.space.large,
      [`.${inputStyleProps.className}:hover ~ &`]: {
        color: tokenSchema.color.alias.foregroundHovered
      },
      [`.${inputStyleProps.className}:disabled ~ &`]: {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    })
  };
  let indicatorStyleProps = {
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.surfaceTertiary,
      borderRadius: tokenSchema.size.radius.full,
      display: 'inline-block',
      flexShrink: 0,
      height: 'var(--track-height)',
      position: 'relative',
      transition: transition('background-color'),
      width: 'var(--track-width)',
      willChange: 'transform',
      // focus ring
      '::after': {
        borderRadius: tokenSchema.size.radius.full,
        content: '""',
        inset: 0,
        margin: 0,
        position: 'absolute',
        transition: transition(['box-shadow', 'margin'], {
          easing: 'easeOut'
        })
      },
      [`.${inputStyleProps.className}[data-focus=visible] + &::after`]: {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // handle
      '&::before': {
        backgroundColor: tokenSchema.color.background.canvas,
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.alias.borderIdle}`,
        borderRadius: `inherit`,
        boxSizing: 'border-box',
        content: '""',
        inlineSize: 'var(--track-height)',
        blockSize: 'var(--track-height)',
        insetBlockStart: 0,
        insetInlineStart: 0,
        margin: 0,
        position: 'absolute',
        transition: transition(['border-color', 'transform'])
      },
      [`.${inputStyleProps.className}:hover + &::before`]: {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      [`.${inputStyleProps.className}:active + &::before`]: {
        borderColor: tokenSchema.color.alias.borderPressed
      },
      // checked state
      [`.${inputStyleProps.className}:checked + &`]: {
        backgroundColor: 'var(--track-background-color)',
        '&::before': {
          borderColor: 'var(--track-background-color)'
        },
        '[dir=ltr] &::before': {
          transform: `translateX(calc(var(--track-width) - 100%))`
        },
        '[dir=rtl] &::before': {
          transform: `translateX(calc(100% - var(--track-width)))`
        }
      },
      // disabled state
      [`.${inputStyleProps.className}:disabled + &`]: {
        backgroundColor: tokenSchema.color.alias.backgroundDisabled,
        '&::before': {
          backgroundColor: tokenSchema.color.alias.borderIdle,
          borderColor: tokenSchema.color.alias.backgroundDisabled
        }
      },
      [`.${inputStyleProps.className}:disabled:checked + &`]: {
        backgroundColor: tokenSchema.color.alias.borderIdle,
        '&::before': {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          borderColor: tokenSchema.color.alias.borderIdle
        }
      }
    }))
  };
  return {
    content: contentStyleProps,
    indicator: indicatorStyleProps,
    input: inputStyleProps,
    label: labelStyleProps
  };
}

export { Switch };
