'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useRadio, useRadioGroup } from '@react-aria/radio';
import React, { useRef, forwardRef } from 'react';
import { SlotProvider } from '@keystar/ui/slots';
import { ClassList, tokenSchema, useStyleProps, css, classNames, FocusRing, transition, resetClassName, toDataAttributes } from '@keystar/ui/style';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useRadioGroupState } from '@react-stately/radio';
import { useProviderProps } from '@keystar/ui/core';
import { validateFieldProps, FieldPrimitive } from '@keystar/ui/field';

const RadioContext = /*#__PURE__*/React.createContext(null);
function useRadioProvider() {
  const context = React.useContext(RadioContext);
  if (!context) {
    throw new Error("useRadioProvider must be used within a RadioGroupProvider");
  }
  return context;
}

const radioClassList = new ClassList('Radio', ['indicator']);
function Radio(props) {
  const $ = c(46);
  let otherProps;
  let autoFocus;
  let children;
  if ($[0] !== props) {
    ({
      children,
      autoFocus,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = otherProps;
    $[2] = autoFocus;
    $[3] = children;
  } else {
    otherProps = $[1];
    autoFocus = $[2];
    children = $[3];
  }
  const styleProps = useStyleProps(otherProps);
  const inputRef = useRef(null);
  const radioGroupProps = useRadioProvider();
  const {
    state
  } = radioGroupProps;
  let t0;
  if ($[4] !== props || $[5] !== radioGroupProps) {
    t0 = {
      ...props,
      ...radioGroupProps
    };
    $[4] = props;
    $[5] = radioGroupProps;
    $[6] = t0;
  } else {
    t0 = $[6];
  }
  const {
    inputProps
  } = useRadio(t0, state, inputRef);
  let t1;
  let t2;
  let t3;
  let T0;
  let t4;
  let inputClassName;
  let slots;
  let t5;
  let t6;
  if ($[7] !== styleProps.className || $[8] !== styleProps.style || $[9] !== autoFocus || $[10] !== inputProps || $[11] !== inputRef) {
    inputClassName = css({
      position: "absolute",
      zIndex: 1,
      inset: 0,
      opacity: 0.0001
    });
    if ($[21] !== styleProps.className) {
      const labelClassName = css({
        alignItems: "flex-start",
        display: "inline-flex",
        gap: tokenSchema.size.space.regular,
        position: "relative",
        userSelect: "none"
      });
      let t7;
      let t8;
      if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
        t8 = {
          text: {
            color: "inherit"
          },
          description: {
            color: "neutralTertiary"
          }
        };
        $[24] = t8;
      } else {
        t8 = $[24];
      }
      t7 = t8;
      slots = t7;
      t5 = classNames(styleProps.className, labelClassName);
      $[21] = styleProps.className;
      $[22] = slots;
      $[23] = t5;
    } else {
      slots = $[22];
      t5 = $[23];
    }
    t6 = styleProps.style;
    T0 = FocusRing;
    t4 = autoFocus;
    t1 = inputProps;
    t2 = inputRef;
    t3 = classNames(inputClassName);
    $[7] = styleProps.className;
    $[8] = styleProps.style;
    $[9] = autoFocus;
    $[10] = inputProps;
    $[11] = inputRef;
    $[12] = t1;
    $[13] = t2;
    $[14] = t3;
    $[15] = T0;
    $[16] = t4;
    $[17] = inputClassName;
    $[18] = slots;
    $[19] = t5;
    $[20] = t6;
  } else {
    t1 = $[12];
    t2 = $[13];
    t3 = $[14];
    T0 = $[15];
    t4 = $[16];
    inputClassName = $[17];
    slots = $[18];
    t5 = $[19];
    t6 = $[20];
  }
  let t7;
  if ($[25] !== t1 || $[26] !== t2 || $[27] !== t3) {
    t7 = /*#__PURE__*/jsx("input", {
      ...t1,
      ref: t2,
      className: t3
    });
    $[25] = t1;
    $[26] = t2;
    $[27] = t3;
    $[28] = t7;
  } else {
    t7 = $[28];
  }
  let t8;
  if ($[29] !== T0 || $[30] !== t4 || $[31] !== t7) {
    t8 = /*#__PURE__*/jsx(T0, {
      autoFocus: t4,
      children: t7
    });
    $[29] = T0;
    $[30] = t4;
    $[31] = t7;
    $[32] = t8;
  } else {
    t8 = $[32];
  }
  let t9;
  if ($[33] !== inputClassName) {
    t9 = /*#__PURE__*/jsx(Indicator, {
      inputClassName: inputClassName
    });
    $[33] = inputClassName;
    $[34] = t9;
  } else {
    t9 = $[34];
  }
  let t10;
  if ($[35] !== children) {
    t10 = children && /*#__PURE__*/jsx(Content, {
      children: isReactText(children) ? /*#__PURE__*/jsx(Text, {
        children: children
      }) : children
    });
    $[35] = children;
    $[36] = t10;
  } else {
    t10 = $[36];
  }
  let t11;
  if ($[37] !== slots || $[38] !== t10) {
    t11 = /*#__PURE__*/jsx(SlotProvider, {
      slots: slots,
      children: t10
    });
    $[37] = slots;
    $[38] = t10;
    $[39] = t11;
  } else {
    t11 = $[39];
  }
  let t12;
  if ($[40] !== t5 || $[41] !== t6 || $[42] !== t8 || $[43] !== t9 || $[44] !== t11) {
    t12 = /*#__PURE__*/jsxs("label", {
      className: t5,
      style: t6,
      children: [t8, t9, t11]
    });
    $[40] = t5;
    $[41] = t6;
    $[42] = t8;
    $[43] = t9;
    $[44] = t11;
    $[45] = t12;
  } else {
    t12 = $[45];
  }
  return t12;
}

// Styled components
// -----------------------------------------------------------------------------

let sizeToken = tokenSchema.size.element.xsmall;
const Indicator = props => {
  let {
    inputClassName
  } = props;
  return /*#__PURE__*/jsx("span", {
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      borderRadius: tokenSchema.size.radius.full,
      color: tokenSchema.color.foreground.onEmphasis,
      display: 'flex',
      flexShrink: 0,
      justifyContent: 'center',
      alignItems: 'center',
      position: 'relative',
      height: sizeToken,
      width: sizeToken,
      // indicator icons
      [radioClassList.selector('indicator')]: {
        opacity: 0,
        transform: `scale(0) translate3d(0, 0, 0)`,
        transition: transition(['opacity', 'transform']),
        willChange: 'opacity, transform'
      },
      // focus ring
      '::after': {
        borderRadius: tokenSchema.size.radius.full,
        content: '""',
        inset: 0,
        margin: 0,
        position: 'absolute',
        transition: transition(['box-shadow', 'margin'], {
          easing: 'easeOut'
        })
      },
      [`.${inputClassName}[data-focus=visible] + &::after`]: {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // border / background
      '&::before': {
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.scale.slate8}`,
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        position: 'absolute',
        transition: transition(['border-color', 'border-width'], {
          duration: 'regular'
        })
      },
      [`.${inputClassName}:disabled + &`]: {
        color: tokenSchema.color.alias.foregroundDisabled,
        '&::before': {
          backgroundColor: tokenSchema.color.alias.borderDisabled,
          borderColor: tokenSchema.color.alias.borderDisabled
        }
      },
      [`.${inputClassName}:enabled:hover + &::before`]: {
        borderColor: tokenSchema.color.scale.slate9
      },
      [`.${inputClassName}:enabled:active + &::before`]: {
        borderColor: tokenSchema.color.scale.slate10
      },
      // checked states
      [`.${inputClassName}:checked + &`]: {
        '&::before': {
          borderWidth: `calc(${sizeToken} / 2)`
        },
        [radioClassList.selector('indicator')]: {
          opacity: 1,
          transform: `scale(1)`
        }
      },
      [`.${inputClassName}:enabled:checked + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo9
      },
      [`.${inputClassName}:enabled:checked:hover + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo10
      },
      [`.${inputClassName}:enabled:checked:active + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo11
      }
    })),
    children: /*#__PURE__*/jsx("span", {
      className: radioClassList.element('indicator'),
      children: /*#__PURE__*/jsx("svg", {
        className: resetClassName,
        fill: "currentColor",
        height: 12,
        viewBox: "0 0 24 24",
        width: 12,
        children: /*#__PURE__*/jsx("circle", {
          cx: "12",
          cy: "12",
          r: "6"
        })
      })
    })
  });
};
const Content = props => {
  const $ = c(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = classNames(css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: "grid",
      paddingTop: `calc((${sizeToken} - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      gap: tokenSchema.size.space.large,
      "input[type=\"radio\"]:hover ~ &": {
        color: tokenSchema.color.alias.foregroundHovered
      },
      "input[type=\"radio\"]:disabled ~ &": {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    }));
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = /*#__PURE__*/jsx("div", {
      className: t0,
      ...props
    });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  return t1;
};

/**
 * Radio groups allow users to select a single option from a list of mutually
 * exclusive options.
 */
const RadioGroup = /*#__PURE__*/forwardRef(function RadioGroup(props, forwardedRef) {
  const $ = c(22);
  props = useProviderProps(props);
  let t0;
  if ($[0] !== props) {
    t0 = validateFieldProps(props);
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  props = t0;
  const {
    validationState,
    children,
    orientation: t1
  } = props;
  const orientation = t1 === undefined ? "vertical" : t1;
  const state = useRadioGroupState(props);
  const {
    radioGroupProps,
    labelProps,
    descriptionProps,
    errorMessageProps
  } = useRadioGroup(props, state);
  let t2;
  if ($[2] !== orientation) {
    t2 = toDataAttributes({
      orientation
    });
    $[2] = orientation;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = classNames(css({
      display: "flex",
      gap: tokenSchema.size.space.large,
      "&[data-orientation=\"vertical\"]": {
        flexDirection: "column"
      }
    }));
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== validationState || $[6] !== state) {
    t4 = {
      validationState,
      state
    };
    $[5] = validationState;
    $[6] = state;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t4 || $[9] !== children) {
    t5 = /*#__PURE__*/jsx(RadioContext.Provider, {
      value: t4,
      children: children
    });
    $[8] = t4;
    $[9] = children;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== radioGroupProps || $[12] !== t2 || $[13] !== t5) {
    t6 = /*#__PURE__*/jsx("div", {
      ...radioGroupProps,
      ...t2,
      className: t3,
      children: t5
    });
    $[11] = radioGroupProps;
    $[12] = t2;
    $[13] = t5;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  let t7;
  if ($[15] !== props || $[16] !== forwardedRef || $[17] !== labelProps || $[18] !== descriptionProps || $[19] !== errorMessageProps || $[20] !== t6) {
    t7 = /*#__PURE__*/jsx(FieldPrimitive, {
      ...props,
      ref: forwardedRef,
      labelProps: labelProps,
      labelElementType: "span",
      descriptionProps: descriptionProps,
      errorMessageProps: errorMessageProps,
      children: t6
    });
    $[15] = props;
    $[16] = forwardedRef;
    $[17] = labelProps;
    $[18] = descriptionProps;
    $[19] = errorMessageProps;
    $[20] = t6;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  return t7;
});

export { Radio, RadioGroup };
