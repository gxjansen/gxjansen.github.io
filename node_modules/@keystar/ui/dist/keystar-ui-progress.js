'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useMeter } from '@react-aria/meter';
import { keyframes, useStyleProps, classNames, css, tokenSchema, toDataAttributes, transition } from '@keystar/ui/style';
import { forwardRef } from 'react';
import { clamp } from '@react-aria/utils';
import { warning } from 'emery';
import { Text } from '@keystar/ui/typography';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useProgressBar } from '@react-aria/progress';

/** @private Internal component shared between `Meter` and `ProgressBar`. */
const BarBase = /*#__PURE__*/forwardRef(function BarBase(props, forwardedRef) {
  var _isIndeterminate;
  const $ = c(42);
  let t0;
  let t1;
  let t2;
  let t3;
  let label;
  let otherProps;
  let isIndeterminate;
  let ariaLabel;
  let ariaLabelledby;
  let barClassName;
  let labelProps;
  let barProps;
  if ($[0] !== props) {
    ({
      value: t0,
      minValue: t1,
      maxValue: t2,
      label,
      barClassName,
      showValueLabel: t3,
      isIndeterminate,
      barProps,
      labelProps,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = t2;
    $[4] = t3;
    $[5] = label;
    $[6] = otherProps;
    $[7] = isIndeterminate;
    $[8] = ariaLabel;
    $[9] = ariaLabelledby;
    $[10] = barClassName;
    $[11] = labelProps;
    $[12] = barProps;
  } else {
    t0 = $[1];
    t1 = $[2];
    t2 = $[3];
    t3 = $[4];
    label = $[5];
    otherProps = $[6];
    isIndeterminate = $[7];
    ariaLabel = $[8];
    ariaLabelledby = $[9];
    barClassName = $[10];
    labelProps = $[11];
    barProps = $[12];
  }
  let value = t0 === undefined ? 0 : t0;
  const minValue = t1 === undefined ? 0 : t1;
  const maxValue = t2 === undefined ? 100 : t2;
  const showValueLabel = t3 === undefined ? !!label : t3;
  const styleProps = useStyleProps(otherProps);
  value = clamp(value, minValue, maxValue);
  let barStyle;
  if ($[13] !== isIndeterminate || $[14] !== value || $[15] !== minValue || $[16] !== maxValue) {
    barStyle = {};
    if (!isIndeterminate) {
      const percentage = (value - minValue) / (maxValue - minValue);
      barStyle.width = `${Math.round(percentage * 100)}%`;
    }
    $[13] = isIndeterminate;
    $[14] = value;
    $[15] = minValue;
    $[16] = maxValue;
    $[17] = barStyle;
  } else {
    barStyle = $[17];
  }
  warning(!!(label || ariaLabel || ariaLabelledby), "If you do not provide a visible label via children, you must specify an aria-label or aria-labelledby attribute for accessibility.");
  let t4;
  if ($[18] !== barClassName || $[19] !== styleProps.className) {
    t4 = classNames(css({
      "--bar-fill": tokenSchema.color.background.accentEmphasis,
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      flexFlow: "wrap",
      isolation: "isolate",
      justifyContent: "space-between",
      minWidth: 0,
      position: "relative",
      verticalAlign: "top",
      width: tokenSchema.size.alias.singleLineWidth
    }), barClassName, styleProps.className);
    $[18] = barClassName;
    $[19] = styleProps.className;
    $[20] = t4;
  } else {
    t4 = $[20];
  }
  let t5;
  if ($[21] !== label || $[22] !== labelProps) {
    t5 = label && /*#__PURE__*/jsx(Text, {
      ...labelProps,
      flex: true,
      children: label
    });
    $[21] = label;
    $[22] = labelProps;
    $[23] = t5;
  } else {
    t5 = $[23];
  }
  let t6;
  if ($[24] !== showValueLabel || $[25] !== barProps) {
    t6 = showValueLabel && barProps && /*#__PURE__*/jsx(Text, {
      flexShrink: 0,
      children: barProps["aria-valuetext"]
    });
    $[24] = showValueLabel;
    $[25] = barProps;
    $[26] = t6;
  } else {
    t6 = $[26];
  }
  let t7;
  if ($[27] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = css({
      backgroundColor: tokenSchema.color.border.muted,
      borderRadius: tokenSchema.size.radius.full,
      height: tokenSchema.size.space.regular,
      minWidth: 0,
      overflow: "hidden",
      width: "100%",
      zIndex: "1"
    });
    $[27] = t7;
  } else {
    t7 = $[27];
  }
  const t8 = (_isIndeterminate = isIndeterminate) !== null && _isIndeterminate !== void 0 ? _isIndeterminate : undefined;
  let t9;
  if ($[28] !== t8) {
    t9 = toDataAttributes({
      indeterminate: t8
    });
    $[28] = t8;
    $[29] = t9;
  } else {
    t9 = $[29];
  }
  let t10;
  if ($[30] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = css({
      backgroundColor: "var(--bar-fill)",
      height: tokenSchema.size.space.regular,
      transition: transition("width", {
        duration: "regular"
      }),
      "&[data-indeterminate]": {
        animation: `${indeterminateLoopLtr} ${tokenSchema.animation.duration.long} ${tokenSchema.animation.easing.easeInOut} infinite`,
        willChange: "transform",
        "[dir=rtl] &": {
          animationName: indeterminateLoopRtl
        }
      }
    });
    $[30] = t10;
  } else {
    t10 = $[30];
  }
  let t11;
  if ($[31] !== t9 || $[32] !== barStyle) {
    t11 = /*#__PURE__*/jsx("div", {
      className: t7,
      children: /*#__PURE__*/jsx("div", {
        ...t9,
        className: t10,
        style: barStyle
      })
    });
    $[31] = t9;
    $[32] = barStyle;
    $[33] = t11;
  } else {
    t11 = $[33];
  }
  let t12;
  if ($[34] !== barProps || $[35] !== styleProps || $[36] !== forwardedRef || $[37] !== t4 || $[38] !== t5 || $[39] !== t6 || $[40] !== t11) {
    t12 = /*#__PURE__*/jsxs("div", {
      ...barProps,
      ...styleProps,
      ref: forwardedRef,
      className: t4,
      children: [t5, t6, t11]
    });
    $[34] = barProps;
    $[35] = styleProps;
    $[36] = forwardedRef;
    $[37] = t4;
    $[38] = t5;
    $[39] = t6;
    $[40] = t11;
    $[41] = t12;
  } else {
    t12 = $[41];
  }
  return t12;
});
const indeterminateLoopLtr = keyframes({
  from: {
    transform: 'translate(-100%)'
  },
  to: {
    transform: 'translate(100%)'
  }
});
const indeterminateLoopRtl = keyframes({
  from: {
    transform: 'translate(100%)'
  },
  to: {
    transform: 'translate(-100%)'
  }
});

/**
 * Meters are visual representations of a quantity or an achievement. Their
 * progress is determined by user actions, rather than system actions.
 */
const Meter = /*#__PURE__*/forwardRef(function Meter(props, forwardedRef) {
  const $ = c(14);
  let tone;
  let otherProps;
  if ($[0] !== props) {
    ({
      tone,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = tone;
    $[2] = otherProps;
  } else {
    tone = $[1];
    otherProps = $[2];
  }
  const {
    meterProps,
    labelProps
  } = useMeter(props);
  let t0;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = css({
      "&[data-tone=\"positive\"]": {
        "--bar-fill": tokenSchema.color.background.positiveEmphasis
      },
      "&[data-tone=\"caution\"]": {
        "--bar-fill": tokenSchema.color.background.cautionEmphasis
      },
      "&[data-tone=\"critical\"]": {
        "--bar-fill": tokenSchema.color.background.criticalEmphasis
      }
    });
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  let t1;
  if ($[4] !== tone) {
    t1 = toDataAttributes({
      tone
    });
    $[4] = tone;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== meterProps || $[7] !== t1) {
    t2 = {
      ...meterProps,
      ...t1
    };
    $[6] = meterProps;
    $[7] = t1;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== otherProps || $[10] !== forwardedRef || $[11] !== t2 || $[12] !== labelProps) {
    t3 = /*#__PURE__*/jsx(BarBase, {
      ...otherProps,
      ref: forwardedRef,
      barClassName: t0,
      barProps: t2,
      labelProps: labelProps
    });
    $[9] = otherProps;
    $[10] = forwardedRef;
    $[11] = t2;
    $[12] = labelProps;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  return t3;
});

/**
 * ProgressBars show the progression of a system operation: downloading, uploading, processing, etc., in a visual way.
 * They can represent either determinate or indeterminate progress.
 */
const ProgressBar = /*#__PURE__*/forwardRef(function ProgressBar(props, forwardedRef) {
  const $ = c(5);
  const {
    progressBarProps,
    labelProps
  } = useProgressBar(props);
  let t0;
  if ($[0] !== props || $[1] !== forwardedRef || $[2] !== progressBarProps || $[3] !== labelProps) {
    t0 = /*#__PURE__*/jsx(BarBase, {
      ...props,
      ref: forwardedRef,
      barProps: progressBarProps,
      labelProps: labelProps
    });
    $[0] = props;
    $[1] = forwardedRef;
    $[2] = progressBarProps;
    $[3] = labelProps;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
});

/**
 * Progress circles show the progression of a system operation such as
 * downloading, uploading, processing, etc. in a visual way. They can represent
 * determinate or indeterminate progress.
 */
const ProgressCircle = /*#__PURE__*/forwardRef(function ProgressCircle(props, forwardRef) {
  var _isIndeterminate, _isIndeterminate2, _isIndeterminate3;
  const $ = c(40);
  let t0;
  let t1;
  let t2;
  let t3;
  let otherProps;
  let ariaLabel;
  let ariaLabelledby;
  let isIndeterminate;
  if ($[0] !== props) {
    ({
      value: t0,
      minValue: t1,
      maxValue: t2,
      size: t3,
      isIndeterminate,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = t1;
    $[3] = t2;
    $[4] = t3;
    $[5] = otherProps;
    $[6] = ariaLabel;
    $[7] = ariaLabelledby;
    $[8] = isIndeterminate;
  } else {
    t0 = $[1];
    t1 = $[2];
    t2 = $[3];
    t3 = $[4];
    otherProps = $[5];
    ariaLabel = $[6];
    ariaLabelledby = $[7];
    isIndeterminate = $[8];
  }
  let value = t0 === undefined ? 0 : t0;
  const minValue = t1 === undefined ? 0 : t1;
  const maxValue = t2 === undefined ? 100 : t2;
  const size = t3 === undefined ? "medium" : t3;
  value = clamp(value, minValue, maxValue);
  let t4;
  if ($[9] !== props || $[10] !== value) {
    t4 = {
      ...props,
      value
    };
    $[9] = props;
    $[10] = value;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  const {
    progressBarProps
  } = useProgressBar(t4);
  const styleProps = useStyleProps(otherProps);
  warning(!!(ariaLabel || ariaLabelledby), "ProgressCircle requires an aria-label or aria-labelledby attribute for accessibility.");
  const t5 = (_isIndeterminate = isIndeterminate) !== null && _isIndeterminate !== void 0 ? _isIndeterminate : undefined;
  const t6 = size === "medium" ? undefined : size;
  let t7;
  if ($[12] !== t5 || $[13] !== t6) {
    t7 = toDataAttributes({
      indeterminate: t5,
      size: t6
    });
    $[12] = t5;
    $[13] = t6;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] !== styleProps.className) {
    t8 = classNames(css({
      height: "var(--diameter)",
      width: "var(--diameter)",
      "--diameter": tokenSchema.size.element.regular,
      "--radius": "calc(var(--diameter) / 2)",
      "--stroke-width": tokenSchema.size.scale[40],
      "--offset-radius": "calc(var(--radius) - var(--stroke-width) / 2)",
      "--circumference": `calc(var(--offset-radius) * pi * 2)`,
      "&[data-size=small]": {
        "--diameter": tokenSchema.size.element.xsmall,
        "--stroke-width": tokenSchema.size.border.medium
      },
      "&[data-size=large]": {
        "--diameter": tokenSchema.size.element.xlarge,
        "--stroke-width": tokenSchema.size.border.large
      }
    }), styleProps.className);
    $[15] = styleProps.className;
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  const t9 = (value - minValue) / (maxValue - minValue);
  let t10;
  if ($[17] !== t9 || $[18] !== styleProps.style) {
    t10 = {
      "--percent": t9,
      ...styleProps.style
    };
    $[17] = t9;
    $[18] = styleProps.style;
    $[19] = t10;
  } else {
    t10 = $[19];
  }
  const t11 = (_isIndeterminate2 = isIndeterminate) !== null && _isIndeterminate2 !== void 0 ? _isIndeterminate2 : undefined;
  let t12;
  if ($[20] !== t11) {
    t12 = toDataAttributes({
      indeterminate: t11
    });
    $[20] = t11;
    $[21] = t12;
  } else {
    t12 = $[21];
  }
  let t13;
  if ($[22] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = css({
      height: "var(--diameter)",
      width: "var(--diameter)",
      "&[data-indeterminate]": {
        animation: `${rotateAnimation} ${tokenSchema.animation.duration.xlong} linear infinite`
      }
    });
    $[22] = t13;
  } else {
    t13 = $[22];
  }
  let t14;
  if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = /*#__PURE__*/jsx("circle", {
      className: circle({
        stroke: tokenSchema.color.border.muted
      })
    });
    $[23] = t14;
  } else {
    t14 = $[23];
  }
  const t15 = (_isIndeterminate3 = isIndeterminate) !== null && _isIndeterminate3 !== void 0 ? _isIndeterminate3 : undefined;
  let t16;
  if ($[24] !== t15) {
    t16 = toDataAttributes({
      indeterminate: t15
    });
    $[24] = t15;
    $[25] = t16;
  } else {
    t16 = $[25];
  }
  let t17;
  if ($[26] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = circle({
      stroke: tokenSchema.color.background.accentEmphasis,
      strokeDasharray: "var(--circumference)",
      strokeLinecap: "round",
      "&:not([data-indeterminate])": {
        strokeDashoffset: `calc(var(--circumference) - var(--percent) * var(--circumference))`,
        transition: transition("stroke-dashoffset", {
          duration: "regular"
        }),
        transform: "rotate(-90deg)",
        transformOrigin: "center"
      },
      "&[data-indeterminate]": {
        animation: `${dashAnimation} ${tokenSchema.animation.duration.xlong} ${tokenSchema.animation.easing.easeInOut} infinite`
      }
    });
    $[26] = t17;
  } else {
    t17 = $[26];
  }
  let t18;
  if ($[27] !== t16) {
    t18 = /*#__PURE__*/jsx("circle", {
      ...t16,
      className: t17
    });
    $[27] = t16;
    $[28] = t18;
  } else {
    t18 = $[28];
  }
  let t19;
  if ($[29] !== t12 || $[30] !== t18) {
    t19 = /*#__PURE__*/jsxs("svg", {
      ...t12,
      role: "presentation",
      tabIndex: -1,
      className: t13,
      children: [t14, t18]
    });
    $[29] = t12;
    $[30] = t18;
    $[31] = t19;
  } else {
    t19 = $[31];
  }
  let t20;
  if ($[32] !== styleProps || $[33] !== progressBarProps || $[34] !== forwardRef || $[35] !== t7 || $[36] !== t8 || $[37] !== t10 || $[38] !== t19) {
    t20 = /*#__PURE__*/jsx("div", {
      ...styleProps,
      ...progressBarProps,
      ref: forwardRef,
      ...t7,
      className: t8,
      style: t10,
      children: t19
    });
    $[32] = styleProps;
    $[33] = progressBarProps;
    $[34] = forwardRef;
    $[35] = t7;
    $[36] = t8;
    $[37] = t10;
    $[38] = t19;
    $[39] = t20;
  } else {
    t20 = $[39];
  }
  return t20;
});

// Utils
// -----------------------------------------------------------------------------

function circle(styles) {
  return css([{
    cx: 'var(--radius)',
    cy: 'var(--radius)',
    r: 'var(--offset-radius)',
    fill: 'transparent',
    strokeWidth: 'var(--stroke-width)'
  }, styles]);
}
const rotateAnimation = keyframes({
  from: {
    transform: 'rotate(0deg)'
  },
  to: {
    transform: 'rotate(360deg)'
  }
});
const dashAnimation = keyframes({
  from: {
    strokeDashoffset: 'calc(var(--circumference) * 1.25)'
  },
  to: {
    strokeDashoffset: 'calc(var(--circumference) * -0.75)'
  }
});

export { Meter, ProgressBar, ProgressCircle };
