import { c } from './react-compiler-runtime-0011f46e.js';
import React, { useMemo, useCallback, useState, useRef, useEffect, createContext, useContext, memo, useSyncExternalStore, Suspense, useDeferredValue } from 'react';
import { Button, ActionButton, ButtonGroup } from '@keystar/ui/button';
import { Icon } from '@keystar/ui/icon';
import { fileX2Icon } from '@keystar/ui/icon/icons/fileX2Icon';
import { githubIcon } from '@keystar/ui/icon/icons/githubIcon';
import { Flex, HStack, Box, Divider, VStack } from '@keystar/ui/layout';
import { Heading, Text } from '@keystar/ui/typography';
import { useLocalizedStringFormatter } from '@react-aria/i18n';
import { isHotkey } from 'is-hotkey';
import { alertCircleIcon } from '@keystar/ui/icon/icons/alertCircleIcon';
import { listXIcon } from '@keystar/ui/icon/icons/listXIcon';
import { searchIcon } from '@keystar/ui/icon/icons/searchIcon';
import { searchXIcon } from '@keystar/ui/icon/icons/searchXIcon';
import { diffIcon } from '@keystar/ui/icon/icons/diffIcon';
import { plusSquareIcon } from '@keystar/ui/icon/icons/plusSquareIcon';
import { dotSquareIcon } from '@keystar/ui/icon/icons/dotSquareIcon';
import { TextLink, useLink } from '@keystar/ui/link';
import { ProgressCircle } from '@keystar/ui/progress';
import { SearchField } from '@keystar/ui/search-field';
import { useMediaQuery, breakpointQueries, css, tokenSchema, injectGlobal, containerQueries, classNames, transition } from '@keystar/ui/style';
import { TableView, TableHeader, Column, TableBody, Cell, Row } from '@keystar/ui/table';
import { p as parseProps, t as toFormattedFormDataError, s as strings, P as PageRoot, a as PageHeader, b as setKeysForArrayValue, g as getKeysForArrayValue, u as useTheme, T as ThemeProvider, c as serializeProps, d as getNewArrayElementKey, e as updateValue, f as getInitialPropsValueFromInitializer, h as createGetPreviewProps, i as PageBody, j as containerWidthForEntryLayout, k as useCreateBranchMutation, l as prettyErrorForCreateBranchMutation, F as FormForEntry, m as clientSideValidateProp, n as setValueToPreviewProps, o as getInitialPropsValue, q as useAssociatedPullRequest, C as CreateBranchDialog, r as useNavItems, v as pluralize, w as useSidebar, S as SidebarDialog, x as SidebarPanel, y as SidebarProvider } from './index-e58d11b7.js';
import { u as useRouter, g as getEntryDataFilepath, o as object, a as useTree, b as useBaseCommit, c as useRepoInfo, d as getDirectoriesForTreeKey, e as getTreeKey, f as useData, L as LOADING, h as getTreeNodeAtPath, i as getBlobFromPersistedCache, s as setBlobToPersistedCache, j as blobSha, k as serializeRepoConfig, l as getPathPrefix, m as getAuth, K as KEYSTATIC_CLOUD_API_URL, n as KEYSTATIC_CLOUD_HEADERS, p as getCollectionPath, q as useCurrentBranch, r as isLocalConfig, t as getEntriesInCollectionWithTreeKey, v as getCollectionFormat, w as getCollectionItemPath, x as getSlugGlobForCollection, y as parseRepoConfig, G as GitHubAppShellQuery, z as useConfig, A as useCloudInfo, B as useAwarenessStates, C as getSyncAuth, D as redirectToCloudAuth, E as CloudAppShellQuery, F as useSetTreeSha, H as useCurrentUnscopedTree, I as updateTreeWithChanges, J as hydrateTreeCacheWithEntries, M as scopeEntriesWithPathPrefix, N as fetchGitHubTreeData, O as treeSha, P as getSlugFromState, Q as useYjs, R as getDraft, S as useYjsIfAvailable, T as getCollection, U as suspendOnData, V as useShowRestoredDraftMessage, W as useEventCallback, X as getBranchPrefix, Y as getRepoUrl, Z as getDataFileExtension, _ as isGitHubConfig, $ as setDraft, a0 as delDraft, a1 as useViewer, a2 as useContentPanelState, a3 as ContentPanelProvider, a4 as AppShellErrorContext, a5 as AppStateContext, a6 as ConfigContext, a7 as GitHubAppShellProvider, a8 as LocalAppShellProvider, a9 as useBranches, aa as GitHubAppShellDataContext, ab as getSingletonFormat, ac as getSingletonPath, ad as isCloudConfig, ae as assertValidRepoConfig, af as RouterProvider, ag as CloudInfoProvider, ah as GitHubAppShellDataProvider } from './index-330df5ae.js';
import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { LRUCache } from 'lru-cache';
import '@keystar/ui/picker';
import { Dialog, DialogContainer, AlertDialog, DialogTrigger } from '@keystar/ui/dialog';
import '@keystar/ui/field';
import '@keystar/ui/menu';
import { Content } from '@keystar/ui/slots';
import '@react-aria/label';
import '@keystar/ui/drag-and-drop';
import { trash2Icon } from '@keystar/ui/icon/icons/trash2Icon';
import '@keystar/ui/list-view';
import '@keystar/ui/tooltip';
import { assert } from 'emery';
import 'slate';
import 'slate-react';
import { SplitPaneSecondary, SplitView, SplitPanePrimary } from '@keystar/ui/split-view';
import '@keystar/ui/icon/icons/panelLeftOpenIcon';
import '@keystar/ui/icon/icons/panelLeftCloseIcon';
import '@keystar/ui/icon/icons/panelRightOpenIcon';
import '@keystar/ui/icon/icons/panelRightCloseIcon';
import '@keystar/ui/checkbox';
import '@keystar/ui/number-field';
import { TextField } from '@keystar/ui/text-field';
import '@keystar/ui/icon/icons/imageIcon';
import '@braintree/sanitize-url';
import '@react-stately/collections';
import '@keystar/ui/action-bar';
import '@keystar/ui/combobox';
import 'minimatch';
import '@keystar/ui/icon/icons/refreshCwIcon';
import '@sindresorhus/slugify';
import { l as loadDataFile } from './required-files-bd819871.js';
import * as Y from 'yjs';
import * as s from 'superstruct';
import { historyIcon } from '@keystar/ui/icon/icons/historyIcon';
import { Notice } from '@keystar/ui/notice';
import { Toaster, toastQueue } from '@keystar/ui/toast';
import { Item as Item$1, ActionGroup } from '@keystar/ui/action-group';
import { Badge } from '@keystar/ui/badge';
import { copyPlusIcon } from '@keystar/ui/icon/icons/copyPlusIcon';
import { clipboardCopyIcon } from '@keystar/ui/icon/icons/clipboardCopyIcon';
import { clipboardPasteIcon } from '@keystar/ui/icon/icons/clipboardPasteIcon';
import { externalLinkIcon } from '@keystar/ui/icon/icons/externalLinkIcon';
import { assertNever } from 'emery/assertions';
import { useClient, createClient, fetchExchange, Provider as Provider$1, useMutation } from 'urql';
import { Item, Breadcrumbs } from '@keystar/ui/breadcrumbs';
import { u as useSlugsInCollection } from './useSlugsInCollection-cedb5275.js';
import { Avatar } from '@keystar/ui/avatar';
import { gql } from '@ts-gql/tag/no-transform';
import { dump } from 'js-yaml';
import { KeystarProvider, ClientSideOnlyDocumentElement } from '@keystar/ui/core';
import { cacheExchange } from '@urql/exchange-graphcache';
import { authExchange } from '@urql/exchange-auth';
import { persistedExchange } from '@urql/exchange-persisted';
import { relayPagination } from '@urql/exchange-graphcache/extras';
import { b as base64Encode, a as base64UrlDecode, c as base64UrlEncode } from './base64-3538d789.js';
import isEqual from 'fast-deep-equal';
import { gitBranchIcon } from '@keystar/ui/icon/icons/gitBranchIcon';
import { gitBranchPlusIcon } from '@keystar/ui/icon/icons/gitBranchPlusIcon';
import { gitPullRequestIcon } from '@keystar/ui/icon/icons/gitPullRequestIcon';
import { plusIcon } from '@keystar/ui/icon/icons/plusIcon';
import '@markdoc/markdoc/dist/index.mjs';
import 'prosemirror-commands';
import 'prosemirror-state';
import 'prosemirror-transform';
import '@keystar/ui/editor';
import '@keystar/ui/icon/icons/boldIcon';
import '@keystar/ui/icon/icons/chevronDownIcon';
import '@keystar/ui/icon/icons/codeIcon';
import '@keystar/ui/icon/icons/italicIcon';
import '@keystar/ui/icon/icons/listIcon';
import '@keystar/ui/icon/icons/listOrderedIcon';
import '@keystar/ui/icon/icons/minusIcon';
import '@keystar/ui/icon/icons/quoteIcon';
import '@keystar/ui/icon/icons/removeFormattingIcon';
import '@keystar/ui/icon/icons/strikethroughIcon';
import '@keystar/ui/icon/icons/tableIcon';
import '@keystar/ui/icon/icons/fileCodeIcon';
import '@keystar/ui/icon/icons/heading1Icon';
import '@keystar/ui/icon/icons/heading2Icon';
import '@keystar/ui/icon/icons/heading3Icon';
import '@keystar/ui/icon/icons/heading4Icon';
import '@keystar/ui/icon/icons/heading5Icon';
import '@keystar/ui/icon/icons/heading6Icon';
import '@keystar/ui/icon/icons/separatorHorizontalIcon';
import 'prosemirror-model';
import '@emotion/css';
import '@react-aria/overlays';
import '@react-aria/utils';
import '@react-stately/overlays';
import '@keystar/ui/nav-list';
import '@keystar/ui/overlays';
import '@keystar/ui/status-light';
import '@keystar/ui/utils';
import '@keystar/ui/icon/icons/logOutIcon';
import '@keystar/ui/icon/icons/gitForkIcon';
import '@keystar/ui/icon/icons/monitorIcon';
import '@keystar/ui/icon/icons/moonIcon';
import '@keystar/ui/icon/icons/sunIcon';
import '@keystar/ui/icon/icons/userIcon';
import '@keystar/ui/radio';
import '@keystar/ui/icon/icons/editIcon';
import '@keystar/ui/icon/icons/linkIcon';
import '@keystar/ui/icon/icons/unlinkIcon';
import '@keystar/ui/icon/icons/maximizeIcon';
import '@keystar/ui/icon/icons/minimizeIcon';
import '@keystar/ui/icon/icons/subscriptIcon';
import '@keystar/ui/icon/icons/superscriptIcon';
import '@keystar/ui/icon/icons/typeIcon';
import '@keystar/ui/icon/icons/underlineIcon';
import '@keystar/ui/icon/icons/alignLeftIcon';
import '@keystar/ui/icon/icons/alignRightIcon';
import '@keystar/ui/icon/icons/alignCenterIcon';
import 'match-sorter';
import '@keystar/ui/icon/icons/trashIcon';
import '@emotion/weak-memoize';
import '@keystar/ui/icon/icons/columnsIcon';
import '@keystar/ui/icon/icons/fileUpIcon';
import 'y-prosemirror';
import '@keystar/ui/icon/icons/sheetIcon';
import 'scroll-into-view-if-needed';
import '@react-stately/list';
import '@keystar/ui/listbox';
import 'slate-history';
import 'mdast-util-from-markdown';
import 'mdast-util-gfm-autolink-literal';
import 'micromark-extension-gfm-autolink-literal';
import 'mdast-util-gfm-strikethrough';
import 'micromark-extension-gfm-strikethrough';
import 'prosemirror-view';
import '@react-aria/selection';
import 'prosemirror-tables';
import '@keystar/ui/icon/icons/pencilIcon';
import 'react-dom';
import 'prosemirror-history';
import 'prosemirror-keymap';
import 'escape-string-regexp';
import 'mdast-util-to-markdown';
import 'mdast-util-gfm-table';
import 'mdast-util-mdx';
import 'micromark-extension-gfm-table';
import 'micromark-extension-mdxjs';
import 'unist-util-visit';
import '@keystar/ui/icon/icons/link2Icon';
import '@keystar/ui/icon/icons/link2OffIcon';
import '@keystar/ui/icon/icons/undo2Icon';
import 'y-protocols/awareness';
import '@toeverything/y-indexeddb';
import 'lib0/broadcastchannel';
import 'lib0/time';
import 'lib0/encoding';
import 'lib0/decoding';
import 'y-protocols/sync';
import 'y-protocols/auth';
import 'lib0/mutex';
import 'lib0/math';
import 'cookie';
import 'idb-keyval';
import 'partysocket/ws';
import 'lib0/encoding.js';

// the collator enables language-sensitive string comparison
const collator = new Intl.Collator(undefined, {
  sensitivity: 'base'
});

/**
 * Creates a comparison function that should be provided to the `sort()` method
 * of your data array.
 */
function sortBy(direction, valueA, valueB) {
  const modifier = direction === 'ascending' ? 1 : -1;

  // always push `null` and `undefined` to the bottom
  if (valueA == null) return 1;
  if (valueB == null) return -1;

  // the collator is only appropriate for strings, it fails in subtle
  // ways for floats, dates, etc.
  if (typeof valueA === 'string' && typeof valueB === 'string') {
    return collator.compare(valueA, valueB) * modifier;
  }
  return compare(valueA, valueB) * modifier;
}

/** Default comparison for non-string values */
function compare(a, b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}

function EmptyState(props) {
  const $ = c(5);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      mobile: "medium",
      tablet: "xlarge",
      desktop: "xxlarge"
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== props) {
    t1 = "children" in props ? props.children : /*#__PURE__*/jsxs(Fragment, {
      children: [props.icon && /*#__PURE__*/jsx(Icon, {
        src: props.icon,
        size: "large",
        color: "neutralEmphasis"
      }), props.title && /*#__PURE__*/jsx(Heading, {
        align: "center",
        size: "medium",
        children: props.title
      }), props.message && /*#__PURE__*/jsx(Text, {
        align: "center",
        children: props.message
      }), props.actions]
    });
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t1) {
    t2 = /*#__PURE__*/jsx(Flex, {
      alignItems: "center",
      direction: "column",
      gap: "large",
      justifyContent: "center",
      minHeight: "scale.3000",
      paddingX: t0,
      children: t1
    });
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

class NotFoundError extends Error {
  constructor() {
    super('Not found');
    this.name = 'NotFoundError';
  }
}
function isNotFoundError(err) {
  return typeof err === 'object' && err !== null && err instanceof NotFoundError;
}
function notFound() {
  throw new NotFoundError();
}
class NotFoundErrorBoundaryInner extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      notFound: false,
      lastHref: props.href
    };
  }
  static getDerivedStateFromError(err) {
    if (isNotFoundError(err)) {
      return {
        notFound: true
      };
    }
    throw err;
  }
  static getDerivedStateFromProps(props, state) {
    if (props.href !== state.lastHref && state.notFound) {
      return {
        notFound: false,
        lastHref: props.href
      };
    }
    return {
      notFound: state.notFound,
      lastHref: props.href
    };
  }
  render() {
    if (this.state.notFound) return this.props.fallback;
    return this.props.children;
  }
}
function NotFoundBoundary(props) {
  const $ = c(3);
  const router = useRouter();
  let t0;
  if ($[0] !== props || $[1] !== router.href) {
    t0 = /*#__PURE__*/jsx(NotFoundErrorBoundaryInner, {
      ...props,
      href: router.href
    });
    $[0] = props;
    $[1] = router.href;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  return t0;
}

class TrackedMap extends Map {
  #onGet;
  constructor(onGet, entries) {
    super(entries);
    this.#onGet = onGet;
  }
  get(key) {
    this.#onGet(key);
    return super.get(key);
  }
}
function parseEntry(args, files) {
  const dataFilepath = getEntryDataFilepath(args.dirpath, args.format);
  const data = files.get(dataFilepath);
  if (!data) {
    throw new Error(`Could not find data file at ${dataFilepath}`);
  }
  const {
    loaded,
    extraFakeFile
  } = loadDataFile(data, args.format, args.requireFrontmatter);
  const filesWithFakeFile = new Map(files);
  if (extraFakeFile) {
    filesWithFakeFile.set(`${args.dirpath}/${extraFakeFile.path}`, extraFakeFile.contents);
  }
  const usedFiles = new Set([dataFilepath]);
  const rootSchema = object(args.schema);
  let initialState;
  const getFile = filepath => {
    usedFiles.add(filepath);
    return filesWithFakeFile.get(filepath);
  };
  const getFilesForAssetsOrContentField = (rootPath, schema) => {
    const otherFiles = new TrackedMap(key => {
      usedFiles.add(`${rootPath}/${key}`);
    });
    const otherDirectories = new Map();
    for (const [filename] of filesWithFakeFile) {
      if (filename.startsWith(rootPath + '/')) {
        const relativePath = filename.slice(rootPath.length + 1);
        otherFiles.set(relativePath, filesWithFakeFile.get(filename));
      }
    }
    for (const dir of (_schema$directories = schema.directories) !== null && _schema$directories !== void 0 ? _schema$directories : []) {
      var _schema$directories, _args$slug, _args$slug2;
      const dirFiles = new TrackedMap(relativePath => usedFiles.add(start + relativePath));
      const start = `${dir}${((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.slug) === undefined ? '' : `/${(_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.slug}`}/`;
      for (const [filename, val] of filesWithFakeFile) {
        if (filename.startsWith(start)) {
          const relativePath = filename.slice(start.length);
          dirFiles.set(relativePath, val);
        }
      }
      if (dirFiles.size) {
        otherDirectories.set(dir, dirFiles);
      }
    }
    return {
      other: otherFiles,
      external: otherDirectories
    };
  };
  try {
    initialState = parseProps(rootSchema, loaded, [], [], (schema, value, path, pathWithArrayFieldSlugs) => {
      var _args$slug3;
      if (path.length === 1 && path[0] === ((_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.field)) {
        if (schema.formKind !== 'slug') {
          throw new Error(`slugField is not a slug field`);
        }
        return schema.parse(value, {
          slug: args.slug.slug
        });
      }
      if (schema.formKind === 'asset') {
        var _args$slug4, _args$slug5, _args$slug6;
        const suggestedFilenamePrefix = pathWithArrayFieldSlugs.join('/');
        const filepath = schema.filename(value, {
          suggestedFilenamePrefix,
          slug: (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.slug
        });
        const asset = filepath ? getFile(`${schema.directory ? `${schema.directory}${((_args$slug5 = args.slug) === null || _args$slug5 === void 0 ? void 0 : _args$slug5.slug) === undefined ? '' : `/${args.slug.slug}`}` : args.dirpath}/${filepath}`) : undefined;
        return schema.parse(value, {
          asset,
          slug: (_args$slug6 = args.slug) === null || _args$slug6 === void 0 ? void 0 : _args$slug6.slug
        });
      }
      if (schema.formKind === 'content' || schema.formKind === 'assets') {
        const rootPath = `${args.dirpath}/${pathWithArrayFieldSlugs.join('/')}`;
        const {
          external,
          other
        } = getFilesForAssetsOrContentField(rootPath, schema);
        if (schema.formKind === 'content') {
          var _args$slug7;
          const mainFilepath = rootPath + schema.contentExtension;
          const mainContents = getFile(mainFilepath);
          return schema.parse(value, {
            content: mainContents,
            other,
            external,
            slug: (_args$slug7 = args.slug) === null || _args$slug7 === void 0 ? void 0 : _args$slug7.slug
          });
        }
        if (schema.formKind === 'assets') {
          var _args$slug8;
          return schema.parse(value, {
            other,
            external,
            slug: (_args$slug8 = args.slug) === null || _args$slug8 === void 0 ? void 0 : _args$slug8.slug
          });
        }
      }
      return schema.parse(value, undefined);
    }, false);
  } catch (err) {
    throw toFormattedFormDataError(err);
  }
  if (extraFakeFile) {
    usedFiles.delete(`${args.dirpath}/${extraFakeFile.path}`);
  }
  return {
    initialState,
    initialFiles: [...usedFiles]
  };
}
function getAllFilesInTree(tree) {
  return [...tree.values()].flatMap(val => val.children ? getAllFilesInTree(val.children) : [val.entry]);
}
function useItemData(args) {
  var _args$slug10;
  const {
    current: currentBranch
  } = useTree();
  const baseCommit = useBaseCommit();
  const repoInfo = useRepoInfo();
  const rootTree = currentBranch.kind === 'loaded' ? currentBranch.data.tree : undefined;
  const locationsForTreeKey = useMemo(() => {
    var _args$slug9;
    return getDirectoriesForTreeKey(object(args.schema), args.dirpath, (_args$slug9 = args.slug) === null || _args$slug9 === void 0 ? void 0 : _args$slug9.slug, args.format);
  }, [args.dirpath, args.format, args.schema, (_args$slug10 = args.slug) === null || _args$slug10 === void 0 ? void 0 : _args$slug10.slug]);
  const localTreeKey = useMemo(() => getTreeKey(locationsForTreeKey, rootTree !== null && rootTree !== void 0 ? rootTree : new Map()), [locationsForTreeKey, rootTree]);
  const tree = useMemo(() => {
    return rootTree !== null && rootTree !== void 0 ? rootTree : new Map();
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [localTreeKey, locationsForTreeKey]);
  const hasLoaded = currentBranch.kind === 'loaded';
  return useData(useCallback(() => {
    var _getTreeNodeAtPath;
    if (!hasLoaded) return LOADING;
    const dataFilepathSha = (_getTreeNodeAtPath = getTreeNodeAtPath(tree, getEntryDataFilepath(args.dirpath, args.format))) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
    if (dataFilepathSha === undefined) {
      return 'not-found';
    }
    const _args = {
      dirpath: args.dirpath,
      format: args.format,
      schema: args.schema,
      slug: args.slug
    };
    const allBlobs = locationsForTreeKey.flatMap(dir => {
      const node = getTreeNodeAtPath(tree, dir);
      if (!node) return [];
      return node.children ? getAllFilesInTree(node.children) : [node.entry];
    }).map(entry => {
      const blob = fetchBlob(args.config, entry.sha, entry.path, baseCommit, repoInfo);
      if (blob instanceof Uint8Array) {
        return [entry.path, blob];
      }
      return blob.then(blob_0 => [entry.path, blob_0]);
    });
    if (allBlobs.every(x => Array.isArray(x))) {
      const {
        initialFiles,
        initialState
      } = parseEntry(_args, new Map(allBlobs));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    }
    return Promise.all(allBlobs).then(async data => {
      const {
        initialState: initialState_0,
        initialFiles: initialFiles_0
      } = parseEntry(_args, new Map(data));
      return {
        initialState: initialState_0,
        initialFiles: initialFiles_0,
        localTreeKey
      };
    });
  }, [hasLoaded, tree, args.dirpath, args.format, args.config, args.schema, args.slug, locationsForTreeKey, baseCommit, repoInfo, localTreeKey]));
}
const blobCache = new LRUCache({
  max: 200
});
async function hydrateBlobCache(contents) {
  const sha = await blobSha(contents);
  blobCache.set(sha, contents);
  await setBlobToPersistedCache(sha, contents);
  return sha;
}
async function fetchGitHubBlob(config, oid, filepath, commitSha, repoInfo) {
  if ((repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.isPrivate) === false) {
    var _getPathPrefix;
    return fetch(`https://raw.githubusercontent.com/${serializeRepoConfig(repoInfo)}/${commitSha}/${(_getPathPrefix = getPathPrefix(config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ''}${filepath}`);
  }
  const auth = await getAuth(config);
  return fetch(config.storage.kind === 'github' ? `https://api.github.com/repos/${serializeRepoConfig(config.storage.repo)}/git/blobs/${oid}` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/blob/${oid}`, {
    headers: {
      Authorization: `Bearer ${auth.accessToken}`,
      Accept: 'application/vnd.github.raw',
      ...(config.storage.kind === 'cloud' ? KEYSTATIC_CLOUD_HEADERS : {})
    }
  });
}
function fetchBlob(config, oid, filepath, commitSha, repoInfo) {
  if (blobCache.has(oid)) return blobCache.get(oid);
  const promise = (async () => {
    const isLocal = config.storage.kind === 'local';
    if (!isLocal) {
      const stored = await getBlobFromPersistedCache(oid);
      if (stored) {
        blobCache.set(oid, stored);
        return stored;
      }
    }
    return (isLocal ? fetch(`/api/keystatic/blob/${oid}/${filepath}`, {
      headers: {
        'no-cors': '1'
      }
    }) : fetchGitHubBlob(config, oid, filepath, commitSha, repoInfo)).then(async x => {
      if (!x.ok) {
        throw new Error(`Could not fetch blob ${oid} (${filepath}): ${x.status}\n${await x.text()}`);
      }
      return x.arrayBuffer();
    }).then(x => {
      const array = new Uint8Array(x);
      blobCache.set(oid, array);
      if (config.storage.kind !== 'local') {
        setBlobToPersistedCache(oid, array);
      }
      return array;
    }).catch(err => {
      blobCache.delete(oid);
      throw err;
    });
  })();
  blobCache.set(oid, promise);
  return promise;
}

function CollectionPage(props) {
  var _config$collections;
  const $ = c(15);
  const {
    collection,
    config
  } = props;
  const collectionConfig = (_config$collections = config.collections) === null || _config$collections === void 0 ? void 0 : _config$collections[collection];
  if (!collectionConfig) {
    notFound();
  }
  const router = useRouter();
  let t0;
  if ($[0] !== router.search) {
    var _URLSearchParams$get;
    t0 = (_URLSearchParams$get = new URLSearchParams(router.search).get("search")) !== null && _URLSearchParams$get !== void 0 ? _URLSearchParams$get : "";
    $[0] = router.search;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const [searchTerm, setSearchTerm] = useState(t0);
  let t1;
  if ($[2] !== router) {
    t1 = value => {
      setSearchTerm(value);
      const params = new URLSearchParams(router.search);
      if (value) {
        params.set("search", value);
      } else {
        params.delete("search");
      }
      router.replace(router.pathname + "?" + params.toString());
    };
    $[2] = router;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const setSearchTermFromForm = t1;
  const debouncedSearchTerm = useDebouncedValue(searchTerm, 300);
  const t2 = `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`;
  let t3;
  if ($[4] !== collectionConfig.label || $[5] !== t2 || $[6] !== searchTerm || $[7] !== setSearchTermFromForm) {
    t3 = /*#__PURE__*/jsx(CollectionPageHeader, {
      collectionLabel: collectionConfig.label,
      createHref: t2,
      searchTerm: searchTerm,
      onSearchTermChange: setSearchTermFromForm
    });
    $[4] = collectionConfig.label;
    $[5] = t2;
    $[6] = searchTerm;
    $[7] = setSearchTermFromForm;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== debouncedSearchTerm || $[10] !== props) {
    t4 = /*#__PURE__*/jsx(CollectionPageContent, {
      searchTerm: debouncedSearchTerm,
      ...props
    });
    $[9] = debouncedSearchTerm;
    $[10] = props;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] !== t3 || $[13] !== t4) {
    t5 = /*#__PURE__*/jsxs(PageRoot, {
      containerWidth: "none",
      children: [t3, t4]
    });
    $[12] = t3;
    $[13] = t4;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  return t5;
}
function CollectionPageHeader(props) {
  const $ = c(50);
  const {
    collectionLabel,
    createHref
  } = props;
  const stringFormatter = useLocalizedStringFormatter(strings);
  const isAboveMobile = useMediaQuery(breakpointQueries.above.mobile);
  const [searchVisible, setSearchVisible] = useState(isAboveMobile);
  const searchRef = useRef(null);
  let t0;
  let t1;
  if ($[0] !== isAboveMobile) {
    t0 = () => {
      setSearchVisible(isAboveMobile);
    };
    t1 = [isAboveMobile];
    $[0] = isAboveMobile;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  useEffect(t0, t1);
  let t2;
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => {
      const listener = event => {
        if (document.activeElement === searchRef.current) {
          return;
        }
        if (isHotkey("mod+f", event)) {
          var _searchRef$current;
          event.preventDefault();
          (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 || _searchRef$current.select();
        }
      };
      document.addEventListener("keydown", listener);
      return () => document.removeEventListener("keydown", listener);
    };
    t3 = [];
    $[3] = t2;
    $[4] = t3;
  } else {
    t2 = $[3];
    t3 = $[4];
  }
  useEffect(t2, t3);
  let t4;
  if ($[5] !== collectionLabel) {
    t4 = /*#__PURE__*/jsx(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      flex: true,
      minWidth: 0,
      children: collectionLabel
    });
    $[5] = collectionLabel;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const t5 = searchVisible ? "block" : "none";
  let t6;
  if ($[7] !== t5) {
    t6 = {
      display: t5
    };
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  if ($[9] !== stringFormatter) {
    t7 = stringFormatter.format("search");
    $[9] = stringFormatter;
    $[10] = t7;
  } else {
    t7 = $[10];
  }
  let t8;
  if ($[11] !== props || $[12] !== isAboveMobile) {
    t8 = () => {
      props.onSearchTermChange("");
      if (!isAboveMobile) {
        setTimeout(() => {
          setSearchVisible(false);
        }, 250);
      }
    };
    $[11] = props;
    $[12] = isAboveMobile;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  let t9;
  if ($[14] !== isAboveMobile || $[15] !== props.searchTerm) {
    t9 = () => {
      if (!isAboveMobile && props.searchTerm === "") {
        setSearchVisible(false);
      }
    };
    $[14] = isAboveMobile;
    $[15] = props.searchTerm;
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  let t10;
  if ($[17] !== stringFormatter) {
    t10 = stringFormatter.format("search");
    $[17] = stringFormatter;
    $[18] = t10;
  } else {
    t10 = $[18];
  }
  let t11;
  if ($[19] !== searchRef || $[20] !== t7 || $[21] !== props.onSearchTermChange || $[22] !== props.searchTerm || $[23] !== t8 || $[24] !== t9 || $[25] !== t10) {
    t11 = /*#__PURE__*/jsx(SearchField, {
      ref: searchRef,
      "aria-label": t7,
      onChange: props.onSearchTermChange,
      onClear: t8,
      onBlur: t9,
      placeholder: t10,
      value: props.searchTerm,
      width: "scale.2400"
    });
    $[19] = searchRef;
    $[20] = t7;
    $[21] = props.onSearchTermChange;
    $[22] = props.searchTerm;
    $[23] = t8;
    $[24] = t9;
    $[25] = t10;
    $[26] = t11;
  } else {
    t11 = $[26];
  }
  let t12;
  if ($[27] !== t6 || $[28] !== t11) {
    t12 = /*#__PURE__*/jsx("div", {
      role: "search",
      style: t6,
      children: t11
    });
    $[27] = t6;
    $[28] = t11;
    $[29] = t12;
  } else {
    t12 = $[29];
  }
  let t13;
  if ($[30] !== searchVisible) {
    t13 = searchVisible || {
      above: "mobile"
    };
    $[30] = searchVisible;
    $[31] = t13;
  } else {
    t13 = $[31];
  }
  let t14;
  if ($[32] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = () => {
      setSearchVisible(true);
      const tempInput = document.createElement("input");
      tempInput.style.position = "absolute";
      tempInput.style.opacity = "0";
      document.body.appendChild(tempInput);
      tempInput.focus();
      setTimeout(() => {
        var _searchRef$current2;
        (_searchRef$current2 = searchRef.current) === null || _searchRef$current2 === void 0 || _searchRef$current2.focus();
        tempInput.remove();
      }, 0);
    };
    $[32] = t14;
  } else {
    t14 = $[32];
  }
  let t15;
  if ($[33] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = /*#__PURE__*/jsx(Icon, {
      src: searchIcon
    });
    $[33] = t15;
  } else {
    t15 = $[33];
  }
  let t16;
  if ($[34] !== t13 || $[35] !== t14) {
    t16 = /*#__PURE__*/jsx(ActionButton, {
      "aria-label": "show search",
      isHidden: t13,
      onPress: t14,
      children: t15
    });
    $[34] = t13;
    $[35] = t14;
    $[36] = t16;
  } else {
    t16 = $[36];
  }
  let t17;
  if ($[37] !== searchVisible) {
    t17 = searchVisible ? {
      below: "tablet"
    } : undefined;
    $[37] = searchVisible;
    $[38] = t17;
  } else {
    t17 = $[38];
  }
  let t18;
  if ($[39] !== stringFormatter) {
    t18 = stringFormatter.format("add");
    $[39] = stringFormatter;
    $[40] = t18;
  } else {
    t18 = $[40];
  }
  let t19;
  if ($[41] !== createHref || $[42] !== t17 || $[43] !== t18) {
    t19 = /*#__PURE__*/jsx(Button, {
      marginStart: "auto",
      prominence: "high",
      href: createHref,
      isHidden: t17,
      children: t18
    });
    $[41] = createHref;
    $[42] = t17;
    $[43] = t18;
    $[44] = t19;
  } else {
    t19 = $[44];
  }
  let t20;
  if ($[45] !== t4 || $[46] !== t12 || $[47] !== t16 || $[48] !== t19) {
    t20 = /*#__PURE__*/jsxs(PageHeader, {
      children: [t4, t12, t16, t19]
    });
    $[45] = t4;
    $[46] = t12;
    $[47] = t16;
    $[48] = t19;
    $[49] = t20;
  } else {
    t20 = $[49];
  }
  return t20;
}
function CollectionPageContent(props) {
  const $ = c(11);
  const trees = useTree();
  const tree = trees.merged.kind === "loaded" ? trees.merged.data.current.entries.get(getCollectionPath(props.config, props.collection)) : null;
  if (trees.merged.kind === "error") {
    let t0;
    if ($[0] !== props.basePath) {
      t0 = /*#__PURE__*/jsx(Button, {
        tone: "accent",
        href: props.basePath,
        children: "Dashboard"
      });
      $[0] = props.basePath;
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    let t1;
    if ($[2] !== trees.merged.error.message || $[3] !== t0) {
      t1 = /*#__PURE__*/jsx(EmptyState, {
        icon: alertCircleIcon,
        title: "Unable to load collection",
        message: trees.merged.error.message,
        actions: t0
      });
      $[2] = trees.merged.error.message;
      $[3] = t0;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    return t1;
  }
  if (trees.merged.kind === "loading") {
    let t0;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = /*#__PURE__*/jsx(EmptyState, {
        children: /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": "Loading Entries",
          isIndeterminate: true,
          size: "large"
        })
      });
      $[5] = t0;
    } else {
      t0 = $[5];
    }
    return t0;
  }
  if (!tree) {
    const t0 = `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`;
    let t1;
    if ($[6] !== t0) {
      t1 = /*#__PURE__*/jsx(EmptyState, {
        icon: listXIcon,
        title: "Empty collection",
        message: /*#__PURE__*/jsxs(Fragment, {
          children: ["There aren't any entries yet.", " ", /*#__PURE__*/jsx(TextLink, {
            href: t0,
            children: "Create the first entry"
          }), " ", "to see it here."]
        })
      });
      $[6] = t0;
      $[7] = t1;
    } else {
      t1 = $[7];
    }
    return t1;
  }
  let t0;
  if ($[8] !== props || $[9] !== trees.merged.data) {
    t0 = /*#__PURE__*/jsx(CollectionTable, {
      ...props,
      trees: trees.merged.data
    });
    $[8] = props;
    $[9] = trees.merged.data;
    $[10] = t0;
  } else {
    t0 = $[10];
  }
  return t0;
}
const SLUG = '@@slug';
const STATUS = '@@status';
function CollectionTable(props) {
  let {
    searchTerm
  } = props;
  const repoInfo = useRepoInfo();
  const currentBranch = useCurrentBranch();
  let isLocalMode = isLocalConfig(props.config);
  let router = useRouter();
  let [sortDescriptor, setSortDescriptor] = useState({
    column: SLUG,
    direction: 'ascending'
  });
  let hideStatusColumn = isLocalMode || currentBranch === (repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.defaultBranch);
  const baseCommit = useBaseCommit();
  const collection = props.config.collections[props.collection];
  const entriesWithStatus = useMemo(() => {
    const defaultEntries = new Map(getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.default.tree).map(x => [x.slug, x.key]));
    return getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.current.tree).map(entry => {
      return {
        name: entry.slug,
        status: defaultEntries.has(entry.slug) ? defaultEntries.get(entry.slug) === entry.key ? 'Unchanged' : 'Changed' : 'Added',
        sha: entry.sha
      };
    });
  }, [props.collection, props.config, props.trees]);
  const mainFiles = useData(useCallback(async () => {
    var _collection$columns;
    if (!((_collection$columns = collection.columns) !== null && _collection$columns !== void 0 && _collection$columns.length)) return undefined;
    const formatInfo = getCollectionFormat(props.config, props.collection);
    const entries = await Promise.all(entriesWithStatus.map(async entry_0 => {
      return [entry_0.name, await fetchBlob(props.config, entry_0.sha, getEntryDataFilepath(getCollectionItemPath(props.config, props.collection, entry_0.name), formatInfo), baseCommit, repoInfo)];
    }));
    const glob = getSlugGlobForCollection(props.config, props.collection);
    const rootSchema = {
      kind: 'object',
      fields: collection.schema
    };
    const parsedEntries = new Map();
    for (const [slug, dataFile] of entries) {
      try {
        const {
          loaded
        } = loadDataFile(dataFile, formatInfo);
        const validated = parseProps(rootSchema, loaded, [], [], (schema, value, path) => {
          if (schema.formKind === 'asset') {
            return schema.reader.parse(value);
          }
          if (schema.formKind === 'content' || schema.formKind === 'assets') {
            return;
          }
          if (path.length === 1 && slug !== undefined) {
            if (path[0] === collection.slugField) {
              if (schema.formKind !== 'slug') {
                throw new Error(`Slug field ${collection.slugField} is not a slug field`);
              }
              return schema.reader.parseWithSlug(value, {
                slug,
                glob
              });
            }
          }
          return schema.reader.parse(value);
        }, true);
        parsedEntries.set(slug, validated);
      } catch {}
    }
    return parsedEntries;
  }, [collection, props.config, props.collection, entriesWithStatus, baseCommit, repoInfo]));
  const entriesWithData = useMemo(() => {
    if (mainFiles.kind !== 'loaded' || !mainFiles.data) {
      return entriesWithStatus;
    }
    const {
      data
    } = mainFiles;
    return entriesWithStatus.map(entry_1 => {
      return {
        ...entry_1,
        data: data.get(entry_1.name)
      };
    });
  }, [entriesWithStatus, mainFiles]);
  const filteredItems = useMemo(() => {
    return entriesWithData.filter(item => item.name.toLowerCase().includes(searchTerm.toLowerCase()));
  }, [entriesWithData, searchTerm]);
  const sortedItems = useMemo(() => {
    return [...filteredItems].sort((a, b) => {
      const readCol = (row, other) => {
        var _other;
        if (sortDescriptor.column === SLUG) {
          var _collection$parseSlug, _collection$parseSlug2;
          return (_collection$parseSlug = (_collection$parseSlug2 = collection.parseSlugForSort) === null || _collection$parseSlug2 === void 0 ? void 0 : _collection$parseSlug2.call(collection, row.name)) !== null && _collection$parseSlug !== void 0 ? _collection$parseSlug : row.name;
        }
        if (sortDescriptor.column === STATUS) {
          return row.status;
        }
        return (_other = other === null || other === void 0 ? void 0 : other[sortDescriptor.column]) !== null && _other !== void 0 ? _other : row.name;
      };
      const other_0 = mainFiles.kind === 'loaded' ? mainFiles.data : undefined;
      return sortBy(sortDescriptor.direction, readCol(a, other_0 === null || other_0 === void 0 ? void 0 : other_0.get(a.name)), readCol(b, other_0 === null || other_0 === void 0 ? void 0 : other_0.get(b.name)));
    });
  }, [collection, filteredItems, mainFiles, sortDescriptor.column, sortDescriptor.direction]);
  const columns = useMemo(() => {
    var _collection$columns2;
    if ((_collection$columns2 = collection.columns) !== null && _collection$columns2 !== void 0 && _collection$columns2.length) {
      return [...(hideStatusColumn ? [] : [{
        name: 'Status',
        key: STATUS,
        minWidth: 32,
        width: 32
      }]), {
        name: 'Slug',
        key: SLUG
      }, ...collection.columns.map(column => {
        const schema_0 = collection.schema[column];
        return {
          name: 'label' in schema_0 && schema_0.label || column,
          key: column
        };
      })];
    }
    return hideStatusColumn ? [{
      name: 'Name',
      key: SLUG
    }] : [{
      name: 'Status',
      key: STATUS,
      minWidth: 32,
      width: 32
    }, {
      name: 'Name',
      key: SLUG
    }];
  }, [collection, hideStatusColumn]);
  return /*#__PURE__*/jsxs(TableView, {
    "aria-labelledby": "page-title",
    selectionMode: "none",
    onSortChange: setSortDescriptor,
    sortDescriptor: sortDescriptor,
    density: "spacious",
    overflowMode: "truncate",
    prominence: "low",
    onAction: key => {
      router.push(getItemPath(props.basePath, props.collection, key));
    },
    renderEmptyState: () => /*#__PURE__*/jsx(EmptyState, {
      icon: searchXIcon,
      title: "No results",
      message: `No items matching "${searchTerm}" were found.`
    }),
    flex: true,
    marginTop: {
      tablet: 'large'
    },
    marginBottom: {
      mobile: 'regular',
      tablet: 'xlarge'
    },
    UNSAFE_className: css({
      marginInline: tokenSchema.size.space.regular,
      [breakpointQueries.above.mobile]: {
        marginInline: `calc(${tokenSchema.size.space.xlarge} - ${tokenSchema.size.space.medium})`
      },
      [breakpointQueries.above.tablet]: {
        marginInline: `calc(${tokenSchema.size.space.xxlarge} - ${tokenSchema.size.space.medium})`
      },
      '[role=rowheader]': {
        cursor: 'pointer'
      }
    }),
    children: [/*#__PURE__*/jsx(TableHeader, {
      columns: columns,
      children: ({
        name,
        key: key_0,
        ...options
      }) => key_0 === STATUS ? /*#__PURE__*/jsx(Column, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: /*#__PURE__*/jsx(Icon, {
          "aria-label": "Status",
          src: diffIcon
        })
      }, key_0) : /*#__PURE__*/jsx(Column, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: name
      }, key_0)
    }), /*#__PURE__*/jsx(TableBody, {
      items: sortedItems,
      children: item_0 => {
        var _collection$columns3;
        const statusCell = /*#__PURE__*/jsx(Cell, {
          textValue: item_0.status,
          children: item_0.status === 'Added' ? /*#__PURE__*/jsx(Icon, {
            color: "positive",
            src: plusSquareIcon
          }) : item_0.status === 'Changed' ? /*#__PURE__*/jsx(Icon, {
            color: "accent",
            src: dotSquareIcon
          }) : null
        }, STATUS + item_0.name);
        const nameCell = /*#__PURE__*/jsx(Cell, {
          textValue: item_0.name,
          children: /*#__PURE__*/jsx(Text, {
            weight: "medium",
            children: item_0.name
          })
        }, SLUG + item_0.name);
        if ((_collection$columns3 = collection.columns) !== null && _collection$columns3 !== void 0 && _collection$columns3.length) {
          return /*#__PURE__*/jsx(Row, {
            children: [...(hideStatusColumn ? [] : [statusCell]), nameCell, ...collection.columns.map(column_0 => {
              var _item_0$data;
              let val;
              val = (_item_0$data = item_0.data) === null || _item_0$data === void 0 ? void 0 : _item_0$data[column_0];
              if (val == null) {
                val = undefined;
              } else {
                val = val + '';
              }
              return /*#__PURE__*/jsx(Cell, {
                textValue: val,
                children: /*#__PURE__*/jsx(Text, {
                  weight: "medium",
                  children: val
                })
              }, column_0 + item_0.name);
            })]
          }, item_0.name);
        }
        return hideStatusColumn ? /*#__PURE__*/jsx(Row, {
          children: nameCell
        }, item_0.name) : /*#__PURE__*/jsxs(Row, {
          children: [statusCell, nameCell]
        }, item_0.name);
      }
    })]
  });
}
function getItemPath(basePath, collection, key) {
  return `${basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(key)}`;
}
function useDebouncedValue(value, t0) {
  const $ = c(4);
  const delay = t0 === undefined ? 300 : t0;
  const [debouncedValue, setDebouncedValue] = useState(value);
  let t1;
  let t2;
  if ($[0] !== value || $[1] !== delay) {
    t1 = () => {
      const timer = setTimeout(() => setDebouncedValue(value), delay);
      return () => {
        clearTimeout(timer);
      };
    };
    t2 = [value, delay];
    $[0] = value;
    $[1] = delay;
    $[2] = t1;
    $[3] = t2;
  } else {
    t1 = $[2];
    t2 = $[3];
  }
  useEffect(t1, t2);
  return debouncedValue;
}

function getYjsValFromParsedValue(schema, value) {
  if (schema.kind === 'form') {
    if (schema.formKind === 'content' && schema.collaboration) {
      return schema.collaboration.toYjs(value);
    }
    return value;
  }
  if (schema.kind === 'child') {
    return null;
  }
  if (schema.kind === 'object') {
    return new Y.Map(Object.entries(schema.fields).map(([key, val]) => [key, getYjsValFromParsedValue(val, value[key])]));
  }
  if (schema.kind === 'array') {
    const arr = new Y.Array();
    arr.push(value.map(val => getYjsValFromParsedValue(schema.element, val)));
    return arr;
  }
  if (schema.kind === 'conditional') {
    const discriminant = value.discriminant;
    return new Y.Map([['discriminant', discriminant], ['value', getYjsValFromParsedValue(schema.values[discriminant + ''], value.value)]]);
  }
  assertNever(schema);
}
function yjsToVal(schema, awareness, yjsValue) {
  if (schema.kind === 'form') {
    if (schema.formKind === 'content' && schema.collaboration) {
      return schema.collaboration.fromYjs(yjsValue, awareness);
    }
    return yjsValue;
  }
  if (schema.kind === 'child') {
    return null;
  }
  if (schema.kind === 'object') {
    return Object.fromEntries(Object.entries(schema.fields).map(([key, val]) => [key, yjsToVal(val, awareness, yjsValue.get(key))]));
  }
  if (schema.kind === 'array') {
    const yArr = yjsValue;
    if (!yArr) {
      debugger;
    }
    const val = yArr.map(val => yjsToVal(schema.element, awareness, val));
    setKeysForArrayValue(val, getKeysForArrayValue(yArr));
    return val;
  }
  if (schema.kind === 'conditional') {
    const yjsMap = yjsValue;
    return {
      discriminant: yjsToVal(schema.discriminant, awareness, yjsMap.get('discriminant')),
      value: yjsToVal(schema.values[yjsMap.get('discriminant') + ''], awareness, yjsMap.get('value'))
    };
  }
}
function parsedValToYjs(schema, value) {
  if (schema.kind === 'form' || schema.kind === 'child') {
    return value;
  }
  if (schema.kind === 'object') {
    return new Y.Map(Object.entries(schema.fields).map(([key, val]) => [key, parsedValToYjs(val, value[key])]));
  }
  if (schema.kind === 'array') {
    const arr = new Y.Array();
    arr.push(value.map(val => parsedValToYjs(schema.element, val)));
    return arr;
  }
  if (schema.kind === 'conditional') {
    const discriminant = value.discriminant;
    return new Y.Map([['discriminant', discriminant], ['value', parsedValToYjs(schema.values[discriminant.toString()], value.value)]]);
  }
}

const AppSlugContext = /*#__PURE__*/createContext(undefined);
const AppSlugProvider = AppSlugContext.Provider;
function InstallGitHubApp(props) {
  const $ = c(18);
  const router = useRouter();
  const appSlugFromContext = useContext(AppSlugContext);
  let t0;
  if ($[0] !== router.href || $[1] !== appSlugFromContext) {
    var _URL$searchParams$get;
    t0 = (_URL$searchParams$get = new URL(router.href, "https://example.com").searchParams.get("slug")) !== null && _URL$searchParams$get !== void 0 ? _URL$searchParams$get : appSlugFromContext === null || appSlugFromContext === void 0 ? void 0 : appSlugFromContext.value;
    $[0] = router.href;
    $[1] = appSlugFromContext;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const appSlug = t0;
  let t1;
  if ($[3] !== props.config.storage.repo) {
    t1 = parseRepoConfig(props.config.storage.repo);
    $[3] = props.config.storage.repo;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const parsedRepo = t1;
  let t2;
  if ($[5] !== parsedRepo.name) {
    t2 = /*#__PURE__*/jsx(TextField, {
      label: "Repo Name",
      width: "100%",
      isReadOnly: true,
      value: parsedRepo.name
    });
    $[5] = parsedRepo.name;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== parsedRepo.name) {
    t3 = /*#__PURE__*/jsx(ActionButton, {
      onPress: () => {
        navigator.clipboard.writeText(parsedRepo.name);
      },
      children: "Copy Repo Name"
    });
    $[7] = parsedRepo.name;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== t2 || $[10] !== t3) {
    t4 = /*#__PURE__*/jsxs(Flex, {
      alignItems: "end",
      gap: "regular",
      children: [t2, t3]
    });
    $[9] = t2;
    $[10] = t3;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] !== appSlug || $[13] !== appSlugFromContext) {
    t5 = appSlug ? /*#__PURE__*/jsx(Button, {
      prominence: "high",
      href: `https://github.com/apps/${appSlug}/installations/new`,
      children: "Install GitHub App"
    }) : /*#__PURE__*/jsx(Notice, {
      tone: "caution",
      children: appSlugFromContext ? /*#__PURE__*/jsxs(Text, {
        children: ["The ", /*#__PURE__*/jsx("code", {
          children: appSlugFromContext.envName
        }), " environment variable wasn't provided so we can't link to the GitHub app installation page. You should find the App on GitHub and add the repo yourself."]
      }) : /*#__PURE__*/jsx(Text, {
        children: "Find the App on GitHub and add the repo."
      })
    });
    $[12] = appSlug;
    $[13] = appSlugFromContext;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  let t6;
  if ($[15] !== t4 || $[16] !== t5) {
    t6 = /*#__PURE__*/jsxs(Flex, {
      direction: "column",
      gap: "regular",
      children: [t4, t5]
    });
    $[15] = t4;
    $[16] = t5;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  return t6;
}

function ForkRepoDialog(props) {
  const stringFormatter = useLocalizedStringFormatter(strings);
  const client = useClient();
  const [state, setState] = useState({
    kind: 'idle'
  });
  useEffect(() => {
    const listener = async event => {
      if (event.key === 'ks-refetch-installations' && event.newValue === 'true') {
        localStorage.removeItem('ks-refetch-installations');
        try {
          var _res$data;
          const auth = await getAuth(props.config);
          if (!auth) throw new Error('Unauthorized');
          const res = await client.query(GitHubAppShellQuery, parseRepoConfig(props.config.storage.repo)).toPromise();
          if ((_res$data = res.data) !== null && _res$data !== void 0 && (_res$data = _res$data.repository) !== null && _res$data !== void 0 && (_res$data = _res$data.forks.nodes) !== null && _res$data !== void 0 && _res$data.some(x => (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'ADMIN' || (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'WRITE' || (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'MAINTAIN')) {
            await new Promise(resolve => setTimeout(resolve, 100));
            props.onCreate();
          }
        } catch (err) {
          setState({
            kind: 'error',
            error: err
          });
        }
      }
    };
    addEventListener('storage', listener);
    return () => removeEventListener('storage', listener);
  }, [client, props]);
  const appSlug = useContext(AppSlugContext);
  return /*#__PURE__*/jsxs(Dialog, {
    size: "small",
    isDismissable: true,
    onDismiss: () => {
      props.onDismiss();
    },
    children: [/*#__PURE__*/jsx(Heading, {
      children: "Fork Repo"
    }), state.kind === 'error' ? /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Content, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: state.error.message
        })
      }), /*#__PURE__*/jsx(ButtonGroup, {
        children: /*#__PURE__*/jsx(Button, {
          onPress: props.onDismiss,
          children: stringFormatter.format('cancel')
        })
      })]
    }) : /*#__PURE__*/jsx(Fragment, {
      children: /*#__PURE__*/jsx(Content, {
        children: /*#__PURE__*/jsxs(Flex, {
          gap: "large",
          direction: "column",
          marginBottom: "large",
          children: [/*#__PURE__*/jsx(Text, {
            children: "You don't have permission to write to this repo so to save your changes, you need to fork the repo."
          }), /*#__PURE__*/jsxs(Text, {
            children: ["To start,", ' ', /*#__PURE__*/jsx(TextLink, {
              href: `https://github.com/${serializeRepoConfig(props.config.storage.repo)}/fork`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "fork the repo on GitHub"
            }), ". Then, come back to this page and", ' ', /*#__PURE__*/jsx(TextLink, {
              href: `https://github.com/apps/${appSlug === null || appSlug === void 0 ? void 0 : appSlug.value}/installations/new?state=close`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "install the Keystatic GitHub App on your fork."
            })]
          })]
        })
      })
    })]
  });
}

const HeaderBreadcrumbs = /*#__PURE__*/memo(props => {
  const $ = c(5);
  let t0;
  if ($[0] !== props.items) {
    let t1;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = item => /*#__PURE__*/jsx(Item, {
        href: item.href,
        children: item.label
      }, item.key);
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    t0 = props.items.map(t1);
    $[0] = props.items;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[3] !== t0) {
    t1 = /*#__PURE__*/jsx(Breadcrumbs, {
      flex: true,
      size: "medium",
      minWidth: "alias.singleLineWidth",
      children: t0
    });
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
});

function useSlugFieldInfo(collection, slugToExclude) {
  const $ = c(10);
  const config = useConfig();
  const allSlugs = useSlugsInCollection(collection);
  let t0;
  let slugs;
  if ($[0] !== allSlugs || $[1] !== slugToExclude) {
    slugs = new Set(allSlugs);
    if (slugToExclude) {
      slugs.delete(slugToExclude);
    }
    $[0] = allSlugs;
    $[1] = slugToExclude;
    $[2] = slugs;
  } else {
    slugs = $[2];
  }
  const collectionConfig = config.collections[collection];
  let t1;
  if ($[3] !== config || $[4] !== collection) {
    t1 = getSlugGlobForCollection(config, collection);
    $[3] = config;
    $[4] = collection;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== collectionConfig.slugField || $[7] !== slugs || $[8] !== t1) {
    t2 = {
      field: collectionConfig.slugField,
      slugs,
      glob: t1
    };
    $[6] = collectionConfig.slugField;
    $[7] = slugs;
    $[8] = t1;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  t0 = t2;
  return t0;
}

function PresenceAvatars() {
  const $ = c(7);
  const cloudInfo = useCloudInfo();
  const awarenessStates = useAwarenessStates();
  const router = useRouter();
  if (!cloudInfo) {
    return null;
  }
  let t0;
  if ($[0] !== awarenessStates) {
    t0 = awarenessStates.values();
    $[0] = awarenessStates;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== t0) {
    t1 = [...t0];
    $[2] = t0;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== router.href || $[5] !== t1) {
    t2 = /*#__PURE__*/jsx(HStack, {
      children: t1.map(val => {
        if (!val.user || router.href !== `/keystatic/branch/${val.branch}/${val.location}`) {
          return null;
        }
        return /*#__PURE__*/jsx(Avatar, {
          src: val.user.avatarUrl,
          name: val.user.name
        });
      })
    });
    $[4] = router.href;
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}

injectGlobal({
  body: {
    overflow: 'hidden'
  }
});
function createUrqlClient(config) {
  const repo = config.storage.kind === 'github' ? parseRepoConfig(config.storage.repo) : {
    owner: 'repo-owner',
    name: 'repo-name'
  };
  return createClient({
    url: config.storage.kind === 'github' ? 'https://api.github.com/graphql' : `${KEYSTATIC_CLOUD_API_URL}/v1/github/graphql`,
    requestPolicy: 'cache-and-network',
    exchanges: [authExchange(async utils => {
      let authState = await getAuth(config);
      return {
        addAuthToOperation(operation) {
          authState = getSyncAuth(config);
          if (!authState) {
            return operation;
          }
          return utils.appendHeaders(operation, {
            Authorization: `Bearer ${authState.accessToken}`,
            ...(config.storage.kind === 'cloud' ? KEYSTATIC_CLOUD_HEADERS : {})
          });
        },
        didAuthError() {
          return false;
        },
        willAuthError(operation) {
          var _operation$query$defi;
          authState = getSyncAuth(config);
          if (operation.query.definitions[0].kind === 'OperationDefinition' && (_operation$query$defi = operation.query.definitions[0].name) !== null && _operation$query$defi !== void 0 && _operation$query$defi.value.includes('AppShell') && !authState) {
            if (config.storage.kind === 'github') {
              window.location.href = '/api/keystatic/github/login';
            } else {
              redirectToCloudAuth('', config);
            }
            return true;
          }
          if (!authState) {
            return true;
          }
          return false;
        },
        async refreshAuth() {
          authState = await getAuth(config);
        }
      };
    }), cacheExchange({
      resolvers: {
        Repository: {
          refs: relayPagination()
        }
      },
      updates: {
        Mutation: {
          createRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === 'github' ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, data => {
              var _data$repository;
              if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && (_data$repository = _data$repository.refs) !== null && _data$repository !== void 0 && _data$repository.nodes && result.createRef && typeof result.createRef === 'object' && 'ref' in result.createRef) {
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: [...data.repository.refs.nodes, result.createRef.ref]
                    }
                  }
                };
              }
              return data;
            });
          },
          deleteRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === 'github' ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, data => {
              var _data$repository2;
              if (data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && (_data$repository2 = _data$repository2.refs) !== null && _data$repository2 !== void 0 && _data$repository2.nodes && result.deleteRef && typeof result.deleteRef === 'object' && '__typename' in result.deleteRef && typeof args.input === 'object' && args.input !== null && 'refId' in args.input && typeof args.input.refId === 'string') {
                const refId = args.input.refId;
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: data.repository.refs.nodes.filter(x => (x === null || x === void 0 ? void 0 : x.id) !== refId)
                    }
                  }
                };
              }
              return data;
            });
          }
        }
      }
    }), ...(config.storage.kind === 'github' ? [] : [persistedExchange({
      enableForMutation: true,
      enforcePersistedQueries: true
    })]), fetchExchange]
  });
}
function Provider(t0) {
  const $ = c(19);
  const {
    children,
    config
  } = t0;
  const themeContext = useTheme();
  const {
    push: navigate
  } = useRouter();
  let t1;
  let t2;
  if ($[0] !== navigate) {
    t2 = {
      navigate
    };
    $[0] = navigate;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const keystarRouter = t1;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /*#__PURE__*/jsx("meta", {
      name: "viewport",
      content: "width=device-width, initial-scale=1"
    });
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  const t4 = config.locale || "en-US";
  let t5;
  let t6;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /*#__PURE__*/jsx(ClientSideOnlyDocumentElement, {
      bodyBackground: "surface"
    });
    t6 = /*#__PURE__*/jsx("link", {
      href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap",
      rel: "stylesheet"
    });
    $[3] = t5;
    $[4] = t6;
  } else {
    t5 = $[3];
    t6 = $[4];
  }
  let t7;
  let t8;
  if ($[5] !== config) {
    t8 = createUrqlClient(config);
    $[5] = config;
    $[6] = t8;
  } else {
    t8 = $[6];
  }
  t7 = t8;
  let t9;
  if ($[7] !== t7 || $[8] !== children) {
    t9 = /*#__PURE__*/jsx(Provider$1, {
      value: t7,
      children: children
    });
    $[7] = t7;
    $[8] = children;
    $[9] = t9;
  } else {
    t9 = $[9];
  }
  let t10;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = /*#__PURE__*/jsx(Toaster, {});
    $[10] = t10;
  } else {
    t10 = $[10];
  }
  let t11;
  if ($[11] !== t4 || $[12] !== themeContext.theme || $[13] !== keystarRouter || $[14] !== t9) {
    t11 = /*#__PURE__*/jsxs(KeystarProvider, {
      locale: t4,
      colorScheme: themeContext.theme,
      router: keystarRouter,
      children: [t5, t6, t9, t10]
    });
    $[11] = t4;
    $[12] = themeContext.theme;
    $[13] = keystarRouter;
    $[14] = t9;
    $[15] = t11;
  } else {
    t11 = $[15];
  }
  let t12;
  if ($[16] !== themeContext || $[17] !== t11) {
    t12 = /*#__PURE__*/jsxs(ThemeProvider, {
      value: themeContext,
      children: [t3, t11]
    });
    $[16] = themeContext;
    $[17] = t11;
    $[18] = t12;
  } else {
    t12 = $[18];
  }
  return t12;
}

const textEncoder = new TextEncoder();
const frontmatterSplit = textEncoder.encode('---\n');
function combineFrontmatterAndContents(frontmatter, contents) {
  const array = new Uint8Array(frontmatter.byteLength + contents.byteLength + frontmatterSplit.byteLength * 2);
  array.set(frontmatterSplit);
  array.set(frontmatter, frontmatterSplit.byteLength);
  array.set(frontmatterSplit, frontmatterSplit.byteLength + frontmatter.byteLength);
  array.set(contents, frontmatterSplit.byteLength * 2 + frontmatter.byteLength);
  return array;
}
function serializeEntryToFiles(args) {
  var _args$slug, _args$slug2;
  let {
    value: stateWithExtraFilesRemoved,
    extraFiles
  } = serializeProps(args.state, object(args.schema), (_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field, (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.value, true);
  const dataFormat = args.format.data;
  let dataContent = textEncoder.encode(dataFormat === 'json' ? JSON.stringify(stateWithExtraFilesRemoved, null, 2) + '\n' : dump(stateWithExtraFilesRemoved));
  if (args.format.contentField) {
    const filename = `${args.format.contentField.path.join('/')}${args.format.contentField.contentExtension}`;
    let contents;
    extraFiles = extraFiles.filter(x => {
      if (x.path !== filename) return true;
      contents = x.contents;
      return false;
    });
    assert(contents !== undefined, 'Expected content field to be present');
    dataContent = combineFrontmatterAndContents(dataContent, contents);
  }
  return [{
    path: getEntryDataFilepath(args.basePath, args.format),
    contents: dataContent
  }, ...extraFiles.map(file => ({
    path: `${file.parent ? args.slug ? `${file.parent}/${args.slug.value}` : file.parent : args.basePath}/${file.path}`,
    contents: file.contents
  }))];
}
function useUpsertItem(args) {
  const [state, setState] = useState({
    kind: 'idle'
  });
  const baseCommit = useBaseCommit();
  const currentBranch = useCurrentBranch();
  const setTreeSha = useSetTreeSha();
  const [, mutate] = useMutation(createCommitMutation);
  const repoInfo = useRepoInfo();
  const appSlug = useContext(AppSlugContext);
  const unscopedTreeData = useCurrentUnscopedTree();
  return [state, async override => {
    try {
      var _getPathPrefix, _args$initialFiles;
      const unscopedTree = unscopedTreeData.kind === 'loaded' ? unscopedTreeData.data.tree : undefined;
      if (!unscopedTree) return false;
      if (args.config.storage.kind === 'github' && repoInfo && !repoInfo.hasWritePermission && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: 'needs-fork'
        });
        return false;
      }
      setState({
        kind: 'loading'
      });
      const pathPrefix = (_getPathPrefix = getPathPrefix(args.config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : '';
      let additions = serializeEntryToFiles({
        basePath: args.basePath,
        schema: args.schema,
        format: args.format,
        state: args.state,
        slug: args.slug
      }).map(addition => ({
        ...addition,
        path: pathPrefix + addition.path
      }));
      const additionPathToSha = new Map(await Promise.all(additions.map(async addition_0 => [addition_0.path, await hydrateBlobCache(addition_0.contents)])));
      const filesToDelete = new Set((_args$initialFiles = args.initialFiles) === null || _args$initialFiles === void 0 ? void 0 : _args$initialFiles.map(x => pathPrefix + x));
      for (const file of additions) {
        filesToDelete.delete(file.path);
      }
      additions = additions.filter(addition_1 => {
        const sha = additionPathToSha.get(addition_1.path);
        const existing = getTreeNodeAtPath(unscopedTree, addition_1.path);
        return (existing === null || existing === void 0 ? void 0 : existing.entry.sha) !== sha;
      });
      const deletions = [...filesToDelete].map(path => ({
        path
      }));
      const updatedTree = await updateTreeWithChanges(unscopedTree, {
        additions,
        deletions: [...filesToDelete]
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.config.storage.kind === 'github' || args.config.storage.kind === 'cloud') {
        var _override$branch, _override$sha, _result$error, _result$error2, _result$data;
        if (!repoInfo) {
          throw new Error('Repo info not loaded');
        }
        const branch = {
          branchName: (_override$branch = override === null || override === void 0 ? void 0 : override.branch) !== null && _override$branch !== void 0 ? _override$branch : currentBranch,
          repositoryNameWithOwner: `${repoInfo.owner}/${repoInfo.name}`
        };
        const runMutation = expectedHeadOid => mutate({
          input: {
            branch,
            expectedHeadOid,
            message: {
              headline: `Update ${args.basePath}`
            },
            fileChanges: {
              additions: additions.map(addition_2 => ({
                ...addition_2,
                contents: base64Encode(addition_2.contents)
              })),
              deletions
            }
          }
        });
        let result = await runMutation((_override$sha = override === null || override === void 0 ? void 0 : override.sha) !== null && _override$sha !== void 0 ? _override$sha : baseCommit);
        const gqlError = (_result$error = result.error) === null || _result$error === void 0 || (_result$error = _result$error.graphQLErrors[0]) === null || _result$error === void 0 ? void 0 : _result$error.originalError;
        if (gqlError && 'type' in gqlError) {
          if (gqlError.type === 'BRANCH_PROTECTION_RULE_VIOLATION') {
            setState({
              kind: 'needs-new-branch',
              reason: 'Changes must be made via pull request to this branch. Create a new branch to save changes.'
            });
            return false;
          }
          if (gqlError.type === 'STALE_DATA') {
            var _refData$data, _args$slug3;
            // we don't want this to go into the cache yet
            // so we create a new client just for this
            const refData = await createUrqlClient(args.config).query(FetchRef, {
              owner: repoInfo.owner,
              name: repoInfo.name,
              ref: `refs/heads/${currentBranch}`
            }).toPromise();
            if (!((_refData$data = refData.data) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.repository) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.ref) !== null && _refData$data !== void 0 && _refData$data.target)) {
              throw new Error('Branch not found');
            }
            const tree = scopeEntriesWithPathPrefix(await fetchGitHubTreeData(refData.data.repository.ref.target.oid, args.config), args.config);
            const treeKey = getTreeKey(getDirectoriesForTreeKey(object(args.schema), args.basePath, (_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.value, args.format), tree.tree);
            if (treeKey === args.currentLocalTreeKey) {
              result = await runMutation(refData.data.repository.ref.target.oid);
            } else {
              setState({
                kind: 'needs-new-branch',
                reason: 'This entry has been updated since it was opened. Create a new branch to save changes.'
              });
              return false;
            }
          }
        }
        if ((_result$error2 = result.error) !== null && _result$error2 !== void 0 && _result$error2.graphQLErrors.some(err_0 => 'type' in err_0 && err_0.type === 'FORBIDDEN' && err_0.message === 'Resource not accessible by integration')) {
          throw new Error(`The GitHub App is unable to commit to the repository. Please ensure that the Keystatic GitHub App is installed in the GitHub repository ${repoInfo.owner}/${repoInfo.name}`);
        }
        if (result.error) {
          throw result.error;
        }
        const target = (_result$data = result.data) === null || _result$data === void 0 || (_result$data = _result$data.createCommitOnBranch) === null || _result$data === void 0 || (_result$data = _result$data.ref) === null || _result$data === void 0 ? void 0 : _result$data.target;
        if (target) {
          setState({
            kind: 'updated'
          });
          return true;
        }
        throw new Error('Failed to update');
      } else {
        const res = await fetch('/api/keystatic/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'no-cors': '1'
          },
          body: JSON.stringify({
            additions: additions.map(addition_3 => ({
              ...addition_3,
              contents: base64Encode(addition_3.contents)
            })),
            deletions
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree: tree_0
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree_0));
        setState({
          kind: 'updated'
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: 'error',
        error: err
      });
      return false;
    }
  }, () => {
    setState({
      kind: 'idle'
    });
  }];
}
const createCommitMutation = gql`
  mutation CreateCommit($input: CreateCommitOnBranchInput!) {
    createCommitOnBranch(input: $input) {
      ref {
        id
        target {
          id
          oid
          ... on Commit {
            tree {
              id
              oid
            }
          }
        }
      }
    }
  }
`;
function useDeleteItem(args) {
  const [state, setState] = useState({
    kind: 'idle'
  });
  const baseCommit = useBaseCommit();
  const currentBranch = useCurrentBranch();
  const [, mutate] = useMutation(createCommitMutation);
  const setTreeSha = useSetTreeSha();
  const repoInfo = useRepoInfo();
  const appSlug = useContext(AppSlugContext);
  const unscopedTreeData = useCurrentUnscopedTree();
  return [state, async () => {
    try {
      const unscopedTree = unscopedTreeData.kind === 'loaded' ? unscopedTreeData.data.tree : undefined;
      if (!unscopedTree) return false;
      if (args.storage.kind === 'github' && repoInfo && !repoInfo.hasWritePermission && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: 'needs-fork'
        });
        return false;
      }
      setState({
        kind: 'loading'
      });
      const deletions = args.initialFiles.map(x => {
        var _getPathPrefix2;
        return ((_getPathPrefix2 = getPathPrefix(args.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : '') + x;
      });
      const updatedTree = await updateTreeWithChanges(unscopedTree, {
        additions: [],
        deletions
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.storage.kind === 'github' || args.storage.kind === 'cloud') {
        if (!repoInfo) {
          throw new Error('Repo info not loaded');
        }
        const {
          error
        } = await mutate({
          input: {
            branch: {
              repositoryNameWithOwner: `${repoInfo.owner}/${repoInfo.name}`,
              branchName: currentBranch
            },
            message: {
              headline: `Delete ${args.basePath}`
            },
            expectedHeadOid: baseCommit,
            fileChanges: {
              deletions: deletions.map(path => ({
                path
              }))
            }
          }
        });
        if (error !== null && error !== void 0 && error.graphQLErrors.some(err_0 => 'type' in err_0 && err_0.type === 'FORBIDDEN' && err_0.message === 'Resource not accessible by integration')) {
          throw new Error(`The GitHub App is unable to commit to the repository. Please ensure that the Keystatic GitHub App is installed in the GitHub repository ${repoInfo.owner}/${repoInfo.name}`);
        }
        if (error) {
          throw error;
        }
        setState({
          kind: 'updated'
        });
        return true;
      } else {
        const res = await fetch('/api/keystatic/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'no-cors': '1'
          },
          body: JSON.stringify({
            additions: [],
            deletions: deletions.map(path_0 => ({
              path: path_0
            }))
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: 'updated'
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: 'error',
        error: err
      });
    }
  }, () => {
    setState({
      kind: 'idle'
    });
  }];
}
const FetchRef = gql`
  query FetchRef($owner: String!, $name: String!, $ref: String!) {
    repository(owner: $owner, name: $name) {
      id
      ref(qualifiedName: $ref) {
        id
        target {
          id
          oid
        }
      }
    }
  }
`;

function useHasChanged(args) {
  const $ = c(9);
  let t0;
  if ($[0] !== args.slugField || $[1] !== args.schema) {
    t0 = async state => {
      const slug = args.slugField ? getSlugFromState({
        schema: args.schema.fields,
        slugField: args.slugField
      }, state) : undefined;
      const serializedState = serializeProps(state, args.schema, args.slugField, slug, true);
      return {
        slug,
        value: serializedState.value,
        extraFiles: Object.fromEntries(await Promise.all(serializedState.extraFiles.map(async val => [JSON.stringify([val.path, val.parent]), await blobSha(val.contents)])))
      };
    };
    $[0] = args.slugField;
    $[1] = args.schema;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const serialize = t0;
  let t1;
  if ($[3] !== args.initialState || $[4] !== serialize) {
    t1 = () => args.initialState === null ? null : serialize(args.initialState);
    $[3] = args.initialState;
    $[4] = serialize;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const initialFilesForUpdate = useData(t1);
  let t2;
  if ($[6] !== serialize || $[7] !== args.state) {
    t2 = () => serialize(args.state);
    $[6] = serialize;
    $[7] = args.state;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const filesForUpdate = useData(t2);
  let t3;
  bb0: {
    if (initialFilesForUpdate.kind === "loaded" && filesForUpdate.kind === "loaded") {
      const a = initialFilesForUpdate.data;
      const b = filesForUpdate.data;
      t3 = !isEqual(a, b);
      break bb0;
    }
    t3 = "unknown";
  }
  const hasChangedState = t3;
  const [hasChanged, setHasChanged] = useState(false);
  if (typeof hasChangedState === "boolean" && hasChangedState !== hasChanged) {
    setHasChanged(hasChangedState);
  }
  return hasChanged;
}

function useYJsValue(schema, type) {
  const $ = c(14);
  const yjsInfo = useYjs();
  let t0;
  let lastVal;
  if ($[0] !== schema || $[1] !== yjsInfo.awareness || $[2] !== type) {
    lastVal = yjsToVal(schema, yjsInfo.awareness, type);
    $[0] = schema;
    $[1] = yjsInfo.awareness;
    $[2] = type;
    $[3] = lastVal;
  } else {
    lastVal = $[3];
  }
  const t1 = lastVal;
  let t2;
  if ($[4] !== t1) {
    t2 = () => lastVal;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const t3 = lastVal;
  let t4;
  if ($[6] !== t3 || $[7] !== schema || $[8] !== yjsInfo.awareness || $[9] !== type) {
    t4 = cb => {
      const handler = () => {
        lastVal = yjsToVal(schema, yjsInfo.awareness, type);
        cb();
      };
      type.observeDeep(handler);
      return () => {
        type.unobserveDeep(handler);
      };
    };
    $[6] = t3;
    $[7] = schema;
    $[8] = yjsInfo.awareness;
    $[9] = type;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== t2 || $[12] !== t4) {
    t5 = {
      getSnapshot: t2,
      subscribe: t4
    };
    $[11] = t2;
    $[12] = t4;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  t0 = t5;
  const thing = t0;
  return useSyncExternalStore(thing.subscribe, thing.getSnapshot, thing.getSnapshot);
}

// this is written like this rather than ArrayField<ComponentSchema> to avoid TypeScript erroring about circularity

function castToMemoizedInfoForSchema(val) {
  return val;
}
function getOrInsert(map, key, val) {
  if (!map.has(key)) {
    map.set(key, val(key));
  }
  return map.get(key);
}
function findSingleReorderedElement(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) return;
  const sortedOldKeys = [...oldKeys].sort();
  const sortedNewKeys = [...newKeys].sort();
  if (sortedOldKeys.join() !== sortedNewKeys.join()) return;
  let reorderedKey;
  for (let i = 0; i < oldKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      if (reorderedKey === newKeys[i]) continue;
      if (reorderedKey !== undefined) return;
      reorderedKey = oldKeys[i];
    }
  }
  return reorderedKey;
}
function createGetPreviewPropsFromY(rootSchema, yMap, awareness) {
  const memoizedInfoForSchema = castToMemoizedInfoForSchema({
    form(schema, onChange) {
      return onChange;
    },
    array(schema, onChange) {
      return {
        rawOnChange: onChange,
        inner: new Map(),
        onChange(updater) {
          const yArr = onChange.yjs();
          const oldVal = yjsToVal(schema, awareness, yArr);
          const oldKeys = getKeysForArrayValue(yArr);
          const uniqueKeys = new Set();
          for (const x of updater) {
            if (x.key !== undefined) {
              if (uniqueKeys.has(x.key)) {
                throw new Error('Array elements must have unique keys');
              }
              uniqueKeys.add(x.key);
            }
          }
          const newKeys = updater.map(x => {
            if (x.key !== undefined) return x.key;
            let elementKey = getNewArrayElementKey();
            // just in case someone gives a key that is above our counter
            while (uniqueKeys.has(elementKey)) {
              elementKey = getNewArrayElementKey();
            }
            uniqueKeys.add(elementKey);
            return elementKey;
          });
          setKeysForArrayValue(yArr, newKeys);
          // optimise for the case where a single element has been re-ordered (drag and drop)
          const reorderedKey = findSingleReorderedElement(oldKeys, newKeys);
          if (reorderedKey !== undefined) {
            const oldIndex = oldKeys.indexOf(reorderedKey);
            const newIndex = newKeys.indexOf(reorderedKey);
            let val = yArr.get(oldIndex);
            if (val instanceof Y.AbstractType) {
              val = val.clone();
            }
            yArr.delete(oldIndex);
            yArr.insert(newIndex, [val]);
            for (const [idx, {
              value
            }] of updater.entries()) {
              const oldIndex = oldKeys.indexOf(newKeys[idx]);
              const newVal = updateValue(schema.element, oldVal[oldIndex], value);
              if (newVal !== oldVal) {
                yArr.delete(oldIndex);
                yArr.insert(idx, [parsedValToYjs(schema.element, newVal)]);
              }
            }
            return;
          }

          // optimise only updating values + added new elements at the end
          const oldKeysJoined = oldKeys.join();
          const newKeysJoined = newKeys.slice(0, oldKeys.length).join();
          if (oldKeysJoined === newKeysJoined) {
            for (const [idx, {
              value
            }] of updater.entries()) {
              const oldIndex = oldKeys.indexOf(newKeys[idx]);
              const newVal = updateValue(schema.element, oldVal[oldIndex], value);
              if (newVal !== oldVal) {
                yArr.delete(oldIndex);
                yArr.insert(idx, [parsedValToYjs(schema.element, newVal)]);
              }
            }
            const valsToInsert = [];
            for (const {
              value
            } of updater.slice(oldKeys.length)) {
              valsToInsert.push(parsedValToYjs(schema.element, getInitialPropsValueFromInitializer(schema.element, value)));
            }
            if (valsToInsert.length) {
              yArr.insert(oldKeys.length, valsToInsert);
            }
            return;
          }
          // for anything else, just replace the whole array

          const newVals = updater.map((x, i) => {
            const key = newKeys[i];
            const oldIndex = oldKeys.indexOf(key);
            if (oldIndex !== -1) {
              const oldElement = yArr.get(oldIndex);
              if (x.value === undefined) {
                if (oldElement instanceof Y.AbstractType) {
                  return oldElement.clone();
                }
                return oldElement;
              }
              const newVal = updateValue(schema.element, oldVal[oldIndex], x.value);
              return parsedValToYjs(schema.element, newVal);
            }
            return parsedValToYjs(schema.element, getInitialPropsValueFromInitializer(schema.element, x.value));
          });
          yArr.delete(0, yArr.length);
          yArr.insert(0, newVals);
        }
      };
    },
    conditional(schema, stateUpdater) {
      return {
        onChange: (discriminant, value) => {
          stateUpdater.yjs().set('discriminant', discriminant);
          if (value !== undefined) {
            const old = yjsToVal(schema, awareness, stateUpdater.yjs().get('value'));
            stateUpdater.yjs().set('value', parsedValToYjs(schema, updateValue(schema.values[discriminant.toString()], old, value)));
          }
        },
        onChangeForValue: Object.assign(cb => {
          const old = yjsToVal(schema, awareness, stateUpdater.yjs().get('value'));
          stateUpdater.yjs().set('value', parsedValToYjs(schema, cb(old)));
        }, {
          yjs() {
            return stateUpdater.yjs().get('value');
          }
        })
      };
    },
    object(schema, stateUpdater) {
      return {
        onChange: updater => {
          for (const [key, val] of Object.entries(updater)) {
            const oldVal = yjsToVal(schema.fields[key], awareness, stateUpdater.yjs().get(key));
            stateUpdater.yjs().set(key, parsedValToYjs(schema.fields[key], updateValue(schema.fields[key], oldVal, val)));
          }
        },
        innerOnChanges: Object.fromEntries(Object.entries(schema.fields).map(([key, val]) => {
          let func = Object.assign(newVal => {
            stateUpdater.yjs().set(key, parsedValToYjs(val, newVal));
          }, {
            yjs() {
              return stateUpdater.yjs().get(key);
            }
          });
          return [key, func];
        }))
      };
    }
  });
  const previewPropsFactories = {
    form(schema, value, onChange) {
      return {
        value,
        onChange,
        schema: schema
      };
    },
    object(schema, value, memoized, path, getInnerProp) {
      const fields = {};
      for (const key of Object.keys(schema.fields)) {
        fields[key] = getInnerProp(schema.fields[key], value[key], memoized.innerOnChanges[key], key);
      }
      const previewProps = {
        fields,
        onChange: memoized.onChange,
        schema: schema
      };
      return previewProps;
    },
    array(schema, value, memoized, path, getInnerProp) {
      const arrayValue = value;
      const keys = getKeysForArrayValue(arrayValue);
      const unusedKeys = new Set(getKeysForArrayValue(value));
      const props = {
        elements: arrayValue.map((val, i) => {
          const key = keys[i];
          unusedKeys.delete(key);
          const element = getOrInsert(memoized.inner, key, () => {
            const onChange = Object.assign(val => {
              const yArr = memoized.rawOnChange.yjs();
              const keys = getKeysForArrayValue(yArr);
              const index = keys.indexOf(key);
              const newVal = val(yjsToVal(schema, awareness, yArr.get(index)));
              yArr.delete(index);
              yArr.insert(index, [parsedValToYjs(schema.element, newVal)]);
            }, {
              yjs() {
                const keys = getKeysForArrayValue(memoized.rawOnChange.yjs());
                const i = keys.indexOf(key);
                return memoized.rawOnChange.yjs().get(i);
              }
            });
            const element = getInnerProp(schema.element, val, onChange, key);
            return {
              element,
              elementWithKey: {
                ...element,
                key
              },
              onChange
            };
          });
          const currentInnerProp = getInnerProp(schema.element, val, element.onChange, key);
          if (element.element !== currentInnerProp) {
            element.element = currentInnerProp;
            element.elementWithKey = {
              ...currentInnerProp,
              key
            };
          }
          return element.elementWithKey;
        }),
        schema: schema,
        onChange: memoized.onChange
      };
      for (const key of unusedKeys) {
        memoized.inner.delete(key);
      }
      return props;
    },
    conditional(schema, value, memoized, path, getInnerProp) {
      const props = {
        discriminant: value.discriminant,
        onChange: memoized.onChange,
        value: getInnerProp(schema.values[value.discriminant.toString()], value.value, memoized.onChangeForValue, 'value'),
        schema: schema
      };
      return props;
    }
  };
  function getPreviewPropsForProp(schema, value, memoedThing, path, getInnerProp) {
    return previewPropsFactories[schema.kind](schema, value, memoedThing, path, getInnerProp);
  }
  function getInitialMemoState(schema, value, stateUpdater, path) {
    const innerState = new Map();
    const memoizedInfo = memoizedInfoForSchema[schema.kind](schema, stateUpdater);
    const state = {
      value,
      inner: innerState,
      props: getPreviewPropsForProp(schema, value, memoizedInfo, path, (schema, value, onChange, key) => {
        const state = getInitialMemoState(schema, value, onChange, path.concat(key));
        innerState.set(key, state);
        return state.props;
      }),
      schema: schema,
      cached: memoizedInfo
    };
    return state;
  }
  function getUpToDateProps(schema, value, stateUpdater, memoState, path) {
    if (memoState.schema !== schema) {
      Object.assign(memoState, getInitialMemoState(schema, value, stateUpdater, path));
      return memoState.props;
    }
    if (memoState.value === value) {
      return memoState.props;
    }
    memoState.value = value;
    const unusedKeys = new Set(memoState.inner.keys());
    memoState.props = getPreviewPropsForProp(schema, value, memoState.cached, path, (schema, value, onChange, innerMemoStateKey) => {
      unusedKeys.delete(innerMemoStateKey);
      if (!memoState.inner.has(innerMemoStateKey)) {
        const innerState = getInitialMemoState(schema, value, onChange, path.concat(innerMemoStateKey));
        memoState.inner.set(innerMemoStateKey, innerState);
        return innerState.props;
      }
      return getUpToDateProps(schema, value, onChange, memoState.inner.get(innerMemoStateKey), path.concat(innerMemoStateKey));
    });
    for (const key of unusedKeys) {
      memoState.inner.delete(key);
    }
    return memoState.props;
  }
  let memoState;
  const rootUpdater = Object.assign(cb => {
    const newValue = cb(memoState.value);
    const innerYMap = parsedValToYjs(rootSchema, newValue);
    for (const [key, val] of innerYMap.entries()) {
      innerYMap.delete(key);
      yMap.set(key, val);
    }
  }, {
    yjs() {
      return yMap;
    }
  });
  return value => {
    if (memoState === undefined) {
      memoState = getInitialMemoState(rootSchema, value, rootUpdater, []);
      return memoState.props;
    }
    return getUpToDateProps(rootSchema, value, rootUpdater, memoState, []);
  };
}

function usePreviewProps(schema, setState, state) {
  return useMemo(() => createGetPreviewProps(schema, setState, () => undefined), [schema, setState])(state);
}
function usePreviewPropsFromY(schema, map, state) {
  const yjsInfo = useYjs();
  return useMemo(() => createGetPreviewPropsFromY(schema, map, yjsInfo.awareness), [map, schema, yjsInfo.awareness])(state);
}
function useCollection(collection) {
  const $ = c(5);
  const config = useConfig();
  const collectionConfig = config.collections[collection];
  let t0;
  let t1;
  if ($[0] !== collectionConfig.schema) {
    t1 = {
      kind: "object",
      fields: collectionConfig.schema
    };
    $[0] = collectionConfig.schema;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const schema = t0;
  let t2;
  if ($[2] !== schema || $[3] !== collectionConfig) {
    t2 = {
      schema,
      collectionConfig
    };
    $[2] = schema;
    $[3] = collectionConfig;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}
function useSingleton(singleton) {
  const $ = c(5);
  const config = useConfig();
  const singletonConfig = config.singletons[singleton];
  let t0;
  let t1;
  if ($[0] !== singletonConfig.schema) {
    t1 = {
      kind: "object",
      fields: singletonConfig.schema
    };
    $[0] = singletonConfig.schema;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const schema = t0;
  let t2;
  if ($[2] !== schema || $[3] !== singletonConfig) {
    t2 = {
      schema,
      singletonConfig
    };
    $[2] = schema;
    $[3] = singletonConfig;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: null
    };
  }
  static getDerivedStateFromError(err) {
    if (isNotFoundError(err)) {
      throw err;
    }
    return {
      message: String(err)
    };
  }
  render() {
    if (this.state.message) {
      return typeof this.props.fallback === 'function' ? this.props.fallback(this.state.message) : this.props.fallback;
    }
    return this.props.children;
  }
}

const keystaticEntryAttributeSchema = s.type({
  slug: s.optional(s.string()),
  files: s.record(s.string(), s.coerce(s.instance(Uint8Array), s.string(), value => base64UrlDecode(value)))
});
const textDecoder = new TextDecoder();
function parseEntryFromHtml(html, format, schema, slugField) {
  const parsedHtml = new DOMParser().parseFromString(html, 'text/html');
  const pre = parsedHtml.querySelector('pre');
  if (!(pre !== null && pre !== void 0 && pre.dataset.keystaticEntry)) {
    return;
  }
  try {
    var _entryInfo$slug, _entryInfo$slug2;
    const parsed = JSON.parse(pre.dataset.keystaticEntry);
    const entryInfo = keystaticEntryAttributeSchema.create(parsed);
    const files = new Map(Object.entries(entryInfo.files));
    return parseEntry({
      dirpath: (_entryInfo$slug = entryInfo.slug) !== null && _entryInfo$slug !== void 0 ? _entryInfo$slug : 'entry',
      format,
      schema,
      slug: slugField ? {
        field: slugField,
        slug: (_entryInfo$slug2 = entryInfo.slug) !== null && _entryInfo$slug2 !== void 0 ? _entryInfo$slug2 : ''
      } : undefined,
      requireFrontmatter: true
    }, files).initialState;
  } catch {}
}
function parseEntryFromPlaintext(bytes, format, schema, slugInfo) {
  try {
    var _slugInfo$slug;
    const dirpath = (_slugInfo$slug = slugInfo === null || slugInfo === void 0 ? void 0 : slugInfo.slug) !== null && _slugInfo$slug !== void 0 ? _slugInfo$slug : 'entry';
    return parseEntry({
      dirpath,
      format,
      schema,
      slug: slugInfo,
      requireFrontmatter: true
    }, new Map([[getEntryDataFilepath(dirpath, format), bytes]])).initialState;
  } catch {}
}
async function getPastedEntry(format, schema, slugInfo) {
  let clipboardItems;
  try {
    // TODO: maybe explore alternative UI for this with an input
    // and instructing users to paste there so the permission is not needed
    clipboardItems = await navigator.clipboard.read();
  } catch (err) {
    if (err instanceof DOMException && err.name === 'NotAllowedError') {
      toastQueue.critical('Failed to paste because clipboard access was denied', {
        timeout: 5000
      });
      return;
    }
    toastQueue.critical('Failed to read clipboard', {
      timeout: 5000
    });
    return;
  }
  for (const item of clipboardItems) {
    if (item.types.includes('text/html')) {
      const html = await item.getType('text/html');
      const text = await html.text();
      const entry = parseEntryFromHtml(text, format, schema, slugInfo === null || slugInfo === void 0 ? void 0 : slugInfo.field);
      if (entry) {
        return entry;
      }
    }
    if (item.types.includes('text/plain')) {
      const plain = await item.getType('text/plain');
      const text = await plain.arrayBuffer();
      const entry = parseEntryFromPlaintext(new Uint8Array(text), format, schema, slugInfo);
      if (entry) {
        return entry;
      }
    }
  }
  toastQueue.critical('Entry not found in clipboard', {
    timeout: 5000
  });
}
function serializeEntryForClipboard(state, format, schema, slug) {
  var _slug$value;
  const basePath = (_slug$value = slug === null || slug === void 0 ? void 0 : slug.value) !== null && _slug$value !== void 0 ? _slug$value : 'entry';
  const files = serializeEntryToFiles({
    basePath,
    format,
    schema,
    slug,
    state
  });
  const element = document.createElement('pre');
  element.dataset.keystaticEntry = JSON.stringify({
    slug: slug === null || slug === void 0 ? void 0 : slug.value,
    files: Object.fromEntries(files.map(f => [f.path, base64UrlEncode(f.contents)]))
  });
  const mainEntryFilepath = getEntryDataFilepath(basePath, format);
  const mainFile = files.find(f => f.path === mainEntryFilepath);
  if (!mainFile) {
    throw new Error('No main entry file found');
  }
  const plain = textDecoder.decode(mainFile.contents);
  element.textContent = plain;
  return {
    html: element.outerHTML,
    plain
  };
}
function copyEntryToClipboard(state, format, schema, slug) {
  const out = serializeEntryForClipboard(state, format, schema, slug);
  navigator.clipboard.write([new ClipboardItem({
    'text/plain': new Blob([out.plain], {
      type: 'text/plain'
    }),
    'text/html': new Blob([out.html], {
      type: 'text/html'
    })
  })]);
}

const storedValSchema$2 = s.type({
  version: s.literal(1),
  savedAt: s.date(),
  slug: s.string(),
  beforeTreeKey: s.string(),
  files: s.map(s.string(), s.instance(Uint8Array))
});
function ItemPageInner(props) {
  var _getPathPrefix, _getPathPrefix2;
  const $ = c(115);
  const {
    collection,
    config,
    itemSlug,
    updateResult,
    onUpdate: parentOnUpdate
  } = props;
  const {
    collectionConfig,
    schema
  } = useCollection(collection);
  const router = useRouter();
  const baseCommit = useBaseCommit();
  let t0;
  if ($[0] !== config || $[1] !== collection || $[2] !== itemSlug) {
    t0 = getCollectionItemPath(config, collection, itemSlug);
    $[0] = config;
    $[1] = collection;
    $[2] = itemSlug;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  const currentBasePath = t0;
  let t1;
  if ($[4] !== config || $[5] !== collection) {
    t1 = getCollectionFormat(config, collection);
    $[4] = config;
    $[5] = collection;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  const formatInfo = t1;
  const currentBranch = useCurrentBranch();
  const repoInfo = useRepoInfo();
  const [forceValidation, setForceValidation] = useState(false);
  let t2;
  if ($[7] !== collectionConfig.previewUrl || $[8] !== props || $[9] !== currentBranch) {
    t2 = collectionConfig.previewUrl ? collectionConfig.previewUrl.replace("{slug}", props.itemSlug).replace("{branch}", currentBranch) : undefined;
    $[7] = collectionConfig.previewUrl;
    $[8] = props;
    $[9] = currentBranch;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const previewHref = t2;
  const {
    push,
    replace
  } = router;
  const slugInfo = useSlugFieldInfo(collection, itemSlug);
  let t3;
  if ($[11] !== props.initialFiles || $[12] !== config.storage || $[13] !== currentBasePath) {
    t3 = {
      initialFiles: props.initialFiles,
      storage: config.storage,
      basePath: currentBasePath
    };
    $[11] = props.initialFiles;
    $[12] = config.storage;
    $[13] = currentBasePath;
    $[14] = t3;
  } else {
    t3 = $[14];
  }
  const [deleteResult, deleteItem, resetDeleteItem] = useDeleteItem(t3);
  let t4;
  if ($[15] !== deleteItem || $[16] !== push || $[17] !== props.basePath || $[18] !== collection) {
    t4 = async () => {
      if (await deleteItem()) {
        push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
      }
    };
    $[15] = deleteItem;
    $[16] = push;
    $[17] = props.basePath;
    $[18] = collection;
    $[19] = t4;
  } else {
    t4 = $[19];
  }
  const onDelete = useEventCallback(t4);
  let t5;
  if ($[20] !== push || $[21] !== props.basePath || $[22] !== collection || $[23] !== itemSlug) {
    t5 = () => {
      push(`${props.basePath}/collection/${encodeURIComponent(collection)}/create?duplicate=${itemSlug}`);
    };
    $[20] = push;
    $[21] = props.basePath;
    $[22] = collection;
    $[23] = itemSlug;
    $[24] = t5;
  } else {
    t5 = $[24];
  }
  const onDuplicate = t5;
  const isSavingDisabled = updateResult.kind === "loading" || !props.hasChanged;
  let t6;
  if ($[25] !== isSavingDisabled || $[26] !== schema || $[27] !== props.state || $[28] !== props.basePath || $[29] !== slugInfo || $[30] !== collectionConfig || $[31] !== parentOnUpdate || $[32] !== itemSlug || $[33] !== replace || $[34] !== collection) {
    t6 = async () => {
      if (isSavingDisabled) {
        return false;
      }
      if (!clientSideValidateProp(schema, props.state, slugInfo)) {
        setForceValidation(true);
        return false;
      }
      const slug = getSlugFromState(collectionConfig, props.state);
      const hasUpdated = await parentOnUpdate();
      if (hasUpdated && slug !== itemSlug) {
        replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug)}`);
      }
      return hasUpdated;
    };
    $[25] = isSavingDisabled;
    $[26] = schema;
    $[27] = props.state;
    $[28] = props.basePath;
    $[29] = slugInfo;
    $[30] = collectionConfig;
    $[31] = parentOnUpdate;
    $[32] = itemSlug;
    $[33] = replace;
    $[34] = collection;
    $[35] = t6;
  } else {
    t6 = $[35];
  }
  const onUpdate = useEventCallback(t6);
  let t7;
  if ($[36] !== props.state || $[37] !== formatInfo || $[38] !== collectionConfig) {
    t7 = () => {
      copyEntryToClipboard(props.state, formatInfo, collectionConfig.schema, {
        field: collectionConfig.slugField,
        value: getSlugFromState(collectionConfig, props.state)
      });
    };
    $[36] = props.state;
    $[37] = formatInfo;
    $[38] = collectionConfig;
    $[39] = t7;
  } else {
    t7 = $[39];
  }
  const onCopy = useEventCallback(t7);
  let t8;
  if ($[40] !== formatInfo || $[41] !== collectionConfig || $[42] !== props.state || $[43] !== props.previewProps) {
    t8 = async () => {
      const entry = await getPastedEntry(formatInfo, collectionConfig.schema, {
        field: collectionConfig.slugField,
        slug: getSlugFromState(collectionConfig, props.state)
      });
      if (entry) {
        setValueToPreviewProps(entry, props.previewProps);
        toastQueue.positive("Entry pasted", {
          shouldCloseOnAction: true,
          actionLabel: "Undo",
          onAction: () => {
            setValueToPreviewProps(props.state, props.previewProps);
          }
        });
      }
    };
    $[40] = formatInfo;
    $[41] = collectionConfig;
    $[42] = props.state;
    $[43] = props.previewProps;
    $[44] = t8;
  } else {
    t8 = $[44];
  }
  const onPaste = useEventCallback(t8);
  const viewHref = config.storage.kind !== "local" && repoInfo ? `${getRepoUrl(repoInfo)}${formatInfo.dataLocation === "index" ? `/tree/${currentBranch}/${(_getPathPrefix = getPathPrefix(config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${currentBasePath}` : `/blob/${currentBranch}/${(_getPathPrefix2 = getPathPrefix(config.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : ""}${currentBasePath}${getDataFileExtension(formatInfo)}`}` : undefined;
  let t9;
  let t10;
  if ($[45] !== updateResult.kind || $[46] !== onUpdate) {
    t9 = () => {
      const listener = event => {
        if (updateResult.kind === "loading") {
          return;
        }
        if (isHotkey("mod+s", event)) {
          event.preventDefault();
          onUpdate();
        }
      };
      document.addEventListener("keydown", listener);
      return () => document.removeEventListener("keydown", listener);
    };
    t10 = [updateResult.kind, onUpdate];
    $[45] = updateResult.kind;
    $[46] = onUpdate;
    $[47] = t9;
    $[48] = t10;
  } else {
    t9 = $[47];
    t10 = $[48];
  }
  useEffect(t9, t10);
  const t11 = updateResult.kind === "loading";
  let t12;
  if ($[49] !== t11 || $[50] !== props.hasChanged || $[51] !== props.onReset || $[52] !== onDelete || $[53] !== onDuplicate || $[54] !== onCopy || $[55] !== onPaste || $[56] !== viewHref || $[57] !== previewHref) {
    t12 = /*#__PURE__*/jsx(HeaderActions, {
      formID: "item-edit-form",
      isLoading: t11,
      hasChanged: props.hasChanged,
      onDelete: onDelete,
      onDuplicate: onDuplicate,
      onCopy: onCopy,
      onPaste: onPaste,
      onReset: props.onReset,
      viewHref: viewHref,
      previewHref: previewHref
    });
    $[49] = t11;
    $[50] = props.hasChanged;
    $[51] = props.onReset;
    $[52] = onDelete;
    $[53] = onDuplicate;
    $[54] = onCopy;
    $[55] = onPaste;
    $[56] = viewHref;
    $[57] = previewHref;
    $[58] = t12;
  } else {
    t12 = $[58];
  }
  let t13;
  if ($[59] !== updateResult) {
    t13 = updateResult.kind === "error" && /*#__PURE__*/jsx(Notice, {
      tone: "critical",
      children: updateResult.error.message
    });
    $[59] = updateResult;
    $[60] = t13;
  } else {
    t13 = $[60];
  }
  let t14;
  if ($[61] !== deleteResult) {
    t14 = deleteResult.kind === "error" && /*#__PURE__*/jsx(Notice, {
      tone: "critical",
      children: deleteResult.error.message
    });
    $[61] = deleteResult;
    $[62] = t14;
  } else {
    t14 = $[62];
  }
  let t15;
  if ($[63] !== onUpdate) {
    t15 = event_0 => {
      if (event_0.target !== event_0.currentTarget) {
        return;
      }
      event_0.preventDefault();
      onUpdate();
    };
    $[63] = onUpdate;
    $[64] = t15;
  } else {
    t15 = $[64];
  }
  const t16 = props.previewProps;
  let t17;
  if ($[65] !== t16 || $[66] !== forceValidation || $[67] !== collectionConfig.entryLayout || $[68] !== formatInfo || $[69] !== slugInfo) {
    t17 = /*#__PURE__*/jsx(FormForEntry, {
      previewProps: t16,
      forceValidation: forceValidation,
      entryLayout: collectionConfig.entryLayout,
      formatInfo: formatInfo,
      slugField: slugInfo
    });
    $[65] = t16;
    $[66] = forceValidation;
    $[67] = collectionConfig.entryLayout;
    $[68] = formatInfo;
    $[69] = slugInfo;
    $[70] = t17;
  } else {
    t17 = $[70];
  }
  let t18;
  if ($[71] !== t15 || $[72] !== t17) {
    t18 = /*#__PURE__*/jsx(Box, {
      id: "item-edit-form",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      elementType: "form",
      onSubmit: t15,
      children: t17
    });
    $[71] = t15;
    $[72] = t17;
    $[73] = t18;
  } else {
    t18 = $[73];
  }
  let t19;
  if ($[74] !== updateResult || $[75] !== collection || $[76] !== router || $[77] !== itemSlug || $[78] !== collectionConfig || $[79] !== props || $[80] !== parentOnUpdate || $[81] !== baseCommit) {
    t19 = updateResult.kind === "needs-new-branch" && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
      branchOid: baseCommit,
      onCreate: async newBranch => {
        const itemBasePath = `/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(collection)}/item/`;
        router.push(itemBasePath + encodeURIComponent(itemSlug));
        const slug_0 = getSlugFromState(collectionConfig, props.state);
        const hasUpdated_0 = await parentOnUpdate({
          branch: newBranch,
          sha: baseCommit
        });
        if (hasUpdated_0 && slug_0 !== itemSlug) {
          router.replace(itemBasePath + encodeURIComponent(slug_0));
        }
      },
      reason: updateResult.reason,
      onDismiss: props.onResetUpdateItem
    });
    $[74] = updateResult;
    $[75] = collection;
    $[76] = router;
    $[77] = itemSlug;
    $[78] = collectionConfig;
    $[79] = props;
    $[80] = parentOnUpdate;
    $[81] = baseCommit;
    $[82] = t19;
  } else {
    t19 = $[82];
  }
  let t20;
  if ($[83] !== props.onResetUpdateItem || $[84] !== t19) {
    t20 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: props.onResetUpdateItem,
      children: t19
    });
    $[83] = props.onResetUpdateItem;
    $[84] = t19;
    $[85] = t20;
  } else {
    t20 = $[85];
  }
  let t21;
  if ($[86] !== updateResult.kind || $[87] !== props || $[88] !== collectionConfig || $[89] !== itemSlug || $[90] !== router || $[91] !== collection) {
    t21 = updateResult.kind === "needs-fork" && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
      onCreate: async () => {
        const slug_1 = getSlugFromState(collectionConfig, props.state);
        const hasUpdated_1 = await props.onUpdate();
        if (hasUpdated_1 && slug_1 !== itemSlug) {
          router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug_1)}`);
        }
      },
      onDismiss: props.onResetUpdateItem,
      config: props.config
    });
    $[86] = updateResult.kind;
    $[87] = props;
    $[88] = collectionConfig;
    $[89] = itemSlug;
    $[90] = router;
    $[91] = collection;
    $[92] = t21;
  } else {
    t21 = $[92];
  }
  let t22;
  if ($[93] !== props.onResetUpdateItem || $[94] !== t21) {
    t22 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: props.onResetUpdateItem,
      children: t21
    });
    $[93] = props.onResetUpdateItem;
    $[94] = t21;
    $[95] = t22;
  } else {
    t22 = $[95];
  }
  let t23;
  if ($[96] !== deleteResult.kind || $[97] !== props || $[98] !== deleteItem || $[99] !== router || $[100] !== collection || $[101] !== resetDeleteItem) {
    t23 = deleteResult.kind === "needs-fork" && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
      onCreate: async () => {
        await deleteItem();
        router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
      },
      onDismiss: resetDeleteItem,
      config: props.config
    });
    $[96] = deleteResult.kind;
    $[97] = props;
    $[98] = deleteItem;
    $[99] = router;
    $[100] = collection;
    $[101] = resetDeleteItem;
    $[102] = t23;
  } else {
    t23 = $[102];
  }
  let t24;
  if ($[103] !== resetDeleteItem || $[104] !== t23) {
    t24 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: resetDeleteItem,
      children: t23
    });
    $[103] = resetDeleteItem;
    $[104] = t23;
    $[105] = t24;
  } else {
    t24 = $[105];
  }
  let t25;
  if ($[106] !== t12 || $[107] !== props || $[108] !== t13 || $[109] !== t14 || $[110] !== t18 || $[111] !== t20 || $[112] !== t22 || $[113] !== t24) {
    t25 = /*#__PURE__*/jsx(Fragment, {
      children: /*#__PURE__*/jsxs(ItemPageShell, {
        headerActions: t12,
        ...props,
        children: [t13, t14, t18, t20, t22, t24]
      })
    });
    $[106] = t12;
    $[107] = props;
    $[108] = t13;
    $[109] = t14;
    $[110] = t18;
    $[111] = t20;
    $[112] = t22;
    $[113] = t24;
    $[114] = t25;
  } else {
    t25 = $[114];
  }
  return t25;
}
function LocalItemPage(props) {
  var _draft$state;
  const $ = c(64);
  const {
    collection,
    config,
    initialFiles,
    initialState,
    localTreeKey,
    draft
  } = props;
  const {
    collectionConfig,
    schema
  } = useCollection(collection);
  const t0 = (_draft$state = draft === null || draft === void 0 ? void 0 : draft.state) !== null && _draft$state !== void 0 ? _draft$state : initialState;
  let t1;
  if ($[0] !== t0 || $[1] !== localTreeKey) {
    t1 = {
      state: t0,
      localTreeKey
    };
    $[0] = t0;
    $[1] = localTreeKey;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const [t2, setState] = useState(t1);
  const {
    state,
    localTreeKey: localTreeKeyInState
  } = t2;
  useShowRestoredDraftMessage(draft, state, localTreeKey);
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      state: initialState,
      localTreeKey
    });
  }
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = stateUpdater => {
      setState(state_0 => ({
        localTreeKey: state_0.localTreeKey,
        state: stateUpdater(state_0.state)
      }));
    };
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const onPreviewPropsChange = t3;
  const previewProps = usePreviewProps(schema, onPreviewPropsChange, state);
  let t4;
  if ($[4] !== initialState || $[5] !== schema || $[6] !== state || $[7] !== collectionConfig.slugField) {
    t4 = {
      initialState,
      schema,
      state,
      slugField: collectionConfig.slugField
    };
    $[4] = initialState;
    $[5] = schema;
    $[6] = state;
    $[7] = collectionConfig.slugField;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const hasChanged = useHasChanged(t4);
  let t5;
  let slug;
  let formatInfo;
  if ($[9] !== collectionConfig || $[10] !== state || $[11] !== config || $[12] !== collection) {
    slug = getSlugFromState(collectionConfig, state);
    let t6;
    if ($[16] !== config || $[17] !== collection) {
      t6 = getCollectionFormat(config, collection);
      $[16] = config;
      $[17] = collection;
      $[18] = t6;
    } else {
      t6 = $[18];
    }
    formatInfo = t6;
    t5 = getCollectionItemPath(config, collection, slug);
    $[9] = collectionConfig;
    $[10] = state;
    $[11] = config;
    $[12] = collection;
    $[13] = t5;
    $[14] = slug;
    $[15] = formatInfo;
  } else {
    t5 = $[13];
    slug = $[14];
    formatInfo = $[15];
  }
  const futureBasePath = t5;
  let t6;
  if ($[19] !== collectionConfig.slugField || $[20] !== slug) {
    t6 = {
      field: collectionConfig.slugField,
      value: slug
    };
    $[19] = collectionConfig.slugField;
    $[20] = slug;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  let t7;
  if ($[22] !== state || $[23] !== initialFiles || $[24] !== config || $[25] !== collectionConfig.schema || $[26] !== futureBasePath || $[27] !== formatInfo || $[28] !== localTreeKey || $[29] !== t6) {
    t7 = {
      state,
      initialFiles,
      config,
      schema: collectionConfig.schema,
      basePath: futureBasePath,
      format: formatInfo,
      currentLocalTreeKey: localTreeKey,
      slug: t6
    };
    $[22] = state;
    $[23] = initialFiles;
    $[24] = config;
    $[25] = collectionConfig.schema;
    $[26] = futureBasePath;
    $[27] = formatInfo;
    $[28] = localTreeKey;
    $[29] = t6;
    $[30] = t7;
  } else {
    t7 = $[30];
  }
  const [updateResult, _update, resetUpdateItem] = useUpsertItem(t7);
  let t8;
  if ($[31] !== collection || $[32] !== props.itemSlug || $[33] !== hasChanged || $[34] !== futureBasePath || $[35] !== config || $[36] !== collectionConfig.schema || $[37] !== collectionConfig.slugField || $[38] !== slug || $[39] !== state || $[40] !== localTreeKey) {
    t8 = () => {
      const key = ["collection", collection, props.itemSlug];
      if (hasChanged) {
        const serialized = serializeEntryToFiles({
          basePath: futureBasePath,
          format: getCollectionFormat(config, collection),
          schema: collectionConfig.schema,
          slug: {
            field: collectionConfig.slugField,
            value: slug
          },
          state
        });
        const files = new Map(serialized.map(x => [x.path, x.contents]));
        const data = {
          beforeTreeKey: localTreeKey,
          slug,
          files,
          savedAt: new Date(),
          version: 1
        };
        setDraft(key, data);
      } else {
        delDraft(key);
      }
    };
    $[31] = collection;
    $[32] = props.itemSlug;
    $[33] = hasChanged;
    $[34] = futureBasePath;
    $[35] = config;
    $[36] = collectionConfig.schema;
    $[37] = collectionConfig.slugField;
    $[38] = slug;
    $[39] = state;
    $[40] = localTreeKey;
    $[41] = t8;
  } else {
    t8 = $[41];
  }
  let t9;
  if ($[42] !== collection || $[43] !== collectionConfig || $[44] !== config || $[45] !== futureBasePath || $[46] !== localTreeKey || $[47] !== props.itemSlug || $[48] !== slug || $[49] !== state || $[50] !== hasChanged) {
    t9 = [collection, collectionConfig, config, futureBasePath, localTreeKey, props.itemSlug, slug, state, hasChanged];
    $[42] = collection;
    $[43] = collectionConfig;
    $[44] = config;
    $[45] = futureBasePath;
    $[46] = localTreeKey;
    $[47] = props.itemSlug;
    $[48] = slug;
    $[49] = state;
    $[50] = hasChanged;
    $[51] = t9;
  } else {
    t9 = $[51];
  }
  useEffect(t8, t9);
  const update = useEventCallback(_update);
  let t10;
  if ($[52] !== initialState || $[53] !== localTreeKey) {
    t10 = () => {
      setState({
        state: initialState,
        localTreeKey
      });
    };
    $[52] = initialState;
    $[53] = localTreeKey;
    $[54] = t10;
  } else {
    t10 = $[54];
  }
  const onReset = t10;
  let t11;
  if ($[55] !== props || $[56] !== update || $[57] !== onReset || $[58] !== updateResult || $[59] !== resetUpdateItem || $[60] !== previewProps || $[61] !== state || $[62] !== hasChanged) {
    t11 = /*#__PURE__*/jsx(ItemPageInner, {
      ...props,
      onUpdate: update,
      onReset: onReset,
      updateResult: updateResult,
      onResetUpdateItem: resetUpdateItem,
      previewProps: previewProps,
      state: state,
      hasChanged: hasChanged
    });
    $[55] = props;
    $[56] = update;
    $[57] = onReset;
    $[58] = updateResult;
    $[59] = resetUpdateItem;
    $[60] = previewProps;
    $[61] = state;
    $[62] = hasChanged;
    $[63] = t11;
  } else {
    t11 = $[63];
  }
  return t11;
}
function CollabItemPage(props) {
  const $ = c(33);
  const {
    collection,
    config,
    initialFiles,
    initialState,
    localTreeKey
  } = props;
  const {
    collectionConfig,
    schema
  } = useCollection(collection);
  const state = useYJsValue(schema, props.map);
  const previewProps = usePreviewPropsFromY(schema, props.map, state);
  const slug = getSlugFromState(collectionConfig, state);
  let t0;
  if ($[0] !== props.config || $[1] !== props.collection) {
    t0 = getCollectionFormat(props.config, props.collection);
    $[0] = props.config;
    $[1] = props.collection;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const formatInfo = t0;
  let t1;
  if ($[3] !== initialState || $[4] !== schema || $[5] !== state || $[6] !== collectionConfig.slugField) {
    t1 = {
      initialState,
      schema,
      state,
      slugField: collectionConfig.slugField
    };
    $[3] = initialState;
    $[4] = schema;
    $[5] = state;
    $[6] = collectionConfig.slugField;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const hasChanged = useHasChanged(t1);
  const futureBasePath = getCollectionItemPath(config, collection, slug);
  let t2;
  if ($[8] !== collectionConfig.slugField || $[9] !== slug) {
    t2 = {
      field: collectionConfig.slugField,
      value: slug
    };
    $[8] = collectionConfig.slugField;
    $[9] = slug;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  let t3;
  if ($[11] !== state || $[12] !== initialFiles || $[13] !== config || $[14] !== collectionConfig.schema || $[15] !== futureBasePath || $[16] !== formatInfo || $[17] !== localTreeKey || $[18] !== t2) {
    t3 = {
      state,
      initialFiles,
      config,
      schema: collectionConfig.schema,
      basePath: futureBasePath,
      format: formatInfo,
      currentLocalTreeKey: localTreeKey,
      slug: t2
    };
    $[11] = state;
    $[12] = initialFiles;
    $[13] = config;
    $[14] = collectionConfig.schema;
    $[15] = futureBasePath;
    $[16] = formatInfo;
    $[17] = localTreeKey;
    $[18] = t2;
    $[19] = t3;
  } else {
    t3 = $[19];
  }
  const [updateResult, _update, resetUpdateItem] = useUpsertItem(t3);
  const update = useEventCallback(_update);
  let t4;
  if ($[20] !== props.map || $[21] !== props.initialState || $[22] !== collectionConfig.schema) {
    t4 = () => {
      var _props$map$doc;
      (_props$map$doc = props.map.doc) === null || _props$map$doc === void 0 || _props$map$doc.transact(() => {
        for (const [key, value] of Object.entries(collectionConfig.schema)) {
          const val = getYjsValFromParsedValue(value, props.initialState[key]);
          props.map.set(key, val);
        }
      });
    };
    $[20] = props.map;
    $[21] = props.initialState;
    $[22] = collectionConfig.schema;
    $[23] = t4;
  } else {
    t4 = $[23];
  }
  const onReset = t4;
  let t5;
  if ($[24] !== props || $[25] !== update || $[26] !== onReset || $[27] !== updateResult || $[28] !== resetUpdateItem || $[29] !== previewProps || $[30] !== state || $[31] !== hasChanged) {
    t5 = /*#__PURE__*/jsx(ItemPageInner, {
      ...props,
      onUpdate: update,
      onReset: onReset,
      updateResult: updateResult,
      onResetUpdateItem: resetUpdateItem,
      previewProps: previewProps,
      state: state,
      hasChanged: hasChanged
    });
    $[24] = props;
    $[25] = update;
    $[26] = onReset;
    $[27] = updateResult;
    $[28] = resetUpdateItem;
    $[29] = previewProps;
    $[30] = state;
    $[31] = hasChanged;
    $[32] = t5;
  } else {
    t5 = $[32];
  }
  return t5;
}
function HeaderActions(props) {
  const $ = c(55);
  const {
    formID,
    hasChanged,
    isLoading,
    onDelete,
    onDuplicate,
    onReset,
    onCopy,
    onPaste,
    previewHref,
    viewHref
  } = props;
  const isBelowDesktop = useMediaQuery(breakpointQueries.below.desktop);
  const stringFormatter = useLocalizedStringFormatter(strings);
  const [deleteAlertIsOpen, setDeleteAlertOpen] = useState(false);
  const [duplicateAlertIsOpen, setDuplicateAlertOpen] = useState(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      key: "reset",
      label: "Reset changes",
      icon: historyIcon
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = {
      key: "delete",
      label: "Delete entry\u2026",
      icon: trash2Icon
    };
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      key: "copy",
      label: "Copy entry",
      icon: clipboardCopyIcon
    };
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  let t4;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      key: "paste",
      label: "Paste entry",
      icon: clipboardPasteIcon
    };
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      key: "duplicate",
      label: "Duplicate entry\u2026",
      icon: copyPlusIcon
    };
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  let items;
  if ($[5] !== previewHref || $[6] !== viewHref) {
    items = [t1, t2, t3, t4, t5];
    if (previewHref) {
      let t6;
      if ($[8] !== previewHref) {
        t6 = {
          key: "preview",
          label: "Preview",
          icon: externalLinkIcon,
          href: previewHref,
          target: "_blank",
          rel: "noopener noreferrer"
        };
        $[8] = previewHref;
        $[9] = t6;
      } else {
        t6 = $[9];
      }
      items.push(t6);
    }
    if (viewHref) {
      let t6;
      if ($[10] !== viewHref) {
        t6 = {
          key: "view",
          label: "View on GitHub",
          icon: githubIcon,
          href: viewHref,
          target: "_blank",
          rel: "noopener noreferrer"
        };
        $[10] = viewHref;
        $[11] = t6;
      } else {
        t6 = $[11];
      }
      items.push(t6);
    }
    $[5] = previewHref;
    $[6] = viewHref;
    $[7] = items;
  } else {
    items = $[7];
  }
  t0 = items;
  const menuActions = t0;
  let t6;
  bb0: {
    if (isLoading) {
      let t7;
      if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
        t7 = /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": "Saving changes",
          isIndeterminate: true,
          size: "small",
          alignSelf: "center"
        });
        $[12] = t7;
      } else {
        t7 = $[12];
      }
      t6 = t7;
      break bb0;
    }
    if (hasChanged) {
      let t7;
      if ($[13] !== isBelowDesktop) {
        t7 = isBelowDesktop ? /*#__PURE__*/jsx(Box, {
          backgroundColor: "pendingEmphasis",
          height: "scale.75",
          width: "scale.75",
          borderRadius: "full",
          children: /*#__PURE__*/jsx(Text, {
            visuallyHidden: true,
            children: "Unsaved"
          })
        }) : /*#__PURE__*/jsx(Badge, {
          tone: "pending",
          children: "Unsaved"
        });
        $[13] = isBelowDesktop;
        $[14] = t7;
      } else {
        t7 = $[14];
      }
      t6 = t7;
      break bb0;
    }
    t6 = null;
  }
  const indicatorElement = t6;
  let t7;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = {
      mobile: "small",
      tablet: "regular"
    };
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  let t8;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /*#__PURE__*/jsx(PresenceAvatars, {});
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  const t9 = isBelowDesktop ? "element.regular" : undefined;
  let t10;
  if ($[17] !== hasChanged) {
    t10 = hasChanged ? [] : ["reset"];
    $[17] = hasChanged;
    $[18] = t10;
  } else {
    t10 = $[18];
  }
  let t11;
  if ($[19] !== onReset || $[20] !== onCopy || $[21] !== onPaste || $[22] !== hasChanged || $[23] !== onDuplicate) {
    t11 = key => {
      bb28: switch (key) {
        case "reset":
          {
            onReset();
            break bb28;
          }
        case "delete":
          {
            setDeleteAlertOpen(true);
            break bb28;
          }
        case "copy":
          {
            onCopy();
            break bb28;
          }
        case "paste":
          {
            onPaste();
            break bb28;
          }
        case "duplicate":
          {
            if (hasChanged) {
              setDuplicateAlertOpen(true);
            } else {
              onDuplicate();
            }
          }
      }
    };
    $[19] = onReset;
    $[20] = onCopy;
    $[21] = onPaste;
    $[22] = hasChanged;
    $[23] = onDuplicate;
    $[24] = t11;
  } else {
    t11 = $[24];
  }
  let t12;
  if ($[25] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = item => /*#__PURE__*/jsxs(Item$1, {
      textValue: item.label,
      href: item.href,
      target: item.target,
      rel: item.rel,
      children: [/*#__PURE__*/jsx(Icon, {
        src: item.icon
      }), /*#__PURE__*/jsx(Text, {
        children: item.label
      })]
    }, item.key);
    $[25] = t12;
  } else {
    t12 = $[25];
  }
  let t13;
  if ($[26] !== t9 || $[27] !== menuActions || $[28] !== t10 || $[29] !== t11) {
    t13 = /*#__PURE__*/jsx(ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: t9,
      items: menuActions,
      disabledKeys: t10,
      onAction: t11,
      children: t12
    });
    $[26] = t9;
    $[27] = menuActions;
    $[28] = t10;
    $[29] = t11;
    $[30] = t13;
  } else {
    t13 = $[30];
  }
  let t14;
  if ($[31] !== stringFormatter) {
    t14 = stringFormatter.format("save");
    $[31] = stringFormatter;
    $[32] = t14;
  } else {
    t14 = $[32];
  }
  let t15;
  if ($[33] !== formID || $[34] !== isLoading || $[35] !== t14) {
    t15 = /*#__PURE__*/jsx(Button, {
      form: formID,
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      children: t14
    });
    $[33] = formID;
    $[34] = isLoading;
    $[35] = t14;
    $[36] = t15;
  } else {
    t15 = $[36];
  }
  let t16;
  if ($[37] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = () => setDeleteAlertOpen(false);
    $[37] = t16;
  } else {
    t16 = $[37];
  }
  let t17;
  if ($[38] !== deleteAlertIsOpen || $[39] !== onDelete) {
    t17 = deleteAlertIsOpen && /*#__PURE__*/jsx(AlertDialog, {
      title: "Delete entry",
      tone: "critical",
      cancelLabel: "Cancel",
      primaryActionLabel: "Yes, delete",
      autoFocusButton: "cancel",
      onPrimaryAction: onDelete,
      children: "Are you sure? This action cannot be undone."
    });
    $[38] = deleteAlertIsOpen;
    $[39] = onDelete;
    $[40] = t17;
  } else {
    t17 = $[40];
  }
  let t18;
  if ($[41] !== t17) {
    t18 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: t16,
      children: t17
    });
    $[41] = t17;
    $[42] = t18;
  } else {
    t18 = $[42];
  }
  let t19;
  if ($[43] === Symbol.for("react.memo_cache_sentinel")) {
    t19 = () => setDuplicateAlertOpen(false);
    $[43] = t19;
  } else {
    t19 = $[43];
  }
  let t20;
  if ($[44] !== duplicateAlertIsOpen || $[45] !== onDuplicate) {
    t20 = duplicateAlertIsOpen && /*#__PURE__*/jsx(AlertDialog, {
      title: "Save and duplicate entry",
      tone: "neutral",
      cancelLabel: "Cancel",
      primaryActionLabel: "Save and duplicate",
      autoFocusButton: "primary",
      onPrimaryAction: onDuplicate,
      children: "You have unsaved changes. Save this entry to duplicate it."
    });
    $[44] = duplicateAlertIsOpen;
    $[45] = onDuplicate;
    $[46] = t20;
  } else {
    t20 = $[46];
  }
  let t21;
  if ($[47] !== t20) {
    t21 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: t19,
      children: t20
    });
    $[47] = t20;
    $[48] = t21;
  } else {
    t21 = $[48];
  }
  let t22;
  if ($[49] !== indicatorElement || $[50] !== t13 || $[51] !== t15 || $[52] !== t18 || $[53] !== t21) {
    t22 = /*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      gap: t7,
      children: [t8, indicatorElement, t13, t15, t18, t21]
    });
    $[49] = indicatorElement;
    $[50] = t13;
    $[51] = t15;
    $[52] = t18;
    $[53] = t21;
    $[54] = t22;
  } else {
    t22 = $[54];
  }
  return t22;
}
function CreateBranchDuringUpdateDialog(props) {
  var _data$createRef;
  const $ = c(41);
  const stringFormatter = useLocalizedStringFormatter(strings);
  const repoInfo = useRepoInfo();
  const [branchName, setBranchName] = useState("");
  const [t0, createBranch] = useCreateBranchMutation();
  const {
    error,
    fetching,
    data
  } = t0;
  const isLoading = fetching || !!(data !== null && data !== void 0 && (_data$createRef = data.createRef) !== null && _data$createRef !== void 0 && _data$createRef.__typename);
  const config = useConfig();
  let t1;
  if ($[0] !== config) {
    t1 = getBranchPrefix(config);
    $[0] = config;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const branchPrefix = t1;
  let t2;
  if ($[2] !== branchPrefix) {
    t2 = branchPrefix ? {
      UNSAFE_className: css({
        "& input": {
          paddingInlineStart: tokenSchema.size.space.xsmall
        }
      }),
      startElement: /*#__PURE__*/jsx(Flex, {
        alignItems: "center",
        paddingStart: "regular",
        justifyContent: "center",
        pointerEvents: "none",
        children: /*#__PURE__*/jsx(Text, {
          color: "neutralSecondary",
          children: branchPrefix
        })
      })
    } : {};
    $[2] = branchPrefix;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const propsForBranchPrefix = t2;
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      display: "contents"
    };
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== branchPrefix || $[6] !== branchName || $[7] !== createBranch || $[8] !== props || $[9] !== repoInfo) {
    t4 = async event => {
      var _result$data;
      if (event.target !== event.currentTarget) {
        return;
      }
      event.preventDefault();
      const fullBranchName = (branchPrefix !== null && branchPrefix !== void 0 ? branchPrefix : "") + branchName;
      const name = `refs/heads/${fullBranchName}`;
      const result = await createBranch({
        input: {
          name,
          oid: props.branchOid,
          repositoryId: repoInfo.id
        }
      });
      if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
        props.onCreate(fullBranchName);
      }
    };
    $[5] = branchPrefix;
    $[6] = branchName;
    $[7] = createBranch;
    $[8] = props;
    $[9] = repoInfo;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== stringFormatter) {
    t5 = stringFormatter.format("newBranch");
    $[11] = stringFormatter;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== t5) {
    t6 = /*#__PURE__*/jsx(Heading, {
      children: t5
    });
    $[13] = t5;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  let t7;
  if ($[15] !== error) {
    t7 = prettyErrorForCreateBranchMutation(error);
    $[15] = error;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  let t8;
  if ($[17] !== branchName || $[18] !== props.reason || $[19] !== t7 || $[20] !== propsForBranchPrefix) {
    t8 = /*#__PURE__*/jsx(Content, {
      children: /*#__PURE__*/jsx(Flex, {
        gap: "large",
        direction: "column",
        children: /*#__PURE__*/jsx(TextField, {
          value: branchName,
          onChange: setBranchName,
          label: "Branch name",
          description: props.reason,
          autoFocus: true,
          errorMessage: t7,
          ...propsForBranchPrefix
        })
      })
    });
    $[17] = branchName;
    $[18] = props.reason;
    $[19] = t7;
    $[20] = propsForBranchPrefix;
    $[21] = t8;
  } else {
    t8 = $[21];
  }
  let t9;
  if ($[22] !== isLoading) {
    t9 = isLoading && /*#__PURE__*/jsx(ProgressCircle, {
      isIndeterminate: true,
      size: "small",
      "aria-label": "Creating Branch"
    });
    $[22] = isLoading;
    $[23] = t9;
  } else {
    t9 = $[23];
  }
  let t10;
  if ($[24] !== stringFormatter) {
    t10 = stringFormatter.format("cancel");
    $[24] = stringFormatter;
    $[25] = t10;
  } else {
    t10 = $[25];
  }
  let t11;
  if ($[26] !== isLoading || $[27] !== props.onDismiss || $[28] !== t10) {
    t11 = /*#__PURE__*/jsx(Button, {
      isDisabled: isLoading,
      onPress: props.onDismiss,
      children: t10
    });
    $[26] = isLoading;
    $[27] = props.onDismiss;
    $[28] = t10;
    $[29] = t11;
  } else {
    t11 = $[29];
  }
  let t12;
  if ($[30] !== isLoading) {
    t12 = /*#__PURE__*/jsx(Button, {
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      children: "Create branch and save"
    });
    $[30] = isLoading;
    $[31] = t12;
  } else {
    t12 = $[31];
  }
  let t13;
  if ($[32] !== t9 || $[33] !== t11 || $[34] !== t12) {
    t13 = /*#__PURE__*/jsxs(ButtonGroup, {
      children: [t9, t11, t12]
    });
    $[32] = t9;
    $[33] = t11;
    $[34] = t12;
    $[35] = t13;
  } else {
    t13 = $[35];
  }
  let t14;
  if ($[36] !== t4 || $[37] !== t6 || $[38] !== t8 || $[39] !== t13) {
    t14 = /*#__PURE__*/jsx(Dialog, {
      children: /*#__PURE__*/jsxs("form", {
        style: t3,
        onSubmit: t4,
        children: [t6, t8, t13]
      })
    });
    $[36] = t4;
    $[37] = t6;
    $[38] = t8;
    $[39] = t13;
    $[40] = t14;
  } else {
    t14 = $[40];
  }
  return t14;
}
function ItemPageOuterWrapper(props) {
  var _props$config$collect;
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig) notFound();
  const format = useMemo(() => getCollectionFormat(props.config, props.collection), [props.config, props.collection]);
  const slugInfo = useMemo(() => {
    return {
      slug: props.itemSlug,
      field: collectionConfig.slugField
    };
  }, [collectionConfig.slugField, props.itemSlug]);
  const draftData = useData(useCallback(async () => {
    try {
      const raw = await getDraft(['collection', props.collection, props.itemSlug]);
      if (!raw) throw new Error('No draft found');
      const stored = storedValSchema$2.create(raw);
      const parsed = parseEntry({
        dirpath: getCollectionItemPath(props.config, props.collection, stored.slug),
        format: getCollectionFormat(props.config, props.collection),
        schema: collectionConfig.schema,
        slug: {
          field: collectionConfig.slugField,
          slug: stored.slug
        }
      }, stored.files);
      return {
        state: parsed.initialState,
        savedAt: stored.savedAt,
        treeKey: stored.beforeTreeKey
      };
    } catch {}
  }, [collectionConfig, props.collection, props.config, props.itemSlug]));
  const itemData = useItemData({
    config: props.config,
    dirpath: getCollectionItemPath(props.config, props.collection, props.itemSlug),
    schema: collectionConfig.schema,
    format,
    slug: slugInfo
  });
  const currentBranch = useCurrentBranch();
  const key = `${currentBranch}/${props.collection}/item/${props.itemSlug}`;
  const yjsInfo = useYjsIfAvailable();
  const isItemDataLoading = itemData.kind !== 'loaded';
  const isItemNotFound = !isItemDataLoading && itemData.data === 'not-found';
  const mapData = useData(useCallback(() => {
    if (!yjsInfo) return;
    if (yjsInfo === 'loading') return LOADING;
    if (isItemDataLoading) return LOADING;
    if (isItemNotFound) return;
    return (async () => {
      await yjsInfo.doc.whenSynced;
      let doc = yjsInfo.data.get(key);
      if (doc instanceof Y.Doc) {
        const promise = doc.whenLoaded;
        doc.load();
        await promise;
      } else {
        doc = new Y.Doc();
        yjsInfo.data.set(key, doc);
      }
      const data = doc.getMap('data');
      return data;
    })();
  }, [isItemDataLoading, isItemNotFound, key, yjsInfo]));
  return /*#__PURE__*/jsx(NotFoundBoundary, {
    fallback: /*#__PURE__*/jsx(ItemPageShell, {
      ...props,
      children: /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "caution",
          children: "Entry not found."
        })
      })
    }),
    children: /*#__PURE__*/jsx(ErrorBoundary, {
      fallback: message => /*#__PURE__*/jsx(ItemPageShell, {
        ...props,
        children: /*#__PURE__*/jsx(PageBody, {
          children: /*#__PURE__*/jsx(Notice, {
            tone: "critical",
            children: message
          })
        })
      }),
      children: /*#__PURE__*/jsx(Suspense, {
        fallback: /*#__PURE__*/jsx(ItemPageShell, {
          ...props,
          children: /*#__PURE__*/jsx(Flex, {
            alignItems: "center",
            justifyContent: "center",
            minHeight: "scale.3000",
            children: /*#__PURE__*/jsx(ProgressCircle, {
              "aria-label": "Loading Item",
              isIndeterminate: true,
              size: "large"
            })
          })
        }),
        children: /*#__PURE__*/jsx(ItemPageWrapper, {
          mapData: mapData,
          draftData: draftData,
          itemData: itemData,
          ...props
        })
      })
    })
  });
}
function ItemPageWrapper(props) {
  const collectionConfig = getCollection(props.config, props.collection);
  const deferredDraftData = useDeferredValue(props.draftData);
  const itemData = suspendOnData(props.itemData);
  if (itemData === 'not-found') notFound();
  const mapData = suspendOnData(props.mapData);
  useMemo(() => {
    var _mapData$doc;
    if (!mapData || mapData.size) {
      return;
    }
    const {
      initialState
    } = itemData;
    (_mapData$doc = mapData.doc) === null || _mapData$doc === void 0 || _mapData$doc.transact(() => {
      for (const [key, value] of Object.entries(collectionConfig.schema)) {
        const val = getYjsValFromParsedValue(value, initialState[key]);
        mapData.set(key, val);
      }
    });
  }, [collectionConfig.schema, itemData, mapData]);
  const loadedDraft = suspendOnData(deferredDraftData);
  if (mapData) {
    return /*#__PURE__*/jsx(CollabItemPage, {
      collection: props.collection,
      basePath: props.basePath,
      config: props.config,
      itemSlug: props.itemSlug,
      initialState: itemData.initialState,
      initialFiles: itemData.initialFiles,
      localTreeKey: itemData.localTreeKey,
      map: mapData
    });
  }
  return /*#__PURE__*/jsx(LocalItemPage, {
    collection: props.collection,
    basePath: props.basePath,
    config: props.config,
    itemSlug: props.itemSlug,
    initialState: itemData.initialState,
    initialFiles: itemData.initialFiles,
    draft: loadedDraft,
    localTreeKey: itemData.localTreeKey
  });
}
function ItemPageShell(props) {
  const $ = c(17);
  let breadcrumbItems;
  let T0;
  let t0;
  if ($[0] !== props.config || $[1] !== props.collection || $[2] !== props.basePath || $[3] !== props.itemSlug) {
    const collectionConfig = getCollection(props.config, props.collection);
    const collectionHref = `${props.basePath}/collection/${props.collection}`;
    breadcrumbItems = [{
      key: "collection",
      label: collectionConfig.label,
      href: collectionHref
    }, {
      key: "item",
      label: props.itemSlug
    }];
    T0 = PageRoot;
    t0 = containerWidthForEntryLayout(collectionConfig);
    $[0] = props.config;
    $[1] = props.collection;
    $[2] = props.basePath;
    $[3] = props.itemSlug;
    $[4] = breadcrumbItems;
    $[5] = T0;
    $[6] = t0;
  } else {
    breadcrumbItems = $[4];
    T0 = $[5];
    t0 = $[6];
  }
  let t1;
  if ($[7] !== breadcrumbItems) {
    t1 = /*#__PURE__*/jsx(HeaderBreadcrumbs, {
      items: breadcrumbItems
    });
    $[7] = breadcrumbItems;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  let t2;
  if ($[9] !== t1 || $[10] !== props.headerActions) {
    t2 = /*#__PURE__*/jsxs(PageHeader, {
      children: [t1, props.headerActions]
    });
    $[9] = t1;
    $[10] = props.headerActions;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  let t3;
  if ($[12] !== T0 || $[13] !== t0 || $[14] !== t2 || $[15] !== props.children) {
    t3 = /*#__PURE__*/jsxs(T0, {
      containerWidth: t0,
      children: [t2, props.children]
    });
    $[12] = T0;
    $[13] = t0;
    $[14] = t2;
    $[15] = props.children;
    $[16] = t3;
  } else {
    t3 = $[16];
  }
  return t3;
}

function useDuplicateSlug(duplicateInitalState, collectionConfig) {
  return useMemo(() => {
    if (duplicateInitalState) {
      // we'll make a best effort to add something to the slug after duplicated so it's different
      // but if it fails a user can change it before creating
      // (e.g. potentially it's not just a text field so appending -copy might not work)
      const {
        slugField
      } = collectionConfig;
      const defaultSlugVal = duplicateInitalState[collectionConfig.slugField];
      const slugFieldSchema = collectionConfig.schema[collectionConfig.slugField];
      if (slugFieldSchema.kind === 'form' && slugFieldSchema.formKind === 'slug') {
        try {
          const serialized = slugFieldSchema.serializeWithSlug(defaultSlugVal);
          const slugFieldValue = slugFieldSchema.parse(serialized.value, {
            slug: serialized.slug ? `${serialized.slug}-copy` : ''
          });
          return {
            ...duplicateInitalState,
            [slugField]: slugFieldValue
          };
        } catch {}
      }
      return {
        ...duplicateInitalState,
        [slugField]: defaultSlugVal
      };
    }
  }, [collectionConfig, duplicateInitalState]);
}

function CreateItemWrapper(props) {
  var _props$config$collect;
  const $ = c(53);
  const router = useRouter();
  let t0;
  let t1;
  if ($[0] !== router.href) {
    const url = new URL(router.href, "http://localhost");
    t1 = url.searchParams.get("duplicate");
    $[0] = router.href;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  t0 = t1;
  const duplicateSlug = t0;
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig) {
    notFound();
  }
  let t2;
  let t3;
  if ($[2] !== props.config || $[3] !== props.collection) {
    t3 = getCollectionFormat(props.config, props.collection);
    $[2] = props.config;
    $[3] = props.collection;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  t2 = t3;
  const format = t2;
  let t4;
  if ($[5] !== props.collection || $[6] !== props.config || $[7] !== duplicateSlug || $[8] !== format || $[9] !== collectionConfig.schema || $[10] !== collectionConfig.slugField) {
    t4 = async () => {
      const raw = await getDraft(["collection-create", props.collection, ...(duplicateSlug ? [duplicateSlug] : [])]);
      if (!raw) {
        throw new Error("No draft found");
      }
      const stored = storedValSchema$1.create(raw);
      const parsed = parseEntry({
        dirpath: getCollectionItemPath(props.config, props.collection, stored.slug),
        format,
        schema: collectionConfig.schema,
        slug: {
          field: collectionConfig.slugField,
          slug: stored.slug
        }
      }, stored.files);
      return {
        state: parsed.initialState,
        savedAt: stored.savedAt
      };
    };
    $[5] = props.collection;
    $[6] = props.config;
    $[7] = duplicateSlug;
    $[8] = format;
    $[9] = collectionConfig.schema;
    $[10] = collectionConfig.slugField;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  const draftData = useData(t4);
  let t5;
  bb0: {
    if (duplicateSlug) {
      let t6;
      if ($[12] !== collectionConfig.slugField || $[13] !== duplicateSlug) {
        t6 = {
          field: collectionConfig.slugField,
          slug: duplicateSlug
        };
        $[12] = collectionConfig.slugField;
        $[13] = duplicateSlug;
        $[14] = t6;
      } else {
        t6 = $[14];
      }
      t5 = t6;
      break bb0;
    }
    if (collectionConfig.template) {
      let t6;
      if ($[15] !== collectionConfig.slugField) {
        t6 = {
          field: collectionConfig.slugField,
          slug: ""
        };
        $[15] = collectionConfig.slugField;
        $[16] = t6;
      } else {
        t6 = $[16];
      }
      t5 = t6;
      break bb0;
    }
    t5 = undefined;
  }
  const slug = t5;
  const isFromTemplate = !!duplicateSlug || !!collectionConfig.template;
  let t6;
  if ($[17] !== collectionConfig.template || $[18] !== duplicateSlug || $[19] !== props) {
    t6 = collectionConfig.template && !duplicateSlug ? collectionConfig.template : getCollectionItemPath(props.config, props.collection, duplicateSlug !== null && duplicateSlug !== void 0 ? duplicateSlug : "");
    $[17] = collectionConfig.template;
    $[18] = duplicateSlug;
    $[19] = props;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  let t7;
  if ($[21] !== props.config || $[22] !== t6 || $[23] !== collectionConfig.schema || $[24] !== format || $[25] !== slug) {
    t7 = {
      config: props.config,
      dirpath: t6,
      schema: collectionConfig.schema,
      format,
      slug
    };
    $[21] = props.config;
    $[22] = t6;
    $[23] = collectionConfig.schema;
    $[24] = format;
    $[25] = slug;
    $[26] = t7;
  } else {
    t7 = $[26];
  }
  const itemData = useItemData(t7);
  const duplicateInitalState = isFromTemplate && itemData.kind === "loaded" && itemData.data !== "not-found" ? itemData.data.initialState : undefined;
  const duplicateInitalStateWithUpdatedSlug = useDuplicateSlug(duplicateInitalState, collectionConfig);
  const currentBranch = useCurrentBranch();
  const yjsInfo = useYjsIfAvailable();
  const key = `${currentBranch}/${props.collection}/create${duplicateSlug !== null && duplicateSlug !== void 0 && duplicateSlug.length ? `?duplicate=${duplicateSlug}` : ""}`;
  let t8;
  if ($[27] !== yjsInfo || $[28] !== isFromTemplate || $[29] !== duplicateInitalState || $[30] !== key || $[31] !== collectionConfig.schema) {
    t8 = async () => {
      if (!yjsInfo) {
        return;
      }
      if (yjsInfo === "loading") {
        return LOADING;
      }
      await yjsInfo.doc.whenSynced;
      if (isFromTemplate && !duplicateInitalState) {
        return LOADING;
      }
      let doc = yjsInfo.data.get(key);
      if (doc instanceof Y.Doc) {
        const promise = doc.whenLoaded;
        doc.load();
        await promise;
      } else {
        doc = new Y.Doc();
        yjsInfo.data.set(key, doc);
      }
      const data = doc.getMap("data");
      if (!data.size) {
        doc.transact(() => {
          for (const [key_0, value] of Object.entries(collectionConfig.schema)) {
            var _duplicateInitalState;
            const val = getYjsValFromParsedValue(value, (_duplicateInitalState = duplicateInitalState === null || duplicateInitalState === void 0 ? void 0 : duplicateInitalState[key_0]) !== null && _duplicateInitalState !== void 0 ? _duplicateInitalState : getInitialPropsValue(value));
            data.set(key_0, val);
          }
        });
      }
      return data;
    };
    $[27] = yjsInfo;
    $[28] = isFromTemplate;
    $[29] = duplicateInitalState;
    $[30] = key;
    $[31] = collectionConfig.schema;
    $[32] = t8;
  } else {
    t8 = $[32];
  }
  const mapData = useData(t8);
  if (isFromTemplate && itemData.kind === "error") {
    let t9;
    if ($[33] !== itemData.error.message) {
      t9 = /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: itemData.error.message
        })
      });
      $[33] = itemData.error.message;
      $[34] = t9;
    } else {
      t9 = $[34];
    }
    return t9;
  }
  if (mapData.kind === "error") {
    console.log(mapData.error);
    let t9;
    if ($[35] !== mapData.error.message) {
      t9 = /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: mapData.error.message
        })
      });
      $[35] = mapData.error.message;
      $[36] = t9;
    } else {
      t9 = $[36];
    }
    return t9;
  }
  if (isFromTemplate && itemData.kind === "loading" || draftData.kind === "loading" || mapData.kind === "loading") {
    let t9;
    if ($[37] === Symbol.for("react.memo_cache_sentinel")) {
      t9 = /*#__PURE__*/jsx(Flex, {
        alignItems: "center",
        justifyContent: "center",
        minHeight: "scale.3000",
        children: /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": "Loading Item",
          isIndeterminate: true,
          size: "large"
        })
      });
      $[37] = t9;
    } else {
      t9 = $[37];
    }
    return t9;
  }
  if (isFromTemplate && itemData.kind === "loaded" && itemData.data === "not-found") {
    let t9;
    if ($[38] === Symbol.for("react.memo_cache_sentinel")) {
      t9 = /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "caution",
          children: "Entry not found."
        })
      });
      $[38] = t9;
    } else {
      t9 = $[38];
    }
    return t9;
  }
  if (!mapData.data) {
    const t9 = draftData.kind === "loaded" ? draftData.data : undefined;
    let t10;
    if ($[39] !== props.collection || $[40] !== props.config || $[41] !== props.basePath || $[42] !== t9 || $[43] !== duplicateSlug || $[44] !== duplicateInitalStateWithUpdatedSlug) {
      t10 = /*#__PURE__*/jsx(CreateItemLocal, {
        collection: props.collection,
        config: props.config,
        basePath: props.basePath,
        draft: t9,
        duplicateSlug: duplicateSlug,
        initialState: duplicateInitalStateWithUpdatedSlug
      });
      $[39] = props.collection;
      $[40] = props.config;
      $[41] = props.basePath;
      $[42] = t9;
      $[43] = duplicateSlug;
      $[44] = duplicateInitalStateWithUpdatedSlug;
      $[45] = t10;
    } else {
      t10 = $[45];
    }
    return t10;
  }
  let t9;
  if ($[46] !== props.collection || $[47] !== props.config || $[48] !== props.basePath || $[49] !== duplicateSlug || $[50] !== duplicateInitalStateWithUpdatedSlug || $[51] !== mapData.data) {
    t9 = /*#__PURE__*/jsx(CreateItemCollab, {
      collection: props.collection,
      config: props.config,
      basePath: props.basePath,
      duplicateSlug: duplicateSlug,
      initialState: duplicateInitalStateWithUpdatedSlug,
      map: mapData.data
    });
    $[46] = props.collection;
    $[47] = props.config;
    $[48] = props.basePath;
    $[49] = duplicateSlug;
    $[50] = duplicateInitalStateWithUpdatedSlug;
    $[51] = mapData.data;
    $[52] = t9;
  } else {
    t9 = $[52];
  }
  return t9;
}
const storedValSchema$1 = s.type({
  version: s.literal(1),
  savedAt: s.date(),
  slug: s.string(),
  files: s.map(s.string(), s.instance(Uint8Array))
});
function CreateItemLocal(props) {
  var _props$draft$state, _props$draft;
  const $ = c(61);
  const {
    collectionConfig,
    schema
  } = useCollection(props.collection);
  let t0;
  let t1;
  if ($[0] !== props.initialState || $[1] !== schema) {
    var _props$initialState;
    t1 = (_props$initialState = props.initialState) !== null && _props$initialState !== void 0 ? _props$initialState : getInitialPropsValue(schema);
    $[0] = props.initialState;
    $[1] = schema;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  t0 = t1;
  const initialState = t0;
  const [state, setState] = useState((_props$draft$state = (_props$draft = props.draft) === null || _props$draft === void 0 ? void 0 : _props$draft.state) !== null && _props$draft$state !== void 0 ? _props$draft$state : initialState);
  const previewProps = usePreviewProps(schema, setState, state);
  useShowRestoredDraftMessage(props.draft, state, undefined);
  let t2;
  let slug;
  let formatInfo;
  if ($[3] !== collectionConfig || $[4] !== state || $[5] !== props.config || $[6] !== props.collection) {
    slug = getSlugFromState(collectionConfig, state);
    let t3;
    if ($[10] !== props.config || $[11] !== props.collection) {
      t3 = getCollectionFormat(props.config, props.collection);
      $[10] = props.config;
      $[11] = props.collection;
      $[12] = t3;
    } else {
      t3 = $[12];
    }
    formatInfo = t3;
    t2 = getCollectionItemPath(props.config, props.collection, slug);
    $[3] = collectionConfig;
    $[4] = state;
    $[5] = props.config;
    $[6] = props.collection;
    $[7] = t2;
    $[8] = slug;
    $[9] = formatInfo;
  } else {
    t2 = $[7];
    slug = $[8];
    formatInfo = $[9];
  }
  const basePath = t2;
  let t3;
  if ($[13] !== collectionConfig.slugField || $[14] !== slug) {
    t3 = {
      field: collectionConfig.slugField,
      value: slug
    };
    $[13] = collectionConfig.slugField;
    $[14] = slug;
    $[15] = t3;
  } else {
    t3 = $[15];
  }
  let t4;
  if ($[16] !== state || $[17] !== basePath || $[18] !== props.config || $[19] !== collectionConfig.schema || $[20] !== formatInfo || $[21] !== t3) {
    t4 = {
      state,
      basePath,
      initialFiles: undefined,
      config: props.config,
      schema: collectionConfig.schema,
      format: formatInfo,
      currentLocalTreeKey: undefined,
      slug: t3
    };
    $[16] = state;
    $[17] = basePath;
    $[18] = props.config;
    $[19] = collectionConfig.schema;
    $[20] = formatInfo;
    $[21] = t3;
    $[22] = t4;
  } else {
    t4 = $[22];
  }
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem(t4);
  const createItem = useEventCallback(_createItem);
  let t5;
  if ($[23] !== initialState || $[24] !== schema || $[25] !== state || $[26] !== collectionConfig.slugField) {
    t5 = {
      initialState,
      schema,
      state,
      slugField: collectionConfig.slugField
    };
    $[23] = initialState;
    $[24] = schema;
    $[25] = state;
    $[26] = collectionConfig.slugField;
    $[27] = t5;
  } else {
    t5 = $[27];
  }
  const hasChanged = useHasChanged(t5);
  const hasCreated = createResult.kind === "updated" || createResult.kind === "loading";
  let t6;
  if ($[28] !== props.collection || $[29] !== props.duplicateSlug || $[30] !== hasChanged || $[31] !== hasCreated || $[32] !== basePath || $[33] !== formatInfo || $[34] !== collectionConfig.schema || $[35] !== collectionConfig.slugField || $[36] !== slug || $[37] !== state) {
    t6 = () => {
      const key = ["collection-create", props.collection, ...(props.duplicateSlug ? [props.duplicateSlug] : [])];
      if (hasChanged && !hasCreated) {
        const serialized = serializeEntryToFiles({
          basePath,
          format: formatInfo,
          schema: collectionConfig.schema,
          slug: {
            field: collectionConfig.slugField,
            value: slug
          },
          state
        });
        const files = new Map(serialized.map(x => [x.path, x.contents]));
        const data = {
          slug,
          files,
          savedAt: new Date(),
          version: 1
        };
        setDraft(key, data);
      } else {
        delDraft(key);
      }
    };
    $[28] = props.collection;
    $[29] = props.duplicateSlug;
    $[30] = hasChanged;
    $[31] = hasCreated;
    $[32] = basePath;
    $[33] = formatInfo;
    $[34] = collectionConfig.schema;
    $[35] = collectionConfig.slugField;
    $[36] = slug;
    $[37] = state;
    $[38] = t6;
  } else {
    t6 = $[38];
  }
  let t7;
  if ($[39] !== collectionConfig || $[40] !== slug || $[41] !== state || $[42] !== hasChanged || $[43] !== props.duplicateSlug || $[44] !== props.collection || $[45] !== basePath || $[46] !== formatInfo || $[47] !== hasCreated) {
    t7 = [collectionConfig, slug, state, hasChanged, props.duplicateSlug, props.collection, basePath, formatInfo, hasCreated];
    $[39] = collectionConfig;
    $[40] = slug;
    $[41] = state;
    $[42] = hasChanged;
    $[43] = props.duplicateSlug;
    $[44] = props.collection;
    $[45] = basePath;
    $[46] = formatInfo;
    $[47] = hasCreated;
    $[48] = t7;
  } else {
    t7 = $[48];
  }
  useEffect(t6, t7);
  let t8;
  if ($[49] !== initialState) {
    t8 = () => {
      setState(initialState);
    };
    $[49] = initialState;
    $[50] = t8;
  } else {
    t8 = $[50];
  }
  let t9;
  if ($[51] !== props.basePath || $[52] !== props.collection || $[53] !== createResult || $[54] !== createItem || $[55] !== resetCreateItemState || $[56] !== state || $[57] !== slug || $[58] !== previewProps || $[59] !== t8) {
    t9 = /*#__PURE__*/jsx(CreateItemInner, {
      basePath: props.basePath,
      collection: props.collection,
      createResult: createResult,
      createItem: createItem,
      resetCreateItemState: resetCreateItemState,
      state: state,
      slug: slug,
      previewProps: previewProps,
      onReset: t8
    });
    $[51] = props.basePath;
    $[52] = props.collection;
    $[53] = createResult;
    $[54] = createItem;
    $[55] = resetCreateItemState;
    $[56] = state;
    $[57] = slug;
    $[58] = previewProps;
    $[59] = t8;
    $[60] = t9;
  } else {
    t9 = $[60];
  }
  return t9;
}
function CreateItemCollab(props) {
  const $ = c(34);
  const {
    collectionConfig,
    schema
  } = useCollection(props.collection);
  const state = useYJsValue(schema, props.map);
  const previewProps = usePreviewPropsFromY(schema, props.map, state);
  let t0;
  let slug;
  let formatInfo;
  if ($[0] !== collectionConfig || $[1] !== state || $[2] !== props.config || $[3] !== props.collection) {
    slug = getSlugFromState(collectionConfig, state);
    let t1;
    if ($[7] !== props.config || $[8] !== props.collection) {
      t1 = getCollectionFormat(props.config, props.collection);
      $[7] = props.config;
      $[8] = props.collection;
      $[9] = t1;
    } else {
      t1 = $[9];
    }
    formatInfo = t1;
    t0 = getCollectionItemPath(props.config, props.collection, slug);
    $[0] = collectionConfig;
    $[1] = state;
    $[2] = props.config;
    $[3] = props.collection;
    $[4] = t0;
    $[5] = slug;
    $[6] = formatInfo;
  } else {
    t0 = $[4];
    slug = $[5];
    formatInfo = $[6];
  }
  const basePath = t0;
  let t1;
  if ($[10] !== collectionConfig.slugField || $[11] !== slug) {
    t1 = {
      field: collectionConfig.slugField,
      value: slug
    };
    $[10] = collectionConfig.slugField;
    $[11] = slug;
    $[12] = t1;
  } else {
    t1 = $[12];
  }
  let t2;
  if ($[13] !== state || $[14] !== basePath || $[15] !== props.config || $[16] !== collectionConfig.schema || $[17] !== formatInfo || $[18] !== t1) {
    t2 = {
      state,
      basePath,
      initialFiles: undefined,
      config: props.config,
      schema: collectionConfig.schema,
      format: formatInfo,
      currentLocalTreeKey: undefined,
      slug: t1
    };
    $[13] = state;
    $[14] = basePath;
    $[15] = props.config;
    $[16] = collectionConfig.schema;
    $[17] = formatInfo;
    $[18] = t1;
    $[19] = t2;
  } else {
    t2 = $[19];
  }
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem(t2);
  const createItem = useEventCallback(_createItem);
  let t3;
  if ($[20] !== props.map || $[21] !== props.initialState || $[22] !== collectionConfig.schema) {
    t3 = () => {
      var _props$map$doc;
      (_props$map$doc = props.map.doc) === null || _props$map$doc === void 0 || _props$map$doc.transact(() => {
        for (const [key, value] of Object.entries(collectionConfig.schema)) {
          var _props$initialState$k, _props$initialState2;
          const val = getYjsValFromParsedValue(value, (_props$initialState$k = (_props$initialState2 = props.initialState) === null || _props$initialState2 === void 0 ? void 0 : _props$initialState2[key]) !== null && _props$initialState$k !== void 0 ? _props$initialState$k : getInitialPropsValue(value));
          props.map.set(key, val);
        }
      });
    };
    $[20] = props.map;
    $[21] = props.initialState;
    $[22] = collectionConfig.schema;
    $[23] = t3;
  } else {
    t3 = $[23];
  }
  let t4;
  if ($[24] !== props.basePath || $[25] !== props.collection || $[26] !== createResult || $[27] !== createItem || $[28] !== resetCreateItemState || $[29] !== state || $[30] !== slug || $[31] !== previewProps || $[32] !== t3) {
    t4 = /*#__PURE__*/jsx(CreateItemInner, {
      basePath: props.basePath,
      collection: props.collection,
      createResult: createResult,
      createItem: createItem,
      resetCreateItemState: resetCreateItemState,
      state: state,
      slug: slug,
      previewProps: previewProps,
      onReset: t3
    });
    $[24] = props.basePath;
    $[25] = props.collection;
    $[26] = createResult;
    $[27] = createItem;
    $[28] = resetCreateItemState;
    $[29] = state;
    $[30] = slug;
    $[31] = previewProps;
    $[32] = t3;
    $[33] = t4;
  } else {
    t4 = $[33];
  }
  return t4;
}
function CreateItemInner(props) {
  const $ = c(96);
  const {
    onReset
  } = props;
  const stringFormatter = useLocalizedStringFormatter(strings);
  const router = useRouter();
  const config = useConfig();
  const {
    collectionConfig,
    schema
  } = useCollection(props.collection);
  const [forceValidation, setForceValidation] = useState(false);
  let t0;
  if ($[0] !== config || $[1] !== props.collection) {
    t0 = getCollectionFormat(config, props.collection);
    $[0] = config;
    $[1] = props.collection;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const formatInfo = t0;
  const baseCommit = useBaseCommit();
  const collectionPath = `${props.basePath}/collection/${encodeURIComponent(props.collection)}`;
  const {
    createResult
  } = props;
  const currentSlug = createResult.kind === "updated" || createResult.kind === "loading" ? props.slug : undefined;
  const slugInfo = useSlugFieldInfo(props.collection, currentSlug);
  let t1;
  if ($[3] !== createResult.kind || $[4] !== schema || $[5] !== props || $[6] !== slugInfo || $[7] !== collectionConfig || $[8] !== router || $[9] !== collectionPath) {
    t1 = async () => {
      if (createResult.kind === "loading") {
        return;
      }
      if (!clientSideValidateProp(schema, props.state, slugInfo)) {
        setForceValidation(true);
        return;
      }
      if (await props.createItem()) {
        const slug = getSlugFromState(collectionConfig, props.state);
        router.push(`${collectionPath}/item/${encodeURIComponent(slug)}`);
        toastQueue.positive("Entry created", {
          timeout: 5000
        });
      }
    };
    $[3] = createResult.kind;
    $[4] = schema;
    $[5] = props;
    $[6] = slugInfo;
    $[7] = collectionConfig;
    $[8] = router;
    $[9] = collectionPath;
    $[10] = t1;
  } else {
    t1 = $[10];
  }
  const onCreate = t1;
  let t2;
  if ($[11] !== props.state || $[12] !== formatInfo || $[13] !== collectionConfig) {
    t2 = () => {
      copyEntryToClipboard(props.state, formatInfo, collectionConfig.schema, {
        field: collectionConfig.slugField,
        value: getSlugFromState(collectionConfig, props.state)
      });
    };
    $[11] = props.state;
    $[12] = formatInfo;
    $[13] = collectionConfig;
    $[14] = t2;
  } else {
    t2 = $[14];
  }
  const onCopy = t2;
  let t3;
  if ($[15] !== formatInfo || $[16] !== collectionConfig || $[17] !== props.state || $[18] !== props.previewProps) {
    t3 = async () => {
      const entry = await getPastedEntry(formatInfo, collectionConfig.schema, {
        field: collectionConfig.slugField,
        slug: getSlugFromState(collectionConfig, props.state)
      });
      if (entry) {
        setValueToPreviewProps(entry, props.previewProps);
        toastQueue.positive("Entry pasted", {
          shouldCloseOnAction: true,
          actionLabel: "Undo",
          onAction: () => {
            setValueToPreviewProps(props.state, props.previewProps);
          }
        });
      }
    };
    $[15] = formatInfo;
    $[16] = collectionConfig;
    $[17] = props.state;
    $[18] = props.previewProps;
    $[19] = t3;
  } else {
    t3 = $[19];
  }
  const onPaste = t3;
  const isLoading = createResult.kind === "loading" || createResult.kind === "updated";
  let t4;
  let t5;
  if ($[20] !== collectionConfig.label || $[21] !== collectionPath) {
    t5 = {
      key: "collection",
      label: collectionConfig.label,
      href: collectionPath
    };
    $[20] = collectionConfig.label;
    $[21] = collectionPath;
    $[22] = t5;
  } else {
    t5 = $[22];
  }
  let t6;
  if ($[23] !== stringFormatter) {
    t6 = stringFormatter.format("add");
    $[23] = stringFormatter;
    $[24] = t6;
  } else {
    t6 = $[24];
  }
  let t7;
  if ($[25] !== t6) {
    t7 = {
      key: "current",
      label: t6
    };
    $[25] = t6;
    $[26] = t7;
  } else {
    t7 = $[26];
  }
  let t8;
  if ($[27] !== t5 || $[28] !== t7) {
    t8 = [t5, t7];
    $[27] = t5;
    $[28] = t7;
    $[29] = t8;
  } else {
    t8 = $[29];
  }
  t4 = t8;
  const breadcrumbItems = t4;
  const isBelowDesktop = useMediaQuery(breakpointQueries.below.desktop);
  let t9;
  if ($[30] !== collectionConfig) {
    t9 = containerWidthForEntryLayout(collectionConfig);
    $[30] = collectionConfig;
    $[31] = t9;
  } else {
    t9 = $[31];
  }
  let t10;
  if ($[32] !== breadcrumbItems) {
    t10 = /*#__PURE__*/jsx(HeaderBreadcrumbs, {
      items: breadcrumbItems
    });
    $[32] = breadcrumbItems;
    $[33] = t10;
  } else {
    t10 = $[33];
  }
  let t11;
  if ($[34] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = /*#__PURE__*/jsx(PresenceAvatars, {});
    $[34] = t11;
  } else {
    t11 = $[34];
  }
  let t12;
  if ($[35] !== isLoading) {
    t12 = isLoading && /*#__PURE__*/jsx(ProgressCircle, {
      "aria-label": "Creating entry",
      isIndeterminate: true,
      size: "small"
    });
    $[35] = isLoading;
    $[36] = t12;
  } else {
    t12 = $[36];
  }
  const t13 = isBelowDesktop ? "element.regular" : undefined;
  let t14;
  if ($[37] !== onReset || $[38] !== onCopy || $[39] !== onPaste) {
    t14 = key => {
      bb38: switch (key) {
        case "reset":
          {
            onReset();
            setForceValidation(false);
            break bb38;
          }
        case "copy":
          {
            onCopy();
            break bb38;
          }
        case "paste":
          {
            onPaste();
          }
      }
    };
    $[37] = onReset;
    $[38] = onCopy;
    $[39] = onPaste;
    $[40] = t14;
  } else {
    t14 = $[40];
  }
  let t15;
  if ($[41] === Symbol.for("react.memo_cache_sentinel")) {
    t15 = item => /*#__PURE__*/jsxs(Item$1, {
      textValue: item.label,
      children: [/*#__PURE__*/jsx(Icon, {
        src: item.icon
      }), /*#__PURE__*/jsx(Text, {
        children: item.label
      })]
    }, item.key);
    $[41] = t15;
  } else {
    t15 = $[41];
  }
  let t16;
  if ($[42] !== t13 || $[43] !== t14) {
    t16 = /*#__PURE__*/jsx(ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: t13,
      items: menuActions,
      onAction: t14,
      children: t15
    });
    $[42] = t13;
    $[43] = t14;
    $[44] = t16;
  } else {
    t16 = $[44];
  }
  let t17;
  if ($[45] !== stringFormatter) {
    t17 = stringFormatter.format("create");
    $[45] = stringFormatter;
    $[46] = t17;
  } else {
    t17 = $[46];
  }
  let t18;
  if ($[47] !== isLoading || $[48] !== t17) {
    t18 = /*#__PURE__*/jsx(Button, {
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      form: "item-create-form",
      marginStart: "auto",
      children: t17
    });
    $[47] = isLoading;
    $[48] = t17;
    $[49] = t18;
  } else {
    t18 = $[49];
  }
  let t19;
  if ($[50] !== t10 || $[51] !== t12 || $[52] !== t16 || $[53] !== t18) {
    t19 = /*#__PURE__*/jsxs(PageHeader, {
      children: [t10, t11, t12, t16, t18]
    });
    $[50] = t10;
    $[51] = t12;
    $[52] = t16;
    $[53] = t18;
    $[54] = t19;
  } else {
    t19 = $[54];
  }
  let t20;
  if ($[55] !== onCreate) {
    t20 = event => {
      if (event.target !== event.currentTarget) {
        return;
      }
      event.preventDefault();
      onCreate();
    };
    $[55] = onCreate;
    $[56] = t20;
  } else {
    t20 = $[56];
  }
  let t21;
  if ($[57] !== createResult) {
    t21 = createResult.kind === "error" && /*#__PURE__*/jsx(Notice, {
      tone: "critical",
      children: createResult.error.message
    });
    $[57] = createResult;
    $[58] = t21;
  } else {
    t21 = $[58];
  }
  let t22;
  if ($[59] !== props.previewProps || $[60] !== forceValidation || $[61] !== collectionConfig.entryLayout || $[62] !== formatInfo || $[63] !== slugInfo) {
    t22 = /*#__PURE__*/jsx(FormForEntry, {
      previewProps: props.previewProps,
      forceValidation: forceValidation,
      entryLayout: collectionConfig.entryLayout,
      formatInfo: formatInfo,
      slugField: slugInfo
    });
    $[59] = props.previewProps;
    $[60] = forceValidation;
    $[61] = collectionConfig.entryLayout;
    $[62] = formatInfo;
    $[63] = slugInfo;
    $[64] = t22;
  } else {
    t22 = $[64];
  }
  let t23;
  if ($[65] !== t20 || $[66] !== t21 || $[67] !== t22) {
    t23 = /*#__PURE__*/jsxs(Flex, {
      id: "item-create-form",
      elementType: "form",
      onSubmit: t20,
      direction: "column",
      gap: "xxlarge",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children: [t21, t22]
    });
    $[65] = t20;
    $[66] = t21;
    $[67] = t22;
    $[68] = t23;
  } else {
    t23 = $[68];
  }
  let t24;
  if ($[69] !== t9 || $[70] !== t19 || $[71] !== t23) {
    t24 = /*#__PURE__*/jsxs(PageRoot, {
      containerWidth: t9,
      children: [t19, t23]
    });
    $[69] = t9;
    $[70] = t19;
    $[71] = t23;
    $[72] = t24;
  } else {
    t24 = $[72];
  }
  let t25;
  if ($[73] !== createResult || $[74] !== router || $[75] !== props || $[76] !== baseCommit || $[77] !== collectionConfig) {
    t25 = createResult.kind === "needs-new-branch" && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
      branchOid: baseCommit,
      onCreate: async newBranch => {
        router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/create`);
        if (await props.createItem({
          branch: newBranch,
          sha: baseCommit
        })) {
          const slug_0 = getSlugFromState(collectionConfig, props.state);
          router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/item/${encodeURIComponent(slug_0)}`);
        }
      },
      reason: createResult.reason,
      onDismiss: props.resetCreateItemState
    });
    $[73] = createResult;
    $[74] = router;
    $[75] = props;
    $[76] = baseCommit;
    $[77] = collectionConfig;
    $[78] = t25;
  } else {
    t25 = $[78];
  }
  let t26;
  if ($[79] !== props.resetCreateItemState || $[80] !== t25) {
    t26 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: props.resetCreateItemState,
      children: t25
    });
    $[79] = props.resetCreateItemState;
    $[80] = t25;
    $[81] = t26;
  } else {
    t26 = $[81];
  }
  let t27;
  if ($[82] !== createResult.kind || $[83] !== config || $[84] !== props || $[85] !== collectionConfig || $[86] !== router || $[87] !== collectionPath) {
    t27 = createResult.kind === "needs-fork" && isGitHubConfig(config) && /*#__PURE__*/jsx(ForkRepoDialog, {
      onCreate: async () => {
        if (await props.createItem()) {
          const slug_1 = getSlugFromState(collectionConfig, props.state);
          router.push(`${collectionPath}/item/${encodeURIComponent(slug_1)}`);
        }
      },
      onDismiss: props.resetCreateItemState,
      config: config
    });
    $[82] = createResult.kind;
    $[83] = config;
    $[84] = props;
    $[85] = collectionConfig;
    $[86] = router;
    $[87] = collectionPath;
    $[88] = t27;
  } else {
    t27 = $[88];
  }
  let t28;
  if ($[89] !== props.resetCreateItemState || $[90] !== t27) {
    t28 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: props.resetCreateItemState,
      children: t27
    });
    $[89] = props.resetCreateItemState;
    $[90] = t27;
    $[91] = t28;
  } else {
    t28 = $[91];
  }
  let t29;
  if ($[92] !== t24 || $[93] !== t26 || $[94] !== t28) {
    t29 = /*#__PURE__*/jsxs(Fragment, {
      children: [t24, t26, t28]
    });
    $[92] = t24;
    $[93] = t26;
    $[94] = t28;
    $[95] = t29;
  } else {
    t29 = $[95];
  }
  return t29;
}
const menuActions = [{
  key: 'reset',
  label: 'Reset',
  icon: historyIcon
}, {
  key: 'copy',
  label: 'Copy entry',
  icon: clipboardCopyIcon
}, {
  key: 'paste',
  label: 'Paste entry',
  icon: clipboardPasteIcon
}];

const DashboardSection = t0 => {
  const $ = c(5);
  const {
    children,
    title
  } = t0;
  let t1;
  if ($[0] !== title) {
    t1 = /*#__PURE__*/jsx(Text, {
      casing: "uppercase",
      color: "neutralTertiary",
      size: "small",
      weight: "bold",
      elementType: "h2",
      children: title
    });
    $[0] = title;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== t1 || $[3] !== children) {
    t2 = /*#__PURE__*/jsxs(Flex, {
      elementType: "section",
      direction: "column",
      gap: "medium",
      children: [t1, children]
    });
    $[2] = t1;
    $[3] = children;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
};
const FILL_COLS = 'fill';
const DashboardGrid = props => {
  return /*#__PURE__*/jsx("div", {
    className: css({
      display: 'grid',
      gap: tokenSchema.size.space.large,
      gridAutoRows: tokenSchema.size.element.xlarge,
      gridTemplateColumns: `[${FILL_COLS}-start] 1fr [${FILL_COLS}-end]`,
      [containerQueries.above.mobile]: {
        gridTemplateColumns: `[${FILL_COLS}-start] 1fr 1fr [${FILL_COLS}-end]`
      },
      [containerQueries.above.tablet]: {
        gridTemplateColumns: `[${FILL_COLS}-start] 1fr 1fr 1fr [${FILL_COLS}-end]`
      }
    }),
    ...props
  });
};
const DashboardCard = props => {
  const $ = c(12);
  const ref = useRef(null);
  const {
    linkProps
  } = useLink(props, ref);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = classNames(css({
      color: tokenSchema.color.foreground.neutral,
      outline: "none",
      "&:hover": {
        color: tokenSchema.color.foreground.neutralEmphasis,
        "::before": {
          backgroundColor: tokenSchema.color.alias.backgroundIdle,
          borderColor: tokenSchema.color.border.neutral
        }
      },
      "&:active": {
        "::before": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          borderColor: tokenSchema.color.alias.borderHovered
        }
      },
      "&:focus-visible::before": {
        outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`,
        outlineOffset: tokenSchema.size.alias.focusRingGap
      },
      "::before": {
        border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`,
        borderRadius: tokenSchema.size.radius.medium,
        content: "\"\"",
        position: "absolute",
        inset: 0,
        transition: transition(["background-color", "border-color"])
      }
    }));
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] !== ref || $[2] !== props.href || $[3] !== props.label || $[4] !== linkProps) {
    t1 = /*#__PURE__*/jsx(Heading, {
      elementType: "h3",
      size: "small",
      truncate: true,
      children: /*#__PURE__*/jsx("a", {
        ref: ref,
        href: props.href,
        ...linkProps,
        className: t0,
        children: props.label
      })
    });
    $[1] = ref;
    $[2] = props.href;
    $[3] = props.label;
    $[4] = linkProps;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== t1 || $[7] !== props.children) {
    t2 = /*#__PURE__*/jsxs(Flex, {
      direction: "column",
      gap: "medium",
      flex: true,
      children: [t1, props.children]
    });
    $[6] = t1;
    $[7] = props.children;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== t2 || $[10] !== props.endElement) {
    t3 = /*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      backgroundColor: "canvas",
      padding: "large",
      position: "relative",
      children: [t2, props.endElement]
    });
    $[9] = t2;
    $[10] = props.endElement;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
};

function useLocalizedString() {
  const stringFormatter = useLocalizedStringFormatter(strings);
  return stringFormatter;
}

function BranchSection() {
  const $ = c(30);
  const repoInfo = useRepoInfo();
  const currentBranch = useCurrentBranch();
  const router = useRouter();
  const localizedString = useLocalizedString();
  const prNumber = useAssociatedPullRequest();
  let t0;
  if ($[0] !== repoInfo) {
    t0 = repoInfo && getRepoUrl(repoInfo);
    $[0] = repoInfo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const repoURL = t0;
  const isDefaultBranch = currentBranch === (repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.defaultBranch);
  let t1;
  if ($[2] !== localizedString) {
    t1 = localizedString.format("currentBranch");
    $[2] = localizedString;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /*#__PURE__*/jsx(Icon, {
      src: gitBranchIcon,
      color: "neutralTertiary"
    });
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== currentBranch) {
    t3 = /*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      gap: "regular",
      border: "muted",
      borderRadius: "medium",
      backgroundColor: "canvas",
      padding: "large",
      children: [t2, /*#__PURE__*/jsx(Text, {
        size: "medium",
        weight: "semibold",
        children: currentBranch
      })]
    });
    $[5] = currentBranch;
    $[6] = t3;
  } else {
    t3 = $[6];
  }
  let t4;
  if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /*#__PURE__*/jsx(Icon, {
      src: gitBranchPlusIcon
    });
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== localizedString) {
    t5 = localizedString.format("newBranch");
    $[8] = localizedString;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== t5) {
    t6 = /*#__PURE__*/jsxs(ActionButton, {
      children: [t4, /*#__PURE__*/jsx(Text, {
        children: t5
      })]
    });
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== router) {
    t7 = close => /*#__PURE__*/jsx(CreateBranchDialog, {
      onDismiss: close,
      onCreate: branchName => {
        close();
        router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(branchName)));
      }
    });
    $[12] = router;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  let t8;
  if ($[14] !== t6 || $[15] !== t7) {
    t8 = /*#__PURE__*/jsxs(DialogTrigger, {
      children: [t6, t7]
    });
    $[14] = t6;
    $[15] = t7;
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  let t9;
  if ($[17] !== isDefaultBranch || $[18] !== prNumber || $[19] !== repoURL || $[20] !== currentBranch || $[21] !== localizedString) {
    t9 = !isDefaultBranch && prNumber !== undefined && (prNumber === false ? /*#__PURE__*/jsxs(ActionButton, {
      href: `${repoURL}/pull/new/${currentBranch}`,
      target: "_blank",
      children: [/*#__PURE__*/jsx(Icon, {
        src: gitPullRequestIcon
      }), /*#__PURE__*/jsx(Text, {
        children: localizedString.format("createPullRequest")
      })]
    }) : /*#__PURE__*/jsxs(ActionButton, {
      href: `${repoURL}/pull/${prNumber}`,
      target: "_blank",
      children: [/*#__PURE__*/jsx(Icon, {
        src: gitPullRequestIcon
      }), /*#__PURE__*/jsxs(Text, {
        children: ["Pull request #", prNumber]
      })]
    }));
    $[17] = isDefaultBranch;
    $[18] = prNumber;
    $[19] = repoURL;
    $[20] = currentBranch;
    $[21] = localizedString;
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== t8 || $[24] !== t9) {
    t10 = /*#__PURE__*/jsxs(Flex, {
      gap: "regular",
      wrap: true,
      children: [t8, t9]
    });
    $[23] = t8;
    $[24] = t9;
    $[25] = t10;
  } else {
    t10 = $[25];
  }
  let t11;
  if ($[26] !== t1 || $[27] !== t3 || $[28] !== t10) {
    t11 = /*#__PURE__*/jsxs(DashboardSection, {
      title: t1,
      children: [t3, t10]
    });
    $[26] = t1;
    $[27] = t3;
    $[28] = t10;
    $[29] = t11;
  } else {
    t11 = $[29];
  }
  return t11;
}

function DashboardCards() {
  const $ = c(9);
  const navItems = useNavItems();
  let t0;
  if ($[0] !== navItems) {
    let t1;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = item => "children" in item;
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    t0 = navItems.some(t1);
    $[0] = navItems;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const hasSections = t0;
  let t1;
  if ($[3] !== navItems) {
    let t2;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = item_0 => renderItemOrGroup(item_0);
      $[5] = t2;
    } else {
      t2 = $[5];
    }
    t1 = navItems.map(t2);
    $[3] = navItems;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const items = t1;
  let t2;
  if ($[6] !== hasSections || $[7] !== items) {
    t2 = hasSections ? /*#__PURE__*/jsx(Fragment, {
      children: items
    }) : /*#__PURE__*/jsx(DashboardSection, {
      title: "Content",
      children: /*#__PURE__*/jsx(DashboardGrid, {
        children: items
      })
    });
    $[6] = hasSections;
    $[7] = items;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  return t2;
}
let dividerCount = 0;
function renderItemOrGroup(itemOrGroup) {
  if (itemOrGroup.isDivider) {
    return /*#__PURE__*/jsx(Flex, {
      gridColumn: FILL_COLS,
      children: /*#__PURE__*/jsx(Divider, {
        alignSelf: "center",
        size: "medium",
        width: "alias.singleLineWidth"
      })
    }, dividerCount++);
  }
  if (itemOrGroup.children) {
    return /*#__PURE__*/jsx(DashboardSection, {
      title: itemOrGroup.title,
      children: /*#__PURE__*/jsx(DashboardGrid, {
        children: itemOrGroup.children.map(child => renderItemOrGroup(child))
      })
    }, itemOrGroup.title);
  }
  let changeElement = (() => {
    if (!itemOrGroup.changed) {
      return undefined;
    }
    return typeof itemOrGroup.changed === 'number' ? /*#__PURE__*/jsx(Badge, {
      tone: "accent",
      marginStart: "auto",
      children: pluralize(itemOrGroup.changed, {
        singular: 'change',
        plural: 'changes'
      })
    }) : /*#__PURE__*/jsx(Badge, {
      tone: "accent",
      children: "Changed"
    });
  })();
  let endElement = (() => {
    // entry counts are only available for collections
    if (typeof itemOrGroup.entryCount !== 'number') {
      return changeElement;
    }
    return /*#__PURE__*/jsxs(Flex, {
      gap: "medium",
      alignItems: "center",
      children: [changeElement, /*#__PURE__*/jsx(ActionButton, {
        "aria-label": "Add",
        href: `${itemOrGroup.href}/create`,
        children: /*#__PURE__*/jsx(Icon, {
          src: plusIcon
        })
      })]
    });
  })();
  return /*#__PURE__*/jsx(DashboardCard, {
    label: itemOrGroup.label,
    href: itemOrGroup.href,
    endElement: endElement,
    children: typeof itemOrGroup.entryCount === 'number' ? /*#__PURE__*/jsx(Text, {
      color: "neutralSecondary",
      children: pluralize(itemOrGroup.entryCount, {
        singular: 'entry',
        plural: 'entries'
      })
    }) : null
  }, itemOrGroup.key);
}

function DashboardPage(props) {
  const $ = c(19);
  const stringFormatter = useLocalizedStringFormatter(strings);
  const viewer = useViewer();
  const cloudInfo = useCloudInfo();
  let t0;
  if ($[0] !== viewer || $[1] !== cloudInfo) {
    var _viewer$name;
    t0 = viewer ? {
      name: (_viewer$name = viewer.name) !== null && _viewer$name !== void 0 ? _viewer$name : viewer.login,
      avatarUrl: viewer.avatarUrl
    } : cloudInfo === null || cloudInfo === void 0 ? void 0 : cloudInfo.user;
    $[0] = viewer;
    $[1] = cloudInfo;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const user = t0;
  let t1;
  if ($[3] !== stringFormatter) {
    t1 = stringFormatter.format("dashboard");
    $[3] = stringFormatter;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = /*#__PURE__*/jsx(PageHeader, {
      children: /*#__PURE__*/jsx(Heading, {
        elementType: "h1",
        id: "page-title",
        size: "small",
        children: t1
      })
    });
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== user || $[8] !== cloudInfo) {
    t3 = user && /*#__PURE__*/jsx(UserInfo, {
      user: user,
      manageAccount: !!cloudInfo
    });
    $[7] = user;
    $[8] = cloudInfo;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== props.config) {
    t4 = !isLocalConfig(props.config) && /*#__PURE__*/jsx(BranchSection, {});
    $[10] = props.config;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  let t5;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /*#__PURE__*/jsx(DashboardCards, {});
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== t3 || $[14] !== t4) {
    t6 = /*#__PURE__*/jsx(PageBody, {
      isScrollable: true,
      children: /*#__PURE__*/jsxs(Flex, {
        direction: "column",
        gap: "xxlarge",
        children: [t3, t4, t5]
      })
    });
    $[13] = t3;
    $[14] = t4;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  let t7;
  if ($[16] !== t2 || $[17] !== t6) {
    t7 = /*#__PURE__*/jsxs(PageRoot, {
      containerWidth: "large",
      children: [t2, t6]
    });
    $[16] = t2;
    $[17] = t6;
    $[18] = t7;
  } else {
    t7 = $[18];
  }
  return t7;
}
function UserInfo(t0) {
  const $ = c(15);
  const {
    user,
    manageAccount
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {
      below: "tablet"
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== user.avatarUrl || $[2] !== user.name) {
    t2 = /*#__PURE__*/jsx(Avatar, {
      src: user.avatarUrl,
      name: user.name,
      size: "large"
    });
    $[1] = user.avatarUrl;
    $[2] = user.name;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      fontWeight: tokenSchema.typography.fontWeight.bold
    };
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== user.name) {
    t4 = /*#__PURE__*/jsxs(Heading, {
      size: "medium",
      elementType: "p",
      UNSAFE_style: t3,
      children: ["Hello, ", user.name, "!"]
    });
    $[5] = user.name;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== manageAccount) {
    t5 = manageAccount && /*#__PURE__*/jsx(TextLink, {
      href: "https://keystatic.cloud/account",
      children: "Manage Account"
    });
    $[7] = manageAccount;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== t4 || $[10] !== t5) {
    t6 = /*#__PURE__*/jsxs(VStack, {
      gap: "medium",
      children: [t4, t5]
    });
    $[9] = t4;
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== t2 || $[13] !== t6) {
    t7 = /*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      gap: "medium",
      isHidden: t1,
      children: [t2, t6]
    });
    $[12] = t2;
    $[13] = t6;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  return t7;
}

const MainPanelLayout = props => {
  const $ = c(13);
  const isBelowDesktop = useMediaQuery(breakpointQueries.below.desktop);
  const sidebarState = useSidebar();
  const ref = useRef(null);
  const context = useContentPanelState(ref);
  const t0 = isBelowDesktop || !sidebarState.isOpen;
  let t1;
  if ($[0] !== isBelowDesktop) {
    t1 = isBelowDesktop ? /*#__PURE__*/jsx(SidebarDialog, {}) : /*#__PURE__*/jsx(SplitPanePrimary, {
      children: /*#__PURE__*/jsx(SidebarPanel, {})
    });
    $[0] = isBelowDesktop;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== ref || $[3] !== props.children) {
    t2 = /*#__PURE__*/jsx(SplitPaneSecondary, {
      ref: ref,
      children: props.children
    });
    $[2] = ref;
    $[3] = props.children;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== t0 || $[6] !== sidebarState.toggle || $[7] !== t1 || $[8] !== t2) {
    t3 = /*#__PURE__*/jsxs(SplitView, {
      autoSaveId: "keystatic-app-split-view",
      isCollapsed: t0,
      onCollapseChange: sidebarState.toggle,
      defaultSize: 260,
      minSize: 180,
      maxSize: 400,
      height: "100vh",
      children: [t1, t2]
    });
    $[5] = t0;
    $[6] = sidebarState.toggle;
    $[7] = t1;
    $[8] = t2;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== context || $[11] !== t3) {
    t4 = /*#__PURE__*/jsx(ContentPanelProvider, {
      value: context,
      children: t3
    });
    $[10] = context;
    $[11] = t3;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  return t4;
};

function BranchNotFound(props) {
  var _appShellDataContext$;
  const $ = c(2);
  const branches = useBranches();
  const currentBranch = useCurrentBranch();
  const appShellDataContext = useContext(GitHubAppShellDataContext);
  if ((appShellDataContext === null || appShellDataContext === void 0 || (_appShellDataContext$ = appShellDataContext.data) === null || _appShellDataContext$ === void 0 || (_appShellDataContext$ = _appShellDataContext$.repository) === null || _appShellDataContext$ === void 0 || (_appShellDataContext$ = _appShellDataContext$.refs) === null || _appShellDataContext$ === void 0 ? void 0 : _appShellDataContext$.pageInfo.hasNextPage) === false && !branches.has(currentBranch)) {
    const t0 = `The branch ${currentBranch} does not exist in this repository.`;
    let t1;
    if ($[0] !== t0) {
      t1 = /*#__PURE__*/jsx(EmptyState, {
        icon: alertCircleIcon,
        title: "Branch not found",
        message: t0
      });
      $[0] = t0;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    return t1;
  }
  return props.children;
}
const AppShell = props => {
  const $ = c(19);
  let t0;
  if ($[0] !== props.children) {
    t0 = /*#__PURE__*/jsx(AppShellErrorContext.Consumer, {
      children: error => error && !(error !== null && error !== void 0 && error.graphQLErrors.some(err => {
        var _err$originalError;
        return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === "NOT_FOUND";
      })) ? /*#__PURE__*/jsx(EmptyState, {
        icon: alertCircleIcon,
        title: "Failed to load shell",
        message: error.message
      }) : props.children
    });
    $[0] = props.children;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const content = t0;
  let t1;
  if ($[2] !== props.basePath) {
    t1 = {
      basePath: props.basePath
    };
    $[2] = props.basePath;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== content) {
    t2 = /*#__PURE__*/jsx(SidebarProvider, {
      children: /*#__PURE__*/jsx(MainPanelLayout, {
        children: /*#__PURE__*/jsx(BranchNotFound, {
          children: content
        })
      })
    });
    $[4] = content;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== t1 || $[7] !== t2) {
    t3 = /*#__PURE__*/jsx(AppStateContext.Provider, {
      value: t1,
      children: t2
    });
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== props.config || $[10] !== t3) {
    t4 = /*#__PURE__*/jsx(ConfigContext.Provider, {
      value: props.config,
      children: t3
    });
    $[9] = props.config;
    $[10] = t3;
    $[11] = t4;
  } else {
    t4 = $[11];
  }
  const inner = t4;
  if (isGitHubConfig(props.config) || props.config.storage.kind === "cloud") {
    let t5;
    if ($[12] !== props.currentBranch || $[13] !== props.config || $[14] !== inner) {
      t5 = /*#__PURE__*/jsx(GitHubAppShellProvider, {
        currentBranch: props.currentBranch,
        config: props.config,
        children: inner
      });
      $[12] = props.currentBranch;
      $[13] = props.config;
      $[14] = inner;
      $[15] = t5;
    } else {
      t5 = $[15];
    }
    return t5;
  }
  if (isLocalConfig(props.config)) {
    let t5;
    if ($[16] !== props.config || $[17] !== inner) {
      t5 = /*#__PURE__*/jsx(LocalAppShellProvider, {
        config: props.config,
        children: inner
      });
      $[16] = props.config;
      $[17] = inner;
      $[18] = t5;
    } else {
      t5 = $[18];
    }
    return t5;
  }
  return null;
};

function SingletonPageInner(props) {
  const $ = c(96);
  const isBelowDesktop = useMediaQuery(breakpointQueries.below.desktop);
  const repoInfo = useRepoInfo();
  const currentBranch = useCurrentBranch();
  const [forceValidation, setForceValidation] = useState(false);
  const {
    schema,
    singletonConfig
  } = useSingleton(props.singleton);
  const router = useRouter();
  let t0;
  bb0: {
    if (!singletonConfig.previewUrl) {
      t0 = undefined;
      break bb0;
    }
    let t1;
    if ($[0] !== singletonConfig.previewUrl || $[1] !== currentBranch) {
      t1 = singletonConfig.previewUrl.replace("{branch}", currentBranch);
      $[0] = singletonConfig.previewUrl;
      $[1] = currentBranch;
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    t0 = t1;
  }
  const previewHref = t0;
  let t1;
  if ($[3] !== props.config) {
    t1 = isGitHubConfig(props.config) || isCloudConfig(props.config);
    $[3] = props.config;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const isGitHub = t1;
  let t2;
  let formatInfo;
  if ($[5] !== props.config || $[6] !== props.singleton || $[7] !== props.initialState || $[8] !== isGitHub || $[9] !== repoInfo || $[10] !== currentBranch) {
    var _getPathPrefix, _getPathPrefix2;
    formatInfo = getSingletonFormat(props.config, props.singleton);
    const singletonExists = !!props.initialState;
    const singletonPath = getSingletonPath(props.config, props.singleton);
    t2 = isGitHub && singletonExists && repoInfo ? `${getRepoUrl(repoInfo)}${formatInfo.dataLocation === "index" ? `/tree/${currentBranch}/${(_getPathPrefix = getPathPrefix(props.config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${singletonPath}` : `/blob/${(_getPathPrefix2 = getPathPrefix(props.config.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : ""}${currentBranch}/${singletonPath}${getDataFileExtension(formatInfo)}`}` : undefined;
    $[5] = props.config;
    $[6] = props.singleton;
    $[7] = props.initialState;
    $[8] = isGitHub;
    $[9] = repoInfo;
    $[10] = currentBranch;
    $[11] = t2;
    $[12] = formatInfo;
  } else {
    t2 = $[11];
    formatInfo = $[12];
  }
  const viewHref = t2;
  let t3;
  let t4;
  if ($[13] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = {
      key: "reset",
      label: "Reset",
      icon: historyIcon
    };
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      key: "copy",
      label: "Copy entry",
      icon: clipboardCopyIcon
    };
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  let t6;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = {
      key: "paste",
      label: "Paste entry",
      icon: clipboardPasteIcon
    };
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  let actions;
  if ($[16] !== previewHref || $[17] !== viewHref) {
    actions = [t4, t5, t6];
    if (previewHref) {
      let t7;
      if ($[19] !== previewHref) {
        t7 = {
          key: "preview",
          label: "Preview",
          icon: externalLinkIcon,
          href: previewHref,
          target: "_blank",
          rel: "noopener noreferrer"
        };
        $[19] = previewHref;
        $[20] = t7;
      } else {
        t7 = $[20];
      }
      actions.push(t7);
    }
    if (viewHref) {
      let t7;
      if ($[21] !== viewHref) {
        t7 = {
          key: "view",
          label: "View on GitHub",
          icon: githubIcon,
          href: viewHref,
          target: "_blank",
          rel: "noopener noreferrer"
        };
        $[21] = viewHref;
        $[22] = t7;
      } else {
        t7 = $[22];
      }
      actions.push(t7);
    }
    $[16] = previewHref;
    $[17] = viewHref;
    $[18] = actions;
  } else {
    actions = $[18];
  }
  t3 = actions;
  const menuActions = t3;
  const baseCommit = useBaseCommit();
  const isCreating = props.initialState === null;
  let t7;
  if ($[23] !== props || $[24] !== schema) {
    t7 = async () => {
      if (props.updateResult.kind === "loading" || !props.hasChanged) {
        return;
      }
      if (!clientSideValidateProp(schema, props.state, undefined)) {
        setForceValidation(true);
        return;
      }
      await props.onUpdate();
    };
    $[23] = props;
    $[24] = schema;
    $[25] = t7;
  } else {
    t7 = $[25];
  }
  const onCreate = t7;
  let t8;
  if ($[26] !== props.state || $[27] !== formatInfo || $[28] !== singletonConfig.schema) {
    t8 = () => {
      copyEntryToClipboard(props.state, formatInfo, singletonConfig.schema, undefined);
    };
    $[26] = props.state;
    $[27] = formatInfo;
    $[28] = singletonConfig.schema;
    $[29] = t8;
  } else {
    t8 = $[29];
  }
  const onCopy = t8;
  let t9;
  if ($[30] !== formatInfo || $[31] !== singletonConfig.schema || $[32] !== props.previewProps || $[33] !== props.state) {
    t9 = async () => {
      const entry = await getPastedEntry(formatInfo, singletonConfig.schema, undefined);
      if (entry) {
        setValueToPreviewProps(entry, props.previewProps);
        toastQueue.positive("Entry pasted", {
          shouldCloseOnAction: true,
          actionLabel: "Undo",
          onAction: () => {
            setValueToPreviewProps(props.state, props.previewProps);
          }
        });
      }
    };
    $[30] = formatInfo;
    $[31] = singletonConfig.schema;
    $[32] = props.previewProps;
    $[33] = props.state;
    $[34] = t9;
  } else {
    t9 = $[34];
  }
  const onPaste = t9;
  let t10;
  if ($[35] !== singletonConfig) {
    t10 = containerWidthForEntryLayout(singletonConfig);
    $[35] = singletonConfig;
    $[36] = t10;
  } else {
    t10 = $[36];
  }
  let t11;
  if ($[37] !== singletonConfig.label) {
    t11 = /*#__PURE__*/jsx(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      children: singletonConfig.label
    });
    $[37] = singletonConfig.label;
    $[38] = t11;
  } else {
    t11 = $[38];
  }
  let t12;
  if ($[39] !== props || $[40] !== singletonConfig) {
    t12 = props.updateResult.kind === "loading" ? /*#__PURE__*/jsx(ProgressCircle, {
      "aria-label": `Updating ${singletonConfig.label}`,
      isIndeterminate: true,
      size: "small",
      alignSelf: "center"
    }) : props.hasChanged && /*#__PURE__*/jsx(Badge, {
      tone: "pending",
      children: "Unsaved"
    });
    $[39] = props;
    $[40] = singletonConfig;
    $[41] = t12;
  } else {
    t12 = $[41];
  }
  let t13;
  if ($[42] !== t11 || $[43] !== t12) {
    t13 = /*#__PURE__*/jsxs(Flex, {
      flex: true,
      alignItems: "center",
      gap: "regular",
      children: [t11, t12]
    });
    $[42] = t11;
    $[43] = t12;
    $[44] = t13;
  } else {
    t13 = $[44];
  }
  let t14;
  if ($[45] === Symbol.for("react.memo_cache_sentinel")) {
    t14 = /*#__PURE__*/jsx(PresenceAvatars, {});
    $[45] = t14;
  } else {
    t14 = $[45];
  }
  const t15 = isBelowDesktop ? "element.regular" : undefined;
  let t16;
  if ($[46] !== props.hasChanged) {
    t16 = props.hasChanged ? [] : ["reset"];
    $[46] = props.hasChanged;
    $[47] = t16;
  } else {
    t16 = $[47];
  }
  let t17;
  if ($[48] !== props || $[49] !== onCopy || $[50] !== onPaste) {
    t17 = key => {
      bb73: switch (key) {
        case "reset":
          {
            props.onReset();
            break bb73;
          }
        case "copy":
          {
            onCopy();
            break bb73;
          }
        case "paste":
          {
            onPaste();
          }
      }
    };
    $[48] = props;
    $[49] = onCopy;
    $[50] = onPaste;
    $[51] = t17;
  } else {
    t17 = $[51];
  }
  let t18;
  if ($[52] === Symbol.for("react.memo_cache_sentinel")) {
    t18 = item => /*#__PURE__*/jsxs(Item$1, {
      textValue: item.label,
      href: item.href,
      target: item.target,
      rel: item.rel,
      children: [/*#__PURE__*/jsx(Icon, {
        src: item.icon
      }), /*#__PURE__*/jsx(Text, {
        children: item.label
      })]
    }, item.key);
    $[52] = t18;
  } else {
    t18 = $[52];
  }
  let t19;
  if ($[53] !== t15 || $[54] !== menuActions || $[55] !== t16 || $[56] !== t17) {
    t19 = /*#__PURE__*/jsx(ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: t15,
      items: menuActions,
      disabledKeys: t16,
      onAction: t17,
      children: t18
    });
    $[53] = t15;
    $[54] = menuActions;
    $[55] = t16;
    $[56] = t17;
    $[57] = t19;
  } else {
    t19 = $[57];
  }
  const t20 = props.updateResult.kind === "loading";
  const t21 = isCreating ? "Create" : "Save";
  let t22;
  if ($[58] !== t20 || $[59] !== t21) {
    t22 = /*#__PURE__*/jsx(Button, {
      form: "singleton-form",
      isDisabled: t20,
      prominence: "high",
      type: "submit",
      children: t21
    });
    $[58] = t20;
    $[59] = t21;
    $[60] = t22;
  } else {
    t22 = $[60];
  }
  let t23;
  if ($[61] !== t13 || $[62] !== t19 || $[63] !== t22) {
    t23 = /*#__PURE__*/jsxs(PageHeader, {
      children: [t13, t14, t19, t22]
    });
    $[61] = t13;
    $[62] = t19;
    $[63] = t22;
    $[64] = t23;
  } else {
    t23 = $[64];
  }
  let t24;
  if ($[65] !== onCreate) {
    t24 = event => {
      if (event.target !== event.currentTarget) {
        return;
      }
      event.preventDefault();
      onCreate();
    };
    $[65] = onCreate;
    $[66] = t24;
  } else {
    t24 = $[66];
  }
  let t25;
  if ($[67] !== props.updateResult) {
    t25 = props.updateResult.kind === "error" && /*#__PURE__*/jsx(Notice, {
      tone: "critical",
      children: props.updateResult.error.message
    });
    $[67] = props.updateResult;
    $[68] = t25;
  } else {
    t25 = $[68];
  }
  const t26 = props.previewProps;
  let t27;
  if ($[69] !== t26 || $[70] !== forceValidation || $[71] !== singletonConfig.entryLayout || $[72] !== formatInfo) {
    t27 = /*#__PURE__*/jsx(FormForEntry, {
      previewProps: t26,
      forceValidation: forceValidation,
      entryLayout: singletonConfig.entryLayout,
      formatInfo: formatInfo,
      slugField: undefined
    });
    $[69] = t26;
    $[70] = forceValidation;
    $[71] = singletonConfig.entryLayout;
    $[72] = formatInfo;
    $[73] = t27;
  } else {
    t27 = $[73];
  }
  let t28;
  if ($[74] !== props || $[75] !== router || $[76] !== baseCommit) {
    t28 = props.updateResult.kind === "needs-new-branch" && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
      branchOid: baseCommit,
      onCreate: async newBranch => {
        router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/singleton/${encodeURIComponent(props.singleton)}`);
        props.onUpdate({
          branch: newBranch,
          sha: baseCommit
        });
      },
      reason: props.updateResult.reason,
      onDismiss: props.onResetUpdateItem
    });
    $[74] = props;
    $[75] = router;
    $[76] = baseCommit;
    $[77] = t28;
  } else {
    t28 = $[77];
  }
  let t29;
  if ($[78] !== props.onResetUpdateItem || $[79] !== t28) {
    t29 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: props.onResetUpdateItem,
      children: t28
    });
    $[78] = props.onResetUpdateItem;
    $[79] = t28;
    $[80] = t29;
  } else {
    t29 = $[80];
  }
  let t30;
  if ($[81] !== props) {
    t30 = props.updateResult.kind === "needs-fork" && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
      onCreate: async () => {
        props.onUpdate();
      },
      onDismiss: props.onResetUpdateItem,
      config: props.config
    });
    $[81] = props;
    $[82] = t30;
  } else {
    t30 = $[82];
  }
  let t31;
  if ($[83] !== props.onResetUpdateItem || $[84] !== t30) {
    t31 = /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: props.onResetUpdateItem,
      children: t30
    });
    $[83] = props.onResetUpdateItem;
    $[84] = t30;
    $[85] = t31;
  } else {
    t31 = $[85];
  }
  let t32;
  if ($[86] !== t24 || $[87] !== t25 || $[88] !== t27 || $[89] !== t29 || $[90] !== t31) {
    t32 = /*#__PURE__*/jsxs(Flex, {
      elementType: "form",
      id: "singleton-form",
      onSubmit: t24,
      direction: "column",
      gap: "xxlarge",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children: [t25, t27, t29, t31]
    });
    $[86] = t24;
    $[87] = t25;
    $[88] = t27;
    $[89] = t29;
    $[90] = t31;
    $[91] = t32;
  } else {
    t32 = $[91];
  }
  let t33;
  if ($[92] !== t10 || $[93] !== t23 || $[94] !== t32) {
    t33 = /*#__PURE__*/jsxs(PageRoot, {
      containerWidth: t10,
      children: [t23, t32]
    });
    $[92] = t10;
    $[93] = t23;
    $[94] = t32;
    $[95] = t33;
  } else {
    t33 = $[95];
  }
  return t33;
}
function LocalSingletonPage(props) {
  const $ = c(49);
  const {
    singleton,
    initialFiles,
    initialState,
    localTreeKey,
    config,
    draft
  } = props;
  const {
    schema,
    singletonConfig
  } = useSingleton(props.singleton);
  let t0;
  if ($[0] !== config || $[1] !== singleton) {
    t0 = getSingletonPath(config, singleton);
    $[0] = config;
    $[1] = singleton;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const singletonPath = t0;
  let t1;
  if ($[3] !== localTreeKey || $[4] !== draft || $[5] !== initialState || $[6] !== schema) {
    t1 = () => {
      var _draft$state;
      return {
        localTreeKey,
        state: (_draft$state = draft === null || draft === void 0 ? void 0 : draft.state) !== null && _draft$state !== void 0 ? _draft$state : initialState === null ? getInitialPropsValue(schema) : initialState
      };
    };
    $[3] = localTreeKey;
    $[4] = draft;
    $[5] = initialState;
    $[6] = schema;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const [t2, setState] = useState(t1);
  const {
    state,
    localTreeKey: localTreeKeyInState
  } = t2;
  useShowRestoredDraftMessage(draft, state, localTreeKey);
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      localTreeKey,
      state: initialState === null ? getInitialPropsValue(schema) : initialState
    });
  }
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema,
    slugField: undefined
  }) || isCreating;
  let t3;
  if ($[8] !== singleton || $[9] !== hasChanged || $[10] !== singletonPath || $[11] !== config || $[12] !== singletonConfig.schema || $[13] !== state || $[14] !== localTreeKey) {
    t3 = () => {
      const key = ["singleton", singleton];
      if (hasChanged) {
        const serialized = serializeEntryToFiles({
          basePath: singletonPath,
          format: getSingletonFormat(config, singleton),
          schema: singletonConfig.schema,
          slug: undefined,
          state
        });
        const files = new Map(serialized.map(x => [x.path, x.contents]));
        const data = {
          beforeTreeKey: localTreeKey,
          files,
          savedAt: new Date(),
          version: 1
        };
        setDraft(key, data);
      } else {
        delDraft(key);
      }
    };
    $[8] = singleton;
    $[9] = hasChanged;
    $[10] = singletonPath;
    $[11] = config;
    $[12] = singletonConfig.schema;
    $[13] = state;
    $[14] = localTreeKey;
    $[15] = t3;
  } else {
    t3 = $[15];
  }
  let t4;
  if ($[16] !== config || $[17] !== localTreeKey || $[18] !== state || $[19] !== hasChanged || $[20] !== singleton || $[21] !== singletonPath || $[22] !== singletonConfig) {
    t4 = [config, localTreeKey, state, hasChanged, singleton, singletonPath, singletonConfig];
    $[16] = config;
    $[17] = localTreeKey;
    $[18] = state;
    $[19] = hasChanged;
    $[20] = singleton;
    $[21] = singletonPath;
    $[22] = singletonConfig;
    $[23] = t4;
  } else {
    t4 = $[23];
  }
  useEffect(t3, t4);
  let t5;
  if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = cb => {
      setState(state_0 => ({
        localTreeKey: state_0.localTreeKey,
        state: cb(state_0.state)
      }));
    };
    $[24] = t5;
  } else {
    t5 = $[24];
  }
  const onPreviewPropsChange = t5;
  const previewProps = usePreviewProps(schema, onPreviewPropsChange, state);
  let t6;
  if ($[25] !== config || $[26] !== singleton) {
    t6 = getSingletonFormat(config, singleton);
    $[25] = config;
    $[26] = singleton;
    $[27] = t6;
  } else {
    t6 = $[27];
  }
  const formatInfo = t6;
  let t7;
  if ($[28] !== state || $[29] !== initialFiles || $[30] !== config || $[31] !== singletonConfig.schema || $[32] !== singletonPath || $[33] !== formatInfo || $[34] !== localTreeKey) {
    t7 = {
      state,
      initialFiles,
      config,
      schema: singletonConfig.schema,
      basePath: singletonPath,
      format: formatInfo,
      currentLocalTreeKey: localTreeKey,
      slug: undefined
    };
    $[28] = state;
    $[29] = initialFiles;
    $[30] = config;
    $[31] = singletonConfig.schema;
    $[32] = singletonPath;
    $[33] = formatInfo;
    $[34] = localTreeKey;
    $[35] = t7;
  } else {
    t7 = $[35];
  }
  const [updateResult, _update, resetUpdateItem] = useUpsertItem(t7);
  const update = useEventCallback(_update);
  let t8;
  if ($[36] !== localTreeKey || $[37] !== initialState || $[38] !== schema) {
    t8 = () => setState({
      localTreeKey,
      state: initialState === null ? getInitialPropsValue(schema) : initialState
    });
    $[36] = localTreeKey;
    $[37] = initialState;
    $[38] = schema;
    $[39] = t8;
  } else {
    t8 = $[39];
  }
  const onReset = t8;
  let t9;
  if ($[40] !== props || $[41] !== hasChanged || $[42] !== onReset || $[43] !== update || $[44] !== resetUpdateItem || $[45] !== updateResult || $[46] !== state || $[47] !== previewProps) {
    t9 = /*#__PURE__*/jsx(SingletonPageInner, {
      ...props,
      hasChanged: hasChanged,
      onReset: onReset,
      onUpdate: update,
      onResetUpdateItem: resetUpdateItem,
      updateResult: updateResult,
      state: state,
      previewProps: previewProps
    });
    $[40] = props;
    $[41] = hasChanged;
    $[42] = onReset;
    $[43] = update;
    $[44] = resetUpdateItem;
    $[45] = updateResult;
    $[46] = state;
    $[47] = previewProps;
    $[48] = t9;
  } else {
    t9 = $[48];
  }
  return t9;
}
function CollabSingletonPage(props) {
  const $ = c(27);
  const {
    singleton,
    initialFiles,
    initialState,
    localTreeKey,
    config
  } = props;
  const {
    schema,
    singletonConfig
  } = useSingleton(props.singleton);
  let t0;
  if ($[0] !== config || $[1] !== singleton) {
    t0 = getSingletonPath(config, singleton);
    $[0] = config;
    $[1] = singleton;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const singletonPath = t0;
  const state = useYJsValue(schema, props.map);
  const previewProps = usePreviewPropsFromY(schema, props.map, state);
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema,
    slugField: undefined
  }) || isCreating;
  let t1;
  if ($[3] !== config || $[4] !== singleton) {
    t1 = getSingletonFormat(config, singleton);
    $[3] = config;
    $[4] = singleton;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const formatInfo = t1;
  let t2;
  if ($[6] !== state || $[7] !== initialFiles || $[8] !== config || $[9] !== singletonConfig.schema || $[10] !== singletonPath || $[11] !== formatInfo || $[12] !== localTreeKey) {
    t2 = {
      state,
      initialFiles,
      config,
      schema: singletonConfig.schema,
      basePath: singletonPath,
      format: formatInfo,
      currentLocalTreeKey: localTreeKey,
      slug: undefined
    };
    $[6] = state;
    $[7] = initialFiles;
    $[8] = config;
    $[9] = singletonConfig.schema;
    $[10] = singletonPath;
    $[11] = formatInfo;
    $[12] = localTreeKey;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  const [updateResult, _update, resetUpdateItem] = useUpsertItem(t2);
  const update = useEventCallback(_update);
  let t3;
  if ($[14] !== props.map || $[15] !== props.initialState || $[16] !== singletonConfig.schema) {
    t3 = () => {
      props.map.doc.transact(() => {
        for (const [key, value] of Object.entries(singletonConfig.schema)) {
          var _props$initialState$k, _props$initialState;
          const val = getYjsValFromParsedValue(value, (_props$initialState$k = (_props$initialState = props.initialState) === null || _props$initialState === void 0 ? void 0 : _props$initialState[key]) !== null && _props$initialState$k !== void 0 ? _props$initialState$k : getInitialPropsValue(value));
          props.map.set(key, val);
        }
      });
    };
    $[14] = props.map;
    $[15] = props.initialState;
    $[16] = singletonConfig.schema;
    $[17] = t3;
  } else {
    t3 = $[17];
  }
  const onReset = t3;
  let t4;
  if ($[18] !== props || $[19] !== hasChanged || $[20] !== onReset || $[21] !== update || $[22] !== resetUpdateItem || $[23] !== updateResult || $[24] !== state || $[25] !== previewProps) {
    t4 = /*#__PURE__*/jsx(SingletonPageInner, {
      ...props,
      hasChanged: hasChanged,
      onReset: onReset,
      onUpdate: update,
      onResetUpdateItem: resetUpdateItem,
      updateResult: updateResult,
      state: state,
      previewProps: previewProps
    });
    $[18] = props;
    $[19] = hasChanged;
    $[20] = onReset;
    $[21] = update;
    $[22] = resetUpdateItem;
    $[23] = updateResult;
    $[24] = state;
    $[25] = previewProps;
    $[26] = t4;
  } else {
    t4 = $[26];
  }
  return t4;
}
const storedValSchema = s.type({
  version: s.literal(1),
  savedAt: s.date(),
  beforeTreeKey: s.optional(s.string()),
  files: s.map(s.string(), s.instance(Uint8Array))
});
function SingletonPageWrapper(props) {
  var _props$config$singlet;
  const $ = c(55);
  const singletonConfig = (_props$config$singlet = props.config.singletons) === null || _props$config$singlet === void 0 ? void 0 : _props$config$singlet[props.singleton];
  if (!singletonConfig) {
    notFound();
  }
  let t0;
  if ($[0] !== singletonConfig.label) {
    t0 = /*#__PURE__*/jsx(PageHeader, {
      children: /*#__PURE__*/jsx(Heading, {
        elementType: "h1",
        id: "page-title",
        size: "small",
        children: singletonConfig.label
      })
    });
    $[0] = singletonConfig.label;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const header = t0;
  let t1;
  let t2;
  if ($[2] !== props.config || $[3] !== props.singleton) {
    t2 = getSingletonFormat(props.config, props.singleton);
    $[2] = props.config;
    $[3] = props.singleton;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  t1 = t2;
  const format = t1;
  let t3;
  if ($[5] !== props.config || $[6] !== props.singleton) {
    t3 = getSingletonPath(props.config, props.singleton);
    $[5] = props.config;
    $[6] = props.singleton;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  const dirpath = t3;
  let t4;
  if ($[8] !== props.singleton || $[9] !== dirpath || $[10] !== format || $[11] !== singletonConfig.schema) {
    t4 = async () => {
      const raw = await getDraft(["singleton", props.singleton]);
      if (!raw) {
        throw new Error("No draft found");
      }
      const stored = storedValSchema.create(raw);
      const parsed = parseEntry({
        dirpath,
        format,
        schema: singletonConfig.schema,
        slug: undefined
      }, stored.files);
      return {
        state: parsed.initialState,
        savedAt: stored.savedAt,
        treeKey: stored.beforeTreeKey
      };
    };
    $[8] = props.singleton;
    $[9] = dirpath;
    $[10] = format;
    $[11] = singletonConfig.schema;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  const draftData = useData(t4);
  let t5;
  if ($[13] !== props.config || $[14] !== dirpath || $[15] !== singletonConfig.schema || $[16] !== format) {
    t5 = {
      config: props.config,
      dirpath,
      schema: singletonConfig.schema,
      format,
      slug: undefined
    };
    $[13] = props.config;
    $[14] = dirpath;
    $[15] = singletonConfig.schema;
    $[16] = format;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  const itemData = useItemData(t5);
  const currentBranch = useCurrentBranch();
  const key = `${currentBranch}/${props.singleton}`;
  const yjsInfo = useYjsIfAvailable();
  const isItemDataLoading = itemData.kind === "loading";
  let t6;
  if ($[18] !== yjsInfo || $[19] !== isItemDataLoading || $[20] !== key) {
    t6 = async () => {
      if (!yjsInfo) {
        return;
      }
      if (yjsInfo === "loading") {
        return LOADING;
      }
      await yjsInfo.doc.whenSynced;
      if (isItemDataLoading) {
        return LOADING;
      }
      let doc = yjsInfo.data.get(key);
      if (doc instanceof Y.Doc) {
        const promise = doc.whenLoaded;
        doc.load();
        await promise;
      } else {
        doc = new Y.Doc();
        yjsInfo.data.set(key, doc);
      }
      return doc.getMap("data");
    };
    $[18] = yjsInfo;
    $[19] = isItemDataLoading;
    $[20] = key;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  const mapData = useData(t6);
  bb0: {
    if (mapData.kind !== "loaded" || itemData.kind !== "loaded" || !mapData.data || mapData.data.size) {
      break bb0;
    }
    const data = mapData.data;
    data.doc.transact(() => {
      for (const [key_0, value] of Object.entries(singletonConfig.schema)) {
        const val = getYjsValFromParsedValue(value, itemData.data === "not-found" ? getInitialPropsValue(value) : itemData.data.initialState[key_0]);
        data.set(key_0, val);
      }
    });
  }
  if (itemData.kind === "error") {
    let t8;
    if ($[22] !== itemData.error.message) {
      t8 = /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: itemData.error.message
        })
      });
      $[22] = itemData.error.message;
      $[23] = t8;
    } else {
      t8 = $[23];
    }
    let t9;
    if ($[24] !== header || $[25] !== t8) {
      t9 = /*#__PURE__*/jsxs(PageRoot, {
        children: [header, t8]
      });
      $[24] = header;
      $[25] = t8;
      $[26] = t9;
    } else {
      t9 = $[26];
    }
    return t9;
  }
  if (mapData.kind === "error") {
    let t8;
    if ($[27] !== mapData.error.message) {
      t8 = /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: mapData.error.message
        })
      });
      $[27] = mapData.error.message;
      $[28] = t8;
    } else {
      t8 = $[28];
    }
    let t9;
    if ($[29] !== header || $[30] !== t8) {
      t9 = /*#__PURE__*/jsxs(PageRoot, {
        children: [header, t8]
      });
      $[29] = header;
      $[30] = t8;
      $[31] = t9;
    } else {
      t9 = $[31];
    }
    return t9;
  }
  if (itemData.kind === "loading" || draftData.kind === "loading" || mapData.kind === "loading") {
    const t8 = `Loading ${singletonConfig.label}`;
    let t9;
    if ($[32] !== t8) {
      t9 = /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Flex, {
          alignItems: "center",
          justifyContent: "center",
          minHeight: "scale.3000",
          children: /*#__PURE__*/jsx(ProgressCircle, {
            "aria-label": t8,
            isIndeterminate: true,
            size: "large"
          })
        })
      });
      $[32] = t8;
      $[33] = t9;
    } else {
      t9 = $[33];
    }
    let t10;
    if ($[34] !== header || $[35] !== t9) {
      t10 = /*#__PURE__*/jsxs(PageRoot, {
        children: [header, t9]
      });
      $[34] = header;
      $[35] = t9;
      $[36] = t10;
    } else {
      t10 = $[36];
    }
    return t10;
  }
  if (mapData.data) {
    const t8 = itemData.data === "not-found" ? null : itemData.data.initialState;
    let t9;
    if ($[37] !== itemData.data) {
      t9 = itemData.data === "not-found" ? [] : itemData.data.initialFiles;
      $[37] = itemData.data;
      $[38] = t9;
    } else {
      t9 = $[38];
    }
    const t10 = itemData.data === "not-found" ? undefined : itemData.data.localTreeKey;
    let t11;
    if ($[39] !== props.singleton || $[40] !== props.config || $[41] !== t8 || $[42] !== t9 || $[43] !== t10 || $[44] !== mapData.data) {
      t11 = /*#__PURE__*/jsx(CollabSingletonPage, {
        singleton: props.singleton,
        config: props.config,
        initialState: t8,
        initialFiles: t9,
        localTreeKey: t10,
        map: mapData.data
      });
      $[39] = props.singleton;
      $[40] = props.config;
      $[41] = t8;
      $[42] = t9;
      $[43] = t10;
      $[44] = mapData.data;
      $[45] = t11;
    } else {
      t11 = $[45];
    }
    return t11;
  }
  const t8 = itemData.data === "not-found" ? null : itemData.data.initialState;
  let t9;
  if ($[46] !== itemData.data) {
    t9 = itemData.data === "not-found" ? [] : itemData.data.initialFiles;
    $[46] = itemData.data;
    $[47] = t9;
  } else {
    t9 = $[47];
  }
  const t10 = itemData.data === "not-found" ? undefined : itemData.data.localTreeKey;
  const t11 = draftData.kind === "loaded" ? draftData.data : undefined;
  let t12;
  if ($[48] !== props.singleton || $[49] !== props.config || $[50] !== t8 || $[51] !== t9 || $[52] !== t10 || $[53] !== t11) {
    t12 = /*#__PURE__*/jsx(LocalSingletonPage, {
      singleton: props.singleton,
      config: props.config,
      initialState: t8,
      initialFiles: t9,
      localTreeKey: t10,
      draft: t11
    });
    $[48] = props.singleton;
    $[49] = props.config;
    $[50] = t8;
    $[51] = t9;
    $[52] = t10;
    $[53] = t11;
    $[54] = t12;
  } else {
    t12 = $[54];
  }
  return t12;
}

function CreatedGitHubApp(props) {
  const $ = c(11);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = /*#__PURE__*/jsx(Heading, {
      children: "You've installed Keystatic! \uD83C\uDF89"
    });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /*#__PURE__*/jsx(Text, {
      children: "To start using Keystatic, you need to install the GitHub app you've created."
    });
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== props.config.storage.repo) {
    t2 = serializeRepoConfig(props.config.storage.repo);
    $[2] = props.config.storage.repo;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== t2) {
    t3 = /*#__PURE__*/jsxs(Text, {
      children: ["Make sure to add the App to the", " ", /*#__PURE__*/jsx("code", {
        children: t2
      }), " ", "repository."]
    });
    $[4] = t2;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== props.config) {
    t4 = /*#__PURE__*/jsx(InstallGitHubApp, {
      config: props.config
    });
    $[6] = props.config;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t3 || $[9] !== t4) {
    t5 = /*#__PURE__*/jsx(Flex, {
      alignItems: "center",
      justifyContent: "center",
      margin: "xxlarge",
      children: /*#__PURE__*/jsxs(Flex, {
        backgroundColor: "surface",
        padding: "large",
        border: "color.alias.borderIdle",
        borderRadius: "medium",
        direction: "column",
        justifyContent: "center",
        gap: "xlarge",
        maxWidth: "scale.4600",
        children: [t0, t1, t3, t4]
      })
    });
    $[8] = t3;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}

function KeystaticSetup(props) {
  const $ = c(22);
  const [deployedURL, setDeployedURL] = useState("");
  const [organization, setOrganization] = useState("");
  const t0 = `https://github.com${organization ? `/organizations/${organization}` : ""}/settings/apps/new`;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /*#__PURE__*/jsx(Flex, {
      justifyContent: "center",
      children: /*#__PURE__*/jsx(Heading, {
        children: "Keystatic Setup"
      })
    });
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = /*#__PURE__*/jsx(Text, {
      children: "Keystatic doesn't have the required config."
    });
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /*#__PURE__*/jsx(Text, {
      children: "If you've already created your GitHub app, make sure to add the following environment variables:"
    });
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  let t4;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = /*#__PURE__*/jsxs(Box, {
      elementType: "ul",
      children: [/*#__PURE__*/jsx("li", {
        children: /*#__PURE__*/jsx("code", {
          children: "KEYSTATIC_GITHUB_CLIENT_ID"
        })
      }), /*#__PURE__*/jsx("li", {
        children: /*#__PURE__*/jsx("code", {
          children: "KEYSTATIC_GITHUB_CLIENT_SECRET"
        })
      }), /*#__PURE__*/jsx("li", {
        children: /*#__PURE__*/jsx("code", {
          children: "KEYSTATIC_SECRET"
        })
      })]
    });
    $[3] = t4;
  } else {
    t4 = $[3];
  }
  let t5;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = /*#__PURE__*/jsx(Text, {
      children: "If you haven't created your GitHub app for Keystatic, you can create one below."
    });
    $[4] = t5;
  } else {
    t5 = $[4];
  }
  let t6;
  if ($[5] !== deployedURL) {
    t6 = /*#__PURE__*/jsx(TextField, {
      label: "Deployed App URL",
      description: "This should the root of your domain. If you're not sure where Keystatic will be deployed, leave this blank and you can update the GitHub app later.",
      value: deployedURL,
      onChange: setDeployedURL
    });
    $[5] = deployedURL;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  let t7;
  if ($[7] !== organization) {
    t7 = /*#__PURE__*/jsx(TextField, {
      label: "GitHub organization (if any)",
      description: "You must be an owner or GitHub App manager in the organization to create the GitHub App. Leave this blank to create the app in your personal account.",
      value: organization,
      onChange: setOrganization
    });
    $[7] = organization;
    $[8] = t7;
  } else {
    t7 = $[8];
  }
  let t8;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = /*#__PURE__*/jsxs(Text, {
      children: ["After visiting GitHub to create the GitHub app, you'll be redirected back here and secrets generated from GitHub will be written to your", " ", /*#__PURE__*/jsx("code", {
        children: ".env"
      }), " file."]
    });
    $[9] = t8;
  } else {
    t8 = $[9];
  }
  let t9;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = css({
      display: "none"
    });
    $[10] = t9;
  } else {
    t9 = $[10];
  }
  let t10;
  if ($[11] !== props.config.storage.repo || $[12] !== deployedURL) {
    t10 = JSON.stringify({
      name: `${parseRepoConfig(props.config.storage.repo).owner} Keystatic`,
      url: deployedURL ? `${deployedURL}/keystatic` : `${window.location.origin}/keystatic`,
      public: true,
      redirect_url: `${window.location.origin}/api/keystatic/github/created-app`,
      callback_urls: [`${window.location.origin}/api/keystatic/github/oauth/callback`, `http://127.0.0.1/api/keystatic/github/oauth/callback`, ...(deployedURL ? [`${deployedURL}/api/keystatic/github/oauth/callback`] : [])],
      request_oauth_on_install: true,
      default_permissions: {
        contents: "write",
        metadata: "read",
        pull_requests: "read"
      }
    });
    $[11] = props.config.storage.repo;
    $[12] = deployedURL;
    $[13] = t10;
  } else {
    t10 = $[13];
  }
  let t11;
  if ($[14] !== t10) {
    t11 = /*#__PURE__*/jsx("input", {
      type: "text",
      name: "manifest",
      className: t9,
      value: t10
    });
    $[14] = t10;
    $[15] = t11;
  } else {
    t11 = $[15];
  }
  let t12;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = /*#__PURE__*/jsx(Button, {
      prominence: "high",
      type: "submit",
      children: "Create GitHub App"
    });
    $[16] = t12;
  } else {
    t12 = $[16];
  }
  let t13;
  if ($[17] !== t0 || $[18] !== t6 || $[19] !== t7 || $[20] !== t11) {
    t13 = /*#__PURE__*/jsx(Flex, {
      alignItems: "center",
      justifyContent: "center",
      margin: "xxlarge",
      children: /*#__PURE__*/jsxs(Flex, {
        backgroundColor: "surface",
        padding: "large",
        border: "color.alias.borderIdle",
        borderRadius: "medium",
        direction: "column",
        justifyContent: "center",
        gap: "xlarge",
        maxWidth: "scale.4600",
        elementType: "form",
        action: t0,
        method: "post",
        children: [t1, t2, t3, t4, t5, t6, t7, t8, t11, t12]
      })
    });
    $[17] = t0;
    $[18] = t6;
    $[19] = t7;
    $[20] = t11;
    $[21] = t13;
  } else {
    t13 = $[21];
  }
  return t13;
}

function RepoNotFound(props) {
  const $ = c(11);
  let t0;
  if ($[0] !== props.config.storage.repo) {
    t0 = serializeRepoConfig(props.config.storage.repo);
    $[0] = props.config.storage.repo;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const repo = t0;
  let t1;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = /*#__PURE__*/jsx(Flex, {
      justifyContent: "center",
      children: /*#__PURE__*/jsx(Heading, {
        children: "Repo not found"
      })
    });
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const t2 = `https://github.com/${repo}`;
  let t3;
  if ($[3] !== t2 || $[4] !== repo) {
    t3 = /*#__PURE__*/jsxs(Text, {
      children: ["Keystatic is configured for the", " ", /*#__PURE__*/jsx("a", {
        href: t2,
        children: repo
      }), " GitHub repo but Keystatic isn't able to access this repo. This is either because you don't have access to this repo or you haven't added the GitHub app to it."]
    });
    $[3] = t2;
    $[4] = repo;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== props.config) {
    t4 = /*#__PURE__*/jsx(InstallGitHubApp, {
      config: props.config
    });
    $[6] = props.config;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== t3 || $[9] !== t4) {
    t5 = /*#__PURE__*/jsx(Flex, {
      alignItems: "center",
      justifyContent: "center",
      margin: "xxlarge",
      children: /*#__PURE__*/jsxs(Flex, {
        backgroundColor: "surface",
        padding: "large",
        border: "color.alias.borderIdle",
        borderRadius: "medium",
        direction: "column",
        justifyContent: "center",
        gap: "xlarge",
        maxWidth: "scale.4600",
        children: [t1, t3, t4]
      })
    });
    $[8] = t3;
    $[9] = t4;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  return t5;
}

const storedStateSchema = s.object({
  state: s.string(),
  from: s.string(),
  code_verifier: s.string()
});
const tokenResponseSchema = s.type({
  access_token: s.string(),
  token_type: s.string(),
  expires_in: s.number()
});
function KeystaticCloudAuthCallback({
  config
}) {
  var _config$cloud2;
  const router = useRouter();
  const url = new URL(window.location.href);
  const code = url.searchParams.get('code');
  const state = url.searchParams.get('state');
  const storedState_0 = useMemo(() => {
    const _storedState = localStorage.getItem('keystatic-cloud-state');
    const storedState = (() => {
      try {
        return storedStateSchema.create(JSON.parse(_storedState || ''));
      } catch {
        return null;
      }
    })();
    return storedState;
  }, []);
  const [error, setError] = useState(null);
  useEffect(() => {
    var _config$cloud;
    if (code && state && storedState_0 && (_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
      const {
        project
      } = config.cloud;
      (async () => {
        const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/oauth/token`, {
          method: 'POST',
          body: new URLSearchParams({
            code,
            client_id: project,
            redirect_uri: `${window.location.origin}/keystatic/cloud/oauth/callback`,
            code_verifier: storedState_0.code_verifier,
            grant_type: 'authorization_code'
          }).toString(),
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...KEYSTATIC_CLOUD_HEADERS
          }
        });
        if (!res.ok) {
          throw new Error(`Bad response: ${res.status} ${res.statusText}\n\n${await res.text()}`);
        }
        const data = await res.json();
        const parsed = tokenResponseSchema.create(data);
        localStorage.setItem('keystatic-cloud-access-token', JSON.stringify({
          token: parsed.access_token,
          project,
          validUntil: Date.now() + parsed.expires_in * 1000
        }));
        router.push(`/keystatic/${storedState_0.from}`);
      })().catch(error_0 => {
        setError(error_0);
      });
    }
  }, [code, state, router, storedState_0, config]);
  if (!((_config$cloud2 = config.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project)) {
    return /*#__PURE__*/jsx(Text, {
      children: "Missing Keystatic Cloud config"
    });
  }
  if (!code || !state) {
    return /*#__PURE__*/jsx(Text, {
      children: "Missing code or state"
    });
  }
  if (!storedState_0 || state !== storedState_0.state) {
    return /*#__PURE__*/jsx(Text, {
      children: "Invalid state"
    });
  }
  if (error) {
    return /*#__PURE__*/jsx(Text, {
      children: error.message
    });
  }
  return /*#__PURE__*/jsx(Flex, {
    justifyContent: "center",
    alignItems: "center",
    height: "100vh",
    children: /*#__PURE__*/jsx(ProgressCircle, {
      size: "large",
      isIndeterminate: true,
      "aria-label": "Authenticating"
    })
  });
}

function parseParamsWithoutBranch(params) {
  if (params.length === 0) {
    return {};
  }
  if (params.length === 2 && params[0] === 'singleton') {
    return {
      singleton: params[1]
    };
  }
  if (params.length < 2 || params[0] !== 'collection') return null;
  const collection = params[1];
  if (params.length === 2) {
    return {
      collection
    };
  }
  if (params.length === 3 && params[2] === 'create') {
    return {
      collection,
      kind: 'create'
    };
  }
  if (params.length === 4 && params[2] === 'item') {
    const slug = params[3];
    return {
      collection,
      kind: 'edit',
      slug
    };
  }
  return null;
}
function RedirectToBranch(props) {
  const $ = c(6);
  const {
    push
  } = useRouter();
  const {
    data,
    error
  } = useContext(GitHubAppShellDataContext);
  let t0;
  let t1;
  if ($[0] !== error || $[1] !== props.config || $[2] !== data || $[3] !== push) {
    t0 = () => {
      var _error$response, _data$repository, _data$repository2, _error$graphQLErrors, _error$graphQLErrors2;
      if ((error === null || error === void 0 || (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
        if (props.config.storage.kind === "github") {
          window.location.href = "/api/keystatic/github/login";
        } else {
          redirectToCloudAuth("", props.config);
        }
      }
      if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && _data$repository.defaultBranchRef) {
        push(`/keystatic/branch/${encodeURIComponent(data.repository.defaultBranchRef.name)}`);
      }
      if (props.config.storage.kind === "github" && !(data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && _data$repository2.id) && (error === null || error === void 0 || (_error$graphQLErrors = error.graphQLErrors) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors[0]) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors.originalError) === null || _error$graphQLErrors === void 0 ? void 0 : _error$graphQLErrors.type) === "NOT_FOUND" || (error === null || error === void 0 || (_error$graphQLErrors2 = error.graphQLErrors) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2[0]) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2.originalError) === null || _error$graphQLErrors2 === void 0 ? void 0 : _error$graphQLErrors2.type) === "FORBIDDEN") {
        window.location.href = "/api/keystatic/github/repo-not-found";
      }
    };
    t1 = [data, error, push, props.config];
    $[0] = error;
    $[1] = props.config;
    $[2] = data;
    $[3] = push;
    $[4] = t0;
    $[5] = t1;
  } else {
    t0 = $[4];
    t1 = $[5];
  }
  useEffect(t0, t1);
  return null;
}
function PageInner(t0) {
  var _config$cloud;
  const $ = c(37);
  const {
    config
  } = t0;
  const {
    params
  } = useRouter();
  let branch = null;
  let parsedParams;
  let basePath;
  if (params.join("/") === "cloud/oauth/callback") {
    let t1;
    if ($[0] !== config) {
      t1 = /*#__PURE__*/jsx(KeystaticCloudAuthCallback, {
        config: config
      });
      $[0] = config;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    return t1;
  }
  let t1;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = x => x;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let wrapper = t1;
  if (isCloudConfig(config) || isLocalConfig(config) && (_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
    let t2;
    if ($[3] !== config) {
      t2 = element => /*#__PURE__*/jsx(CloudInfoProvider, {
        config: config,
        children: element
      });
      $[3] = config;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    wrapper = t2;
  }
  if (isGitHubConfig(config) || isCloudConfig(config)) {
    const origWrapper = wrapper;
    let t2;
    if ($[5] !== config || $[6] !== origWrapper) {
      t2 = element_0 => /*#__PURE__*/jsx(AuthWrapper, {
        config: config,
        children: /*#__PURE__*/jsx(GitHubAppShellDataProvider, {
          config: config,
          children: origWrapper(element_0)
        })
      });
      $[5] = config;
      $[6] = origWrapper;
      $[7] = t2;
    } else {
      t2 = $[7];
    }
    wrapper = t2;
    if (params.length === 0) {
      let t3;
      if ($[8] !== config) {
        t3 = /*#__PURE__*/jsx(RedirectToBranch, {
          config: config
        });
        $[8] = config;
        $[9] = t3;
      } else {
        t3 = $[9];
      }
      let t4;
      if ($[10] !== wrapper || $[11] !== t3) {
        t4 = wrapper(t3);
        $[10] = wrapper;
        $[11] = t3;
        $[12] = t4;
      } else {
        t4 = $[12];
      }
      return t4;
    }
    if (params.length === 1 && isGitHubConfig(config)) {
      if (params[0] === "setup") {
        let t3;
        if ($[13] !== config) {
          t3 = /*#__PURE__*/jsx(KeystaticSetup, {
            config: config
          });
          $[13] = config;
          $[14] = t3;
        } else {
          t3 = $[14];
        }
        return t3;
      }
      if (params[0] === "repo-not-found") {
        let t3;
        if ($[15] !== config) {
          t3 = /*#__PURE__*/jsx(RepoNotFound, {
            config: config
          });
          $[15] = config;
          $[16] = t3;
        } else {
          t3 = $[16];
        }
        return t3;
      }
      if (params[0] === "created-github-app") {
        let t3;
        if ($[17] !== config) {
          t3 = /*#__PURE__*/jsx(CreatedGitHubApp, {
            config: config
          });
          $[17] = config;
          $[18] = t3;
        } else {
          t3 = $[18];
        }
        return t3;
      }
    }
    if (params[0] !== "branch" || params.length < 2) {
      let t3;
      if ($[19] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = /*#__PURE__*/jsx(Text, {
          children: "Not found"
        });
        $[19] = t3;
      } else {
        t3 = $[19];
      }
      return t3;
    }
    branch = params[1];
    basePath = `/keystatic/branch/${encodeURIComponent(branch)}`;
    let t3;
    if ($[20] !== params) {
      t3 = parseParamsWithoutBranch(params.slice(2));
      $[20] = params;
      $[21] = t3;
    } else {
      t3 = $[21];
    }
    parsedParams = t3;
  } else {
    let t2;
    if ($[22] !== params) {
      t2 = parseParamsWithoutBranch(params);
      $[22] = params;
      $[23] = t2;
    } else {
      t2 = $[23];
    }
    parsedParams = t2;
    basePath = "/keystatic";
  }
  const t2 = branch || "";
  let t3;
  if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = /*#__PURE__*/jsx(PageRoot, {
      children: /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(EmptyState, {
          icon: fileX2Icon,
          title: "Not found",
          message: "This page could not be found."
        })
      })
    });
    $[24] = t3;
  } else {
    t3 = $[24];
  }
  let t4;
  if ($[25] !== parsedParams || $[26] !== config || $[27] !== basePath) {
    t4 = /*#__PURE__*/jsx(NotFoundBoundary, {
      fallback: t3,
      children: parsedParams === null ? /*#__PURE__*/jsx(AlwaysNotFound, {}) : parsedParams.collection ? parsedParams.kind === "create" ? /*#__PURE__*/jsx(CreateItemWrapper, {
        collection: parsedParams.collection,
        config: config,
        basePath: basePath
      }, parsedParams.collection) : parsedParams.kind === "edit" ? /*#__PURE__*/jsx(ItemPageOuterWrapper, {
        collection: parsedParams.collection,
        basePath: basePath,
        config: config,
        itemSlug: parsedParams.slug
      }, parsedParams.collection) : /*#__PURE__*/jsx(CollectionPage, {
        basePath: basePath,
        collection: parsedParams.collection,
        config: config
      }, parsedParams.collection) : parsedParams.singleton ? /*#__PURE__*/jsx(SingletonPageWrapper, {
        config: config,
        singleton: parsedParams.singleton
      }, parsedParams.singleton) : /*#__PURE__*/jsx(DashboardPage, {
        config: config,
        basePath: basePath
      })
    });
    $[25] = parsedParams;
    $[26] = config;
    $[27] = basePath;
    $[28] = t4;
  } else {
    t4 = $[28];
  }
  let t5;
  if ($[29] !== config || $[30] !== t2 || $[31] !== basePath || $[32] !== t4) {
    t5 = /*#__PURE__*/jsx(AppShell, {
      config: config,
      currentBranch: t2,
      basePath: basePath,
      children: t4
    });
    $[29] = config;
    $[30] = t2;
    $[31] = basePath;
    $[32] = t4;
    $[33] = t5;
  } else {
    t5 = $[33];
  }
  let t6;
  if ($[34] !== wrapper || $[35] !== t5) {
    t6 = wrapper(t5);
    $[34] = wrapper;
    $[35] = t5;
    $[36] = t6;
  } else {
    t6 = $[36];
  }
  return t6;
}
function AlwaysNotFound() {
  notFound();
}
function AuthWrapper(props) {
  const $ = c(13);
  const [state, setState] = useState("unknown");
  const router = useRouter();
  let t0;
  let t1;
  if ($[0] !== props.config) {
    t0 = () => {
      getAuth(props.config).then(auth => {
        if (auth) {
          setState("valid");
          return;
        }
        setState("explicit-auth");
      });
    };
    t1 = [props.config];
    $[0] = props.config;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  useEffect(t0, t1);
  if (state === "valid") {
    return props.children;
  }
  if (state === "explicit-auth") {
    if (props.config.storage.kind === "github") {
      const t2 = `/api/keystatic/github/login${router.params.length ? `?${new URLSearchParams({
        from: router.params.map(encodeURIComponent).join("/")
      })}` : ""}`;
      let t3;
      if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = /*#__PURE__*/jsx(Icon, {
          src: githubIcon
        });
        $[3] = t3;
      } else {
        t3 = $[3];
      }
      let t4;
      if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
        t4 = /*#__PURE__*/jsx(Text, {
          children: "Log in with GitHub"
        });
        $[4] = t4;
      } else {
        t4 = $[4];
      }
      let t5;
      if ($[5] !== t2) {
        t5 = /*#__PURE__*/jsx(Flex, {
          justifyContent: "center",
          alignItems: "center",
          height: "100vh",
          children: /*#__PURE__*/jsxs(Button, {
            href: t2,
            target: "_top",
            children: [t3, t4]
          })
        });
        $[5] = t2;
        $[6] = t5;
      } else {
        t5 = $[6];
      }
      return t5;
    }
    if (props.config.storage.kind === "cloud") {
      let t2;
      if ($[7] !== router.params || $[8] !== props.config) {
        t2 = () => {
          redirectToCloudAuth(router.params.map(encodeURIComponent).join("/"), props.config);
        };
        $[7] = router.params;
        $[8] = props.config;
        $[9] = t2;
      } else {
        t2 = $[9];
      }
      let t3;
      if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = /*#__PURE__*/jsx(Text, {
          children: "Log in with Keystatic Cloud"
        });
        $[10] = t3;
      } else {
        t3 = $[10];
      }
      let t4;
      if ($[11] !== t2) {
        t4 = /*#__PURE__*/jsx(Flex, {
          justifyContent: "center",
          alignItems: "center",
          height: "100vh",
          children: /*#__PURE__*/jsx(Button, {
            onPress: t2,
            children: t3
          })
        });
        $[11] = t2;
        $[12] = t4;
      } else {
        t4 = $[12];
      }
      return t4;
    }
  }
  return null;
}
function RedirectToLoopback(props) {
  const $ = c(2);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      if (window.location.hostname === "localhost") {
        window.location.href = window.location.href.replace("localhost", "127.0.0.1");
      }
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  if (window.location.hostname === "localhost") {
    return null;
  }
  return props.children;
}
function Keystatic(props) {
  const $ = c(8);
  if (props.config.storage.kind === "github") {
    assertValidRepoConfig(props.config.storage.repo);
  }
  let t0;
  if ($[0] !== props.config) {
    t0 = /*#__PURE__*/jsx(PageInner, {
      config: props.config
    });
    $[0] = props.config;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== props.config || $[3] !== t0) {
    t1 = /*#__PURE__*/jsx(RouterProvider, {
      children: /*#__PURE__*/jsx(Provider, {
        config: props.config,
        children: t0
      })
    });
    $[2] = props.config;
    $[3] = t0;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== props.appSlug || $[6] !== t1) {
    t2 = /*#__PURE__*/jsx(ClientOnly, {
      children: /*#__PURE__*/jsx(RedirectToLoopback, {
        children: /*#__PURE__*/jsx(AppSlugProvider, {
          value: props.appSlug,
          children: t1
        })
      })
    });
    $[5] = props.appSlug;
    $[6] = t1;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}
function ClientOnly(props) {
  const $ = c(2);
  const [mounted, setMounted] = useState(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      setMounted(true);
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  if (!mounted) {
    return null;
  }
  return props.children;
}

export { Keystatic };
